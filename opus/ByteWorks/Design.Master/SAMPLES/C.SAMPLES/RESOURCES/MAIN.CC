#pragma keep "main"/* --------------------------------------------------------------- *//*                                                                 *//*  MiniWord - A simple text editor                                *//*                                                                 *//*  Written by Barbara Allred and Design Master                    *//*                                                                 *//*  Copyright 1990                                                 *//*  Byte Works, Inc.                                               *//*                                                                 *//* --------------------------------------------------------------- */#include "globals.h"#include "error.h"#include "cmds1.h"#include "cmds2.h"/* Our data structures, global to main. */static int             masterID;                  /* user ID passed by loader */static long            startStopAddr;static StartStopRecord startStopRec =     /* GS/OS 5.0 1-stop load tools call */                           { 0,                       /* flags must be zero   */                             0x0080,                  /* 640 mode             */                             0,                       /* output: res file ID  */                             0L,                      /* output: dPageHandle  */                             21,                      /* we'll start 21 tools */                             0x0001, 0x0300,          /* Tool Locator         */                             0x0002, 0x0300,          /* Memory Manager       */                             0x0003, 0x0300,          /* Miscellaneous Tool   */                             0x0004, 0x0300,          /* Quick Draw II        */                             0x0006, 0x0300,          /* Event Manager        */                             0x000E, 0x0300,          /* Window Manager       */                             0x0010, 0x0300,          /* Control Manager      */                             0x000F, 0x0300,          /* Menu Manager         */                             0x0014, 0x0100,          /* LineEdit Toolset     */                             0x0015, 0x0100,          /* Dialog Manager       */                             0x0008, 0x0100,          /* Sound Manager        */                             0x0017, 0x0100,          /* Std File Operations  */                             0x0016, 0x0104,          /* Scrap Manager        */                             0x0009, 0x0100,          /* Apple Desktop Bus    */                             0x0005, 0x0100,          /* Desk Manager         */                             0x001C, 0x0100,          /* List Manager         */                             0x001B, 0x0204,          /* Font Manager         */                             0x0013, 0x0100,          /* Print Manager        */                             0x0012, 0x0206,          /* Quick Draw II Aux.   */                             0x000B, 0x0100,          /* Integer Math Toolset */                             0x0022, 0x0100 };        /* Text Edit Toolset    *//************************************************* DoQuit - Handle Quit command.************************************************/void DoQuit (int *done, int *index, int *numWindows, GrafPortPtr *currWindow){static int MyWindow (int *index, GrafPortPtr *currWindow, int numWindows);/* Loop to close all open windows. */while (MyWindow (index, currWindow, *numWindows))   DoClose (*index, *currWindow, numWindows);*done = TRUE;                                            /* set the done flag */} /* DoQuit *//************************************************* EventLoop - Get next event, then dispatch the*             appropriate routine to handle it.************************************************/void EventLoop (){/* Local subroutines that EventLoop calls. */static void HandleMenu (long menuData, int *index, int *numWindows,                        GrafPortPtr *currWindow, int *done);static void HandleSpecial (long menuData, int *index, int *numWindows,                           GrafPortPtr *currWindow);static void HandleUpdate (GrafPortPtr theWindow);static int MyWindow (int *index, GrafPortPtr *currWindow, int numWindows);/* Event codes returned by TaskMaster -- included here for your convenience.#define  inButtDwn      0x0001     button down event#define  mouseUpEvt     0x0002     button up event#define  inKey          0x0003     keystroke event#define  autoKeyEvt     0x0005     auto key event:  key held down by user#define  inUpdate       0x0006     update event#define  activateEvt    0x0008     activate event#define  switchEvt      0x0009     switch event#define  deskAccEvt     0x000A     desk accessory event#define  driverEvt      0x000B     driver event#define  app1Evt        0x000C     application 1 event#define  app2Evt        0x000D     application 2 event#define  app3Evt        0x000E     application 3 event#define  app4Evt        0x000F     application 4 event#define  wInDesk        0x0010     On Desktop#define  wInMenuBar     0x0011     On system menu bar#define  wClickCalled   0x0012     system click called#define  wInContent     0x0013     In content region#define  wInDrag        0x0014     In drag region#define  wInGrow        0x0015     In grow region, active window only#define  wInGoAway      0x0016     In go-away region, active window only#define  wInZoom        0x0017     In zoom region, active window only#define  wInInfo        0x0018     In information bar#define  wInSpecial     0x0019     Item ID selected was 250 - 255#define  wInDeskItem    0x001A     Item ID selected was 1 - 249#define  wInFrame       0x001B     in Frame, but not on anything else#define  wInactMenu     0x001C     "selection" of inactive menu item#define  wClosedNDA     0x001D     desk accessory closed#define  wCalledSysEdit 0x001E     inactive menu item selected#define  wTrackZoom     0x001F     zoom box clicked, but not selected#define  wHitFrame      0x0020     button down on frame, made active#define  wInControl     0x0021     button or keystroke in control#define  wInSysWindow   0x8000     hi bit set for system windows          */GrafPortPtr currWindow;                /* current active window               */EventRecord taskRecord;                /* used to communicate with TaskMaster */int         eventCode;                 /* returned by TaskMaster              */int         numWindows;                /* # of currently open windows         */int         index;                     /* window arrays index, active window  */int         i;done = FALSE;                                           /* we aint done yet   */for (i = 0; i < 4; i++)                                 /* no window open yet */   windowOpen [i] = noWindow;numWindows = 0;index      = 0;taskRecord.wmTaskMask = 0x001FBFFF;    /* let TaskMaster do almost everything */while (!(done)) {                       /* execute event loop 'til we're done */   /* Call TaskMaster to get next event we need to handle. */   eventCode = TaskMaster (0x076E,       /* event mask = just about everything */                           &taskRecord); /* pointer to extended task record    */   errNum = _toolErr;   if (errNum)                                          /* only error possible */       HandleError (errNum, fatalErr, stopAlertTyp);    /*   is messing up     */                                                        /*   wmTaskMask field  */   /* Window update event? */   else if (eventCode == inUpdate)       HandleUpdate ((GrafPortPtr) (taskRecord.wmTaskData));   /* Cut, copy, paste, or close command? */   else if (eventCode == wInSpecial)       HandleSpecial (taskRecord.wmTaskData, &index, &numWindows, &currWindow);   /* Did user click in close box? */   else if (eventCode == wInGoAway) {       if (MyWindow (&index, &currWindow, numWindows))           DoClose (index, currWindow, &numWindows);       }   /* Non-special command? */   else if (eventCode == wInMenuBar)       HandleMenu (taskRecord.wmTaskData, &index, &numWindows, &currWindow,                   &done);   } /* while not done */} /* EventLoop *//************************************************* HandleMenu - Handle menu selections, menu IDs*              256 ->.************************************************/void HandleMenu (long menuData, int *index, int *numWindows,                 GrafPortPtr *currWindow, int *done){static int MyWindow (int *index, GrafPortPtr *currWindow, int numWindows);int theItem;int menuNum;/* Menu item ID is in low-order word of the menuData parameter. *//* Menu ID is in the high-order word of the parameter.          */theItem = menuData;menuNum = menuData >> 16;/* Dispatch the appropriate routine, based on menu item selected. */switch (theItem) {   case aboutID:   DoAbout ();                   break;   case newID:     DoNew (index, numWindows);                   break;   case openID:    DoOpen (index, numWindows);                   break;   case saveID:    if (MyWindow (index, currWindow, *numWindows))                       DoSave (*index, *currWindow);                   break;   case saveAsID:  if (MyWindow (index, currWindow, *numWindows))                       DoSaveAs (*index, *currWindow);                   break;   case pSetUpID:  DoPSetUp ();                   break;   case printID:   if (MyWindow (index, currWindow, *numWindows))                       DoPrint (*index, *currWindow);                   break;   case quitID:    DoQuit (done, index, numWindows, currWindow);                   break;   case findID:    DoFind ();                   break;   }/* Unhighlight the menu they just pulled down. */HiliteMenu (FALSE, menuNum);} /* HandleMenu *//************************************************* HandleSpecial - Handle special menu commands,*                 menu IDs 250 - 255.************************************************/void HandleSpecial (long menuData, int *index, int *numWindows,                    GrafPortPtr *currWindow){static int MyWindow (int *index, GrafPortPtr *currWindow, int numWindows);int theItem;int menuNum;/* Menu item ID is in low-order word of the menuData parameter. *//* Menu ID is in the high-order word of the parameter.          */theItem = menuData;menuNum = menuData >> 16;/* Close command selected?  All other special items handled by TaskMaster. */if (theItem == closeID)   if (MyWindow (index, currWindow, *numWindows))       DoClose (*index, *currWindow, numWindows);/* Unhighlight the menu they just pulled down. */HiliteMenu (FALSE, menuNum);} /* HandleSpecial *//************************************************* HandleUpdate - Handle update event for active*                window.************************************************/void HandleUpdate (GrafPortPtr theWindow){BeginUpdate  (theWindow);DrawControls (theWindow);EndUpdate    (theWindow);} /* HandleUpdate *//************************************************* Init - Initialize all global variables, start*        the tools we need, create our menu bar.** Output:*      Returns true if everything started OK,*      and false otherwise.************************************************/int Init (){static void InitMenus (void);/* Initialize all global variables. */masterID = _ownerid;                  /* get user ID passed by loader         */myID     = masterID | 0x0200;         /* alter for our purposes, so we can do */                                      /*   a simple DisposeAll at the end     *//* Start the tools we need:  Use GS/OS 5.0 one-call startup mechanism. */startStopAddr = StartUpTools (masterID, refIsPointer, &startStopRec);errNum        = _toolErr;if (errNum)   return (FALSE);/* Initialize our other modules. */if (! InitCmds1 ())   return (FALSE);if (! InitCmds2 ())   return (FALSE);InitMenus ();InitCursor ();                     /* StartUpTools brings up the watch cursor */                                   /*   so change it to the arrow             */return (TRUE);} /* Init *//************************************************* InitMenus - Initialize the menu bar.************************************************/void InitMenus (void){int  i;/* Create the menu bar.  Start at the last menu, since we're inserting each *//* new menu at the front of the current menu list.                          */InsertMenu (NewMenu2 (refIsResource, (long) searchMenuID), 0);InsertMenu (NewMenu2 (refIsResource, (long) editMenuID), 0);InsertMenu (NewMenu2 (refIsResource, (long) fileMenuID), 0);InsertMenu (NewMenu2 (refIsResource, (long) appleMenuID), 0);FixAppleMenu (1);            /* add desk accessories to Apple menu            */i = FixMenuBar ();           /* compute standard sizes for menu bar and menus */                             /*   throw away returned height                  */DrawMenuBar ();} /* InitMenus *//************************************************* MyWindow - Checks if front window is one of ours.** Output:*        true if it's one of ours; false otherwise************************************************/int MyWindow (int *index, GrafPortPtr *currWindow, int numWindows){GrafPortPtr  tmp;/* First check if any windows are open. */if (! (numWindows))   return (FALSE);/* Now check if the window is one of ours:  call FrontWindow to get grafPort *//* pointer of active window, then call GetSysWFlag to see if it's a system   *//* window.                                                                   */tmp = FrontWindow ();if (GetSysWFlag (tmp))   return (FALSE);/* It's one of ours, so get index into window arrays from wRefCon field. */*index      = GetWRefCon (tmp);*currWindow = tmp;return (TRUE);} /* MyWindow *//************************************************* ShutDown - Unload the tools we started.************************************************/void ShutDown (){DisposeAll (myID);                      /* dispose of all memory we allocated */ShutDownTools (refIsPointer, startStopAddr);    /* shut down tools we started */errNum = _toolErr;if (errNum)   HandleError (errNum, fatalErr, stopAlertTyp);} /* ShutDown *//************************************************* Main program*************************************************/void main (){if (Init () )                               /* start tools, bring up menu bar */   EventLoop ();                            /* execute main event loop        */ShutDown ();                                /* unload tools                   */} /* Main */