#pragma keep "cmds2"/* --------------------------------------------------------------- *//*                                                                 *//*  Cmds2 - Handles the menu commands New, Open,                   *//*          Save, and Save as.                                     *//*                                                                 *//*  Written by Barbara Allred and Design Master                    *//*                                                                 *//*  Copyright 1990                                                 *//*  Byte Works, Inc.                                               *//*                                                                 *//* --------------------------------------------------------------- */#include "globals.h"#include "error.h"struct gsosMinOutputBuffer             /* minimally sized GS/OS output buffer */   { int  totalSize;     int  currSize;     char theText [2]; };struct smGSOSinString                             /* small GS/OS input string */   { int  currSize;     char theText [10]; };/* Our data structures, private to the Cmds2 module. *//* Window tracking information -- We're allowing only 4 windows *//* to be opened on the desktop.                                 */static int             untitledNum; /* # to assign to next untitled window    */static pString17       wName [4];   /* array of window names                  */static GSString255Ptr  thePath [4]; /* array of pathname ptrs to opened files */                                  /* Standard File Operations data structures */static SFReplyRec2  theReply;static char         openMsg [] =           /* msg to display in open file dlg */   "\pSelect file to open:";static SFTypeList2 openTypes =          /* filetypes we'll allow to open      */   { 2,                                 /* number of entries in filetype list */     0x8000,                            /* match filetype, any auxtype, allow */                                        /*   user to select these files       */     0x04,                              /* can open ASCII text files          */     0,                                 /* don't care about auxtype           */     0x8000,                            /* match filetype, any auxtype, allow */                                        /*   user to select these files       */     0xB0,                              /* can open APW source files          */     0 };                               /* don't care about auxtype           */static char saveMsg [] =                   /* msg to display in save file dlg */   "\pEnter name of file to save:";static struct smGSOSinString saveName =    /* default filename to appear in   */                                           /*   save file dialog              */   { 7,                                    /* currSize                        */     "newFile" };                      /* default name to appear SFO save dlg */                             /* Data structures for GS/OS file handling calls */                                    /* buffer for FST info, returned by GS/OS */static struct gsosMinOutputBuffer options =   { 6,                                             /* total size of buffer   */     2 };                                           /* current size of buffer */static OpenRecGS openRec =                /* open file parameter block        */   { 15,                                  /* parameter count                  */     0,                                   /* reference number                 */     NULL,                                /* pathname of file to open         */     0x0003,                              /* request read/write access        */     0,                                   /* resource number:  open data fork */     0,                                   /* file's access                    */     0,                                   /* file's filetype                  */     0L,                                  /* file's auxtype                   */     0,                                   /* file's storage type              */     0, 0, 0, 0, 0, 0, 0, 0,              /* file's create date and time      */     0, 0, 0, 0, 0, 0, 0, 0,              /* file's modification date/time    */     (ResultBuf255Ptr) &options };        /* pointer to GS/OS result buffer   */static IORecGS readRec =                         /* read file parameter block */   { 5 };                                        /* parameter count           */static IORecGS writeRec =                       /* write file parameter block */   { 5 };                                       /* parameter count            */static RefNumRecGS closeRec =                   /* close file parameter block */   { 1 };                                       /* parameter count            */static NameRecGS destroyRec =                  /* delete file parameter block */   { 1 };                                      /* parameter count             */static FileInfoRecGS getFileInfoRec =          /* getFileInfo parameter block */   { 12,                                       /* parameter count             */     NULL,                                     /* file's pathname             */     0,                                        /* file's access               */     0,                                        /* file's filetype             */     0L,                                       /* file's auxtype              */     0,                                        /* file's storage type         */     0, 0, 0, 0, 0, 0, 0, 0,                   /* file's create date/time     */     0, 0, 0, 0, 0, 0, 0, 0,                   /* file's mod. date/time       */     (ResultBuf255Ptr) &options };             /* ptr to GS/OS output buffer  */static CreateRecGS createRec =   /* create file parameter block               */   { 7,                          /* parameter count                           */     NULL,                       /* file's pathname                           */     0x00C3,                     /* file access: destroy, rename, write, read */     0x0004,                     /* filetype: ASCII file                      */     0,                          /* auxType                                   */     0x0001,                     /* storage type: standard file               */     0L,                         /* initial size of data fork is 0            */     0L };                       /* initial size of resource fork is 0        */extern void DoClose (int index, GrafPortPtr currWindow, int *numWindows);/* Close the front window, checked if it's ours before calling us. *//* These are some of the private functions, forward declared  *//* so that we can alphabetize the subroutines in this module. */static void FiniWindow (int *numWindows);/* Wraps up window creation. */static void GetOpenName (SFReplyRec2 *theReply, int index);/* Gives new window a title based on file just opened. */static int GetText (int index, TEInfoRec textInfo, LongWord *size);/* Retrieves text from Text Edit for the currently active window. */static void GetUntitledName (int index, int *untitledNum);/* Gives new window an "Untitled X" title. */static void InitWindow (int *index);/* Initializes window creation. *//************************************************* CreateWindow - Create new window on the desktop.** Output:*      true if window was created; false otherwise*************************************************/int CreateWindow (int *index, int *numWindows){/* Call Window Manager's NewWindow2 function to create new window on desktop. */windowPtr [*index] = NewWindow2 (wTitle, wRefCon, NULL, NULL, refIsResource,                                 (long) windowID, 0x800E);errNum             = _toolErr;if (errNum) {   HandleError (errNum, newWindow2Err, cautionAlertTyp);   return (FALSE);   }/* Add text edit control to window. */else {   (CtlRecHndl) (textEdHandle [*index]) = NewControl2 (windowPtr [*index],                                                       refIsResource,                                                       (long) textEditID);   errNum = _toolErr;   if (errNum) {       HandleError (errNum, memoryErr, cautionAlertTyp);       DoClose (*index, windowPtr [*index], numWindows);       return (FALSE);       }   }return (TRUE);} /* CreateWindow *//************************************************* DoNew - Handle New command.************************************************/void DoNew (int *index, int *numWindows){InitWindow (index);                          /* init. window data structures  */GetUntitledName (*index, &untitledNum);      /* create untitled window's name */if (CreateWindow (index, numWindows)) {      /* create new window on desktop  */   windowOpen [*index] = fromNew;     /* set flag that window from the New cmd */   FiniWindow (numWindows);          /* disable Open, New cmds, if necessary  */   }} /* DoNew *//************************************************* DoOpen - Handle Open command.************************************************/void DoOpen (int *index, int *numWindows){Handle           aHandle;ResultBuf255Hndl tmp;InitWindow (index);                      /* initialize window data structures *//* Make SFGetFile2 call to bring up SFO Open dialog and get filename and *//* pathname of file to open.                                             */SFGetFile2 (20,           /* upper left corner X-coord of SFGetFile2's dialog */            20,           /* upper left corner Y-coord of SFGetFile2's dialog */            refIsPointer, /* prompt is pointer to P-string                    */            &openMsg,     /* pointer to prompt                                */            NULL,         /* no filter procedure                              */            &openTypes,   /* fileTypes, auxTypes of files to open             */            &theReply);   /* GS/OS 5.0 reply record                           */errNum = _toolErr;if (errNum) {   HandleError (errNum, getFileErr, cautionAlertTyp);   return;   }if (! (theReply.good))                      /* Does user want to open a file? */   return;                                            /* Yes - get pointer to pathname  */tmp              = (ResultBuf255Hndl) theReply.pathRef;openRec.pathname = &((*tmp)->bufString);OpenGS (&openRec);                                           /* open the file */errNum = _toolErr;if (errNum) {   HandleError (errNum, openErr, cautionAlertTyp);   return;   }/* Record file's pathname - we'll need it when saving file to disk.  *//* Pass file's reference # to GS/OS read and close parameter blocks. */thePath [*index] = openRec.pathname;readRec.refNum   = openRec.refNum;closeRec.refNum  = openRec.refNum;GetOpenName (&theReply, *index);                   /* get filename to display */                                                   /*   in window's title     *//* Create new window - if unable to create, close the file and exit. */if (! (CreateWindow (index, numWindows)) ){   CloseGS (&closeRec);   return;   }/* Read the file into memory, pass its text on to TextEdit to paint into *//* window.                                                               *//* Allocate memory block to read file into.  Attributes flag is locked,  *//* can't move, don't purge, don't cross bank boundary.                   */aHandle = NewHandle (openRec.eof, myID, 0xC010, NULL);errNum  = _toolErr;if (errNum) {   HandleError (errNum, memoryErr, cautionAlertTyp);   CloseGS (&closeRec);   DoClose (*index, windowPtr [*index], numWindows);   return;   }readRec.dataBuffer   = *aHandle;                 /* dereference memory handle */readRec.requestCount = openRec.eof;              /* get # bytes to read       */ReadGS (&readRec);errNum = _toolErr;/* If unable to read the file, report the error, close the window, close the *//* file.                                                                     */if (errNum) {   HandleError (errNum, readErr, cautionAlertTyp);   DoClose (*index, windowPtr [*index], numWindows);   CloseGS (&closeRec);   return;   }/* Call Text Edit to transfer the text from the read buffer to the control. */TESetText (0x0005,                                  /* text is raw data       */           readRec.dataBuffer,                      /* pointer to data        */           readRec.transferCount,                   /* size of data           */           refIsPointer,                            /* style ref is pointer   */           0L,                                      /* not passing style info */           NULL);                                   /* use active TE control  */errNum = _toolErr;if (errNum) {   /* Only possible errs are messing up parms or propagation of memory errs */   HandleError (errNum, fatalErr, stopAlertTyp);   CloseGS (&closeRec);   DoClose (*index, windowPtr [*index], numWindows);   return;   }/* Perform clean-up:  record that window is from a disk file, check if need  *//* to disable Open & New commands, close the file, release read buffer's     *//*  memory.                                                                  */windowOpen [*index] = fromFile;FiniWindow (numWindows);CloseGS (&closeRec);DisposeHandle (aHandle);} /* DoOpen *//************************************************* DoSave - Handle Save command.************************************************/void DoSave (int index, GrafPortPtr currWindow){void DoSaveAs (int index, GrafPortPtr currWindow);CtlRecPtr tePtr;            /* ptr to active window's textEdit control record *//* Check if window from the New command; if so, execute DoSaveAs. */if (windowOpen [index] == fromNew) {   DoSaveAs (index, currWindow);   return;   }/* Check if file has changed since it was last saved to disk.  Check if the *//* dirty bit in the textEdit record has been set by Text Edit.              */tePtr = *(textEdHandle [index]);                      /* dereference TEHandle */if (! (tePtr->ctlFlag && isDirty))   return;/* Get the window's text to write to disk. */if (! (GetText (index, textInfo, &writeRec.requestCount)) )   return;/* Get file's pathname for delete, create, and open operations. */destroyRec.pathname = thePath [index];createRec.pathname  = thePath [index];openRec.pathname    = thePath [index];DestroyGS (&destroyRec);                          /* delete the old disk file */errNum = _toolErr;if (errNum) {   HandleError (errNum, deleteErr, cautionAlertTyp);   return;   }CreateGS (&createRec);                                     /* create new file */errNum = _toolErr;if (errNum) {   HandleError (errNum, createErr, cautionAlertTyp);   return;   }OpenGS (&openRec);                                       /* open the new file */errNum = _toolErr;if (errNum) {   HandleError (errNum, openErr, cautionAlertTyp);   return;   }/* Dereference buffer's handle to get pointer to data to write. */writeRec.dataBuffer = *buffer;/* Get file's reference # for write and close operations. */writeRec.refNum = openRec.refNum;closeRec.refNum = openRec.refNum;WriteGS (&writeRec);                                  /* write window to disk */errNum = _toolErr;if (errNum)   HandleError (errNum, writeErr, cautionAlertTyp);/* Clear the dirty bit after saving file. */else  tePtr->ctlFlag &= notDirty;CloseGS (&closeRec);                                   /* close the disk file */} /* DoSave *//************************************************* DoSaveAs - Handle Save as command.************************************************/void DoSaveAs (int index, GrafPortPtr currWindow){#define fileNotFound 0x0046        /* File not found error, reported by GS/OS */CtlRecPtr        tePtr;               /* pointer to textEdit control's record */ResultBuf255Hndl tmp;/* Make SFPutFile2 call to bring up SFO Save dialog and get filename and *//* pathname of file to create, open, and then write.                     */SFPutFile2 (20,              /* upper left corner X-coord of SFPutFile2's dlg */            20,              /* upper left corner Y-coord of SFPetFile2's dlg */            refIsPointer,                /* prompt is pointer to P-string     */            &saveMsg,                    /* pointer to prompt                 */            refIsPointer,                /* default name is pointer           */            &saveName,                   /* pointer to GS/OS input string     */            &theReply);                  /* pointer to GS/OS 5.0 reply record */errNum = _toolErr;if (errNum) {   HandleError (errNum, fileErr, cautionAlertTyp);   return;   }if (! (theReply.good))                      /* Does user want to open a file? */   return;/* Fill in GS/OS write parameter block fields.  Call TEGetText to get *//* the text to write to disk.                                         */if (! (GetText (index, textInfo, &writeRec.requestCount)) )   return;/* Get pathname selected by user with SFPutFile2 call, in reply record. *//* Then make GS/OS GetFileInfo call to see if file already exists.      */tmp                     = (ResultBuf255Hndl) theReply.pathRef;getFileInfoRec.pathname = &((*tmp)->bufString);GetFileInfoGS (&getFileInfoRec);errNum = _toolErr;if ((errNum) && (errNum != fileNotFound)) {   HandleError (errNum, fileErr, cautionAlertTyp);   return;   }/* If no error reported by GetFileInfo call, need to delete old *//* file before creating new file with the same pathname.        */if (! (errNum) ) {   destroyRec.pathname = getFileInfoRec.pathname;   DestroyGS (&destroyRec);   errNum = _toolErr;   if (errNum) {       HandleError (errNum, deleteErr, cautionAlertTyp);       return;       }   }/* Now create new file with pathname selected by user. */createRec.pathname = getFileInfoRec.pathname;CreateGS (&createRec);errNum = _toolErr;if (errNum) {   HandleError (errNum, createErr, cautionAlertTyp);   return;   }/* Open the file to prepare for writing window's contents to disk. */openRec.pathname = getFileInfoRec.pathname;OpenGS (&openRec);errNum = _toolErr;if (errNum) {   HandleError (errNum, openErr, cautionAlertTyp);   return;   }/* Record file's reference # returned by GS/OS in write and close *//* parameter blocks.                                              */writeRec.refNum = openRec.refNum;closeRec.refNum = openRec.refNum;/* Check if window previously belonged to another file, and if so,  *//* dispose of its old pathname handle.  Record its new path handle. */if (windowOpen [index] = fromFile)   DisposeHandle (pathHandle [index]);pathHandle [index] = (Handle) tmp;/* Dereference buffer's handle to get pointer to data to write to disk. *//* Write the window's contents to disk.                                 */writeRec.dataBuffer = *buffer;WriteGS (&writeRec);errNum = _toolErr;if (errNum) {   HandleError (errNum, writeErr, cautionAlertTyp);   CloseGS (&closeRec);   return;   }/* Clear the dirty bit after saving the file. */tePtr           = *(textEdHandle [index]);tePtr->ctlFlag &= notDirty;/* Get opened file's name to put in window' title. */GetOpenName (&theReply, index);SetWTitle (wName [index], currWindow);/* Record that window comes from a file, close the disk file, then record the *//* new pathname.                                                              */windowOpen [index] = fromFile;thePath [index]    = getFileInfoRec.pathname;CloseGS (&closeRec);} /* DoSaveAs *//************************************************* FiniWindow - Disable New and Open commands if*              this is the 4th window opened.************************************************/void FiniWindow (int *numWindows){(*numWindows)++;                               /* one more open window        */if (*numWindows == maxWindows) {               /* max # open windows reached? */   DisableMItem (openID);                      /* yes - don't let 'em open or */   DisableMItem (newID);                       /*   create another window     */   }} /* FiniWindow *//************************************************* GetOpenName - Build filename when open a file.************************************************/void GetOpenName (SFReplyRec2 *theReply, int index)/* Will dispose of filename's handle; will change window's title. */{ResultBuf255Ptr tmp;char            *namePtr;/* Use filename returned by SFO to place into window's title string.  Get    *//* length of filename; AND with 0x000F to restrict length to 15 characters.  *//* Surround the filename with blanks, then convert to a Pascal-style string. */tmp     = * ((ResultBuf255Hndl) (theReply->nameRef));namePtr = wName [index];strcpy (namePtr, " ");strncat (namePtr, tmp->bufString.text, tmp->bufString.length);strcat (namePtr, " ");strcpy (namePtr, c2pstr (namePtr));/* Dispose of filename handle since we won't need it after this. */DisposeHandle ((Handle) theReply->nameRef);} /* GetOpenName *//************************************************* GetText - Call Text Edit's TEGetText routine*           to get text to write to disk.** Output:*        true if text can be returned, false otherwise************************************************/int GetText (int index, TEInfoRec textInfo, LongWord *size){#define NotEnoughMemory 0x0201                     /* not enough memory error *//* First call Text Edit's TEGetTextInfo to determine if the current *//* TEGetText buffer is large enough to hold the window's text.      */TEGetTextInfo (&textInfo, 2, textEdHandle [index]);errNum = _toolErr;if (errNum) {   HandleError (errNum, getTextInfoErr, cautionAlertTyp);   return (FALSE);   }/* Check if current buffer is too small; if so, *//* attempt to allocate new buffer.              */if (textInfo.charCount > bufferSize)   if (MaxBlock () >= textInfo.charCount) {       DisposeHandle (buffer);       buffer = NewHandle (textInfo.charCount, myID, 0, NULL);       errNum = _toolErr;       if (errNum) {           HandleError (errNum, memoryErr, cautionAlertTyp);           return (FALSE);           }       else           bufferSize = textInfo.charCount;       }   else {                                        /* can't allocate new buffer */       HandleError (NotEnoughMemory, memoryErr, cautionAlertTyp);       return (FALSE);       }/* Call TEGetText to get window's text.  We'll pass a handle to the buffer in *//* which to store the text, and not ask for any style information.            */*size = TEGetText (0x000D, buffer, bufferSize, refIsPointer,                   NULL, textEdHandle [index]);errNum = _toolErr;if (errNum) {   HandleError (errNum, getTextErr, cautionAlertTyp);   return (FALSE);   }return (TRUE);} /* GetText *//************************************************* GetUntitledName - Create next untitled window's*                   name.************************************************/void GetUntitledName (int index, int *untitledNum){char num [6];char *namePtr;/* Convert untitled window number to a C-style string, then increment *//* untitled number.                                                   */sprintf (num, "%d", (*untitledNum)++);/* Move character representation of untitled number into the window's title. */namePtr = wName [index];strcpy (namePtr, " Untitled ");strcat (namePtr, num);strcat (namePtr, " ");strcpy (namePtr, c2pstr (namePtr));} /* GetUntitledName *//************************************************* InitCmds2 - Initialize the Cmds2 unit's data*             structures.************************************************/int InitCmds2 (){untitledNum = 1;                      /* # to assign to next untitled window  *//* Initialize SFO variables. */theReply.nameRefDesc = refIsNewHandle;   /* reference is undefined:  SFO will */theReply.pathRefDesc = refIsNewHandle;   /*   allocate and return a handle    *//* Allocate memory block for TEGetText call. */buffer = NewHandle (1024L, myID, 0, NULL);      /* don't purge, can move */errNum = _toolErr;if (errNum) {   HandleError (errNum, memoryErr, stopAlertTyp);   return (FALSE);   }bufferSize = 1024;return (TRUE);} /* InitCmds2 *//************************************************* InitWindow - Perform window initialization,*              common to both DoOpen and DoNew.************************************************/void InitWindow (int *index){/* Find empty slot in windowOpen array for this window. */*index = 0;while (windowOpen [*index] != noWindow)   (*index)++;/* Use window's RefCon to track position in window arrays. */wRefCon = *index;/* Set window's title pointer. */wTitle = wName [*index];} /* InitWindow */