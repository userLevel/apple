#pragma keep "cmds1"/* --------------------------------------------------------------- *//*                                                                 *//*  Cmds1 - Handles the menu commands About, Close,                *//*          Find, Page setup, and Print.                           *//*                                                                 *//*  Written by Barbara Allred and Design Master                    *//*                                                                 *//*  Copyright 1990                                                 *//*  Byte Works, Inc.                                               *//*                                                                 *//* --------------------------------------------------------------- */#include "globals.h"#include "error.h"/* *** GENERATED BY DESIGN MASTER, with comments by B.A. *** */char item00pointerAbt1 [] = "\p            MiniWord\r\rA simple text editor written\rby Barbara Allred and\rDesign Master\r";int item01colorsAbt1 [] =   { 0x0010,                           /* button outline color                */     0x00D0,                           /* interior color when not highlighted */     0x0070,                           /* interior color when highlighted     */     0x00E8,                           /* text color when not highlighted     */     0x00B9 };                         /* text color when highlighted         */ItemTemplate ITEM00Abt1 =                /* About's static text item template */   { 0x0064,                             /* item ID number                    */                                         /* bounding rectangle                */     4,                                  /*   v1                              */     8,                                  /*   h1                              */     72,                                 /*   v2                              */     241,                                /*   h2                              */     0x800F,                             /* type: static text + disable       */     item00pointerAbt1,                  /* desc: pointer to static text      */     sizeof (item00pointerAbt1),         /* value: length of text             */     0,                                  /* flag: default                     */     NULL };                             /* color table: none                 */ItemTemplate ITEM01Abt1 =                /* About's OK button item template   */   { 0x0001,                             /* item ID number                    */                                         /* bounding rectangle                */     89,                                 /*   v1                              */     94,                                 /*   h1                              */     102,                                /*   v2                              */     149,                                /*   h2                              */     0x000A,                             /* type: simple button               */     okTitle,                            /* desc: pointer to button's title   */     0,                                  /* value: default                    */     0x0001,                             /* flag: bold, round-cornered        */     (void *) item01colorsAbt1 };        /* color table                       */DialogTemplate aboutDlg =                      /* About dialog template       */   {                                           /* bounding rectangle          */     0x002B,                                   /*   v1                        */     0x00C4,                                   /*   h1                        */     0x009C,                                   /*   v2                        */     0x01B9,                                   /*   h2                        */     TRUE,                                     /* Visiblilty flag             */     0,                                        /* RefCon, for application use */     &ITEM00Abt1,                              /* item pointer:  message      */     &ITEM01Abt1,                              /* item pointer:  OK button    */     NULL };                                   /* null terminator             */char item00pointerSave1 [] = "\pSave changes before closing?";ItemTemplate ITEM00Save1 =                /* Save alert's message template    */   { 0x0064,                              /* item ID                          */                                          /* bounding rectangle               */     37,                                  /*   v1                             */     8,                                   /*   h1                             */     47,                                  /*   v2                             */     217,                                 /*   h2                             */     0x800F,                              /* type: static text + item disable */     item00pointerSave1,                  /* desc: pointer to text            */     sizeof (item00pointerSave1),         /* value: length of text            */     0,                                   /* flag: default                    */     NULL };                              /* color table: none                */ItemTemplate ITEM01Save1 =                /* Save alert's OK button template  */   { 1,                                   /* item ID number                   */                                          /* bounding rectangle               */     62,                                  /*   v1                             */     12,                                  /*   h1                             */     75,                                  /*   v2                             */     67,                                  /*   h2                             */     0x000A,                              /* type: simple button              */     okTitle,                             /* desc: pointer to button's title  */     0,                                   /* value: default                   */     0x0003,                              /* flag: bold, square-cornered buttn*/     NULL };                              /* color table: none                */ItemTemplate ITEM02Save1 =                /* Save alert's Cancel btn template */   { 2,                                   /* item ID number                   */                                          /* bounding rectangle               */     62,                                  /*   v1                             */     115,                                 /*   h1                             */     75,                                  /*   v2                             */     201,                                 /*   h2                             */     0x000A,                              /* type: simple button              */     cancelTitle,                         /* desc: pointer to button's title  */     0,                                   /* value: default                   */     0x0002,                              /* flag: plain, square-cornered btn */     NULL };                              /* color table: none                */AlertTemplate saveAlert =                     /* WantToSave alert template    */   {                                          /* bounding rectangle           */     0x0028,                                  /*   v1                         */     0x009C,                                  /*   h1                         */     0x007A,                                  /*   v2                         */     0x017B,                                  /*   h2                         */     2,                                       /* alert ID number              */     0x81,                                    /* stage 1: draw alert, 1 beep  */     0x81,                                    /* stage 2: draw alert, 1 beep  */     0x81,                                    /* stage 3: draw alert, 1 beep  */     0x81,                                    /* stage 4: draw alert, 1 beep  */     &ITEM00Save1,                            /* item pointer:  Save message  */     &ITEM01Save1,                            /* item pointer:  OK button     */     &ITEM02Save1,                            /* item pointer:  Cancel button */     NULL };                                  /* null terminator              *//* Our data structures, private to the Cmds1 module. */static PrRecHndl    printHandle;             /* print record handle           */static Rect         prRect;                  /* TEPaintText rect to draw into */static PrStatusRec  prStatus; /* reports info to user during spooled printing */extern void DoSave (int index, GrafPortPtr currWindow);/* Save a document to disk, where document is associated with a disk file. *//************************************************* DoAbout - Handle About command.************************************************/void DoAbout (void){GrafPortPtr theDialog;                  /* pointer to About dialog's grafPort */int         junk;                       /* item hit returned by ModalDialog   */theDialog = GetNewModalDialog (&aboutDlg);             /* create modal dialog */errNum    = _toolErr;if (errNum)   HandleError (errNum, memoryErr, cautionAlertTyp);else {                                           /* call Dialog Mgr to detect */   junk = ModalDialog (NULL);                    /*   user clicking OK button */                                                 /*   use default filter proc */   errNum = _toolErr;   if (errNum)                                  /* only error is front window */       HandleError (errNum, fatalErr, stopAlertTyp);    /*  not modal dialog! */   else       CloseDialog (theDialog);   }} /* DoAbout *//************************************************** DoClose - Handle Close command.*************************************************/void DoClose (int index, GrafPortPtr currWindow, int *numWindows){static void WantToSave (int index, GrafPortPtr currWindow);CtlRecHndl  tmp;CtlRecPtr tePtr;         /* ptr to textEdit control's record for front window */int        flag;         /* flag holding dirty bit in TE record, front window */EnableMItem (newID);                             /* can now create new window */EnableMItem (openID);                            /* can now open a file       *//* Check if they want to save data before closing window.  Dereference        *//* textEdit control's handle in order to check if the dirty bit has been set  *//* by Text Edit.  If it has, give user chance to save window before closing   *//* it.                                                                        */tePtr = * (textEdHandle [index]);if (tePtr->ctlFlag && isDirty)   WantToSave (index, currWindow);CloseWindow (currWindow);(*numWindows)--;                           /* one less window open on desktop *//* If window allocated by Open command, free memory used by it. */if (windowOpen [index] == fromFile)   DisposeHandle (pathHandle [index]);windowOpen [index] = noWindow;       /* free up slot in window tracking array */} /* DoClose *//************************************************* DoFind - Handle Find command.************************************************/void DoFind (void){}/************************************************* DoPrint - Handle Print command.************************************************/void DoPrint (int index, GrafPortPtr currWindow){#define thruPrinting 0x2209          /* err code returned by TEPaintText when */                                     /*   starting line # exceeds last line # */GrafPortPtr prPort;                               /* Print Manager's grafPort */PrRecPtr    printRecPtr;                          /* pointer to print record  */long currLine;                               /* current line # to print       */long lastLine;                               /* last line # to print          */long firstPage;                              /* first page to begin printing  */long finalPage;                              /* final page to print           */int  copies;                                 /* # copies of document to print */int  spool;                                  /* false = draft mode;           */                                             /* true = spooled printing       */int  answer;                                 /* user's response to PrJob dlg  */int  anError;                                /* true if error detected        */long tmp;answer = PrJobDialog (printHandle);         /* bring up Print Job dialog      */errNum = _toolErr;                      /* error returned by PrJobDialog? */if (errNum) {   HandleError (errNum, memoryErr, cautionAlertTyp);   return;   }if (! (answer))                                   /* want to print document? */   return;printRecPtr = *printHandle;                /* dereference print record handle *//* Set up page rectangle based on printed page size calculated by *//* Print Manager as derived from Job and Page setup dialogs.      */prRect.v1 = printRecPtr->prInfo.rPage.v1;prRect.h1 = printRecPtr->prInfo.rPage.h1;prRect.v2 = printRecPtr->prInfo.rPage.v2;prRect.h2 = printRecPtr->prInfo.rPage.h2;firstPage = printRecPtr->prJob.iFstPage;      /* get first page to print      */currLine  = (firstPage - 1) * 60;             /* calculate 1st line to print, */                                              /*   counting lines from 0, and */                                              /*   60 lines per page          */printRecPtr->prJob.iFstPage = 1; /* set page # to 1 for Print Mgr, since it   */                                 /*  counts ea. page it prints, starting at 1 */finalPage = printRecPtr->prJob.iLstPage;      /* get last page to print       */lastLine  = finalPage * 60;                   /* calculate last line to print *//* Ensure that starting page number not greater than ending page */tmp = finalPage - firstPage;if (tmp < 0)   return;printRecPtr->prJob.iLstPage = tmp + 1;        /* reset last page to print for */                                              /*  Print Mgr, relative to 1    */copies    = printRecPtr->prJob.iCopies;              /* get # copies to print */firstPage = currLine;            /* remember starting line # in case multiple */                                 /*  copies wanted and printing in draft mode *//* Determine whether printing in draft or spooled mode. */if (printRecPtr->prJob.bJDocLoop == 0)   spool = FALSE;else {   spool  = TRUE;   copies =  1;                             /* PrPicFile handles mult. copies */   }/* Ensure starting line # is in document by calling Text Edit's *//* TEGetTextInfo to get # lines in document.                    */TEGetTextInfo (&textInfo, 2, textEdHandle [index]);errNum = _toolErr;if (errNum) {   HandleError (errNum, getTextInfoErr, cautionAlertTyp);   return;   }if (currLine > textInfo.lineCount)   return;/* Call Print Manager to open the document for printing; get Print Manager's *//* printing grafPort.                                                        */anError = FALSE;/* Outer print loop, to print multiple copies in draft mode. */do {   prPort = PrOpenDoc (printHandle, NULL);   errNum = _toolErr;   if (errNum) {       HandleError (errNum, printErr, cautionAlertTyp);       anError = true;       }   else {       /* Inner print loop, to print each page in the document. */       do {           PrOpenPage (prPort, NULL);     /* init. grafPort, no scaling rect. */           errNum = _toolErr;           if (errNum) {               HandleError (errNum, printErr, cautionAlertTyp);               anError = true;               }           else {               PenNormal ();      /* set pen to standard state                */               MoveTo (0, 0);     /* move to top left corner of drawing rect. */               /* Call TEPaintText to draw text into Print Manager's grafPort.*/               currLine = TEPaintText (prPort, currLine, &prRect, 0,                                      textEdHandle [index]);               errNum   = _toolErr;               if ((errNum) && (errNum != thruPrinting)) {                   HandleError (errNum, printErr, cautionAlertTyp);                   anError = true;                   }               } /* no error from PrOpenPage */           PrClosePage (prPort);                   /* close this printed page */           errNum = _toolErr;           if ((errNum) && (! (anError))) {               HandleError (errNum, printErr, cautionAlertTyp);               anError = true;               }           }                                        /* end page-printing loop */       while ((currLine != -1) && (currLine <= lastLine) && (! (anError)));     } /* no error from PrOpenDoc */   PrCloseDoc (prPort);                        /* close document for printing */   errNum = _toolErr;   if ((errNum) && (! (anError))) {       HandleError (errNum, printErr, cautionAlertTyp);       anError = true;       }   copies--;                                        /* one less copy to print */   currLine = firstPage;                            /* reset for next copy    */   }while ((copies > 0) && (! (anError)));               /* end print copies loop *//* Handle spooled printing. */if ((spool) && (! (anError))) {   PrPicFile (printHandle, NULL, &prStatus);    /* let Print Mgr allocate new */                                                /*   grafPort for printing    */   errNum = _toolErr;   if (errNum)       HandleError (errNum, printErr, cautionAlertTyp);   }SetPort (currWindow);                            /* restore window's grafPort */} /* DoPrint *//************************************************* DoPSetUp - Handle Page setUp command.************************************************/void DoPSetUp (void){int junk;/* Bring up Page Setup dialog; throw away result since Print Manager handles  *//* everything for us.                                                         */junk   = PrStlDialog (printHandle);errNum = _toolErr;if (errNum)   HandleError (errNum, memoryErr, cautionAlertTyp);} /* DoPSetUp *//************************************************* InitCmds1 - Initialize the Cmds1 unit's data*             structures.************************************************/int InitCmds1 (void){/* Create print record.  First allocate memory to obtain handle to record, *//* then call the Print Manager to initialize it.  Attributes are locked,   *//* don't purge, don't move.                                                */printHandle = (PrRecHndl) (NewHandle (140L, myID, 0xC010, NULL));errNum      = _toolErr;if (errNum) {   HandleError (errNum, memoryErr, stopAlertTyp);   return (FALSE);   }PrDefault (printHandle);errNum = _toolErr;if (errNum) {   HandleError (errNum, fatalPrintErr, stopAlertTyp);   return (FALSE);   }return (TRUE);} /* InitCmds1 *//************************************************* WantToSave - Ask user if they'd like to save*              a file before closing its window.************************************************/static void WantToSave (int index, GrafPortPtr currWindow){/* Bring up want-to-save alert.  If user selects OK button, call DoSave to *//* save the window to disk.                                                */if ( (NoteAlert (&saveAlert, NULL)) == 1 )   DoSave (index, currWindow);} /* WantToSave */