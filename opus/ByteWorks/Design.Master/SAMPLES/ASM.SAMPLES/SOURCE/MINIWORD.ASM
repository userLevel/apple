         keep  miniword         mload miniword.macros************************************************** MiniWord - A simple text editor** Written by Barbara Allred and Design Master** Copyright 1990 by Byte Works, Inc.**************************************************MiniWord start         using MWData         phk                            ensure code and data in same bank         plb         jsr   Init                     start tools, bring up menu bar         jsr   EventLoop                execute main event loop         jsr   ShutDown                 unload tools         Quit  quitRec                  make ProDOS 16 quit call, instead of RTL         end**************************************************  MWData - Common data area for MiniWord*************************************************MWData   data;;  Event codes returned by TaskMaster;inButtDwn      GEQU   $0001             ; button down eventmouseUpEvt     GEQU   $0002             ; button up eventinKey          GEQU   $0003             ; keystroke eventautoKeyEvt     GEQU   $0005             ; auto key event:  key held down by userinUpdate       GEQU   $0006             ; update eventactivateEvt    GEQU   $0008             ; activate eventswitchEvt      GEQU   $0009             ; switch eventdeskAccEvt     GEQU   $000A             ; desk accessory eventdriverEvt      GEQU   $000B             ; driver eventapp1Evt        GEQU   $000C             ; application 1 eventapp2Evt        GEQU   $000D             ; application 2 eventapp3Evt        GEQU   $000E             ; application 3 eventapp4Evt        GEQU   $000F             ; application 4 eventwInDesk        GEQU   $0010             ; On DesktopwInMenuBar     GEQU   $0011             ; On system menu barwClickCalled   GEQU   $0012             ; system click calledwInContent     GEQU   $0013             ; In content regionwInDrag        GEQU   $0014             ; In drag regionwInGrow        GEQU   $0015             ; In grow region, active window onlywInGoAway      GEQU   $0016             ; In go-away region, active window onlywInZoom        GEQU   $0017             ; In zoom region, active window onlywInInfo        GEQU   $0018             ; In information barwInSpecial     GEQU   $0019             ; Item ID selected was 250 - 255wInDeskItem    GEQU   $001A             ; Item ID selected was 1 - 249wInFrame       GEQU   $001B             ; in Frame, but not on anything elsewInactMenu     GEQU   $001C             ; "selection" of inactive menu itemwClosedNDA     GEQU   $001D             ; desk accessory closedwCalledSysEdit GEQU   $001E             ; inactive menu item selectedwTrackZoom     GEQU   $001F             ; zoom box clicked, but not selectedwHitFrame      GEQU   $0020             ; button down on frame, made activewInControl     GEQU   $0021             ; button or keystroke in controlwInSysWindow   GEQU   $8000             ; hi bit set for system windows;;  Error numbers.;err1           equ    0                 Unable to load tools.  Aborting...err2           equ    1                 Out of memory.  Aborting...err3           equ    2                 Fatal error reported by Print Manager.err4           equ    3                 Out of memory.  Can't do operation.err5           equ    4                 Error from GS/OS when opening file.err6           equ    5                 Error from GS/OS when reading file.err7           equ    6                 Error during printing.  Can't print.err8           equ    7                 Error from GS/OS when writing file.err9           equ    8                 Error when accessing file.err10          equ    9                 Error from GS/OS when creating file.err11          equ    10                Error from GS/OS when deleting file.err12          equ    11                Error from TEGetText call.err13          equ    12                Error from SFGetFile call.err14          equ    13                Error from TEGetTextInfo call.;;   Alert types.;stdAlert       equ    1stopAlert      equ    2noteAlert      equ    3cautionAlert   equ    4;;  Global variables.;;                                       Direct page variables;offset2        gequ    0                index into 2-byte window arraysoffset4        gequ    2                index into 4-byte window arrayscurrWindow     gequ    4                front window's grafPort pointerhandle         gequ    8                "generic" handleptr            gequ    12               "generic" pointersptr2           gequ    16ptr3           gequ    20count          gequ    24               "generic" counterdirtyOffset    equ     16               offset to dirty flag in text edit recordisDirty        equ     $0040            mask to check dirty bit;;                                       Non-direct page variables;masterID       ds  2                    user ID passed by loadermyID           ds  2                    MiniWord's user IDdone           dc  i2'0'                done flag - set if user selects QuitmenuHandle     ds  4                    "generic" menu handleprHandle       ds  4                    print record handlebuffer         ds  4                    buffer to hold text returned by TEGetTextbufferSize     ds  4                    size of this bufferprRect         ds  8                    TEPaintText rect to draw intoblankAddr      dc  a4'blanks'           blanks to clear window title namesblanks         dc  i1'17'               dc  c'                 'untitledNum    dc  i2'1'                # to assign to next untitled window;;  Error messages.;msg1     dc    i1'44'         dc    c'Unable to load tools.  Aborting MiniWord.   'msg2     dc    i1'44'         dc    c'Out of memory.  Aborting MiniWord.          'msg3     dc    i1'44'         dc    c'Fatal error reported by Print Manager.      'msg4     dc    i1'44'         dc    c'Out of memory.  Unable to perform operation.'msg5     dc    i1'44'         dc    c'Error returned by GS/OS when opening file.  'msg6     dc    i1'44'         dc    c'Error returned by GS/OS when reading file.  'msg7     dc    i1'44'         dc    c'Error:  Aborting printing.                  'msg8     dc    i1'44'         dc    c'Error returned by GS/OS when writing file.  'msg9     dc    i1'44'         dc    c'Error when accessing file.                  'msg10    dc    i1'44'         dc    c'Error returned by GS/OS when creating file. 'msg11    dc    i1'44'         dc    c'Error returned by GS/OS when deleting file. 'msg12    dc    i1'44'         dc    c'Error returned by TextEdit when reading file'msg13    dc    i1'44'         dc    c'Error returned by SFO when getting file     'msg14    dc    i1'44'         dc    c'Error returned by GetTextInfo call          ';;  SANE data structures.;                                       DecForm recorddecForm        dc  i2'1'                style is fixed               dc  i2'0'                no zeroes after decimal point;;                                       Decimal recorddecRec         ds  2                    sign field               ds  2                    exponent fielddecStr         ds  29                   P-string field; holds actual digits;;  Start/stop tools data structures;startStopAddr  dc  a4'startStopRec'startStopRec   dc  i2'0'                flags must be zerovideoMode      dc  i2'$80'              640 moderesFileID      ds  2                    output from StartUpToolsDPHandle       ds  4                    output from StartUpToolsnumTools       dc  i2'22'               we'll start 22 toolstoolArray      anop               dc  i2'$01,$0100'        Tool Locator               dc  i2'$02,$0100'        Memory Manager               dc  i2'$03,$0300'        Miscellaneous Toolset               dc  i2'$04,$0300'        Quick Draw II               dc  i2'$06,$0300'        Event Manager               dc  i2'$0E,$0300'        Window Manager               dc  i2'$10,$0300'        Control Manager               dc  i2'$0F,$0300'        Menu Manager               dc  i2'$14,$0100'        LineEdit Toolset               dc  i2'$15,$0100'        Dialog Manager               dc  i2'$08,$0100'        Sound Manager               dc  i2'$17,$0100'        Standard File Operations Toolset               dc  i2'$16,$0104'        Scrap Manager               dc  i2'$09,$0100'        Apple Desktop Bus Toolset               dc  i2'$05,$0100'        Desk Manager               dc  i2'$1C,$0100'        List Manager               dc  i2'$1B,$0204'        Font Manager               dc  i2'$13,$0100'        Print Manager               dc  i2'$12,$0206'        Quick Draw II Auxiliary               dc  i2'$0A,$0100'        SANE Toolset               dc  i2'$0B,$0100'        Integer Math Toolset               dc  i2'$22,$0100'        Text Edit Toolset;;  Extended task record;taskRec          anopwmWhat           ds  2wmMessage        ds  4wmWhen           ds  4wmWhere          ds  4wmModifiers      ds  2wmTaskData       ds  4wmTaskMask       dc  h'FFBF1F00'wmLastClickTick  ds  4wmClickCount     ds  2wmTaskData2      ds  4wmTaskData3      ds  4wmTaskData4      ds  4wmLastClickPt    anop                   this is a pointwmLCP_Y          ds  2wmLCP_X          ds  2;;  Window tracking information -- We're allowing only 4 windows to be opened;  on the desktop.;numWindows     dc  i2'0'                number of currently open windows;;  Array of open flags:  0 = not open,  1 = new,  2 = from file.;windowOpen     dc  i2'0'                window 1               dc  i2'0'                window 2               dc  i2'0'                window 3               dc  i2'0'                window 4;;  Array of pointers to window grafPorts.;windowPtr      dc  i4'0'                window 1               dc  i4'0'                window 2               dc  i4'0'                window 3               dc  i4'0'                window 4;;  Array of handles to TextEdit controls.;teHandle       dc  i4'0'                window 1               dc  i4'0'                window 2               dc  i4'0'                window 3               dc  i4'0'                window 4;;  Array of pointers to window names.;wNamePtr       dc  a4'wName1,wName2,wName3,wName4';;  Array of window names.;wName1         dc  i1'17'               dc  c'                 'wName2         dc  i1'17'               dc  c'                 'wName3         dc  i1'17'               dc  c'                 'wName4         dc  i1'17'               dc  c'                 ';;  Array of allocated pathname pointers, for opening files.;pathName       ds  4                    first open file               ds  4                    second open file               ds  4                    third open file               ds  4                    fourth open file;;  Array of allocated pathname handles, returned by SFO.;pathHandle     ds  4                    first open file               ds  4                    second open file               ds  4                    third open file               ds  4                    fourth open file;;  Standard File Operations data structures;replyRecord    anoprrGood         ds  2rrFileType     ds  2rrAuxType      ds  4rrNameVerb     dc  i2'3'                reference is undefined:  SFO will;                                         allocate and return a handlerrNameRef      ds  4                    refers to class 1 GS/OS output stringrrpathVerb     dc  i2'3'                reference is undefined:  SFO will do itrrPathRef      ds  4                    refers to class 1 GS/OS output stringopenMsg        dc  i1'20'               dc  c'Select file to open:'openTypes      dc  i2'2'                number of entries in filetype list               dc  i2'$8000'            match filetype, any auxtype, can select               dc  i2'$04'              ASCII text file               dc  i4'0'                don't care about auxtype               dc  i2'$8000'               dc  i2'$B0'              APW source file               dc  i4'0'saveMsg        dc  i1'27'               dc  c'Enter name of file to save:'saveName       dc  i2'7'                default name to appear SFO save dlg               dc  c'newFile';;  Data structures for GS/OS file handling calls.;options        dc  i2'6'                6 bytes total in options area               ds  4openRec        dc  i2'15'               pcountopenRef        ds  2                    refNumopenPath       ds  4                    pathname               dc  i2'$0003'            request read/write access               dc  i2'0'                resource number:  open data fork               ds  2                    access               ds  2                    filetype               ds  4                    auxType               ds  2                    storage type               ds  8                    create date/time               ds  8                    mod date/time               dc  i4'options'          pointer to GS/OS result bufferopenSize       ds  4                    eof:  # bytes that can be read               ds  4                    blocks used               ds  4                    resource eof               ds  4                    resource blocksreadRec        dc  i2'5'readRef        ds  2readBuffer     ds  4readRequest    ds  4transferCount  ds  4cache          dc  i2'0'closeRec       dc  i2'1'                pCountcloseRef       ds  2destroyRec     dc  i2'1'                pCountdestroyPath    ds  4                    pointer to GS/OS input stringwriteRec       dc  i2'5'                pCountwriteRef       ds  2                    file reference #writeData      ds  4                    pointer to data to writewriteRequest   ds  4                    # bytes to writewriteTransfer  ds  4                    # bytes actually written               dc  i2'0'                don't cache filegetFileInfoRec dc  i2'12'               pCountGFIPath        ds  4                    pointer to GS/OS input stringGFIInfo        ds  26                   not relevant for our purposes               dc  a4'options'          pointer to GS/OS output buffer               ds  24                   not interested in this stuffcreateRec      dc  i2'7'                pCountcreatePath     ds  4                    pointer to GS/OS input string               dc  i2'$00C3'            destroy, rename, write, read access               dc  i2'$0004'            filetype = ASCII file               dc  i4'0'                auxtype               dc  i2'$0001'            standard file               dc  i4'0'                initial size of data fork is 0               dc  i4'0'                initial size of resource fork is 0quitRec  dc    i4'0'                    let GS/OS choose the next app. to run         dc    i2'0'                    don't recall MiniWord, we load from disk;;  Print Manager's prStatusRec, used to report information to user during;  during spooled printing.;prStatusRec    anopiTotPages      ds  2                    # pages in spool fileiCurPage       ds  2                    current page # being printediTotCopies     ds  2                    # copies requestediCurCopy       ds  2                    current copy being printediTotBands      ds  2                    reservediCurBand       ds  2                    reservedfPgDirty       ds  2                    TRUE if started printing pagefImaging       ds  2                    reservedhPrint         ds  4                    print record handlepPrPort        ds  4                    pointer to grafPort being used to printhPic           ds  4                    reserved;;  textInfo record, used to find out the number of lines in a document.;textInfo       anopcharCount      ds  4                    total # characters in documentlineCount      ds  4                    total # lines in document               ds  16                   other fields not interested in         end************************************************** CreateWindow - Create new window on the desktop.**************************************************CreateWindow start         using MWData         using DMData         ph4   #0                       outer call -- NewControl2         ph4   #0                       make Window Manager's NewWindow call         ph4   #WINDOW         _NewWindow         bcc   CW1                      handle error returned by NewWindow call         plx                            pull nil off stack         plx         plx         plx         pea   err4                     err msg = "Out of memory. Can't do op."         pea   cautionAlert         jsr   HandleError         sec         rtsCW1      ldx   offset4                  get index into window pointers array         lda   1,S                      get window pointer         sta   windowPtr,X         lda   3,S         sta   windowPtr+2,X;                                       create text edit record for window         pea   0                        will push pointer to control template         ph4   #control001111         _NewControl2         bcc   Rts         plx                            throw away zero handle         plx         pea   err4                     err msg = "Out of memory. Can't do op."         pea   cautionAlert         jsr   HandleError         jsr   DoClose         sec         rtsRts      ldx   offset4                  get index into teHandle array         pla         sta   teHandle,X         pla         sta   teHandle+2,X         clc         rts         end************************************************** DoAbout - Handle About command.**************************************************DoAbout  start         using MWData         using DMData         pea   0                        room for dialog ptr         pea   0         ph4   #aboutDlg                pointer to the About dialog         _GetNewModalDialog             create the modal dialog         bcc   DA1         plx         plx         pea   err4                     err msg = "Out of memory.;                                         Unable to perform operation."         pea   cautionAlert               Use caution alert.         jsr   HandleError                Report the error.         rts                              Exit the subroutine.DA1      pea   0                        room for result         ph4   #0                       standard filter procedure         _ModalDialog                   let Dialog Manager handle events         bcc   DA2         plx                            pull item hit off stack         plx                            pull dialog pointer from stack         plx         brl   FatalErr                 only error is front window not modal dlgDA2      pla                            can throw away item hit value         _CloseDialog                   dialog pointer left on stack from;                                         GetNewModalDialog call         rts         end************************************************** DoClose - Handle Close command.**************************************************DoClose  start         using MWData         using DMData         jsr   MyWindow                 ensure it's one of our windows, and if         bcs   DC0                       so, get indices into window arrays         rtsDC0      ph2   newID                    can now create new window         _EnableMItem         ph2   openID                   can now open a file         _EnableMItem;;  Check if they want to save data before closing window.;         ldx   offset4         lda   teHandle,X               get ready to dereference text edit         sta   handle                     record's handle         lda   teHandle+2,X         sta   handle+2         lda   [handle]                 dereference the handle         sta   ptr         ldy   #2         lda   [handle],Y         sta   ptr+2         ldy   #dirtyOffset             check dirty bit in text edit record         lda   [ptr],Y         and   #isDirty         beq   DC1         jsr   WantToSave               file has changed -- ask if they want to;                                         save changesDC1      lda   currWindow+2             close the window -- they're done with it         pha         lda   currWindow         pha         _CloseWindow         dec   numWindows               one less window open;;  If window allocated by Open command, free memory used by it.;         ldx   offset2         lda   windowOpen,X         cmp   #2         beq   DC2         stz   windowOpen,X             free up slot in window tracking array         rtsDC2      stz   windowOpen,X         ldx   offset4         lda   pathHandle+2,X         pha         lda   pathHandle,X         pha         _DisposeHandle         rts         end************************************************** DoFind - Handle Find command.**************************************************DoFind   start         using MWData         rts         end************************************************** DoOpen - Handle Open command.**************************************************DoOpen   start         using MWData         jsr   InitWindow               initialize window data structures;;  Make SFGetFile2 call to bring up SFO Open dialog and get filename and;  pathname of file to open.;         pea   20                       upper left corner X-coord of SFGetFile2's dialog         pea   20                       upper left corner Y-coord of SFGetFile2's dialog         pea   0                        prompt is pointer to P-string         ph4   #openMsg                 pointer to prompt         ph4   #0                       no filter procedure         ph4   #openTypes               fileTypes, auxTypes of files to open         ph4   #replyRecord         _SFGetFile2         bcc   DO1         pea   err13                    err msg = "Error from SFGetFile2 call"         pea   cautionAlert         jsr   HandleError              report error         rtsDO1      lda   rrGood                   Does user want to open a file?         bne   DO2         rtsDO2      ldx   offset4                  get offset into pathHandle array         lda   rrPathRef         sta   pathHandle,X         sta   handle                   get ready to dereference the handle         lda   rrPathRef+2         sta   pathHandle+2,X         sta   handle+2         ldy   #2                       dereference the handle         lda   [handle],Y         sta   openPath+2         lda   [handle]                 need to skip total length byte of GS/OS         clc                              output string         adc   #2         sta   openPath         bcc   DO3         inc   openPath+2DO3      _OpenGS  openRec               open the file         bcc   DO4         pea   err5                     err msg = "Error returned when;                                         opening file."         pea   cautionAlert         jsr   HandleError         rtsDO4      ldx   offset4                  record file's pathname, will need it         lda   openPath                   when saving the file to disk         sta   pathName,X         lda   openPath+2         sta   pathName+2,X         lda   openRef                  get ready to read and then close the file         sta   readRef         sta   closeRef         jsr   GetOpenName              set filename for displaying in window's;                                         title         jsr   CreateWindow             create new window         bcc   DO5         _CloseGS  closeRec         rts;;  Read the file into memory, pass its text on to TextEdit to paint into window.;DO5      ph4   #0                       allocate memory block to read files         ph4   openSize                 read in the whole thing         ph2   myID         pea   $C010                    locked, can't move, don't purge, don't;                                         cross bank bound., don't page align         ph4   #0                       no absolute address specified         _NewHandle         bcc   DO6         plx                            throw away zero handle         plx         pea   err4                     err msg = "Out of memory. Can't do op."         pea   cautionAlert         jsr   HandleError         _CloseGS  closeRec         jsr   DoClose         rtsDO6      pla         sta   handle                   get ready to dereference the handle         pla         sta   handle+2         lda   [handle]                 dereference memory handle         sta   readBuffer         ldy   #2         lda   [handle],Y         sta   readBuffer+2         lda   openSize                 get # bytes to read         sta   readRequest         lda   openSize+2         sta   readRequest+2         _ReadGS  readRec               make the Read call         bcc   DO7         pea   err6                     err msg = "Error from GS/OS when";                                         reading file."         pea   cautionAlert         jsr   HandleError         jsr   DoClose         bra   Rts         rtsDO7      pea   $0005                    text descriptor:  text is raw data         ph4   readBuffer               pointer to data         ph4   transferCount            size of data         pea   0                        style ref is pointer         ph4   #0                       not really passing any style reference         ph4   #0                       use currently active TE control         _TESetText         bcc   DO8         brl   FatalErr                 possible errors are screwing up parms;                                         or propagation of memory errorsDO8      ldx   offset2                  set flag that window from Open cmd         lda   #2         sta   windowOpen,X         jsr   FiniWindow               check need to disable Open, New cmdsRts      _CloseGS  closeRec             close the file         ph4   readBuffer               release memory used for reading file         _DisposeHandle         rts         end************************************************** DoNew - Handle New command.**************************************************DoNew    start         using MWData         jsr   InitWindow               initialize window data structures         jsr   GetUntitledName          create untitled window's name         jsr   CreateWindow             create new window on desktop         bcs   Rts         ldx   offset2                  set flag that window from the New cmd         lda   #1         sta   windowOpen,X         jsr   FiniWindow               disable Open, New commands, if necessaryRts      rts         end************************************************** DoPrint - Handle Print command.**************************************************DoPrint  start         using MWDataprPort       gequ  30                   Print Manager's grafPortcurrLine     gequ  34                   current page # to printlastLine     gequ  38                   last page # to printcopies       gequ  42                   # copies of document to printfirstPage    gequ  44                   first page to begin printingspool        gequ  46                   0 = draft mode; 1 = spooled printingfinalPage    gequ  48                   final page to printjobOffset    equ   $0050                offset from beginning of print record;                                         to prJob subrecordrPageOffset  equ   $0008                offset from beginning of print record;                                         to rPage field in prInfo subrecord         jsr   MyWindow                 printing one of our windows?         bcs   DP1         rtsDP1      pea   0                        room for integer result         ph4   prHandle         _PrJobDialog                   bring up print job dialog         bcc   DP2         plx         pea   err4                     err msg = "Out of memory. Can't do op."         pea   cautionAlert         jsr   HandleError         rtsDP2      pla                            get dialog result         bne   DP3                      Do they want to print?         rtsDP3      lda   prHandle                 dereference print record handle         sta   handle         lda   prHandle+2         sta   handle+2         lda   [handle]         sta   ptr         ldy   #2         lda   [handle],Y         sta   ptr+2         ldy   #rPageOffset             set page rectangle size         lda   [ptr],Y                    h1         sta   prRect         iny                              v1         iny         lda   [ptr],Y         sta   prRect+2         iny                              h2         iny         lda   [ptr],Y         sta   prRect+4         iny                              v2         iny         lda   [ptr],Y         sta   prRect+6         ldy   #jobOffset               get first page # to print         lda   [ptr],Y         sta   firstPage                record this page for use later         dec   A         phy         pea   0                        multiply by 60 to get 1st line #         pea   0         pha         pea   60         _Multiply         pla         sta   currLine         pla         sta   currLine+2         ply                            set page # to 1 for Print Manager         lda   #1         sta   [ptr],Y         iny                            get last page # to print         iny         lda   [ptr],Y         sta   finalPage                record this page for use later         phy         pea   0                        multiply by 60 to get last line #         pea   0         pha         pea   60         _Multiply         pla         sta   lastLine         pla         sta   lastLine+2         ply         lda   finalPage                get final page # to pass to Print Mgr         sec         sbc   firstPage         bpl   DP3A                     ensure start page # less than end page #         rtsDP3A     inc   A         sta   [ptr],Y         iny                            get # copies to print         iny         lda   [ptr],Y         sta   copies         lda   currLine                 remember starting line # in case of         sta   firstPage                  multiple copies in draft mode         stz   spool                    assume draft printing         iny         lda   [ptr],Y         and   #$FF00                   mode is a byte value         beq   DP3B         inc   spoolDP3B     ph4   #textInfo                ensure requested line # is in document         pea   2                        all we really want are 1st 2 fields         ldx   offset4         lda   teHandle+2,X         pha         lda   teHandle,X         pha         _TEGetTextInfo         bcc   DP3C         pea   err14                    err msg = "Error from GetTextInfo call"         pea   cautionAlert         jsr   HandleError         rtsDP3C     lda   lineCount                # lines in document > 1st line to print?         cmp   currLine         bge   Top0         rts;;  Call Print Manager to open the document for printing.;Top0     pea   0                        room for long result         pea   0         ph4   prHandle                 print record handle         pea   0                        let Print Manager allocate & init.         pea   0                          new grafPort         _PrOpenDoc         bcc   DP4         plx         plx         pea   err7                     err msg = "Aborting printing."         pea   cautionAlert         jsr   HandleError         brl   DP12                     reset port and exitDP4      pla                            record Print Manager's grafPort         sta   prPort         pla         sta   prPort+2;;  Print loop.;;  Get ready to print the next page.;Top      lda   prPort+2                 Print Manager's grafPort         pha         lda   prPort         pha         pea   0                        no scaling rect.         pea   0         _PrOpenPage         bcc   DP5         pea   err7                     err msg = "Aborting printing."         pea   cautionAlert         jsr   HandleError         brl   DP9                      close the document, clean up, exitDP5      _PenNormal                     set pen to standard state         pea   0                        move to top left corner of drawing         pea   0                          rectangle         _MoveTo;;  Call TEPaintText to draw text into Print Manager's grafPort.;         pea   0                        room for long result         pea   0         lda   prPort+2                 Print Manager's printing port         pha         lda   prPort         pha         lda   currLine+2               page # to start printing         pha         lda   currLine         pha         ph4   #prRect                  pointer to rectangle defining one page         pea   0                        don't clip the last line on page         ldx   offset4                  use current TE record         lda   teHandle+2,X         pha         lda   teHandle,X         pha         _TEPaintText         bcc   DP6         cmp   #$2209                   Error = "Thru printing" ?         beq   DP6         plx         plx         pea   err7                     err msg = "Aborting printing."         pea   cautionAlert         jsr   HandleError         lda   #-1         sta   currLine         bra   DP7DP6      pla                            returns -1 when all is printed         sta   currLine         plx                            throw away high word - can't print over;                                         32,767 pagesDP7      lda   prPort+2                 close this page         pha         lda   prPort         pha         _PrClosePage         bcc   DP8         pea   err7                     err msg = "Aborting printing."         pea   cautionAlert         jsr   HandleError         bra   DP9DP8      lda   currLine                 move on to next page to print         cmp   #$FFFF                   check if we're finished printing         beq   DP9         cmp   lastLine         bgt   DP9         brl   TopDP9      lda   prPort+2                 close this document for printing         pha         lda   prPort         pha         _PrCloseDoc         bcc   DP10         pea   err7                     err msg = "Aborting printing."         pea   cautionAlert         jsr   HandleError         bra   DP12;;  Need to print multiple copies?;DP10     lda   spool                    if spooled printing, it handles the         bne   DP11                       copies         dec   copies                   print copies of this document         beq   DP12         lda   firstPage         sta   currLine         brl   Top0;;  Handle spooled printing here.;DP11     ph4   prHandle                 call PrPicFile to do spooled printing         ph4   #0                       let Print Manager alloc. new grafPort         ph4   #prStatusRec         _PrPicFile         bcc   DP12         pea   err7                     err msg = "Aborting printing."         pea   cautionAlert         jsr   HandleErrorDP12     lda   currWindow+2             restore the original grafPort         pha         lda   currWindow         pha         _SetPort         rts         end************************************************** DoPSetUp - Handle Page setUp command.**************************************************DoPSetUp start         using MWData         pea   0                        room for integer result         ph4   prHandle         _PrStlDialog                   bring up print style dialog         bcc   OK         plx         pea   err4                     err msg = "Out of memory. Can't do op."         pea   cautionAlert         jsr   HandleError         rtsOK       pla                            throw away result - Print Manager;                                         handles it all         rts         end************************************************** DoQuit - Handle Quit command.**************************************************DoQuit   start         using MWDataTop      jsr   MyWindow         bcc   Out         jsr   DoClose         bra   TopOut      inc   done                     set the done flag         rts         end************************************************** DoSave - Handle Save command.**************************************************DoSave   start         using MWDatadirtyFlag gequ 30                       flag read from text edit record         jsr   MyWindow         bcs   DS1         rtsDS1      ldx   offset2                  check if a new file - goto Save as         lda   windowOpen,X         cmp   #1         jeq   DSA0         ldx   offset4         lda   teHandle,X               need to get and change dirty flag         sta   handle                     from text edit record         lda   teHandle+2,X         sta   handle+2         lda   [handle]                 dereference handle         sta   ptr         ldy   #2         lda   [handle],Y         sta   ptr+2;;  Determine if file has changed and needs to be saved.;         ldy   #dirtyOffset             access flag containing dirty bit in         lda   [ptr],Y                   TE record         sta   dirtyFlag         and   #isDirty         bne   DS3         rts                            if not changed, no need to saveDS3      jsr   GetText         bcc   DS4         rtsDS4      ldx   offset4                  get file's pathname for delete, create,         lda   pathName,X                 and open operations         sta   openPath         sta   destroyPath         sta   createPath         lda   pathName+2,X         sta   openPath+2         sta   destroyPath+2         sta   createPath+2         _DestroyGS  destroyRec         delete the old file         bcc   DS10         pea   err11                    err msg = "Error when deleting old file"         pea   cautionAlert         jsr   HandleError         rtsDS10     _CreateGS  createRec           create new file         bcc   DS11         pea   err10                    err msg = "Error when creating file."         pea   cautionAlert         jsr   HandleError         rtsDS11     _OpenGS  openRec               open the new file         bcc   DS12         pea   err5                     err msg = "Error when opening file."         pea   cautionAlert         jsr   HandleError         rtsDS12     lda   buffer                   dereference buffer's handle to get         sta   handle                     pointer to data to write         lda   buffer+2         sta   handle+2         lda   [handle]         sta   writeData         ldy   #2         lda   [handle],Y         sta   writeData+2         lda   openRef                  get file's reference # for write and         sta   writeRef                   close operations         sta   closeRef         _WriteGS  writeRec             write window to disk         bcc   DS13         pea   err8                     err msg = "Error when writing file."         pea   cautionAlert         jsr   HandleError         bra   RtsDS13     ldy   #dirtyOffset             clear the dirty bit after saving file         lda   dirtyFlag         and   #$FFBF         sta   [ptr],YRts      _CloseGS  closeRec         rts         end         append    miniword2.asm