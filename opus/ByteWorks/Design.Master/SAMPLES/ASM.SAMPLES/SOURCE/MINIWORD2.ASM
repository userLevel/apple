************************************************** DoSaveAs - Handle Save as command.**************************************************DoSaveAs start         using MWData         using DMData         jsr   MyWindow         bcs   DSA0         rtsDSA0     entry         ldx   offset4         lda   teHandle,X               need to access dirty flag in text edit         sta   handle                   record         lda   teHandle+2,X         sta   handle+2         lda   [handle]                 dereference handle         sta   ptr         ldy   #2         lda   [handle],Y         sta   ptr+2         ldy   #dirtyOffset         lda   [ptr],Y                  get dirty flag         sta   dirtyFlag;;  Make SFPutFile2 call to bring up SFO Save dialog and get filename and;  pathname of file to create, open, and then write.;         pea   20                       upper left corner X-coord of SFGetFile2's dialog         pea   20                       upper left corner Y-coord of SFGetFile2's dialog         pea   0                        prompt is pointer to P-string         ph4   #saveMsg                 pointer to prompt         pea   0                        default name is pointer         ph4   #saveName                pointer to GS/OS input string         ph4   #replyRecord         _SFPutFile2         bcc   DSA1         pea   err9                     err msg = "Error when accessing file."         pea   cautionAlert         jsr   HandleError         rtsDSA1     lda   rrGood                   Does user want to open a file?         bne   DSA2         rts;;  Fill in GS/OS write parameter block fields.  Call TEGetText to get info.;DSA2     jsr   GetText         bcc   DSA3         rtsDSA3     lda   rrPathRef                dereference path handle         sta   handle         lda   rrPathRef+2         sta   handle+2         ldy   #2                       call GetFileInfo to see if file exists         lda   [handle],Y         sta   GFIPath+2         lda   [handle]                 skip buffer length in GS/OS output string         clc         adc   #2         sta   GFIPath         sta   destroyPath         sta   createPath         sta   openPath         ldx   offset4         sta   pathName,X         bcc   DSA9         inc   GFIPath+2DSA9     lda   GFIPath+2         sta   destroyPath+2         sta   createPath+2         sta   openPath+2         sta   pathName+2,X         _GetFileInfoGS  getFileInfoRec         bcc   DSA10                    No error - file should be deleted         cmp   #$0046                   File not found error?         beq   DSA11                    Yes - skip deletion         pea   err9                     err msg = "Error when accessing file."         pea   cautionAlert         jsr   HandleError         rtsDSA10    _DestroyGS  destroyRec         File exists -- overwrite it         bcc   DSA11         pea   err11                    err msg = "Error when deleting file."         pea   cautionAlert         jsr   HandleError         rtsDSA11    _CreateGS  createRec           File not found error -- create new one         bcc   DSA12         pea   err10                    err msg = "Error when creating file."         pea   cautionAlert         jsr   HandleError         rtsDSA12    _OpenGS  openRec               open the file         bcc   DSA13         pea   err5                     err msg = "Error when opening file."         pea   cautionAlert         jsr   HandleError         rtsDSA13    lda   openRef         sta   writeRef         sta   closeRef         ldx   offset2                  check if old file & need to release its         lda   windowOpen,X               memory handle & save new path handle         cmp   #2         bne   DSA14         ldx   offset4         lda   pathHandle+2,X         pha         lda   pathHandle,X         pha         _DisposeHandleDSA14    ldx   offset4                  save new path handle for file         lda   rrPathRef         sta   pathHandle,X         lda   rrPathRef+2         sta   pathHandle+2,X         lda   buffer                   dereference buffer's handle to get         sta   handle                     pointer to data to write         lda   buffer+2         sta   handle+2         lda   [handle]         sta   writeData         ldy   #2         lda   [handle],Y         sta   writeData+2         _WriteGS  writeRec             write window to disk         bcc   DSA15         pea   err8                     err msg = "Error when writing file"         pea   cautionAlert         jsr   HandleError         bra   RtsDSA15    ldy   #dirtyOffset             clear the dirty bit after saving file         lda   dirtyFlag         and   #$FFBF         sta   [ptr],Y         ldx   offset4                  set wTitle pointer - currently points to         lda   wNamePtr,X                 last new/opened window title         sta   wTitle         lda   wNamePtr+2,X         sta   wTitle+2         jsr   GetOpenName              get opened file's name to put in window         ph4   wTitle                   change window's title         lda   currWindow+2         pha         lda   currWindow         pha         _SetWTitle         ldx   offset2                  record that window comes from file         lda   #2         sta   windowOpen,XRts      _CloseGS  closeRec         rts         end************************************************** EventLoop - Get next event, then dispatch the*             appropriate routine to handle it.**************************************************EventLoop start         using MWDataLoop     lda   done                     check if we're finished         beq   L0         rtsL0       pea   0                        call TaskMaster         pea   $076E                    event mask = just about everything         ph4   #taskRec         _TaskMaster         bcc   L1         brl   FatalErr                 only error is screwing up wmTaskMask;                                         bitsL1       pla         beq   L0         cmp   #inUpdate                handle window update events         bne   L2         jsr   HandleUpdate         bra   L0L2       cmp   #wInSpecial         bne   L3         jsr   HandleSpecial         bra   L0L3       cmp   #wInGoAway         bne   L4         jsr   DoClose         bra   L0L4       cmp   #wInMenuBar         bne   Loop         jsr   HandleMenu         bra   Loop         end************************************************** FatalErr - Handle a fatal error.**************************************************FatalErr start         using MWData         pea   0         pea   0         _SysFailMgr         end************************************************** FiniWindow - Disable New and Open commands if*              this is the 4th window opened.**************************************************FiniWindow start         using MWData         using DMData         inc   numWindows               one more open window         lda   numWindows         cmp   #4         bne   Rts         ph2   newID                    can't allow creation of new window         _DisableMItem         ph2   openID                   or opening of a file         _DisableMItemRts      rts         end************************************************** GetOpenName - Build filename when open a file.**************************************************GetOpenName start         using MWData         using DMData         lda   rrNameRef                get filename returned by SFO         sta   handle                   get ready to dereference the handle         lda   rrNameRef+2         sta   handle+2         ldx   blankAddr                clear window name before getting new         ldy   wTitle                     name to store         lda   #17         mvn   blankAddr,wTitle         ldy   #2                       get filename to display in windo's         lda   [handle],Y                 title bar -- dereference the handle         sta   ptr3+2                     and move beyond initial length words         lda   [handle]                   of GS/OS output string         clc         adc   #2         sta   ptr3         bcc   GON1         inc   ptr3+2GON1     lda   [ptr3]                   get length of filename         and   #$000F                   we're restricting these names to 15 chars         pha                            save the size for now         lda   ptr3                      final adjustment to filename pointer --         clc                              move beyond its length word         adc   #2         sta   ptr3         bcc   GON2         inc   ptr3+2GON2     lda   wTitle+2                 move filename passed by SFO to wTitle+2         sta   ptr2+2         lda   wTitle         clc         adc   #2         sta   ptr2         bcc   GON3         inc   ptr2+2GON3     ldy   #0         plx         short MTop      lda   [ptr3],Y         sta   [ptr2],Y         iny         dex         bne   Top         long  M         ph4   rrNameRef                we don't need this handle anymore         _DisposeHandle         rts         end************************************************** GetText - Call Text Edit's TEGetText routine*           to get text to write to disk.** Output:*        carry flag - clear if text can be*                     returned, and set otherwise*        buffer     - handle to text to write*        bufferSize - size of text to write**************************************************GetText  start         using MWDatatmp      gequ  50;; First call Text Edit's TEGetTextInfo to determine if the current buffer; is large enough to hold the text to write.;         ph4   #textInfo                pointer to textInfo record         pea   2                        all we really want are 1st 2 fields         ldx   offset4         lda   teHandle+2,X         pha         lda   teHandle,X         pha         _TEGetTextInfo         bcc   GT1         pea   err14                    err msg = "Error from GetTextInfo call"         pea   cautionAlert         jsr   HandleError         sec         rts;; Now check if the current buffer is too small; if so, attempt to allocate a; new buffer.;GT1      cmp4  bufferSize,charCount         bcc   GT1A         brl   GT4GT1A     pea   0                        room for long result         pea   0         _MaxBlock                      determine the largest block can allocate         pla         sta   tmp         pla         sta   tmp+2         cmp4  tmp,charCount            Size of text exceeds largest block?         bcs   GT2         pea   err4                     err msg = "Out of memory. Can't do op."         pea   cautionAlert         jsr   HandleError         sec         rtsGT2      pea   0                        allocate memory block for TEGetText call         pea   0         ph4   charCount                allocate needed size         ph2   myID         pea   $0000                    don't purge         pea   0                        no absolute address specified         pea   0         _NewHandle         bcc   GT3         plx         plx         pea   err4                     err msg = "Out of memory. Can't do op."         pea   cautionAlert         jsr   HandleError         sec         rtsGT3      ph4   buffer                   deallocate old buffer         _DisposeHandle         pla                            get buffer's handle         sta   buffer         pla         sta   buffer+2GT4      lda   charCount                get new buffer size         sta   bufferSize         lda   charCount+2         sta   bufferSize+2;; Call Text Edit's GetText to get handle of text to write to disk.;         pea   0                        room for long result         pea   0         pea   $000D                    will pass buffer's handle         ph4   buffer         ph4   bufferSize         pea   0                        don't care about style info         pea   0         pea   0         ldx   offset4         lda   teHandle+2,X         pha         lda   teHandle,X         pha         _TEGetText         bcc   GT5                      if error, process error         plx         plx         pea   err12                    err msg = "Error from TEGetText"         pea   cautionAlert         jsr   HandleError         sec         rtsGT5      pla                            get size of text to write to disk,         sta   writeRequest               returned by TEGetText call         pla         sta   writeRequest+2         clc         rts         end************************************************** GetUntitledName - Create next untitled window's*                   name.**************************************************GetUntitledName start         using MWData         using DMData         ph4   #decForm                 call SANE to convert integer to decimal         ph4   #untitledNum               string         ph4   #decRec         FI2Dec         bcc   GUN1         brl   FatalErrGUN1     inc   untitledNum              set # for next untitled window;;  Loop to move digits to temporary name.;         short I,M         ldy   decStr         ldx   #1Top      lda   decStr,X         sta   num,X         inx         dey         bne   Top         long  I,M;;  Now move temporary name to window names array.;         ldx   nameAddr                 source address into X         ldy   wTitle                   destination address into Y         lda   size                     # bytes to move in A         and   #$00FF                   clear high byte         mvn   nameAddr,wTitle          block move         rtsnameAddr dc    a4'size'size     dc    i1'17'         dc    c' Untitled 'num      dc    c'       '         end************************************************** HandleError - Report errors detected in*               MiniWord.** Input:*        5,S - error message #*        3,S - alert type*        A   - error number returned by tool**************************************************HandleError start         using MWData         using DMData         sta   error                    save error # returned by tool         lda   5,S                      get address of error message         asl   A         asl   A         tax         lda   errMsgPtr,X              change alert template's pointer to         sta   errMsg                     error message         lda   errMsgPtr+2,X         sta   errMsg+2         ph2   error                    convert integer error # to hex string         ph4   #errNum                  address of space for hex string         pea   4                        length of string is 4 spaces         _Int2Hex         bcc   OK         brl   FatalErr;;  Bring up alert.;OK       pea   0                        room for result         ph4   #genAlert                address of alert template         ph4   #0                       use default filter procedure         lda   3,S                      decide which type of alert to bring up         cmp   #stdAlert         bne   HE1         _Alert         bra   RtsHE1      cmp   #stopAlert         bne   HE2         inc   done                     catastrophic error has occurred         _StopAlert         bra   RtsHE2      cmp   #noteAlert         bne   HE3         _NoteAlert         bra   RtsHE3      _CautionAlertRts      pla                            only 1 item to be hit, so ignore it         lda   1,S                      clean up stack and exit         sta   5,S                      put rts at top of stack         pla                            pull extra bytes off stack         pla         rtserror     ds   2errMsgPtr dc   a4'msg1,msg2,msg3,msg4,msg5,msg6,msg7,msg8,msg9,msg10,msg11'          dc   a4'msg12,msg13,msg14'         end************************************************** HandleMenu - Handle menu selections, menu IDs*              256 ->.**************************************************HandleMenu start         using MWData         using DMData         lda   wmTaskData               get menu item ID         sec         sbc   aboutID                  get offset from 1st menu ID, the about item         asl   A                        multiply by 2 since table items are 2 bytes         tax         jsr   (table,X)                get address from table to stuff into jsr         pea   0                        need to unhighlight menu         ph2   wmTaskData+2         _HiliteMenu         rtstable    dc    a2'DoAbout'         dc    a2'DoNew'         dc    a2'DoOpen'         dc    a2'DoSave'         dc    a2'DoSaveAs'         dc    a2'DoPSetUp'         dc    a2'DoPrint'         dc    a2'DoQuit'         dc    a2'DoFind'         end************************************************** HandleSpecial - Handle special menu commands,*                 menu IDs 250 - 255.**************************************************HandleSpecial start         using MWData         using DMData         lda   wmTaskData         cmp   closeID                  Selected Close?         bne   Out                      all other special items handled by TaskMaster         jsr   DoCloseOut      pea   0                        need to unhighlight menu         ph2   wmTaskData+2         _HiliteMenu         rts         end************************************************** HandleUpdate - Handle update event for active*                window.**************************************************HandleUpdate start         using MWData         ph4   wmTaskData         _BeginUpdate         ph4   wmTaskData         _DrawControls         ph4   wmTaskData         _EndUpdate         rts         end************************************************** Init - Start the tools we need, then create*        our menu bar.**************************************************Init     start         using MWData         using DMData         sta   masterID                 get user ID passed by loader         ora   #$0200                   alter for our purposes, so we can do         sta   myID                       a simple DisposeAll at the end;; Start tools we need.;         ph4   #0                       room for return value         ph2   masterID         pea   0                        start/stop verb is pointer         ph4   startStopAddr            address of start/stop record         _StartUpTools                  use GS/OS 5.0 one-call tool start up         bcc   OK         plx         plx         brl   FatalErr                 ERROR -- pull pointer to start/stop;                                                recordOK       pla         sta   startStopAddr         pla         sta   startStopAddr+2;;  Create the menu bar.;         pea   0                        space for result         pea   0         pea   0                        ref. is pointer         ph4   #menu04                  pointer to 1st menu template         _NewMenu2         pea   0                        insert menu at front         _InsertMenu         pea   0                        space for result         pea   0         pea   0                        ref. is pointer         ph4   #menu03                  pointer to 1st menu template         _NewMenu2         pea   0                        insert menu at front         _InsertMenu         pea   0                        space for result         pea   0         pea   0                        ref. is pointer         ph4   #menu02                  pointer to 1st menu template         _NewMenu2         pea   0                        insert menu at front         _InsertMenu         pea   0                        space for result         pea   0         pea   0                        ref. is pointer         ph4   #menu01                  pointer to 1st menu template         _NewMenu2         pea   0                        insert menu at front         _InsertMenu         pea   1                        add desk accessories to Apple menu         _FixAppleMenu         pea   0                        compute standard sizes for menu bar and         _FixMenuBar                      menus         pla                            throw away returned height         _DrawMenuBar;;  Create print record.;         pea   0                        allocate memory block for print record         pea   0         ph4   #140                     record is 140 bytes long         ph2   myID         pea   $C010                    locked, don't purge, don't move         pea   0                        no absolute address specified         pea   0         _NewHandle         bcc   OK1         plx                            ERROR -- pull nil pointer from stack         plx         pea   err2                       Error msg = "Out of memory"         pea   stopAlert                  Fatal error.         jsr   HandleError                Report the error.         rtsOK1      lda   1,S                      save the print record handle         sta   prHandle         lda   3,S         sta   prHandle+2         _PrDefault                     let Print Manager initialize print record         bcc   OK2         pea   err3                       Error msg = "Fatal error reported by;                                                      Print Manager"         pea   stopAlert                  Fatal error.         jsr   HandleError                Report the error.         rts         brl   FatalErrOK2      pea   0                        allocate memory block for TEGetText call         pea   0         ph4   #1024                    allocate 2 blocks         ph2   myID         pea   $0000                    don't purge         pea   0                        no absolute address specified         pea   0         _NewHandle         bcc   OK3         plx                            ERROR -- pull nil pointer off stack         plx         pea   err2                       Error msg = "Out of memory"         pea   stopAlert                  Fatal error.         jsr   HandleError                Report the error.         rtsOK3      pla                            save buffer handle         sta   buffer         pla         sta   buffer+2         lda   #1024                    save buffer's size         sta   bufferSize         stz   bufferSize+2         _InitCursor                    StartUpTools brings up the watch cursor;                                         so change it to the arrow         ldx   #0Top      stz   windowOpen,X         inx         inx         cpx   #8         blt   Top         rts         end************************************************** InitWindow - Perform window initialization,*              common to both DoOpen and DoNew.**************************************************InitWindow start         using MWData         using DMData         ldx   #0                       track window # in array         stx   countTop      lda   windowOpen,X             loop to find empty slot in array         beq   IW1         inc   count         inx         inx         bra   TopIW1      lda   count                    count is index into window arrays         sta   wRefCon                  use window's RefCon to track position;                                         in arrays         asl   A                        calculate 2-byte offset into arrays         sta   offset2         asl   A                        calculate 4-byte offset into arrays         sta   offset4         ldx   offset4                  set wTitle pointer         lda   wNamePtr,X         sta   wTitle         lda   wNamePtr+2,X         sta   wTitle+2         rts         end************************************************** MyWindow - Checks if front window is one of ours.** Output:*        carry flag - set if its one of ours**************************************************MyWindow start         using MWData         lda   numWindows               Any windows up?         bne   MW1         clc         rts;;  Now check if the window is one of ours.;MW1      pea   0                        room for integer result - outer call         pea   0                        room for long result - inner call         pea   0         _FrontWindow                   get grafPort ptr of active window         lda   1,S                      save ptr in case it's ours         sta   currWindow         lda   3,S         sta   currWindow+2         _GetSysWFlag                   Is system window or application window?         pla         beq   MW2         clc         rts;;  It's one of ours, so calculate offsets in arrays.;MW2      pea   0         pea   0         lda   currWindow+2         pha         lda   currWindow         pha         _GetWRefCon                    get window's index into window arrays         pla         plx                            throw away high byte - we don't need it         asl   A                        get 2-byte offset into integer arrays         sta   offset2         asl   A                        get 4-byte offset into long arrays         sta   offset4         sec         rts         end************************************************** ShutDown - Unload the tools we started.**************************************************ShutDown start         using MWData         ph2   myID                     dispose of all memory we allocated         _DisposeAll         pea   0                        shut down tools started by MiniWord         ph4   startStopAddr         _ShutDownTools         bcc   Rts         brl   FatalErrRts      rts         end************************************************** WantToSave - Ask user if they'd like to save*              a file before closing its window.**************************************************WantToSave start         using MWData         using DMData;;  Bring up alert.;         pea   0                        room for result         ph4   #saveAlert               address of alert template         ph4   #0                       use default filter procedure         _NoteAlert         pla                            get item hit         cmp   #1                       do they want to save file?         bne   Rts         jsr   DoSaveRts      rts         end************************************************** DMData - Records generated by Design Master.**************************************************DMData   data;;  Generated by Design Master, with a little help from BA;menu01   anop                           ; Apple menu         dc    i2'0'                    ; version, must be 0         dc    i2'$0001'                ; menu ID number         dc    i2'$0008'                ; menu flags         dc    i4'dropmenutitle01'      ; title reference         dc    i4'menu01item00'         ; item reference:  About         dc    i4'0'                    ; null terminatordropmenutitle01  dw  '@'menu01item00  anop                      ; Apple menu's About item template         dc    i2'0'                    ; versionaboutID  dc    i2'$01F4'                ; item ID number         dc    i2'$0000'                ; shortcut characters         dc    i2'$0000'                ; mark character         dc    i2'$0041'                ; flags:  bold the item, divider beneath         dc    i4'menu01itemtitle00'    ; item title referencemenu01itemtitle00  dw  'About'menu02   anop                           ; File menu         dc    i2'0'                    ; version, must be 0         dc    i2'$0002'                ; menu ID number         dc    i2'$0008'                ; menu flags         dc    i4'dropmenutitle02'      ; title reference         dc    i4'menu02item00'         ; item reference:  New         dc    i4'menu02item01'         ; item reference:  Open         dc    i4'menu02item02'         ; item reference:  Close         dc    i4'menu02item03'         ; item reference:  Save         dc    i4'menu02item04'         ; item reference:  Save as         dc    i4'menu02item05'         ; item reference:  Page setup         dc    i4'menu02item06'         ; item reference:  Print         dc    i4'menu02item07'         ; item reference:  Quit         dc    i4'0'                    ; null terminatordropmenutitle02  dw  ' File 'menu02item00  anop                      ; File menu's New item template         dc    i2'0'                    ; versionnewID    dc    i2'$01F5'                ; item ID number         dc    i2'$6E4E'                ; shortcut characters         dc    i2'$0000'                ; mark character         dc    i2'$0000'                ; flags         dc    i4'menu02itemtitle00'    ; item title referencemenu02itemtitle00  dw  'New'menu02item01  anop                      ; File menu's Open item template         dc    i2'0'                    ; versionopenID   dc    i2'$01F6'                ; item ID number         dc    i2'$6F4F'                ; shortcut characters         dc    i2'$0000'                ; mark character         dc    i2'$0000'                ; flags         dc    i4'menu02itemtitle01'    ; item title referencemenu02itemtitle01  dw  'Open...'menu02item02  anop                      ; File menu's Close item template         dc    i2'0'                    ; versioncloseID  dc    i2'255'                  ; item ID number         dc    i2'$7757'                ; shortcut characters         dc    i2'$0000'                ; mark character         dc    i2'$0000'                ; flags         dc    i4'menu02itemtitle02'    ; item title referencemenu02itemtitle02  dw  'Close'menu02item03  anop                      ; File menu's Save item template         dc    i2'0'                    ; versionsaveID   dc    i2'$01F7'                ; item ID number         dc    i2'$7353'                ; shortcut characters         dc    i2'$0000'                ; mark character         dc    i2'$0000'                ; flags         dc    i4'menu02itemtitle03'    ; item title referencemenu02itemtitle03  dw  'Save'menu02item04  anop                      ; File menu's Save as item template         dc    i2'0'                    ; versionsaveAsID dc    i2'$01F8'                ; item ID number         dc    i2'$0000'                ; shortcut characters         dc    i2'$0000'                ; mark character         dc    i2'$0040'                ; flags:  divider beneath         dc    i4'menu02itemtitle04'    ; item title referencemenu02itemtitle04  dw  'Save as...'menu02item05  anop                      ; File menu's Page setup item template         dc    i2'0'                    ; versionpSetUpID dc    i2'$01F9'                ; item ID number         dc    i2'$0000'                ; shortcut characters         dc    i2'$0000'                ; mark character         dc    i2'$0000'                ; flags         dc    i4'menu02itemtitle05'    ; item title referencemenu02itemtitle05  dw  'Page setup...'menu02item06  anop                      ; File menu's Print item template         dc    i2'0'                    ; versionprintID  dc    i2'$01FA'                ; item ID number         dc    i2'$7050'                ; shortcut characters         dc    i2'$0000'                ; mark character         dc    i2'$0040'                ; flags:  divider beneath         dc    i4'menu02itemtitle06'    ; item title referencemenu02itemtitle06  dw  'Print'menu02item07  anop                      ; File menu's Quit item template         dc    i2'0'                    ; versionquitID   dc    i2'$01FB'                ; item ID number         dc    i2'$7151'                ; shortcut characters         dc    i2'$0000'                ; mark character         dc    i2'$0000'                ; flags         dc    i4'menu02itemtitle07'    ; item title referencemenu02itemtitle07  dw  'Quit'menu03   anop                           ; Edit menu         dc    i2'0'                    ; version, must be 0         dc    i2'$0003'                ; menu ID number         dc    i2'$0008'                ; menu flags         dc    i4'dropmenutitle03'      ; title reference         dc    i4'menu03item00'         ; item reference         dc    i4'menu03item01'         ; item reference         dc    i4'menu03item02'         ; item reference         dc    i4'0'                    ; null terminatordropmenutitle03  dw  ' Edit 'menu03item00  anop                      ; Edit menu's Cut item template         dc    i2'0'                    ; versioncutID    dc    i2'251'                  ; item ID number         dc    i2'$7858'                ; shortcut characters         dc    i2'$0000'                ; mark character         dc    i2'$0000'                ; flags         dc    i4'menu03itemtitle00'    ; item title referencemenu03itemtitle00  dw  'Cut'menu03item01  anop                      ; Edit menu's Copy item template         dc    i2'0'                    ; versioncopyID   dc    i2'252'                  ; item ID number         dc    i2'$6343'                ; shortcut characters         dc    i2'$0000'                ; mark character         dc    i2'$0000'                ; flags         dc    i4'menu03itemtitle01'    ; item title referencemenu03itemtitle01  dw  'Copy'menu03item02  anop                      ; Edit menu's Paste item template         dc    i2'0'                    ; versionpasteID  dc    i2'253'                  ; item ID number         dc    i2'$7656'                ; shortcut characters         dc    i2'$0000'                ; mark character         dc    i2'$0000'                ; flags         dc    i4'menu03itemtitle02'    ; item title referencemenu03itemtitle02  dw  'Paste'menu04   anop                           ; Search menu         dc    i2'0'                    ; version, must be 0         dc    i2'$0004'                ; menu ID number         dc    i2'$0008'                ; menu flags         dc    i4'dropmenutitle04'      ; title reference         dc    i4'menu04item00'         ; item reference         dc    i4'0'                    ; null terminatordropmenutitle04  dw  ' Search 'menu04item00  anop                      ; Search menu's Find item template         dc    i2'0'                    ; versionfindID   dc    i2'$01FC'                ; item ID number         dc    i2'$6646'                ; shortcut characters         dc    i2'$0000'                ; mark character         dc    i2'$0000'                ; flags         dc    i4'menu04itemtitle00'    ; item title referencemenu04itemtitle00  dw  'Find...'aboutDlg anop                           ; About menu item's dialog box         dc    i2'$02B,$0C4,$09C,$1B9'  ; Enclosing rectangle         dc    i2'-1'                   ; Visiblilty flag         dc    i4'0'                    ; RefCon, for application use         dc    i4'item00Abt1'           ; item pointer         dc    i4'item01Abt1'           ; item pointer         dc    i4'0'                    ; Null terminatorITEM00Abt1 anop                         ; About dialog's static text item         dc    i2'$0064'                ; Item ID number         dc    i2'004,008,072,241'      ; Bounding rectangle         dc    i2'$000F'                ; Item Type         dc    i4'item00pointerAbt1'    ; Item descriptor         dc    i2'0093'                 ; Item value         dc    i2'$0000'                ; Item bit flag         dc    i4'0'                    ; Item color tableitem00pointerAbt1 anop                  ; Descriptor for About's static text         dc    i1'093'                  ; character count         dc    c'                  MiniWord',h'0d0d'         dc    c'A simple text editor written',h'0d'         dc    c'by Barbara Allred and',h'0d'         dc    c'Design Master.'ITEM01Abt1 anop                         ; About dialog's OK button         dc    i2'$0001'                ; Item ID number         dc    i2'089,094,102,149'      ; Bounding rectangle         dc    i2'$000A'                ; Item Type         dc    i4'item01pointerAbt1'    ; Item descriptor         dc    i2'0000'                 ; Item value         dc    i2'$0001'                ; Item bit flag         dc    i4'item01colorsAbt1'     ; Item color tableitem01colorsAbt1  dc  i2'$0010,$00D0,$0070,$00E8,$00B9'         ; Colorsitem01pointerAbt1 anop                  ; OK button's descriptor         dc    i1'002'                  ; character count         dc    c'OK'WINDOW   anop                              ; Window parameter list         dc    i2'windowEnd-WINDOW'        ; parm list length         dc    i2'$C1E7'                   ; frame bitswTitle   dc    i4'0'                       ; pointer to titlewRefCon  dc    i4'0'                       ; refcon         dc    i2'$01E,$014,$03C,$064'     ; zoomed rectangle         dc    i4'windColorTable'          ; color table pointer         dc    i2'$0000'                   ; vert offset of content          dc    i2'$0000'                   ; horiz offset of content         dc    i2'$0000'                   ; data area height         dc    i2'$0000'                   ; data area width         dc    i2'$00C8'                   ; max grow height         dc    i2'$0280'                   ; max grow width         dc    i2'$0000'                   ; vert. arrow scroll amount         dc    i2'$0000'                   ; horiz arrow scroll amount         dc    i2'$0000'                   ; vert. page amount         dc    i2'$0000'                   ; horiz page amount         dc    i4'0'                       ; info bar ref con         dc    i2'000'                     ; info bar height         dc    i4'0'                       ; window definition procedure         dc    i4'0'                       ; info bar draw routine         dc    i4'0'                       ; window content draw routine         dc    i2'$01E,$014,$0C2,$25F'     ; window position rectangle         dc    i4'-1'                      ; window plane, -1 for front          dc    i4'0'                       ; memory for window, windowEnd anop  windColorTable  anop           dc    i2'$0010,$0D81,$021D,$0074,$0000'    ; Colorscontrol001111 anop                          ; TEXTEDIT          dc    i2'23'                       ; parm count         dc    i4'$000087DA'                ; ID number         dc    i2'$0002,$0002,$0000,$0000'  ; rectangle         dc    i4'$85000000'                ; Defproc            dc    i2'$0000'                    ; flags         dc    i2'$7C00'                    ; More flags         dc    i4'0'                        ; RefCon         dc    i4'$62200000'                ; TE text flags         dc    i2'$FFFF,$FFFF,$FFFF,$FFFF'  ; indent rect, standard         dc    i4'$FFFFFFFF'                ; te vert                          dc    i2'0'                        ; vert amount         dc    i4'0'                        ; MUST BE NULL version 1.0         dc    i2'0'                        ; MUST BE NULL version 1.0         dc    i4'0'                        ; style ref         dc    i2'0'                        ; text descriptor         dc    i4'0'                        ; text ref         dc    i4'$00000000'                ; text length         dc    i4'0'                        ; maximum characters         dc    i4'0'                        ; MUST BE NULL version 1.0         dc    i2'0'                        ; MUST BE NULL version 1.0         dc    i2'0'                        ; MUST BE NULL version 1.0         dc    i4'00'                       ; color table         dc    i2'$0000'                    ; drawing mode         dc    i4'0'                        ; filter procgenAlert anop                               ; ** General alert box **         dc    i2'$02A,$04C,$082,$1F9'      ; Enclosing rectangle         dc    i2'00'                       ; Alert ID number         dc    h'81'                        ; Stage byte         dc    h'81'                        ; Stage byte         dc    h'81'                        ; Stage byte         dc    h'81'                        ; Stage byte         dc    i4'item00Gen1'               ; item pointer:  Error message         dc    i4'item01Gen1'               ; item pointer:  Error number         dc    i4'item02Gen1'               ; item pointer:  OK button         dc    i4'0'                        ; null terminatorITEM00Gen1 anop                             ; Name as needed         dc    i2'$0064'                    ; Item ID number         dc    i2'030,010,045,409'          ; Bounding rectangle         dc    i2'$800F'                    ; Item TypeerrMsg   dc    i4'item00pointerGen1'        ; Item descriptor         dc    i2'0044'                     ; Item value         dc    i2'$0000'                    ; Item bit flag         dc    i4'0'                        ; Item color tableitem00pointerGen1 anop                      ; Descriptor         dc    i1'044'                      ; character count         dc    c'Message goes here.    '         dc    c'                      'ITEM01Gen1 anop                             ; Name as needed         dc    i2'$0064'                    ; Item ID number         dc    i2'050,150,065,200'          ; Bounding rectangle         dc    i2'$800F'                    ; Item Type         dc    i4'item01pointerGen1'        ; Item descriptor         dc    i2'0005'                     ; Item value         dc    i2'$0000'                    ; Item bit flag         dc    i4'0'                        ; Item color tableitem01pointerGen1 anop                      ; Descriptor         dc    i1'05'                       ; character count         dc    c'$'errNum   dc    c'0000'                      ; **ITEM02Gen1 anop                             ; Name as needed         dc    i2'$0001'                    ; Item ID number         dc    i2'070,200,085,230'          ; Bounding rectangle         dc    i2'$000A'                    ; Item Type         dc    i4'item02pointerGen1'        ; Item descriptor         dc    i2'0000'                     ; Item value         dc    i2'$0001'                    ; Item bit flag         dc    i4'0'                        ; Item color tableitem02pointerGen1 anop                      ; Descriptor         dc    i1'002'                      ; character count         dc    c'OK'saveAlert      anop                     ; WantToSave alert box         dc    i2'$028,$09C,$07A,$17B'  ; Enclosing rectangle         dc    i2'00'                   ; Alert ID number         dc    h'81'                    ; Stage byte         dc    h'81'                    ; Stage byte         dc    h'81'                    ; Stage byte         dc    h'81'                    ; Stage byte         dc    i4'item00Save'           ; item pointer:  Save message         dc    i4'item01Save'           ; item pointer:  OK button         dc    i4'item02Save'           ; item pointer:  Cancel button         dc    i4'0'                    ; null terminatorITEM00Save     anop                     ; save alert's message template         dc    i2'$0064'                ; Item ID number         dc    i2'037,008,047,217'      ; Bounding rectangle         dc    i2'$800F'                ; Item Type         dc    i4'item00pointerSave'    ; Item descriptor         dc    i2'0028'                 ; Item value         dc    i2'$0000'                ; Item bit flag         dc    i4'0'                    ; Item color tableitem00pointerSave  anop                 ; Descriptor         dc    i1'028'                  ; character count         dc    c'Save changes before closing?'ITEM01Save     anop                     ; save alert's OK button template         dc    i2'$0001'                ; Item ID number         dc    i2'062,012,075,067'      ; Bounding rectangle         dc    i2'$000A'                ; Item Type         dc    i4'item01pointerSave'    ; Item descriptor         dc    i2'0000'                 ; Item value         dc    i2'$0003'                ; Item bit flag         dc    i4'0'                    ; Item color tableitem01pointerSave  anop                 ; Descriptor         dc    i1'002'                  ; character count         dc    c'OK'ITEM02Save     anop                     ; save alert's Cancel button template         dc    i2'$0002'                ; Item ID number         dc    i2'062,115,075,201'      ; Bounding rectangle         dc    i2'$000A'                ; Item Type         dc    i4'item02pointerSave'    ; Item descriptor         dc    i2'0000'                 ; Item value         dc    i2'$0002'                ; Item bit flag         dc    i4'0'                    ; Item color tableitem02pointerSave  anop                 ; Descriptor         dc    i1'006'                  ; character count         dc    c'Cancel'         end