{$keep 'Error'}unit Error;{---------------------------------------------------------------}{                                                               }{ Error - Text editor's error handling routines.                }{                                                               }{ Written by Barbara Allred and Design Master                   }{                                                               }{ Copyright 1990                                                }{ Byte Works, Inc.                                              }{                                                               }{---------------------------------------------------------------}interfaceuses  Common, DialogMgr, IntegerMath, ControlMgr, TextEdit;{$LibPrefix '0/'}uses  Globals;type                                                                 {Error numbers}  errType = (OOM, fatalPrintErr, memoryErr, openErr, readErr, printErr,             writeErr, fileErr, createErr, deleteErr, getTextErr, getFileErr,             getTextInfoErr, fatalErr, window2Err, getCtlErr);var  { Variables accessible from outside the Error unit. }  errNum: integer;                                   {error # returned by tools}  errMsg: array [errType] of pString50;              {error messages           }{ Subroutines that can be called from outside of the Error unit. }procedure InitError;{ Initializes the Error unit. }procedure HandleError (error: integer; whichErr: errType; whichAlert: alertType);{ Reports error detected by the MiniWord program. }implementationvar  { *** GENERATED BY DESIGN MASTER *** }  errAlert:          alertTemplate;  ITEM00Err1:        itemTemplate;  ITEM01Err1:        itemTemplate;  ITEM02Err1:        itemTemplate;  item00pointerErr1: packed array [0..60] of char;  item01pointerErr1: packed array [0..5]  of char;(************************************************* HandleError - Report errors detected in*               MiniWord.** Input:*        error      - error number returned by tool*        whichErr   - error message #*        whichAlert - alert type************************************************)procedure HandleError (* error: integer; whichErr: errType;                         whichAlert: alertType *) ;var  tmp:  longint;  junk: integer;begin{ Get error message to display. }item00err1.itemDescr  :=  @errMsg [whichErr];{ Convert integer error number to hex string in order to display error number }{ in the same format as used by GS/OS and the tools.                          }tmp  :=  ord4 (item01err1.itemDescr) + 2;       {adjust address obtained from  }                                                {  alert item template to point}                                                {  beyond length byte and '$'  }Int2Hex (error, tmp, 4);       {call Integer Math toolset to perform conversion}{ Bring up alert. }case whichAlert of  stdAlertTyp:      junk  :=  Alert (errAlert, nil);  noteAlertTyp:     junk  :=  NoteAlert (errAlert, nil);  cautionAlertTyp:  junk  :=  CautionAlert (errAlert, nil);  stopAlertTyp:     begin                    junk  :=  StopAlert (errAlert, nil);                    done  :=  true;                    end;  end;end;(************************************************* InitError - Initializes the Error unit.************************************************)procedure InitError;beginerrMsg [OOM]            :=  'Out of memory.  Aborting MiniWord.';errMsg [fatalPrintErr]  :=  'Fatal error reported by Print Manager.';errMsg [memoryErr]      :=  'Memory error:  Unable to perform operation.';errMsg [openErr]        :=  'Error returned by GS/OS when opening file.';errMsg [readErr]        :=  'Error returned by GS/OS when reading file.';errMsg [printErr]       :=  'Error:  Aborting printing.';errMsg [writeErr]       :=  'Error returned by GS/OS when writing file.';errMsg [fileErr]        :=  'Error when accessing file.';errMsg [createErr]      :=  'Error returned by GS/OS when creating file.';errMsg [deleteErr]      :=  'Error returned by GS/OS when deleting file.';errMsg [getTextErr]     :=  'Error returned by TextEdit when reading file.';errMsg [getFileErr]     :=  'Error returned by SFO when accessing file.';errMsg [getTextInfoErr] :=  'Error returned by Text Edit when getting info.';errMsg [fatalErr]       :=  'Fatal error:  Cannot recover.';errMsg [window2Err]     :=  'Error returned by NewWindow2 call.';errMsg [getCtlErr]      :=  'Error returned by NewControl2 call.';{ *** GENERATED BY DESIGN MASTER, with comments by B.A. *** }{ Initialize the error alert.                               }with errAlert do begin                          {Error-handling alert template }  with atBoundsRect do begin                    {enclosing rectangle for alert }     v1  :=  $002A;     h1  :=  $004C;     v2  :=  $0082;     h2  :=  $01F9;  end;  atAlertID  :=  1;                          {alert ID number                  }  atStage1   :=  $81;                        {stage 1:  draw alert, emit 1 beep}  atStage2   :=  $81;                        {stage 2:  draw alert, emit 1 beep}  atStage3   :=  $81;                        {stage 3:  draw alert, emit 1 beep}  atStage4   :=  $81;                        {stage 4:  draw alert, emit 1 beep}  atItemList [1]  :=  @item00Err1;           {item pointer:  Error message     }  atItemList [2]  :=  @item01Err1;           {item pointer:  Error number      }  atItemList [3]  :=  @item02Err1;           {item pointer:  OK button         }  atItemList [4]  :=  nil;                   {null terminator                  }end;with ITEM00Err1 do begin                     {Error message item template      }  itemID  :=  $0064;                         {item ID number                   }  with itemRect do begin                     {bounding rectangle               }     v1  :=  30;     h1  :=  10;     v2  :=  45;     h2  :=  409;  end;  itemType  :=  $800F;                       {static text + item disable       }  itemDescr  :=  @item00pointerErr1;         {pointer to error message         }  itemValue  :=  50;                         {length of static text to display }  itemFlag   :=  0;                          {default flag                     }  itemColor  :=  nil;                        {no color table                   }end;item00pointerErr1  :=  'Here is a message that is fifty characters long!!!';with ITEM01Err1 do begin                       {Error alert's error number item}  itemID  :=  $0065;                           {Item ID number                 }  with itemRect do begin                       {bounding rectangle             }     v1  :=  50;     h1  :=  150;     v2  :=  65;     h2  :=  200;  end;  itemType   :=  $800F;                         {static text + item disable    }  itemDescr  :=  @item01pointerErr1;            {pointer to Pascal-style string}  itemValue  :=  5;                             {length of the text            }  itemFlag   :=  0;                             {default flag                  }  itemColor  :=  nil;                           {no color table                }end;item01pointerErr1  :=  '$0000';with ITEM02Err1 do begin                      {Error alert's OK button template}  itemID  :=  1;  with itemRect do begin                      {bounding rectangle              }     v1  :=  70;     h1  :=  200;     v2  :=  85;     h2  :=  230;  end;  itemType   :=  $000A;                            {simple button              }  itemDescr  :=  @okTitle;                         {pointer to button's title  }  itemValue  :=  0;  itemFlag   :=  $0001;                            {bold, round-cornered button}  itemColor  :=  nil;                              {no color table             }end;end;  {InitError}end.  {Error unit}