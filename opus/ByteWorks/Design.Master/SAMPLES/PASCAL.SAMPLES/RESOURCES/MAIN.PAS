{$keep 'main'}program MiniWord;{---------------------------------------------------------------}{                                                               }{ MiniWord - A simple text editor                               }{                                                               }{ Written by Barbara Allred and Design Master                   }{                                                               }{ Copyright 1990                                                }{ Byte Works, Inc.                                              }{                                                               }{---------------------------------------------------------------}uses  Common, MemoryMgr, ToolLocator, QuickDrawII, EventMgr, WindowMgr,  ControlMgr, MenuMgr, DialogMgr, DeskMgr, PrintMgr, IntegerMath,  TextEdit, GSOS;{$LibPrefix '0/'}uses  Globals, Error, Cmds1, Cmds2;var  { Our data structures, global to main. }  masterID:      integer;                             {user ID passed by loader}  startStopAddr: longint;  startStopRec:  startStopRecord;             {GS/OS 5.0 1-stop load tools call}function MyWindow (var index: integer; var currWindow: grafPortPtr;                   numWindows: integer): boolean; forward;(************************************************* DoQuit - Handle Quit command.************************************************)procedure DoQuit (var done: boolean; var index, numWindows: integer;                  var currWindow: grafPortPtr);beginwhile (MyWindow (index, currWindow, numWindows)) do     {close all open windows}  DoClose (index, currWindow, numWindows);done  :=  true;                                              {set the done flag}end;{ Forward declarations of local subroutines that EventLoop calls. }procedure HandleMenu (menuData: longint; var index, numWindows: integer;                      var currWindow: grafPortPtr; var done: boolean); forward;procedure HandleSpecial (menuData: longint; var index, numWindows: integer;                         var currWindow: grafPortPtr); forward;procedure HandleUpdate (theWindow: grafPortPtr); forward;(************************************************* EventLoop - Get next event, then dispatch the*             appropriate routine to handle it.************************************************)procedure EventLoop;{const}                                     {Event codes returned by TaskMaster}  { inButtDwn      =   $0001;  }        {button down event                     }  { mouseUpEvt     =   $0002;  }        {button up event                       }  { inKey          =   $0003;  }        {keystroke event                       }  { autoKeyEvt     =   $0005;  }        {auto key event:  key held down by user}  { inUpdate       =   $0006;  }        {update event                          }  { activateEvt    =   $0008;  }        {activate event                        }  { switchEvt      =   $0009;  }        {switch event                          }  { deskAccEvt     =   $000A;  }        {desk accessory event                  }  { driverEvt      =   $000B;  }        {driver event                          }  { app1Evt        =   $000C;  }        {application 1 event                   }  { app2Evt        =   $000D;  }        {application 2 event                   }  { app3Evt        =   $000E;  }        {application 3 event                   }  { app4Evt        =   $000F;  }        {application 4 event                   }  { wInDesk        =   $0010;  }        {On Desktop                            }  { wInMenuBar     =   $0011;  }        {On system menu bar                    }  { wClickCalled   =   $0012;  }        {system click called                   }  { wInContent     =   $0013;  }        {In content region                     }  { wInDrag        =   $0014;  }        {In drag region                        }  { wInGrow        =   $0015;  }        {In grow region, active window only    }  { wInGoAway      =   $0016;  }        {In go-away region, active window only }  { wInZoom        =   $0017;  }        {In zoom region, active window only    }  { wInInfo        =   $0018;  }        {In information bar                    }  { wInSpecial     =   $0019;  }        {Item ID selected was 250 - 255        }  { wInDeskItem    =   $001A;  }        {Item ID selected was 1 - 249          }  { wInFrame       =   $001B;  }        {in Frame, but not on anything else    }  { wInactMenu     =   $001C;  }        {"selection" of inactive menu item     }  { wClosedNDA     =   $001D;  }        {desk accessory closed                 }  { wCalledSysEdit =   $001E;  }        {inactive menu item selected           }  { wTrackZoom     =   $001F;  }        {zoom box clicked, but not selected    }  { wHitFrame      =   $0020;  }        {button down on frame, made active     }  { wInControl     =   $0021;  }        {button or keystroke in control        }  { wInSysWindow   =   $8000;  }        {hi bit set for system windows         }var   numWindows: integer;                    {# of currently open windows        }   index:      integer;                    {window arrays index, active window }   currWindow: grafPortPtr;                {current active window              }   taskRecord: wmTaskRec;                  {used to communicate with TaskMaster}   eventCode:  integer;                    {returned by TaskMaster             }   i:          integer;begindone  :=  false;                                            {we aint done yet  }for i := 0 to 3 do                                          {no window open yet}  windowOpen [i]  :=  noWindow;numWindows  :=  0;index       :=  0;taskRecord.taskMask  :=  $001FBFFF;       {let TaskMaster do almost everything }while not (done) do begin                   {execute event loop 'til we're done}  { Call TaskMaster to get next event we need to handle. }  eventCode  :=  TaskMaster ($076E,         {event mask = just about everything}                             taskRecord);   {pointer to extended task record   }  errNum  :=  ToolError;  if errNum <> 0 then                                      {only error possible}      HandleError (errNum, fatalErr, stopAlertTyp)         {  is messing up    }                                                           {  wmTaskMask field }  { Window update event? }  else if eventCode = inUpdate then     HandleUpdate (grafPortPtr (taskRecord.taskData))  { Cut, copy, paste, or close command? }  else if eventCode = wInSpecial then     HandleSpecial (taskRecord.taskData, index, numWindows, currWindow)  { Did user click in close box? }  else if eventCode = wInGoAway then begin     if MyWindow (index, currWindow, numWindows) then        DoClose (index, currWindow, numWindows)     end  { Non-special command? }  else if eventCode = wInMenuBar then     HandleMenu (taskRecord.taskData, index, numWindows, currWindow, done)  end  {while not done}end;  {EventLoop}(************************************************* HandleMenu - Handle menu selections, menu IDs*              256 ->.************************************************)procedure HandleMenu (* menuData: longint; var index, numWindows: integer;                        var currWindow: grafPortPtr; var done: boolean *);type  menuIDs = 256..264;var  theItem: menuIDs;  menuNum: integer;begin{ Menu item ID is in low-order word of the taskData field of our task record. }{ Menu ID is in the high-order word of the field.                             }theItem  :=  convert (menuData) .lsw;menuNum  :=  convert (menuData) .msw;{ Dispatch the appropriate routine, based on menu item selected. }case theItem of  aboutID:    DoAbout;  newID:      DoNew (index, numWindows);  openID:     DoOpen (index, numWindows);  saveID:     if MyWindow (index, currWindow, numWindows) then                 DoSave (index, currWindow);  saveAsID:   if MyWindow (index, currWindow, numWindows) then                 DoSaveAs (index, currWindow);  pSetUpID:   DoPSetUp;  printID:    if MyWindow (index, currWindow, numWindows) then                 DoPrint (index, currWindow);  quitID:     DoQuit (done, index, numWindows, currWindow);  findID:     DoFind;  end;{ Unhighlight the menu they just pulled down. }HiliteMenu (false, menuNum);end;(************************************************* HandleSpecial - Handle special menu commands,*                 menu IDs 250 - 255.************************************************)procedure HandleSpecial (* menuData: longint; var index, numWindows: integer;                           var currWindow: grafPortPtr *);var   theItem: integer;   menuNum: integer;begin{ Menu item ID is in low-order word of the taskData field of our task record. }{ Menu ID is in the high-order word of the field.                             }theItem  :=  convert (menuData) .lsw;menuNum  :=  convert (menuData) .msw;{ Close command selected?  All other special items handled by TaskMaster. }if theItem = closeID then  if MyWindow (index, currWindow, numWindows) then     DoClose (index, currWindow, numWindows);{ Unhighlight the menu they just pulled down. }HiliteMenu (false, menuNum);end; {HandleSpecial}(************************************************* HandleUpdate - Handle update event for active*                window.************************************************)procedure HandleUpdate (* theWindow: grafPortPtr *);beginBeginUpdate  (theWindow);DrawControls (theWindow);EndUpdate    (theWindow);end;procedure InitMenus; forward;(************************************************* Init - Initialize all global variables, start*        the tools we need, create our menu bar.** Output:*      Returns true if everything started OK,*      and false otherwise.************************************************)function Init: boolean;label 99;var  ok: boolean;begin{ Initialize all global variables. }Init      :=  true;                       {assume all is well to start with    }masterID  :=  userID;                     {get user ID passed by loader        }myID      :=  masterID | $0200;           {alter for our purposes, so we can do}                                          {  a simple DisposeAll at the end    }{ Start tools we need:  Use GS/OS 5.0 one-call startup mechanism. }with startStopRec do begin  flags      :=  0;                          {flags must be zero  }  videoMode  :=  $80;                        {640 mode            }  numTools   :=  22;                         {we'll start 22 tools}  toolArray [1].toolNumber  :=  $01;         {Tool Locator}  toolArray [1].minVersion  :=  $0100;  toolArray [2].toolNumber  :=  $02;         {Memory Manager}  toolArray [2].minVersion  :=  $0100;  toolArray [3].toolNumber  :=  $03;         {Miscellaneous Toolset}  toolArray [3].minVersion  :=  $0300;  toolArray [4].toolNumber  :=  $04;         {Quick Draw II}  toolArray [4].minVersion  :=  $0300;  toolArray [5].toolNumber  :=  $06;         {Event Manager}  toolArray [5].minVersion  :=  $0300;  toolArray [6].toolNumber  :=  $0E;         {Window Manager}  toolArray [6].minVersion  :=  $0300;  toolArray [7].toolNumber  :=  $10;         {Control Manager}  toolArray [7].minVersion  :=  $0300;  toolArray [8].toolNumber  :=  $0F;         {Menu Manager}  toolArray [8].minVersion  :=  $0300;  toolArray [9].toolNumber  :=  $14;         {LineEdit Toolset}  toolArray [9].minVersion  :=  $0100;  toolArray [10].toolNumber :=  $15;         {Dialog Manager}  toolArray [10].minVersion :=  $0100;  toolArray [11].toolNumber :=  $08;         {Sound Manager}  toolArray [11].minVersion :=  $0100;  toolArray [12].toolNumber :=  $17;         {Standard File Operations Toolset}  toolArray [12].minVersion :=  $0100;  toolArray [13].toolNumber :=  $16;         {Scrap Manager}  toolArray [13].minVersion :=  $0104;  toolArray [14].toolNumber :=  $09;         {Apple Desktop Bus Toolset}  toolArray [14].minVersion :=  $0100;  toolArray [15].toolNumber :=  $05;         {Desk Manager}  toolArray [15].minVersion :=  $0100;  toolArray [16].toolNumber :=  $1C;         {List Manager}  toolArray [16].minVersion :=  $0100;  toolArray [17].toolNumber :=  $1B;         {Font Manager}  toolArray [17].minVersion :=  $0204;  toolArray [18].toolNumber :=  $13;         {Print Manager}  toolArray [18].minVersion :=  $0100;  toolArray [19].toolNumber :=  $12;         {Quick Draw II Auxiliary}  toolArray [19].minVersion :=  $0206;  toolArray [20].toolNumber :=  $0A;         {SANE Toolset}  toolArray [20].minVersion :=  $0100;  toolArray [21].toolNumber :=  $0B;         {Integer Math Toolset}  toolArray [21].minVersion :=  $0100;  toolArray [22].toolNumber :=  $22;         {Text Edit Toolset}  toolArray [22].minVersion :=  $0100;  end;startStopAddr  :=  StartUpTools (masterID, pointerVerb, ord4 (@startStopRec));errNum         :=  ToolError;if errNum <> 0 then begin  Init  :=  false;  goto 99;  end;{ Initialize our units. }okTitle      :=  'OK';cancelTitle  :=  'Cancel';InitError;if not (InitCmds1) then begin  Init  :=  false;  goto 99;  end;if not (InitCmds2) then begin  Init  :=  false;  goto 99;  end;InitMenus;InitCursor;                            {StartUpTools brings up the watch cursor}                                       {  so change it to the arrow            }99:end;(************************************************* InitMenus - Initialize the menu bar.************************************************)procedure InitMenus;var  i: integer;begin{ Create the menu bar.  Start at the last menu, since we're inserting each new }{ menu at the front of the current menu list.  Note:  We're using menu         }{ resources, whose IDs are given in the Globals unit.                          }InsertMenu (NewMenu2 (resourceVerb, searchMenuID), 0);InsertMenu (NewMenu2 (resourceVerb, editMenuID), 0);InsertMenu (NewMenu2 (resourceVerb, fileMenuID), 0);InsertMenu (NewMenu2 (resourceVerb, appleMenuID), 0);FixAppleMenu (1);               {add desk accessories to Apple menu           }i  :=  FixMenuBar;              {compute standard sizes for menu bar and menus}                                {  throw away returned height                 }DrawMenuBar;end; {InitMenus}(************************************************* MyWindow - Checks if front window is one of ours.** Output:*        true if it's one of ours; false otherwise************************************************)function MyWindow (* var index: integer; var currWindow: grafPortPtr;                     numWindows: integer): boolean *);label 99;var  systemWind: boolean;             {true if the front window is a system window}  tmp:        grafPortPtr;  tmp2:       longint;beginMyWindow  :=  true;                            {assume the front window is ours}{ First check if any windows are open. }if numWindows = 0 then begin  MyWindow  :=  false;  goto 99;  end;{ Now check if the window is one of ours. }tmp         :=  FrontWindow;             {get grafPort pointer of active window}systemWind  :=  GetSysWFlag (tmp);               {active window belong to desk }                                                 {  accessory?                 }if systemWind then begin                         {Yes - MyWindow is false, exit}  MyWindow  :=  false;  goto 99;  end;{ It's one of ours, so get index into window arrays from wRefCon field. }tmp2        :=  GetWRefCon (tmp);index       :=  convert (tmp2) .lsw;currWindow  :=  tmp;99:end;(************************************************* ShutDown - Unload the tools we started.************************************************)procedure ShutDown;beginDisposeAll (myID);                          {dispose of all memory we allocated}ShutDownTools (pointerVerb, startStopAddr);         {shut down tools we started}errNum  :=  ToolError;if errNum <> 0 then   HandleError (errNum, fatalErr, stopAlertTyp);end;(************************************************* Main program*************************************************)beginif Init then                                    {start tools, bring up menu bar}   EventLoop;                                   {execute main event loop       }ShutDown;                                       {unload tools                  }end.