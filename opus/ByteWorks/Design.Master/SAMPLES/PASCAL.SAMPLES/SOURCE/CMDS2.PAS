{$keep 'Cmds2'}unit Cmds2;{---------------------------------------------------------------}{                                                               }{ Cmds2 - Handles the menu commands New, Open,                  }{         Save, and Save as.                                    }{                                                               }{ Written by Barbara Allred and Design Master                   }{                                                               }{ Copyright 1990                                                }{ Byte Works, Inc.                                              }{                                                               }{---------------------------------------------------------------}interfaceuses  Common, MemoryMgr, WindowMgr, ControlMgr, MenuMgr, DialogMgr, SFToolset,  IntegerMath, TextEdit, GSOS;{$LibPrefix '0/'}uses  Globals, Error;{ Subroutines that can be called from outside of the Cmds2 unit. }procedure DoNew (var index: integer; var numWindows: integer);{ Create an unititled window on the desktop. }procedure DoOpen (var index: integer; var numWindows: integer);{ Open a disk file, displaying its contents in a new window. }procedure DoSave (index: integer; currWindow: grafPortPtr);{ Save a document to disk, where document is associated with a disk file. }procedure DoSaveAs (index: integer; currWindow: grafPortPtr);{ Save a document to disk; document may/may not be associated with a disk file }function InitCmds2: boolean;{ Initialize the Cmds2 unit. }{ The rest of the file is private to the Cmds2 unit. }implementationtype  gsosMinOutputBuffer = record             {minimally sized GS/OS output buffer}     totalSize: integer;     currSize:  integer;     theText:   packed array [1..2] of char;     end;  smGSOSinString = record                             {small GS/OS input string}     currSize: integer;     theText:  packed array [1..10] of char;     end;var  { *** GENERATED BY DESIGN MASTER, with comments by B.A. *** }  windColorTable: wColorTbl;                       {document window definitions}  window:         paramList;  control001111: editTextControl;  { Our data structures, global to the Cmds1 unit. }  { Window tracking information -- We're allowing only 4 windows to be opened }  { on the desktop.                                                           }  untitledNum: integer;                    {# to assign to next untitled window}  wName:       array [0..3] of pString17;           {array of window names     }  thePath:     array [0..3] of gsosInStringPtr;     {array of pathname pointers}                                                    {  for opening files       }                                      {Standard File Operations data structures}  theReply:  replyRecord5_0;  openMsg:   packed array [0..20] of char;     {msg to display in open file dlg}  openTypes: typeList5_0;  saveMsg:   packed array [0..27] of char;     {msg to display in save file dlg}  saveName:  smGSOSinString;                   {default filename to appear in  }                                               {  save file dialog             }                                 {Data structures for GS/OS file handling calls}  openRec:        openOSDCB;                       {open file parameter block  }  readRec:        readWriteOSDCB;                  {read file parameter block  }  writeRec:       readWriteOSDCB;                  {write file parameter block }  closeRec:       closeOSDCB;                      {close file parameter block }  destroyRec:     destroyOSDCB;                    {delete file parameter block}  getFileInfoRec: getFileInfoOSDCB;                {getFileInfo parameter block}  createRec:      createOSDCB;                     {create file parameter block}  options:        gsosMinOutputBuffer;  {buffer for FST info, returned by GS/OS}{ These are some of the private procedures and functions, forward declared }{ so that we can alphabetize the subroutines in this unit.                 }procedure DoClose (index: integer; currWindow: grafPortPtr;                   var numWindows: integer); extern;{ Close the front window, checked if it's ours before passing currWindow to us }procedure FiniWindow (var numWindows: integer); forward;{ Wraps up window creation. }procedure GetOpenName (var theReply: replyRecord5_0; index: integer); forward;{ Gives new window a title based on file just opened. }function GetText (index: integer; textInfo: teInfoRec;                  var size: longint): boolean; forward;{ Retrieves text from Text Edit for the currently active window. }procedure GetUntitledName (index: integer; var untitledNum: integer); forward;{ Gives new window an "Untitled X" title. }procedure InitWindow (var window: paramList; var index: integer); forward;{ Initializes window creation. }(************************************************* CreateWindow - Create new window on the desktop.** Output:*      true if window was created; false otherwise*************************************************)function CreateWindow (var index: integer; var numWindows: integer): boolean;var  tmp: longint;beginCreateWindow  :=  true;                          {assume we'll be successful}{ Call Window Manager's NewWindow function to create new window on desktop. }windowPtr [index]  :=  NewWindow (window);errNum             :=  ToolError;if (errNum <> 0) then begin  HandleError (errNum, memoryErr, cautionAlertTyp);  CreateWindow  :=  false;  end{ Add text edit control to window. }else begin  tmp  :=  ord4 (@control001111);  textEdHandle [index]  :=  NewControl2 (windowPtr [index], pointerVerb, tmp);  errNum  :=  ToolError;  if (errNum <> 0) then begin     HandleError (errNum, memoryErr, cautionAlertTyp);     DoClose (index, windowPtr [index], numWindows);     CreateWindow  :=  false;     end;  end;end; {CreateWindow}(************************************************* DoNew - Handle New command.************************************************)procedure DoNew (* var index: integer; var numWindows: integer *);beginInitWindow (window, index);                      {init. window data structures }GetUntitledName (index, untitledNum);            {create untitled window's name}if CreateWindow (index, numWindows) then begin   {create new window on desktop }  windowOpen [index]  :=  fromNew;       {set flag that window from the New cmd}  FiniWindow (numWindows);               {disable Open, New cmds, if necessary }  end;end; {DoNew}(************************************************* DoOpen - Handle Open command.************************************************)procedure DoOpen (* var index: integer; var numWindows: integer *);label 99;var  aHandle: handle;  tmp:     handle;beginInitWindow (window, index);                  {initialize window data structures}{ Make SFGetFile2 call to bring up SFO Open dialog and get filename and }{ pathname of file to open.                                             }SFGetFile2 (20,               {upper left corner X-coord of SFGetFile2's dialog}            20,               {upper left corner Y-coord of SFGetFile2's dialog}            pointerVerb,      {prompt is pointer to P-string                   }            @openMsg,         {pointer to prompt                               }            nil,              {no filter procedure                             }            openTypes,        {fileTypes, auxTypes of files to open            }            theReply);        {GS/OS 5.0 reply record                          }errNum  :=  ToolError;if errNum <> 0 then  HandleError (errNum, getFileErr, cautionAlertTyp)else if theReply.good <> 0 then begin           {Does user want to open a file?}                                                {Yes - get pointer to pathname }  tmp               :=  handle (theReply.pathRef);  openRec.pathname  :=  pointer (ord4 (tmp^) + 2);  OpenGS (openRec);                                              {open the file}  errNum  :=  ToolError;  if errNum <> 0 then begin     HandleError (errNum, openErr, cautionAlertTyp);     goto 99;     end;  { Record file's pathname - we'll need it when saving file to disk.  }  { Pass file's reference # to GS/OS read and close parameter blocks. }  thePath [index]  :=  gsosInStringPtr (openRec.pathname);  readRec.refNum   :=  openRec.refNum;  closeRec.refNum  :=  openRec.refNum;  GetOpenName (theReply, index);     {get filename to display in window's title}  { Create new window - if unable to create, close the file & exit. }  if not (CreateWindow (index, numWindows)) then begin     CloseGS (closeRec);     goto 99;     end;  { Read the file into memory, pass its text on to TextEdit to paint into }  { window.                                                               }  { Allocate memory block to read file into.  Attributes flag is locked,  }  { can't move, don't purge, don't cross bank boundary.                   }  aHandle  :=  NewHandle (openRec.dataEOF, myID, $C010, nil);  errNum   :=  ToolError;  if errNum <> 0 then begin     HandleError (errNum, memoryErr, cautionAlertTyp);     CloseGS (closeRec);     DoClose (index, windowPtr [index], numWindows);     goto 99;     end;  readRec.dataBuffer    :=  aHandle^;               {dereference memory handle}  readRec.requestCount  :=  openRec.dataEOF;        {get # bytes to read      }  ReadGS (readRec);  errNum  :=  ToolError;  { If unable to read the file, report the error, close the window, close the }  { file.                                                                     }  if errNum <> 0 then begin     HandleError (errNum, readErr, cautionAlertTyp);     DoClose (index, windowPtr [index], numWindows);     CloseGS (closeRec);     goto 99;     end;  { Call Text Edit to transfer the text from the read buffer to the control. }  TESetText ($0005,                                     {text is raw data      }             ord4 (readRec.dataBuffer),                 {pointer to data       }             readRec.transferCount,                     {size of data          }             pointerVerb,                               {style ref is pointer  }             0,                                         {not passing style info}             nil);                                      {use active TE control }  errNum  :=  ToolError;  if errNum <> 0 then begin     { Only possible errs are messing up parms or propagation of memory errs }     HandleError (errNum, fatalErr, stopAlertTyp);     CloseGS (closeRec);     DoClose (index, windowPtr [index], numWindows);     goto 99;     end;  { Perform clean-up:  record that window is from a disk file, check if need  }  { to disable Open & New commands, close the file, release read buffer's     }  { memory.                                                                   }  windowOpen [index]  :=  fromFile;  FiniWindow (numWindows);  CloseGS (closeRec);  DisposeHandle (aHandle);  end; {if user wants to open file}99:end; {DoOpen}(************************************************* DoSave - Handle Save command.************************************************)procedure DoSave (* index: integer, currWindow: grafPortPtr *);label 99;var  tePtr: teRecPtr;              {ptr to active window's textEdit control record}begin{ Check if window from the New command; if so, execute DoSaveAs. }if windowOpen [index] = fromNew then begin  DoSaveAs (index, currWindow);  goto 99;  end;{ Check if file has changed since it was last saved to disk.  Check if the }{ dirty bit in the textEdit record has been set by Text Edit.              }tePtr  :=  teRecPtr (textEdHandle [index]^);              {dereference teHandle}if (tePtr^.ctlFlag & isDirty) = 0 then  goto 99;{ Get the window's text to write to disk. }if not (GetText (index, textInfo, writeRec.requestCount)) then  goto 99;{ Get file's pathname for delete, create, and open operations. }destroyRec.pathname  :=  thePath [index];createRec.pathname   :=  thePath [index];openRec.pathname     :=  thePath [index];DestroyGS (destroyRec);                               {delete the old disk file}errNum  :=  ToolError;if errNum <> 0 then begin  HandleError (errNum, deleteErr, cautionAlertTyp);  goto 99;  end;CreateGS (createRec);                                          {create new file}errNum  :=  ToolError;if errNum <> 0 then begin  HandleError (errNum, createErr, cautionAlertTyp);  goto 99;  end;OpenGS (openRec);                                            {open the new file}errNum  :=  ToolError;if errNum <> 0 then begin  HandleError (errNum, openErr, cautionAlertTyp);  goto 99;  end;{ Dereference buffer's handle to get pointer to data to write. }writeRec.dataBuffer  :=  buffer^;{ Get file's reference # for write and close operations. }writeRec.refNum  :=  openRec.refNum;closeRec.refNum  :=  openRec.refNum;WriteGS (writeRec);                                       {write window to disk}errNum  :=  ToolError;if errNum <> 0 then  HandleError (errNum, writeErr, cautionAlertTyp){ Clear the dirty bit after saving file. }else  tePtr^.ctlFlag  :=  tePtr^.ctlFlag & notDirty;CloseGS (closeRec);                                        {close the disk file}99:end; {DoSave}(************************************************* DoSaveAs - Handle Save as command.************************************************)procedure DoSaveAs (* index: integer; currWindow: grafPortPtr *);label 99;const  fileNotFound = $0046;                {File not found error, reported by GS/OS}var  tePtr: teRecPtr;                        {pointer to textEdit control's record}  tmp:   handle;begin{ Make SFPutFile2 call to bring up SFO Save dialog and get filename and }{ pathname of file to create, open, and then write.                     }SFPutFile2 (20,                  {upper left corner X-coord of SFPutFile2's dlg}            20,                  {upper left corner Y-coord of SFPetFile2's dlg}            pointerVerb,                     {prompt is pointer to P-string    }            ord4 (@saveMsg),                 {pointer to prompt                }            pointerVerb,                     {default name is pointer          }            ord4 (@saveName),                {pointer to GS/OS input string    }            theReply);                       {pointer to GS/OS 5.0 reply record}errNum  :=  ToolError;if errNum <> 0 then begin  HandleError (errNum, fileErr, cautionAlertTyp);  goto 99;  end;if theReply.good = 0 then                       {Does user want to open a file?}  goto 99;{ Fill in GS/OS write parameter block fields.  Call TEGetText to get }{ the text to write to disk.                                         }if not (GetText (index, textInfo, writeRec.requestCount)) then  goto 99;{ Get pathname selected by user with SFPutFile2 call, in reply record. }{ Then make GS/OS GetFileInfo call to see if file already exists.      }tmp                      :=  handle (theReply.pathRef);getFileInfoRec.pathname  :=  pointer (ord4 (tmp^) + 2);GetFileInfoGS (getFileInfoRec);errNum  :=  ToolError;if (errNum <> 0) and (errNum <> fileNotFound) then begin  HandleError (errNum, fileErr, cautionAlertTyp);  goto 99;  end;{ If no error reported by GetFileInfo call, then need to delete old }{ file before creating new file with the same pathname.             }if errNum = 0 then begin  destroyRec.pathname  :=  getFileInfoRec.pathname;  DestroyGS (destroyRec);  errNum  :=  ToolError;  if errNum <> 0 then begin     HandleError (errNum, deleteErr, cautionAlertTyp);     goto 99;     end;  end;{ Now create new file with pathname selected by user. }createRec.pathname  :=  getFileInfoRec.pathname;CreateGS (createRec);errNum  :=  ToolError;if errNum <> 0 then begin  HandleError (errNum, createErr, cautionAlertTyp);  goto 99;  end;{ Open the file to prepare for writing window's contents to disk. }openRec.pathname  :=  getFileInfoRec.pathname;OpenGS (openRec);errNum  :=  ToolError;if errNum <> 0 then begin  HandleError (errNum, openErr, cautionAlertTyp);  goto 99;  end;{ Record file's reference # returned by GS/OS in write and close }{ parameter blocks.                                              }writeRec.refNum  :=  openRec.refNum;closeRec.refNum  :=  openRec.refNum;{ Check if window previously belonged to another file, and if so,  }{ dispose of its old pathname handle.  Record its new path handle. }if windowOpen [index] = fromFile then   DisposeHandle (pathHandle [index]);pathHandle [index]  :=  tmp;{ Dereference buffer's handle to get pointer to data to write to disk. }{ Write the window's contents to disk.                                 }writeRec.dataBuffer  :=  buffer^;WriteGS (writeRec);errNum  :=  ToolError;if errNum <> 0 then begin  HandleError (errNum, writeErr, cautionAlertTyp);  CloseGS (closeRec);  goto 99;  end;{ Clear the dirty bit after saving the file. }tePtr           :=  teRecPtr (textEdHandle [index]^);tePtr^.ctlFlag  :=  tePtr^.ctlFlag & notDirty;{ Get opened file's name to put in window's title. }GetOpenName (theReply, index);       {get filename to display in window's title}SetWTitle ( @wName [index], currWindow);{ Record that window comes from a file, close the disk file, then record the }{ new pathname.                                                              }windowOpen [index]  :=  fromFile;thePath [index]     :=  getFileInfoRec.pathname;CloseGS (closeRec);99:end; {DoSaveAs}(************************************************* FiniWindow - Disable New and Open commands if*              this is the 4th window opened.************************************************)procedure FiniWindow (* var numWindows: integer *);beginnumWindows  :=  numWindows + 1;                    {one more open window       }if numWindows = maxWindows then begin              {max # open windows reached?}  DisableMItem (openID);                           {yes - don't let 'em open or}  DisableMItem (newID);                            {  create another window    }  end;end; {FiniWindow}(************************************************* GetOpenName - Build filename when open a file.************************************************)procedure GetOpenName (* var theReply: replyRecord5_0; index: integer *);{ Will dispose of filename's handle; will change window's title. }var  namePtr: ptr;  size:    byte;  tmp:     handle;  tmpPtr:  pStringPtr;begin{ Use filename returned by SFO to place into window's title string. }{ First need to dereference filename handle, then move beyond GS/OS }{ total buffer length.                                              }tmp      :=  handle (theReply.nameRef);namePtr  :=  pointer (ord4 (tmp^) + 2);{ Get length of filename; AND with $000F to restrict length to 15 characters. }{ Set filename pointer to point to 2nd byte of length word, to prepare for    }{ converting a GS/OS input string into a Pascal-style string.  Stuff the      }{ length byte into the byte pointed to by namePtr to complete the conversion. }size     :=  namePtr^ & $0F;namePtr  :=  pointer (ord4 (namePtr) + 1);namePtr^ :=  size;{ Move filename into area pointed to by wTitle, surrounding it with blanks. }tmpPtr         :=  pStringPtr (namePtr);wName [index]  :=  concat (' ', tmpPtr^, ' ');{ Dispose of filename handle since we won't need it after this. }DisposeHandle (tmp);end; {GetOpenName}(************************************************* GetText - Call Text Edit's TEGetText routine*           to get text to write to disk.** Output:*        true if text can be returned, false otherwise************************************************)function GetText (* index: integer; textInfo: teInfoRec;                    var size: longint): boolean *);label 99;const  NotEnoughMemory = $0201;                             {not enough memory error}begin{ First call Text Edit's TEGetTextInfo to determine if the current TEGetText   }{ buffer is large enough to hold the window's text.                            }TEGetTextInfo (textInfo, 2, textEdHandle [index]);errNum  :=  ToolError;if errNum <> 0 then begin  HandleError (errNum, getTextInfoErr, cautionAlertTyp);  GetText  :=  false;  goto 99;  end;{ Check if current buffer is too small; if so, attempt to allocate new buffer. }if textInfo.charCount > bufferSize then  if MaxBlock >= textInfo.charCount then begin     DisposeHandle (buffer);     buffer  :=  NewHandle (textInfo.charCount, myID, $0000, nil);     errNum  :=  ToolError;     if errNum <> 0 then begin        HandleError (errNum, memoryErr, cautionAlertTyp);        GetText  :=  false;        goto 99;        end     else        bufferSize  :=  textInfo.charCount;     end  else begin                                         {can't allocate new buffer}     HandleError (NotEnoughMemory, memoryErr, cautionAlertTyp);     GetText  :=  false;     goto 99;     end;{ Call TEGetText to get window's text.  We'll pass a handle to the buffer in }{ which to store the text, and not ask for any style information.            }size  :=  TEGetText ($000D, buffer, bufferSize, pointerVerb,                     nil, textEdHandle [index]);errNum  :=  ToolError;if errNum <> 0 then begin  HandleError (errNum, getTextErr, cautionAlertTyp);  GetText  :=  false;  goto 99;  end;GetText  :=  true;99:end; {GetText}(************************************************* GetUntitledName - Create next untitled window's*                   name.************************************************)procedure GetUntitledName (* index: integer; var untitledNum: integer *);var  num : packed array [0..5] of char;begin{ Convert untitled window number to a Pascal-style string, then increment }{ untitled number.                                                        }num          :=  cnvis (untitledNum);untitledNum  :=  untitledNum + 1;{ Move character representation of untitled number into the window's title. }wName [index]  :=  concat (' Untitled ', num, ' ');end; {GetUntitledName}(************************************************* InitCmds2 - Initialize the Cmds2 unit's data*             structures.************************************************)function InitCmds2 (* : boolean *);label 99;beginInitCmds2    :=  true;untitledNum  :=  1;                       {# to assign to next untitled window }{ Allocate memory block for TEGetText call. }buffer  :=  NewHandle (1024, myID, $0000, nil);          {don't purge, can move}errNum  :=  ToolError;if errNum <> 0 then begin  HandleError (errNum, memoryErr, stopAlertTyp);  InitCmds2  :=  false;  goto 99;  end;bufferSize  :=  1024;{ Initialize SFO variables. }with theReply do begin  nameVerb  :=  newHandleVerb;               {reference is undefined:  SFO will}  pathVerb  :=  newHandleVerb;               {  allocate and return a handle   }  end;openMsg  :=  'Select file to open:';with openTypes do begin  numEntries  :=  2;                        {number of entries in filetype list}  fileAndAuxTypes [1].flags  :=  $8000;     {match filetype, any auxtype, allow}                                            {  user to select these files      }  fileAndAuxTypes [1].fileType  :=  $04;    {ASCII text file                   }  fileAndAuxTypes [1].auxType   :=  0;      {don't care about auxtype          }  fileAndAuxTypes [2].flags  :=  $8000;     {match filetype, any auxtype, allow}                                            {  user to select these files      }  fileAndAuxTypes [2].fileType  :=  $B0;    {APW source file                   }  fileAndAuxTypes [2].auxType   :=  0;      {don't care about auxtype          }  end;saveMsg   :=  'Enter name of file to save:';with saveName do begin  currSize  :=  7;  theText   :=  'newFile';                 {default name to appear SFO save dlg}end;{ Initialize GS/OS variables. }with options do begin  totalSize  :=  6;  currSize   :=  2;  end;with openRec do begin  pCount          :=  15;                     {parameter count                 }  access          :=  $0003;                  {request read/write access       }  resourceNumber  :=  0;                      {resource number:  open data fork}  optionList      :=  @options;               {pointer to GS/OS result buffer  }  end;with readRec do begin  pCount         :=  5;                                       {parameter count }  cachePriority  :=  0;                                       {don't cache file}  end;closeRec.pCount    :=  1;                                      {parameter count}destroyRec.pCount  :=  1;with writeRec do begin  pCount         :=  5;                                       {parameter count }  cachePriority  :=  0;                                       {don't cache file}  end;with getFileInfoRec do begin  pCount      :=  12;                           {parameter count               }  optionList  :=  @options;                     {pointer to GS/OS output buffer}  end;with createRec do begin  pCount       :=  7;                      {parameter count                    }  access       :=  $00C3;                  {destroy, rename, write, read access}  fileType     :=  $0004;                  {ASCII file                         }  auxType      :=  0;  storageType  :=  $0001;                  {standard file                      }  dataEOF      :=  0;                      {initial size of data fork is 0     }  resourceEOF  :=  0;                      {initial size of resource fork is 0 }  end;{ *** GENERATED BY DESIGN MASTER, with comments by B.A. ***     }{ Initialize window parameter list and editText control record. }with window do begin                       {Window parameter list              }  paramLength  :=  78;                     {parm list length                   }  wFrameBits   :=  $C1E7;                  {frame bits                         }  wTitle       :=  nil;                    {pointer to window's title          }  wRefCon      :=  0;                      {we'll use to store index into      }                                           {  window-tracking arrays           }  with wZoom do begin                      {zoomed rectangle                   }     v1  :=  $001E;     h1  :=  $0014;     v2  :=  $003C;     h2  :=  $0064;  end;  wColor         :=  @windColorTable;      {color table pointer                }  wYOrigin       :=  $0000;                {vert offset of content             }  wXOrigin       :=  $0000;                {horiz offset of content            }  wDataH         :=  $0000;                {data area height                   }  wDataW         :=  $0000;                {data area width                    }  wMaxH          :=  $00C8;                {max grow height                    }  wMaxW          :=  $0280;                {max grow width                     }  wScrollVer     :=  $0000;                {vert. arrow scroll amount          }  wScrollHor     :=  $0000;                {horiz arrow scroll amount          }  wPageVer       :=  $0000;                {vert. page amount                  }  wPageHor       :=  $0000;                {horiz page amount                  }  wInfoRefCon    :=  0;                    {info bar ref con                   }  wInfoHeight    :=  0;                    {info bar height                    }  wFrameDefProc  :=  nil;                  {window definition procedure        }  wInfoDefProc   :=  nil;                  {info bar draw routine              }  wContDefProc   :=  nil;                  {window content draw routine        }  with wPosition do begin                  {window position rectangle          }     v1  :=  $001E;     h1  :=  $0014;     v2  :=  $00C2;     h2  :=  $025F;  end;  wPlane    :=  grafPortPtr (-1);          {window plane, -1 for front         }  wStorage  :=  nil;                       {address of memory for window record}end;with windColorTable do begin  frameColor  :=  $0010;                                    {window frame color}  titleColor  :=  $0D81;                                    {title color       }  tBarColor   :=  $021D;                                    {title bar color   }  growColor   :=  $0074;                                    {grow box color    }  infoColor   :=  $0000;                                    {info bar color    }end;with control001111 do begin                 {editText control template         }  pCount     :=    23;                      {parameter count                   }  controlID  :=    $000087DA;               {ID number TaskMaster will use     }  with boundsRect do begin                  {encloses entire control, including}     v1  :=  $0002;                         {  scroll bars and grow box        }     h1  :=  $0002;     v2  :=  $0000;     h2  :=  $0000;  end;  procRef    :=  $85000000;                 {Code for editText control         }  flags      :=  $0000;                     {control is visible, not dirty yet }  moreflags  :=  $7C00;                     {add a grow box to the control     }  refCon     :=  0;  textFlags  :=  $62200000;                 {smart cut & paste; allow editing  }  with indentRect do begin                  {use standard indentation          }     v1  :=  $FFFF;     h1  :=  $FFFF;     v2  :=  $FFFF;     h2  :=  $FFFF;  end;  vertBar          :=  $FFFFFFFF;          {create vert. scroll bar just inside}                                           {  right edge of bounds rect        }  vertAmount       :=  0;                  {scroll 9 pixels, up- & down-arrows }  horzBar          :=  0;                  {MUST BE NULL version 1.0           }  horzAmount       :=  0;                  {MUST BE NULL version 1.0           }  styleRef         :=  0;                  {use default style and ruler        }  textDescriptor   :=  0;                  {no initial text for control        }  textRef          :=  0;  textLength       :=  0;  maxChars         :=  0;  maxLines         :=  0;  maxCharsPerLine  :=  0;                       {MUST BE NULL version 1.0      }  maxHeight        :=  0;                       {MUST BE NULL version 1.0      }  colorRef         :=  0;                       {no color table                }  drawMode         :=  0;  filterProcPtr    :=  nil;                     {use built-in filter procedures}end;99:end; {InitCmds2}(************************************************* InitWindow - Perform window initialization,*              common to both DoOpen and DoNew.************************************************)procedure InitWindow (* var window: paramList; var index: integer *);begin{ Find empty slot in windowOpen array for this window. }index  :=  0;while windowOpen [index] <> noWindow do  index  :=  index + 1;{ Use window's RefCon to track position in window arrays. }window.wRefCon  :=  index;{ Set window's title pointer. }window.wTitle  :=  @wName [index];end;end. {Cmds2 unit}