{$keep 'Cmds1'}unit Cmds1;{---------------------------------------------------------------}{                                                               }{ Cmds1 - Handles the menus commands About, Close,              }{         Find, Page setup, and Print.                          }{                                                               }{ Written by Barbara Allred and Design Master                   }{                                                               }{ Copyright 1990                                                }{ Byte Works, Inc.                                              }{                                                               }{---------------------------------------------------------------}interfaceuses  Common, MemoryMgr, QuickDrawII, WindowMgr, ControlMgr, MenuMgr, DialogMgr,  PrintMgr, TextEdit;{$LibPrefix '0/'}uses  Globals, Error;{ Subroutines that can be called from outside of the Cmds1 unit. }procedure DoAbout;{ Handle the About menu item. }procedure DoClose (index: integer; currWindow: grafPortPtr;                   var numWindows: integer);{ Close the front window, checked if it's ours before passing currWindow to us }procedure DoFind;{ Handle the Find menu item. }procedure DoPrint (index: integer; currWindow: grafPortPtr);{ Print a document. }procedure DoPSetUp;{ Allow user to set some printer options. }function InitCmds1: boolean;{ Initialize the Cmds1 unit. }{ The rest of the file is private to the Cmds1 unit. }implementationvar  { *** GENERATED BY DESIGN MASTER, with comments by B.A. *** }  aboutDlg:          dialogTemplate;                          {About dialog box}  ITEM00Abt1:        itemTemplate;  ITEM01Abt1:        itemTemplate;  item00pointerAbt1: packed array [0..100] of char;  item01colorsAbt1:  colorTable;  saveAlert:          alertTemplate;                      {WantToSave alert box}  ITEM00Save1:        itemTemplate;  ITEM01Save1:        itemTemplate;  ITEM02Save1:        itemTemplate;  item00pointerSave1: packed array [0..30] of char;  { Our data structures, global to the Cmds1 unit. }  printHandle: prHandle;          {print record handle                         }  prRect:      Rect;              {TEPaintText rect to draw into               }  prStatus:    prStatusRec;       {reports info to user during spooled printing}procedure DoSave (index: integer; currWindow: grafPortPtr); extern;{ Save a document to disk, where document is associated with a disk file. }(************************************************* DoAbout - Handle About command.************************************************)procedure DoAbout;var  theDialog: grafPortPtr;                   {pointer to About dialog's grafPort}  junk:      integer;                       {item hit returned by ModalDialog  }begintheDialog  :=  GetNewModalDialog (aboutDlg);               {create modal dialog}errNum     :=  ToolError;if errNum <> 0 then  HandleError (errNum, memoryErr, cautionAlertTyp)else begin                                           {call Dialog Mgr to detect}  junk    :=  ModalDialog (nil);                     {  user clicking OK button}                                                     {  use default filter proc}  errNum  :=  ToolError;  if errNum <> 0 then                               {only error is front window}     HandleError (errNum, fatalErr, stopAlertTyp)   {  not modal dialog!       }  else     CloseDialog (theDialog);  end;end;  {DoAbout}procedure WantToSave (index: integer; currWindow: grafPortPtr); forward;(************************************************** DoClose - Handle Close command.*************************************************)procedure DoClose (* index: integer; currWindow: grafPortPtr;                     var numWindows: integer *);var  tmp:   ctlRecHndl;  tePtr: teRecPtr;                               {pointer to textEdit control's}                                                 {  record for front window    }  flag:  integer;                                {flag containing dirty bit in }                                                 {  teRecord for front window  }beginEnableMItem (newID);                                 {can now create new window}EnableMItem (openID);                                {can now open a file      }{ Check if they want to save data before closing window.  Dereference       }{ textEdit control's handle in order to check if the dirty bit has been set }{ by Text Edit.  If it has, give user chance to save window before closing  }{ it.                                                                       }tmp    :=  textEdHandle [index];tePtr  :=  teRecPtr (tmp^);if (tePtr^.ctlFlag & isDirty) <> 0 then  WantToSave (index, currWindow);CloseWindow (currWindow);numWindows  :=  numWindows - 1;                {one less window open on desktop}{ If window allocated by Open command, free memory used by it. }if windowOpen [index] = fromFile then  DisposeHandle (pathHandle [index]);windowOpen [index]  :=  noWindow;        {free up slot in window tracking array}end; {DoClose}(************************************************* DoFind - Handle Find command.************************************************)procedure DoFind;beginend;(************************************************* DoPrint - Handle Print command.************************************************)procedure DoPrint (* index: integer; currWindow: grafPortPtr *);label 99;                                                          {error label}const  thruPrinting = $2209;                  {err code returned by TEPaintText when}                                         {  starting line # exceeds last line #}var  prPort:      grafPortPtr;                      {Print Manager's grafPort     }  currLine:    longint;                          {current line # to print      }  lastLine:    longint;                          {last line # to print         }  firstPage:   longint;                          {first page to begin printing }  finalPage:   longint;                          {final page to print          }  copies:      integer;                          {# copies of document to print}  spool:       boolean;                          {false = draft mode;          }                                                 {true = spooled printing      }  anError:     boolean;                          {true if error detected       }  printRecPtr: prRecPtr;                         {pointer to print record      }  tmp:         longint;  answer:      integer;beginanswer  :=  PrJobDialog (printHandle);          {bring up Print Job dialog     }errNum  :=  ToolError;                          {error returned by PrJobDialog?}if errNum <> 0 then begin  HandleError (errNum, memoryErr, cautionAlertTyp);  goto 99;  end;if answer = 0 then                                     {want to print document?}  goto 99;printRecPtr  :=  printHandle^;                 {dereference print record handle}{ Set up page rectangle based on printed page size calculated by Print Manager }{ as derived from Job and Page setup dialogs.                                  }with printRecPtr^ do begin  with prInfo.rPage do begin     prRect.v1  :=  v1;     prRect.h1  :=  h1;     prRect.v2  :=  v2;     prRect.h2  :=  h2;     end;  firstPage  :=  prJob.iFstPage;                  {get first page to print     }  currLine   :=  (firstPage - 1) * 60;            {calculate 1st line to print,}                                                  {  counting lines from 0, and}                                                  {  60 lines per page         }  prJob.iFstPage  :=  1;         {set page # to 1 for Print Manager, since it  }                                 {  counts ea. page it prints, starting at 1   }  finalPage  :=  prJob.iLstPage;                  {get last page to print      }  lastLine   :=  finalPage * 60;                  {calculate last line to print}  { Ensure that starting page number not greater than ending page}  tmp  :=  finalPage - firstPage;  if tmp < 0 then     goto 99;  prJob.iLstPage  :=  convert (tmp) .lsw + 1;     {reset last page to print for}                                                  { Print Mgr, relative to 1   }  copies     :=  prJob.iCopies;      {get # copies to print                    }  firstPage  :=  currLine;           {remember starting line # in case multiple}                                     { copies wanted and printing in draft mode}  { Determine whether printing in draft or spooled mode.}  if prJob.bJDocLoop = 0 then     spool  :=  false  else begin     spool  :=  true;     copies :=  1;                              {PrPicFile handles mult. copies}     end;  { Ensure starting line # is in document by calling Text Edit's }  { TEGetTextInfo to get # lines in document.                    }  TEGetTextInfo (textInfo, 2, textEdHandle [index]);  errNum  :=  ToolError;  if errNum <> 0 then begin     HandleError (errNum, getTextInfoErr, cautionAlertTyp);     goto 99;     end;  if currLine > textInfo.lineCount then     goto 99;  end;    {with printRecPtr}{ Call Print Manager to open the document for printing; get Print Manager's }{ printing grafPort.                                                        }anError  :=  false;{ Outer print loop, to print multiple copies in draft mode. }repeat  prPort  :=  PrOpenDoc (printHandle, nil);  errNum  :=  ToolError;  if errNum <> 0 then begin     HandleError (errNum, printErr, cautionAlertTyp);     anError  :=  true;     end  else begin     { Inner print loop, to print each page in the document. }     repeat        PrOpenPage (prPort, nil);      {init. grafPort, no scaling rect. passed}        errNum  :=  ToolError;        if errNum <> 0 then begin           HandleError (errNum, printErr, cautionAlertTyp);           anError  :=  true;           end        else begin           PenNormal;             {set pen to standard state                   }           MoveTo (0, 0);         {move to top left corner of drawing rectangle}           { Call TEPaintText to draw text into Print Manager's grafPort. }           currLine  :=  TEPaintText (prPort, currLine, prRect, 0,                                      textEdHandle [index]);           errNum    :=  ToolError;           if (errNum <> 0) and (errNum <> thruPrinting) then begin              HandleError (errNum, printErr, cautionAlertTyp);              anError  :=  true;              end;           end;   {no error from PrOpenPage}        PrClosePage (prPort);                       {close this printed page}        errNum  :=  ToolError;        if (errNum <> 0) and (not anError) then begin           HandleError (errNum, printErr, cautionAlertTyp);           anError  :=  true;           end;                                                        {end page-printing loop}     until (currLine = -1) or (currLine > lastLine) or (anError);     end; {no error from PrOpenDoc}  PrCloseDoc (prPort);                             {close document for printing}  errNum  :=  ToolError;  if (errNum <> 0) and (not anError) then begin     HandleError (errNum, printErr, cautionAlertTyp);     anError  :=  true;     end;  copies    :=  copies - 1;                             {one less copy to print}  currLine  :=  firstPage;                              {reset for next copy   }until (copies = 0) or (anError);                        {end print copies loop }{ Handle spooled printing. }if (spool) and (not anError) then begin  PrPicFile (printHandle, nil, @prStatus);          {let Print Mgr allocate new}                                                    {  grafPort for printing   }  errNum  :=  ToolError;  if errNum <> 0 then     HandleError (errNum, printErr, cautionAlertTyp);  end;SetPort (currWindow);                                {restore window's grafPort}99:end;(************************************************* DoPSetUp - Handle Page setUp command.************************************************)procedure DoPSetUp;var  junk: boolean;begin{ Bring up Page Setup dialog; throw away result since Print Manager handles }{ everything for us.                                                        }junk    :=  PrStlDialog (printHandle);errNum  :=  ToolError;if errNum <> 0 then  HandleError (errNum, memoryErr, cautionAlertTyp);end; {DoPSetUp}(************************************************* InitCmds1 - Initialize the Cmds1 unit's data*             structures.************************************************)function InitCmds1 (* : boolean *);label 99;beginInitCmds1  :=  true;{ Create print record.  First allocate memory to obtain handle to record, then }{ call the Print Manager to initialize it.  Attributes are locked, don't purge,}{ don't move.                                                                  }printHandle  :=  prHandle (NewHandle (140, myID, $C010, nil));errNum       :=  ToolError;if errNum <> 0 then begin  HandleError (errNum, memoryErr, stopAlertTyp);  InitCmds1  :=  false;  goto 99;  end;PrDefault (printHandle);errNum  :=  ToolError;if errNum <> 0 then begin  HandleError (errNum, fatalPrintErr, stopAlertTyp);  InitCmds1  :=  false;  goto 99;  end;{ *** GENERATED BY DESIGN MASTER, with comments by B.A. *** }with aboutDlg do begin  with dtBoundsRect do begin                               {Enclosing rectangle}     v1  :=  $002B;     h1  :=  $00C4;     v2  :=  $009C;     h2  :=  $01B9;  end;  dtVisible       :=  true;                        {Visiblilty flag            }  dtRefCon        :=  0;                           {RefCon, for application use}  dtItemList [1]  :=  @item00Abt1;                 {item pointer:  message     }  dtItemList [2]  :=  @item01Abt1;                 {item pointer:  OK button   }  dtItemList [3]  :=  nil;                         {null terminator            }end;with ITEM00Abt1 do begin                       {About dialog's static text item}  itemID  :=  $0064;                           {Item ID number                 }  with itemRect do begin                       {bounding rectangle             }     v1  :=  0004;     h1  :=  0008;     v2  :=  0072;     h2  :=  0241;  end;  itemType   :=  $800F;                                 {static text + disable }  itemDescr  :=  @item00pointerAbt1;                    {pointer to static text}  itemValue  :=  0093;                                  {length of text        }  itemFlag   :=  0;                                     {default flag          }  itemColor  :=  nil;                                   {pointer to color table}end;item00pointerAbt1  :=  '                  MiniWord';item00pointerAbt1  :=  concat (item00pointerAbt1, chr ($0D), chr ($0D));item00pointerAbt1  :=  concat (item00pointerAbt1, 'A simple text editor written');item00pointerAbt1  :=  concat (item00pointerAbt1, chr ($0D), 'by Barbara Allred and ');item00pointerAbt1  :=  concat (item00pointerAbt1, chr ($0D), 'Design Master', chr ($0D));with ITEM01Abt1 do begin                              {About dialog's OK button}  itemID  :=  $0001;  with itemRect do begin                              {bounding rectangle      }     v1  :=  0089;     h1  :=  0094;     v2  :=  0102;     h2  :=  0149;  end;  itemType  :=  $000A;                               {simple button            }  itemDescr  :=  @okTitle;                           {pointer to button's title}  itemValue  :=  0;  itemFlag   :=  $0001;                              {bold, round-cornered     }  itemColor  :=  @item01colorsAbt1;                  {ptr to button's color tbl}end;item01colorsAbt1 [0]  :=  $0010;           {button outline color               }item01colorsAbt1 [1]  :=  $00D0;           {interior color when not highlighted}item01colorsAbt1 [2]  :=  $0070;           {interior color when highlighted    }item01colorsAbt1 [3]  :=  $00E8;           {text color when not highlighted    }item01colorsAbt1 [4]  :=  $00B9;           {text color when highlighted        }with saveAlert do begin                              {WantToSave alert template}  with atBoundsRect do begin                         {bounding rectangle       }     v1  :=  $0028;     h1  :=  $009C;     v2  :=  $007A;     h2  :=  $017B;  end;  atAlertID  :=  2;                               {Alert ID number             }  atStage1   :=  $81;                             {stage 1: draw alert, 1 beep }  atStage2   :=  $81;                             {stage 2: draw alert, 1 beep }  atStage3   :=  $81;                             {stage 3: draw alert, 1 beep }  atStage4   :=  $81;                             {stage 4: draw alert, 1 beep }  atItemList [1]  :=  @item00Save1;               {item pointer:  Save message }  atItemList [2]  :=  @item01Save1;               {item pointer:  OK button    }  atItemList [3]  :=  @item02Save1;               {item pointer:  Cancel button}  atItemList [4]  :=  nil;                        {null terminator             }end;with ITEM00Save1 do begin                        {save alert's message template}  itemID  :=  $0064;  with itemRect do begin                         {bounding rectangle           }     v1  :=  37;     h1  :=  8;     v2  :=  47;     h2  :=  217;  end;  itemType   :=  $800F;                             {static text + item disable}  itemDescr  :=  @item00pointerSave1;               {pointer to text           }  itemValue  :=  28;                                {length of text            }  itemFlag   :=  0;                                 {default flag              }  itemColor  :=  nil;                               {no color table            }end;item00pointerSave1  :=  'Save changes before closing?';with ITEM01Save1 do begin                      {save alert's OK button template}  itemID  :=  1;  with itemRect do begin                       {bounding rectangle             }     v1  :=  62;     h1  :=  12;     v2  :=  75;     h2  :=  67;  end;  itemType   :=  $000A;                           {simple button               }  itemDescr  :=  @okTitle;                        {pointer to button's title   }  itemValue  :=  0;  itemFlag   :=  $0003;                           {bold, square-cornered button}  itemColor  :=  nil;                             {no color table              }end;with ITEM02Save1 do begin                  {save alert's Cancel button template}  itemID  :=  2;  with itemRect do begin                   {bounding rectangle                 }     v1  :=  62;     h1  :=  115;     v2  :=  75;     h2  :=  201;  end;  itemType   :=  $000A;                          {simple button                }  itemDescr  :=  @cancelTitle;                   {pointer to button's title    }  itemValue  :=  0;  itemFlag   :=  $0002;                          {plain, square-cornered button}  itemColor  :=  nil;                            {no color table               }end;99:end; {InitCmds1}(************************************************* WantToSave - Ask user if they'd like to save*              a file before closing its window.************************************************)procedure WantToSave (* index: integer, currWindow: grafPortPtr *);var  result: integer;begin{ Bring up want-to-save alert.  If user selects OK button, call DoSave to }{ save the window to disk.                                                }if (NoteAlert (saveAlert, nil)) = 1 then  DoSave (index, currWindow);end; {WantToSave}end. {Cmds1 unit}