{$keep 'main'}program MiniWord;{---------------------------------------------------------------}{                                                               }{ MiniWord - A simple text editor                               }{                                                               }{ Written by Barbara Allred and Design Master                   }{                                                               }{ Copyright 1990                                                }{ Byte Works, Inc.                                              }{                                                               }{---------------------------------------------------------------}uses  Common, MemoryMgr, ToolLocator, QuickDrawII, EventMgr, WindowMgr,  ControlMgr, MenuMgr, DialogMgr, DeskMgr, PrintMgr, IntegerMath,  TextEdit, GSOS;{$LibPrefix '0/'}uses  Globals, Error, Cmds1, Cmds2;var  { *** DATA STRUCTURES GENERATED BY DESIGN MASTER, and altered by B.A. *** }  {                                                                         }  { Note:  Design Master will generate the type "pString" instead of        }  {        "packed array of char."  These have been changed to use          }  {        less space.                                                      }  dropmenutitle01: packed array [0..20] of char;               {menu titles}  dropmenutitle02: packed array [0..20] of char;  dropmenutitle03: packed array [0..20] of char;  dropmenutitle04: packed array [0..20] of char;  menu01itemtitle00: packed array [0..20] of char;          {menu item titles}  menu02itemtitle00: packed array [0..20] of char;  menu02itemtitle01: packed array [0..20] of char;  menu02itemtitle02: packed array [0..20] of char;  menu02itemtitle03: packed array [0..20] of char;  menu02itemtitle04: packed array [0..20] of char;  menu02itemtitle05: packed array [0..20] of char;  menu02itemtitle06: packed array [0..20] of char;  menu02itemtitle07: packed array [0..20] of char;  menu03itemtitle00: packed array [0..20] of char;  menu03itemtitle01: packed array [0..20] of char;  menu03itemtitle02: packed array [0..20] of char;  menu04itemtitle00: packed array [0..20] of char;  menu01: menuTemplate;  menu02: menuTemplate;  menu03: menuTemplate;  menu04: menuTemplate;  menu01item00: menuItemTemplate;  menu02item00: menuItemTemplate;  menu02item01: menuItemTemplate;  menu02item02: menuItemTemplate;  menu02item03: menuItemTemplate;  menu02item04: menuItemTemplate;  menu02item05: menuItemTemplate;  menu02item06: menuItemTemplate;  menu02item07: menuItemTemplate;  menu03item00: menuItemTemplate;  menu03item01: menuItemTemplate;  menu03item02: menuItemTemplate;  menu04item00: menuItemTemplate;  { Our data structures, global to main. }  masterID:      integer;                             {user ID passed by loader}  startStopAddr: longint;  startStopRec:  startStopRecord;             {GS/OS 5.0 1-stop load tools call}function MyWindow (var index: integer; var currWindow: grafPortPtr;                   numWindows: integer): boolean; forward;(************************************************* DoQuit - Handle Quit command.************************************************)procedure DoQuit (var done: boolean; var index, numWindows: integer;                  var currWindow: grafPortPtr);beginwhile (MyWindow (index, currWindow, numWindows)) do     {close all open windows}  DoClose (index, currWindow, numWindows);done  :=  true;                                              {set the done flag}end;{ Forward declarations of local subroutines that EventLoop calls. }procedure HandleMenu (menuData: longint; var index, numWindows: integer;                      var currWindow: grafPortPtr; var done: boolean); forward;procedure HandleSpecial (menuData: longint; var index, numWindows: integer;                         var currWindow: grafPortPtr); forward;procedure HandleUpdate (theWindow: grafPortPtr); forward;(************************************************* EventLoop - Get next event, then dispatch the*             appropriate routine to handle it.************************************************)procedure EventLoop;{const}                                     {Event codes returned by TaskMaster}  { inButtDwn      =   $0001;  }        {button down event                     }  { mouseUpEvt     =   $0002;  }        {button up event                       }  { inKey          =   $0003;  }        {keystroke event                       }  { autoKeyEvt     =   $0005;  }        {auto key event:  key held down by user}  { inUpdate       =   $0006;  }        {update event                          }  { activateEvt    =   $0008;  }        {activate event                        }  { switchEvt      =   $0009;  }        {switch event                          }  { deskAccEvt     =   $000A;  }        {desk accessory event                  }  { driverEvt      =   $000B;  }        {driver event                          }  { app1Evt        =   $000C;  }        {application 1 event                   }  { app2Evt        =   $000D;  }        {application 2 event                   }  { app3Evt        =   $000E;  }        {application 3 event                   }  { app4Evt        =   $000F;  }        {application 4 event                   }  { wInDesk        =   $0010;  }        {On Desktop                            }  { wInMenuBar     =   $0011;  }        {On system menu bar                    }  { wClickCalled   =   $0012;  }        {system click called                   }  { wInContent     =   $0013;  }        {In content region                     }  { wInDrag        =   $0014;  }        {In drag region                        }  { wInGrow        =   $0015;  }        {In grow region, active window only    }  { wInGoAway      =   $0016;  }        {In go-away region, active window only }  { wInZoom        =   $0017;  }        {In zoom region, active window only    }  { wInInfo        =   $0018;  }        {In information bar                    }  { wInSpecial     =   $0019;  }        {Item ID selected was 250 - 255        }  { wInDeskItem    =   $001A;  }        {Item ID selected was 1 - 249          }  { wInFrame       =   $001B;  }        {in Frame, but not on anything else    }  { wInactMenu     =   $001C;  }        {"selection" of inactive menu item     }  { wClosedNDA     =   $001D;  }        {desk accessory closed                 }  { wCalledSysEdit =   $001E;  }        {inactive menu item selected           }  { wTrackZoom     =   $001F;  }        {zoom box clicked, but not selected    }  { wHitFrame      =   $0020;  }        {button down on frame, made active     }  { wInControl     =   $0021;  }        {button or keystroke in control        }  { wInSysWindow   =   $8000;  }        {hi bit set for system windows         }var   numWindows: integer;                    {# of currently open windows        }   index:      integer;                    {window arrays index, active window }   currWindow: grafPortPtr;                {current active window              }   taskRecord: wmTaskRec;                  {used to communicate with TaskMaster}   eventCode:  integer;                    {returned by TaskMaster             }   i:          integer;begindone  :=  false;                                            {we aint done yet  }for i := 0 to 3 do                                          {no window open yet}  windowOpen [i]  :=  noWindow;numWindows  :=  0;index       :=  0;taskRecord.taskMask  :=  $001FBFFF;       {let TaskMaster do almost everything }while not (done) do begin                   {execute event loop 'til we're done}  { Call TaskMaster to get next event we need to handle. }  eventCode  :=  TaskMaster ($076E,         {event mask = just about everything}                             taskRecord);   {pointer to extended task record   }  errNum  :=  ToolError;  if errNum <> 0 then                                      {only error possible}      HandleError (errNum, fatalErr, stopAlertTyp)         {  is messing up    }                                                           {  wmTaskMask field }  { Window update event? }  else if eventCode = inUpdate then     HandleUpdate (grafPortPtr (taskRecord.taskData))  { Cut, copy, paste, or close command? }  else if eventCode = wInSpecial then     HandleSpecial (taskRecord.taskData, index, numWindows, currWindow)  { Did user click in close box? }  else if eventCode = wInGoAway then begin     if MyWindow (index, currWindow, numWindows) then        DoClose (index, currWindow, numWindows)     end  { Non-special command? }  else if eventCode = wInMenuBar then     HandleMenu (taskRecord.taskData, index, numWindows, currWindow, done)  end  {while not done}end;  {EventLoop}(************************************************* HandleMenu - Handle menu selections, menu IDs*              256 ->.************************************************)procedure HandleMenu (* menuData: longint; var index, numWindows: integer;                        var currWindow: grafPortPtr; var done: boolean *);type  menuIDs = 256..264;var  theItem: menuIDs;  menuNum: integer;begin{ Menu item ID is in low-order word of the taskData field of our task record. }{ Menu ID is in the high-order word of the field.                             }theItem  :=  convert (menuData) .lsw;menuNum  :=  convert (menuData) .msw;{ Dispatch the appropriate routine, based on menu item selected. }case theItem of  aboutID:    DoAbout;  newID:      DoNew (index, numWindows);  openID:     DoOpen (index, numWindows);  saveID:     if MyWindow (index, currWindow, numWindows) then                 DoSave (index, currWindow);  saveAsID:   if MyWindow (index, currWindow, numWindows) then                 DoSaveAs (index, currWindow);  pSetUpID:   DoPSetUp;  printID:    if MyWindow (index, currWindow, numWindows) then                 DoPrint (index, currWindow);  quitID:     DoQuit (done, index, numWindows, currWindow);  findID:     DoFind;  end;{ Unhighlight the menu they just pulled down. }HiliteMenu (false, menuNum);end;(************************************************* HandleSpecial - Handle special menu commands,*                 menu IDs 250 - 255.************************************************)procedure HandleSpecial (* menuData: longint; var index, numWindows: integer;                           var currWindow: grafPortPtr *);var   theItem: integer;   menuNum: integer;begin{ Menu item ID is in low-order word of the taskData field of our task record. }{ Menu ID is in the high-order word of the field.                             }theItem  :=  convert (menuData) .lsw;menuNum  :=  convert (menuData) .msw;{ Close command selected?  All other special items handled by TaskMaster. }if theItem = closeID then  if MyWindow (index, currWindow, numWindows) then     DoClose (index, currWindow, numWindows);{ Unhighlight the menu they just pulled down. }HiliteMenu (false, menuNum);end; {HandleSpecial}(************************************************* HandleUpdate - Handle update event for active*                window.************************************************)procedure HandleUpdate (* theWindow: grafPortPtr *);beginBeginUpdate  (theWindow);DrawControls (theWindow);EndUpdate    (theWindow);end;procedure InitMenus; forward;(************************************************* Init - Initialize all global variables, start*        the tools we need, create our menu bar.** Output:*      Returns true if everything started OK,*      and false otherwise.************************************************)function Init: boolean;label 99;var  ok: boolean;begin{ Initialize all global variables. }Init      :=  true;                       {assume all is well to start with    }masterID  :=  userID;                     {get user ID passed by loader        }myID      :=  masterID | $0200;           {alter for our purposes, so we can do}                                          {  a simple DisposeAll at the end    }{ Start tools we need:  Use GS/OS 5.0 one-call startup mechanism. }with startStopRec do begin  flags      :=  0;                                      {flags must be zero  }  videoMode  :=  $80;                                    {640 mode            }  numTools   :=  22;                                     {we'll start 22 tools}  toolArray [1].toolNumber  :=  $01;         {Tool Locator}  toolArray [1].minVersion  :=  $0100;  toolArray [2].toolNumber  :=  $02;         {Memory Manager}  toolArray [2].minVersion  :=  $0100;  toolArray [3].toolNumber  :=  $03;         {Miscellaneous Toolset}  toolArray [3].minVersion  :=  $0300;  toolArray [4].toolNumber  :=  $04;         {Quick Draw II}  toolArray [4].minVersion  :=  $0300;  toolArray [5].toolNumber  :=  $06;         {Event Manager}  toolArray [5].minVersion  :=  $0300;  toolArray [6].toolNumber  :=  $0E;         {Window Manager}  toolArray [6].minVersion  :=  $0300;  toolArray [7].toolNumber  :=  $10;         {Control Manager}  toolArray [7].minVersion  :=  $0300;  toolArray [8].toolNumber  :=  $0F;         {Menu Manager}  toolArray [8].minVersion  :=  $0300;  toolArray [9].toolNumber  :=  $14;         {LineEdit Toolset}  toolArray [9].minVersion  :=  $0100;  toolArray [10].toolNumber :=  $15;         {Dialog Manager}  toolArray [10].minVersion :=  $0100;  toolArray [11].toolNumber :=  $08;         {Sound Manager}  toolArray [11].minVersion :=  $0100;  toolArray [12].toolNumber :=  $17;         {Standard File Operations Toolset}  toolArray [12].minVersion :=  $0100;  toolArray [13].toolNumber :=  $16;         {Scrap Manager}  toolArray [13].minVersion :=  $0104;  toolArray [14].toolNumber :=  $09;         {Apple Desktop Bus Toolset}  toolArray [14].minVersion :=  $0100;  toolArray [15].toolNumber :=  $05;         {Desk Manager}  toolArray [15].minVersion :=  $0100;  toolArray [16].toolNumber :=  $1C;         {List Manager}  toolArray [16].minVersion :=  $0100;  toolArray [17].toolNumber :=  $1B;         {Font Manager}  toolArray [17].minVersion :=  $0204;  toolArray [18].toolNumber :=  $13;         {Print Manager}  toolArray [18].minVersion :=  $0100;  toolArray [19].toolNumber :=  $12;         {Quick Draw II Auxiliary}  toolArray [19].minVersion :=  $0206;  toolArray [20].toolNumber :=  $0A;         {SANE Toolset}  toolArray [20].minVersion :=  $0100;  toolArray [21].toolNumber :=  $0B;         {Integer Math Toolset}  toolArray [21].minVersion :=  $0100;  toolArray [22].toolNumber :=  $22;         {Text Edit Toolset}  toolArray [22].minVersion :=  $0100;  end;startStopAddr  :=  StartUpTools (masterID, pointerVerb, ord4 (@startStopRec));errNum         :=  ToolError;if errNum <> 0 then begin  Init  :=  false;  goto 99;  end;{ Initialize our units. }okTitle      :=  'OK';cancelTitle  :=  'Cancel';InitError;if not (InitCmds1) then begin  Init  :=  false;  goto 99;  end;if not (InitCmds2) then begin  Init  :=  false;  goto 99;  end;InitMenus;InitCursor;                            {StartUpTools brings up the watch cursor}                                       {  so change it to the arrow            }99:end;(************************************************* InitMenus - Initialize the menu bar.************************************************)procedure InitMenus;var  tmp: longint;  i:   integer;begin{ *** GENERATED BY DESIGN MASTER, with comments provided by B.A. *** }dropmenutitle01  :=  '@';                                           {Apple menu}with menu01 do begin  version       :=  0;  menuID        :=  $0001;  menuFlag      :=  $0008;                  {cache menu; will pass ptr to title}  menuTitleRef  :=  ord4 (@dropMenuTitle01);           {pointer to menu's title}  itemRefs [1]  :=  ord4 (@menu01item00);              {About item reference   }  itemRefs [2]  :=  0;                                 {null terminator        }end;menu01itemtitle00  :=  'About';with menu01item00 do begin  version       :=  0;  itemID        :=  256;                                   {About ID           }  itemChar      :=  $00;                                   {shortcut characters}  itemAltChar   :=  $00;  itemCheck     :=  $0000;  itemFlag      :=  $0041;                         {bold, divider beneath, will}                                                   {  pass pointer to title    }  itemTitleRef  :=  ord4 (@menu01itemtitle00);          {pointer to item's name}end;dropmenutitle02  :=  ' File ';with menu02 do begin  version       :=  0;  menuID        :=  $0002;  menuFlag      :=  $0008;                  {cache menu; will pass ptr to title}  menuTitleRef  :=  ord4 (@dropMenuTitle02);       {pointer to menu's title    }  itemRefs [1]  :=  ord4 (@menu02item00);          {item reference:  New       }  itemRefs [2]  :=  ord4 (@menu02item01);          {item reference:  Open      }  itemRefs [3]  :=  ord4 (@menu02item02);          {item reference:  Close     }  itemRefs [4]  :=  ord4 (@menu02item03);          {item reference:  Save      }  itemRefs [5]  :=  ord4 (@menu02item04);          {item reference:  Save as   }  itemRefs [6]  :=  ord4 (@menu02item05);          {item reference:  Page setup}  itemRefs [7]  :=  ord4 (@menu02item06);          {item reference:  Print     }  itemRefs [8]  :=  ord4 (@menu02item07);          {item reference:  Quit      }  itemRefs [9]  :=  0;                             {null terminator            }end;menu02itemtitle00  :=  'New';with menu02item00 do begin  version       :=  0;  itemID        :=  257;                                   {new ID             }  itemChar      :=  $4E;                                   {shortcut characters}  itemAltChar   :=  $6E;  itemCheck     :=  $0000;  itemFlag      :=  $0000;                          {will pass pointer to title}  itemTitleRef  :=  ord4 (@menu02itemtitle00);      {pointer to item's name    }end;menu02itemtitle01  :=  'Open...';with menu02item01 do begin  version       :=  0;  itemID        :=  258;                                   {open ID            }  itemChar      :=  $4F;                                   {shortcut characters}  itemAltChar   :=  $6F;  itemCheck     :=  $0000;  itemFlag      :=  $0000;                          {will pass pointer to title}  itemTitleRef  :=  ord4 (@menu02itemtitle01);      {pointer to item's name    }end;menu02itemtitle02  :=  'Close';with menu02item02 do begin  version       :=  0;  itemID        :=  255;                                   {close ID           }  itemChar      :=  $57;                                   {shortcut characters}  itemAltChar   :=  $77;  itemCheck     :=  $0000;  itemFlag      :=  $0000;                          {will pass pointer to title}  itemTitleRef  :=  ord4 (@menu02itemtitle02);      {pointer to item's name    }end;menu02itemtitle03  :=  'Save';with menu02item03 do begin  version       :=  0;  itemID        :=  259;                                   {save ID            }  itemChar      :=  $53;                                   {shortcut characters}  itemAltChar   :=  $73;  itemCheck     :=  $0000;  itemFlag      :=  $0000;                          {will pass pointer to title}  itemTitleRef  :=  ord4 (@menu02itemtitle03);      {pointer to item's name    }end;menu02itemtitle04  :=  'Save as...';with menu02item04 do begin  version       :=  0;  itemID        :=  260;                                   {save as ID         }  itemChar      :=  $00;                                   {shortcut characters}  itemAltChar   :=  $00;  itemCheck     :=  $0000;  itemFlag      :=  $0040;                          {will pass pointer to title}                                                    {  draw divider beneath    }  itemTitleRef  :=  ord4 (@menu02itemtitle04);      {pointer to item's name    }end;menu02itemtitle05  :=  'Page setup...';with menu02item05 do begin  version       :=  0;  itemID        :=  261;                                   {page setup ID      }  itemChar      :=  $00;                                   {shortcut characters}  itemAltChar   :=  $00;  itemCheck     :=  $0000;  itemFlag      :=  $0000;                          {will pass pointer to title}  itemTitleRef  :=  ord4 (@menu02itemtitle05);      {pointer to item's name    }end;menu02itemtitle06  :=  'Print...';with menu02item06 do begin  version       :=  0;  itemID        :=  262;                                   {print ID           }  itemChar      :=  $50;                                   {shortcut characters}  itemAltChar   :=  $70;  itemCheck     :=  $0000;  itemFlag      :=  $0040;                          {will pass pointer to title}                                                    {  divider beneath         }  itemTitleRef  :=  ord4 (@menu02itemtitle06);      {pointer to item's name    }end;menu02itemtitle07  :=  'Quit';with menu02item07 do begin  version       :=  0;  itemID        :=  263;                                   {quit ID            }  itemChar      :=  $51;                                   {shortcut characters}  itemAltChar   :=  $71;  itemCheck     :=  $0000;  itemFlag      :=  $0000;                          {will pass pointer to title}  itemTitleRef  :=  ord4 (@menu02itemtitle07);      {pointer to item's name    }end;dropmenutitle03  :=  ' Edit ';with menu03 do begin  version       :=  0;  menuID        :=  $0003;  menuFlag      :=  $0008;                  {cache menu; will pass ptr to title}  menuTitleRef  :=  ord4 (@dropmenutitle03);       {pointer to menu's title    }  itemRefs [1]  :=  ord4 (@menu03item00);          {item reference:  Cut       }  itemRefs [2]  :=  ord4 (@menu03item01);          {item reference:  Copy      }  itemRefs [3]  :=  ord4 (@menu03item02);          {item reference:  Paste     }  itemRefs [4]  :=  0;                             {null terminator            }end;menu03itemtitle00  :=  'Cut';with menu03item00 do begin  version       :=  0;  itemID        :=  251;                                   {cut ID             }  itemChar      :=  $58;                                   {shortcut characters}  itemAltChar   :=  $78;  itemCheck     :=  $0000;  itemFlag      :=  $0000;                          {will pass pointer to title}  itemTitleRef  :=  ord4 (@menu03itemtitle00);      {pointer to item's name    }end;menu03itemtitle01  :=  'Copy';with menu03item01 do begin  version       :=  0;  itemID        :=  252;                                   {copy ID            }  itemChar      :=  $43;                                   {shortcut characters}  itemAltChar   :=  $63;  itemCheck     :=  $0000;  itemFlag      :=  $0000;                          {will pass pointer to title}  itemTitleRef  :=  ord4 (@menu03itemtitle01);      {pointer to item's name    }end;menu03itemtitle02  :=  'Paste';with menu03item02 do begin  version       :=  0;  itemID        :=  253;                                   {paste ID           }  itemChar      :=  $56;                                   {shortcut characters}  itemAltChar   :=  $76;  itemCheck     :=  $0000;  itemFlag      :=  $0000;                          {will pass pointer to title}  itemTitleRef  :=  ord4 (@menu03itemtitle02);      {pointer to item's name    }end;dropmenutitle04  :=  ' Search ';with menu04 do begin  version       :=  0;  menuID        :=  $0004;  menuFlag      :=  $0008;                  {cache menu; will pass ptr to title}  menuTitleRef  :=  ord4 (@dropmenutitle04);       {pointer to menu's title    }  itemRefs [1]  :=  ord4 (@menu04item00);          {Find item reference        }  itemRefs [2]  :=  0;                             {null terminator            }end;menu04itemtitle00  :=  'Find...';with menu04item00 do begin  version       :=  0;  itemID        :=  264;                                   {find ID            }  itemChar      :=  $46;                                   {shortcut characters}  itemAltChar   :=  $66;  itemCheck     :=  $0000;  itemFlag      :=  $0000;                          {will pass pointer to title}  itemTitleRef  :=  ord4 (@menu04itemtitle00);      {pointer to item's name    }end;{ The rest of the code is this procedure is ours.                              }{ Create the menu bar.  Start at the last menu, since we're inserting each new }{ menu at the front of the current menu list.                                  }tmp  :=  ord4 (@menu04);   InsertMenu (NewMenu2 (pointerVerb, tmp), 0);tmp  :=  ord4 (@menu03);   InsertMenu (NewMenu2 (pointerVerb, tmp), 0);tmp  :=  ord4 (@menu02);   InsertMenu (NewMenu2 (pointerVerb, tmp), 0);tmp  :=  ord4 (@menu01);   InsertMenu (NewMenu2 (pointerVerb, tmp), 0);FixAppleMenu (1);               {add desk accessories to Apple menu           }i  :=  FixMenuBar;              {compute standard sizes for menu bar and menus}                                {  throw away returned height                 }DrawMenuBar;end; {InitMenus}(************************************************* MyWindow - Checks if front window is one of ours.** Output:*        true if it's one of ours; false otherwise************************************************)function MyWindow (* var index: integer; var currWindow: grafPortPtr;                     numWindows: integer): boolean *);label 99;var  systemWind: boolean;             {true if the front window is a system window}  tmp:        grafPortPtr;  tmp2:       longint;beginMyWindow  :=  true;                            {assume the front window is ours}{ First check if any windows are open. }if numWindows = 0 then begin  MyWindow  :=  false;  goto 99;  end;{ Now check if the window is one of ours. }tmp         :=  FrontWindow;             {get grafPort pointer of active window}systemWind  :=  GetSysWFlag (tmp);               {active window belong to desk }                                                 {  accessory?                 }if systemWind then begin                         {Yes - MyWindow is false, exit}  MyWindow  :=  false;  goto 99;  end;{ It's one of ours, so get index into window arrays from wRefCon field. }tmp2        :=  GetWRefCon (tmp);index       :=  convert (tmp2) .lsw;currWindow  :=  tmp;99:end;(************************************************* ShutDown - Unload the tools we started.************************************************)procedure ShutDown;beginDisposeAll (myID);                          {dispose of all memory we allocated}ShutDownTools (pointerVerb, startStopAddr);         {shut down tools we started}errNum  :=  ToolError;if errNum <> 0 then   HandleError (errNum, fatalErr, stopAlertTyp);end;(************************************************* Main program*************************************************)beginif Init then                                    {start tools, bring up menu bar}   EventLoop;                                   {execute main event loop       }ShutDown;                                       {unload tools                  }end.