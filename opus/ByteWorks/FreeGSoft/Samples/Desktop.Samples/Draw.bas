!---------------------------------------------------------------!!  Draw 1.0!!  Draw is a (very) simple CAD program based on the Frame!  program.  With Draw, you can open new windows, close!  windows that are on the desktop, and draw lines using the!  mouse.  Multiple windows are supported.!!  Mike Westerfield!!  Copyright 1998!  Byte Works, Inc.!!---------------------------------------------------------------pragma autodim= offconst return% = 13			: ! return key codeconst Apple_About%   = 257		: ! Menu ID #sconst File_Quit%     = 256const File_New%      = 258const File_Close%    = 255const maxWindows%   = 4		: ! max # of drawing windows + 1const maxLines%     = 50		: ! max # of lines in a window + 1const norml%   = 0			: ! kinds of alertsconst stop%    = 2const note%    = 3const caution% = 4type lineRec				: ! one line in the window   p1 as point   p2 as pointend typetype windowRecord			: ! holds all info about one window   wPtr as grafPortPtr		: ! pointer to the window's port   draw as procPtr			: ! tool glue for DrawWindow   wName as string			: ! name of the window   numLines as integer		: ! number of lines in this window   lines(maxLines%) as lineRec	: ! lines in the drawingend typedim done as integer			: ! tells if the program should stopdim event as integer                  : ! event #; returned by TaskMasterdim lastEvent as eventRecord          : ! last event returned in event loopdim startStopParam as long		: ! tool startup/shutdown informationdim windows(maxWindows%) as windowRecord : ! drawing windows! Initialize the programstartStopParam = StartupTools(MMStartup, 2, clng(1))if ToolError <> 0 then   print "Could not start the tools! ToolError = ";ToolError   stopend ifcall InitMenuscall InitWindowslastEvent.taskMask = $1FFFShowCursorInitCursor! Main event loopdone = 0while not done   event = TaskMaster($076E, lastEvent)   select case event      case wInSpecial, wInMenuBar         call HandleMenu(lastEvent.taskData)      case wInGoAway         call DoClose      case wInContent         call Sketch   end selectwendShutDownTools(1, startStopParam)end!---------------------------------------------------------------!! DoAlert - handle an alert box!! Parameters:!     kind - kind of alert!     msg - alert message!!---------------------------------------------------------------SUB DoAlert (kind as integer, msg as string)dim alertString as string		: ! alert stringdim button as integer			: ! number of the button pressedalertString = "5" + chr$(asc("0" + kind)) + "/" + msg + "/^OK"button = AlertWindow(0, NIL, @alertString);END SUB!---------------------------------------------------------------!! DoClose - Close the front drawing window (if there is one).! ! Shared:!	File_New% - menu ID number for New in the File menu!	windows - array of our windows!!---------------------------------------------------------------SUB DoCloseshared File_New%			: ! menu ID number for New in the File menushared windows()			: ! array of windowsdim i as integer			: ! index variableif FrontWindow <> nil then   i = GetWRefCon(FrontWindow)   CloseWindow(windows(i).wPtr)   windows(i).wPtr = nil   EnableMItem(File_New%)end ifEND SUB!---------------------------------------------------------------!! DoNew - Open a drawing window.! ! Shared:!	File_New% - menu ID number for New in the File menu!	maxWindows% - max # of drawing windows + 1!	windows - array of our windows!!---------------------------------------------------------------SUB DoNewconst wrNum = 1001			: ! window resource numbershared File_New%			: ! menu ID number for New in the File menushared maxWindows%			: ! max # of drawing windows + 1shared windows()			: ! array of windowsdim i as integer			: ! index variabledim foundOne as boolean		: ! have we found an available window record?! find an empty recordi = 0while windows(i).wPtr <> nil   i = i + 1wend! initialize the recordwindows(i).numLines = 0windows(i).draw = AllocateProc(DrawWindow)if windows(i).draw <> nil then   windows(i).wPtr = NewWindow2(pStringPtr(@windows(i).wName), i, windows(i).draw, nil, $02, wrNum, rWindParam1)   if ToolError <> 0 then	windows(i).wPtr = nil      DisposeSub(windows(i).draw   end ifend if! flag an error if one occurredif windows(i).wPtr = nil then  DoAlert(stop, "Error opening the window.")end if! don't allow more than maxWindows% + 1 open windows (0 is valid)foundOne = falsefor i = 0 to maxWindows%   if windows(i).wPtr = nil then      foundOne = true   end ifnextif not foundOne then   DisableMItem(File_New%)end ifEND SUB!---------------------------------------------------------------!!  DrawWindow - Draw the contents of the current window.! ! Shared:!	windows - array of our windows!!---------------------------------------------------------------SUB DrawWindowshared windows()			: ! array of windowsdim i as integer			: ! window's indexdim j as integer			: ! loop variablei = GetWRefCon(GetPort)if windows(i).numLines <> 0 then   SetPenMode(modeCopy)   SetSolidPenPat(0)   SetPenSize(2, 1)   for j = 0 to windows(i).numLines - 1      MoveTo(windows(i).lines(j).p1.h, windows(i).lines(j).p1.v)      LineTo(windows(i).lines(j).p2.h, windows(i).lines(j).p2.v)   nextend ifEND SUB!---------------------------------------------------------------!! InitMenus - Initialize the menu bar.! !---------------------------------------------------------------SUB InitMenusconst menuID% = 1			: ! menu bar resource IDdim height as integer			: ! height of the largest menudim m as menuBarHandle		: ! our menu bar's handle! create the menu barm = NewMenuBar2(2, 1, NIL)SetSysBar(ctlRecHndl(m))SetMenuBar(NIL)! add desk accessoriesFixAppleMenu(1)! draw the completed menu barheight = FixMenuBarDrawMenuBarEND SUB!---------------------------------------------------------------!! InitWindows - Initialize the window records.!! Shared:!	windows - array of our windows!	maxWindows% - max # of drawing windows + 1!!---------------------------------------------------------------SUB InitWindowsshared windows()			: ! array of windowsshared maxWindows%			: ! max # of drawing windows + 1dim i as integer			: ! loop variabledim wName as string			: ! name of a windowfor i = 0 to maxWindows%   windows(i).wPtr = nil   wName = " Draw " + chr$(asc("1") + i) + " "   windows(i).wName = chr$(len(wName)) + wNamenextEND SUB!---------------------------------------------------------------!! HandleMenu - Handle a menu selection.!! Parameters:!	taskData - taskData field for the menu event!! Shared:!	done - event loop done flag!	Apple_?? and File_?? - menu ID numbers!!---------------------------------------------------------------SUB HandleMenu (taskData as long)shared Apple_About%			: ! Menu ID #sshared File_Quit%shared File_New%shared File_Close%shared doneselect case LoWord(taskData)   case Apple_About%      call MenuAbout   case File_Quit%      done = 1   case File_New%      call DoNew   case File_Close%      call DoClose   end selectHiliteMenu(0, HiWord(taskData))END SUB!---------------------------------------------------------------!! MenuAbout - Show About alert box.!!---------------------------------------------------------------SUB MenuAboutconst alertID% = 1			: ! alert resource IDdim b as integer			: ! button pushedb = AlertWindow(5, NIL, alertID%)END SUB!---------------------------------------------------------------!! Sketch - Track the mouse, drawing lines to connect the points.!! Shared:!	lastEvent - last event returned in event loop!	maxLines% - max # of lines in a window + 1!	windows - array of our windows!!---------------------------------------------------------------SUB Sketchshared lastEvent			: ! last event returned in event loopshared maxLines%			: ! max # of lines in a window + 1shared windows()			: ! array of windowsdim endPoint as point			: ! the end point of the linedim firstPoint as point		: ! the initial pointdim i as integer			: ! window indexdim numLines as integer		: ! copy of windows(i).numLinesdim sEvent as eventRecord		: ! last event returned in event loopdim msg as string			: ! for error messages! get the window's indexi = GetWRefCon(FrontWindow)! check for too many linesif windows(i).numLines = maxLines% then    msg = "The window is full - " + chr$(return)   msg = msg + "more lines cannot be " + chr$(return)   msg = msg + "added."   DoAlert(stop, msg);else   ! initialize the pen   SetPort(windows(i).wPtr)   SetSolidPenPat(15)   SetPenSize(2, 1)   SetPenMode(modeXOR)   ! record the initial pen location   firstPoint = lastEvent.eventWhere   GlobalToLocal(firstPoint)   MoveTo(firstPoint.h, firstPoint.v)   LineTo(firstPoint.h, firstPoint.v)   endPoint = firstPoint   ! follow the pen, rubber-banding the line   while not GetNextEvent(mUpMask, sEvent)	GlobalToLocal(sEvent.eventWhere)      if (endPoint.h <> sEvent.eventWhere.h) or (endPoint.v <> sEvent.eventWhere.v) then         MoveTo(firstPoint.h, firstPoint.v)         LineTo(endPoint.h, endPoint.v)         MoveTo(firstPoint.h, firstPoint.v)         endPoint.h = sEvent.eventWhere.h         endPoint.v = sEvent.eventWhere.v         LineTo(endPoint.h, endPoint.v)      end if   wend   ! erase the last XORed line   MoveTo(firstPoint.h, firstPoint.v)   LineTo(endPoint.h, endPoint.v)   ! if we have a line (not a point), record it in the window's line list   if (firstPoint.h <> endPoint.h) or (firstPoint.v <> endPoint.v) then      numLines = windows(i).numLines      windows(i).numLines = numLines + 1      windows(i).lines(numLines).p1 = firstPoint      windows(i).lines(numLines).p2 = endPoint	SetPenMode(modeCopy)	SetSolidPenPat(0)	MoveTo(firstPoint.h, firstPoint.v)	LineTo(endPoint.h, endPoint.v)   end ifend ifEND SUB