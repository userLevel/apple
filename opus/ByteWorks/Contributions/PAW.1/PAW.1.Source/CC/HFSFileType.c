 /*	HFSFileType : Change the Type and Creator of a Mac HFS file.			      Also displays the old values as char and hex.	Syntax	: HFSFileType filename {new_type new_creator}			  If type & creator are missing, the old values are displayed only.			  'type' and 'creator' are 4-byte case sensitive values, blank              padded on the right to 4 bytes if necessary.              If type or creator begins with a '$', the value is treated as hex,              with '$00' padding on the *left*!              Wildcards are supported for the filename.			  V1.0  Copyright by Peter Watson, Sep 1992.*/#include <types.h>#include <stdio.h>#include <stdlib.h>#include <orca.h>#include <shell.h>#define __PRODOS__		/* Shorten GSOS defines */#include <gsos.h>#include <string.h>#define debug 0  		/* 25 = stack check + trace back + range checking */#pragma lint -1#pragma expand 0#define VER    "1.0"char *helloMsg = \  "\nHFS File Type/Creator Updater v" VER "  Copyright 1992 by Peter Watson\n";void exit(int);							/* Library 'exit' function			*/void stripQuotes(char *);				/* Strip quotes from a parameter	*/char *chk(char);						/* Ensure character is printable	*/char getKey(void);						/* Better console getchar()			*/extern int STOP_PAUSE(void);			/* Pause on keypress or <oa-.>		*/word GetSet_Info(char *, boolean);		/* Get & optionally set type/creator	*/char wildFile[128];               		/* Wildcard filename buffer			*/struct wild {char *namePtr;				/* Pointer to the pathname			*/        int   flags;                    /* Flags: '?' valid; use all files	*/        } wildParm = {NULL,0};          /* INIT_WILDCARD parm list			*/VersionRecGS	vRec		= {1, 0};				/* For GetVersionGS req	*/FileInfoRecGS	iRec		= {12,};				/* For Get/SetFileInfo 	*/GSString255		GSfileName	= { 0, ""};				/* For Create, Open, etc.*/ResultBuf255	oList		= {255};				/* Optionlist buffer	*/char			*olPtr;								/* Ptr to Optionlist data*/char			type[]		= "    ";char			creator[]	= "    ";char			temp[5];							/* Hex conversion buffer */boolean			goodShell;							/* ORCA / APW shell?	*/#if debug/*#pragma debug -1 		/* 25 = stack check + trace back + range checking */FileInfoRecPtrGS	iRecPtr		= {&iRec};			/* For debugger */GSString255Ptr		GSfilePtr	= {&GSfileName};ResultBuf255Ptr		resultPtr	= {&oList};struct wild			*wildPtr	= {&wildParm};#endif/*******************************************************/int main(int argc, char *argv[]){long x, ver;word i, j, cc;								/* Work variables		*/int	 files;									/* # of files found		*/longword *q;								/* Used to put hex in type/creator*/char ch, *p;char *filename;								/* Filename save pointer *//* Initialisations */files = 0;puts(helloMsg);						/* Announce ourselves *//* Do we have enough parameters? */if ((argc != 2) && (argc != 4))  {   puts("Usage : HFSFileType filename {type creator}\n");   puts("If new type and creator are not specified,");   puts("the old values are simply displayed with no changes.");	puts("Hexadecimal values may specified as $aabbccdd.");   exit(0);} /*if*//* Support ProSel shell commands: Final parameter terminates with 0x0d!	*/p = argv[argc-1];p += strlen(p) - 1;if (*p == 0x0d)				/* Final parameter is non-standard	*/	*p = '\0';				/* Make it standard!				*//* Check GSOS version is adequate */GetVersionGS(&vRec);                /* Get ProDOS / GS/OS version no. */ver = vRec.version & majorRelNumMask;/* Isolate major release info    */ver = ver >> 8;                     /* Make it a 'normal' integer     */if (toolerror() || ver < 4)  {    puts("GS/OS System 6.0 is required to execute this program!");    exit(-1);} /*if*//*******************************************************//* Let's see if we can support wildcards			   */goodShell = !strcmp(shellid(),"BYTEWRKS");                     /*******************************************************//* Get parameters 1, 2, 3 - filename, type, creator	   */filename = argv[1];stripQuotes(filename);if (argc == 4) {								/* Type and Creator exist */    /* Get the 'type' */	strcpy(type,"    ");						/* Initialise to blanks */	p = argv[2];	stripQuotes(p);	if ((strlen(p) > 4 && *p != '$') || strlen(p) > 9)  {		puts("HFS Type value must be 1 to 4 characters long, or \n"\			 "1 to 8 hex digits preceded by a '$' sign.");    	exit(-1);	}/*if*/	if (*p == '$')  {		q  = (longword *)temp;    	*q = (longword)strtoul(p+1,NULL,16);	/* Get hex number */		for (i=0; i<4; i++)			*(type+3-i) = *(temp+i);			/* Reverse the byte order */	}/*if*/	else		for (i=0; i<4; i++)  {			if (ch = *(p+i))				*(type+i) = ch;		}/*for*/    /* Get the 'creator' */	strcpy(creator,"    ");						/* Initialise to blanks */	p = argv[3];	stripQuotes(p);	if ((strlen(p) > 4 && *p != '$') || strlen(p) > 9)  {		puts("HFS Creator value must be 1 to 4 characters long, or \n"\			 "1 to 8 hex digits preceded by a '$' sign.");    	exit(-1);	}/*if*/	if (*p == '$')  {		q  = (longword *)temp;    	*q = (longword)strtoul(p+1,NULL,16);	/* Get hex number */		for (i=0; i<4; i++)			*(creator+3-i) = *(temp+i);			/* Reverse the byte order */	}/*if*/	else		for (i=0; i<4; i++)  {			if (ch = *(p+i))				*(creator+i) = ch;		}/*for*/} /*if argc == 4*//*******************************************************//* Begin by getting getting the next filename, if wildcarding */           if (goodShell)  {							/* Handle wildcards */	wildParm.namePtr = wildFile;	strcpy(wildFile,c2pstr(filename));	INIT_WILDCARD(&wildParm);	switch (cc = toolerror())  {		case noError :					break;		case drvrNoDevice : case drvrOffLine :        			printf("Error: No disk in drive!\n\n",filename);					break;		case badPathSyntax:	case volNotFound  :			case fileNotFound :	case pathNotFound :        			printf("Error: Path '%s' not found!\n\n",filename);					break;		default :	printf("Error $%0.4X from INIT_WILDCARD\n\n",cc);					break;	}/*switch*/}/*if*/do {	/* while goodShell */					/* Always executed once! */	if (goodShell)  {							/* Handle wildcards		 */    	NEXT_WILDCARD(&wildParm.namePtr);		filename = p2cstr(wildFile);    	if (!*filename)							/* No (more) filename(s) */	    	break;								/* Leave processing loop */	}/*if*/	printf("File '%s'\n\n",filename);	files++;	/*******************************************************/	cc = GetSet_Info(filename,(argc==2));		/* ReadOnly if argc = 2 */	if (cc) exit(cc);	/*******************************************************/	if (STOP_PAUSE()) exit(0);					/* He wants out RIGHT NOW! */	putchar('\n');} while (goodShell);							/* Look for more wildcards */if (files == 0)	puts("No files found!");exit(files ? 0 : -1);							/* Set shell return code */} /*main*//*******************************************************//* Subroutines										   *//*******************************************************//*******************************************************//* stripQuotes - Remove enclosing quotes from a parameter */void stripQuotes(char *parm){if (*parm == '"') {	parm[strlen(parm)-1] = '\0';			/* Kill trailing quote */    parm++;									/* Kill leading quote  */}/*if*/}/*stripQuotes*//*******************************************************//* chk - Ensure a character is printable (make control chars inverse) */char *chk(char c){static char x[2];						/* Simple char */static char y[4];						/* Make char inverse */char ch;x[1] = '\0';y[0] = 15;		/* Inverse */y[2] = 14;		/* Normal  */y[3] = '\0';ch = c & 0x7f;if (ch < ' ') {							/* Control character? */	y[1] = ch + 'A' - 1;				/* Make inverse & printable as well */    return y;}*x = ch;return x;}/*chk*//*******************************************************//*	getKey - Wait for and return a keystroke.    		 Set hi-bit if Open-Apple also pressed.*/char getKey(void){char *KeyBd  	= (char *)0xe1c000;	/* Keystroke read location */char *KbdStrobe = (char *)0xe1c010;	/* Clear keyboard strobe location */char *KeyMod 	= (char *)0xe1c025;	/* Keyboard modifiers location */									/* 0x80 = Open-Apple pressed */char key;while (!((key = *KeyBd) & 0x80));	/* Wait for a keypress  */key &= 0x7f;						/* Strip hardware high bit */key |= (*KeyMod & 0x80);			/* Add high bit if Open-Apple pressed */*KbdStrobe = '\0';                  /* Reset keyboard       */               return(key);						/* Tell us what we got */} /*getKey*//*******************************************************//* GetSet_Info - Read the old type & creator, and update if required *//*               Returns 0 if processing should continue, else 'exit_code' */word GetSet_Info(char *filename,boolean readOnly){word	cc, i, j;char	ch;strcpy(GSfileName.text,filename);			/* Copy name into a GSOS buffer */GSfileName.length = strlen(filename);/* Begin by getting the old file info */iRec.pCount		= 12;iRec.pathname	= &GSfileName;				/* Filename buffer pointer		*/iRec.optionList = &oList;					/* Optionlist buffer pointer	*/    GetFileInfoGS(&iRec);						/* Get the file info */if (cc = toolerror())  {	switch (cc)  {		case badPathSyntax:	case volNotFound  :			case fileNotFound :	case pathNotFound :        			printf("Error: Path '%s' not found.\n",filename);					break;		default :	printf("Error $%0.4X while getting file info\n",cc);					break;	} /*switch*/    return cc;} /*if toolerror()*//* Look at the option list for the HFS details */#define offFSID		0				/* Offset in option list to FST Id		*/#define offType		2				/* Offset in option list to HFS Type	*/#define offCreator	6				/* Offset in option list to HFS Creator	*/#define hoTyp(x) *(olPtr+offType+x)#define hoCre(x) *(olPtr+offCreator+x)#define oTyp(x) chk(hoTyp(x))#define oCre(x) chk(hoCre(x))    olPtr = oList.bufString.text;		/* Point to optionlist	*/j	  = oList.bufString.length;		/* optionlist length	*/if (j == 0)  {	printf("No option list found for file - unable to process\n");	return 0;						/* Let processing continue */}/*if*/if ((word)*(olPtr+offFSID) != hfsFSID)  {	printf("This is not a HFS file!\n");    return -1;						/* Neither will any others be! */}/*if*//* 'Original : Type 'xxxx' (aabbccdd)  Creator 'yyyy' (aabbccdd)' */printf("Original : Type '"); for (i=0; i<4; i++) printf("%s",oTyp(i));printf("' (");				 for (i=0; i<4; i++) printf("%0.2X",hoTyp(i));printf(")  Creator '");		 for (i=0; i<4; i++) printf("%s",oCre(i));printf("' (");				 for (i=0; i<4; i++) printf("%0.2X",hoCre(i));printf(")\n");    if (readOnly)	return 0;				/* Return early *//* printf("     New : Type '%s'             Creator '%s'\n",type,creator); *//* 'Original : Type 'xxxx' (aabbccdd)  Creator 'yyyy' (aabbccdd)' */printf("     New : Type '"); for (i=0; i<4; i++) printf("%s",chk(type[i]));printf("' (");				 for (i=0; i<4; i++) printf("%0.2X",type[i]);printf(")  Creator '");		 for (i=0; i<4; i++) printf("%s",chk(creator[i]));printf("' (");				 for (i=0; i<4; i++) printf("%0.2X",creator[i]);printf(")\n");printf("\nMake changes? (y/n) ");do {	/*while (ch != 'Y' && ch != 'y')*/	ch = getKey();    if (ch == '.'+128)				/* <command>-.	*/    	return 1;					/* Abandon ship */	ch &= 0x7f;	if  (ch == 'N' || ch == 'n') {        puts("N\nChanges cancelled!");		return 0;    }/*if*/} while (ch != 'y' && ch != 'Y');puts("Y");strncpy(olPtr+offType,type,4);				/* Insert new type		*/strncpy(olPtr+offCreator,creator,4);		/* Insert new creator	*/SetFileInfoGS(&iRec);						/* Set the file info */switch (cc = toolerror())  {	case noError :		puts("Update successful!");						break;	case drvrWrtProt :	puts("Error: Output disk is write-protected.");						puts("Remove write-protection and try again!");						break;	default   :			printf("Error $%0.4X while setting new file info\n",cc);						break;} /*switch*/return cc;             }/*GetSet_Info*/