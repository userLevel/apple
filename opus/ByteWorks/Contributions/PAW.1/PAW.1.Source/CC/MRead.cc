/*	MRead : Dump memory data to the screen (or to a file)	Syntax: MREAD start_addr[.[end_addr]] [length] [-A] [-F[A] pathname]		    -A	- ASCII display only, no hexadecimal            -F	- Dump raw data to a file instead of the screen            -FA	- Append to a file            pathname - Name of GSOS path to save file to (filetype = BIN)			Addresses *must* be in hexadecimal. Length defaults to decimal,            (but may be hexadecimal if prefixed by '$'), and defaults to            one line (16 bytes hex, 64 bytes ASCII).            An address in the form 'xxxx. ' will list until <Command-.> pressed.	V1.0	Copyright by Peter Watson, April 1993.    V1.1	Add '-F pathname' option. May 1993    V1.11	Add '-FA pathname' option. Oct 1993                			Compiled using ORCA/C 2.01.*/#include <types.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <ctype.h>#pragma lint -1#define VER    "1.11"#define _DEBUG_ 0extern int STOP_PAUSE(void);			/* Pause on keypress or <oa-.>	*/void dumpHex(longword,longword);		/* Display data (hex & ASCII)	*/void dumpASCII(longword,longword);		/* Display data (ASCII only)	*/char *helloMsg = \	"\nMemory Display v" VER "  Copyright 1993 by Peter Watson\n";char *USAGE = \	"Usage : MRead start_addr[.end_addr] [length] [-A] [-F[A] pathname]\n";char *Licence[] =	"This program contains material from the ORCA/C",					"Run-Time Libraries, copyright 1987-1993",					"by Byte Works, Inc.  Used with permission.";char *buf;								/* Pointer to memory loc *//*******************************************************/int main(int argc, char *argv[]){FILE *fPtr;								/* Output file pointer			*/longword startAddr,						/* Start address in memory		*/		 endAddr,						/* End address in memory		*/		 length;						/* Length of memory block		*/word i,j,k,err;							/* Work variables				*/char ch;char *b, *e;char workBuf[256];						/* Alternative to malloc		*/char *fileName	= "";					/* Pointer to filename parameter*/boolean doASCII	= FALSE,				/* If TRUE, show ASCII only		*/		doFile	= FALSE,				/* If TRUE, dump to a file		*/		append	= FALSE,				/* If TRUE, append to a file	*/		nullEndAddr = FALSE;			/* TRUE if address in 'xxxx. ' format */puts(helloMsg);err	= 0;								/* Assume no error	*/buf	= workBuf;							/* No address yet	*/fPtr= NULL;								/* No file yet		*//* If we have enough parameters, parse for our known options */if ((argc <2) || (argc > 6) || (*argv[1] == '?'))  {	printf(USAGE);    goto cleanup;} /*if*//* Support ProSel shell commands: Final parameter terminates with 0x0d!	*/b  = argv[argc-1];					/* Last parameter's...				*/while (*b++); b--;					/*				   ...last character*/if (*b == 0x0d)						/* Final parameter is non-standard	*/	*b = '\0';						/* Make it standard!				*//**** Get the starting address ****/if ((argc < 2) || (*argv[1] == '-'))  {	/* Switch? */    *buf = '\0';	printf("Enter starting address >");    gets(buf);    if (*buf == '\0')				/* He changed his mind */    	goto cleanup;    b = buf;} else	b = strcpy(buf,argv[1]);		/* Make copy so we can modify it *//**** Handle any 'end address', which is in 'aaaa.bbbb' format ****/if (*b == '.')  {					/* Leading '.'? */	printf("Error: Invalid address - format is 'address' or "\    	   "'start_addr.end_addr'\n");    err = -1;    goto cleanup;} /*if*//* Is it an 'start.end' format address? *//* Nb: We must distinguish between 'no' end address, and a 'null' end address */e = b;while (ch = *e)  {	if (ch == '.')  {	    *e++ = '\0';				/* Terminate 'start', and point to 'end' */		if (!*e)					/* No more characters? */			nullEndAddr = TRUE;		/* Address is in 'xxxx. ' format */		break;						/* Exit the loop */	} /*if*/    e++;} /*while*/if (*b == '$') b++;					/* Skip any 'hex' prefix */startAddr = (longword)strtoul(b,NULL,16);		/* Get hex number */if (startAddr < 0)  {	puts("Error: Invalid starting address (negative numbers not allowed)!");	err = -1;    goto cleanup;} /*if*//**** Get the ending address (if any) ****/if (*e)	endAddr = (longword)strtoul(e,NULL,16);		/* Get hex number */else	endAddr = 0;if (endAddr < 0)  {	puts("Error: Invalid end address - format is 'start_addr.end_addr'!");    err = -1;    goto cleanup;} /*if*/if (endAddr && (endAddr < startAddr))  {	puts("Error: The ending address is less than the starting address!");    err = -1;    goto cleanup;} /*if*//**** Get the length ****/if ((argc < 3) || (*argv[2] == '-'))	/* Switch? */	length = 0;										/* Temporary value */else  {	b = argv[2];    	if (*b == '$')    	length = (longword)strtoul(b+1,NULL,16);	/* Get hex number */	else    	length = (longword)strtoul(b,NULL,10);		/* Get decimal number */	if (length < 0)  {		puts("Error: Invalid length (negative numbers not allowed)!");		err = -1;    	goto cleanup;	} /*if*/	if (length == 0)  {		puts("Error: Zero length specified! " \        	 "(May need '$' prefix for hex numbers)");		err = -1;    	goto cleanup;	} /*if*/} /*else*/    /**** Find any switches ****/for (i=1; i<argc; i++)  {	/* Check all parms */	if (*argv[i] == '-')	/* Found a switch */		switch (ch = toupper(argv[i][1]))  {            case 'A' :	doASCII = TRUE;						break;            case 'F' :	doFile = TRUE;                        if (argc < i+2 || !*argv[i+1])  {							puts("Missing filename parameter!");							err = -1;							goto cleanup;                        }/*if*/                        fileName = argv[i+1];						if (toupper(argv[i][2]) == 'A')	                        append = TRUE;		/* Append flag set */						break;            default  :	printf("Unknown switch character '%c'!\n",ch);						puts(USAGE);						err = -1;						goto cleanup;						break;        } /*switch*/} /*for*/#if _DEBUG_printf("+++ (1) startAddr = $%0.6lX, endAddr = $%0.6lX, length = $%0.6lX\n", \				startAddr,endAddr,length);#endif/**** Ensure that length has a reasonable value ****/if (nullEndAddr && !length)  {		/* If null end address & no length */	i = (startAddr>>16) & 0xff;		/* Get bank byte */    if ((i < 0x01) && (startAddr < 0x00c000))	endAddr = 0x00bfff; else    if ((i < 0x02) && (startAddr < 0x01c000))	endAddr = 0x01bfff; else    if ((i < 0xe1) && (startAddr < 0xe0c000))	endAddr = 0xe0bfff; else    if ((i < 0xe2) && (startAddr < 0xe1c000))	endAddr = 0xe1bfff; else    											endAddr = 0xffffff;	length = endAddr-startAddr+1;	/* Set 'endless' length */} elseif (!endAddr && !length)			/* If no end address & no length */	length = (doASCII ? 64 : 16);	/* One line of data */elseif (!length)						/* Convert end address to a length */	length = endAddr-startAddr+1;                /* Round *up* length to multiple of 16 or 64 as appropriate (Not for files!) */if (!doFile)  {	i = (doASCII ? 64 : 16);		/* Appropriate line length */	length  = (length+i-1) / i;		/* Get number of lines */	length *= i;					/* Get length rounded up to line length */}/*if*/                                    /* Formalise the end address (in case it was not specified, or has changed) */endAddr = startAddr + length - 1;/* Check for unreasonable addresses (like I/O locations) */if ((startAddr >= 0x00c000 && endAddr <= 0x00cfff) || \	(startAddr >= 0xe0c000 && endAddr <= 0xe0cfff) || \	(startAddr >= 0xe1c000 && endAddr <= 0xe1cfff) || \	(startAddr <= 0x00cfff && endAddr >  0x00cfff) || \	(startAddr <= 0xe0cfff && endAddr >  0xe0cfff) || \	(startAddr <= 0xe1cfff && endAddr >  0xe1cfff) || \	(startAddr <  0x00c000 && endAddr >= 0x00c000) || \	(startAddr <  0xe0c000 && endAddr >= 0xe0c000) || \	(startAddr <  0xe1c000 && endAddr >= 0xe1c000))  {	puts("Error: Memory range enters one of the I/O address ranges!\n" \    	 "       ($00Cxxx, $01Cxxx, $E0Cxxx or $E1Cxxx)");	err = -1;    goto cleanup;} /*if*/if (endAddr > 0xffffff)  {	puts("Error: End address exceeds maximum for the Apple IIgs ($FFFFFF)!");	err = -1;    goto cleanup;} /*if*/#if _DEBUG_printf("+++ (2) startAddr = $%0.6lX, endAddr = $%0.6lX, length = $%0.6lX\n", \				startAddr,endAddr,length);#endif/******* If we are in '-F' mode, write to a file (with a message) *******/if (doFile)  {	fPtr = fopen(fileName,(append ? "ab" : "wb"));	/*Open for write or append*/    if (fPtr == NULL)  {	    printf("Unable to open file '%s'!\n",fileName);		err = -1;		goto cleanup;	}/*if*/	printf("%s addresses $%0.6lX.$%0.6lX to file '%s'\n", \    		(append ? "Appending" : "Writing"),startAddr,endAddr,fileName);	fwrite((void *)startAddr,1L,length,fPtr);/* Write 'length' 1-byte elements*/    if (err = ferror(fPtr))	    printf("Error writing memory data to file!\n");	fclose(fPtr);	goto cleanup;}/*if doFile*//******* Display memory *******/if (doASCII)    dumpASCII(startAddr,length);else	dumpHex(startAddr,length);/******* Clean up and go home *******/cleanup:exit(err);} /*main*//*******************************************************/void dumpHex(longword addr,longword len)/*	dumpHex - Display memory in hex and ASCII*/{	word i,j;	char ch,		 *k;/* Print data in hex, 16 bytes per line, with ASCII format on the right. */    k = (char *)addr;    while (k < (char *)(addr+len))  {			    printf("%0.6lX  |  ",k);			/* Print offset */        for (i=4; i; i--)  {	        printf("%0.2X%0.2X%0.2X%0.2X ",	/* Print hex data */ \					*k,*(k+1),*(k+2),*(k+3));			k += 4;		} /*for*/		printf(" |  ");        k -= 16;							/* Move pointer back again */        for (i=16; i; i--)  {				/* Print ASCII */            ch = *(k++) & 0x7f;	        putchar(ch > ' ' ? ch : ' ');	/* Make <ctrl>-chars printable */        } /*for*/		puts("  |");		if (STOP_PAUSE())		    return;	/* User pressed <command-.> or <option-.> to exit early */    }/*while*/return;} /*dumpHex*//*******************************************************/void dumpASCII(longword addr,longword len)/*	dumpASCII - Display memory in ASCII only*/{	word i;	char ch,		 *k;         /* Print ASCII data only */    k = (char *)addr;    while (k < (char *)(addr+len))  {			    printf("%0.6lX  |  ",k);			/* Print offset */        for (i=64; i; i--)  {				/* Print ASCII */            ch = *(k++) & 0x7f;	        putchar(ch > ' ' ? ch : ' ');	/* Make <ctrl>-chars printable */        } /*for*/		puts("  |");		if (STOP_PAUSE())		    return;	/* User pressed <command-.> or <option-.> to exit early */    }/*while*/return;} /*dumpASCII*/        