#define WhoAmI "SORT V1.1"#define _DEBUG_ 0/*******************************************************    SORT - Filter to sort input from STDIN and write it to STDOUT            SORT [-D] [-N] [-C column]         '-D' specifies a descending order sort.         '-N' specifies a 'numeric' sort (ie. treat the string as a number).         '-C' specifies a column to start the comparison at (defaults to 1);              Nb: With '-C', 'equal' strings may be switched by qsort!                  Eg. '21', '11' sorted with '-C 2' may result in '11', '21'.         V1.0 - Copyright by Peter Watson. Mar 1990.         V1.1 - Add '-C' option. Mar 1990.         Compiled under ORCA/C V1.0b   ********************************************************/#include <stdio.h>             /* fgets(), fputs(), fprintf()  */#include <stdlib.h>            /* For qsort(), calloc(), free()*/#include <string.h>            /* For strcmp()                 */#include <ctype.h>             /* For toupper()                */#include <types.h>             /* For boolean, true, false     */#include <errno.h>             /* For errno, strerror()        */#include <orca.h>              /* For toolerror()              */#define ArraySize 1024         /* No. of array elements        */#define LineSize  256          /* Maximum size of an array line*/doCompare(char *,char *);      /* String compare for qsort     */char *Copyright[]=WhoAmI,                  " - Copyright 1990 by Peter Watson and Byte Works, Inc.";char *Licence[] = "This program contains material from the ORCA/C ",                  "Run-Time Libraries, copyright 1987-1989 ",                  "by Byte Works, Inc. Used with permission.";struct BufLine {   char line[LineSize];       } *buffer;              /* File i/o buffer line pointer */boolean OptD,                  /* '-D'escending order requested*/        OptN,                  /* '-N'umeric sort     requested*/        OptC;                  /* '-C'olumn to start comparing */long Col;                      /* Value specified for '-C'     *//*******************************************************//* Main program */main(argc,argv)  int   argc;  char *argv[];{   int  numread,               /* Number of lines read            */        i;                     /* Work counter                    */   setbuf(stderr,NULL);        /* Defeat buffering for screen messages */   #if _DEBUG_   fprintf(stderr,"%s%s\n",Copyright[0],Copyright[1]);   if (argc > 1)       for (i=1;i<argc;i++) fprintf(stderr,"Arg %d = [%s]  ",i,argv[i]);   else fprintf(stderr,"No command line arguments");   fprintf(stderr,"\n");   #endif/********************************************************//* Check for switches                                   */   if (ParseParm(argc,argv))       exit(-1);/********************************************************//* Allocate a buffer to hold the file data that we read */   buffer = (struct BufLine *)calloc(ArraySize+1,LineSize);/*Allocate a buffer*/   if (buffer == NULL)  {       fprintf(stderr,"Insufficient memory to allocate buffer\n");       exit(-1);       }/*******************************************************//* Read the entire file unless we run out of room      */   numread = 0;   fgets((char *)buffer,LineSize,stdin); /* Read first line */   while (!feof(stdin))  {       #if _DEBUG_       fprintf(stderr,"I:%s",(char *)(buffer+numread));       #endif       if (++numread > ArraySize)  {           fprintf(stderr,"File too big (more than %d lines)\n",ArraySize);           free(buffer);           exit(-1);           }       fgets((char *)(buffer+numread),LineSize,stdin);  /* Read next line */       }   if (numread == 0)  {       free(buffer);       exit(0);                /* Empty input file */       }/*******************************************************//* Sort the file                                       */   qsort((char *)buffer,numread,LineSize,doCompare);   /* Sort the array *//*******************************************************//* Write the file to stdout                            */   for (i=0; i<numread; i++)  {       #if _DEBUG_       fprintf(stderr,"O:%s",(char *)(buffer+numread));       #endif       if (fputs((char *)(buffer+i),stdout))  {           fprintf(stderr,"%s (Code $%x) during file output", \                          strerror(errno),toolerror());           break;                     /* Write failed! */       }   }/*******************************************************//* Free our allocated memory                           */   free(buffer);/*******************************************************//* Return to our caller                                */   exit(0);}/*******************************************************//*                                                     *//* doCompare - Compare two strings for qsort function  *//* =========                                           *//*             Return 1 if s1 > s2                     *//*                    0 if s1 = s2                     *//*                   -1 if s1 < s2                     *//*                                                     *//*             Short strings handled like 'strcmp'.    *//*                                                     *//*             If OptD, then return -1, 0, 1 instead.  *//*             If OptN, treat strings as numbers.      *//*             If OptC, start compare at column 'Col'  *//*                                                     *//*******************************************************/int doCompare(ps1,ps2)   char *ps1, *ps2;{   char *s1, *s2;              /* My starts of strings */   int result;                 /* Work variable        */   double d1, d2;   #if _DEBUG_   fprintf(stderr,"doCompare: S1 = %s           S2 = %s",ps1,ps2);   #endif   if (Col > strlen(ps1))          /* Handle short strings */       if (Col > strlen(ps2))  result =  0;       else                    result = -1;   else   if (Col > strlen(ps2))      result =  1;   else   {                               /* Handle 'normal' strings */   s1 = ps1 + Col - 1;             /* Set starting columns */   s2 = ps2 + Col - 1;   if (OptN)  {                    /* Numeric comparison   */       d1 = strtod(s1,NULL);       /* Convert to numbers   */       d2 = strtod(s2,NULL);       if (d1  < d2) result = -1;  else if (d1 == d2) result =  0;  else               result =  1;       }   else       result = strcmp(s1,s2);     /* Compare the strings  */   } /* End of 'normal sized strings' block */   #if _DEBUG_   fprintf(stderr,"           Result = %d\n=========\n",OptD? -result : result);   #endif   return(OptD ? -result : result);/* Return results (in correct order) */}/****************************************************************** ParseParm - Parse command line arguments, if any* =========\****************************************************************/int ParseParm(argc,argv)   int argc; char *argv[];{   int  i,        ErrFlag = false;           /* Parameter error flag    */   char ch;                        /* Option character        */   Col = 1;                        /* Default starting column */   OptD = OptN = OptC = false;     /*Initialise switch flags*/   if (argc > 1)                   /* First parameter is program name */       for (i=1; i<argc; i++) {           ch = toupper(argv[i][1]);           if (argv[i][0] == '-' || argv[i][0] == '+')               if (strpos("DNC",ch) > -1)  /* Get around 'default' bug */                   switch (ch) {                       case 'D': OptD = true;                                 break;                       case 'N': OptN = true;                                 break;                       case 'C': OptC = true;                                 errno = Col = 0;       /* Set defaults       */                                 if (++i < argc)                                   Col = atol(argv[i]); /* Get compare column */                                 if (errno || Col == 0)  {                                   fprintf(stderr,\                                         "Invalid compare column value '%s'\n",\                                         i>=argc ? "" : argv[i]);                                   ErrFlag = true;                                   }                                 break;                       } /* switch */               else {                   fprintf(stderr,"Invalid switch '%s'\n",argv[i]);                   ErrFlag = true;                   }           else {               fprintf(stderr,"Unknown command parameter '%s'\n",argv[i]);               ErrFlag = true;               }           } /* for */   return(ErrFlag);} /* ParseParm */