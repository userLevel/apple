#define WhoAmI "FIXSOUND V1.3"#define _DEBUG_ 0/*******************************************************    FIXSOUND - Program to change occurrences of $00 to $01             in digitised sound files to avoid problems             with the Ensoniq DOC chip.  Also removes header             and trailer info from Macintosh format files.               V1.0 - Copyright by Peter Watson. Oct 1989.             V1.1 - Add wildcard support if under the Shell. Nov 1989             V1.2 - Remove header/trailer from converted Mac files. Dec 1989             V1.3 - Fix header/trailer bug. Support Mac sound resources.                    Ignore "invisible" files. Feb 1990                            Compiled under ORCA/C V1.0b   ********************************************************/#include <stdio.h>#include <stdlib.h>#include <errno.h>#include <string.h>#include <prodos.h>#include <shell.h>#include <orca.h>#define BUFSIZE 4096           /* Size of I/O buffer              */void convert(char *s);         /* Convert 0's to 1's subroutine   */long CheckHeader();            /* Check for Mac file header       */long getNum(int offset,int length);/*Convert buffer data to number*/char *Licence[] = "This program contains material from the ORCA/C ",                  "Run-Time Libraries, copyright 1987-1989 ",                  "by Byte Works, Inc. Used with permission.";char buffer[BUFSIZE];          /* File i/o buffer                 */char fileName[FILENAME_MAX];   /* Filename buffer                 */struct {char *namePtr;         /* Pointer to the pathname         */        int   flags;           /* Flags: '?' valid; use all files */        } WildParm = {NULL,0}; /* INIT_WILDCARD parm list         */FileRec Info_Parm = {NULL};    /* GetFileInfo parm list           */OpenRec IO_Parm = {0,NULL,0L}; /* ProDOS Open and Close parm list */EOFRec  SET_EOF_Parm = {0,0L}; /* SetEOF parm list                */long block,                    /* Block number we are reading     */     bytes,                    /* No. of bytes we have read       */     blocksUsed,               /* No. of data blocks in the file  */     hdr_len,                  /* Length of header                */     data_len,                 /* Length of data (from header)    */     count_1;                  /* Count of '1's in part of header */int  numread;                  /* Number of bytes read            */boolean Found_One;             /* Did we find 'any' files?        *//* ********************************************************/main(argc,argv)  int   argc;  char *argv[];{   FILE *fptr;                 /* File we are processing */   char ch;   int  err, i;                /* Work variables         */   setbuf(stdout,NULL);        /* Defeat buffering for screen messages */   printf("\n%s - Copyright 1989 by Peter Watson and Byte Works, Inc.\n\n",\          WhoAmI);   WildParm.namePtr = fileName;Get_File_Name:   if (argc < 2)  {       printf("Name of sound file to fix >");       gets(fileName);       if (strlen(fileName) == 0)           exit(0);       }   else strncpy(fileName,argv[1],FILENAME_MAX-1);   strcpy(fileName,c2pstr(fileName));   INIT_WILDCARD(&WildParm);   if (toolerror())  {       err = toolerror();       printf("\n");       ERROR(&err);                            /* Print an error message */       exit(err);       }   Found_One = FALSE;   NEXT_WILDCARD(&WildParm.namePtr);   while (fileName[0] != '\0')  {       Found_One = TRUE;       Info_Parm.pathname = fileName;       GET_FILE_INFO(&Info_Parm);              /* Get file details */       if ((Info_Parm.storageType > 3) ||          !(Info_Parm.fAccess & P_WRITE_ENABLE)) {               printf("Access not allowed to %p\n",fileName);               goto Next_File;               }       if (Info_Parm.fAccess & P_INVISIBLE)           goto Next_File;                 /* Invisibly ignore invisible files*/       /* Following code not used at present */#if 0       blocksUsed = Info_Parm.blocksUsed;       if (blocksUsed > 2)  {                  /* Get data blocks used        */           /* Remove one index block for every 257(!) or part thereof         */           i = (blocksUsed + 256) / 257;       /* Round up (integer division) */           if (i > 256) i++;                   /* Ignore master index block   */           blocksUsed -= i;                    /* Ignore index blocks         */           }#endif       strcpy(fileName,p2cstr(fileName));       printf("Converting file %s ",fileName);       if ((fptr = fopen(fileName,"rb+")) == NULL)  {           perror("\nUnable to open file\n");    /* Print message */           exit(errno);           }       block = bytes = hdr_len = 0;       do  {           #if _DEBUG_           printf("Pos1=%ld, ",ftell(fptr));           #endif           if (fseek(fptr,block*BUFSIZE+hdr_len,SEEK_SET)) {                                               /* Position file ptr    */               err = errno;               perror("\nSeek error! ");               fclose(fptr);               exit(err);               }           numread = fread(buffer,1,BUFSIZE,fptr); /* Read next block  */           if (block == 0)               if (hdr_len = CheckHeader(fptr)) {/* Check for Mac header*/                   #if _DEBUG_                   printf("New hdr_len = %ld, ",hdr_len);                   #endif                   if (hdr_len < 0)  {                       fclose(fptr);                       break;                    /* Leave the 'while' loop */                       }                   fseek(fptr,hdr_len,SEEK_SET); /* Skip the header     */                   numread = fread(buffer,1,BUFSIZE,fptr); /* Read 1st real block*/                   }           #if _DEBUG_           printf("Numread = %d, Pos2=%ld\n",numread,ftell(fptr));           #endif           bytes += numread;                     /* Bump byte counter   */           printf(". ");                         /* Keep the user amused*/           convert(buffer);                      /* Convert 0's to 1's  */           fseek(fptr,block*BUFSIZE,SEEK_SET);   /* Reposition file ptr */           #if _DEBUG_           printf("\nPos3=%ld, ",ftell(fptr));           #endif                                                 /* and write new block */           if (fwrite(buffer,1,numread,fptr) != numread)  {               err = errno;               perror("\nError writing! ");               fclose(fptr);               exit(err);               }           #if _DEBUG_           printf("Pos4=%ld\n",ftell(fptr));           #endif           block++;                   /* Next block */       } while (numread == BUFSIZE);  /* Check that EOF not reached */       fclose(fptr);       #if _DEBUG_       printf("Block = %ld, Bytes = %ld (%#lx)\n",block,bytes,bytes);       #endif/* If a header was found, truncate the trailer as well, using ProDOS calls */       if (hdr_len > 0) {              /* If header present, else 0 */           #if _DEBUG_           printf("data_len 1 = %ld\n",data_len);           #endif           if ((data_len > bytes) && (count_1 == -1L))/* Suspect header info*/               data_len -= (long)1 << 16; /* Fix our previous ver's work  */           #if _DEBUG_           printf("data_len 2 = %ld\n",data_len);           #endif           strcpy(fileName,c2pstr(fileName)); /* Need pString for ProDOS */           IO_Parm.openPathname = fileName;           OPEN(&IO_Parm);           if (toolerror()) {               err = toolerror();               printf("\n");               ERROR(&err);       /* Print an error message */               }           else {               SET_EOF_Parm.eofRefNum   = IO_Parm.openRefNum;               SET_EOF_Parm.eofPosition = data_len;               SET_EOF(&SET_EOF_Parm);        /* Reposition before trailer  */               if (toolerror()) {                   err = toolerror();                   printf("\n");                   ERROR(&err);       /* Print an error message */                   }               }           CLOSE(&IO_Parm);       }/* Finished the file - see if there are any others */Next_File:       printf("\n");       NEXT_WILDCARD(&WildParm.namePtr);   } /* While there are more wildcard filenames */   if (!Found_One)       printf("No file found!\n");   if (argc < 2)                 /* If we are in prompting mode */       goto Get_File_Name;   printf("\n");} /* main *//* ********************************************************/void convert(buffer)char buffer[];/*   Convert - Change all zeroes in the buffer to ones*/{   int   i;   char ch;   for (i=0;i<numread;i++)       buffer[i] = ((ch = buffer[i]) ? ch : '\001'); /* $00 -> $01 */   return;} /* Convert *//* ********************************************************/long CheckHeader(fptr)   FILE *fptr;/*   CheckHeader - Look for Mac sound file header and offset to trailer.                 Alternatively, extract details of the first sound resource.                 Returns header size, if present, or zero.   =====================================================   Header format - +0x00 = 0   (Sound data)    +0x01 = Length of sound name (0 < n < 32)                   +0x02 = Sound name                   +0x41 = 'INIT' or 'FSSD' (Are there others??)                   +0x54 = 3 byte data length ('MSB first' format!!)                   +0x70 = ? (Usually 16 bytes of 0 - if 1's, then an                              earlier version of FixSound has been there!)                             (Or someone else's fix program!)                   +0x7f = Last byte of header   =====================================================   Nb: If a resource file has been '0->1' converted, we must ignore it!   Header format - +0x00 = Header length (normally 0x100)   (Resource fork) +0x04 = Trailer offset (resource map)                   +0x08 = Data length (all resources)                   +0x0c = Trailer length                   +0x10 = Reserved (112 bytes)                    ...                   +0x52 = 'rsrcRSED' (Are there others??)                    ...                   +0x80 = Start of application header data                   +0xff = Beginning of resource data for each resource   Resource data - +0x00 = Length of 'resource data' for this resource                   +0x04 = Resource data for this resource   Trailer format- +0x00 = First 16 bytes of header repeated   (Resource map)  +0x10 = Reserved                   +0x16 = Resource file attributes                   +0x18 = Offset in 'map' to 'type list'                   +0x1a = Offset in 'map' to 'resource name list'   Type list     - +0x00 = No. of resource types - 1   Type          - +0x00 = Resource type (eg. 'snd ')                   +0x04 = No. of resources of this type - 1                   +0x06 = Offset in 'type list' of this type's 'reference list'   Reference list- +0x00 = Resource id                   +0x02 = Offset in 'resource names' to name, or '-1'                   +0x04 = Resource attributes                   +0x05 = Offset in 'resource data' to resource's data length                   +0x08 = Reserved (4 bytes)   Resource names- +0x00 = Name (pString format - 1 byte length prefix)   =====================================================*/{   int  i;   long offset;   /* Resource file related variables */   long headerLen, /* In header         */        mapOffset,        dataLen,        mapLen;   int  typesOffset,   /* In resourceMap    */        namesOffset;   int  rTypeCount;    /* Start of typeList */   #define TYPESIZE 8  /* Length of type entry*/   char rType[4];      /* In typeList       */   int  rCount,        refOffset;   long resDataOffset; /* In referenceList  */   #define CHECKLEN 256/* Length of data to check for internal header */   data_len = count_1 = offset = 0L;   #if _DEBUG_   printf("Checkheader entered\n");   #endif/* Start by calculating some 'resource' variables, just in case */   headerLen = getNum(0,4);   mapOffset = getNum(4,4);   dataLen   = getNum(8,4);   mapLen    = getNum(12,4);   #if _DEBUG_   printf("\nheaderLen=%#lx, mapOffset=%#lx, dataLen=%#lx, mapLen=%#lx\n",\             headerLen,      mapOffset,      dataLen,      mapLen);   printf("id = ["); for (i=0;i<8;i++) printf("%c",buffer[82+i]); printf("]\n");   #endif/* Check for ordinary sound files (ie. information in the data fork) */   if ((strncmp(buffer+65,"INIT",4)==0 || strncmp(buffer+65,"FSSD",4)==0) &&       (buffer[0] <= 1) &&       (buffer[1] <= 32)) {       printf("(Mac header/trailer removed) ");       for (i = 0x70; i < 0x80; i++)           count_1 += buffer[i];           /* Count 1's - either 0 or 16*/ /* Calculate the offset to the trailer (ie. the data length)          */       #if _DEBUG_       printf("\ncount of 01's = %ld\n",count_1);       printf("[84]=%#02x, [85]=%#02x, [86]=%#02x\n", \              buffer[84],buffer[85],buffer[86]);       #endif       data_len = getNum(85,2);       if (buffer[84] != 1 || count_1 != 16)           data_len += (long)buffer[84] << 16;       else count_1 = -1;                      /* Check length later   */       offset = 128L;                          /* Header size          */       }/* Now check for sound resource files (ie. information in the resource fork) */   else   if (strncmp(buffer+82,"rsrcRSED",8) == 0 &&       headerLen == 256L                    &&       headerLen + dataLen == mapOffset)  {/* Looks like a resource fork */       #if _DEBUG_       printf("\nResource file detected\n");       #endif /* We *must* look at the trailer - so read it                           */       if (fseek(fptr,mapOffset,SEEK_SET))  {     /* Skip to the trailer */           printf("\nTrailer seek error (Offset = %#lx)! : %s\n",\                   mapOffset,strerror(errno));           offset = -1;           goto Exit;           }       numread = fread(buffer,1,(int)mapLen,fptr);/* Read the trailer    */       if (numread != mapLen)  {                  /* File is corrupt!    */           printf("\nResource data corrupt (Map data too short)!\n");           offset = -1;           goto Exit;           }/* Look in the resource map for any sound resources, and locate the first */       typesOffset = getNum(24,2);       rTypeCount  = getNum(typesOffset,2)+1; /* No. of resource types */       #if _DEBUG_       printf("typesOffset = %#x, rTypeCount = %d\n",typesOffset,rTypeCount);       #endif       for (i=0;i<rTypeCount;i++)  {          /* For each type */           strncpy(rType,buffer+typesOffset+2+(i*TYPESIZE),4);           /* Ignore count - we handle first only */           refOffset= getNum(typesOffset+2+(i*TYPESIZE)+6,2);           refOffset += typesOffset; /* Offset from rMap instead of typeList */           #if _DEBUG_           printf("rType = [%c%c%c%c]\n",rType[0],rType[1],rType[2],rType[3]);           #endif           if (strncmp(rType,"snd ",4) != 0)               continue;           resDataOffset = getNum(refOffset+5,3); /* 3 byte data offset */           #if _DEBUG_           printf("refOffset=%#x, resDataOffset=%#lx\n",refOffset,resDataOffset);           #endif           break;           }       if (i > rTypeCount)  {           printf("\nNo sound resource found!\n");           offset = -1;           goto Exit;           } /* Find the start of the resource - errors "should" be impossible  */       offset  = headerLen + resDataOffset;    /* Point to resource */       fseek(fptr,offset,SEEK_SET);       numread = fread(buffer,1,CHECKLEN,fptr);/* Get the resource length*//* Still need to step over 'internal' sound header. Experiments     *//* suggest that this header ends with 0x003c on a word boundary.    */       for (i=4; i<CHECKLEN; i+=2)           if (getNum(i,2) == 0x003cL) {               i += 2;               break;               }       if (i == CHECKLEN)         /* Normal end not found - fake it */           for (i=CHECKLEN-1; i>4; i--)               if (buffer[i] == '\0')  { /* Usually no zeroes at start */                   i += 2;                   break;                   }       data_len  = getNum(0,4) - (i-4); /* Length of sound data     */       offset   +=  i;                  /* Point to sound data      */       printf("(Mac resource data removed) ");       }/* Check for a previously '0->1' converted sound resource file */   else   if (strncmp(buffer+82,"rsrsRSED",8)==0)  {       printf("Mac resource format damaged - file skipped\n");       offset = -1;       }   #if _DEBUG_   printf("Data_len = %ld (%#lx) at offset %#lx, ",data_len,data_len,offset);   printf("Count_1  = %ld\n",count_1);   #endifExit:   #if _DEBUG_   printf("CheckHeader returning %ld\n",offset);   #endif   return(offset);} /* CheckHeader *//* ********************************************************/long getNum(offset,length)   int offset, length;/*   getNum - Take bytes from the buffer and make them into a long integer.            1) Allows Mac-style 'MSB first' numbers            2) Allows conversion of (eg.) 3-byte numbers*/{   int  i;   long answer = 0;   for (i=0; i<length; i++)       answer = (answer<<8) + (long)buffer[offset+i];   return(answer);} /* getNum */