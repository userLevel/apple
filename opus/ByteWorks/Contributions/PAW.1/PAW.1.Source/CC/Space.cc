#define WhoAmI "SPACE v1.42"#pragma stacksize 16384          /* Set stacksize to 16K bytes */#define _DEBUG_ 0/****************************************************************SPACE -  Shell utility to determine the amount of disk space used by the         files in a directory, and all sub-directories. Restartable.         SPACE [-O] [-Q] [-L] [-B] [pathname]         If pathname is omitted, it will be prompted for.         '-O' 'O'nly scans the specified directory (no subdirectories).         '-Q' 'Q'uietly suppresses the 'Processing ....' messages.         '-L' 'L'ists space used by each subdirectory as well as a total.         '-B' 'B'ackup bit files only are included.         v1.0 - Copyright April 1989 by Peter Watson.         v1.1 - Minor bug fixes. Allow to execute under the Finder. Apr 1989         v1.2 - Rewritten in ORCA/C. Support resource forks. Jan 1990         v1.21- Fix file count bug. Jan 1990         v1.3 - Add '-L' option to show size of each directory. Feb 1990         v1.31- v1.3 accidently disabled the '-O' option. Mar 1990         v1.4 - Add '-B' option to only include 'backup bit' files. Mar 1990                (Directories are 'assumed' to have the bit set!)         v1.41- Support ProSel command shell a bit better. ORCA/C 2.01. Jul 1994         v1.42- Fix loop if prompting and 'standalone'. ORCA/C 2.03. Aug 1995		 Compiled under ORCA/C 2.03*****************************************************************/#include <types.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <ctype.h>#include <gsos.h>#include <shell.h>#include <orca.h>/****************************************************************** GLOBAL declarations*\****************************************************************/#define MAXBUF 255#define DirectoryType 0x0F                         /* Directory file type    */extern int STOP_PAUSE(void);                       /* Function from PAW.LIB  */long   ProcessFile(char *);                        /* Function prototypes    */void   ShowArgs(int, char *[]);int    ParseParm(int, char *[]);void   callERROR(int);VersionRecGS vrec = {1,0};                         /* GS/OS version no. rec  */struct {char *namePtr;                             /* For INIT_WILDCARD      */        int  flags;} wildParm;ResultBuf255 optList;                              /* Used by GetDirEntry    */boolean OptO,                                      /* = true if '-O' specified*/        OptQ,                                      /* = true if '-Q' specified*/        OptL,                                      /* = true if '-L' specified*/        OptB,                                      /* = true if '-B' specified*/        StopFlag,                                  /* = true if Apple-. keyed*/        StandAlone;                                /* = false if under Shell */char    PathName[MAXBUF] = "",                     /* Pathname buffer        */		NextPath[MAXBUF],        cNxtPath[MAXBUF];						   /* Wildcard name buffers	*/long    Files;                                     /* No. of files counter   *//****************************************************************** MAIN function* ====\****************************************************************/main(int argc, char *argv[]){   word i,j,k;                             /* Work variables                 */   boolean FoundOne = false;               /* Found a wildcard name          */   word ver;                               /* unsigned int                   */   long Used;                              /* Used space counter             */   char *p;   wildParm.namePtr = NextPath;            /* Wildcard pathname pointer      */   wildParm.flags   = 0x0000;              /* Wildcard flags - allow '?'     */   StopFlag         = false;/* Announce ourselves, and check that we are running under the shell & GS/OS*/   printf("\n%s: Copyright 1990-95 by Peter Watson and Byte Works, Inc.\n", \			WhoAmI);   GetVersionGS(&vrec);                    /* Get ProDOS / GS/OS version no. */   ver = vrec.version & majorRelNumMask;   /* Isolate major release info     */   ver = ver >> 8;                         /* Make it a 'normal' integer     */   if (toolerror() || ver < 2)  {       printf("\nGS/OS is required to execute this program\n");       exit(-1);                           /* Tell shell we bombed out       */       }if (argc > 0 && strncmp(shellid(),"BYTEWRKS",8)==0)     StandAlone = false;else StandAlone = true;				/* May still be some 'other' shell! *//* Support ProSel shell commands: Final parameter terminates with 0x0d!	*/if (argc)  {	p  = argv[argc-1];				/* Last parameter's...				*/	p += strlen(p)-1;				/*				   ...last character*/	if (*p == 0x0d)					/* Final parameter is non-standard	*/		*p = '\0';					/* Make it standard!				*/} /*if*/       /* Find and extract any switches and pathnames */   if (ParseParm(argc,argv))       exit(-1);                           /* Tell shell we bombed out       *//* Prompt for a pathname if we did not get one */Prompt:   if (strlen(PathName) == 0)  {       printf("\nPathname of directory >");       gets(PathName);                     /* Get a string from the user     */       if (strlen(PathName) == 0)           exit(0);       if (StandAlone)           OptL = true;                    /* Default under the Finder       */       }#if _DEBUG_   printf("shellid()=[%s], StandAlone=%d\n",shellid(),StandAlone);   printf("Compile date = %s, time = %s\n",__DATE__,__TIME__);   ShowArgs(argc,argv);   printf("Option O %sspecified\n",OptO ? "" : "not ");   printf("Option Q %sspecified\n",OptQ ? "" : "not ");   printf("Option L %sspecified\n",OptL ? "" : "not ");   printf("Option B %sspecified\n",OptB ? "" : "not ");   printf("Pathname is '%s'\n",PathName);#endif/* Set up for wildcard processing */   strcpy(NextPath,c2pstr(PathName));       /* Take a copy of the pathname    */   if (!StandAlone) {                       /* If running under the shell     */       INIT_WILDCARD(&wildParm);            /* Allow all '?' requests         */       if ((k = toolerror()) != noError) {  /* Save value from printf clutches*/           printf("\nError $%4x setting up wildcard handling\n",k);           callERROR(k);                    /* Display an explanatory message */           exit(k);                         /* Leave immediately              */           }       } /* if not under Shell *//*................................................................. Process directories (each as a unique request) until there are no more..................................................................*/   if (!StandAlone)       NEXT_WILDCARD(&wildParm.namePtr);/* Get next (first!) pathname, if any */   while (*NextPath) {       FoundOne = true;                 /* Say we found at least one filename */       printf("\n");       strcpy(cNxtPath,p2cstr(NextPath));/* Take a copy of the pathname		 */       Files = 0;                       /* Initialise file counter			 */       Used = ProcessFile(cNxtPath);    /* Process this filename              */       if (StopFlag)                    /* User requested stop?               */           break;       if (Used > -1L) {           if (!OptQ)               printf("\n");           printf("%ld block%s used by %ld file%s within the %s directory\n", \               Used, Used==1L ? "":"s", Files, Files==1L ? "":"s", cNxtPath);           }       if (StandAlone)           break;                      /* Not under the shell                */       NEXT_WILDCARD(&wildParm.namePtr);/* Get next pathname, if any         */       } /* while *//*................................................................. End the program and go home..................................................................*/   if (!FoundOne)       printf("\nNo file found!\n");   if (StandAlone && argc < 2)  {	   *PathName = '\0';			   /* Force another pathname prompt		*/       goto Prompt;                    /* Give the user another shot         */   } /*if*/   exit(0);                            /* Return to the shell                */} /* main *//****************************************************************** ProcessFile - Compute the space used within a directory (recursively)* ===========\****************************************************************/long ProcessFile(char *DirName)/* cString format - fully qualified */{   int           i, myErr;   long          Used, tempU;  /* Used space counters              */   long          filesThisDir=0;/*File count this directory        */   ResultBuf32Ptr p;           /* Pointer to Entry Name buffer     */   ResultBuf32   EntName;      /* Entry name in directory          */   OpenRecGS     OpenList;     /* Open parameter list              */   DirEntryRecGS DirList;      /* Directory entry parameter list   */   RefNumRecGS   CloseList;    /* Close parameter list             */   GSString255   FileName;     /* GS type name string              */   char          cPath[MAXBUF];/****************************************************************//* Check for a user request to 'abandon ship' (<Open Apple>-<.> pressed) *//* Also halts processing temporarily if user presses a key               */   StopFlag = STOP_PAUSE();    /* Call checking routine            */   if (StopFlag) {       printf("Processing stopped by user request\n");       return(-1);             /* Pass the message up the line     */       }/* Tell the user where we're up to, if he wants to know */   if (!OptQ && !OptL)         /* Quiet or List modes requested?   */       printf("Processing %s\n",DirName);/* Convert the cString name into a GSString name */   FileName.length = strlen(DirName);   strcpy((char *)FileName.text,DirName);/****************************************************************//* Open the file */   OpenList.pCount = 2;            /* Only interested in 2 parameters */   OpenList.pathname = &FileName;  /* What we want to open    */   OpenGS(&OpenList);              /* Open the requested file */   if ((myErr = toolerror()) != noError) { /* Save value from printf clutches */       printf("\nOPEN error : "); callERROR(myErr);       return(-1);                 /* Error exit */       }   Used = 0L;                      /* Initialise our counter  */   strcat(DirName,"/");            /* Allow filename addition */   DirList.refNum = CloseList.refNum = OpenList.refNum;/******************************************************************//* If it's a directory file, step through reading the entries     *//* If an entry is another directory, call ProcessFile recursively */   DirList.pCount       = 17;          /* We require 17 parameters           */   DirList.base         = 1;           /* Start at the very beginning        */   DirList.displacement = 1;           /* Look at every file                 */   DirList.name = (ResultBuf255Ptr)&EntName; /* Entry name 'Pointer'         */   DirList.optionList   = &optList;    /* Pointer to options list            */   EntName.bufSize      = 36;          /* Output buffer size (= 32 + 2 + 2)  */   optList.bufSize      = 259;         /* Output FST info    (=255 + 2 + 2)  */   GetDirEntryGS(&DirList);            /* Get first directory entry          */   myErr = toolerror();   if (myErr == noError || myErr == endOfDir || myErr == badFileFormat)       switch(myErr) {           case noError  :           case endOfDir :                      /*Allow for empty directory*/               break;           case badFileFormat :               printf("Not a directory file!\n");               Used = -1L;                      /* Flag error to main     */               break;       } /* switch */   else {           /* Can't use 'default' due to 'switch' bug! */       printf("\n");                            /* Flush buffer           */       callERROR(myErr);       Used = -1L;                              /* Flag error to main     */       }#if _DEBUG_   printf("ProcessFile: 1st GetDirEntry: Used=%ld, myErr=%d\n",Used,myErr);#endif/***********************************************************************//* Loop through the directory. Prepare to descend if another directory *//* Nb: For extended files, must add 1 block for 'mini-directory' block */   if (Used > -1L)								   /* If no previous errors  */   while (!myErr) {								   /* Until end-of-directory */       if (OptB)           if (!(DirList.access & backupNeeded) &&                (DirList.fileType != DirectoryType))/*Count DIR files always!*/               goto nextEntry;                     /* Only if backup bit set */       Files++;                                    /* Increment file counts  */       filesThisDir++;       if (tempU = DirList.resourceBlocks)		   /* Is this file extended? */	   		tempU++;					   		   /* Include extra index blk*/       Used += DirList.blockCount + tempU;		   /* Add in these blocks    */#if _DEBUG_       printf("File %03ld: dFork = %ld blks, rFork = %ld blks\n", \               Files,DirList.blockCount,DirList.resourceBlocks);#endif       if (!OptO && DirList.fileType == DirectoryType) {           /* Build a fully qualified name for the next level subdirectory   */           i = EntName.bufString.length;           /* Result string length   */           if (i+strlen(DirName) > MAXBUF-1)  {               printf("Error: Path length will exceed %d characters\n",MAXBUF-1);               return(-1);}           strcpy(cPath,DirName);                  /* Working variable       */           strncat(cPath,(char *)EntName.bufString.text,i);                                                   /* Fully qualified name   */           /* Process the next directory down */           tempU = ProcessFile(cPath);             /* Process a subdirectory */           if (tempU < 0)  {                       /* Ignore error counts    */               Used = -1;               break;               }           Used += tempU;                          /* Add in the block count */           } /* if 'Directory' and not '-O' */nextEntry:       GetDirEntryGS(&DirList);                    /* Get next entry         */       myErr = toolerror();                        /* Save the return code   */   } /* while myErr == noError *//****************************************************************//* Close the file */   CloseList.pCount = 1;                           /* Only 1 parameter       */   CloseGS(&CloseList);                            /* Close the file         *//* Tell the user (?) and our calling function how many blocks we found  */   DirName[strlen(DirName)-1] = '\0';              /* Remove end '/' again   */   if (!OptQ && OptL && Used > 0)                  /* List  mode requested?  */       printf("%5ld block%s (%3ld file%s) in %s\n", \       Used,Used==1L ? " ":"s",filesThisDir,filesThisDir==1L ?" ":"s",DirName);   if (StopFlag)                                   /* Stop requested?        */       Used = -1;                                  /* Say it was an error    */#if _DEBUG_   printf("ProcessFile: Main exit: Returning %ld blks, %ld files\n",Used,Files);#endif   return(Used);                                   /* Return to the caller   */} /* ProcessFile *//****************************************************************** ParseParm - Parse command line arguments, if any* =========\****************************************************************/int ParseParm(int myargc,char *myargv[]){   int i,       ErrFlag = false;            /* Parameter error flag    */   char ch;                        /* Option character        */   OptO = OptQ = OptL = OptB = false;/*Initialise switch flags*/   PathName[0] = '\0';             /* Pathname is null        */   if (myargc > 1)                 /* First parameter is program name */       for (i=1; i<myargc; i++) {           ch = toupper(myargv[i][1]);           if (myargv[i][0] == '-' || myargv[i][0] == '+')               if (strpos("OQLB",ch) > -1)  /* Get around 'default' bug */                   switch (ch) {                       case 'O': OptO = true;                                 break;                       case 'Q': OptQ = true;                                 break;                       case 'L': OptL = true;                                 break;                       case 'B': OptB = true;                                 break;                       } /* switch */               else {                   printf("Invalid switch '%s'\n",myargv[i]);                   ErrFlag = true;                   }           else { /* Use first non-switch argument as the pathname */               strncpy(PathName,myargv[i],MAXBUF-1);               PathName[MAXBUF-1] = '\0';    /* Guarantee a terminator */               break; /* Exit 'for' loop */               }           } /* for */   return(ErrFlag);} /* ParseParm *//****************************************************************** ShowArgs - Display command line arguments, if any, for debugging* ========\****************************************************************/void ShowArgs(int myargc,char *myargv[]){   int i;   printf("\n%d argument%s",myargc,myargc!=1 ? "s - " : "");   if (myargc > 1)      for (i=1; i<myargc; i++)         printf("arg %d = [%s]  ",i,myargv[i]);   printf("\n");} /* ShowArgs *//****************************************************************** callERROR - Display a precoded error message if under the shell* =========\****************************************************************/void callERROR(int err){#if _DEBUG_   printf("callERROR: Error = %d\n",err);#endif   if (!StandAlone)       ERROR(&err);   else       printf("\n");           /* We still the need the newline */} /* callERROR */