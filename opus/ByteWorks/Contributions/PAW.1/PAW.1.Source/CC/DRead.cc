/*	dRead : Dump one or more blocks from a block (disk) device.	Syntax: dRead devNum start_block [end_block | .count] [-A] [-F[A] filename]									 [-S string] [-Z]			-A	- ASCII display only, no hexadecimal			-Z	- Zero blocks (ie. 512 bytes of zero) shown as a 1-line message			-F	- Dump to a file, not the screen			-FA	- Append to a file				filename - name of GSOS path to save file to (filetype = BIN)			-S	- Search for text				string  - Text to search for (case, high-bit ignored).						- Use $xxyyzz to search for hex data	V1.0  Copyright by Peter Watson, Mar 1992.	V1.1  Was copying data to 'buf' pointer while uninitialised!		  Allow <command-.> to skip current block, <option-.> to exit.		  Recompile in ORCA/C 2.0 (=faster). Added '-A' option. Apr 1993	V1.2  Add '-F' option to dump to a file. May 1993.	V1.21 Add '-FA' option to append to a file. Oct 1993.	V1.3  Report but tolerate i/o errors. Reword '-f' message. Dec 1993.	V1.4  Support '.count' alternative to end_block.		  Add '-S' to search for string. Oct 1996	V1.41 Fix check for <command-.> when writing to a file. Dec 1997	V1.5  Add '-Z' to shorten all zero blocks. Hex search bug fix. Mar 1998		  Compiled using ORCA/C 2.10.*/#include <types.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <orca.h>#include <gsos.h>#include <ctype.h>#include <errno.h>#pragma lint -1#pragma expand 0#define VER    "1.5"#define BUFSIZE ((size_t)512)			/* I/O buffer size (1 block)		*/void symfix(void) {}					/* Stop building the .sym file here!	*/extern	int STOP_PAUSE(void);			/* Pause on keypress or <oa-.>		*/word	dumpBlock(longword);			/* Display a block (hex & ASCII)	*/word	dumpASCII(longword);			/* Display a block (ASCII only)		*/boolean	findBlock(longword blk, char *, word *); /* Find text in a block	*/word	initFind(char **);				/* Init cDisp array for seaching	*/char *helloMsg =	"\nDisk Block Reader v" VER "  Copyright 1993-1998 by Peter Watson\n";char *USAGE ="Usage: DREAD devNum startBlk [endBlk|.count] [-A] [-F[A] file] [-S string] [-Z]";char *Licence[] =	"This program contains material from the ORCA/C "					"Run-Time Libraries, copyright 1987-1993 "					"by Byte Works, Inc.  Used with permission.";char *compiled  =	"Compiled on " __DATE__ " at " __TIME__;VersionRecGS vRec = {1, 0};					/* For GetVersionGS request		*/DIORecGS readRec  = {6, 0, NULL, 0, 0, 512L};/*For DReadGS request			*/char		*buf,							/* Pointer to malloc'ed buffer	*/			*zeroes,						/* Pointer to malloc'ed buffer	*/			*findText;						/* pString version of find text	*/word		*cDisp;							/* Character displacement array	*/boolean		doASCII,						/* If TRUE, show ASCII only		*/			doFind,							/* If TRUE, search for text		*/			hexFind,						/* If TRUE, search for hex text	*/			foundText,						/* If TRUE, search text	found	*/			doZeroBlk,						/* If TRUE, zero blocks skipped	*/			doFile,							/* If TRUE, dump to a file		*/			append;							/* If TRUE, append to file end	*//*******************************************************/int main(int argc, char *argv[]){FILE		*fPtr = NULL;					/* File pointer if in '-F' mode	*/word		devNum;							/* Device number				*/longword	firstBlk,						/* First block to dump			*/			lastBlk,						/* Last block to dump			*/			count;							/* Count of blocks to dump		*/longword	ver, blk, x;word		i, j, err = 0;					/* Work variables				*/char		ch, *b,			*findText, *findTextI,			/* Pointer to search string text	*/			*fileName = "";					/* Pointer to filename parameter	*/word		findOff;						/* Offset to found string		*/puts(helloMsg);buf		= zeroes = NULL;				/* No buffer yet	*/doASCII	= doZeroBlk = doFind = hexFind = foundText = doFile = append = FALSE;/* If we have enough parameters, parse for our known options */if ((argc < 3) || (*argv[1] == '?'))  {	puts(USAGE);	goto cleanup;}/*if*/GetVersionGS(&vRec);                /* Get ProDOS / GS/OS version no. */ver = vRec.version & majorRelNumMask;/* Isolate major release info    */ver = ver >> 8;                     /* Make it a 'normal' integer     */if (toolerror() || ver < 2)  {	puts("GS/OS is required to execute this program!");	goto cleanup;}/*if*//* Allocate buffers */x = BUFSIZE + 512L /*cDisp*/ + 256L /*findText*/;buf = malloc(x);					/* Allocate buffers */if (buf == NULL)  {	printf("Unable to allocate memory buffer of %lu bytes\n", x);	goto cleanup;}/*if*/readRec.buffer = buf;				/* Put buffer addr. in dRead parm list*/cDisp	 = (word *)(buf + BUFSIZE);	/* cDisp[256] array (512 bytes!) */findText = buf + BUFSIZE + 512L;	/* findText[256] string *//* Support ProSel shell commands: Final parameter terminates with 0x0d!	*/b  = argv[argc - 1];				/* Last parameter's...				*/while (*b++); b--;					/*				   ...last character*/if (*b == 0x0d)						/* Final parameter is non-standard	*/	*b = '\0';						/* Make it standard!				*//* Get the device number */if ((argc < 2) || (*argv[1] == '-'))  {	/* Switch? */	*buf = '\0';	printf("Enter device number >");	gets(buf);	if (*buf == '\0')				/* He changed his mind */		goto cleanup;	b = buf;} else	b = argv[1];if (*b == '.')  {	if ((*(b+1) == 'D') || (*(b+1) == 'd'))		 devNum = (word)strtoul(b+2, NULL, 10);	/* Get number */	else devNum = 0;} else	devNum = (word)strtoul(b, NULL, 10);		/* Get number */if (!devNum)  {	puts("Invalid device number!");	err = -1;	goto cleanup;}/*if*//* Get the starting block number */if ((argc < 3) || (*argv[2] == '-'))  {	/* Switch? */	*buf = '\0';	printf("Enter starting block number >");	gets(buf);	if (*buf == '\0')							/* He changed his mind */		goto cleanup;	b = buf;} else	b = argv[2];errno = 0;if (*b == '$')	firstBlk = (longword)strtoul(b+1, NULL, 16);/* Get hex number */else	firstBlk = (longword)strtoul(b, NULL, 10);	/* Get decimal number *//* Nb: The pointer 'b' is reused below if no ending_block is entered */if (errno > 0)  {	puts("Invalid starting block number!");	err = -1;	goto cleanup;}/*if*//* Get the ending block number, or block count */if (argc < 1)  {	*buf = '\0';	printf("Enter ending block number >");	gets(buf);	if (*buf == '\0')			/* He changed his mind */		goto cleanup;	b = buf;} elseif ((argc < 4) || (*argv[3] == '-'))	/* Switch? */	;							/* ie. reuse 'starting block' parm! */else	b = argv[3];if (*b == '$')	lastBlk = (longword)strtoul(b+1, NULL, 16);	/* Get hex number */elseif (*b == '.')  {				/* Block count, not end block */	if (*(b+1) == '$')		count = (longword)strtoul(b+2, NULL, 16);/* Get hex number */	else		count = (longword)strtoul(b+1, NULL, 10);/* Get decimal number */	lastBlk	= firstBlk + count - 1;}else	lastBlk = (longword)strtoul(b, NULL, 10);	/* Get decimal number */if (errno > 0)  {	puts("Invalid ending block number!");	err = -1;	goto cleanup;}/*if*/if (lastBlk < firstBlk)  {	puts("Ending block number less than starting block number!");	err = -1;	goto cleanup;}/*if*//* Find any switches */for (i = 1; i < argc; i++)  {	/* Check all parms */	if (*argv[i] == '-')	/* Found a switch */		switch (ch = toupper(argv[i][1]))  {			case 'A' :	doASCII = TRUE;						break;			case 'F' :	doFile = TRUE;						if (argc < i + 2 || *argv[i+1] == '\0')  {							puts("Missing filename parameter!");							puts(USAGE);							err = -1;							goto cleanup;						}/*if*/						fileName = argv[i+1];						if (toupper(argv[i][2]) == 'A')							append = TRUE;		/* Append flag set */						break;			case 'S' :	doFind = TRUE;						if (argc < i + 2 || *argv[i+1] == '\0')  {							puts("Missing search text parameter!");							puts(USAGE);							err = -1;							goto cleanup;						}/*if*/						findTextI = argv[i+1];						strcpy(findText, findTextI);						if (initFind(&findText))							goto cleanup;						break;			case 'Z' :	doZeroBlk = TRUE;						break;			case '?' :	puts(USAGE);						puts(compiled);						err = 0;						goto cleanup;						break;			default  :	printf("Unknown switch character '%c'\n", ch);						puts(USAGE);						err = -1;						goto cleanup;						break;		}/*switch*/}/*for*//* If we are in '-F' mode, open the file, and write a message */if (doFile)  {	fPtr = fopen(fileName, (append ? "ab" : "wb"));	//Open for write or append	if (fPtr == NULL)  {		printf("Unable to open file '%s'!\n", fileName);		err = -1;		goto cleanup;	}/*if*/	printf("%s block", (append ? "Appending" : "Reading"));	if (firstBlk < lastBlk)		printf("s $%lX to", firstBlk);	printf(" $%lX from device %u to file '%s'\n", lastBlk, devNum, fileName);}/*if*/if (doZeroBlk) {	zeroes = calloc(BUFSIZE, (size_t)1);  /* Allocate a buffer of all zeroes */	if (doFile || doFind) {		puts("Warning: '-Z' option ignored if '-F' or '-S' options specified");		doZeroBlk = FALSE;	}/*if*/}/*if*/readRec.devNum 			= devNum;	/* Put devnum in dRead parm list */readRec.requestCount	= BUFSIZE;	/* 1 block (at a time)			 *//******* Read blocks (one at a time) and display them *******/for (blk = firstBlk; blk <= lastBlk; blk++)  {	readRec.startingBlock = blk;Read_Block:		DReadGS(&readRec);			/* Read the block */	err = toolerror();	if (err)		switch (err)  {			case devNotFound:				/* Device not found		*/			case invalidDevNum:				/* Invalid device number*/				printf("Device %u not found!\n", devNum);				goto cleanup;			case drvrDiskSwitch:		    /* Disk switched error	*/				goto Read_Block;			/* Simply try again		*/			case drvrOffLine:				/* No disk in drive		*/				puts("No disk in drive!");				goto cleanup;			case drvrIOError:				/* I/O error			*/				printf("I/O error reading block $%lX (%lu)!\n\n", blk, blk);				continue;	/* Next block in 'for' loop */				break;			case drvrBadBlock:				/* Bad block			*/			case outOfRange:				/* Parm out of range	*/				printf("Block $%lX (%lu) does not exist!\n", blk, blk);				goto cleanup;			case notBlockDev:				/* Not a block device	*/				printf("Device %u is not a block device!\n", devNum);				goto cleanup;			default :				printf("Error $%0.4X reading block $%lX (%lu)\n", err, blk,blk);				goto cleanup;		}/*switch*//******* Display the data (or write to the file) *******/	if (doFile)  {		fwrite(buf, 1L, BUFSIZE, fPtr);	/* Write BUFSIZE 1-byte elements */		if (ferror(fPtr))  {			printf("Error writing block $%lX to '%s'\n", blk, fileName);			err = -1;			goto cleanup;		}/*if*/		if (STOP_PAUSE())				/* User pressed <Command-.> */			goto cleanup;		continue;						/* Continue the for loop	*/	}/*if*/	if (doFind)  {						/* Find block, if necessary */		if (!findBlock(blk, findText, &findOff))			continue;		if (blk > firstBlk)			putchar('\n');		printf("<<< Search string '%s' found at +$%0.4X >>>\n\n",				findTextI, findOff);		foundText = TRUE;	} else {		if (blk > firstBlk)			putchar('\n');	}/*else*/	printf("%cBlock $%0.6lX  (%ld)%c", 15, blk, blk, 14); /* Inverse */	/* Check for an all zero block (so we can write a summary line only) */	if (doZeroBlk) {		if (memcmp(buf, zeroes, BUFSIZE) == 0) {			printf("  <<< Block contains all zero bytes >>>\n");			if (STOP_PAUSE() == 2)				goto cleanup;	/* User pressed <Option-. >	*/			continue;			/* Continue the for loop	*/		}/*if*/	}/*if*/	putchar('\n');	/* Display the data */	i = doASCII ? dumpASCII(blk) : dumpBlock(blk);	if (i == 2)					/* Skip to next block for <Command-.> */		goto cleanup;			/* User pressed <Option-.>			 */}/*for each block*/if (doFind && foundText == FALSE)	printf("Search string '%s' not found!\n", findTextI);/******* Clean up and go home *******/cleanup:if (fPtr != NULL)						/* If file is open, close it */	fclose(fPtr);if (zeroes != NULL)						/* If buffer allocated, free it */	free(zeroes);if (buf != NULL)						/* If buffer allocated, free it */	free(buf);exit(err);}/*main*//*******************************************************/word dumpBlock(longword blkNo)  {/*	dumpBlock - Display the current block in hex and ASCII*/word	off, i, j;char	ch, *k;/* Print data in hex, 16 bytes per line, with ASCII format on the right. *///printf("%cBlock $%0.6lX  (%ld)%c\n", 15, blkNo, blkNo, 14); /* Inverse */for (off = 0; off < 512; off += 16)  {			printf("%0.4X  |  ", off);				/* Print offset */	k = buf + off;	for (i=4; i; i--)  {		printf("%0.2X%0.2X%0.2X%0.2X ",		/* Print hex data */				*k, *(k+1), *(k+2), *(k+3));		k += 4;	}/*for*/	printf(" |  ");	k -= 16;	for (i = 16; i; i--)  {					/* Print ASCII */		ch = *(k++) & 0x7f;		putchar(ch > ' ' ? ch : ' ');		/* Make <ctrl>-chars printable */	}/*for*/	puts("  |");	if (i = STOP_PAUSE())		return i;	/* User pressed <command-.> or <option-.> to exit early */}/*for*/return 0;}/*dumpBlock*//*******************************************************/word dumpASCII(longword blkNo)  {/*	dumpASCII - Display the current block in ASCII only*/word	off, i, j;char	ch, *k;/* Print ASCII data only *///printf("%cBlock $%0.6lX  (%ld)%c\n", 15, blkNo, blkNo, 14); /* Inverse */for (off = 0; off < 512; off += 64)  {	printf("%0.4X  |  ", off);				/* Print offset */	k = buf + off;	for (i = 64; i; i--)  {					/* Print ASCII */		ch = *(k++) & 0x7f;		putchar(ch > ' ' ? ch : ' ');		/* Make <ctrl>-chars printable */	}/*for*/	puts("  |");	if (i = STOP_PAUSE())		return i;	/* User pressed <command-.> or <option-.> to exit early */}/*for*/return 0;}/*dumpASCII*//*******************************************************/boolean findBlock(longword blkNo, char *text, word *findOff)  {/*	findBlock - Search current block for a text string.				Note: 'text' is a 'pString' (it may contain nulls)!	If hexFind is TRUE, then bytes are matched literally, else string is	assumed to be text and comparison is case- and high-bit insensitive.	Returns TRUE if text found (and sets offset in block to findOff)	Search method based on article by Mike Westerfield in Call Apple, Dec 1988.*/word	i, len, t;int		tLen;char	*p, *q;p		= buf-1;							/* Source pointer		*/tLen	= BUFSIZE;							/* Source length		*/q		= text+1;							/* Search string pointer*/len		= *text;							/* Search string length	*/do {	i = len;	if (hexFind)  {		while (i && (*(p+i) == *(text+i)))					// Case sensitive			i--;		t = cDisp[*(p+len)];				/* Get displacement	*/	} else  {		while (i && (toupper(*(p+i) & 0x7F) == *(text+i)))	// Case insensitive			i--;		t = cDisp[*(p+len) & 0x7F];			/* Get displacement	*/	}/*else*/	if (i == 0)  {		*findOff = p + 1 - buf;				/* Offset to found string */		return TRUE;						/* Found it! */	}/*if*/	p	 += t;								/* Bump pointer		*/	tLen -= t;								/* Shrink length	*/} while (tLen >= len);if (STOP_PAUSE())	return TRUE;	/* User pressed <command-.> to exit early */return FALSE;}/*findBlock*//*******************************************************/word initFind(char **text)  {/*	initFind	- Initialise the search string displacement array.				  (Basically, if the char is not found, skip cDisp[] chars.)				- Uppercase the search string or convert it from hex to text.				- Convert from cString to pString, so we can handle nulls.	Returns TRUE if text found*/word	i, len;char	c, ch, *p, *q, *findText;findText = *text;							/* Point to search string	*//* Check for and convert a hex string to ASCII *//* Also, text or hex, make the string a 'pString' */if (*findText == '$')  {					/* Convert hex data */	hexFind = TRUE;	if ((strlen(findText) & 1) == 0)  {badHex:		printf("Hex search string invalid (length or chars)!\n");		return -1;	}/*if*/	p = q = findText+1;						/* Skip '$' */	while (c = *(p++))  {		if (!isxdigit(c))	goto badHex;		ch = toint(c) << 4;					/* High nibble */		c  = *(p++);		if (!isxdigit(c))	goto badHex;		*(q++) = ch | toint(c);				/* Store byte */	}/*while*/	*findText = q - findText - 1;			/* String length */} else {	p = findText;	while (*(p++) = toupper(*p));			/* Upper case the string */	p = c2pstr(findText);					/* Make into a pString */	memcpy(findText, p, (size_t)(1 + *p));	/* Include length byte! */}/*else*//* Initialise the character displacement (cDisp) array */len	= (word)*findText;						/* Length of search string		*/for (i = 0; i < 256; i++)					/* 256 words (can't use memset!)	*/	cDisp[i] = len;							/* Default to full length skips	*//* If a char is repeated, we want the displacement for the *last* instance!	*/for (i = 1; i < len; i++)  {	ch = *(findText + i);	cDisp[ch]			= len - i;	if (!hexFind)							/* For text strings...			*/	cDisp[tolower(ch)]	= len - i;			/* ..treat lower case like upper	*/}/*for*/#if 0		// Debugging only//-----------------------------------------------------------------------printf("---------------------------------------------------------------\n");printf("findString=");for (i = 0; i < 1 + len; i++)	printf("%0.2X ", *(findText + i)); putchar('\n');printf("cDisp:\n");for (i = 0; i < 128; i += 16) {	for (len = i; len < i + 16; len++)		printf("%c  ", ((char)len < ' ' ? '.' : (char)len)); putchar('\n');	for (len = i; len < i + 16; len++)		printf("%0.2X ", cDisp[len]); putchar('\n');}/*for*/if (STOP_PAUSE())	goto cleanup;	/* User pressed <Option-. >	*/if (hexFind)for (i = 128; i < 256; i += 16) {	for (len = i - 128; len < i + 16 - 128; len++)		printf("%c  ", ((char)len < ' ' ? '.' : (char)len)); putchar('\n');	for (len = i; len < i + 16; len++)		printf("%0.2X ", cDisp[len]); putchar('\n');}/*for*/printf("---------------------------------------------------------------\n");//-----------------------------------------------------------------------#endifreturn 0;}/*initFind*/