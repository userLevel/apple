/*	PFSext : Extract the data records from a (Pascal-based) PFS data disk	Syntax: PFSext [-I] [D] devNum filename			-I		- Ignore I/O errors when reading			-D		- Debug mode			devNum	- Device number containing the PFS data disk			filename- Pathname of the file to contain the extracted data records	V1.0  ORCA/C version copyright by Peter Watson, Sep 1997.	Based on an Applesoft Utility written by Jim Luther in 1986.	Compiled using ORCA/C 2.10.*/#include <types.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <orca.h>#include <gsos.h>#include <ctype.h>#include <errno.h>#pragma  lint -1#pragma expand 0void symfix(void) {}					/* Stop building the .sym file here!	*/#include <gsbug.h>#define VER			"1.0"#define BUFSIZE		(140L * 1024L)		/* I/O buffer size (140K)			*/#define RBUFSIZE	( 32L * 1024L)		/* Record buffer size (32K)			*/#define SBUFSIZE	( 32L * 1024L)		/* String buffer size (32K)			*/#define MAXBLK		(140 * 8)			/* Max PFS 128 byte block (140K * 8)	*/#define peek(adr)	*(byte *)(adr)		/* Return byte at 'adr'				*/#define peek2(adr)	*(word *)(adr)		/* Return word at 'adr'				*/#define readPBlk(b)	(buf + ((long)b<<7))/* Return adr of Pascal 128 byte blk	*/boolean badBlk(word, char *);			/* Check for a valid PFS block #	*/int		checkStop(void);				/* Check for <Command-.> to cancel	*/char *helloMsg = \	"\nPFS Data Extractor v" VER "  Copyright 1997 by Peter Watson\n";char *USAGE = \	"Usage: PFSext [-I(gnore i/o errs)] [-D(ebug)] devNum filename";char *Licence[] =	"This program contains material from the ORCA/C",					"Run-Time Libraries, copyright 1987-1993",					"by Byte Works, Inc.  Used with permission.";VersionRecGS vRec = {1,0};					/* For GetVersionGS request		*/DIORecGS readRec  = {6,0,NULL,0,0,512L,0};	/* For DReadGS request			*/char		*keybd  = (char *)0xe1c000;		/* Used by checkStop() */char		*strobe = (char *)0xe1c010;char		*keycmd = (char *)0xe1c061;		/* Command key */char		*buf, *rbuf, *sbuf;				/* Pointer to malloc'ed buffers	*/char		name[16];						/* Pointer to name of PFS file	*/boolean		tolErr,							/* If TRUE, tolerate i/o errors	*/			debug;							/* If TRUE, debug mode active	*//*******************************************************/int main(int argc, char *argv[]){FILE		*fPtr;							/* File pointer					*/word		devNum;							/* Device number				*/longword	ver, x;word		i, j, k, err, errCount;			/* Work variables				*/word		pg, bp, blk, tr, nr, nb, cl, fl;word		recs;							/* Record (form) count			*/char		ch, *b, *pnt, *ns,			*fileName = "";					/* Pointer to filename parameter	*/puts(helloMsg);err		= 0;							/* Assume no error		*/errCount= 0;							/* Assume no i/o errors	*/recs	= 0;							/* No records yet		*/buf		= NULL;							/* No buffer yet		*/fPtr	= NULL;							/* No file yet			*/tolErr	= FALSE;						/* Don't tolerate errors*/debug	= FALSE;						/* Debug mode inactive	*//* If we have enough parameters, parse for our known options */if ((argc < 3) || (*argv[1] == '?'))  {	printf(USAGE);	goto cleanup;}/*if*/GetVersionGS(&vRec);                /* Get ProDOS / GS/OS version no. */ver = vRec.version & majorRelNumMask;/* Isolate major release info    */ver = ver >> 8;                     /* Make it a 'normal' integer     */if (toolerror() || ver < 2)  {	puts("GS/OS is required to execute this program!");	goto cleanup;}/*if*//* Allocate buffers */x	= BUFSIZE + RBUFSIZE + SBUFSIZE;buf = malloc(x);					/* Allocate buffer */if (buf == NULL)  {	printf("Unable to allocate memory buffer of %lu bytes\n", x);	goto cleanup;}/*if*/rbuf = buf  + BUFSIZE;				/* Record output area */sbuf = rbuf + RBUFSIZE;				/* String output area *//* Support ProSel shell commands: Final parameter terminates with 0x0d!	*/b  = argv[argc-1];					/* Last parameter's...				*/while (*b++); b--;					/*				   ...last character*/if (*b == 0x0d)						/* Final parameter is non-standard	*/	*b = '\0';						/* Make it standard!				*//* Find any switches */for (i=1; i<argc; i++)  {	/* Check all parms */	if (*argv[i] == '-')	/* Found a switch */		switch (ch = toupper(argv[i][1]))  {			case 'D' :	debug = TRUE;						break;			case 'I' :	tolErr = TRUE;						break;			default  :	printf("Unknown switch character '%c'\n",ch);						puts(USAGE);						err = -1;						goto cleanup;						break;		}/*switch*/	else break;		/* No more switches */}/*for*/if (i == argc) {	puts("Missing device number parameter!");	puts(USAGE);	err = -1;	goto cleanup;}/*if*//* Get the device number */b = argv[i];									/* First non-switch parm */if (*b == '.')  {	if ((*(b+1) == 'D') || (*(b+1) == 'd'))		 devNum = (word)strtoul(b+2,NULL,10);	/* Get number */	else devNum = 0;} else	devNum = (word)strtoul(b,NULL,10);			/* Get number */if (!devNum)  {	puts("Invalid device number!");	err = -1;	goto cleanup;}/*if*/if (i++ >= argc)  {	puts("Missing filename parameter!");	err = -1;	goto cleanup;}/*if*/fileName = argv[i];/* Open the output file, and write a message */fPtr = fopen(fileName, "w");		/* Open for write */if (fPtr == NULL)  {	printf("Unable to open file '%s'!\n", fileName);	err = -1;	goto cleanup;}/*if*/puts("Loading disk image into memory...\n");readRec.devNum 			= devNum;	/* Put devnum in dRead parm list	*/readRec.buffer			= buf;		/* Put buf adr in dRead parm list	*/readRec.requestCount	= BUFSIZE;	/* Read the whole disk for speed	*/readRec.startingBlock	= 0L;		/* Start at block 0 (of course)		*/Read_Block:	DReadGS(&readRec);				/* Read the disk */	err = toolerror();	if (err)		switch (err)  {			case devNotFound:				/* Device not found		*/			case invalidDevNum:				/* Invalid device number*/				printf("Device %u not found!\n", devNum);				goto cleanup;			case drvrDiskSwitch:		    /* Disk switched error	*/				goto Read_Block;			/* Simply try again		*/			case drvrOffLine:				/* No disk in drive		*/				puts("No disk in drive!");				goto cleanup;			case drvrIOError:				/* I/O error			*/				if (tolErr)  {				/* Allowed to retry?	*/					errCount++;				/* Count this error		*/					x = readRec.transferCount; /* What *did* we get?*/					printf("I/O error reading disk on block %u! Continuing!\n",							readRec.startingBlock+(x>>9) );					if (debug)						printf("Old request:\n"								"- Buffer = $%p\n- Block  = %lu\n"								"- Bytes  = %lu\n- Xfer   = %lu\n",								readRec.buffer, readRec.startingBlock,								readRec.requestCount, x);					memset(readRec.buffer+x, 0, 512L);/* Fake block	*/					if (x & 0x00000100)		/* Got 1st sector in blk*/						x -= 256L; 			/* 256 byte sectors!	*/					x += 512L;				/* Allow for fake block	*/					readRec.buffer += x;	/* Adjust buffer pointer*/					readRec.startingBlock += (x>>9);/* Fix blk count*/					readRec.requestCount -= x; /* Read the remainder*/					if (debug)						printf("New request:"								"- Buffer = $%p\n- Block  = %lu\n"								"- Bytes  = %lu\n",								readRec.buffer, readRec.startingBlock,								readRec.requestCount);					if ((long)readRec.requestCount <= 0) /* Last block? */						break;				/* Yes, just continue	*/					goto Read_Block;		/* Try to read some more*/				}/*if*/  				printf("I/O error reading disk! (Use '-i' to ignore)\n\n");				goto cleanup;				break;			case notBlockDev:				/* Not a block device	*/				printf("Device %u is not a block device!\n", devNum);				goto cleanup;			default :				printf("Error $%0.4X loading disk image\n", err);				goto cleanup;		} /*switch*/if (errCount)	printf("\nDue to %u previous disk error%s, "			"processing and/or results may be unreliable!\n\n",			errCount, (errCount==1 ? "" : "s"));/* OK, we've read the disk into our buffer - let's process it */pnt = buf + 86L;					/* Point to filename */i = *(pnt++);						/* Get length */if (i > 8)  {	puts("Invalid length for name of PFS file! (Not a PFS disk?)");	goto cleanup;}/*if*/memcpy(name, pnt, (long)i);			/* Copy the filename */*(name+i) = '\0';					/* Terminator */pnt = buf + 4L;pg	= peek2(pnt);					/* # of form pages */if (pg > 32)  {	puts("Invalid # of form pages! (Not a PFS disk?)");	goto cleanup;}/*if*/pnt = buf + 8L;bp	= peek2(pnt);					/* Pointer (block) to first form */if (badBlk(bp, "First block"))	goto cleanup;printf("PFS file name = %s   (%d page%s per form)\n\n",		name, pg, (pg == 1 ? "" : "s"));printf("Processing records . ");/* Read the data for the next record */nextRecord:pnt = readPBlk(bp);					/* Point to block area in memory */tr	= peek2(pnt+6);					/* Set TR to this record number */nr	= peek2(pnt+10);				/* Set NR to point to next record */if (debug)  {	printf("\n(nextRec: rec=%u, blk=%u) ", tr, bp);	fprintf(fPtr, "[Record %u at PFS block %u (disk block %u)]\n", tr,bp,bp>>2);}/*if*/recs++;/* Copy a record's (discontiguous!) disk data chunk(s) to our record buffer */ns	= rbuf;							/* Start of output buffer	*/memcpy(ns, pnt+12L, 114L);			/* Copy initial data bytes	*/ns += 114L;							/* Next buffer area			*/nb	= peek2(pnt+126);				/* Set NB -> next block of this record */if (debug) printf("[nb = %u (d:%u)] ", nb, nb>>2);if (badBlk(nb, "Next block"))	goto cleanup;/* Copy remaining data block chunks */while (nb)  {	pnt = readPBlk(nb);				/* Point to block data		*/	memcpy(ns, pnt, 126L);			/* Copy data bytes			*/	ns += 126L;						/* Next buffer area			*/	nb	= peek2(pnt+126L);			/* NB -> next block of this record */	if (debug) printf("[nb = %u (d:%u)] ", nb, nb>>2);	if (badBlk(nb, "Next block"))		goto cleanup;	if (checkStop())				/* User pressed <Command-.> */		goto cleanup;}/*while*//* Now that the record data is contiguous, process the fields in the record */if (debug) printf("(procFields) ");pnt = rbuf;							/* Start of record data */while (fl = peek2(pnt))  {			/* While field length > 0 */	if (checkStop())				/* User pressed <Command-.> */		goto cleanup;	if (debug) printf("+");	k = 0;							/* Length of output string */	if (fl < 7)						/* 7 = length of single char string */		if (peek(pnt+4) < 128)			goto nextField;			/* If blank field, then skip to output */	/* Copy data for this field */	for (b=pnt+4; b <= pnt+fl-3; b++)  {		ch = peek(b);		if (ch == 1)  {				/* Decompress spaces */			for (j=peek(b+1); j; j--)				*(sbuf+(k++)) = ' ';/* Append spaces */			b += 2;					/* Allow for extra bytes */		} else			*(sbuf+(k++)) = ch & 0x7f;/* Append another character */	}/*for*/	if ((ch = peek(b)) > 127)		*(sbuf+(k++)) = ch & 0x7f;	/* Append another character (why??) */        nextField:	pnt += fl;						/* Point past this field */	cl++;							/* Count this field */	*(sbuf+k) = '\0';				/* String terminator */	fprintf(fPtr, "%s\n", sbuf);	/* Output this field */}/*while*/printf(". ");if (checkStop())					/* User pressed <Command-.> */	goto cleanup;/* If there are more records, go process them */if (nr)  {	if (badBlk(nr, "Next record"))		goto cleanup;	bp = nr;							/* Set block for next record */	cl = 0;								/* Reset field count */	goto nextRecord;}/*if*/printf("\n\nExtracted %u records (%u fields per record)\n", recs, cl);/******* Clean up and go home *******/cleanup:if (fPtr != NULL)						/* If file is open, close it */	fclose(fPtr);if (buf != NULL)						/* If buffer allocated, free it */	free(buf);exit(err);}/*main*//*******************************************************/boolean badBlk(word blk, char *why)  {/* Check validity of a PFS block number, issuing a message if it is bad */if (blk < MAXBLK)	return FALSE;printf("\nInvalid PFS block # (%u) - %s\n", blk, why);return TRUE;}/*badBlk*//*******************************************************/int checkStop(void)  {/* Check for command-'.' pressed to abort processing */char ch;if ((ch = *keybd) < 0x80)	return 0;				/* Key pressed? */*strobe = ch;										/* Clear key strobe */if (ch == (0x80+'.') && *keycmd > 0x7f)	return 1;	/* <Command-.>? */return 0;}/*checkStop*/