/*	ADB.READER : Display AppleWorks ADB (database) files.	The algorithm is based on the BASIC program written in Applesoft	by Tom Weishaar in Open-Apple (now A2-Central) in March 1987.	(This explains some of the weird names, eg. 'peek' for a buffer!)	Supports AppleWorks V3.0, and displays any 'tag data' in hex.	Syntax :  ADB.READER [-M] [-L] [-D] filename				-M : Multi Record Layout mode				-L : Display the file layout (ie. category numbers and locs)				-D : Double-Data file support (tolerates extra 30 categories)	V1.0  Copyright by Peter Watson, Jan 1992.	V1.1  Load file in one pass into a dynamically allocated buffer.		  Support '-L' option to display record layout. Add <oa-?> for help.		  Support <oa-F> as a Find command.		  Support <oa-UpArrow> to return to previous record.		  Support <oa-1> to <oa-9> to move through the file.  Feb 1992.	V1.2  Support 'Multi Record Layout' format via 'OA-Z' command & '-M' option.		  Made a few cosmetic changes while I was there.		  This version requires GSOS (and the .CONSOLE driver). Feb 1992	V1.3  Prompt if no file name (eg. standalone). If R=0, 'OA-down' = 'down'.		  Close and reopen stdin and stdout pointing to '.CONSOLE'. Mar 1992	V1.31 Playing with '.CONSOLE' doesn't seem to work under System 6. Also, I		  could have sworn the code for filename case used to work! Apr 1992.	V1.40 Compiled with ORCA/C 2.01. (Now works properly from the Finder).		  Reprompts for another file when finished if standalone! Displays		  offset to record in SRL. Find/Jump errors report error record. Added		  <oa-J> JUMP command, and '-D' DoubleData (60 cat's) option. Sep 1993.	V1.41 Fix screen format messed up if > 9 reports. 1994 copyrights. Mar 1994.	V1.42 Use '*(int *)' not a 'byte' calculation for pk2. Allow '=' and <oa-G>		  for 'Repeat Find'. Compiled with ORCA/C 2.10. Sep 1997.*/#include <types.h>#include <stdio.h>#include <stdlib.h>#include <string.h>#include <orca.h>#include <ctype.h>#include <errno.h>#include <misctool.h>#include <gsos.h>void symfix(void) {}					/* Stop building the .sym file here!	*/#pragma lint		-1#pragma expand		0#define DEBUG		0#define VER			"1.42"#define BUFSIZE		8192					/* I/o buffer size				*/#define CATSIZE		128 					/* Max category size + 1		*/#define CATNAMESIZE 21  					/* Max category name size + 1	*/#define CATNUM		61	/* 60 if '-D' */	/* Number of categories + 1		*/#define clEOL		29  					/* Clear to End-Of-Line			*/#define scrollDown	22						/* Scroll text port down 1 line	*/#define scrollUp	23						/* Scroll text port up   1 line	*/#define esc			27  					/* Escape key					*/#define leftArrow	 8  					/* Left-Arrow key				*/#define downArrow	10  					/* Down-Arrow key				*/#define upArrow		11  					/* Up-Arrow key					*/#define rightArrow	21  					/* Right-Arrow key				*/#define peek(adr)			*(bufPtr+adr)#define pk2(adr)			*(word *)(bufPtr+adr)#define home				putchar('\f')#define gotoXY(Y,X)			printf("\x1e%c%c", X+31, Y+31)#define makeWindow(Top,Bot)	printf("\x2\x20%c\x79%c", Top+31, Bot+31)#define popWindow			putchar(0x04)extern int STOP_PAUSE(void);			/* Pause on keypress or <oa-.>	*/void getCategories(void);				/* Read categories into c[n]	*/void getCategory(word n);				/* Read a single category		*/void showTags(void);					/* Dump Tag Data in hex			*/int  doFind(char); 						/* Find string in any category	*/int  doJump(void); 						/* Jump to a specified record #	*/char getKey(void);						/* Get a keystroke				*/int  parseParm(int argc, char *argv[]);	/* Parse any parameters			*/void showHelp(void);					/* Display a command key help	*/void doError(int err);					/* Report error, then exit		*/void clearWindow(void);					/* Clear the display window		*/void setMRLTitles(void);				/* Display the MRL mode titles	*/void showMRLLine(int row);				/* Display MRL mode data line	*/char *USAGE = "AppleWorks ADB File Reader v"VER"\n"		\			  "Copyright 1993-1997 by Peter Watson\n\n"	\			  "Usage : ADB.READER [-M] [-L] [-D] pathname\n"	\			  "        -M : Multi Record Layout (default is Single Record)\n"\			  "        -L : Display the layout of the categories\n"\			  "        -D : DoubleData format (tolerates extra 30 categories)\n";char *month[12] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", \					"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};char OA[6] = {0x1b,0x0f,'A',0x0e,0x18,'\0'};	/* Mousetext Open-Apple  */char UA[6] = {0x1b,0x0f,'K',0x0e,0x18,'\0'};	/* Mousetext Up-Arrow    */char DA[6] = {0x1b,0x0f,'J',0x0e,0x18,'\0'};	/* Mousetext Down-Arrow  */char LA[6] = {0x1b,0x0f,'H',0x0e,0x18,'\0'};	/* Mousetext Left-Arrow  */char RA[6] = {0x1b,0x0f,'U',0x0e,0x18,'\0'};	/* Mousetext Right-Arrow */char CR[6] = {0x1b,0x0f,'M',0x0e,0x18,'\0'};	/* Mousetext <return>    */char *errMsg[] =  {	  /*  0 */	"Header length more than 1017 ($3F9)",	  /*  1 */	"Too many reports (8 for v1, v2; 20 for v3)",	  /*  2 */	"More than 30 categories (more than 60 for DoubleData mode)",	  /*  3	*/	"Calculated header length different from stored header length",	  /*  4	*/	"Invalid record length, or record data corrupted (missing $FF)",	  /*  5	*/	"Calculated record length different from stored record length",	  /*  6	*/	"Unknown category type (not Date, Time, text)",	  /*  7	*/	"EOF marker not found after last record",	  /*  8	*/	"Tag count does not match number of Tags found",	  /*  9 */  "EOF marker not found on initial search",	  /* 10 */  "Attempt to read to end-of-file failed",	  /* 11 */  "Insufficient memory to load file",	  /* 12 */  "Number of MRL categories greater than number of categories",/* MAXERR+1 */  "Unknown error number"}; /***** Must be last! *****/#define MAXERR	13				/* No. of supported error messages + 1		*/FILE *inFile= NULL;            	/* Input file								*/VersionRecGS vRec		= {1,0};/* For GetVersionGS request					*/FileInfoRecGS infoRec	= {9};	/* For GetFileInfoGS request				*/word dateMode,  				/* Control Panel date format (ex ReadBParam)	*/	 timeMode,  				/* Control Panel time format (ex ReadBParam)	*/	 auxType;					/* Auxtype from file's directory entry		*/long pntr,						/* Position in buffer						*/	 oldPntr,					/* Saved position during FIND, JUMP commands */	 firstRec, 					/* Buffer position of first data record		*/	 lastRec,  					/* Buffer position of last data record		*/	 fileSize,					/* Size of file (= size of buffer)			*/	 one_8th; 					/* Size of one eighth of file (for <OA-n>)	*/word ver,						/* Version number							*/	 hl,						/* Header length							*/	 nr,						/* Number of records	(displayable)		*/	 nc, dnc,					/* Number of categories	(displayable)		*/	 ncMRL, dncMRL,				/* Number of categories	shown in MRL format	*/	 nf,						/* Number of report formats					*/	 r, oldRec,					/* Record number (and saved copy)			*/	 n,							/* Category number							*/	 rl;						/* Record length							*/int	 exitCode = -1,				/* Code to be issued by exit(exitCode)		*/	 maxCats = 30,				/* Maximum # of categories (30 or 60)		*/	 standAlone,				/* = 0 if not running under a command Shell	*/	 oneLine = 0;				/* = 1 or 15 if a one-line scroll requested	*/boolean optM = FALSE,           /* = true if '-M' specified					*/		optL = FALSE,			/* = true if '-L' specified					*/		optD = FALSE,			/* = true if '-D' specified					*/		MRLmode = FALSE,		/* = true if in Multi Record Layout mode	*/		finalExit = TRUE;		/* Don't retry from cleanup if 'standAlone'	*/char *bufPtr = NULL;			/* Pointer to dynamically allocated file buf	*/GSString255 fileName;			/* Buffer for path & filename				*/char *findString,				/* Buffer for string to be used by FIND		*/	 *oldString;				/* Buffer for string to be reused by FIND	*//* Common (SRL & MRL) data */char cn[CATNUM][CATNAMESIZE],	/* Category names - 1 to 20 chars			*/	  c[CATNUM][CATSIZE];		/* Category Info - 0 to 127 chars			*/word tb[CATNUM][3];	   /*SRL*/	/* Category #'s & TAB positions on the screen*/word cw[CATNUM][2];	   /*MRL*/	/* Category #'s and column widths			*//*******************************************************/int main(int argc, char *argv[]){long x, ver;word i, err;							/* Work variables	*/char ch;standAlone = !argc;						/* argv[0] = Shell name, if present *//* If we have enough parameters, parse for our known options */if (argv[1][0] == '?' || argc == 1)  {	printf(USAGE);	goto cleanup;}/*if*/if (parseParm(argc, argv))  {		/* Parameter error */	printf(USAGE);	goto cleanup;}/*if*/GetVersionGS(&vRec);                /* Get ProDOS / GS/OS version no. */ver = vRec.version & majorRelNumMask;/* Isolate major release info    */ver = ver >> 8;                     /* Make it a 'normal' integer     */if (toolerror() || ver < 2)  {	puts("\nGS/OS is required to execute this program");	goto cleanup;}/*if*//* Ensure our output will be seen in the proper format - open the	*//* .CONSOLE driver as 'stdout'.  Appears to work better if we redo	*//* 'stdin' at the same time. Why doesn't 'freopen' work?			*//* Appears to fail under System 6 - so can't use if .CONSOLE active */if (ver < 4)  {						/* Doesn't seem to work under System 6 */	fclose(stdout);	if ((stdout = fopen(".CONSOLE", "w")) == NULL)  {			puts("\nThe GS/OS console driver is required to execute this program");		goto cleanup;	}/*if*/	setbuf(stdout,NULL);			/* Ensure data is written when we expect */	fclose(stdin);	if ((stdin = fopen(".CONSOLE", "r")) == NULL)  {			puts("\nUnable to open the GS/OS console driver for input");		goto cleanup;	}/*if*/	setbuf(stdin,NULL);				/* Ensure data is read when we expect */}/*if*/findString	= malloc(256L);			/* Allocate a find string buffers	 */oldString	= findString+128;		/* Use second half of the buffer	 */*findString = *oldString = '\0';	/* No contents yet					 *//* Get date & time formats from the Control Panel for date & time categories */dateMode = ReadBParam(dateFormat);	/* Get Control Panel date format	 */									/* in case there are any date fields */timeMode = ReadBParam(clockFormat);	/* Get Control Panel time format	 */									/* in case there are any time fields */MainLoop:							/* Main loop in 'standAlone' mode	 */if (standAlone)  {					/* Prompt for filename */		puts("AppleWorks ADB File Reader v" VER);		puts("Copyright 1993-1997 by Peter Watson\n");		printf("Enter filename >");		gets(fileName.text);		if (*fileName.text == '\0')  {			goto cleanup;		}/*if*/		finalExit = FALSE;			/* Return here next time from 'cleanUp' */		home;}/*if*//* Open input file in 'binary' mode */fileName.text[254] = '\0';					/* Dumb safety guarantee */if ((inFile = fopen(fileName.text, "rb")) == NULL)  {	puts("AppleWorks ADB File Reader v"VER);	printf("\nUnable to open '%s'\n", fileName.text);	goto cleanup;}/*if*//******* Get various bits of file info via GSOS *******/fileName.length    = strlen(fileName.text);	/* GS String format */infoRec.pathname   = (GSString255Ptr)&fileName;GetFileInfoGS(&infoRec);if (err = toolerror())  {	puts("AppleWorks ADB File Reader v"VER);	printf("\nGetInfo failed with error $%0.4lX\n", err);	exitCode = err;	goto cleanup;} /*if*/fileSize = infoRec.eof;						/* Get the file size for later */if (infoRec.fileType != 0x19)  {	printf("%s is not filetype ADB!\n", fileName.text);	exitCode = -1;	goto cleanup;} /*if*/auxType = infoRec.auxType;					/* Get the auxillary type */#if DEBUG	printf("+++ Original AuxType = $%0.4X\n",auxType);#endifasm {										/* We need the bytes 'flipped' */	lda	auxType	xba	sta auxType}/*asm*//******* Make the filename into AppleWorks style (mixed case & spaces) *******//* We can reuse the fileName buffer now */if (fileName.text[fileName.length] == '/')	/* Ignore a trailing '/' */	fileName.text[fileName.length] = '\0';	/* Shrink the string by 1 */if ((i = strrpos(fileName.text,'/')) > 0)	/* Path and filename? */	strcpy(fileName.text, &fileName.text[i+1]);/* Filenames are assumed to be all uppercase */#if DEBUG		printf("+++ Filename before conversion = %s\n", fileName.text);#endiffor (i=0; i<15; i++)   						/* Convert name to proper case */	if (auxType & (1 << (15-i)))  {		if (isalpha(fileName.text[i]))			fileName.text[i] = _tolower(fileName.text[i]);		else		if (fileName.text[i] == '.')			fileName.text[i] = ' ';			/* Make into a space! */#if DEBUG		putchar('x');#endif	}/*if*/	else  { /* User may have entered mixed case - fix it */		if (isalpha(fileName.text[i]))			fileName.text[i] = _toupper(fileName.text[i]);#if DEBUG		putchar('X');#endif	}/*else*/#if DEBUG	printf( " = Upper/Lower case in filename\n" \			"+++ File name = %s\n", fileName.text);#endif/******* Load the file into memory *******/exitCode = 0;						/* Default to a good return code now */#if DEBUG	puts("+++ Loading the file into memory");#endif#if 0								/* Replaced by GetFileInfo call		      */if (fseek(inFile, -1L, SEEK_END))	/* Find EOF by seeking 1 byte from the end*/	doError(10);					/* Unable to seek to end of file		 */fileSize = ftell(inFile)+1;			/* ftell doesn't include that last byte!  */#endif#if DEBUG	printf("+++ AuxType = $%0.4X\n+++ File size = %ld\n", auxType, fileSize);#endifif ((bufPtr = malloc(fileSize+1)) == NULL)	/* Allocate a file buffer */	doError(11);					/* Insufficient memory */rewind(inFile);						/* Back to the beginning again   */fread(bufPtr, 1L, fileSize, inFile);/* Read the file into the buffer */*(bufPtr+fileSize) = '\0';			/* Ensure 'tag data' check works */pntr = 0;/******* Dig stuff out of the header *******/#if DEBUG	puts("+++ Decoding header information");#endifver = peek(pntr+218);				/* Version needed, eg. v3.0 = 30, else 00 */hl  = pk2(pntr)+2;          		/* Header length */if (!optD)							/* Unless DoubleData mode */if (hl > 1017) doError(0);			/* Impossible header length */nr  = pk2(pntr+36);					/* Number of records */i = 0;if (ver)	if (nr & 0x8000)  {				/* Hi-bit says more than 8 report formats */		nr &= 0x7fff;				/* Strip high bit */		i = 1;	}/*if*/nf = peek(pntr+38); 				/* Number of report formats */if (nf > (8 + i*12)) doError(1);    /* Too many reports */nc = peek(pntr+35);					/* Number of categories */if (nc > maxCats) doError(2);    	/* Too many categories  */ncMRL = peek(pntr+222);				/* Number of MRL categories */if (ncMRL > nc) doError(12);    	/* Too many categories  *//* Although we 'tolerate' DoubleData, we can't 'handle' it! */dnc		= (nc	 > 30) ? 30 : nc;	/* Displayable categories */dncMRL	= (ncMRL > 30) ? 30 : ncMRL;/* *** For each category *** */#if DEBUG	puts("+++ Decoding category screen loc. information");#endiffor (n=0; n<dnc; n++)  {	tb[n][0] = peek(pntr+186+n);	/* Screen seq. left-top to bot-right */	tb[n][1] = peek(pntr+114+n);	/* Horizontal screen position        */	tb[n][2] = peek(pntr+150+n);	/* Vertical screen position          */} /*for*/for (n=0; n<dncMRL; n++)  {	cw[n][0] = peek(pntr+42+n);		/* MRL column width					 */	cw[n][1] = peek(pntr+78+n);		/* MRL column category				 */}/*for*/             pntr += 357;						/* Get category names		     	 */#if DEBUG	puts("+++ Decoding category name information");#endiffor (n=0; n<dnc; n++,pntr+=22)  {	strncpy((char *)&cn[n], bufPtr+pntr+1, peek(pntr));	cn[n][peek(pntr)] = '\0';		/* Ensure string terminator is present */	}/*for n*/if (optD)	pntr = hl;						/* Don't check for errors, or assume! */if (pntr != hl)	doError(3);     				/* Header length consistency check	 */pntr += nf*600;						/* Skip the 600 byte report formats  */firstRec = pntr;					/* Save the starting address		 *//* Find end of data record */for (r=0; r<nr; r++)  {	pntr += pk2(pntr)+2;		/* Skip a record */	if (peek(pntr-1) != 0xff)		doError(4);				/* Corrupt record */}/*for*/lastRec = pntr;					/* Last record start */pntr    = firstRec;				/* Restore pointer */one_8th = (lastRec-firstRec)>>3;/* Size of one eighth of the file for <OA-n> *//******* Just for fun, draw an AppleWorks-like screen for display *******/#if DEBUG	puts("+++ Drawing the screen - press a key to continue");	getKey(); home; gotoXY(10,1);	puts("Variables are :-");	printf("ver=%u, hdr len=%u, recs=%u, cats=%u, MRL cats = %u, rpts=%u\n", \			ver, hl, nr, nc, ncMRL, nf, pntr);	printf("pntr = $%0.4lX, firstRec = $%0.4lX, lastRec = $%0.4lX\n", \			pntr, firstRec, lastRec);	gotoXY(1,1);   				/* 'Home' the cursor */#else	home;             			/* Clear the screen   */#endifgotoXY(24,1);printf("Press arrow keys or use %s commands%27cPress %s-? for help", OA,' ',OA);putchar(0x19);					/* Home the cursor */printf("File: %s\n\nSelection: All records", fileName.text);gotoXY(1,32);printf("ADB.READER v" VER "%15cEsc: Exit program " \		"%20cCopyright 1993-1997 by Peter Watson", ' ', ' ');gotoXY(7,1);for (i=1; i<9; i++)  printf("=========");printf("=======");gotoXY(23,1);for (i=1; i<9; i++)  printf("---------");	printf("-------");	/******* Loop through file displaying what we can *******/#if DEBUG	gotoXY(20,1);	puts("+++ Displaying records - press a key to continue");	getKey();#endif/* If '-L' specified, display the SRL record layout */if (optL)  {	gotoXY(6,1);	puts("Record layout category names");	for (i=0; i<dnc; i++) {	/* Show number/name relationship */		if (i < 15)	gotoXY(i+8, 1);		/* Two columns for up to 30 cats */		else		gotoXY(i+8-15, 41);		printf("%2d : %s\n", i+1, cn[i]);	}/*for*/	ch = getKey();			/* Accept anything, but don't act on it! */	if ((ch == esc) || (ch == '.'))		goto cleanup;		/* Early exit */	gotoXY(6,1);	puts("Record layout category numbers");	if (MRLmode)  {		makeWindow(8, 22);	/* Create a partial height window	 */		clearWindow();		for (n=0; n<dncMRL; n++) 			printf("%d ", cw[n][1]);		putchar('\n');	} else {		clearWindow();		for (n=0; n<dnc; n++)  {			gotoXY(tb[n][2]+1, tb[n][1]);			printf("%s: %d", cn[tb[n][0]-1], tb[n][0]);		}/*for*/	}/*else*/	ch = getKey();			/* Accept anything, but don't act on it! */	if ((ch == esc) || (ch == '.'))		goto cleanup;		/* Early exit */}/*if optL*/if (MRLmode)  {	popWindow;				/* Clear possible window			*/	setMRLTitles();			/* Display the MRL title line first!*/	makeWindow(8, 22);		/* Create a partial height window	*/	clearWindow();			/* Clear it							*/}/*if*//* Now display the real stuff */for (r=0; r<=nr; r++)  {reBuild :					/* Entry point for redisplaying a new record */	getCategories();		/* Read category data into our array */							/* rl has been set correctly here */reShow :					/* Entry point for redisplaying current record */							/* reShow entry point does not set rl correctly! */	if (!MRLmode)  {		gotoXY(6,1);		if (r == 0)			printf("Standard Values for this file:%28c" \					"%s%u reports defined)%c", ' ', (nf>9?"(":" ("), nf, clEOL);		else  {			printf("Record %u of %u  (%u selected)%c", r, nr, nr, clEOL);			gotoXY(6,50);					printf("File offset : %lu ($%0.6lX)", pntr, pntr);		}/*else*/		/* Tab to proper location and print categories */		for (n=0; n<dnc; n++)  {			gotoXY(tb[n][2]+1, tb[n][1]);			printf("%s: %s%c", cn[tb[n][0]-1], c[tb[n][0]-1], clEOL);		}/*for*/	}/*if*/	else  {						    /* MRL mode contains fixed category names */		if (oneLine)  {			showMRLLine(oneLine);	/* Show a line in the MRL 'window' */			oneLine = 0;			/* Reset the flag */		}/*if*/		else  {			clearWindow();			/* Cleanup window */			if (!r)				showMRLLine(1);		/* Show the layout line only */			else  {				oldPntr = pntr - rl - 2;/* Save current record pointer */				for (i=1; i<=15; i++)  {					showMRLLine(i);	/* Show a line in the MRL 'window' */					if (r+i > nr)						break;		/* Skip non-existent lines */					if (i<15)  {						putchar('\n');						getCategories();/* Get the next line */					}/*if*/				}/*for*/				pntr = oldPntr;		/* Restore the pointer (to the top line) */				getCategories();	/* Get the data again for reShow */			}/*else*/		}/*else*/	}/*else*/noShow:								/* No reshow required - scroll was enough *//************************************************************//* Display done.  Get a keystroke or command from the user. *//************************************************************//* Nb:  Difficult to use 'rl' as the record length safely here - too many *//*		ways for it	to become invalid!									  */	if ((ch = getKey()) & 0x80)		/* Handle <Open-Apple> commands */		switch (ch&0x7f)  {			case upArrow :				if (!MRLmode)					goto doUpArrow;	/* Ignore 'command' key for SRL mode */				if (r < 2)  {		/* Trivial request? */					pntr = firstRec;					r = 0;				}/*if*/				else				if (r < 16)  {		/* Not enough room to move */					r 	 = 1;		/* Set record count */					pntr = firstRec;/* Set buffer pointer */					pntr += pk2(pntr) + 2; /* Skip standard values */				}/*if*/				else  {				/* Move up a page */					pntr -= (rl+3);	/* Point to 0xff of r-1 record */					i = r-15;					for (r=r; r!=i; r--)  {						while (peek(--pntr) != 0xff); /* Find 0xff of prev rec*/						if (peek(pntr-1) == 0xff)							pntr--;	/* LSB of length can be 0xff too! */					}/*for*/					pntr++;			/* Point to 1st byte of (r-15)th record */				} /*else*/				goto reBuild;			case downArrow :				if ((r == 0) || (!MRLmode))					goto doDownArrow;	/* Ignore 'command' key for SRL mode */				if ((r+15) > nr)  {	/* Not enough room to move */					pntr = lastRec;		/* Set buffer pointer	*/					r 	 = nr;			/* Set record count 	*/				}/*if*/				else  {					/* Move down a page */					i = r+15;					for (r=r+1; r<i; r++)							pntr += pk2(pntr) + 2;				} /*else*/				goto reBuild;			/* Quantum leaps through file */			case '1' :				r 	 = 1;			/* Set record count 	*/				pntr = firstRec;	/* Set buffer pointer	*/				pntr += pk2(pntr) + 2; /* Skip standard values */				goto reBuild;			case '2' : case '3' : case '4' : case '5' :			case '6' : case '7' : case '8' :				x = (ch & 0x7f) - '1';	/* # of eighths to skip */				x *= one_8th;			/* Offset we need (approximately) */				x += firstRec;			/* Pointer value we need */				pntr = firstRec;				pntr += pk2(pntr) + 2;				for (r=1; pntr<x; r++)	/* Calculates 'r' for us */					pntr += pk2(pntr) + 2;				goto reBuild;			case '9' :				pntr = lastRec;		/* Set buffer pointer	*/				r 	 = nr;			/* Set record count 	*/				goto reBuild;			case '?' : case '/' :				showHelp();         /* Display a help message   */				goto reShow;			/* FIND command */			case 'f' : case 'F' :			case 'g' : case 'G' :				oldPntr = pntr-rl-2;/* Save 1st byte of current record */				oldRec	= r;		/* Save current record number */				i = doFind(ch&0x7f);/* Go look for the string */  				if (!i)  {			/* Not found */					pntr = oldPntr;	/* Restore the old pointer */					r	 = oldRec;	/* Restore record number */					goto reBuild;	/* Display the record */				}/*if*//*******		else r = i;			/* Set new record number */				goto reShow; 		/* Display the record */			/* GOTO command */			case 'j' : case 'J' :				oldPntr = pntr-rl-2;/* Save 1st byte of current record */				oldRec	= r;		/* Save current record number */				i = doJump();		/* Go jump to the record */				if (!i)  {			/* Not found */					pntr = oldPntr;	/* Restore the old pointer */					r	 = oldRec;	/* Restore record number */				}/*if*//*******		else r = i;			/* Set new record number */				goto reBuild;		/* Display the record */		/* ZOOM command */			case 'z' : case 'Z' :				MRLmode = !MRLmode;	/* Toggle the flag */				if (!MRLmode)		/* Currently in MRL mode */					popWindow;		/* Restore full height window */				else {					setMRLTitles();	/* Display the MRL title line first! */					makeWindow(8,22);/* Create partial height window */				} /*else*/				clearWindow();		/* Clear the window */				goto reShow; 		/* Display the record(s) */			case '.' : case 'q' : case 'Q' :				goto cleanup;		/* Early exit */		    default  : goto reShow;	/* Ignore anything else */		}/*switch*/	else /*not OA key*/		switch (ch)  {			case leftArrow :			case upArrow :doUpArrow:		if (r < 2) {		/* Display first record */					pntr = firstRec;					r = 0;				}/*if*/				else  {				/* Display previous record */					pntr -= (rl+3);	/* Point to 0xff of r-1 record */					while (peek(--pntr) != 0xff); /* Find 0xff of r-2 record */					if (peek(pntr-1) == 0xff)						pntr--;		/* LSB of length was 0xff too! */					pntr++;			/* Point to 1st byte of r-1 record */					r--;			/* Decrement record count	*/				}/*else*/				if (MRLmode && r)  {					oneLine = 1;					gotoXY(oneLine,1);	/* First window row */					putchar(scrollDown);				}/*if*/				goto reBuild;			case rightArrow :			case downArrow	:			case ' '	 :			case '\r'	 :doDownArrow:  	break;				/* Display the next record */			case esc	 :				goto cleanup;		/* Alternate early exit */			default		 : goto noShow;	/* Simply keep displaying this record */		}/*switch*//* At this point, we will simply display the next record - or will we? */	if (r == nr)  {		clearWindow(); /* Clear the display area and put the cursor on line 8 */		if (MRLmode)			popWindow;		gotoXY(12,18);		puts("You are about to move past the last record!");		gotoXY(14,18);		puts("You will not be able to display any more records.");		gotoXY(16,18);		puts("(However there may be 'tag' data to be displayed)");		gotoXY(18,18);		puts("Are you sure want to do this? (Y/N)");		do  {			ch = getKey() & 0x7f;			if (ch == esc)  ch = 'N';			else			ch &= 0x5f;	/* Make upper case */			if (ch == 'N')  {				if (MRLmode)					makeWindow(8, 22);	/* Reset our window */				clearWindow();				goto reShow;			} /*if*/		}/*do*/		while (ch != 'Y');		/* Don't clear the screen - it will be done soon anyway */	}/*if*/	else	if (MRLmode && r)  {		if (r+15 > nr)	i = nr - r + 1;		else			i = 15;		gotoXY(i,1);			/* Last window row */		putchar(scrollUp);		if (r+15 > nr)  {			getCategories();	/* Get the data for reShow */		}/*if*/		else  {			oldPntr = pntr;		/* Save 'next' record pointer */			for (i=1; i<15; i++)				pntr += pk2(pntr) + 2;				getCategories();	/* Get the data again for reShow */		showMRLLine(15);			pntr = oldPntr;		/* Restore the pointer (to the NEW top line) */			getCategories();	/* Get the data again for reShow */		} /*else*/		r++;		goto noShow;			/* Scrolling was enough! */	}/*if*//**********************************************************/}/*for r <= nr*/if (pk2(pntr) != 0xffff)	doError(7);						/* EOF error */home;if (peek(pntr+2))  {				/* TRUE = File contains Tag Data */	pntr += 2;	gotoXY(6,1);	printf("\n\n%c This file contains Tag Data! %c\n\n", 0x0f, 0x0e);/*Inverse*/	printf("Press 'y' to display the data (in hex) >");	printf("%c %c%c", 0x0f,0x0e,'\b');	/* Make a pretty prompt */	ch = getKey() & 0x7f;				/* Ignore high bit */	putchar(ch);	if (ch == 'Y' || ch == 'y' || ch == ' ')		showTags();}/*if*//******* Clean up and go home *******/cleanup:#if DEBUG	puts("\n+++ Program exit");#endifpopWindow;							/* Just in case! */gotoXY(24,1);						/* PopWindow does a 'home cursor' */putchar('\n');						/* Ensure Shell prompt stays clear */if (standAlone)  {	if (!finalExit)		goto MainLoop;				/* Look at another file */	printf("%c Press any key to exit %c", 15, 14);	/* Inverse prompt */	getKey();						/* Let user see error messages */}/*if*/if (findString)		free(findString);/*Free malloc'ed buffer */if (bufPtr)			free(bufPtr);	/* Free malloc'ed buffer */if (inFile != NULL) fclose(inFile);exit(exitCode);}/*main*//*******************************************************/void getCategories(void)/*	Read record's categories into c[0]...c[n-1]*/{	word	t, 						/* Type byte     */			cbyte,					/* Control byte  */			hr,						/* Hour value	 */			nb; 					/* # of blank categories */	char	*cp;					/* Pointer to c[n] */rl = pk2(pntr);						/* Get record length */pntr += 2;if (peek(pntr+rl-1) != 0xff)	doError(4);    					/* Invalid record length (or file) */nb = 0;/*** For each category ***/for (n=0; n<nc; n++)  {	cp = c[n];						/* Speed up array indexing */	if (nb)  {						/* Handle a blank category */		*cp 	= '-';				/* Make blank categories into a 'dash' */		*(++cp) = '\0';		nb--;		continue;					/* for loop */	}/*if*/	cbyte = peek(pntr++);			/* Get the 'control byte' */	if (cbyte == 0xff)  {		pntr--;		*cp 	= '-';				/* Make remaining categories 'blank' */		*(++cp) = '\0';		continue;					/* for loop */	}/*if*/	if (cbyte & 0x80)  {		nb = cbyte & 0x7f;			/* nb = # of blank categories */		*cp 	= '-';				/* Make remaining categories 'blank' */		*(++cp) = '\0';		nb--;		continue;					/* for loop */	}/*cbyte>0x7f*/	if ((t=peek(pntr)) & 0x80)  {		/* Date or Time category? */		switch (t)  {			case 0xc0 :					/* Date */				if (peek(pntr+4) == ' ' && peek(pntr+5) == '0')					peek(pntr+5) = ' '; /* For dates with no day value!		 */				switch(dateMode)  {		/* Use Control Panel format for Date  */					default:			/* If an unknown date format found    */					case 0 :			/* Display date in 'mmm dd yy' format */						sprintf(cp, "%s %c%c %c%c", month[peek(pntr+3)-65],							peek(pntr+4),peek(pntr+5),peek(pntr+1),peek(pntr+2));						break;					case 1 :			/* Display date in 'dd mmm yy' format */						sprintf(cp, "%c%c %s %c%c", peek(pntr+4), peek(pntr+5),							month[peek(pntr+3)-65], peek(pntr+1), peek(pntr+2));						break;					case 2 :			/* Display date in 'yy mmm dd' format */						sprintf(cp, "%c%c %s %c%c", peek(pntr+1), peek(pntr+2),							month[peek(pntr+3)-65], peek(pntr+4), peek(pntr+5));						break;				}/*switch(dateMode)*/				break;			case 0xd4 :					/* Time */				hr = peek(pntr+1)-65;				switch(timeMode)  {		/* Use Control Panel format for Time  */					default:			/* If an unknown date format found    */					case 0 :			/* am/pm format */						sprintf(cp, "%0.2u:%c%c %cm", (hr>11 ? hr-12 : hr), 							peek(pntr+2), peek(pntr+3), (hr>11 ? 'p' : 'a'));						break;					case 1 :			/* 24 hour format */						sprintf(cp, "%0.2u:%c%c", hr,							peek(pntr+2), peek(pntr+3));						break;				}/*switch(timeMode)*/				break;          			default	:	doError(6);		/* Oops */						break;		}/*switch*/	}/*if t > 0x80*/	else  {		strncpy(cp, bufPtr+pntr, cbyte);/* Copy ASCII data */		*(cp+cbyte) = '\0';				/* Ensure string terminator is present */	}/*else*/	pntr += cbyte;}/*for*/if (peek(pntr) != 0xff)	doError(5);    					/* Invalid length (or file) */pntr++;								/* Skip 0xff */}/*getCategories*//*******************************************************/void showTags(void)/*	showTags - Display 'Tag Data' at the end of the file - in 'hex dump' mode.	Tag data format (From 'Filetype Tech Notes' - but they claim 1 byte id's!)	+0	: Id (?) byte - should be 0xff	+1	: Id byte (If 'id' IS 2 bytes, appears to be 'aabb', NOT 'bbaa' format)	+2	: Id byte (This is not in the tech note, but it is in files!)	+3	: Length word (max. 64k)	+5	: Tag data	For the final tag,	+3	: Tag count byte (max. 64)	+4	: 0xff*/{   word	id;						/* Tag 'id'		 */	word	tl,   					/* Tag length    */			toff,					/* Offset in Tag */			count = 0;				/* Count of Tags */	word	i, j, k;				/* Work variables*/	char	ch;						/* Work variables*/#define TAGID	0#define TAGID2  1#define TAGLEN  2#define TAGCNT  2#define TAGEND  3#define TAGDATA 4#define TAGHDRSIZE (TAGDATA)home;puts("\nTag Data\n--------\n");while (peek(pntr+TAGEND) != 0xff)  {	/* while there are more tags */	count++;	id = peek(pntr+TAGID)*256+peek(pntr+TAGID2);/* Id (not in 'reverse'!) */	tl = pk2(pntr+TAGLEN);				/* Tag length */	pntr += TAGHDRSIZE;	printf("Tag %d:  Id $%0.4X,  Length $%0.4X\n\n", count, id, tl);/* Print data in hex, 16 bytes per line, with ASCII format on the right. */	toff = 0;	while (tl - toff >= 16)  {		/* Full width print */		printf("%0.4X  |  ",toff);		j = pntr + toff;		for (i=0; i<16; i+=4)  {			k = j + i;			printf("%0.2X%0.2X%0.2X%0.2X ",					peek(k), peek(k+1), peek(k+2), peek(k+3));		}/*for*/		printf(" |  ");		for (i=0; i<16; i++)  {			ch = peek(j+i) & 0x7f;			putchar(ch > ' ' ? ch : ' ');	/* Make <ctrl>-chars printable */		}/*for*/		puts("  |");		toff += 16;		if (STOP_PAUSE())		    return;					/* User pressed <oa-'.'> to exit early */	}/*while*/	if (tl - toff)  {				/* Print any remaining characters */		printf("%0.4X  | ",toff);		j = pntr + toff;		for (i=0; i<16; i++)  {			if (!(i & 0x03))	putchar(' ');	/* ie. i mod 4 */			if (tl > toff + i)	printf("%0.2X", peek(j+i));			else				printf("  ");		}/*for*/         		printf("  |  ");			/* Extra leading blank is required! */		for (i=0; i<16; i++)  {		/* ASCII data part */			ch = peek(j+i) & 0x7f;			if ((ch < ' ') || (toff + i >= tl))				ch = ' ';			putchar(ch);		}/*for*/		puts("  |");	}/*if*/	putchar('\n');	pntr += tl; 					/* Skip over Tag */}/*while*//* Handle the final tag */if (peek(pntr+TAGCNT) != count)	doError(8);						/* Tag count does not match */id = peek(pntr+TAGID)<<8 + peek(pntr+TAGID2);	/* Id (not in 'reverse'!) */printf("Final Id = $%0.4X\n\nTags found = %d", id, count);}/*showTags*//*******************************************************/int doFind(char findType)/*	Find a string in any category in the remaining records.	- 'type' is f/F for initial Find, or g/G for repeat find*/{	word rr;					/* Temporary record counter */	word i, l;if (MRLmode)	popWindow;					   /* In case we are in MRL mode */if (findType == 'f' || findType == 'F')  { /* Initial find */	gotoXY(4,1);	printf("%c String to find? ('=' to refind) >%c ", 0x0f, 0x0e); /* Inverse */	gets(findString);			/* Get the string */	gotoXY(4,1);	putchar(clEOL);				/* Clear the prompt */} else {						/* Repeat find */	*findString = '=';			/* Pretend user entered refind character */}/*else*/if (*findString == '\0')  {		/* I guess he changed his mind */	if (MRLmode)		makeWindow(8, 22);		/* Recreate the window */	return(0);}/*if*/if (*findString == '=')			/* Reuse old string? */	strcpy(findString, oldString);/* Get old string */else	strcpy(oldString, findString);/* Save old string *//* Let the search begin! */gotoXY(4,1);printf("%c Searching... %c ", 0x0f, 0x0e);	/* Inverse */for (r=r+1; r<=nr; r++)  {	getCategories();	for (i=0; i<nc; i++)  {		if (nc <= dnc)			/* Ignore categories we can't display */		if (strstr(c[i], findString))  {			if (!MRLmode)  {				/* Highlight the category (if possible) */				if ((l = (word)strlen(c[i])) < CATSIZE-2)  {					c[i][l+2] = '\0';					c[i][l+1] = 0x0e;					do {						c[i][l] = c[i][l-1];					} while (l--);					c[i][0] = 0x0f;					}/*if*/			}/*if*/			gotoXY(4,1);			putchar(clEOL);		/* Clear the "searching" message */			if (MRLmode)				makeWindow(8, 22);	/* Recreate the window *//********	pntr -= (rl+2);		/* Point to start of correct record *//* Don't need since we only display, not rebuild the data */			return r;			/* String found */		}/*if*/	}/*for*/}/*for*/gotoXY(4,1);putchar(clEOL);					/* Clear the "searching" message */putchar(7);						/* Ring that bell */if (MRLmode)	makeWindow(8, 22);			/* Recreate the window */return 0;						/* String not found */}/*doFind*//*******************************************************/int doJump(void)/*	Jump to a specified record number*/{	word rr, jumpRec;			/* Temporary record counter */	word i, l;	char jumpString[80] = "";	/* Buffer for input string used by JUMP */popWindow;					    /* In case we are in MRL mode */gotoXY(4,1);printf("%c Enter record number to jump to >%c ", 0x0f, 0x0e);	/* Inverse */gets(jumpString);				/* Get the string */gotoXY(4,1);putchar(clEOL);					/* Clear the prompt */if (MRLmode)	makeWindow(8,22);			/* Recreate the window */if (*jumpString == '\0')		/* I guess he changed his mind */	return 0;jumpRec = (word)strtoul(jumpString, NULL, 10);	/* Extract a decimal number */if (jumpRec < 1 || jumpRec > nr)  {	putchar(7);					/* Ring that bell */	return 0;     }/*if*//* Let the search begin! */pntr = firstRec + pk2(firstRec) + 2;	/* First record after standard values */for (r=1; r<=nr; r++)  {	if (r == jumpRec)		return r;	pntr += pk2(pntr) + 2;}/*for*/putchar(7);						/* Ring that bell */return 0;						/* Record not found */}/*doJump*//*******************************************************/void doError(int err)/*	We found an inconsistency in the file - report it and exit.*/{	printf("%c +++ ERROR - Press a key to continue +++ %c\n", 15,14);/*Inverse*/	getKey();	popWindow;							/* Just in case */	home;	gotoXY(10,1);	puts("An error has been found in the file structure\n");	if (err > MAXERR-1)		err = MAXERR;					/* Last message is the default */	printf("%s\n\n", errMsg[err]); 	printf("Category %u of %u   Record %u of %u\n", n, nc, r, nr);	printf("Header length %u ($%0.4X)   Records start at %u ($%0.4X)\n",			hl, hl, hl+nf*600, hl+nf*600);	printf("File pointer at %lu ($%0.6lX)\n", pntr, pntr);	if (standAlone)  {		printf("\nPress any key to exit");		getKey();						/* Let user see error messages */		putchar('\n');	}/*if*/	if (findString)		free(findString);/*Free malloc'ed buffer */	if (bufPtr)			free(bufPtr);	/* Free malloc'ed buffer */	if (inFile != NULL) fclose(inFile);	exit(err);}/*doError*//*******************************************************/char getKey(void)/*	getKey - Wait for and return a keystroke.			 Set hi-bit if Open-Apple also pressed.*/{char *KeyBd  	= (char *)0xe1c000;	/* Keystroke read location */char *KbdStrobe = (char *)0xe1c010;	/* Clear keyboard strobe location */char *KeyMod 	= (char *)0xe1c025;	/* Keyboard modifiers location */									/* 0x80 = Open-Apple pressed */char key;while (!((key = *KeyBd) & 0x80));	/* Wait for a keypress */key &= 0x7f;						/* Strip hardware high bit */key |= (*KeyMod & 0x80);			/* Add high bit if Open-Apple pressed */*KbdStrobe = '\0';                  /* Reset keyboard */return(key);						/* Tell us what we got */}/*getKey*//*******************************************************/int parseParm(int argc, char *argv[])  {/*	parseParm - Parse command line arguments, if any*/word	i,		fileNameNum = 0,			/* Parameter number of filename parameter */		ErrFlag = FALSE;			/* Parameter error flag    */optM = optL = optD = FALSE;			/* Initialise switch flags */if (argc > 1)						/* First parameter is program name */	for (i=1; i<argc; i++) {		if (*argv[i] == '-' || *argv[i] == '+')  {			switch (toupper(argv[i][1])) {        /* Make upper case */				case 'M':	optM = TRUE;		/* Multi Record Layout option */							MRLmode = TRUE;		/* Multi Record Layout mode */							break;				case 'L':	optL = TRUE;		/* Layout display option */							break;				case 'D':	optD = TRUE;		/* DoubleData option */							maxCats = 60;		/* Tolerate extra 30 cat's */							break;				case '?':	ErrFlag = TRUE;		/* Quick way to get USAGE */							break;				default :	printf("Invalid switch '%s'\n", argv[i]);							ErrFlag = TRUE;							break;			}/*switch*/		}/*if*/		else  {			if (fileNameNum)  {				puts("More than one filename specified");				ErrFlag = TRUE;			} /*if*/			else				fileNameNum = i;	/* Parm # of (likely) filename parameter */		}/*else*/	}/*for*/	if (fileNameNum)		strncpy(fileName.text, argv[fileNameNum], 254);	return(ErrFlag);}/*parseParm*//*******************************************************/void showHelp(void)  {/*	showHelp - Display a 'command key' help message during record displays*/clearWindow();	/* Clear the display area and home the cursor */printf( "     Valid commands%50c%4ldK used\n" \		"     ==============\n" \		"     %s or %s or %s or <space> : Display the next record\n"     \		"     %s or %s                 : Display the previous record\n"  \		"     %s-%s                    : Display the next page\n"        \		"     %s-%s                    : Display the previous page\n"    \		"     %s-1                    : Go to beginning of file\n"       \		"       through                    through\n" \		"     %s-9                    : Go to end of file\n"             \		"     %s-F                    : Find a string (case-sensitive) in any category\n" \		"     %s-G                    : Repeat a previous 'find' command\n" \		"     %s-J                    : Jump to a specific record number\n" \		"     %s-Z                    : Zoom between Single and Multi Record Layout\n" \		"     %s-?                    : Display this help message\n"     \		"     %s-Q  or <escape>       : Exit the program",		' ', (fileSize+511)>>10,		DA,RA,CR, UA,LA, OA,DA, OA,UA,   OA, OA, OA, OA, OA, OA, OA, OA);getKey();clearWindow();	/* Clear the display area again */}/*showHelp*//*******************************************************/void clearWindow(void)/*	clearWindow - Clear all data within the data 'window' (lines 8 to 22)*/{if (MRLmode)  {	home;	return;}/*if*/gotoXY(8,1);printf( "\x1d\n\x1d\n\x1d\n\x1d\n\x1d\n\x1d\n\x1d\n\x1d\n\x1d\n\x1d\n\x1d\n" \		"\x1d\n\x1d\n\x1d\n\x1d");	/* Clear to end of line for lines 8 - 22 */gotoXY(8,1);}/*clearWindow*//*******************************************************/void setMRLTitles(void)/*	setMRLTitles - Display the MRL mode title line*/{	word	pos = 0,			/* Current horizontal position */			cat,				/* Category */			wid,				/* Width of a column */			len,				/* Length of name */			col,				/* Column number */			j;					/* Character within the field */gotoXY(6,1);					/* Line 6 normally */putchar(clEOL);for (col=0; col<dncMRL; col++)  {	wid = cw[col][0] - 1;		/* Width of this column (last char always ' ')*/	cat = cw[col][1] - 1;		/* Category in this column (-1 as array index)*/	len = strlen(cn[cat]);		/* Length of category name */	for (j=0; j<wid; j++)  {		putchar(j<len ? cn[cat][j] : ' ');		if (++pos == 79)		/* Too much to show for us */		break;					/* Exit the loop */	}/*for j*/	if (pos < 79)  {		putchar(' ');		pos++;	}/*if*/	if (pos > 78)		break;					/* As much as we can show */}/*for col*/}/*setMRLTitles*//*******************************************************/void showMRLLine(int row)/*	showMRLLine - Display an MRL mode data line*/{	word	pos = 0,			/* Current horizontal position */			wid,				/* Width of a column */			len,				/* Length of category */			col,				/* Column number */			j;					/* Character within the field */	char	*cp,				/* Input pointer */			myLine[80];			/* Output line buffer */for (col=0; col<dncMRL, pos<79; col++)  {	wid = cw[col][0] - 1;		/* Width of this column (last char always ' ')*/	cp  = c[cw[col][1] - 1];	/* Category data in this col (-1 array index) */	len = strlen(cp);			/* Length of category */	for (j=0; j<wid; j++)  {		myLine[pos++] = (j<len ? *(cp+j) : ' ');	/* Show the category data */		if (pos == 79)			/* Too much to show for us */	    	break;				/* Exit the loop */	}/*for j*/    	myLine[pos++] = ' ';		/* Column separator */}/*for col*/if (pos == 80)	pos--;			/* May have been one 'separator' too many! */myLine[pos] = '\0';printf("%s", myLine);			/* No new line char */}/*showMRLLine*/