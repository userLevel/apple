#define WhoAmI "STRIPLF v1.01"#define _DEBUG_ 0/*******************************************************    STRIPLF - Program to strip all <LF> characters from a file.                V1.0  - Copyright by Peter Watson. Jan 1990.             V1.01 - Fix length of i,j in Convert routine. Jan 1991                            Compiled under ORCA/C V1.0b   ********************************************************/#include <stdio.h>#include <stdlib.h>#include <errno.h>#include <string.h>#include <prodos.h>#include <shell.h>#include <orca.h>#define BUFSIZE 4096           /* Size of I/O buffer              */extern int STOP_PAUSE(void);   /* Function from PAW.LIB           */                               /* Allows '<OpenApple>-.' to exit  */long convert(char s[],long i); /* Strip <LF> characters subroutine*/char *Licence[] = "This program contains material from the ORCA/C ",                  "Run-Time Libraries, copyright 1987-1989 ",                  "by Byte Works, Inc. Used with permission.";char buffer[BUFSIZE];          /* File i/o buffer                 */char fileName[FILENAME_MAX];   /* Filename buffer                 */struct {char *namePtr;         /* Pointer to the pathname         */        int   flags;           /* Flags: '?' valid; use all files */        } WildParm = {NULL,0}; /* INIT_WILDCARD parm list         */FileRec Info_Parm = {NULL};    /* GetFileInfo parm list           */OpenRec IO_Parm = {0,NULL,0L}; /* ProDOS Open and Close parm list */EOFRec  SET_EOF_Parm = {0,0L}; /* SetEOF parm list                */long block,                    /* Block number we are reading     */     bytes;                    /* Number of output bytes written  */int  numread, numwrite;        /* Number of bytes read / to write */boolean Found_One,             /* Did we find 'any' files?        */        standAlone;            /* Are we running under APW shell? */main(argc,argv)  int   argc;  char *argv[];{   FILE *fptr;                 /* File we are processing */   char ch;   int  err;                   /* Work variables         */   setbuf(stdout,NULL);        /* Defeat buffering for screen messages */   printf("\n%s - Copyright 1990 by Peter Watson and Byte Works, Inc.\n\n",\          WhoAmI);   WildParm.namePtr = fileName;   standAlone = (argc == 0 || strncmp(shellid(),"BYTEWRKS",8)!=0);#if _DEBUG_   printf("Argc = %d, standAlone = %d\n",argc,standAlone);#endifGet_File_Name:   if (standAlone || argc < 2)  {       printf("Name of file to strip <LF> chars from >");       gets(fileName);       if (strlen(fileName) == 0)           exit(0);       }   else strncpy(fileName,argv[1],FILENAME_MAX-1);   strcpy(fileName,c2pstr(fileName));   if (!standAlone)  {                         /* If running under APW  */       INIT_WILDCARD(&WildParm);       if (toolerror())  {           err = toolerror();           printf("\n");           ERROR(&err);                        /* Print an error message */           exit(err);           }       NEXT_WILDCARD(&WildParm.namePtr);       }   Found_One = FALSE;/*******************************************************\ Main file processing loop\*******************************************************/   while (fileName[0] != '\0')  {       Found_One = TRUE;       Info_Parm.pathname = fileName;       GET_FILE_INFO(&Info_Parm);              /* Get file details */       if ((Info_Parm.storageType > 3) ||      /* Can't handle resources */          !(Info_Parm.fAccess & P_WRITE_ENABLE)) {               printf("Access not allowed to %p\n",fileName);               goto Next_File;       }       strcpy(fileName,p2cstr(fileName));       printf("Processing file %s ",fileName);       if ((fptr = fopen(fileName,"rb+")) == NULL)  {           perror("\nUnable to open file\n");    /* Print message */           exit(errno);       }       block = bytes = 0;       do  {           #if _DEBUG_           printf("Pos1=%ld, ",ftell(fptr));           #endif           if (fseek(fptr,block*BUFSIZE,SEEK_SET)) {                                                 /* Position file ptr   */               err = errno;               perror("\nSeek error! ");               fclose(fptr);               exit(err);           }           numread = fread(buffer,1,BUFSIZE,fptr); /* Read next block   */           printf(". ");                         /* Keep the user amused*/           numwrite = convert(buffer,numread);   /* Strip <LF> chars    */           fseek(fptr,bytes,SEEK_SET);           /* Reposition file ptr */                                                 /* and write new block */           #if _DEBUG_           printf("Pos2=%ld, ",ftell(fptr));           #endif           if (fwrite(buffer,1,numwrite,fptr) != numwrite)  {               err = errno;               perror("\nError writing! ");               fclose(fptr);               exit(err);           }           bytes += numwrite;           block++;                   /* Next block */       } while (numread == BUFSIZE);  /* Check that EOF not reached */       fclose(fptr);/* Must now physically 'shorten' the file by reducing the EOF value */       strcpy(fileName,c2pstr(fileName)); /* Need pString for ProDOS */       IO_Parm.openPathname = fileName;       OPEN(&IO_Parm);       if (toolerror()) {           err = toolerror();           printf("\n");           ERROR(&err);       /* Print an error message */       }       else {           SET_EOF_Parm.eofRefNum   = IO_Parm.openRefNum;           SET_EOF_Parm.eofPosition = bytes;           SET_EOF(&SET_EOF_Parm);     /* Reposition new EOF     */           if (toolerror()) {               err = toolerror();               printf("\n");               ERROR(&err);            /* Print an error message */           }       }       CLOSE(&IO_Parm);Next_File:       printf("\n");       if (standAlone ||               /* If not running under APW or */           STOP_PAUSE())               /* user pressed <OpenApple>-.  */           break;       NEXT_WILDCARD(&WildParm.namePtr);   } /* While there are more wildcard filenames */   if (!Found_One)       printf("No file found!\n");   if (standAlone || argc < 2)           /* If we are in prompting mode */       goto Get_File_Name;   printf("\n");} /* main *//*******************************************************\ Subroutine to convert file contents by stripping <LF>'s\*******************************************************/long convert(buffer,amount)   char buffer[];   long amount;/*   Convert - Delete all <LF> (0x0A) characters in the buffer*/{   long i,j;   char ch;   j = 0;                             /* Output pointer                  */   for (i=0;i<amount;i++)       if ((ch = buffer[i]) != 0x0A){ /* Not <LF> - copy the character   */           buffer[j] = ch;           j++;           }   return(j);                         /* New 'numread' value now required*/} /* Convert */