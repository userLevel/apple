         mcopy purge.mac         gen   on;................................................................;; Purge - Utility to list and purge all purgeable memory blocks,;         compacting any remaining allocated memory.;;         by Mike Westerfield;;         Copyright 1988 by Byte Works, Inc.;;         Requires STOP_PAUSE routine from PAW.LIB (or STOP.PAUSE.INC source);;         Adapted for APW assembler by Peter Watson, April 1989.;         Modified to work under the Finder, and titles, pathnames;         and total free space added.;         V1.1  - Added '-L' to display results without 'purge'ing. 19 Feb 90.;                 Doesn't purge Loader blocks (ie. purge level = 3).;                 Now displays program name if auxid nibble is non-zero.;         V1.2  - Added '-A' to display all handles. Added call to STOP_PAUSE.;                 Display default 'owner' if no name found. 30 Jan 91;         V1.21 - Fixed message text (Double quotes '' bad in STR). 24 Feb 91.;         V1.22 - Ooops!  V1.21 stopped memory actually being purged! 19 Oct 91;................................................................         longa on         longi onPURGE    start         gblc  &VER&VER     setc  '1.22'                   Program version number; Zero page equatesParmPtr    equ 0                        Pointer to parameter on entryWork       equ 0                        Reused later as a work areaHandle     equ 4                        Current handleNextHandle equ 8                        Next handle; Displacements to fields in memory recordLocation   equ 0                        Address of allocated memoryAttributes equ 4                        Attributes of the memoryUserId     equ 6                        Associated user idLength     equ 8                        Length of the blockLast       equ 12                       Previous handle pointerNext       equ 16                       Next     handle pointer;................................................................         phk         plb                            Make data bank same as program bank         sty   ParmPtr         stx   ParmPtr+2         stz   ParmLFlg                 No '-L' found         stz   ParmAFlg                 No '-A' found         stz   Counter                  Zero purged space counter         stz   Counter+2; Introduce ourselves         _Write_Console CursOff         Turn off the cursor         writeln         writeln HelloMsg         writeln; See if the user entered a parameter of '-L' or '-A'         lda   ParmPtr         ora   ParmPtr+2                Did we get a parm?         beq   ParmDone         shortm         ldy   #8                       Skip shell id (who cares?)         jsr   SkipBlks                 Skip leading blanks         bcs   ParmDone                 End of parm reachedSkipCmd  iny         lda   [ParmPtr],Y              Get a byte         beq   ParmDone         cmp   #' '                     Find blank after command name         bne   SkipCmd         iny         jsr   SkipBlks                 Skip any intermediate blanks         bcs   ParmDone                 End of parm reached         lda   [ParmPtr],Y              Get a byte         beq   ParmDone         cmp   #'-'         bne   ParmBad         iny         lda   [ParmPtr],Y              Get a byte         beq   ParmBad         and   #$5F                     Upper case with no high bit         cmp   #'L'                     Is it 'L(ist)'?         bne   ParmA         longm         inc   ParmLFlg                 We found a parm!         writeln ListMsg         bra   ParmsOK         longa offParmA    cmp   #'A'                     Is it 'A(ll)'?         bne   ParmBad         longm         inc   ParmAFlg                 We found a parm!         inc   ParmLFlg                 Set this flag too, for safety         writeln AllMsgParmsOK  writelnParmDone longm         brl   FindThem                 Go find intreesting handles;................................................................;; SkipBlks - Skip blanks in the command line.;            On entry, m=1, and Y = offset into command buffer.;            On exit,  c=1 if end of command was  Y points to non-blank.;         longa offSkipBlks anop         sec                            Default 'error' flagBlnkLoop lda   [ParmPtr],Y              Get a byte         beq   BlnkDone         cmp   #' '                     Find blank after command name         bne   BlnkFnd                  Not a blank!         iny         bra   BlnkLoopBlnkFnd  clc                            Reset 'error' flagBlnkDone rts;................................................................;; Handle invalid parameters (anything except '-L' or '-A')ParmBad  anop         longm         writestr #"Unknown parameter in command ["         add4  ParmPtr,#8,ParmPtr       Skip past Shell Identifier         pushlong ParmPtr               Command string address        _WriteCString         writeln  #']'         brl   GoHome;................................................................;; Start by finding the handle of our own code;FindThem anop         pea   0                        Result space         pea   0                        Result space         pushlong #&SYSNAME             Our Address        _FindHandle                     Where are we?         pulllong Handle                Save the handle; Work back to the first handle in the chainWorkBack anop         ldy   #Last                    while not at the         lda   [Handle],Y               first handle do         tax         iny         iny         ora   [Handle],Y               Zero yet?         beq   TitleMsg                 Yes, go print startup message         lda   [Handle],Y               Handle :=         sta   Handle+2                 Handle^.Last         stx   Handle         bra   WorkBack; Display a starting titleTitleMsg anop         writeln #'Handle  Addr   Size  Flgs Uid   Prev   Next  Path'         writeln #'------  ----   ----  ---- ----  ----   ----  ----'; Loop through the handle list looking for purgeable blocks of memoryWorkFwd  anop         lda   Handle                   while Handle <>         ora   Handle+2                 nil do begin         bne   *+5         brl   DoCompact                Done, go do memory compact         ldy   #Next                    Next handle pointer         lda   [Handle],Y               Get next handle         sta   NextHandle         iny         iny         lda   [Handle],Y         sta   NextHandle+2         lda   ParmAFlg                 'A'll specified?         bne   DoDisplay                Yes, do display always         ldy   #Attributes              if the handle is         lda   [Handle],Y               purgeable then         bmi   GoDoNext                 Ignore 'locked' blocks (High bit set)         and   #$0300                   Look at purge flags only         beq   GoDoNext                 0 = Not purgeable         cmp   #$0300                   3 = Loader only - leave it alone!         bne   DoDisplay                1 or 2 are legally purgeableGoDoNext brl   DoNext;................................................................;; Found a purgeable block - display the details and purge it;;................................................................DoDisplay anop* Handle         ldx   Handle+2         lda   Handle         jsr   PrintHex3                Print 3 bytes* Address         writech #' '         ldy   #2                       Print the location         lda   [Handle],Y               Address of block         tax         lda   [Handle]         jsr   PrintHex3                Print 3 bytes* Size         writech #' '         ldy   #Length+2                Print the size of the block         lda   [Handle],Y         sta   Size+2                   Store for addition later         tax         dey         dey         lda   [Handle],Y         sta   Size                     Store for addition later         jsr   PrintHex3                Print 3 bytes* Attributes         writech #' '         ldy   #Attributes              Print the         lda   [Handle],Y               attributes of the block         jsr   PrintHex2                Print 2 bytes* UserId         writech #' '         ldy   #UserId                  Print the user id of the block         lda   [Handle],Y         sta   Uid                      Store for later         jsr   PrintHex2                Print 2 bytes* Previous         writech #' '         ldy   #Last+2                  Print the         lda   [Handle],Y               previous pointer         tax         dey         dey         lda   [Handle],Y         jsr   PrintHex3                Print 3 bytes* Next         writech #' '         ldy   #Next+2                  Print the         lda   [Handle],Y               'next' pointer         tax         dey         dey         lda   [Handle],Y         jsr   PrintHex3                Print four bytes; Attempt to get the pathname from the Loader (if not found, zero AuxId & retry)         writech #' 'GetPath  anop         stz   AuxCheck                 Clear the loop detection flag         lda   Uid         beq   ChkIdType                Avoid funny result from loader callGetPath2 pea   0                        Result space         pea   0         pha                            Push UserId         pea   1                        Default to load file one        _LGetPathName                   Get name from the Loader         pla                            Get low  order bytes of address         ply                            Get high order bytes of address         bcs   NoPath                   Handle errors by ignoring name         sta   Work                     Check for...         sty   Work+2                            ...'null' pathname (how null?)         tax                            Save Acc         lda   [ParmPtr]                Get length         and   #$00FF                   One byte, please         beq   NoPath                   Length = 0?         txa                            Restore Acc         writestr                       Points via A, Y regs (A has low bytes)         brl   LineDone; Attempt to find owner by zeroing 'auxid' nibble and trying againNoPath   anop         lda   AuxCheck                 Been here before?         bne   ChkIdType                Yes, all done (or cleared already)         lda   Uid         and   #$F0FF                   Zero the Auxid         inc   AuxCheck                 Ensure we don't loop         bra   GetPath2                 Try again now; Display a generic type based on the first nibble of the useridChkIdType anop         lda   Uid         and   #$F000                   Zero the all but the 'owner' nibble         xba         cmp   #$40                     Handle toolbox owners differently         beq   ToolTypeLookTabl anop         lsr   A                        Acc = (4 * index into table)         lsr   A         tax                            Index into table (times 4)         lda   TypeTable+2,X            Get high order byte         tay         lda   TypeTable,X              Get low order byteWriteType anop         writestr         brl   LineDoneToolType anop         lda   Uid         and   #$FF00         xba         cmp   #$40                     Tool?         bne   ToolTyp1         lda   Uid         and   #$00FF                   Get tool number         pha                            Push word value onto the stack         pushlong #Msg40+5              Push result area address onto the stack         pea   3                        Push required length onto the stack         pea   0                        Sign flag        _Int2Dec                        Do the conversion         short         ldy   #'0'         lda   #' '         cmp   Msg40+5                  Leading blanks?         bne   Write40                  No         sty   Msg40+5                  Else replace with a zero         cmp   Msg40+6                  Another leading blank?         bne   Write40                  No         sty   Msg40+6                  Else replace with a zeroWrite40  anop         long         writestr Msg40         bra   LineDoneToolTyp1 anop         cmp   #$41                     Misc Tools?         bne   ToolTyp2         writestr Msg41         bra   LineDoneToolTyp2 anop         cmp   #$42                     Scrap Manager?         bne   ToolTypX         writestr Msg42         bra   LineDoneToolTypX anop         lda   Uid         and   #$F000         xba         brl   LookTabl                 Go use the generic messageLineDone anop         writeln                        Finish the line         jsl   STOP_PAUSE               Look for keypress or Apple-Period         tax                            Apple-Period or Option-Period pressed?         beq   *+5         brl   CompDone                 Yes, so exit; Purge the handle that we found (if allowed)         lda   ParmLFlg                 '-L' specified?         bne   PurgeDone         pushlong Handle                Dispose of memory,        _PurgeHandle                    but retain handle         bcs   PurgeErr                 Oops!PurgeDone anop; Add the purged memory to our counter         add4  Counter,Size,Counter   Add size to accululator; Look for the next handleDoNext   anop                           End; {if}         lda   NextHandle               Handle :=         sta   Handle                   NextHandle;         lda   NextHandle+2         sta   Handle+2         brl   WorkFwd                  Go look at next handle; 'Handle' an error by PurgeHandle!PurgeErr anop         pha                            Save error code         writestr #'Error $'         pla         jsr   PrintHex2                Display Acc (eg. 0206)         writeln #' purging handle'         brl   PurgeDone                Continue anyway;................................................................;; All done, compact the remaining allocated memory (if allowed);;................................................................DoCompact anop         lda   ParmLFlg                 '-L' or '-A' specified?         bne   CompDone        _CompactMem                     Compact the remaining memoryCompDone anop         writeln         lda   ParmAFlg                 '-A' specified?         beq   *+5         brl   GoHome                   Yes, so no final message; Tell the user what we did (or will do) for him         lda   Counter         ora   Counter+2                Did we free anything?         beq   NoneMsg                  No, tell the user         writestr #'Total space '         lda   ParmLFlg                 'List' mode?         beq   NoWarn                   No         writestr #'which would be 'NoWarn   anop         writestr #'released = $'         lda   Counter         ldx   Counter+2         jsr   PrintHex3                Write out the space value         writeln         bra   GoHomeNoneMsg  anop         writeln #'No space was purgeable'; Return to our callerGoHome   anop         _Write_Console CursOn          Turn on the cursor         lda   #0                       Return code 0        _Quit  QuitParm                 Shell will trap Quit call;................................................................HelloMsg str   '&SYSNAME v&VER Copyright 1988 Mike Westerfield; 1989-91 Peter Watson'Eyeball1 dc    c'Original copyright Mike Westerfield, April 1989, Call-APPLE'Eyeball2 dc    c'Modifications copyright Peter Watson, &SYSDATE &SYSTIME';              *** STR macro can't handle embedded quotes properlyListMsg  dc    i1'ListMsgE-ListMsg-1'         dc    c"'List' mode specified - memory will not be modified"ListMsgE anopAllMsg   dc    i1'AllMsgE-AllMsg-1'         dc    c"'All' handles mode specified - memory will not be modified"AllMsgE  anopParmLFlg ds    2                        = 1 if '-L' specifiedParmAFlg ds    2                        = 1 if '-A' specifiedSize     ds    4                        Purged handle size work variableCounter  ds    4                        Purged space size counterUid      ds    2                        UserId of a purged blockAuxCheck ds    2                        Loop detection flag for auxid zero stepCursOff  dc    i'6'                     Turn the cursor offCursOn   dc    i'5'                     Turn the cursor onQuitParm dc    i4'0'                    No next pathname         dc    i2'0'                    Return via Quit stackTypeTable dc   a4'Msg0,Msg1,Msg2,Msg3,Msg4,Msg5,Msg6,Msg7'          dc   a4'Msg8,Msg9,MsgA,MsgB,MsgC,MsgD,MsgE,MsgF'Msg0     str   '(memory manager)'Msg1     str   '(application)'Msg2     str   '(control program)'Msg3     str   '(gs/os)'Msg4     str   '(toolbox)'Msg5     str   '(desk accessory)'Msg6     str   '(runtime library)'Msg7     str   '(loader)'Msg8     str   '(firmware)'Msg9     str   '(tool locator)'MsgA     str   '(setup file)'MsgB     str   ' 'MsgC     str   ' 'MsgD     str   ' 'MsgE     str   ' 'MsgF     str   '(system)'Msg40    str   'TOOL0..'Msg41    str   '(misc tools)'Msg42    str   '(scrap manager)'         end                            Main 'Purge' routine;................................................................;; PrintHex2 - Print a word value as a hex string; =========;             Input : Acc = Word to print;;................................................................PrintHex2 start         pha                            Push word value onto the stack         pushlong #String2+1            Push result area address onto the stack         pea   4                        Push required length onto the stack        _Int2Hex                        Do the conversion         writestr String2               Write to the console         rtsString2  str '....'                     Converted string buffer         end                            PrintHex2 routine;................................................................;; PrintHex3 - Print a longword value as a three byte hex string; =========;             Input : X, Acc = Longword to print;                              (X is the most significant word);;................................................................PrintHex3 start         phx                            Push high word onto the stack         pha                            Push low  word onto the stack         pushlong #String3+1            Push result area address onto the stack         pea   6                        Push required length onto the stack        _Long2Hex                       Do the conversion         writestr String3               Write to the console         rtsString3  str '......'                   Converted string buffer         end                            PrintHex3 routine