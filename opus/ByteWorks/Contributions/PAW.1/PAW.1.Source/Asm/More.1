         mcopy more.mac         gen   on;................................................................;; MORE - Shell filter to prompt for a keypress after 22 lines of output.;        Control characters are printed in inverse.;        Uses standard input, with all output forced to the screen.;;        There are no parameters.;;        V1.0 Copyright by Peter Watson. Apr 1989;        V1.1 Correctly count lines > 80 columns (which have wrapped). Jan 90.;        V1.2 Don't double count lines with a <CR> in column 80.  Mar 90.;        V1.3 Handle ORCA 2 shell. Fix inconsistent line count.  Feb 92.;;................................................................         longa on         longi onMORE     start         gblc  &VER&VER     setc  '1.3'                    Program versionNewLine  equ   13                       New line character = <Return>MoreLine equ   22                       Prompt every 22 linesC_CursOn  equ  5                        Cursor on       control characterC_CursOff equ  6                        Cursor off      control characterC_Back    equ  8                        Backspace       control characterC_LineFeed equ 10                       Linefeed        control characterC_Return  equ  13                       Carriage return control characterC_Normal  equ  14                       Normal  mode    control characterC_Inverse equ  15                       Inverse mode    control characterC_ZapLine equ  26                       Clear line      control characterC_Text    equ  32                       First text character;................................................................         phk                            Push program bank         plb                            Data bank = program bank         lda   #C_CursOff               Kill the cursor         sta   ConParm                  Store in parm list        _WRITE_CONSOLE ConParm          Do it;................................................................;; Initialise screen & line counters;;................................................................StartLoop anop         lda   #MoreLine                Line to prompt on         sta   Counter         stz   Chars                    Count of characters on line;................................................................;; Now read input and echo to output;;................................................................MainLoop anop         pea   0                        Result space         pea   0                        No echo required        _ReadChar                       Call the toolbox         bcc   *+5         brl   ToolErr                  Handle a tool error         pla                            Get the character         and   #$7f                     Strip any high bit (0 = End-of-File)         bne   WriteIt                  No, go write the character         brl   Exit                     Else say goodbye; Make control characters inverse and printableWriteIt  anop	pha		Save the character         cmp   #C_Text                  Control character?         bge   MainWrite                No, go write it out         cmp   #NewLine                 New line?         beq   MainWrite                Yes, go write it out normally         lda   #C_Inverse               Inverse mode         sta   ConParm                  Store into parameter buffer        _WRITE_CONSOLE ConParm          Write to screen         lda   1,s                      Retrieve the character again         clc         adc   #'A'-1                   Make printable; Echo the character to the screen (ignore output redirection)MainWrite anop         sta   ConParm                  Store into parameter buffer        _WRITE_CONSOLE ConParm          Echo to screen; Remove inverse mode         lda   1,s                      Retrieve the character         cmp   #C_Text                  Control character?         bge   DoCount                  No, go do next character         cmp   #NewLine                 New line?         beq   DoCount                  Yes, was not inversed         lda   #C_Normal                Normal mode         sta   ConParm                  Store into parameter buffer        _WRITE_CONSOLE ConParm          Echo to screen; Count the characters on each line so we can detect (and count) line wrappingDoCount	anop         inc   Chars                    Increment # of chars on this line         lda   Chars                    Gone to a new line?         cmp   #80                      80 character lines         blt   Counted                  No, counting all done         pla                            Restore saved character	bra	LineFeed	Process like a linefeedCounted  anop; Add a linefeed character to carriage returns         pla                            Restore saved character         cmp   #NewLine                 New line?         beq   LineFeed                 Yes, do linefeed         brl   MainLoop                 Go get another characterLineFeed anop         lda   #C_LineFeed              Line feed needed as well!         sta   ConParm                  Store into parameter buffer        _WRITE_CONSOLE ConParm          Echo to screen         stz   Chars                    Start character count at 0 again;................................................................;; Check counter for each new line;;................................................................         dec   Counter         beq   DoMsg                    Zero - time to do our stuff         bmi   DoMsg                    Maybe decremented by line wrapping         brl   MainLoop                 Otherwise continue on;................................................................;; It's time!;;................................................................DoMsg    anop         ldx   #0                       Index to messageMoreLoop anop         lda   MoreMsg,X                Get next character         beq   MsgDone                  Message finished         phx                            Save X across tool call         sta   ConParm                  Save character in parameter block        _WRITE_CONSOLE ConParm          Always write to the screen!         plx                            Restore previously saved X register         inx                            Point to next character         bra   MoreLoop                 Go get itMsgDone  anop;................................................................;; Wait for a keypress - check for Open-Apple-Period request to abandon ship;;................................................................         lda   #0                       Ensure high bits are zero         shortm         phb                            Save data bank         pha                            Set data bank to 0...         plb                            ...so we can read keystrobe and data         bit   $C010                    Reset strobeKeyLoop  bit   $C000                    Test strobe...         bpl   KeyLoop                  ...until next keypress         bit   $C025                    Look for Open-Apple modifier         bpl   KeyDone                  No, continue         lda   #'.'+$80                 Test for period (high bit still set)         cmp   $C000         beq   StopSet                  Yes, so handle STOP request         lda   #0                       Restore default result         bra   KeyDone                  and finish upStopSet  lda   #1                       Set return value for STOPKeyDone  bit   $C010                    Reset strobe always         plb                            Restore data bank         longm         pha                            Save result;................................................................;; Remove prompt line from the screen;;................................................................         lda   #C_ZapLine               Clear line, but stay there         sta   ConParm                  Save character in parameter block        _WRITE_CONSOLE ConParm          Always write to the screen!         pla                            Retrieve stop request flag         cmp   #1                       Stop requested?         beq   Exit                     Yes, let's go home         brl   StartLoop                No, reset counter and start over;................................................................;; Return to our caller;;................................................................Exit     anop         lda   #C_CursOn                Restore the cursor         sta   ConParm                  Store in parm list        _WRITE_CONSOLE ConParm          Do it         lda   #0                       Return code of zero always        _Quit  QuitParm;................................................................;; Handle an error from readch;;................................................................ToolErr  anop         sta   ConParm                  Save error code         pla                            Clean error character from stack         ldx   #0                       Index to messageErrLoop  anop         lda   ErrMsg,X                 Get next character         beq   ErrExit                  Message finished         phx                            Save X across tool call         sta   ConParm                  Save character in parameter block        _WRITE_CONSOLE ConParm          Always write to the screen         plx                            Restore previously saved X register         inx                            Point to next character         bra   ErrLoop                  Go get itErrExit  anop        _ERROR ConParm                  Writes write to the screen!         bra   Exit                     Return to caller;................................................................;; Data areas;;................................................................Eyeball  dc    c'&SYSNAME - v&VER Copyright Peter Watson, &SYSDATE &SYSTIME'MoreMsg  dc    i1'C_Inverse',c'[More]',i1'C_Normal'         dc	i1'C_Back,C_Back,C_Back,C_Back,C_Back,C_Back' Backspace past msg         dc    i'0'                     End of string WORDErrMsg   dc    i1'C_Return',c'ReadChar error - '         dc    i'0'                     End of string WORDCounter  ds    2                        Line counterChars    ds    2                        Character counterConParm  ds    2                        Write_Console parameter bufferQuitParm dp    0                        Pathname         dc    i2'0'                    Flags (Return via Quit stack)         end