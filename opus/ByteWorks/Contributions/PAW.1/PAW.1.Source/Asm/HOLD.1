         mcopy hold.mac         gen   on;................................................................;; HOLD  - CDA to display a moving text 'icon' to prevent screen burnout.;;         Exit the CDA by pressing a key, or by moving / clicking the mouse.;         About the only activities we don't catch are Reset or disk activity.;;         Copyright by Peter Watson, May 1989.;; Modifications;         V1.1 Use Event Manager for keystrokes if it is active.  3 Sep 1989;         V1.2 Ensure outstanding mouse data is cleared. (Mouse seems;              to default to 'active', and seems to 'remember' movement;              on entry, often causing instant exit!)            24 Apr 1990;         V1.3 Add a bit of colour.                              12 Oct 1990;         V1.4 Support ORCA/M 2.0 shell (esp. CONSOLE driver)     2 Sep 1992;;................................................................         longa on         longi onHOLD     start         gblb  &CDA         gblc  &VER         gblc  &NAME         gbla  &Delay         gbla  &M_Icon&CDA     setb  1                        1 = Assemble as a CDA&NAME    setc  'Screen Protector'&VER     setc  '1.4'                    Program version number&Delay   seta  16                       Arbitary value to slow down the display&M_Icon  seta  '@'                      MouseText 'icon' = Solid AppleTBCOLOR  gequ  $E0C022                  Text & Background coloursCLOCKCTL gequ  $E0C034                  Clock control & Border colour         aif   &CDA,.IsCDA         jmp   H_Start                  Skip header code for testing.IsCDA;................................................................;; CDA Header;         str   '&NAME'                  CDA title         dp    H_Start                  Startup entry point         dp    H_End                    Shutdown entry point;................................................................;; Main program;H_Start  anop         phb                            Save data bank         phk         plb                            Data bank = Program bank         stz   MouseFlg                 Default to mouse not started; Initialise the text environment (avoid console driver wierdness)         ph4	#0	Result space        ~GetOutGlobals        ~SetOutGlobals #127,#0         ph4	#0	Result space         ph2	#0        ~GetOutputDevice        ~SetOutputDevice #1,#3	Pascal in slot 3        ~InitTextDev #1	Initialise 'output' device; Save the current screen colours, and set a black background and white text         shortm         lda   TBCOLOR         sta   Save1         lda   CLOCKCTL         and   #$0F                     Only want border colour data         sta   Save2         lda   #$F0                     White on black         sta   TBCOLOR         lda   CLOCKCTL         and   #$F0                     Make border colour into black         sta   CLOCKCTL         longm; Tell the user who we are         writestr Setup                 Just for screen clear here         writeln  HelloMsg;................................................................;; Check for Event Manager active (eg. in Finder).  If active, use it!;         pea   0                        Result space        ~EMStatus         pla                            Get result         sta   EventFlg                 Store Event Manager status         beq   InitMouse                Event Manager not active         jsr   FlushEvents              Flush the Event Manager queue;................................................................;; Start the mouse, if necessary.  Mouse data can be be buffered, so read it all.;InitMouse anop         lda   #5                       'Clear' mouse & allow user to see msg         sta   CounterReadMouse anop         jsr   Pause                    Mouse reads need to be 'spaced out'!         pea   0                        Result         pea   0                        Result         pea   0                        Result        ~ReadMouse         pla                            Status and mode         ply                            Y coordinate         plx                            X coordinate         dec   Counter         bne   ReadMouse                Do it again! (Ensure buffer(?) is clear)         bcc   ClearKbd                 ReadMouse was OK - mouse active; Mouse inactive or missing - I guess we'd better start it, then         inc   MouseFlg                 Say we started mouse up        ~InitMouse #0                   Search for mouse, and initialise it         bcs   ClearKbd                 No mouse to be found!        ~SetMouse #1                    Turn on the mouse in passive mode;................................................................;; Clear keyboard strobe and mouse data, and ensure mouse has elbow room!;ClearKbd anop         sta   $E0C010                  Ensure keyboard has been reset        ~ClearMouse                     Clear mouse data. No errors!         lda   #$7F         pha                            X-data         pha                            Y-data        ~PosMouse *,*                   Ensure mouse is NOT in HOME position!;                                       No errors!;----------------------------------------------------------------; MAIN LOOP;----------------------------------------------------------------;; Clear the screen, set 80 cols for safety, and write the first 'icon'.; We only do 23 lines to save special handling for line 24.;Home     anop         writestr Setup         lda   #(80*23)-2               Write the next 'icon' on 23 lines         sta   Counter                  Initialise counter;................................................................;; Display the next icon, check for a keypress or mouse activity, pause then loop;DoNext   anop         shortm         lda   TBCOLOR                  Get current colourNxtColor clc         adc   #$10                     Next text colour         bcs   NxtColor                 Skip 'Black'         sta   TBCOLOR         longm         writestr NextIcon              Erase old icon, then write next one; Check for a keypress (including modifier keys) or mouse activity         jsr   CheckKeyBd               Any keyboard activity?         bcs   Exit                     Yes, leave early         jsr   CheckMouse               Any mouse activity?         bcs   Exit                     Yes, treat the same as a keystroke; Pause, then decrement our counter and see whether we have finished this screen         jsr   Pause                    Move the 'icon' at a sedate pace         bcs   Exit                     Keypress, leave early         dec   Counter                  Finished this screen yet?         bne   DoNext                   No, print next icon         brl   Home                     Clear the screen and start again;................................................................;; Return to our caller, cleaning up after ourselves as appropriate;Exit     anop         writeln CleanUp                Clean up the text environment         lda   MouseFlg                 Did we start the mouse?         beq   Exit2                    No, skip close down        ~SetMouse #0                    Deactivate the mouseExit2    anop         lda   EventFlg                 Are we under the Event Manager?         beq   Exit3                    No, skip queue flush         jsr   FlushEvents              Flush the Event Manager queueExit3    anop; Restore the original screen colours         shortm         lda   Save1         sta   TBCOLOR         lda   CLOCKCTL         ora   Save2                    (Since Black Border = 0 already)         sta   CLOCKCTL         longm;			Parms on stacks from initialisation        ~SetOutputDevice *,*        ~SetOutGlobals   *,*	                          plbH_End    rtl                            Return to caller (= CDA shutdown code);................................................................;; PAUSE - Subroutine to pause a while. (Allow the 'icon' to move sedately).; =====   One iteration of the inner loop takes 'about' 1/20th of a second.;         On exit, C flag = 0  -  Loop completed normally;                         = 1  -  Loop interrupted by keyboard activity;;................................................................Pause    anop         lda   #&Delay                  Arbitrary (hopefully reasonable) delay         beq   P_Exit_0                 No delay requested         sta   Delay                    Initialise the counterP_Loop   anop         ldx   #$7FFFSpin     dex         bne   Spin                     Spin for a while (32767 times!)         jsr   CheckKeyBd               Any keyboard activity?         bcs   P_Exit_1                 Yes, leave early         dec   Delay                    Check outer loop         bne   P_LoopP_Exit_0 clc                            No keyboard interrupt         rtsP_Exit_1 sec                            Keyboard activity detected         rts;................................................................;; CHECKKEYBD - Subroutine to detect keyboard activity (normal keys or modifiers); ==========;              On exit, C flag = 0  -  No activity;                              = 1  -  Keyboard activity detected;................................................................CheckKeyBd anop         lda   EventFlg                 Use Event Manager?         bne   EventChk                 Yes - go check the queue         shortm         lda   $E0C000                  Look for a keystroke         bmi   K_Exit_1                 High bit = Key pressed = Finished         lda   $E0C025                  Look at keyboard modifier register         and   #%11011011               O-Apple, Option, Keypad, Rpt, Ctrl, Shft         bne   K_Exit_1                 Modifier key pressed = FinishedK_Exit_0 anop         longm         clc                            No activity         rtsK_Exit_1 sta   $E0C010                  Reset keyboard strobe         longm         sec                            Activity detected         rts;................................................................;; EVENTCHK - Subroutine to detect keyboard activity in the event queue; ========   (defined as key down or autokey).;            We don't check for mouse activity here since only mouse button;            up/down events are reported, NOT mouse movement.;            On exit, C flag = 0  -  No activity;                            = 1  -  Activity detected;................................................................EventChk anop         shortm         lda   $E0C025                  Look at keyboard modifier register         and   #%11011011               O-Apple, Option, Keypad, Rpt, Ctrl, Shft         bne   K_Exit_1                 Modifier key pressed = Finished         longm         pea   0                        Result space         pea   %0000000000101000        Look for keyboard events        ~EventAvail *,#EventRec         Event available?         pla                            Get result flag (No 'errors' possible)         beq   K_Exit_0                 No event, continue icon loop         bra   K_Exit_1                 Activity detected;................................................................;; FlushEvents - Ensure the event queue is empty when we start.; ===========   Flush *all* the events from the queue for safety;................................................................FlushEvents anop         pea   0                        Result space        ~FlushEvents #$FFFF,#0	Flush all valid events for all of queue         pla                            Ignore result         rts;................................................................;; CHECKMOUSE - Subroutine to detect mouse activity (movement or button); ==========   Returns 'no activity' if the mouse has not been activated.;              On exit, C flag = 1  -  No activity (or mouse inactive);                              = 0  -  Mouse activity detected;................................................................CheckMouse anop         pea   0                        Result         pea   0                        Result         pea   0                        Result        ~ReadMouse         pla                            Status and mode         ply                            Y coordinate         plx                            X coordinate         bcs   M_Exit_0                 Exit immediately if an error occurred         and   #$E000                   Want button/movement bits in Status only         bne   M_Exit_1M_Exit_0 clc                            No activity, or mouse error         rtsM_Exit_1 sec                            Activity detected         rts;................................................................;; Data areas;;................................................................HelloMsg str    '&NAME v&VER - Copyright 1992 by Peter Watson'Eyeball  dc    c'&SYSNAME - Copyright by Peter Watson, &SYSDATE &SYSTIME'Save1    ds    1                        Save TBCOLOR byteSave2    ds    1                        Save CLOCKCTL byteCounter  ds    2                        Icon loop counterDelay    ds    2                        Pause loop counterMouseFlg ds    2                        1 = We started up mouseEventFlg ds    2                        1 = Event Manager presentEventRec ds    16                       Event Manager record (We ignore it); 'Setup' clears the screen, sets 80 cols and no cursor, and MouseText mode; 'CleanUp' leaves things in a reasonable stateSetUp    dc    i1'4,18,6,12,27'         80-cols, Cursor_Off, CLSCleanUp  dc    i1'4,8,32,24,5'          No MouseText, Cursor on; NextIcon blanks the previous icon, then writes the next iconNextIcon dc    i1'5,8,32,15,&M_Icon,14' Blank last, M/text char         end