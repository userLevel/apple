         mcopy basicx.mac         gen   on;................................................................;; BASICX - Use BASIC.LAUNCHER to startup a BASIC program from APW or ORCA.;;          Turns out we can't launch BASIC.LAUNCHER directly, but we can set;          things up so we can run as part of an EXEC file, as follows :-;;          BASICX  [-P] pathname;          */BASIC.LAUNCHER;;          Optional -P parameter displays program details.;;          V1.0 Copyright Peter Watson, December 1988.;          V1.1 Copyright Peter Watson, January 1989. Add -P parm.;          V1.2 Copyright Peter Watson, January 1989. Filetype check, RetCode.;;................................................................         longa on         longi onBASICX   start         gblc  &VER         gblc  &MaxPath&VER     setc  '1.2'                    Program version number&MaxPath setc  '64'                     Maximum pathname lengthParmPtr  equ   0                        Offset into direct page for parm parsingHandle   equ   0                        Handle to message center parmAddress  equ   4                        Dereferenced handle         phk         plb         sta   UserId                   Save MM userid         sty   ParmPtr                  Save parameter...         stx   ParmPtr+2                ...address on entry         stz   PathBuf                  Initialise pathname length for reuse;................................................................;; First check for the Id string from APW or ORCA/M;;................................................................         lda   ParmPtr                  X = Y = 0?         ora   ParmPtr+2                Did we get a command line passed to us?         beq   GoExit                   No, we can (will) do nothing         ldy   #L:IdString-2ChkId    lda   [ParmPtr],Y              Check for legit parameter...         beq   GoExit         cmp   IdString,Y               ...starting with 'BYTEWRKS'         beq   *+5GoExit   brl   Exit                     Leave immediately         dey         dey         bpl   ChkId;................................................................;; Now we can look for our real command operands (Skip command name first);;................................................................         shortm                         8-bit memory & registers         ldy   #L:IdString              Point to first byte of command lineLook1    anop         lda   [ParmPtr],Y              Get character         beq   Prompt                   End of string - Not enough!         cmp   #' '                     End of command yet?         beq   SkipBlnk                 Yes, Go skip some blanks         iny         bne   Look1; Skip blanks until next parameterSkipBlnk anop         lda   [ParmPtr],Y              Get character         beq   Prompt                   End of string         cmp   #' '                     Non-blank yet?         bne   LookDone                 Found first operand byte         iny         bne   SkipBlnkLookDone anop;................................................................;; Handle '-P' parameter to display program details;; If the user is silly enough, he will get a message for each -P parameter;;................................................................         cmp   #'-'                     Is it a -P parameter?         bne   CopyPath                 No, assume it's a pathname         iny                            Bump Parameter index         lda   [ParmPtr],Y              Get next character         beq   MissParm         and   #$DF                     Make upper case         cmp   #'P'                     Is it a -P parameter?         beq   ShowVer                  Yes, display a message         brl   UnkParm                  No, unknown parameterMissParm lda   #' '         brl   UnkParmShowVer  anop         phy         longm         writeln         writeln VerMsg                 Display a version message         shortm         ply         iny                            Bump Parameter index         brl   Look1                    Go look for the pathname;................................................................;; Transfer the parameter to the pathname buffer;;................................................................CopyPath ldx   #0                       Offset into PathBufLoop3    anop         sta   PathBuf+1,X              Fill the pathname buffer         inx                            Bump PathBuf index         cpx   #&MaxPath+1              Pathname too long?         blt   *+5         brl   ParmErr                  Yes, go whinge about it         inc   PathBuf                  Increment count byte         iny                            Bump Parameter index         lda   [ParmPtr],Y              Get next character         beq   CopyDone                 End of buffer         cmp   #' '                     Trailing blank? (which we will ignore)         bne   Loop3                    Not done yetCopyDone anop         longm                          16 bit memory & registers         brl   GotPath                  Continue processing;................................................................;; Prompt the caller for a pathname;;................................................................Prompt   anop         longm                          16 bit memory & registers         writeln         writestr #'Enter pathname for BASIC program >'         pea   0                        Result - Character count         pushlong #PathBuf+1            Pathname buffer         pea   &MaxPath                 Maximum line length         pea   13                       End-of-Line character = <Return>         pea   1                        1 = Echo characters        _ReadLine; Store the length - if zero, then exit         writeln         pla                            Get character count         bne   ReadOK         lda   #$FFFF                   Error code         brl   Exit2                    None, time to goReadOK   anop         shortm         sta   PathBuf         longm;................................................................;; Allow a wildcard filename;;................................................................GotPath  anop        _Init_WildCard WildParm        _Next_WildCard WildParm         ldx   #'!'                     Error location flag         bcc   *+5         brl   Error                    Handle error condition; Check that we actually found a valid pathname (else PathBuf is now blank)         lda   PathBuf                  Get length of pathname (1 byte!)         and   #$00FF                   Ensure high byte is zero         tax                            Test for zero and prime X register         bne   FixParm                  Found (by Next_WildCard)         writeln #'Unable to find requested BASIC program'         brl   Prompt;................................................................;; Use the obtained pathname as the program to call.; Now, finish building the 'message' by putting 2 bytes of 0 at the end.;;................................................................FixParm  anop         stz   PathBuf+1,X              Put two zero bytes after pathname         clc                            A-reg set above         adc   #11                      Plus overhead (4+2+2+1+PathNameLen+1+1)         sta   MsgPLen                  Save total length for later;................................................................;; Check that the file is BAS, BIN, SYS or TXT only;;................................................................        _Get_File_Info InfoParm         Get file's filetype         ldx   #'+'                     Error location flag         bcc   *+5         brl   Error                    Handle error condition         lda   FileType                 Get filetype         cmp   #$04                     TXT?         beq   TypeOK                   That's OK         cmp   #$06                     BIN?         beq   TypeOK                   That's OK         cmp   #$FC                     BAS?         beq   TypeOK                   That's OK         cmp   #$FF                     SYS?         beq   TypeOK                   That's OK         writestr #'Filetype of '         writestr PathBuf         writeln  #' is not BAS, BIN, TXT or SYS'         brl   PromptTypeOK   anop;................................................................;; Send a message to the 'message center' for BASIC.LAUNCHER to collect;; Start by getting some memory from the memory manager;;................................................................         pushlong #0                    Result space         pushlong MsgPLen               Size required         pushword UserId                MM userid         pushword #0                    Attributes         pushlong #0                    Location (unused)        _NewHandle         ldx   #'4'                     Error location flag         bcc   *+5         brl   Error         pulllong Handle                Store handle in Direct Page         lda   [Handle]                 Dereference handle         sta   Address         ldy   #2         lda   [Handle],Y         sta   Address+2;................................................................;; Copy the 'message' into the memory we obtained;;................................................................         ldy   MsgPLen                  Get length to copy         dey                            Decrement for use as an offset         shortmLoop     anop         lda   MsgParm,Y                From our program         sta   [Address],Y              To memory buffer         dey         bpl   Loop         longm;................................................................;; Now send the message to the 'message center';;................................................................         pea   0001                     Action = Add         pea   0001                     Type   = 1   (open/print name)         pushlong Handle                Handle to structure        _MessageCenter         ldx   #'5'                     Error location flag         bcs   Error;................................................................;; Lastly we must return the memory we obtained;;................................................................         pushlong Handle        _DisposeHandle         ldx   #'6'                     Error location flag         bcs   Error;................................................................;; Return to our caller;;................................................................Exit     lda   #0                       Good return codeExit2    anop        _Quit  QuitParm                 Shell traps this;................................................................;; Handle errors - pretty ordinary, but then errors are unlikely! (???!!!);; On entry, X = an identifier character to say where we came from;;................................................................Error    anop         sta   ErrCode         txa                            Get error location identifier         writech                        Where did the error occur?        _Error ErrCode                  Shell will print a message         lda   ErrCode                  To tell the user         bra   Exit2;................................................................;; ParmErr - Print an error message for a parameter that is too long;;................................................................ParmErr  anop         longm         writeln         writestr #'Pathname length more than &MaxPath characters'         brl   Prompt;................................................................;; UnkParm - Print an error message for an unknown parameter;;           The only valid parameters are the pathname, with an;           optional '-P' switch to display program details.;;................................................................UnkParm  anop         longm         pha                            Save parameter character         writeln         writestr #'Unknown parameter (-'         pla                            Get unknown parameter character         writech         writech  #')'         lda   #$FFFF                   Error code         brl   Exit2;................................................................;; Data areas;;................................................................IdString dc    c'BYTEWRKS'              Shell id stringUserId   ds    2                        Memory Manager Id passed by ShellErrCode  ds    2                        Error code from tool callMsgPLen  ds    4                        Actual length of message structureMsgParm  anop                           Structure for 'Message Center' call         dp    0                        Link pointer         dc    i'1'                     Type = 1         dc    i'0'                     0 = 'open' filePathBuf  dc    i1'&MaxPath',&MaxPath.c' ' Name1PBufLen  equ   *-PathBuf-1              Max length for pathname         dc    i1'0'                    Pathname2 (will be null, ie. length = 0)         dc    i1'0'                    Terminator flagEyeball  dc    c'&SYSNAME - V&VER Copyright by Peter Watson &SYSDATE &SYSTIME'VerMsg   str    '&SYSNAME - V&Ver Copyright by Peter Watson, January 1989'WildParm anop                           Parameter to handle a wildcard filename         dp    PathBuf         dc    i'$4000'                 '?' prompting allowed; 1st match onlyInfoParm anop                           Parameter for Get_File_Info         dp    PathBuf                  Pathname         ds    2                        Access typeFileType ds    2                        Filetype         ds    18                       Other odds and endsQuitparm anop                           Parameter for GS/OS Quit call         dp    0                        Return to calling program         dc    i'0'                     No flags needed         end