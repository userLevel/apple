;................................................................;;      GOTOXY;      ------;  Position the text screen cursor at a given X-Y location.;;  Works with both BASIC or Pascal screen protocols.;  The 'real' GOTOXY function only works with the Pascal protocol, which we;  may not be able to guarantee, for example, in a CDA.;;  On entry, e = m = x = 0 (full native mode).  B, D, S, Acc = Don't care;            X = x-axis location 1-80  (It couldn't be much easier to remember!);            Y = y-axis location 1-24;;  *** Note: No error checking is performed on input values.;            Garbage will be printed if the bounds are exceeded!;; On exit,   B, D, S, A, X, Y, e, m, x unchanged;; Copyright 1990 by Peter Watson.; Permission granted to use this code provided acknowledgement is given.;;................................................................;;  NOTE: This is NOT a standalone program!;        ---------------------------------;;  To install in source code, add the following source line :-;;      APPEND GOTOXY                    (or manually cut & paste this source);;  Or ensure that this routine has been installed in a library (eg. PAW.LIB);;  Example of use :-;;        ldy   #3;        ldx   #40;        jsl   GOTOXY                   ;GOTO line 3, column 40;;................................................................         case    on         objcase on                     Need lowercase 'main' for 'C'GOTOXY   start   main         longa   on                     Just for the assembler's sake         longi   onC_LF     equ   $8A                      <Line Feed>C_Home   equ   $99                      <Home Cursor> (doesn't clear screen)C_Right  equ   $9C                      <Move Right> (non-destructive 'space');................................................................;; Start of the main routine;; Start by getting our stack and DP in order. (Assume m = x = 0);;................................................................         phb                            Save data bank address         phk         plb                            Localise the data bank register         pha                            Save registers         phx         phy;................................................................;; Move the cursor         tya                            Get VTAB value         ora   #C_Home*$100             $hhll - Length and Home         sta   VTABmsg         phx                            Save X reg         writestr VTABmsg               Move to start, then down         pla                            Retrieve HTAB value         dec   A                        Make into offset         beq   Done         xba                            $ll?? = ??ll when stored         sta   HTABmsg-1                Ignore 'extra' byte         writestr HTABmsg               Move right;................................................................;; Clean up and go homeDone     anop         ply                            Restore registers         plx         pla         plb         rtl                            Return to our caller;................................................................;; Data areasVTABmsg  ds    2                        String length and Home Cursor         dc    24i1'C_LF'               24 <line feed>s         ds    1                        'Overflow' from 16 bit storeHTABmsg  ds    1                        String length         dc    80i1'C_Right'            80 <move right>s         end