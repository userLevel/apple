         mcopy toggle.mac         gen   on;................................................................;; TOGGLE - Swap a IIgs slot from the internal port to 'Your Card' & vice-versa.;;          Syntax:  TOGGLE slot {-b};              'slot' - Number (1-7) of the slot to toggle;              '-b'   - Optional parm causing an immediate (re)Boot;;          v1.0 - P. Watson, 15th May 1990.;;................................................................         longa on         longi onToggle   start         gblc  &VER         gblc  &MaxBuf         gblb  &Debug&VER     setc  '1.0'                    Program version&MaxBuf  setc  '9'                      Maximum parameter/pathname buffer size&Debug   setb  0                        Set debugging mode offParmPtr  equ   0                        Offset into direct pageslt1intExt equ $21                      Slot 1 internal/external parm ref. no.;                                       Slot 2 = $22, etcSltIntExt equ  slt1IntExt-1             Mask for 'OR'ing to create correct value;................................................................         phk         plb                            Better data bank for us         sty   ParmPtr                  Save parameter...         stx   ParmPtr+2                ...address on entry         stz   SlotRef         stz   BootFlag         writeln         aif   .NOT.&Debug,.NoEye         writestr Eyeball               Minute to minute version data!.NoEye         writeln HelloMsg               Announce ourselves to the world         writeln ;................................................................;; Check for a shell Id string - we don't care who from!;;................................................................         lda   ParmPtr                  X = Y = 0?         ora   ParmPtr+2                Did we get a parm?         bne   *+5         brl   Exit                     No, simply leave early;................................................................;; Now we can look for our real command operand (Skip command name first);;................................................................         stz   ParmLen                  Ensure high byte is zero (Memory)         lda   #0                       Ensure high byte is zero (Acc)         shortm                         8-bit accumulator & memory         ldy   #8                       Point to first byte of command line data         jsr   GetToken                 Skip our command name;................................................................;; Transfer the first parameter to the slot buffer;;................................................................         jsr   GetToken                 Get first parameter         lda   ParmLen                  Get parameter length         bne   *+5         brl   GoPErr3                  No slot value - error!         cmp   #2                       Parameter too long?         bge   GoPErr2                  Too long!         lda   ParmBuf                  Get the byte         cmp   #'1'                     Valid byte?         blt   GoPErr3                  No         cmp   #'8'         blt   SlotOK                   YesGoPErr3  brl   ParmErr3                 Handle the errorSlotOK   anop         and   #$07                     Chop off ASCII bits         ora   #sltIntExt               Make it valid BRam parm. ref. no.         sta   SlotRef                  Save it         aif   .NOT.&DEBUG,.NoSltRef         longm         phy         pha         writestr #'SlotRef = '         lda   1,S                      Retrieve saved A-reg         jsl   ShowAcc         writeln         pla         ply         shortm.NoSltRef;................................................................;; Transfer the second parameter to the 'reboot' flag;;................................................................         jsr   GetToken                 Get next parameter (if any)         lda   ParmLen                  Any parameter found?         bne   *+5         brl   ParmDone                 No parm, continue normally         lda   ParmBuf                  Get first character         cmp   #'-'                     Switch parameter?         bne   GoPErr2                  No, so error         lda   Parmlen                  Get the length         cmp   #2                       Two characters?         bne   GoPErr2                  No, invalid switch parameter         lda   ParmBuf+1                Get actual switch         and   #$DF                     Make upper case         cmp   #'B'                     Is it the 'reboot' switch?         beq   *+5GoPErr2  brl   ParmErr2                 No, invalid switch parameter         inc   BootFlag                 Say we found a '-B' parameter         jsr   GetToken                 Find next parameterParmDone anop         longm;................................................................;; Get the current slot status from the control panel parameters;;................................................................         pha                            Result space         pushword SlotRef               Slot int/ext status ref no        _ReadBParam                     Get the slot int/ext status         aif   .NOT.&DEBUG,.NoShow         longm         phy         writestr #'Slot Status = '         lda   3,S                      Retrieve returned value from stack         jsl   ShowAcc         writeln         ply         shortm.NoShow         pla                            Retrieve the result;................................................................;; Replace with the new status;;................................................................         eor   #1                       Toggle the bit         sta   SlotStat                 Save for message         pha                            New value         pushword SlotRef               Slot int/ext status ref no        _WriteBParam                    Update the slot int/ext status;................................................................;; Tell the user what we've done;;................................................................         lda   SlotRef                  Get slot ref. no.         and   #$0007                   Get slot number         pha                            Save for later         ora   #' 0'                    Don't forget the <space> char!         sta   DoneMsg+6                Insert into the message         writestr DoneMsg         pla                            Retrieve slot number         ldx   SlotStat                 Is it now a port or a slot?         beq   DoPort         writeln #'Your Card'         brl   MsgDoneDoPort   anop         cmp   #3                       80-col port?         beq   VideoMsg                 Yes, handle it         cmp   #4                       Mouse port?         beq   MouseMsg                 Yes         cmp   #5                       Smart port?         beq   SmartMsg                 Yes         cmp   #6                       Disk port?         beq   DiskMsg                  Yes         cmp   #7                       AppleTalk?         beq   ATlkMsg                  Yes         writeln #'IIgs Port'           Could be more specific, but for ROM 03?         brl   MsgDoneVideoMsg anop         writeln Slot3Msg         brl   MsgDoneMouseMsg anop         writeln Slot4Msg         brl   MsgDoneSmartMsg anop         writeln Slot5Msg         brl   MsgDoneDiskMsg  anop         writeln Slot6Msg         brl   MsgDoneATlkMsg  anop         writeln Slot7MsgMsgDone anop;................................................................;; Reboot, if required, by calling OS_ShutDown with auto restart;;................................................................         lda   BootFlag                 Reboot required?         beq   Exit                     No; Do a DeskShutDown call first. Not theoretically required, but circumvents; a problem with SoftSwitch, which needs some program to have issued this; call at some stage.  Of course, TEXT shells don't issue it very often!        _DeskShutDown                   No parameters, and no errors        _OSShutdownGS ShutParm          Shut down the system; Should never drop through (unless GS/OS is 'busy'?); Of course, we may simply NOT be running GS/OS in this program!         pha                            Save error code         writeln #'ShutDown call failed!  GS/OS required for reboot option'         pla;................................................................;; Return to our caller;;................................................................Exit     anop         lda   #$0000                   Good return code always        _Quit QuitParm                  NB: MUST be Class 0 'Quit' call!!!;................................................................;;  SUBROUTINES;;................................................................;; GetToken - Look for the next command line token, if any.; ========   Maximum token length is 64 characters.;; On entry, Y = offset into command line;           m = 1 (8 bit accumulator mode); On exit,  ParmBuf contains the parameter;           ParmLen contains the length;           Y = offset of last token char + 1;           Exit via RTS; On error, GOTO ParmErr;;................................................................GetToken anop         longa off         aif   .NOT.&DEBUG,.DoGT         phy         longm         writestr #'GetToken : Y = '         lda   1,S                      Retrieve saved Y-reg         jsl   ShowAcc         writeln         shortm         ply.DoGT; Blank the parameter buffer for safety         ldx   #L:ParmBuf-1         lda   #' 'BlankIt  sta   ParmBuf,X                Blank parameter buffer for safety         dex         bpl   BlankIt         stz   ParmLen                  Ensure parameter length is zero; Skip any leading blanksSkipBlnk anop         lda   [ParmPtr],Y              Get character         beq   GTExit                   End of string         cmp   #' '                     Non-blank yet?         bne   SkipDone                 Found first operand byte         iny         bne   SkipBlnkSkipDone anop; Transfer the parameter to the pathname buffer         ldx   #0               CopyTokn anop         sta   ParmBuf,X                Fill the parameter buffer         inx                            Bump ParmBuf index         cpx   #L:ParmBuf               Token too long?         blt   CopyTok2         pla                            Pop the...         pla                                   ...return address         brl   ParmErr                  Yes, go whinge about itCopyTok2 iny                            Bump Parameter index         lda   [ParmPtr],Y              Get next character         beq   CopyDone                 End of string - done!         cmp   #' '                     Blank delimiter?         bne   CopyTokn                 No, not done yetCopyDone anop         txa                            Convert to 8 bits         sta   ParmLen                  Save parameter lengthGTExit   rts         longa on;................................................................;; ParmErr - Print an error message for a parameter that is too long; =======;................................................................ParmErr  anop         long                           16 bit memory & registers         writeln #'Parameter length more than &MaxBuf characters'         brl   Exit                     Go get a decent pathnameParmErr2 anop         long                           16 bit memory & registers         writestr #'Uknown parameter option ('         writestr ParmLen               Write unknown character(s)         writeln  #')'         brl   Exit                     Leave in a huffParmErr3 anop         long                           16 bit memory & registers         writeln #'Slot parameter missing, or not 1 to 7'         brl   Exit                     Leave in a huff;................................................................;; Data areas;;................................................................ParmLen  ds    1                        Parameter token lengthParmBuf  ds    &MaxBuf                  Parameter token bufferSlotRef  ds    2                        Slot int/ext BRam ref. no.BootFlag ds    2                        0 = Reboot not requiredSlotStat ds    2                        New slot statusHelloMsg str   '&SYSNAME v&VER - Copyright 1990 by Peter Watson'Eyeball  str   '&SYSNAME v&VER - &SYSDATE &SYSTIME 'DoneMsg  str   'Slot ? toggled to 'PortMsg  str   'IIgs Port'Slot3Msg str   '80-col Port'Slot4Msg str   'Mouse Port'Slot5Msg str   'Smart Port'Slot6MSg str   'Disk Port'Slot7Msg str   'AppleTalk'ShutParm OSShutdownRecGS 1,shutdownFlag=1 Restart, leaving powerup byte aloneQuitParm dp    0                        Pathname (Nb: Class 0 call!)         dc    i2'0'                    Flags (Return via Quit stack)         end