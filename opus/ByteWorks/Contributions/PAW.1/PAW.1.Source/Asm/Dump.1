         mcopy dump.mac         gen   on;.......................................;; DUMP  -  APW shell utility to dump a file in hex and ASCII on the; ====     80 column screen.  The shell utility DUMPOBJ requires parameters,;          and baulks at some files.  DUMP is reusable/restartable.;	  Besides - we can dump other file formats as well!;; Syntax:  DUMP [-X][-C][-T[T]][-A][-B][-M][-O/@ offset][-Q][-R][-1];	       [-I tabwidth] pathname;           (will prompt if pathname omitted; '+' supported as switch char);;          -X - Suppress hex listing (print 64 characters per line);          -C - Display only 'printable' chars ($20-$7F) (implies -X);               (No offsets, simply wraps at end of line);          -T - As '-C' mode, but honour <CR) chars ($0D) with a new line.;               (Acts like TYPE command, but reads any filetype.);          -TT- As '-T', but attempt to convert high ASCII to printable values.;          -A - As '-T' mode, but format AppleWorks WP files.;          -B - Format a type BAS file as Applesoft BASIC.;	  -M - Format a text file as Merlin source data.;          -O - Offset in file at which to start dumping. (Alias '-@');          -Q - Suppress title and copyright notice. Good for 'copying' files.;          -R - Dump the resource fork of a file.;          -1 - Read file 1 block at a time (useful for damaged files).;          -I - Alter default tab stop 'width' (Default: 5);                                   ;         Copyright by Peter Watson, November 1988 - July 1999.;;         Requires the following <INC>lude files (or object modules) :-;           DUMP.2                 Required subroutines;           DUMP.3                 BASICTAB token table;           ReadLn.INC             ReadLn subroutine;           ShowAcc.INC            Show accumulator subroutine (debug only);; Modifications :-;          v1.1 - Minor miscellaneous cleanup. Nov 88;          v1.2 - Bugfix - pathname buffer not reusable. 19 Dec 88;          v2.0 - Add wildcard file handling capability. 27 Dec 88;          v2.1 - Add '-X' and '-T' options, and ReadLn. 18 Feb 89;          v2.2 - Rename '-T' to '-C'. Add '-T' option.  11 Mar 89;                 Support '+' as the switch char. Disable cursor.;          v2.3 - Add '-A' option.                       20 Mar 89;          v2.4 - Add '-B' option.                        4 May 89;          v2.41- Fix buffer refill bug with '-A'.       20 May 89;          v2.5 - Fix <Apple>-. bug with '-A' and '-B'.  22 Jul 89;                 Fix '-C' for AWP and BAS files. Options prompt under Finder.;          v3.0 - Add '-O' option. Support AWP 3.0 files. 23 Nov 89;                 Minimal support for non-BYTEWRKS shells.;          v3.1 - Add '-R', '-Q'. Allow '-O' for BAS files. 18 Feb 90;                 <Tab> stops every 5 spaces.;          v3.11- Fix LastMsg bug which didn't always show last line! 6 Apr 90;          v3.12- Reset A or B flags if set by program. Use ConsoleOut. 8 Feb 91;          v3.2 - Fixed calling toolbox in 8-bit mode for BAS files. 23 Aug 92;		   Support ProSel command lines. Handle quoted parameters.;		   Ignore 'invisible' files (mostly 'FINDER.' files) if '-T'.;          v4.0 - Major update. April 1994;		   . Press '?' while paused to show offset and pathname;		   . Handle embedded quotes in quoted parameters;		   . Handle embedded control chars in BASIC REMs, strings;		   . <LF> treated like <CR> in '-T' mode (except after <CR>);		   . Tabs move to 6, 11, 16... instead of 5, 10, 15...;		   . Ensure that <CR> is issued after error messages;		   . '-X' mode no longer repeats last line if <Apple>-. pressed;		   . Added '-1' mode to read file 1 block at a time;		   . Spurious trailing blanks removed, eg. from '-A' lines;		   . Now attempts to recover from mildly corrupted AWP files;		   . <CR> added to AWP lines;		   . Display tag data found after normal AWP file end;		   . Added '-M'(erlin) mode to display Merlin source files;		   . Added '-I' to change default tab stop width;		   . Added '-TT' to convert high ASCII values to printable;          v4.01- AWP <CR> records not generating a <CR>! April 1994;          v4.02- BASIC formatting problems fixed. July 1994;          v4.1 - AW5.0 AWP Mousetext/Inverse; Reverse bold/underline. Feb 1995;          v4.2 - Uses ORCA shell v2.0 wildcard calls. June 1995;		   Still runs under ORCA 1.0 and ProDOS 16, but no wildcards.;          v4.3 - Ensure 16-bit mode for tool calls in STOP_PAUSE. July 1999;		   Merlin tabs generate at least one space. Show file offset;		   after I/O errors. Continue after I/O errors in '-1' mode.;		   Show EOF in file offset displays.;.......................................         longa on         longi onDUMP     start         gblc  &VER         gblc  &MaxBuf         gblb  &Debug&VER     setc  '4.3'	Program version&MaxBuf  setc  '250'                    Max parm/pathname buffer size&Debug   setb  0                        Debug mode flagParmPtr  equ   0  (long)	Direct page pointer to cmd lineZPStart	equ	4	First location to be clearedKeyWdLen equ   4  (word)	Keyword length counterLastChar equ   6  (word)	Previous char in BASIC lineAW_Offset equ  8  (word)	A/Works - Offset into data lineAW_Len	equ	10 (word)	A/Works - Line lengthAW_Byte0	equ	12 (word)	A/Works - First byte in a line recordB_Offset	equ	14 (word)	BASIC - Offset into lineB_LineNo	equ	16 (word)	BASIC - Line number acc.B_Quoted	equ	18 (word)	BASIC - 'In quoted string' flagMTabCnt	equ	20 (word)	Merlin - Count of tabs on a given lineWork	equ	22 (word)HexFlag	equ	24 (word)	Non-zero if *program* wants hex dumpMTxtFlag	equ	26 (word)	A/Works - True if in MouseText modeBoldFlag	equ	28 (word)	A/Works - True if in Bold modeULFlag	equ	30 (word)	A/Works - True if in Underline modeITxtFlag	equ	32 (word)	A/Works - True if in Inverse modeInvFlag	equ	34 (word)	A/Works - True if displaying in inverseZPZapLen	equ	64-ZPStart	Length of zero-page stuff: must be evenTabSize  equ   5                        Default Tab stop width (not for A/Wks)Tab      equ   $09                      <Tab> = TabCR       equ   $0D                      <CR>  = Carriage ReturnLF       equ   $0A                      <LF>  = Line FeedInv_Off	equ	$0E	Turn inverse display offInv_On	equ	$0F	Turn inverse display onMT_Off	equ	$18	Turn MouseText offMT_On	equ	$1B	Turn MouseText onAWP_Type equ   $1A                      AppleWorks WP filetypeGWP_Type equ   $50                      Graphics WP filetype (ie. Teach format)BAS_Type equ   $FC                      Applesoft BASIC filetype;.......................................         phb         phk         plb         ora   #$0100                   Make the UserId unique to us         sta   UserId         sty   ParmPtr                  Save parm address         stx   ParmPtr+2         tsc                            Save stack for debugging         sta   SaveStck         stz   ParmXFlg                 Init 'parm found' flags         stz   ParmCFlg         stz   ParmTFlg         stz   ParmTTFlg         stz   ParmAFlg         stz   ParmBFlg         stz   ParmMFlg         stz   ParmOFlg         stz   ParmQFlg         stz   ParmRFlg         stz   Parm1Flg         stz   FixFlag         stz   RulerFlg         stz   StrtByte                 Init start offset into file         stz   StrtByte+2         stz   PathFlag                 Init 'Found pathname' flag         stz   PathGSOS                 Init pathname length byte (P16 & GS/OS)         stz   ShellPgm                 Init 'Running under Shell' flag	lda	#TabSize	Default tab width	sta	TabWidth         lda   #L:LineC         sta   LineMsgC                 Make sure length is right	lda	DataLen	Set default read buffer size	sta	ReadReqL	lda	DataLen+2	sta	ReadReqL+2	ldx	#ZPZapLen	Length of area to zapZPZaps	stz	ZPStart,X	Clear two bytes at a time	dex	dex	bpl	ZPZaps	Go do some more        _IMStartUp                      Start Integer Math toolset;.......................................;; Set the Input Global parameters to remove the high bit from input.; The Shell does this for us, but let's be safe.;         pushlong #0                    Result space        _GetInGlobals                   Leave result on the stack for exit         pea   $7F                      AND mask - strip high bit         pea   $00                      OR  mask - no change        _SetInGlobals;.......................................;; Check for Id string from APW or ORCA/M (if not, parse command line anyway);         lda   ParmPtr                  X = Y = 0? Did we get a parm?         ora   ParmPtr+2         bne   *+5                      Yes         brl   Prompt                   No, so we must prompt         ldy   #L:IdString-2ChkId    lda   [ParmPtr],Y              Check for valid parm...         beq   IsShell         cmp   IdString,Y               ...starting with 'BYTEWRKS'         bne   IsShell                  Unknown shell (not APW or ORCA)         dey         dey         bpl   ChkId         inc   ShellPgm                 ShellPgm = TRUE (non-zero)IsShell  anop                           A 'shell' - if unknown, no wildcards!;.......................................;; Look for our command parameters (Skip command name first);         stz   ParmLen                  Ensure high byte is zero (memory)         lda   #0                       Ensure high byte is zero (Acc)         shortm         ldy   #L:IdString              First byte of command line         jsr   GetToken                 Skip command name;.......................................;; Transfer the first parm to the pathname buffer, unless it's a; switch (-X, etc). Support '+X' format too.; Nb: The -T, -A and -B parms exit through the -C code.;LookParm procname LookParm         jsr   GetToken                 Get next 'token'         lda   ParmBuf         cmp   #'-'                     Switch parm?         beq   LP2                      Yes         cmp   #'+'                     Alternate switch?         beq   LP2                      Yes         brl   GetPath                  No, get pathnameLP2      lda   ParmLen                  Get length         cmp   #2                       At least two chars?         bcs   LP3	brl   ParmErr1                 No, invalid switchLP3      lda   ParmBuf+1                Get switch char; Test first for switches that can't handle being 'uppercase'd!         cmp   #'1'                     -1 : '1 block' buffer required?         bne   Not1	inc	Parm1Flg         brl   LookParmNot1     anop; Now we can uppercase the rest!         and   #$DF                     Make upper case         cmp   #'X'                     -X : Suppress hex output?         bne   NotX         inc   ParmXFlg         brl   LookParmNotX     anop         cmp   #'C'                     -C : Character data only, ie. no offsets         bne   NotC         inc   ParmCFlgDoSwC    anop                           Entry from -T, -A, -B or -M switch code         longm         jsr   NewLineC                 Clear output line for the first pass         lda   #0                       Keep Acc high byte clean         shortm         bra   LookParmNotC     anop         cmp   #'T'                     -T : Honour <CR> chars? (Like TYPE)         bne   NotT         inc   ParmTFlg	lda	ParmBuf+2	and	#$DF	Upper case	cmp	#'T'	-TT: Convert high-ASCII characters         bne   DoSwC                    Clear the '-C' line buffer         inc   ParmTTFlg         bra   DoSwC                    Clear the '-C' line bufferNotT     anop         cmp   #'A'                     -A : Honour AppleWorks WP files?         bne   NotA         inc   ParmAFlg         bra   DoSwC                    Clear the '-C' line bufferNotA     anop         cmp   #'B'                     -B : Format BASIC output?         bne   NotB         inc   ParmBFlg         bra   DoSwC                    Clear the '-C' line bufferNotB     anop         cmp   #'O'                     -O : Offset to start at in file?         beq   IsO                      Yes         cmp   #'@'                     -@ : Alias for '-O'?         bne   NotOIsO      anop         inc   ParmOFlg         jsr   GetToken                 Get next token         jsr   GetOffset                Parse and store the value         brl   LookParmNotO     anop         cmp   #'Q'                     -Q : Quiet (no header)?         bne   NotQ         inc   ParmQFlg         brl   LookParmNotQ     anop         cmp   #'R'                     -R : Resource fork required?         bne   NotR         inc   ParmRFlg         brl   LookParmNotR     anop         cmp   #'M'                     -M : Merlin source format?         bne   NotM         inc   ParmMFlg         brl   DoSwC                    Clear the '-C' line bufferNotM     anop               cmp   #'I'                     -I : Alter default tab width         bne   NotI	"qoth the raven"         jsr   GetToken                 Get next token         jsr   GetTabWid	Parse and store the value         brl   LookParmNotI     anop                    	brl   ParmErr1                 Invalid switch parm;.......................................;; Now get the pathname parameter for sure;GetPath  procname GetPath         lda   ParmLen                  Parameter length...         sta   PathBuf                  ...in length byte         bne   *+5         brl   Prompt                   No pathname, go prompt         tax                            Transfer 16 bits         dexLoop1    anop         lda   ParmBuf,X                Get next char         sta   PathName,X               Fill the pathname buffer         dex                            Bump PathBuf index         bpl   Loop1         inc   PathFlag                 Say we have a pathname parm         brl   GotParms                 Start processing;.......................................;; Prompt the caller for a pathname;Prompt   procname Prompt         longm                          16 bit Acc.         stz   PathGSOS                 May be 'dirty' after an error         ConsoleOut CursOn              Cursor back on, just in case         writestr #'Pathname to &SYSNAME >'         pushlong #PathName             Pathname buffer         pea   &MaxBuf                  Max line length         jsl   ReadLn                   Get input line         writeln                        New line after read         pla                            Char count         bne   *+5GoExit   brl   Exit                     None, time to go         shortm         sta   PathBuf         longm;.......................................;; Prompt the caller for an option (-O, -I, -TT not supported here!);         lda   ShellPgm                 Running under the Shell?         beq   *+5         brl   GotParms                 No, don't prompt for parms         writestr #'Option(s)? (X, C, T, A, B, M, R, 1, Q or <None>) >'GetOpt   anop         pushlong #1                    Result space; echo on        _ReadChar         pla                            Retrieve char         and   #$007F                   Clear high byte and bit         cmp   #' '	Ignore spaces         beq   GetOpt         cmp   #','	Ignore commas         beq   GetOpt         cmp   #'-'	Ignore switch chars         beq   GetOpt         cmp   #$1B                     <Esc> = Prompt again         bne   NotEsc2         brl   Prompt                   Start prompting againNotEsc2	anop	cmp   #'1'                     '1 block' mode?         bne   Not12         inc   Parm1Flg         bra   GetOptNot12    anop           and   #$DF                     Make upper case         cmp   #'X'                     No Hex?         bne   NotX2         inc   ParmXFlg         bra   GetOptNotX2    cmp   #'C'                     No offsets?         bne   NotC2         inc   ParmCFlg         bra   GetOptNotC2    cmp   #'T'                     Text?         bne   NotT2         inc   ParmTFlg         bra   GetOptNotT2    cmp   #'A'                     AWP format?         bne   NotA2         inc   ParmAFlg         bra   GoGetOptNotA2    cmp   #'B'                     BAS format?         bne   NotB2         inc   ParmBFlg         bra   GoGetOptNotB2    cmp   #'R'                     Resource fork?         bne   NotR2         inc   ParmRFlg         bra   GoGetOptNotR2    anop    	cmp   #'M'                     Merlin format?         bne   NotM2         inc   ParmMFlg         bra   GoGetOptNotM2    anop	cmp   #'Q'                     Quiet mode?         bne   NotQ2         inc   ParmQFlg         bra   GoGetOptNotQ2    anop         cmp   #CR                      <CR> = default         beq   PromptOX                 Yes, got all we're getting         writestr DelMsg                Delete char on screenGoGetOpt	brl   GetOpt                   Try againDelMsg   dc    i1'2,8,29'               Destructive backspacePromptOX anop         writeln                        New line after read         jsr   NewLineC                 Always clear buffer here;.......................................;; Set up for wildcard file handling;GotParms procname GotParms         longm         lda   ParmQFlg                 Quiet?         bne   TitlDone         writeln         writeln HelloMsg               Say hello!         aif   .NOT.&Debug,.NoEye         writeln Eyeball.NoEyeTitlDone anop	jsr	FixFName	Copy name to display buffer for errors         lda	PathGSOS	Convert PString to GString	xba	sta	PathGSOS	; Nb: If not running under a shell, then this will be undone below anyway!	lda   ShellPgm         beq   SkipWild                 Skip wild-carding if not under Shell         InitWildcardGS WildParm         bcc   *+5         brl   ToolErrSkipWild anop	stz   OpenFlag                 'File opened' flag = CLOSED         stz   FileCnt                  'Files processed'  = 0; Set last tab column based on tab width value	lda	#1	clcSetTabLp	anop	adc	TabWidth	cmp	#L:LineC	Reached end of line yet?	bcc	SetTabLp	No, keep looping	beq	StorLTab	Yes, exact value!	sbc	TabWidth	Reset to last stop within lineStorLTab	sta	LastTab	Store for tab use; Shrink buffer read size, if requested	lda	Parm1Flg	'1 block' read mode?	beq	ReadLOk	No, skip size reset	lda	DataLenS	Set '1 block' read buffer size	sta	ReadReqL	lda	DataLenS+2	sta	ReadReqL+2ReadLOk	anop; Round starting offset to provide an 'even' boundary, if required         lda   ParmOFlg                 Offset requested?         beq   NextFile                 No         lda   ParmCFlg                 C, T, B or M mode?         ora   ParmTFlg         ora   ParmBFlg         ora   ParmMFlg         bne   NextFile                 Yes, offset OK         lda   StrtByte         ldx   ParmXFlg                 X mode?         beq   DefltMde                 No         and   #$FFC0                   Else round down to $40 boundary         bra   StorStrtDefltMde anop                           Default hex dump mode         and   #$FFF0                   Round down to $10 boundaryStorStrt sta   StrtByte;.......................................;; Open (next) file after getting next (or only) filename.; Ignore the file if the invisibility bit is set and we're in -Text mode.; Set the file pointer if '-O' was specified.; If no files found, then fake a 'Path not found' error.;NextFile procname NextFile         lda   FixFlag         beq   FixDone         stz   ParmAFlg         stz   ParmBFlg         stz   ParmTTFlg         stz   FixFlagFixDone  anop         NextWildcardGS NextParm        Get next/only filename, if any; Even if not under a shell, this undoes a similar change above         lda	PathGSOS	Convert GString to PString	xba	sta	PathGSOS	; Copy the filename to a display buffer, setting the separator to '/'	jsr	FixFName	Copy name and convert ':' to '/'         lda   PathBuf                  Get length         and   #$00FF                   Low order byte only!         bne   GetFInfo                 Found (next) file         lda   FileCnt                  Count of processed files         beq   *+5         brl   GoExit                   Found at least one (per prompting)         lda   #$44                     Fake 'Path not found' error         brl   ToolErr; Note: We still do GetFileInfo, since NextWildcardGS mat have have executedGetFInfo	anop        _Get_File_Info InfoParm         Get file details         bcc   *+5         brl   ToolErr; If displaying text, check for AWP, BAS or GWP files and format correctly; Also, ignore files with invisibility bit set.         lda   ParmTFlg                 '-T' flag set?         beq   TellUser                 No         lda   InfAccess                Get file access bits	and	#$0004	Check for 'invisible' bit         bne	NextFile	Bit set - go look for another file         lda   FileType                 Get filetype         cmp   #AWP_Type                AWP file?         bne   NotAWP                   No         inc   ParmAFlg                 Set '-A' flag         bra   SetFixFlagNotAWP   anop         cmp   #GWP_Type                GWP file? ($50 - Graphics Word Proc)         bne   NotGWP                   No         inc   ParmTTFlg                Set '-TT' flag         bra   SetFixFlagNotGWP   anop         cmp   #BAS_Type                BAS file?         bne   TellUser                 No         inc   ParmBFlg                 Set '-B' flagSetFixFlag anop         inc   FixFlag                  Tell us to reset later; Tell the user what he's about to seeTellUser procname TellUser         ConsoleOut CursOff             Cursor off for speed         inc   FileCnt                  Increment 'files processed'         lda   ParmQFlg                 Quiet?         bne   HdrDoneB         writeln         writestr ShowBuf               Display current pathname         lda   ParmRFlg                 -R specified?         beq   HdrDoneA         writestr #' (Resource data)'HdrDoneA writeln         writelnHdrDoneB anop;.......................................;; Open the file's data fork (or resource fork if -R)DoOpen   procname DoOpen         lda   ParmRFlg                 -R specified?         bne   OpenRsrc                 Yes, open the resource fork        _Open  OpenParm                 Open the file (data fork)         bcs   OpenErr         lda   RefNum         bra   StRefNumOpenErr  brl   ToolErr                  OPEN failedOpenRsrc anop         lda   PathGSOS         xba                            Fix length for Class 1 call         sta   PathGSOS        _OpenGS OpenPrmGS               Open the resource fork         php                            Save error status         pha         lda   PathGSOS         xba                            Now fix for Class 0 calls and msgs         sta   PathGSOS         pla         plp         bcs   OpenErr         lda   RefNumGSStRefNum anop         sta   ReadParm                 Store refnum in READ parm         sta   EOFParm                  Also GET_EOF         sta   MarkParm                 Also SET_MARK         inc   OpenFlag                 For error routine later	_Get_EOF EOFParm	Get the file EOF (length)	bcc	*+5	brl	ToolErr         stz   Address         stz   Address+2         stz   LastFlag                 Begin with no data in line         stz   ExitFlag                 No exit flag set         stz   ALenFlag                 AWP file length not checked         stz   B_Offset         stz   MTabCnt	No tabs found yet         stz   LastChar         stz   HexFlag                 ; Set starting offset into file, if required (for -B, ignore here)         lda   ParmOFlg                 Offset specified?         beq   DoRead                   No, default to zero         lda   ParmAFlg                 '-A' or '-B' specified?         ora   ParmBFlg         bne   DoRead                   Offset not applicable here         lda   StrtByte         sta   Address                  Init displayed address, too         lda   StrtByte+2         sta   Address+2        _Set_Mark MarkParm              Set the file pointer         bcc   DoRead         cmp   #$4D                     Out-of-Range error?         beq   *+5         brl   ToolErr                  Unknown error         writeln #'Error: Requested start offset > end of file!'         brl   DoClose;.......................................;; READ some (more) dataDoRead   procname DoRead        _Read  ReadParm                 Attempt to READ some data         bcc   ReadOK         cmp   #$4C                     End-of-file?         beq   ReadOK                   Yes, see if we got ANY data         brl   ToolErr                  Unable to READ the fileReadOK   anop         lda   XferCnt                  READ zero bytes?         beq   DoClose                  Yes, we must be finished; Process the data as requested         ldy   #0                       Offset into data buffer         lda   HexFlag                  Hex/ASCII only? (Set by program)         bne   DoHex         lda   ParmXFlg                 'No hex'?         bne   DoX         lda   ParmAFlg                 'AppleWorks format'?         bne   DoA         lda   ParmBFlg                 'Applesoft BASIC format'?         bne   DoB         lda   ParmMFlg                 'Merlin Source format'?         bne   DoM; Test for '-T' *last* (may have turned into '-A' or '-B')!         lda   ParmCFlg                 'Chars only'?         ora   ParmTFlg                 'Honour <CR>'s in text'?         bne   DoCDoHex    anop                           Hex/ASCII display         jsr   Display                  Display data in hex AND char         bra   DoneDispDoX      anop                           No hex         jsr   DisplayX         bra   DoneDispDoC      anop                           No hex or control chars         jsr   DisplayC         bra   DoneDispDoA      anop                           AppleWorks format	jsr   DisplayA         bra   DoneDispDoB      anop                           Applesoft BASIC format         jsr   DisplayB         bra   DoneDispDoM      anop                           Merlin Source format         jsr   DisplayMDoneDisp anop         lda   XferCnt                  Get transfer count again         cmp   ReadReqL	Short READ?         bne   *+5         brl   DoRead                   No, READ some moreDoClose  procname DoClose         jsr   CloseFile                Close the file         lda   LastFlag                 Any data in last line?         beq   GoNextFile               No         jsr   LastMsg                  Write last line in the correct formatGoNextFile anop         longm                          Branch entry         lda   ExitFlag                 Sudden exit required?         cmp   #2                       Complete HALT? (ie. Option-.)         beq   Exit                     Yes         lda   ShellPgm                 Running under the Shell?         beq   GoPrmpt2                 No, prompt again         brl   NextFile                 Else look for another fileGoPrmpt2 brl   Prompt;.......................................;; Exit - Return to our caller; ====;Exit     procname Exit         lda   #0                       Return code of 0Exit2    anop         sta   ErrCode                  Save for exit         aif   .NOT.&Debug,.NoEStk         tsc                            Test stack integrity during debugging         clc         adc   #4                       4 bytes for SetInGlobals!         sec         sbc   SaveStck         beq   Exit3         jsl   ShowAcc         writeln #' bytes difference between entry/exit stack ptrs'         pushlong #0                    No echo        _ReadChar         plaExit3    anop.NoEStk         lda   ParmQFlg                 Quiet?         bne   Exit4                    Yes, suppress additions         ConsoleOut CursOn              Cursor back onExit4    anop        _SetInGlobals                   Parameters already on the stack        _IMShutDown         lda   ErrCode                  Load return code (if any)        _Quit QuitParm                  Return to our caller (Shell traps Quit);.......................................;; Display - Display the data in our full hex and ASCII mode; =======;; Address  - offset into file; XferCnt  - Maximum no. of bytes to display; Y-reg    - Offset into DataBuf; HexIndx  - Offset into hex part of line of a char; CharIndx - Offset into char part of line of a char;; NOTE: We rely on getting at least 16 chars on all but the last line;         longa onDisplay  procname Display         lda   Address                  Low order bytes         and   #$000F                   Low nibble         bne   *+5                      Not divisible by 16         jsr   NewLine                  Start the new line         inc   LastFlag                 Say we have some data in the line         shortm         ldx   CharIndx                 Get output offset         lda   DataBuf,Y                Get input byte         and   #$7F         cmp   #' '                     Control char?         blt   SkipIt1                  Yes, skip storing it         sta   LineChar,X               Store in stringSkipIt1  inx                            Increment offset         stx   CharIndx;; Convert to hex;         ldx   HexIndx                  Get offset into hex area         lda   DataBuf,Y                Get data byte again         pha         lsr   a                        Do first nibble         lsr   a         lsr   a         lsr   a                        Acc = $00 - $0F         clc         adc   #'0'                     Acc = $30 - $3F         cmp   #'9'+1                   In range '0' - '9'         blt   Skip01         clc         adc   #'A'-'9'-1               Range 'A' - 'F'Skip01   sta   LineHex,X         inx         pla                            Get saved char for second nibble         and   #$0F                     Acc = $00 - $0F         clc         adc   #'0'                     Acc = $30 - $3F         cmp   #'9'+1                   In range '0' - '9'         blt   Skip02         clc         adc   #'A'-'9'-1               Range 'A' - 'F'Skip02   sta   LineHex,X         inx         stx   HexIndx                  Save updated offset         longm; Do we need to insert a blank separator column?         tya                            Get offset         inc   a                        Make 0-3 into 1-4         and   #$0003                   Divisible by four, ie. 4th byte?         bne   SkipIt2                  No         inc   HexIndx                  Skip blank columnSkipIt2  anop; If we're at the end of the line (so to speak), print it         ldx   CharIndx         cpx   #$10                     Finished a line?         bne   SkipIt3         phy         writeln LineMsg                Write it out         ply         stz   LastFlag                 No data in the last line         jsl   Stop_Pause               Keypress or Apple-Period?         tax                            Save result, and set Z flag         beq   SkipIt3                  Neither Apple nor Option-Period pressed         sta   ExitFlag         pla                            Dump return address         brl   DoClose                  And exitSkipIt3  anop         inc4  Address                  Bump address; If we've finished the current buffer, return for more         iny                            Increment offset (by 1!) into DataBuf         cpy   XferCnt                  Done enough?         bge   *+5                      Finished - return for more         brl   Display                  Display next char         rts;.......................................;; Start a new line by clearing it and building the current address;NewLine  procname NewLine         ldx   #LineHex-LineMsg         lda   #'  'NewLLoop sta   LineMsg,X                Blank area in case line is short         inx         inx         cpx   #LineMsgL-1         blt   NewLLoop         lda   #'| '         sta   Sep2                     Replace overwritten separator; Only need to convert middle bytes - high and low ALWAYS zero!         phy         pushlong Address               Get 'address'         pushlong #AddrStr              Target address         pea   L:AddrStr                Length        _Long2Hex                       Convert to hexadecimal         ply         stz   HexIndx                  Zero output line offsets         stz   CharIndx         rts;.......................................;; DisplayX - Display the data without hex (ie. ASCII only); ========;; Address  - Offset into file; XferCnt  - Max. no. of bytes to display; Y-reg    - Offset into DataBuf; CharIndx - Offset into char part of line of a character;; NOTE: We rely on getting at least 64 chars on all but the last line;         longa onDisplayX procname DisplayX         lda   Address                  Get low order bytes         and   #$003F                   Low nibble         bne   *+5                      Not divisible by 64!         jsr   NewLineX                 Start the new line         inc   LastFlag                 We have data in the line         shortm         ldx   CharIndx                 Get offset         lda   DataBuf,Y                Get byte         and   #$7F         cmp   #' '                     Control char?         blt   SkipIt1X                 Yes, skip storing it         sta   LineX,X                  Store in stringSkipIt1X inx                            Increment offset         stx   CharIndx         longm; If we're at the end of the line (so to speak), print it         cpx   #L:LineX                 Finished a line?         bne   SkipIt3X         phy         writeln LineMsgX               Write it out         ply         stz   LastFlag                 No data in the line         jsl   Stop_Pause               Keypress or Apple-Period?         tax                            Save result, and set Z flag         beq   SkipIt3X                 Neither Apple nor Option-Period pressed         sta   ExitFlag         pla                            Dump return address         brl   DoClose                  ExitSkipIt3X anop         inc4  Address                  Bump address; If we've finished the current buffer, return for more         iny                            Increment offset (by 1!) into DataBuf         cpy   XferCnt                  Done enough?         bge   *+5                      Finished - return for more         brl   DisplayX                 Display the next char         rts;.......................................;; Start a new '-X' line by clearing it and building the current address;NewLineX procname NewLineX         ldx   #0                       Starting offset         lda   #'  'NewLX    sta   LineX,X                  Blank area in case line is short         inx         inx         cpx   #L:LineX                 Reached ending offset?         blt   NewLX; Only need to convert middle address bytes - high and low ALWAYS zero!         phy         pushlong Address               Get 'address'         pushlong #AddrStrX             Target address         pea   L:AddrStrX               Length        _Long2Hex                       Convert to hexadecimal         ply         stz   CharIndx         rts;.......................................;; DisplayC - Display the data without hex or spaces for control chars.; ========   If '-T' specified, honour <CR>'s & <Tab>s (tab stop every 5 cols);	    Also, honour standalone <LF>'s as <CR>'s (except after <CR>).;; XferCnt  - Maximum number of bytes to display; Y-reg    - Offset into DataBuf; CharIndx - Offset into char part of line of a char;         longa onDisplayC procname DisplayC         inc   LastFlag                 Say we have data in the line         shortm         lda   DataBuf,Y                Get a byte	ldx	ParmTTFlg	Handle high-ASCII?	beq	DispCNrm	No, handle normally	jsr	DispCHi	Yes (!May return via DoWriteC/SkipIt3C)DispCNrm	anop         and   #$7F	Strip high bit         cmp   #$20                     Control char?         bge   NotCtlCh                 No, add to the buffer         brl   CheckCtl                 Check for <CR> or <Tab> in -T mode; Store characterNotCtlCh anop	sta	LastChar	Remember this character	ldx   CharIndx                 Get offset         sta   LineC,X                  Store char         inx                            Bump offset         stx   CharIndx; If we're at the end of the line (so to speak), print it         cpx   #L:LineC                 Finished a line?         blt   SkipIt3CDoWriteC anop                           Needs m=1, X reg = CharIndx         txa                            Make 1 byte         sta   LineMsgC                 Store 'real' length         longm         phy         writestr LineMsgC              Write it (NOT writeln - auto wraps!)         plyDoneWrtC jsr   NewLineC                 Clear the line         jsl   Stop_Pause               Keypress or Apple-Period?         tax                            Set the Z flag         beq   SkipIt3C                 Neither Apple nor Option-Period pressed         sta   ExitFlag         pla                            Dump return address         brl   DoClose                  And exit; If we've finished the current buffer, return for moreSkipIt3C anop         longm                          In case we branched here         inc4  Address                  Bump address         iny                            Bump offset (1 only!) into DataBuf         cpy   XferCnt                  Enough?         bge   *+5                      Finished - return for more         brl   DisplayC                 Display next char         rts; Check for a Carriage Return or Tab, and honour it if -T specified         longa offCheckCtl anop         ldx   ParmTFlg                 -T specified?         bne	ChkCtl2	YesChkCtl1	sta	LastChar	Remember this character         bra   SkipIt3CChkCtl2	anop         cmp   #Tab                     <Tab>?         bne   NotTab	sta	LastChar	Remember this character	lda	LastTab	Get 'offset' of last tab 'stop'	dec	ATabLoop  cmp   CharIndx                 Are we <= current pos'n yet?         beq   FixTab         bcc   FixTab         sbc   TabWidth                 Try previous stop         bpl   TabLoop                  Unless negative; Tab stop at 0, 5, 10, 15, etc. means start at 1, 6, 11, 16, etc.FixTab   clc         adc   TabWidth                 Up to 'next' stop+1	cmp	LastTab	Past last stop?         bcc   StoreTab                 No         ldx   #L:LineC                 Limit to line length         brl   DoWriteC                 Write the lineStoreTab sta   CharIndx         brl   SkipIt3C                 Ignore the <Tab>NotTab   anop; Handle <CR> (and <LF> when treated as <CR>)         cmp   #CR                      Carriage Return char?         bne   NotCR	No, try for LFDoCR	anop	sta	LastChar	Remember this character         lda   CharIndx                 1 byte         sta   LineMsgC                 Store length         longm         phy         writeln LineMsgC               Write the line - with a <CR>         ply         brl   DoneWrtC                 Finish up normally; Handle <LF> (Treat as <CR> if not following a <CR>)         longa offNotCR	anop         cmp   #LF                      Line feed char?         bne   ChkCtl1	No, all done	lda	#CR         cmp   LastChar                 Previous char a Carriage Return char?	php		Remember status	lda	#LF	So we remember correct character	plp		Restore status after load         beq   ChkCtl1	Previous was <CR>, ignore this <LF>         bra   DoCR	Handle as though we got a CR                  ;.......................................;; Start a new -C line by blanking it.  Used by T, A, B and M options also.; (Also called from parameter checking!); NOTE: Routine requires 'm' flag = 0!;; ***** Must BLANK line buffer so that tabs, etc. behave properly! *****;         longa onNewLineC procname NewLineC         stz   CharIndx                 Zero the offset counter         stz   LastFlag                 No data in line         ldx   #0                       Starting offset         lda   #'  'NewLC    sta   LineC,X                  Blank area in case line is short         inx         inx         cpx   #L:LineC-1               Ending offset         blt   NewLC         rts;.......................................;; DisplayA - Display in text mode, and support AppleWorks WP files.; ========   Note: We use the 'C' type buffer, and NewLineC subroutine.;; XferCnt  - Max. number of bytes to display; Y-reg    - Offset into DataBuf; CharIndx - Offset into char part of line of a char;; AppleWorks file format summary :-;   First 300 bytes are ignorable header (includes tabs, Zoom, etc);   If SFMinVers (+183) > 0, then first 2 bytes will be $001E (=30 = v3.0);   Each line after starts with 2 bytes;     +0 = Optional data (eg. counts for formatting cmds; length of text record);     +1 = $D0 -> Carriage return (+0 = column for <CR>);        > $D0 -> Formatting commands (eg. New page, Center, etc);        = $00 -> Text lines;        = $FF -> End of file  (may be followed by 'tag data');   Text lines also have :-;     +2 = Indent for start of data (high bit set for <TAB> lines);     +3 = Length of remaining data (high bit set for explicit <CR>);     +4 = Data bytes. If < $20, special codes like underline, sticky-space);         longa onDisplayA procname DisplayA         lda   ALenFlag                 Checked file length yet?         bne   Display_A                Yes         inc   ALenFlag                 Set flag         stz   RulerFlg         stz   AW_Offset         stz   AW_Len         stz   MTxtFlag         stz   ULFlag         stz   BoldFlag         stz   InvFlag         ldy   #300                     Set starting offset into buffer	sty	Address	Initialise address variable         cpy   XferCnt                  Enough bytes? (Need > 300)         blt   Display_A                Yes, off we go         writeln #'Error: Invalid AWP file (length < 301 bytes)!'         rtsDisplay_A procname Display_A            Loop here for each byte hereafter         inc   LastFlag                 Say we have an output line         shortm         lda   DataBuf,Y                Get a byte         ldx   AW_Offset                Check offset into data line         cpx   #4                       Into text data? (Offset >= 4?)	blt	TryA0	No, check for byte at offset 0	bne	GoDoA4a	Yes, and we're past first byte of text;        X = 4 exactly; Check to see whether we need to restore inverse display after <CR>	pha		Save the byte	lda	InvFlag	Inverse display in effect?	beq	GoDoA4	No, do nothing	lda	ParmQFlg	Quiet mode?	bne	GoDoA4	Yes, do nothing	ldx	CharIndx	Get character index	lda	#Inv_On	Turn on inverse again	sta	LineC,X	inx	stx	CharIndx	Store index for DoTextAGoDoA4	anop	pla		Retrieve the byteGoDoA4a	anop         brl   DoTextA                  Yes, go process text byte; Check byte at offset 0 into recordTryA0    procname TryA0         cpx   #0                       Offset +0 = variable data         bne   TryA1	sta	AW_Byte0	Save in case neededGoSkip3A brl   SkipIt3A                 Ignore byte; Check byte at offset 1 into recordTryA1    procname TryA1         cpx   #1                       Offset +1 = Line type         bne   TryA2         cmp   #$00                     Text line?         beq   GoSkip3A                 Yes, skip ahead         cmp   #$FF                     End-of-file?         bne   TryA1_A         brl   AW_EOF                   Handle it - hopefully not prematureTryA1_A  anop;;;	jsr	ITextOff	Set Inverse text off (if on);;;	jsr	MTextOff	Set Mousetext off (if on)         cmp   #$D0                     <CR> line?         beq   DoCRA         cmp   #$E9                     New Page line?         beq   GoDoWrtA                 Yes, just skip a line         cmp   #$EE                     Skip Lines line?         beq   DoSkipL                  Yes, ditto; Handle unknowns, or initial two data bytes of a v3.0+ file (= version?)         ldx   #-1                      Start a new data line         stx   AW_Offset                Incremented to 0 later         brl   SkipIt3A                 Ignore byte; Handle <CR> line record (blank line, where <CR> may be in column > 1 )DoCRA	anop	ldx	AW_Byte0	Retrieve column offset for <CR>	stx	CharIndx	Set as character indexGoDoWrtA brl   DoWriteA	Go write line; Handle skip lines by inserting a bunch of <CR>'s into the recordDoSkipL	anop         phy		Preserve y-reg	ldy	AW_Byte0	Retrieve skip lines count	dey		(Because <CR> always added by DoWriteA)	ldx	CharIndx	Get character index	lda	ParmQFlg	Quiet mode?	bne	DoSkipL2	Yes, do nothing extra;;;	lda	#Inv_Off	Always turn inverse mode off for safety;;;      sta   LineC,X                  Blank up to <CR>;;;	inxDoSkipL2	anop	lda	#CRDoSkipLp	anop         dey         bmi   DoSkipOK	Go write line         sta   LineC,X                  Blank up to <CR>	inx	bra	DoSkipLpDoSkipOK	anop	stx	CharIndx	ply	brl   DoWriteA	Go write the line(s)             ; Check byte at offset 2 into recordTryA2    procname TryA2                 Offset +2 = Indent         cpx   #2                       Line indent?         bne   TryA3         sta   RulerFlg                 $FF = 'Ruler' line         cmp   #$FF                     'Ruler' line?         bne   *+3         inc   A                        Make it zero         and   #$7F                     Ignore '<TAB>s in line' bit         cmp   #80                      Reasonable value?         blt   *+4         lda   #79                      Partial increment         sta   CharIndx                 Store as indent (can only be at start!)         brl   SkipIt3A                 Ignore byte; Handle non-text byte at offset 3 into recordTryA3    procname TryA3                 Offset +3 = Data length         and   #$7F                     High bit maybe set (explicit <CR>)         sta   AW_Len                   Store length         brl   SkipIt3A                 Ignore byte; Resync if we find a corrupted text record (found embedded $00 in text data)ReSync	anop         lda   DataBuf+1,Y              Get next byte	cmp	#$D0	Carriage return or command line?	bge	ReSync2	Yes	dey		To byte +0	lda	CharIndx	Ignore byte placed in buffer previously	beq	ReSync2	Skip if at start of line	dec	CharIndxReSync2	anop		Resync on a <CR> or command record	dey	brl	DoWriteA	Write what we got previously; Handle actual text bytes (which may include 'specials' like bold, etc.)DoTextA  procname DoTextA         ldx   CharIndx                 Get offset         cmp   #$20                     Control char?         bge   SkipIt2A                 No, insert in buffer         cmp   #$00                     Corrupt record? (Start of next record)         beq   ReSync	Yes         cmp   #$01                     <Begin Bold>?         bne   NotBold1                 No	jsr	BoldOn	Set inverse mode	bra	SkipIt2BNotBold1 anop         cmp   #$02                     <End Bold>?         bne   NotBold2                 No	jsr	BoldOff	Clear inverse mode	bra	SkipIt2BNotBold2 anop         cmp   #$07                     <Begin UnderLine>?         bne   NotUL1	No	jsr	UL_On	Set inverse mode	bra	SkipIt2BNotUL1	anop         cmp   #$08                     <End UnderLine>?         bne   NotUL2	No	jsr	UL_Off	Clear inverse mode	bra	SkipIt2BNotUL2	anop         cmp   #$0B                     <Sticky-Space>?         beq   MakeSpcA                 Yes         cmp   #$16                     <TAB>? (Followed by <TAB-fillers>)         beq   MakeSpcA                 Yes         cmp   #$17                     <TAB-filler>?         beq   MakeSpcA                 Yes         bra   SkipIt4A                 No, ignore the restMakeSpcA anop         lda   #' '                     Make it a 'normal' spaceSkipIt2A anop	cmp	#$80	Mousetext possibility?	blt	NotMT1	No	and	#$7F	Strip high bit         cmp   #'@'	Valid Mousetext?         blt   IsItInv                  No         cmp   #'_'+1	Valid Mousetext?         bge   IsItInv                  No	jsr	ITextOff	Set Inverse text off (if on)	jsr	MTextOn	Set Mousetext	bra	IsMT2IsItInv	anop         cmp   #' '	Inverse capitals?         bcs   IsInv	No	adc	#'A'-1	Make capital letterIsInv	anop	jsr	MTextOff	Set Mousetext off (if on)	jsr	ITextOn	Set Inverse text	bra	IsMT2NotMT1   anop	jsr	ITextOff	Set Inverse text off (if on)	jsr	MTextOff	Set Mousetext off (if on)IsMT2	anop         sta   LineC,X                  Store char in string         inx                            Increment offsetSkipIt2B anop         stx   CharIndxSkipIt4A anop         longm         dec   AW_Len                   One less byte to do	bne   SkipIt3A	More to go still; If we're at the end of the line (so to speak), print it;;;; Bugs aside, an AppleWorks line can never be longer than 80 screen bytes!;;;; (The buffer length may be longer due to Mousetext or highlighting)DoWriteA procname DoWriteA	shortm         ldx   CharIndx                 Get offset	jsr	MTextOff	Always set Mousetext off (if on)	jsr	ITextOff	Always set Inverse text off (if on)	lda	InvFlag	Is inverse set (for bold/underline)?	bne	NoInvCR	Yes, turn inverse off for <CR>         lda	#CR	sta	LineC,X	Store <CR> at line end	inxDoWrtA2	anop	txa		Make 1 byte	sta	LineMsgC	Store length for this line         longm                          After branch entry         lda   RulerFlg                 'Ruler' line?         cmp   #$FF         beq   SkipWrtA                 Yes, don't print it         phy         writestr LineMsgC              Write it         plySkipWrtA anop         ldx   #-1                      Must be starting a new data line         stx   AW_Offset                Will increment to 0 at SkipIt3A         jsr   NewLineC                 Clear the output line; Handle early exit         jsl   Stop_Pause               Look for keypress or Apple-Period         tax                            Set the Z flag (ignore X reg)         beq   SkipIt3A                 Neither Apple nor Option-Period pressed         sta   ExitFlag	pla                            Dump return address	lda	InvFlag	Any form of highlighting?	beq	GoDoClsA	No	ldx	#0	jsr	BoldOff	Always set Bold off (if on)	jsr	UL_Off	Always set Underline off (if on)	jsr	MTextOff	Always set Mousetext off (if on)	jsr	ITextOff	Always set Inverse text off (if on)         inc   LastFlag                 Say we have an output line         stx   CharIndx                 Save offsetGoDoClsA brl   DoClose; If we've finished current buffer, return for moreSkipIt3A anop         longm                          In case we branched here         inc4  Address                  Bump address         inc   AW_Offset                Bump data line offset         iny                            Increment offset (by 1!) into DataBuf         cpy   XferCnt                  Have we done enough bytes?         bge   *+5                      Finished - return to get more data         brl   Display_A                Display the next charRTS_A    rts;.......................................;; Turn off inverse mode while we print a <CR>.; On entry, we *know* that inverse mode is currently active;; Normally this is not a problem, unless we are on line 24, where the <CR>; causes the entire new line to become inversed!;         longa offNoInvCR	procname NoInvCR	lda	ParmQFlg	Quiet mode?	bne	NoInvCRX	Yes, do nothing	lda	#Inv_Off	Turn off inverse	sta	LineC,X	inx	lda	#CR	Add the <CR>	sta	LineC,X	inxNoInvCRX	anop	bra	DoWrtA2;.......................................;; Handle finding the EOF flag in the text stream;; If 'tag data' is present, revert to 'hex dump' mode after a message; Nb: By definition, the last data line has already been printed;AW_EOF   procname AW_EOF         longm                          Reset 16 bit mode	lda	ParmQFlg	Quiet mode?	bne	HiLiteOK	Yes, do nothing	phy	writestr NormalMsg	Reset Mousetext/inverse, just in case         ply         stz   InvFlag	Ensure flag is valid         stz   MTxtFlag	Ensure flag is valid         stz   ItxtFlag	Ensure flag is validHiLiteOK	anop	tyx         inx         cpx   XferCnt                  Would we have stopped ourselves?         bge   SkipIt3A                 Exit normally; Handle 'tag data' by reverting to hex dump mode after a message	lda	ParmQFlg	Quiet mode?	bne	RTS_A	Yes, ignore tag data	phy	writeln TagMsg	ply	iny		Skip past $FF         inc4  Address                  Bump address	jsr	NewLine	Setup initial line	inc	HexFlag	Say we want hex/ASCII now; Init the 'CharIndx' value (easy)	lda	Address	Get low order bytes	and	#$000F	Get low nibble	sta	CharIndx	Set CharIndx; Init the 'HexIndx' value (a bit harder)	stz	Work	cmp	#12	blt	TagSkip1         inc   Work	Skip blank columnTagSkip1	cmp	#8	blt	TagSkip2         inc   Work	Skip blank columnTagSkip2	cmp	#4	blt	TagSkip3         inc   Work	Skip blank columnTagSkip3	anop                           	asl	A	Two hex digits for every char	adc	Work	Add in blank cols (Nb: CLC set by ASL)	sta	HexIndx	Set HexIndx         brl   Display	Display data in hex and ASCIINormalMsg dc	i1'2,14,18'	Inverse off, Mousetext off, no <CR>TagMsg   dc	i1'TagMsgL,13,15'	Inverse message, within blank lines	dc	c' Tag data found following normal end of AWP file ',i1'14'TagMsgL	equ	*-TagMsg-1;.......................................;; Turn mousetext mode on;         longa offMTextOn	procname MTextOn	pha	lda	MTxtFlag	In a Mousetext string?	bne	MTextOnX	Yes, do nothing	lda	ParmQFlg	Quiet mode?	bne	MTextOnX	Yes, do nothing	lda	#MT_On	Turn on Moustetext	sta	LineC,X	inx	jsr	InvOn	Turn inverse on to activate Mousetext         inc   MTxtFlag	Set the flagMTextOnX anop	pla         rts;.......................................;; Turn mousetext mode off;MTextOff	procname MTextOff	pha	lda	MTxtFlag	In a Mousetext string?	beq	MTOffX	No, do nothing	lda	ParmQFlg	Quiet mode?	bne	MTOffX	Yes, do nothing	jsr	InvOff	Inverse off to deactivate Mousetext	lda	#MT_Off	Turn off Moustetext	sta	LineC,X	inx         stz   MTxtFlag	Clear the flagMTOffX   anop	pla         rts;.......................................;; Turn 'inverse text' on;         longa offITextOn	procname ITextOn	pha	lda	ITxtFlag	Flag already set?	bne	ITextOnX	Yes, do nothing	lda	ParmQFlg	Quiet mode?	bne	ITextOnX	Yes, do nothing	jsr	InvOn	Turn on inverse         inc   ITxtFlag	Set the flagITextOnX	anop	pla	rts;.......................................;; Turn 'inverse text' off;ITextOff	procname ITextOff	pha	lda	ITxtFlag	Flag already clear?	beq	ITOffX	Yes, do nothing	lda	ParmQFlg	Quiet mode?	bne	ITOffX	Yes, do nothing	jsr	InvOff	Turn off inverse         stz   ITxtFlag	Clear the flagITOffX	anop	pla	rts;.......................................;; Turn 'bold' on;         longa offBoldOn	procname BoldOn	lda	BoldFlag	Flag already set?	bne	BoldOnX	Yes, do nothing	lda	ParmQFlg	Quiet mode?	bne	BoldOnX	Yes, do nothing	jsr	InvOn	Turn on inverse         inc   BoldFlag	Set the flagBoldOnX	anop	rts;.......................................;; Turn 'bold' off;BoldOff	procname BoldOff	lda	BoldFlag	Flag already clear?	beq	BoldOffX	Yes, do nothing	lda	ParmQFlg	Quiet mode?	bne	BoldOffX	Yes, do nothing	jsr	InvOff	Turn off inverse         stz   BoldFlag	Clear the flagBoldOffX	anop	rts;.......................................;; Turn 'underline' on;         longa offUL_On	procname UL_On	lda	ULFlag	Flag already set?	bne	UL_OnX	Yes, do nothing	lda	ParmQFlg	Quiet mode?	bne	UL_OnX	Yes, do nothing	jsr	InvOn	Turn on inverse         inc   ULFlag	Set the flagUL_OnX	anop	rts                 ;.......................................;; Turn 'underline' off;UL_Off	procname UL_Off	lda	ULFlag	Flag already clear?	beq	UL_OffX	Yes, do nothing	lda	ParmQFlg	Quiet mode?	bne	UL_OffX	Yes, do nothing	jsr	InvOff	Turn off inverse         stz   ULFlag	Clear the flagUL_OffX	anop	rts;.......................................;; Make text display in inverse;         longa offInvOn	procname InvOn	lda	InvFlag	Already displaying in inverse?	bne	InvOnX	Yes, still increment the counter	lda	#Inv_On	Turn on inverse display	sta	LineC,X	inxInvOnX	anop                      inc   InvFlag	Increment the counter	rts;.......................................;; Make text display in normal;InvOff	procname InvOff	lda	InvFlag	Already displaying in inverse?	beq	InvOffX	No, and *don't* decrement the counter!         dec   InvFlag	Decrement the counter	bne	InvOffX	Not zero, inverse display still needed	lda	#Inv_Off	Turn off inverse display	sta	LineC,X	inxInvOffX	anop	rts;.......................................;; DisplayB - Display in text mode, and support Applesoft BASIC.; ========   Nb: We use the C type buffers, and NewLineC subroutine.;            Nb: Although LineC is 80 chars, we only use 79 so we can WRITELN.;            Nb: If -O specified, StrtByte contains a starting LINE NUMBER!;            Nb: Control characters (eg. in strings, REMs) are made printable.;; XferCnt  - Max no. of bytes to display; Y-reg    - Offset into DataBuf (BASIC progs may finish before 'true' EOF); CharIndx - Offset into 'char' part of line of a character;; Applesoft BASIC file format summary :-;   Each line as follows :-;     +0-1 = 2 bytes of link info ($0000 = end of program);     +2-3 = 2 bytes of line no.;     +4-n < $80 -> Text info;          > $7F -> Tokens (to be expanded into keywords);     +n   = $00 -> End of line flag;         longa onDisplayB procname DisplayB         inc   LastFlag                 Say we have data in the output line         shortm         lda   DataBuf,Y                Get a byte         ldx   B_Offset                 Check offset into data line         bmi   BLineSkp                 Continue skipping lines (= -1)         cpx   #4                       Reached text data?         bge   DoTextB                  Yes, go process it; Offset 0 - Link pointer low byte         cpx   #0                       Offset 0 = link pointer low byte         bne   TryB1GoSkip3B brl   SkipIt3B                 Ignore offset 0 byte; Offset 1 - Link pointer high byte (If zero, we've finished)TryB1    anop         cpx   #1                       Offset 1  = Link pointer high byte         bne   TryB2         cmp   #$00                     End-of-file?         beq   *+5         brl   SkipIt3B                 No, ignore the byte         brl   B_EOF                    Handle EOF - will often be 'premature'; Offset 2 - Line no. low byteTryB2    anop                           Offset 2 = Line number low byte         cpx   #2                       Line indent?         bne   TryB3         sta   B_LineNo                 Store as Line no. low byte         brl   SkipIt3B                 Ignore the byte; Offset 3 - Line no. high byte. Print the line no. (if reached 'start')TryB3    anop         sta   B_LineNo+1               Store as Line no. high byte         lda   ParmOFlg                 'Offset' specified?         beq   DoLineNo         longm         lda   B_LineNo                 Reached starting point yet?         cmp   StrtByte         bge   DoLineNo                 Yes         ldx   #-1                      Say we will start a new data line         stx   B_Offset                 Will increment to 0 at SkipIt3B         shortm         inyBLineSkp lda   DataBuf,Y                Find zero (EOL)         beq   BLineEnd         iny         cpy   XferCnt                  Have we done enough bytes?         blt   BLineSkp                 No         brl   SkipIt3B                 Finished - Return to get more dataBLineEnd anop         longm         brl   DoneWrtB                 Pretend we just wrote the line; Insert the line numberDoLineNo phy         longm         pushword B_LineNo              Number to convert         pushlong #LineC                Target address         pea   5                        Length = 5         pea   0                        Unsigned        _Int2Dec                        Convert to string         shortm         ply         ldx   #6                       First data location offset	stx   CharIndx         lda   #0                       Dummy last char         sta   LastChar         stz   B_Quoted                 Initialise 'quoted string' flag         brl   SkipIt3B;.......................................;; Offset 4 to 'end-of-line' (or 'end-of-file'); Handle actual text bytes (which may include Applesoft tokens >= $80);DoTextB  anop         cmp   #$00                     Check byte type         bmi   Token                    >= $80 is a token         beq   *+5                       = $00 is end of line         brl   NormChar                 <= $7F is a 'normal' char         ldx   #-1                      Say we will start a new data line         stx   B_Offset                 Will increment to zero at SkipIt3B         brl   DoWriteB                 Write the line now;.......................................;; Expand Applesoft tokens;Token    procname Token         phy                            Save Y reg (data buffer index)         ldx   CharIndx                 Get offset into output line; Insert a space only before non-operator (+, -, etc) tokens (also '('); and if the previous char was not a space also.; Check previous char (in Y reg) - Nb: A character, not a token!         shortx                         Short **index** registers, too         ldy   LastChar                 Look at the last char         cpy   #' '+1                   Already have a blank or null separator?         blt   NoPreSpc                 Yes - don't insert another         cpy   #'('                     Previous char a '('?         beq   NoPreSpc                 Yes         cpy   #'*'                     Operator char?         beq   NoPreSpc                 Yes         cpy   #'+'         beq   NoPreSpc         cpy   #'-'         beq   NoPreSpc         cpy   #'/'         beq   NoPreSpc         cpy   #'^'         beq   NoPreSpc         cpy   #'<'         beq   NoPreSpc         cpy   #'='         beq   NoPreSpc         cpy   #'>'         beq   NoPreSpc; Check current token (in A reg)         cmp   #'('                     Left bracket?         beq   NoPreSpc                 Yes         cmp   #200                     Operator token?         blt   PreSpace                 No         cmp   #210                     Operator token?         bge   PreSpace                 No         cmp   #205                     Operator token? ('AND' is special)         beq   PreSpace                 No         cmp   #206                     Operator token? ('OR' is special)         beq   PreSpace                 No         bra   NoPreSpc                 Don't insert the spacePreSpace anop         inx                            Leave a blank         stx   CharIndxNoPreSpc anop         long                           m *AND* x flags!         and   #$007F                   Chop Acc high-byte, low-byte high-bit         asl   A                        Double for index         tay         lda   B_OffTab,Y               Get offset to keyword         tay                            Make into index         shortm; Check if there's enough room for the token, else start a new line first.         lda   TokenTab,Y               Get token string length         sta   KeyWdLen                 Save for copy routine         clc         adc   CharIndx                 Add to index         cmp   #L:LineC-1               Enough room left?         blt   CpyKeyWd                 Yes, copy the keyword; End this line here and now, and print it out	ldx	#0	New line start column (Quiet mode)	phx         ldx   CharIndx                 Get offset	lda	ParmQFlg	In 'Q'uiet mode	bne	SkipCRB1	Yes, allow line to remain contiguous         lda	#CR	sta	LineC,X	Store <CR> at line end	inx		Allow for <CR>	lda	#6	Normal new line start column	sta	1,S	Overwrite saved value (Nb: m=1 x=0!)SkipCRB1	anop	txa		Make 1 byte	sta	LineMsgC	Store length for this line         longm	phy         writestr LineMsgC	Write it         ply         longm	stz   LastFlag                 No data in the line         jsr   NewLineC                 Clear the output line         plx		Start under data section of prev. line         stx   CharIndx         lda   #':'                     Pretend ':' was previous character         sta   LastChar                 Save it for later                  ; Handle an early exit request         jsl   Stop_Pause               Look for keypress or Apple-Period         tax                            Set the Z flag (ignore X reg)         beq   CpyKeyWd                 Neither Apple nor Option-Period pressed         sta   ExitFlag         ply                            Restore data buffer pointer         brl   GoCloseB                 Finish up; Copy the token acrossCpyKeyWd anop         shortm         ldx   CharIndx         iny                            Offset to first keyword charKeyLoop  lda   TokenTab,Y               Get keyword (token) char         sta   LineC,X                  Store in output line         inx                            Bump output offset         iny                            Bump keyword offset         dec   KeyWdLen         bne   KeyLoop                  Next char         sta   LastChar                 Save 'true' last char         stx   CharIndx                 Updated index         ply                            Restore buffer index         brl   SkipIt3B;.......................................;; Handle most other characters - simply echo as is, except for control-chars; which are made printable by converting to uppercase letters (not LF, CR); After a ':' insert a blank in the buffer first (unless second in a row).; After a ' ' write a ':' over the previous blank.; After a <CR> char, even (usually!) in a string, add a <LF>.;NormChar anop         ldx   CharIndx                 Get offset         pha                            Save the current character         lda   B_Quoted                 Inside a quoted string?         bne   NoColon2                 Yes, don't check for a colon; Handle a colon by adding a space this pass         lda   LastChar                 Get previous character         cmp   #':'                     Colon (ie. statement separator)?         bne   NoColon1                 No, go insert the character         inx                            Leave a space         stx   CharIndx         cpx   #L:LineC-1               Finished a line?         blt   NoColon1                 No, simply continue         dey                            Else do same character on the next pass         pla                            Fix stack         brl   DoWriteB                 Write out the line; If previous char was ' ' or ':', and CURRENT is ':', then step back over spaceNoColon1 anop         cmp   #':'                     Was previous a colon?         beq   SupSpace                 Yes, treat like a previous space         cmp   #' '                     Was previous a space?         bne   NoColon2                 No, leave things aloneSupSpace pla                            Retrieve current character         pha         cmp   #':'                     Colon         bne   NoColon2                 No, leave things alone         dec   CharIndx                 Step back over space         ldx   CharIndxNoColon2 anop         pla                            Restore character; If the character is a <CR>, then end this line now by printing it         cmp   #' '                     Is it a control character?         bge   NotCtl                   No, continue on         cmp   #CR                      Is it a <CR> character?         bne   NoCR                     No, continue on; Perform some ugly code so we can test memory while preserving registers	stx	Work	Preserve 'X' reg	ldx	ParmQFlg	In 'Q'uiet mode	php		Preserve 'S' reg	ldx	Work	Restore 'X' reg	plp		Restore 'S' reg	bne	NoCR	Yes - treat as normal control char	sta	LineC,X	Store <CR> at line end	inx		Allow for <CR>	txa		Make 1 byte	sta	LineMsgC	Store real line length         longm         phy         writestr LineMsgC	Write it         ply         stz   LastFlag                 No data in the line         jsr   NewLineC                 Clear the output line         shortm         stz   CharIndx                 Start at the left margin here         lda   #' '                     Pretend ' ' was previous character         sta   LastChar                 Save it for later         brl   ChkStopB                 Look for Apple-Period; If it is any other control char (except <LF>), convert to an uppercase letterNoCR     anop         cmp   #LF                      Is it an <LF> character?         beq   NotCtl                   Yes, let it be for better formatting	clc	adc	#'A'-1	Make into an upper case letterNotCtl   anop; Insert the character into the buffer         sta   LineC,X                  Store character in string         sta   LastChar                 Save for next time through; If the character is a quote, toggle the quoted string flag         cmp   #'"'                     Quote character?         bne   NoQuote         lda   B_Quoted                 Get 'quoted string' flag         eor   #1                       Toggle the flag         sta   B_Quoted                 Set itNoQuote  anop         inx                            Increment offset         stx   CharIndx;.......................................;; If we're at the end of the line (so to speak), print it; (In Quiet mode, only print <CR> at "real" end of line);         cpx   #L:LineC-1               Finished a line?         blt   SkipIt3BDoWriteB anop	shortm         ldx   CharIndx                 Get offset	lda	ParmQFlg	In 'Q'uiet mode	beq	WrtCRB	No, always write <CR>	lda	B_Offset	End of (BASIC) Line? (Offset = -1?)	cmp	#-1	bne	SkipCRB	No, allow line to remain contiguousWrtCRB	anop         lda	#CR	sta	LineC,X	Store <CR> at line end	inx		Allow for <CR>SkipCRB	anop	txa		Make 1 byte	sta	LineMsgC	Store length for this line         longm	phy         writestr LineMsgC	Write it         plyDoneWrtB stz   LastFlag                 No data in the line         jsr   NewLineC                 Clear the output line; Default indentation - a 'real' new line overrides this value         ldx   #5                       Start under data section of prev. line         lda   B_Quoted                 In a quoted string?         beq   *+3                      No         inx                            Won't auto align with colon	lda	ParmQFlg	In 'Q'uiet mode         beq   stChrIdx                 No	ldx	#0	Suppress indenting in quiet modestChrIdx stx   CharIndx         lda   #':'                     Pretend ':' was previous character         sta   LastChar                 Save it for later; Handle early exitChkStopB anop         jsl   Stop_Pause               Look for keypress or Apple-Period         tax                            Set the Z flag (ignore X reg)         beq   SkipIt3B                 Neither Apple nor Option-Period pressed         sta   ExitFlag                 Save for laterGoCloseB pla                            Dump return address         brl   DoClose; If we've finished the current buffer, return for moreSkipIt3B anop         longm                          In case we branched here         inc4  Address                  Bump address         inc   B_Offset                 Bump line offset         iny                            Increment offset (by 1!) into DataBuf         cpy   XferCnt                  Have we done enough bytes?         bge   *+5                      Finished - Return to get more data         brl   DisplayB                 Display the next character         rts;.......................................;; Handle finding the EOF flag in the text stream;B_EOF    anop         longm                          Reset 16 bit mode         tyx         inx         cpx   XferCnt                  Would we have stopped ourselves?         bge   SkipIt3B                 Exit normally         brl   GoCloseB                 Exit abnormally;.......................................;; DisplayM - Display the data formatted as Merlin source data; ========   Low-ASCII <space> = <space>; High-ASCII <space> = <tab>;	    All other chars have high bit set. Ignore control chars.;; XferCnt  - Maximum number of bytes to display; Y-reg    - Offset into DataBuf; CharIndx - Offset into char part of line of a char; MTabCnt  - Count of tabs on a given line;         longa onDisplayM procname DisplayM         inc   LastFlag                 Say we have data in the line         shortm         lda   DataBuf,Y                Get a byte	cmp	#$20	Low-ASCII space?	beq	MNormChr	Yes, it's a real space         and   #$7F	Strip high bit         cmp   #$20                     Control char or <space> (ie. <tab>)?	beq	GoMTab	<space>, it's a <tab>!         bge   MNormChr                 No, add to the buffer	brl   MChkCtl                  Check for <CR>GoMTab	brl   MTab	Handle <tab>MNormChr anop	ldx   CharIndx                 Get offset         sta   LineC,X                  Store char         inx                            Bump offset         stx   CharIndx; If we're at the end of the line (so to speak), print it         cpx   #L:LineC                 Finished a line?         blt   SkipIt3MDoWriteM anop                           Needs m=1, X reg = CharIndx         txa                            Make 1 byte         sta   LineMsgC                 Store 'real' length         longm         phy         writestr LineMsgC              Write it (NOT writeln - auto wraps!)         plyDoneWrtM jsr   NewLineC                 Clear the line         jsl   Stop_Pause               Keypress or Apple-Period?         tax                            Set the Z flag         beq   SkipIt3M                 Neither Apple nor Option-Period pressed         sta   ExitFlag         pla                            Dump return address         brl   DoClose                  And exit; If we've finished the current buffer, return for moreSkipIt3M anop         longm                          In case we branched here         inc4  Address                  Bump address         iny                            Bump offset (1 only!) into DataBuf         cpy   XferCnt                  Enough?         bge   *+5                      Finished - return for more         brl   DisplayM                 Display next char         rts; Check for a Carriage Return, else ignore other control chars         longa offMChkCtl	anop         cmp   #CR	<CR>?         bne   SkipIt3M         lda   CharIndx                 1 byte         sta   LineMsgC                 Store length         longm         phy         writeln LineMsgC               Write the line         ply         stz   MTabCnt	Reset tab count         brl   DoneWrtM                 Finish up normally; Handle Merlin Tabs (at 10, 16, 36, 44)                 longa offMTab	anop	ldx	MTabCnt	Get tab count	inc	MTabCnt	Increment tab count	cpx	#MTabTLen	Too many tabs?	bge	MTabSpc	Yes, just treat as a space	lda	MTabs,X	Get this tab stop         cmp   CharIndx	Tab stop >= current position?	beq	MTabSpc	No, treat as a space	blt	MTabSpc	No, treat as a space	sta   CharIndx	Move pointer to tab stop         brl   SkipIt3M                 Ignore the 'tab' char; Treat this tab as a space because we have already missed the tab stopMTabSpc	anop	lda	#' '	Pretend it's a <space>	brl	MNormChr; Tab stop at 9, 15, 35, 43, etc. means store at 10, 16, 36, 44, etc.MTabs	dc	i1'9,15,35,43,51,59,67,75'MTabTLen	equ	*-MTabs	Length of table = # of tabs stops;.......................................;; CloseFile - Close the open file; =========;         longa onCloseFile procname CloseFile         lda   OpenFlag                 Is the file open?         beq   ClosExit                 No        _Close OpenParm         stz   OpenFlag                 Reset 'File opened' flagClosExit rts;.......................................;; LastMsg - Write out the appropriate last line; =======;LastMsg  procname LastMsg         stz   LastFlag                 Now no data in the line         lda   HeXFlag                  Internal hex/ASCII specified?         bne   DoHex2                   Yes, do it that way         lda   ParmXFlg                 '-X' specified?         bne   DoX2                     Yes, do it that way         lda   ParmBFlg                 '-B', '-A' specified?         ora   ParmAFlg         bne   DoB2                     Yes, do it that way         lda   ParmCFlg                 '-C','-T' specified?         ora   ParmTFlg         bne   DoC2                     Yes, do it '-C' wayDoHex2   writeln LineMsg         rtsDoX2     writeln LineMsgX               '-X' format         rts; '-A' and '-B' should never get here unless the file was corrupted!DoB2     anop		Use 'writeln' for '-A', '-B'         lda   CharIndx         xba                            Put length in correct byte         sta   LineMsgC-1               Store 'real' length (1 byte)         writeln LineMsgC               '-C' format line (-B max = 79 chars)         jsr   NewLineC                 In case we are in wildcard mode         rts; Don't force final <CR> if original file didn't have one!DoC2     anop		Use 'writestr' only         lda   CharIndx         xba                            Put length in correct byte         sta   LineMsgC-1               Store 'real' length (1 byte)         writestr LineMsgC              '-C' format (80 cols - will wrap)         jsr   NewLineC                 In case we are in wildcard mode         rts;.......................................;; GetToken - Look for the next command line token, if any.; ========   Maximum token length is normally 64 characters.;; On entry, Y = offset into command line pointed to by [ParmPtr];           m = 1 (8 bit accumulator mode); On exit,  ParmBuf contains the parameter;           ParmLen contains the length;           Y = offset of last token char + 1;           Exit via RTS; On error, GOTO ParmErr;;; GetOffset - Extract and convert the operand of the -O parameter.; =========   'JSR';; On entry, Y = offset into command line;           m = 1 (8 bit accumulator mode); On exit,  StrtByte contains a 4-byte offset into the file;           Y = offset of last char + 1 of offset value;           Exit via RTS; On error, GOTO ParmErr2;;; GetTabWid - Extract and convert the operand of the -I parameter.; =========   'JSR' entry;; On entry, Y = offset into command line;           m = 1 (8 bit accumulator mode); On exit,  TabWidth contains a 2-byte default tab width;           Y = offset of last char + 1 of tab width value;           Exit via RTS; On error, GOTO ParmErr3;;; DispCHi - Convert a high-ASCII character to a string of one or more chars; =======   'JSR' entry;; On entry, Y = offset into command line;           m = 1 (8 bit accumulator mode); On exit,  LineC will be updated;           Y = offset of last char + 1 of offset value;           Exit via RTS if char is not high ASCII;           Exit via labels DoWriteC or SkipIt3C if char is high ASCII; No error exit;;; ParmErr - Print error messages for invalid parameters; =======   'JSR';;; ShowAcc - Display A-reg contents on the screen in hex; =======   'JSL' entry;           On entry, Acc = Value to be displayed with leading '$';           On exit,  5 chars written to standard output;; STOP_PAUSE - Handle key press pause and resume, and CANCEL; ==========;  *** Special version for DUMP recognises '?' and JSL's to label ShowInfo;		Returns 1 for Open-Apple-Period;		        2 for Option-Period;.......................................;; The GetToken, GetOffset, ParmErr and STOP_PAUSE routines are 'COPY'ed here.         copy  DUMP.2;.......................................;; ToolErr - Print an error message after a tool error, then restart; =======   at 'Prompt'. Use the Shell's utility routine, if possible.;;           On entry, Acc = Error code;ToolErr  procname ToolErr         sta   ErrCode         cmp   #$0027                   I/O error?         bne   *+5         brl   ToolErr4                 Yes         cmp   #$0001                   Bad OS call? (ie. GS/OS not present)         bne   *+5         brl   ToolErr5                 Yes         cmp   #$0063                   No resource?         bne   *+5         brl   ToolErr6                 Yes         ldx   ShellPgm                 Under Shell?         beq   ToolErr2                 No, can't use ERROR         cmp   #$0044                   Path not found?         bne   *+5         brl   ToolErr3                 Yes (Use my msg, I don't like ORCA's!)        _Error ErrCode         brl   ChkClose                 Need to close the file?; Oh well, we have to do it ourselvesToolErr2 anop         jsr   ChkError                 'Can't find file' type error?         bcc   *+5         brl   ToolErr3                 Yes         pha                            Error code         pushlong #ErrorStr             Target address         pea   L:ErrorStr               Length of string        _Int2Hex                        Convert to hexadecimal         writeln ErrorMsg         brl   ChkClose                 Do we need to close the file?ToolErr3 writestr #'Unable to find '         brl   ToolErrPToolErr4	writeln	writestr #'I/O error on '         brl   ToolErrPToolErr5 writeln #'-R option requires GS/OS to dump resource data'         brl   ChkCloseToolErr6 writestr #'No resource data in file '                                      ToolErrP anop         lda	ShowBuf	Get length	and	#$00FF	One byte only	beq	NoName	Fake a 'name' if no name available	writeln ShowBuf	Print the pathnameChkClose anop         jsr   CloseFile                Close any open file         lda   ErrCode	cmp	#$0027	I/O error?	beq	ContIO	Yes, special extra handlinggoPrompt	brl   Prompt                   Go prompt againNoName	anop	writeln #'file'	Generic 'filename'!	bra	ChkCloseContIO	anop	jsl	SHOWINFO	Display the file offset (like Apple-?)	lda	Parm1Flg	Ignore I/O errors if '-1' mode?	beq	goPrompt	No, go prompt again	brl	DoRead	Simply read next block instead;.......................................;; ChkError - Test for GS/OS errors which we can treat as 'bad pathname'; ========;            On entry, Acc = Error code;            On exit,  Carry set if 'recognised error', else Carry clear;ChkError procname ChkError         cmp   #$10                     Device not found         blt   ChkErr2                  Error too small!         beq   ChkErrX         cmp   #$11                     Invalid device request         beq   ChkErrX         cmp   #$28                     No device connected         beq   ChkErrX         cmp   #$2F                     Device not online         beq   ChkErrX         cmp   #$40                     Syntax error?         beq   ChkErrX         cmp   #$44                     Path/Volume/File error?         blt   ChkErr2                  No, too small         cmp   #$47         blt   ChkErrX                  Yes ($44, $45, $46)         cmp   #$4E                     Access not allowed?         beq   ChkErrXChkErr2  clc                            Must be some other error         rtsChkErrX  sec                            Default 'bad path' error         rts;.......................................;; Data areas; ==========;IdString dc    c'BYTEWRKS'              Shell id stringUserId   ds    2                        Memory Manager UserId (passed by caller); Flags - 0 = Parm not specifiedParmXFlg ds    2ParmCFlg ds    2ParmTTFlg ds	2ParmTFlg ds    2ParmAFlg ds    2ParmBFlg ds    2ParmOFlg ds    2ParmQFlg ds    2ParmRFlg ds    2Parm1Flg ds    2ParmMFlg ds    2PathFlag ds    2                        0 = No pathname (ie. must prompt)ShellPgm ds    2                        0 = Not running under the ShellOpenFlag ds    2                        0 = File not OPEN'ed yetLastFlag ds    2                        0 = No chars to be printedExitFlag ds    2                        1 = Open-Apple-Period, 2 = Option-PeriodFixFlag  ds    2                        1 = A or B flag set by program, not userALenFlag ds    2                        0 = A/Works file length not checkedRulerFlg ds    2                        0 = Line is not an AW 'ruler'; Variables moved to direct page;AW_Offset ds   2                       A/Works - Offset into data line;AW_Len   ds    2                       A/Works - Line length;AW_Byte0 ds    2                       A/Works - First byte in a line record;B_Offset ds    2                       BASIC - Offset into line;B_LineNo ds    2                       BASIC - Line number acc.;B_Quoted ds    2                       BASIC - 'In quoted string' flagFileCnt  ds    2                        Files found counter (Wildcards)TabWidth	ds	2	Tab stop widthLastTab	ds	2	Last tab stop columnSaveStck ds    2                        Stack save on entry for debuggingParmLen  ds    1                        Parm token lengthParmBuf  ds    &MaxBuf                  Parm token buffer (MUST follow Len)HelloMsg str   '&SYSNAME v&VER - Copyright Peter Watson, 1989-1995'Eyeball  str   '&SYSNAME v&VER - &SYSDATE &SYSTIME'CursOff  dc    i'6'                     Cursor offCursOn   dc    i'5'                     Cursor on; The pathname buffer used as PString, GString and GS result string!PathO_GS dc	i2'&MaxBuf+4'	ResultBufGS Buffer sizePathGSOS dc    i1'0'                    Used to build Class 1 string (must be 0)PathBuf  dc    i1'0'                    Pathname bufferPathName ds    &MaxBufShowBuf  dc    i1'0'                    Pathname buffer for display onlyShowPath ds    &MaxBufWildParm dc	i'2'	For InitWildcardGS	dp    PathGSOS                 Pathname ptr         dp    0                        '?' wildcard OK; multiple choicesNextParm dc	i'1'	For NextWildcardGS         dp    PathO_GS                 Pathname ptrInfoParm dp    PathBuf                  Pathname ptrInfAccess ds	2                        Access bitsFileType ds    2                        File type         ds    18                       Remaining dataOpenParm anop                           ProDOS 16 Class 0 OpenRefNum   ds    2                        Refnum (Used by CLOSE)         dp    PathBuf                  Pathname ptr         dp    0                        I/O buffer (must be 0)OpenPrmGS dc   i2'4'                    Class 1 open with 4 parametersRefNumGS ds    2                        Refnum (copied to RefNum)         dp    PathGSOS                 Pathname ptr         dc    i2'$0001'                GS/OS Access required (1 = Read)         dc    i2'$0001'                GS/OS Resource No. (1 = Resource fork)EOFParm	ds    2                        RefNumEOF	dc    i4'0'                    File EOFMarkParm ds    2                        RefNumStrtByte dc    i4'0'                    Offset into file (For -B, = line no.)ReadParm ds    2                        Refnum         dp    DataBuf                  Data buffer ptrReadReqL ds    4	Request count ( <= 65535)XferCnt  ds    4                        Transfer countQuitParm dp    0         dc    i'0'Address  ds    4                        Offset of current line of dataLineMsg  dc    i1'LineMsgL'             ===== Standard type line =====AddrStr  dc    c'000000'                ASCII from Long2Hex (limit to 6 bytes)         dc    c'  |  'LineHex  dc    4c'00000000 '            Hex charactersSep2     dc    c' |  'LineChar dc    16c' ',c' '              Printable charactersLineMsgL equ   *-LineMsg-1              This MUST be an EVEN numberLineMsgX dc    i1'LineMsgLX'            ===== '-X' type line =====AddrStrX dc    c'000000'                ASCII from Long2Hex (limit to 6 bytes)         dc    c'  |  'LineX    ds    64                       Printable characters         dc    c' | 'LineMsgLX equ  *-LineMsgX-1             MUST be an EVEN number; Nb: '-C' line is also used by '-T', '-A' and '-B' routines; Nb: Length is overridden by '-A' and '-B' routines; Nb: '-A' line may increase > 80 with Mousetext, etc., but screen size is < 80         ds    1                        Allow 'word' stores into lengthLineMsgC dc    i1'LineMsgLC'            ===== '-C' type line =====LineC    ds    80                       Printable chars (no control chars)LineMsgLC equ  *-LineMsgC-1             MUST be an EVEN number         ds    256-LineMsgLC            Insurance against line length bugs;			(Also allows high-ASCII expansion);			(Allow for Mousetext and highlighting)HexIndx  ds    2                        Offset to hex  part of lineCharIndx ds    2                        Offset to char part of lineErrCode  ds    2                        Tool error codeErrorMsg dc    i1'EMsgLen'              Error message         dc    c'Error $'ErrorStr dc    c'0000'                  Filled by Int2Hex         dc    c' occurred'EMsgLen  equ   *-ErrorMsg-1;; Data I/O buffer;DataLen	dc	i4'DataBufL'	Default buffer sizeDataLenS	dc	i4'512'	Short buffer size (for '-1' mode)DataBuf  ds    16*1024                  Buffer for READ (must be EVEN, > 302!)DataBufL equ   *-DataBuf                Too long for 'L:' operator!         end;.......................................;; The BASICTAB token table data segment is 'APPEND'ed here.;         append DUMP.3;.......................................;; Routines included at LINK time. Nb: Routines preserve m, x bits;; ReadLn     - Read a line of input from Standard Input.; ======       'JSL'. All registers preserved.;; End of Source