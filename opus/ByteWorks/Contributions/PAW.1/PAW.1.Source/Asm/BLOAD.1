         mcopy bload.mac         gen   on;................................................................;; BLOAD  -  Utility to call the system loader to load an application;           and resolve relocatable data, then return the address;           for use by a disassembler such as Nifty-List or the Monitor.;;           Syntax:  BLOAD pathname;              (will prompt if pathname omitted);;           WARNING: If the program has an 'Initialization' segment, it will;                    be executed just as if you were running the program!!!;;           BLOAD was primarily designed for the APW (or ORCA/M) shell, but;           it will work correctly as a system file if first converted to;           filetype S16 ($B3).;;           V1.0 - Copyright by Peter Watson, December 1988.;           V1.1 - Add wildcard capability. Jan 1989.;           V1.2 - Full support for running without the Shell. Jan 1989.;;................................................................         longa on         longi onBLOAD    startParmPtr  equ   0                        Offset into direct page         phk         plb                            Make data bank = program bank         sty   ParmPtr                  Save parameter...         stx   ParmPtr+2                ...address on entry         stz   ParmFlag                 Initialise 'Found a parm' flag         stz   ShellPgm                 Initialise 'Running under Shell' flag         stz   PathBuf                  Initialise pathname length for reuse; Start some toolsets, just in case they weren't started by the Tool Locator        _IMStartUp                      Start Integer Math toolset        _TextStartUp                    Start Text Tool toolset         writeln         writeln HelloMsg               Announce ourselves to the world;................................................................;; Set the Input Global parameters to remove the high bit from input.; The Shell does this for us, but we may not be under the Shell!;;................................................................         pushlong #0                    Result space        _GetInGlobals         pulllong InGlobals             Save original values         pea   $7F                      AND mask - strip high bit         pea   0                        OR  mask - don't change        _SetInGlobals;................................................................;; Check for the Id string from APW or ORCA/M;;................................................................         lda   ParmPtr                  X = Y = 0?         ora   ParmPtr+2                Did we get a parm?         beq   GoPrompt                 No, go prompt for a pathname         ldy   #L:IdString-2ChkId    lda   [ParmPtr],Y              Check for legit parameter...         beq   GoPrompt                 (end of string)         cmp   IdString,Y               ...starting with 'BYTEWRKS'         beq   *+5GoPrompt brl   Prompt                   Not from Shell, so must always prompt         dey         dey         bpl   ChkId         inc   ShellPgm                 Set ShellPgm = TRUE (non-zero);................................................................;; Now we can look for our real command operand (Skip command name first);;................................................................         short                          8-bit memory & registers         ldy   #L:IdString              Point to first byte of command lineLook1    anop         lda   [ParmPtr],Y              Get character         beq   Prompt                   End of string - Not enough!         cmp   #' '                     End of command yet?         beq   SkipBlnk                 Yes, Go skip some blanks         iny         bne   Look1SkipBlnk anop         lda   [ParmPtr],Y              Get character         beq   Prompt                   End of string         cmp   #' '                     Non-blank yet?         bne   LookDone                 Found first operand byte         iny         bne   SkipBlnkLookDone anop         sta   ParmFlag                 Set 'Parm found' to TRUE (ie. non-zero);................................................................;; Transfer the parameter to the pathname buffer;;................................................................         ldx   #0                       Offset into PathBufLoop3    anop         sta   PathBuf+1,X              Fill the pathname buffer         inx                            Bump PathBuf index         cpx   #PathLen+1               Pathname too long?         blt   *+5         brl   ParmErr                  Yes, go whinge about it         inc   PathBuf                  Increment count byte         iny                            Bump Parameter index         lda   [ParmPtr],Y              Get next character         bne   Loop3                    Branch if not done yet         long                           16 bit memory & registers         brl   GotPath                  We have a pathname;................................................................;; Prompt the caller for a pathname;;................................................................Prompt   anop         long                           16 bit memory & registers         writeln         writestr #'Pathname to load >'         pea   0                        Result - Character count         pushlong #PathBuf+1            Pathname buffer         pea   PathLen                  Maximum line length         pea   13                       End-of-Line character = <Return>         pea   1                        1 = Echo characters        _ReadLine; Store the length - if zero, then exit         writeln                        Move to next line         pla                            Get character count         bne   *+5         brl   Exit                     None, time to go         shortm         sta   PathBuf         longm;................................................................;; Got a pathname - handle wildcards (first only) if under the Shell;;................................................................GotPath  anop         lda   ShellPgm                 Running under the Shell?         bne   *+5         brl   DoLoad                   No, can't handle wild cards        _Init_WildCard WildParm         Initialise wildcard processing         bcc   *+5         brl   ToolErr                  Handle any errors        _Next_WildCard WildParm         Get first name (only); Check that we actually found a valid pathname - else PathBuf is now blank         lda   PathBuf                  Get length byte (and one garbage byte)         and   #$00FF                   Ensure high byte is zero         bne   DoLoad                   Pathname present (and found!);................................................................;; Some path or file or whatever that we couldn't handle - tell the user;;................................................................BadPath  anop         pha                            Save pathname length         writestr #'Unable to find or access '         pla         beq   BadPath2                 Pathname unavailable         writeln  PathBuf         brl   PromptBadPath2 writeln  #'the specified file'         brl   Prompt;................................................................;; Call the System Loader to load the file;;................................................................DoLoad   anop         pea   0                        Result - UserId         pushlong #0                    Result - Starting address         pea   0                        Result - Address of direct page/stack         pea   0                        Result - Length  of direct page/stack         pea   0                        Input - UserId (0 = Obtain new UserId)         pushlong #PathBuf              Input - Pathname buffer address         pea   0                        Input - 0 = Load anywhere        _InitialLoad                    Load the file         tax                            Save error value (if any) in X-reg         pullword UserId                Get returned UserId         pulllong Address               Save load address for message         pullword DPS                   Direct page/stack address         pullword DPSlen                Direct page/stack size         txa                            Restore error value (if any)         beq   Display                  All OK, display results         jsr   ChkError                 Test for assorted ProDOS / GS/OS errors         bcc   *+5         brl   BadPath                  Simple error - treat as a bad pathname         brl   ToolErr                  Handle an unexpected error;................................................................;; Test for ProDOS / GS/OS errors which we can treat as 'bad pathname';;................................................................ChkError anop         cmp   #$10                     Device not found         blt   ChkErr2                  Error too small!         beq   ChkErrX         cmp   #$11                     Invalid device request         beq   ChkErrX         cmp   #$28                     No device connected         beq   ChkErrX         cmp   #$2F                     Device not online         beq   ChkErrX         cmp   #$40                     Syntax error?         beq   ChkErrX         cmp   #$44                     Path/Volume/File error?         blt   ChkErr2                  No, too small         cmp   #$47         blt   ChkErrX                  Yes ($44, $45, $46)         cmp   #$4E                     Access not allowed?         beq   ChkErrXChkErr2  clc                            Must be some other error         rts                            Return to our callerChkErrX  sec                            Default 'bad path' error         rts                            Return to our caller;................................................................;; Display the results;;................................................................Display  anop         pushlong Address               Get address         pushlong #AddrStr              Target string address         pea   L:AddrStr                Length of target string        _Long2Hex                       Convert the address to hexadecimal         writeln         writestr PathBuf               Tell the user what  it is         writeln AddrMsg                Tell the user where it is;................................................................;; Now wait for the user to press a key, so we can unload the program;; Note that he can call CDA's while we're waiting!;;................................................................         writeln         writestr #'Please press a key to unload the file...'         pea   0                        Space for result         pea   0                        Don't echo the key        _ReadChar                       Get a keystroke         writeln         pla                            What was the key?         cmp   #$1B                     <Esc> key pressed?         beq   Exit                     Abandon ship - NOT recommended!;................................................................;; Unload the program now he's finished;;................................................................         pea   0                        Result space - UserId         pushword UserId                Input - The UserId from InitialLoad         pea   0                        Input - Quit flag (not restartable, etc)        _UserShutDown         plx                            Discard returned UserId         bcs   ToolErr                  Handle any error;................................................................;; Go around again if we were in 'prompt' mode;;................................................................         lda   ParmFlag                 Did we get have a parm (ie. no prompt)?         bne   Exit                     Yes, so exit immediately         brl   Prompt                   Otherwise, go again;................................................................;; Exit - Return to our caller (Shell will trap QUIT call);;................................................................Exit     anop         pushlong InGlobals             Restore global variables        _SetInGlobals        _TextShutDown                   Close down the Text Tool toolset        _IMShutDown                     Close down the Integer Math toolset         lda   #0                       Return code of zero        _Quit  QuitParm                 Return to our caller (Shell traps Quit);................................................................;; ToolErr - Print an error message after a tool error, then restart;           at 'Prompt'. Use the Shell's utility routine, if possible.;;................................................................ToolErr  anop         sta   ErrCode         ldx   ShellPgm                 Test for Shell facilities         beq   ToolErr2                 Not running under Shell; can't use ERROR        _Error ErrCode                  Shell 'standard' error message         brl   Prompt; Oh well, we have to do it ourselvesToolErr2 anop                           Second best error message from us         cmp   #$1104                   'Loader: Not a load file'         beq   ToolErr3                 Real error message         cmp   #$0027                   I/O error?         beq   ToolErr4                 Real error message         pha                            Push error code         pushlong #ErrorStr             Target string address         pea   L:ErrorStr               Length of target string        _Int2Hex                        Convert to hexadecimal         writeln ErrorMsg               Tell the user the error code, at least         brl   PromptToolErr3 anop                           A worthwhile message         writestr PathBuf         writeln #' is not a load file (filetype $Bx)'         brl   PromptToolErr4 anop                           A worthwhile message         writestr #'I/O error on '         writestr PathBuf         brl   Prompt;................................................................;; ParmErr - Print an error message for a parameter that is too long;;................................................................ParmErr  anop         long                           16 bit memory & registers         writeln         writestr #'Pathname length more than 64 characters'         brl   Prompt                   Go get a decent pathname;................................................................;; Data areas;;................................................................IdString dc    c'BYTEWRKS'              Shell id stringParmFlag ds    2                        0 = No parameter found (ie. must prompt)ShellPgm ds    2                        0 = Not running under the Shell / ORCA/MInGlobals ds   4                        Save area for input global parametersErrCode  ds    2                        Tool error codeHelloMsg str    '&SYSNAME v1.2 - Copyright by Peter Watson, January 1989'Eyeball  dc    c'&SYSNAME - &SYSDATE &SYSTIME'WildParm anop                           Parm for Init_Wildcard & Next_WildCard         dp    PathBuf                  Pathname pointer         dc    i'$4000'                 '?' wildcards OK; use first one onlyPathBuf  dc    i1'0',64c' '             Pathname bufferPathLen  equ   *-PathBuf-1UserId   ds    2                        UserId  from InitialLoadAddress  ds    4                        Address from InitialLoadDPS      ds    2                        Direct page/stack from InitialLoadDPSlen   ds    2                        Direct page/stack size from InitialLoadAddrMsg  dc    i1'AMsgLen'              Address message         dc    c' loaded at $'AddrStr  dc    c'000000'                Filled by Long2HexAMsgLen  equ   *-AddrMsg-1ErrorMsg dc    i1'EMsgLen'              Error message         dc    c'Error $'ErrorStr dc    c'0000'                  Filled by Int2Hex         dc    c' occurred'EMsgLen  equ   *-ErrorMsg-1QuitParm dp    0                        Pathname (Return via Quit stack)         dc    i'0'                     Flags         end