         mcopy auxtype.mac         gen   on;................................................................; AUXTYPE - ORCA shell utility to display and alter the AuxType of a file.;           Wildcard filenames are supported.  Code is reusable/restartable.;;           Syntax:  AuxType [-L] pathname [AuxType];             (Will prompt if pathname omitted and/or AuxType omitted.);             (If AuxType is supplied, it will be used for ALL files.);             (If the auxtype value is is prefixed by 'A', 'O' or 'X', then the;              specified value will be 'And'ed, 'Or'ed or 'Xor'ed respectively;              with the current auxtype value.);;             -L - 'List' the AuxType only;;           Requires the following <INC>lude files (or object modules) :-;             ReadLn.INC                ReadLn Subroutine;             Stop.Pause.INC            Stop_Pause Subroutine;;           V1.0 - Copyright by Peter Watson, December 1988.;           V1.1 - Support wildcards. January 1989.;           V1.2 - Allow AuxType on command line. January 1989.;           V1.3 - Ignore DIR files in wildcards. January 1989.;           V1.31- Fix case problem in message. February 1989.;           V1.4 - Use READLN. Add '-L' option. Honour locked files.;                  If in prompt mode, stay there. January 1990.;           V1.5 - Support 'A' and 'O' prefix to auxtype. July 1993.;           V1.51- Support 'X' prefix to auxtype. May 1994.;................................................................         longa on         longi onAUXTYPE  start         gblc  &VER         gblc  &MaxBuf&VER     setc  '1.51'	Program version&MaxBuf  setc  '64'                     Maximum parameter/pathname buffer sizeParmPtr  equ   0                        Offset into direct page;................................................................         phk         plb         sty   ParmPtr                  Save parameter...         stx   ParmPtr+2                ...address on entry         stz   ParmLFlg                 Initialise 'Found -L switch' flag         stz   ParmFlag                 Initialise 'Found a parm' flag         stz   ParmAux                  Initialise 'Found AuxType parm' flag         stz   ParmAuxAO                Initialise 'AND'/'OR'  prefix flag         stz   PathBuf                  Initialise pathname length for reuse         lda   #'  '         sta   AuxBuf                   Clear buffer for possible use in message         sta   AuxBuf+2         sta   AuxBuf+4; Start Int Math toolset, just in case it wasn't started by the tool locator        _IMStartUp                      Start Integer Math toolset         writeln         writeln HelloMsg;................................................................;; Check for the Id string from APW or ORCA/M;;................................................................         lda   ParmPtr                  X = Y = 0?         ora   ParmPtr+2                Did we get a parm?         beq   GoNotShl                 No, we really don't want to know him         ldy   #L:IdString-2ChkId    lda   [ParmPtr],Y              Check for legit parameter...         beq   GoNotShl         cmp   IdString,Y               ...starting with 'BYTEWRKS'         beq   *+5GoNotShl brl   NotShell         dey         dey         bpl   ChkId;................................................................;; Now we can look for our real command operands (Skip command name first);;................................................................         shortm                         8-bit memory         ldy   #L:IdString              Point to first byte of command lineLook1    anop         lda   [ParmPtr],Y              Get character         beq   GoPrompt                 End of string - Not enough!         cmp   #' '                     End of command yet?         beq   SkipBlk1                 Yes, Go skip some blanks         iny         bne   Look1SkipBlk1 anop         jsr   SkipBlks         bcc   *+5GoPrompt brl   Prompt                   End of string found;................................................................;; Check for '-L' (listing only) parameter;;................................................................         cmp   #'-'                     Switch character?         bne   FoundP1         iny         lda   [ParmPtr],Y              Get character         beq   GoPerr3                  End of string         and   #$DF                     Make upper case         cmp   #'L'                     'L'isting only?         beq   *+5GoPerr3  brl   ParmErr3                 No         inc   ParmLFlg                 Set ParmLFlg = TRUE         jsr   SkipBlks         bcs   Prompt                   End of string foundFoundP1  anop         sta   ParmFlag                 Set 'Parm found' to TRUE (ie. non-zero); Transfer the pathname to the pathname buffer         ldx   #0                       Offset into PathBufMovePath anop         sta   PathBuf+1,X              Fill the pathname buffer         inx                            Bump PathBuf index         cpx   #&MaxBuf+1               Pathname too long?         bne   *+5         brl   ParmErr                  Yes, go whinge about it         inc   PathBuf                  Increment count byte         iny                            Bump Parameter index         lda   [ParmPtr],Y              Get next character         beq   GoGotPth                 End of parameter         cmp   #' '                     End of pathname?         bne   MovePath                 Not done yet;................................................................;; Let's see if he also specified an AuxType;;................................................................         jsr   SkipBlks         bcs   GoGotPth                 End of string found         sta   ParmAux                  Set 'AuxType found' to TRUE (ie. > 0); Transfer the parameter to the AuxType buffer         ldx   #0                       Offset into AuxBufMoveAux  anop         cmp   #'a'                     Lower case?         blt   StaAux                   No, leave it alone         and   #$DF                     Convert to upper (for messages)StaAux   sta   AuxBuf,X                 Fill the AuxType buffer         inx                            Bump AuxType index         iny                            Bump Parameter index         lda   [ParmPtr],Y              Get next character         beq   StoreAux                 End of buffer         cpx   #L:AuxBuf                Parameter too long?         bne   NextAux         cmp   #' '                     Ignore trailing blanks/parameters         beq   StoreAux                 Ignore it         brl   ParmErr2                 Yes, go whinge about itNextAux  anop         cmp   #' '                     Ignore trailing blanks/parameters         bne   MoveAux                  Not done yetStoreAux stx   AuxBufL                  Save length for laterGoGotPth anop         brl   GotPath                  Continue processing;................................................................;; Subroutine to skip blanks in the command line;; On entry, m=1.; On exit,  m=1, Acc = First non-blank.;           c=1 if the end of the command line was reached.;;................................................................SkipBlks anop         iny         lda   [ParmPtr],Y              Get character         beq   SB_End                   End of string         cmp   #' '                     Non-blank yet?         beq   SkipBlks                 No, keep looking         clc         rtsSB_End   sec                            Indicate unsatisfactory ending         rts;................................................................;; Prompt the caller for a pathname;;................................................................Prompt   anop         longm                          16 bit memory         writeln         writestr #'Enter pathname >'         pushlong #PathBuf+1            Pathname buffer         pea   &MaxBuf                  Maximum line length         jsl   ReadLn                   Go get an input line; Store the length - if zero, then exit         writeln         pla                            Get character count         bne   ReadOK         brl   Exit                     None, time to goReadOK   anop         shortm         sta   PathBuf;................................................................;; Allow wildcard filenames;;................................................................GotPath  anop         longm                          16 bit memory         writeln        _Init_WildCard WildParm         bcc   *+5         brl   ToolErr                  Handle error condition;................................................................;; Call Get_File_Info to get (next) file's AuxType;;................................................................GetInfo  anop        _Next_WildCard WildParm         Get (next) filename, if any         lda   PathBuf                  Get pathname length         and   #$00FF                   Low order byte only         bne   ShowName                 Go print the name         lda   ParmFlag                 Did we get a pathname (ie. no prompt)?         bne   *+5         brl   Prompt                   No, so we're in prompting mode         brl   Exit                     If none/no more, then exitShowName anop         writeln PathBuf                Display the current filename        _Get_File_Info InfoParm         Look for file         bcc   *+5         brl   ToolErr                  Handle an error; Ignore directory files         lda   FileType                 Get filetype         cmp   #$0F                     DIR?         bne   DispAux                  No, go display AuxType         writeln #'Directory file ignored!'         brl   EndLoop                  Skip processing for this file;................................................................;; Display the current AuxType value in decimal and hex;;................................................................DispAux  anop         pushword Aux_Type              Get AuxType         pushlong #HexType              Target string address         pea   L:HexType                Target string length        _Int2Hex                        Convert address to hexadecimal         pushword Aux_Type              Get AuxType         pushlong #DecType              Target string address         pea   L:DecType                Target string length         pea   0                        Unsigned string        _Int2Dec                        Convert address to Decimal         writeln CurrMsg                Write current value message;................................................................;; Prompt for a new AuxType value if required.  Exit if none entered.;;................................................................         lda   ParmLFlg                 '-L' (listing mode) specified?         beq   *+5         brl   EndLoop                  Yes, skip update of auxtype         lda   ParmAux                  Was an AuxType supplied already?         beq   AskAux                   No, so ask for one         ldx   AuxBufL                  Prepare X for next routine         brl   CnvrtAux                 Don't bother promptingAskAux   anop         writeln         writestr #'Enter new AuxType (default = no change) >'         stz   AuxBuf                   Zero buffer for safety         stz   AuxBuf+2         stz   AuxBuf+4         pushlong #AuxBuf               AuxType buffer         pea   L:AuxBuf                 Maximum line length         jsl   ReadLn                   Go get an input line         writeln                        Move to next line; Check for zero length, therefore no change.; Also, check for an attempt to exit with Apple-Period, <Esc> or <Ctrl-C>.         plx                            Get character count         bne   *+5         brl   EndLoop                  None, leave file alone         cpx   #1                       Did he try to leave, maybe?         bne   CnvrtAux         shortm         lda   AuxBuf         cmp   #'.'                     Look for period as only character         beq   GoExit         cmp   #$1B                     Look for <Esc> character         beq   GoExit         cmp   #$03                     Look for <Ctrl-C> character         beq   GoExit         longm         bra   CnvrtAuxGoExit   anop         longm         brl   Exit                     Early retirement scheme;................................................................;; Convert the input from character to integer - handle hex or decimal;; On entry, X reg = Count of characters within AuxBuf;................................................................CnvrtAux anop	jsr	AndOrChk	Handle 'and' or 'or' prefix chars         lda   AuxBuf                   Look at first character         and   #$007F                   Ignore second byte and high bit         cmp   #'$'                     Hex entry?         beq   CvtHex         pea   0                        Space for result         pushlong #AuxBuf               String address         phx                            String length         pea   0                        Unsigned integer only        _Dec2Int                        Convert string to integer         bcs   AskError                 Handle errors         brl   GetResult            CvtHex   anop         pea   0                        Space for result         pushlong #AuxBuf+1             String address         dex                            Ignore '$' sign         phx                            String length        _Hex2Int                        Convert string to integer         bcs   AskError                 Handle errors         brl   GetResultAskError anop         pla                            Ignore result         lda   #$07                     Bell character         writech         writeln #'Invalid AuxType - please re-enter'         brl   AskAux                   Go prompt for AuxType again;................................................................;; Check for 'A'(nd), 'O'(r) or 'X'(or) as prefix characters to the new auxtype.; If present, they request to 'and', 'or' or 'xor'  the specified value; respectively with the existing auxtype value, rather than replacing it.;; On entry, X reg = Count of characters within AuxBuf; On exit,  ParmAuxAO = -1 (and), 0 (no char), +1 (or);           AuxBuf has been shifted left by 1, and the X reg decremented.;................................................................AndOrChk anop         lda   AuxBuf                   Look at first character         and   #$005F                   One byte; no high bit; uppercase         cmp   #'A'                     AND requested?         beq   SayAND         cmp   #'O'                     OR  requested?         beq   SayOR         cmp   #'X'                     XOR requested?         beq   SayXOR	bra   AndOrOK	Nothing to do (X reg unchanged)SayAND	lda	#1	Set flag for 'AND'	bra	FlagSetSayOR	lda	#2	Set flag for 'OR '	bra	FlagSetSayXOR	lda	#3	Set flag for 'XOR'FlagSet	anop	sta	ParmAuxAO	Save flag value	shortm	dex		Show new length	stx	AuxBufL	Save in appropriate place	ldy	#0ShiftAux anop	lda	AuxBuf+1,Y	Shift left by 1	sta	AuxBuf,Y	iny	dex	bne	ShiftAux	Do another byte	lda	#' '	sta	AuxBuf,Y	Blank out the last character	ldx	AuxBufL	Retrieve auxtype length againAndOrOK	longm	rts;................................................................;; Create the new AuxType from any AND, OR or XOR flags, and display it;;................................................................GetResult anop	pla		Retrieve result	ldx	ParmAuxAO	Test And/Or flag	beq	SetAux	No flag specified         cpx	#2	Which flag?	bcc	AndIt	'And' specified	beq	OrIt	'Or' specifiedXorIt	anop	eor	Aux_Type	'Xor' with existing auxtype	bra	SetAuxOrIt	anop	ora	Aux_Type	'Or' with existing auxtype	bra	SetAuxAndIt	anop	and	Aux_Type	'And' with existing auxtypeSetAux	anop	sta	Aux_Type	Place auxtype in parm list; Convert back to characters for display         pushword Aux_Type              Get AuxType         pushlong #HexType2             Target string address         pea   L:HexType2               Target string length        _Int2Hex                        Convert address to hexadecimal         pushword Aux_Type              Get AuxType         pushlong #DecType2             Target string address         pea   L:DecType2               Target string length         pea   0                        Unsigned string        _Int2Dec                        Convert address to Decimal         writeln NewMsg                 Remind user of new value;................................................................;; Modify the file's AuxType (unless the file is locked!);;................................................................         lda   Access                   Get ACCESS bits         and   #$0002                   Get 'write enable' bit (.... ..1.)         beq   LockErr                  Handle 'locked file' error        _Set_File_Info InfoParm         Change the entry         bcc   EndLoop         brl   ToolErr                  Handle an error;................................................................;; Tell the user that the file was locked, so no change was made;;................................................................LockErr  anop         writeln         lda   #$07                     Bell character         writech         writeln #'File is locked - changes not made!';................................................................;; Go look for more files to modify; pause if a key was pressed.;;................................................................EndLoop  anop         writeln         jsl   Stop_Pause               Look for keypress or Apple-Period         cmp   #0         bne   Exit                     Apple-Period or Option-Period pressed         brl   GetInfo                  Yes, go look for more files;................................................................;; Exit - Return to our caller;;................................................................Exit     anop         lda   #0                       Set a good return codeExit2    anop         pha                            Save return code        _IMShutDown                     Shut down Integer Math toolset         pla                            Restore return code        _Quit QuitParm                  Return to our caller;................................................................;; ToolErr - Print an error message after a tool or OS error, then exit;;................................................................ToolErr  anop         sta   ErrCode        _Error ErrCode         lda   ErrCode                  Restore error code         bra   Exit2;................................................................;; Return to someone other than a Shell-based caller;; Display a message first;;................................................................NotShell anop         pea   0                        Result - Button that was pressed         pushlong #MsgLine1         pushlong #MsgLine2         pushlong #MsgBut1         pushlong #MsgBut2        _TLTextMountVolume         bra   Exit;................................................................;; ParmErr  - Print an error message for a parameter that is too long; ParmErr2 - AuxType too long; ParmErr3 - Unknown 'switch' parameter;;................................................................ParmErr  anop         longm                          16 bit memory & registers         writeln         writestr #'Pathname length more than &MaxBuf characters'         brl   Prompt                   Go get a decent parameterParmErr2 anop         longm                          16 bit memory & registers         writeln         writestr #'AuxType length more than 6 characters'         brl   AskAux                   Go get a decent parameterParmErr3 anop         sta   BadParm                  Store in message         longm         writeln         writeln ParmMsg         lda   #$FFFF                   Set return code         brl   Exit2                    Leave immediately;................................................................;; Data areas;;................................................................IdString dc    c'BYTEWRKS'              Shell id stringParmLFlg ds    2                        0 = No '-L' flag foundParmFlag ds    2                        0 = No parameter found (ie. must prompt)ParmAux  ds    2                        0 = No AuxType parameter foundParmAuxAO ds   2                        0 = No AuxType 'AND' prefix specified;                                       1 = AuxType 'OR'  prefix specified;                                      -1 = AuxType 'AND' prefix specifiedEyeball  dc    c'&SYSNAME - V&VER - &SYSDATE &SYSTIME'HelloMsg str    '&SYSNAME - V&VER Copyright 1989-1993 by Peter Watson'ParmMsg  dc    i1'ParmMsgL'         dc    i1'7',c'Unknown parameter option (-'BadParm  dc    c'?)'ParmMsgL equ   *-ParmMsg-1PathBuf  dc    i1'0',&MaxBuf.c' '       Set by ReadLineWildParm dp    PathBuf                  Pathname pointer         dc    i2'0'                    '?' wildcards OK, with multiple filesInfoParm anop         dp    PathBuf                  PathnameAccess   ds    2                        AccessFileType ds    2                        FiletypeAux_Type ds    4                        AuxType         ds    14                       Other odds and endsCurrMsg  dc    i1'CurrMsgL'         dc    c'Current AuxType is $'HexType  dc    c'0000'         dc    c' ('DecType  dc    c'00000'         dc    c')'CurrMsgL equ   *-CurrMsg-1NewMsg   dc    i1'NewMsgL'         dc    c'New     AuxType is $'HexType2 dc    c'0000'         dc    c' ('DecType2 dc    c'00000'         dc    c')'NewMsgL  equ   *-NewMsg-1AuxBuf   ds    6                        Input buffer for new AuxType (Even numb.;                                       for zap routine, and makes input better)AuxBufL  ds    2                        Actual AuxType length within bufferErrCode  ds    2                        Tool error codeMsgLine1 str   '  &SYSNAME must be called from'MsgLine2 str   '  the APW or ORCA shell!'MsgBut1  dc    i1'13',i1'27,15',c'M',i1'14,24',c' = Oops!'MsgBut2  str   'Esc = Cancel'QuitParm dp    0                        Pathname         dc    i'0'                     Flags         end