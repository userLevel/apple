         keep  MoreRecent         mcopy MoreRecent.mac*****************************************************************************      MoreRecent**  Tests to see if any file in a list of files has been changed more*  recently than a test file.**  Format:**      MORERECENT tfile file1 file2 ...**  At least two files must be supplied.  The first file name is read,*  and the Mod date recorded.  Each remaining file is then read in*  turn.  If an error occurs, either due to supplying less than two*  files names or due to ProDOS not being able to do a Get_File_Info*  call on one of the files, -1 is returned in the accumulator (where*  it can be read using the shell's {Status} variable.  If any file is*  found that has a Mod date after that of tfile, a 1 is returned,*  and the rest of the list of files is not read or tested.  If all*  files are tested, and none has a more recent Mod date than tfile, a*  zero is returned.**  This program is restartable.  To install it as a utility, place the*  executable file in the utility directory, then add the following line :-**      MORERECENT      *U      See if files are more recent**  to the 4/SYSCMND file.*****************************************************************************  Written at the Byte Works*  Source code released to the public domain**  Program assembled under Orca/M 1.1*  (Assembled under APW V1.0 by P. Watson, May 1988)**  by Mike Westerfield*  March 1988*      nb. see Call-Apple May 1988, S. Harker, May 1988.***************************************************************************MoreRecent start         using Common         phk                            Set up data bank         plb         jsr   Init                     Set up globals and read the first file         bcs   rts         jsr   Main                     Check further filesrts      lda   <status                  Return the status         rtl         end**************************************************************************      Common - Common data area**************************************************************************Common   data;;      Direct page areas;cLine    gequ  0                        Pointer to the command linestatus   gequ  4                        Value to return to the shellcmpDate  gequ  6                        Mod date for initial filecmpTime  gequ  8                        Mod time for initial file;;      Global constants;maxTokenSize equ 64                     Max # of characters in a token;;      Global data areas;token    ds    maxTokenSize+1           Last command line tokengiDCB    anop                           Dcb for GET_File_Info         dc    a4'token'                Path name         ds    2                        Access         ds    2                        File type         ds    4                        Aux type         ds    2                        Storage type         ds    2                        Create date         ds    2                        Create timeModDate  ds    2                        Mod dateModTime  ds    2                        Mod time         ds    4                        Blocks used         end***************************************************************************        GetModDate - read in a file name and get it's Mod date/time**  Outputs:*        modDate, modTime - mod date/time of the file*        C - clear if there was no file or an error occurred*        status - set to -1 if a disk error occurred.***************************************************************************GetModDate start         using Common         jsr   GetToken                 Get the file name         bcc   rts                      Exit (with C=0) if there was no file         Get_File_Info giDCB            Get the file's mod date/time         bcs   error         sec                            Return; file foundrts      rtserror    lda   #-1                      Return; error during Get_File_Info         sta   status         clc         rts         end****************************************************************************  GetToken - read a token from the command line**  Inputs:*        cLine - pointer to next char in command line**  Outputs:*        token - token string*        C - set if there was a token***************************************************************************GetToken start         using Commonlb1      lda   [cLine]                  Skip leading blanks         and   #$00ff         cmp   #' '         bne   lb2         inc4  cLine         bra   lb1lb2      short I,M                      Use short registers         ldy   #0                       y := 0lb3      lda   [cLine],y                while not (cLine[y] in [' ',chr(00)]) do         beq   lb4         cmp   #' '         beq   lb4         iny                            y++         sta   token,y                  token[y] := cLine[y-1]         cpy   #maxTokenSize            if y = maxTokenSize then exit         bne   lb3                      endwhilelb4      sty   token                    token[0] := y         long  I,M                      Back to long registers         tya                            Skip the token in the command line...         and   #$00ff                   ...by adding its length to the cLine...         beq   lb6                      ...pointer         clc         adc   cLine         sta   cLine         bcc   lb5         inc   cLine+2lb5      sec                            Return; token found         rtslb6      clc                            Return; no token found         rts         end***************************************************************************        Init  - Initialise scalars and read the intitial file**  Inputs:*        X,Y (from shell) - addr of the command line - 8**  Outputs:*        C - set if there was an error, else clear*        cLine - pointer to the command line*        status - error code (see intro for details)***************************************************************************Init     start         using common         tya                            Save the pointer to the command line         clc         adc   #8                       Skip 'BYTEWRKS' string         bcc   lb1         inxlb1      sta   cLine         stx   cLine+2         stz   status                   status = 0; no error so far         jsr   GetToken                 Read command name from command line         bcc   error         jsr   GetModDate               Get the Mod date for the first file         bcc   error         lda   ModDate                  Save the mod date         sta   cmpDate         lda   modTime         sta   cmpTime         clc                            Return with no error         rtserror    lda   #-1                      status = Error         sta   status         sec                            Flag error and return         rts         end***************************************************************************        Main - Check each file in the remainder of the command line**  Outputs:*        status - error code (see intro for details)***************************************************************************Main     start         using commonlb1      jsr   GetModDate               Get the mod date for the next file         bcc   rts                      Quit if we're done or an error occurred         lda   cmpDate                  Branch if the new file is more recent         cmp   modDate                  Check date         blt   lb2         lda   cmpTime         cmp   modTime                  Check time         blt   lb2         bra   lb1                      Next filelb2      lda   #1                       Indicate that a file was more recent         sta   statusrts      rts         end