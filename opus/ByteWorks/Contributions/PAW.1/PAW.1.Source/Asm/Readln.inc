;................................................................;;      READLN;      ------;  Read a line of input from standard input, with minimal editing keystrokes.;;  On entry, e = m = x = 0 (full native mode).  B, D, Acc, X, Y = Don't care;;            Stack :-  AL4(Address of buffer);                      AL2(Maximum length)     (usually buffer length);               SP --->;;  While processing, 4 bytes at +0 in the direct page are "borrowed".;;  On exit,  Buffer contains input string (if any);            Carry bit - set   if input ended by <Esc>;                      - clear if input ended by <Return>;            B, D, A, X, Y, e, m, x unchanged;;            Stack :-  AL2(Length of string);               SP --->;;................................................................;;  NOTE: This is NOT a standalone program!;        ---------------------------------;;  To install in a module, add the following source line :-;;      APPEND READLN                    (or manually cut & paste this source);;  Example of use :-;;        pushlong #Buffer               ;Push buffer address;        pea   L:Buffer                 ;Push buffer length (= max length);        jsl   READLN                   ;Read a line of input;        bcs   Escape                   ;<Escape> pressed (fix stack later);        pla                            ;Retrieve the string length;        beq   NoEntry                  ;No, nothing entered;        bne   Process                  ;Yes, process the input;        ......; Escape pla                            ;Clean up the stack;        ......;................................................................         case    on         objcase on                     Need lowercase 'main' for 'C'READLN   start   main         longa   on                     Just for the assembler's sake         longi   onC_Bell   equ   $07                      BellC_ClrEOS equ   $0B                      Clear to End-Of-ScreenK_LArrow equ   $08                      Left arrow (backspace)K_Return equ   $0D                      ReturnK_Clear  equ   $18                      Clear (Control-X)K_Escape equ   $1B                      EscapeK_Space  equ   $20                      Space characterK_Delete equ   $7F                      DeleteBufPtr   equ   $00                      Direct page address to point to buffer;................................................................;; Start of the main routine;; Start by getting our stack and DP in order. (Assume m = x = 0);;................................................................         phb                            Save data bank address         phk         plb                            Localise the data bank register         sta   SaveAcc                  Save Acc.         shortm                         8 bit memory         pla                            Get data bank byte         sta   SaveBank                 Save it for later         longm         lda   BufPtr                   Save some direct page         sta   SaveDP         lda   BufPtr+2         sta   SaveDP+2         pull3 RetAddr                  Save return address         pullword Max                   Save maximum length         pulllong BufPtr                Store buffer address         phx                            Save index registers         phy         stz   Count                    Zero counter;................................................................;; Main Loop - Read another characterReadChar anop         pea   0                        Space for result         pea   0                        Don't echo the key        _ReadChar                       Get a keystroke         pla                            Get the key         and   #$007F                   Low ASCII only;................................................................;; Process the various editing characters         cmp   #K_Delete                <Delete> key?         beq   Delete                   Yes, handle like a backspace         cmp   #K_Space                 Control character?         bge   EchoChar                 No, echo and store it         cmp   #K_LArrow                Backspace?         beq   Delete                   Yes, handle backspace         cmp   #K_Escape                <Esc> key?         beq   Escape                   Yes, handle two possibilities         cmp   #K_Clear                 <Clear> key (Control-X)?         beq   Clear                    Yes, handle it         cmp   #K_Return                <Return> key?         bne   ReadChar                 Ignore anything else         clc                            Say it was <Return>         brl   Done                     Off we go;................................................................;; Handle <Delete> and <BackSpace>Delete   anop         lda   Count                    Get count         beq   ReadChar                 Can't go back any more!         writestr Del_Left              Write the 'left-space-left' string         dec   Count                    Decrement the count         brl   ReadChar                 Go read another character;................................................................;; Handle <Clear> (Control-X)Clear    anop         lda   Count                    Get count         beq   ReadChar                 Can't go back any more!Clear2   anop                           Entry from <Escape>SpaceLft anop         writech #K_LArrow              Write a backspace character         dec   Count                    Decrement the counter         bne   SpaceLft                 Go around again (until Count = 0)         writech #C_ClrEOS              Clear to end of screen         brl   ReadChar                 Go read another character;................................................................;; Handle <Escape>Escape   anop         lda   Count                    Get count         bne   Clear2                   In the middle - treat like <Clear>         sec                            Say it was <Escape>         brl   Done                     Well, he wants to abandon ship;................................................................;; At last, handle a 'real' characterEchoChar anop         ldy   Count                    Get the current count         cpy   Max                      Reached the maximum yet?         bge   Complain                 Yes, beep and return         shortm         sta   [BufPtr],Y               Save the character         longm         writech                        Echo the character         inc   Count                    Bump the counter         brl   ReadChar                 Go read another character;................................................................;; Complain about too many characters with a beepComplain anop         writech #C_Bell                Write(?) a beep         brl   ReadChar                 Go around again;................................................................;; Go home, with a job well done - carry bit already set/reset on entry hereDone     anop         ply                            Restore index registers         plx         pushword Count                 Put count on the stack         push3 RetAddr                  Restore our return address         lda   SaveDP                   Restore our borrowed direct page         sta   BufPtr         lda   SaveDP+2         sta   BufPtr+2         pushword SaveAcc               Save saved Acc contents         shortm         lda   SaveBank                 Restore data bank         pha         plb         longm         pla                            Restore Acc         rtl                            Return to our caller;................................................................;; Data areasDel_Left dc    I1'3,K_LArrow,K_Space,K_LArrow' Destructive backspaceCount    ds    2                        Number of characters readMax      ds    2                        Maximum number of characters allowedRetAddr  ds    3                        Save area for return address on entrySaveBank ds    1                        Save area for data bank on entrySaveAcc  ds    2                        Save area for Acc. on entrySaveDP   ds    4                        Save area for 4 bytes of direct page         end