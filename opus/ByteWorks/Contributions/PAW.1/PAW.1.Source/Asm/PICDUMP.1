         mcopy picdump.mac         gen   on;................................................................;; PicDump - CDA to save the IIgs Super Hi-Res screen as a PIC ($C1) file.;           The file will be named SCREEN.00 - if this file already exists;           then it will be named SCREEN.01, etc. up to SCREEN.99.;           CDA works in both ProDOS 8 and ProDOS 16/GSOS.;;           v1.0  - Copyright by Peter Watson, May 1990.;           v1.01 - Disable interrupts while playing with ProDOS 8. 26 Sep 90.;;................................................................         longa on         longi onPicDump  start         gblb  &CDA         gblc  &VER&CDA     setb  1                        1 = Assemble as a CDA (0 = testing)&VER     setc  '1.01'                   Program version number; EquatesMemHandle gequ 0                        Zero page handle  to MM-acquired memoryMemBlock gequ  4                        Zero page pointer to MM-acquired memoryOS_ID    gequ  $E100BC                  (0=P8, 1=P16 or GS/OS)Screen   gequ  $E12000                  Address of super hires screen memoryScreenLen gequ $8000                    Length of screen, SCBs and Palettes; Bank 0 equates for ProDOS 8 routinesBank0Loc gequ  $000A00                  Address of our ProDOS 8 bank 0 code/bufCodeLen  gequ  $200                     Amount we allow for our codeFileBuf  gequ  Bank0Loc+CodeLen         Address of file buffer for OPEN callDataBuf  gequ  FileBuf+$400             Address of data bufferDataBufL gequ  $8000                    Data buffer length (factor of ScreenLen)Bank0Len gequ  DataBufL+DataBuf-Bank0Loc Length of 'borrowed' bank 0 storage; ProDOS 8 and BASIC.SYSTEM code equatesBIGlobal gequ  $BE00                    BASIC global page addressCURSLOT  gequ  $BE3C                    BASIC default slotCURDRIVE gequ  $BE3D                    BASIC default driveMLI      gequ  $BF00                    ProDOS 8 MLI vectorLASTDEV  gequ  $BF30                    ProDOS 8 last device accessedBitmap   gequ  $BF58                    ProDOS 8 system bitmapPREFLAG  gequ  $BF9A                    ProDOS 8 Prpfix flag (0 = no prefix)MLIACTIV gequ  $BF9B                    ProDOS MLI active flag ($80 = active)NEWVIDEO gequ  $C029                    Super hires (etc) softswitchBELL     gequ  $FF3A                    Monitor bell routine for 8-bit mode         aif   .NOT.&CDA,.notCDA;................................................................;; CDA Header;         str   'Super Hi-Res Screen Dump' CDA title         dp    Start                    ptr to code start         dp    RTL                      ptr to shutdown routine.notCDA;................................................................;; Main program;Start    anop         phb                            Save data bank         phk         plb                            Data bank = Program bank; Initialise variables         stz   ClosePrm                 Init file opened flag         lda   #'00'                    Filename suffix         sta   Suffix                   Reset it;................................................................;; Now determine what OS we are running under (P8 or P16)?;         lda   OS_ID                    Get OS version         and   #$00FF                   Only want one byte         bne   DoCreate                 ProDOS 16 (GS/OS) - Do it!         lda   >MLI                     Double check         and   #$00FF                   Only want one byte         cmp   #$4C                     JMP instruction?         bne   WhatOS                   No - what the ?#$%^ OS is it?         lda   >MLIACTIV                Is MLI in use? (we ARE a CDA!)         bit   #$0080                   Test the 'active' bit         bne   WhatOS                   Treat the same as no OS         brl   P8Setup                  ProDOS 8 - Go that way!WhatOS   anop         brl   FileErr                  This will do the job;................................................................;; Create the file first;DoCreate anop        _CREATE CreatPrm                Create the save file         bcc   DoSave         cmp   #$47                     Duplicate pathname?         bne   FileErr                  No, so filename is OK         jsr   NextFile                 Next filename - this one exists already         bra   DoCreate                 Try again;................................................................;; Open the file, write the data and close the file;DoSave   anop        _OPEN OpenParm                  OPEN         bcs   FileErr         lda   OpenParm                 Get RefNum         sta   WritePrm                 Save it         sta   ClosePrm                 Save it        _WRITE WritePrm                 Write the file         bcs   FileErr        _CLOSE ClosePrm                 CLOSE         bcs   FileErr;................................................................;; Restore our registers and leave;Exit     anop         plbRTL      rtl;................................................................;; Routine for file handling errors (16 bit mode);FileErr  anop        _SysBeep                        Let user know         lda   ClosePrm                 File open? (ie. RefNum not zero)         beq   Exit                     No, skip close        _CLOSE ClosePrm                 CLOSE         bra   Exit;................................................................;; Routine to increment the file name since it already exists;NextFile anop         shortm         inc   Suffix+1                 Bump the 'units' digit         lda   Suffix+1         cmp   #'9'+1                   Increased past 9?         bne   NextExit                 No, so go try again         lda   #'0'                     Reset units to zero         sta   Suffix+1         inc   Suffix                   Now the 'tens' digit         lda   Suffix         cmp   #'9'+1                   Increased past 9?         bne   NextExit                 No, so go try again         longm         pla                            Drop the return address         bra   FileErr                  Oops, can't handle thatNextExit longm         rts                            Return to our caller;................................................................;; Setup and call our ProDOS 8 code in bank 0;;................................................................P8Setup  anop; Request a new userid         pha                            Result space         pea   $5100                    ID type (Desk accessory, aux=1)        _GetNewId                       Request new UserId         pullword MyId                  Save it; Now allocate the memory we need         pha                            Result...         pha                                  ...space         pushlong #Bank0Len             Size         pushword MyId                  UserId         pushword #$C008                Locked, No special memory         pushlong #0                    Location (unused)        _NewHandle                      Request the memory         pulllong MemHandle             Store the handle         lda   [MemHandle]              Dereference the handle         sta   MemBlock         ldy   #2         lda   [MemHandle],Y         sta   MemBlock+2; Save the existing bank zero data to our save buffer         php                            Save interrupt status         sei                            Disable interrupts         pushlong #Bank0Loc             Source address         pushlong MemBlock              Destination address         pushlong #Bank0Len             Length        _BlockMove                      Move it; Copy our code into bank zero         pushlong #ProDOS8              Source address         pushlong #Bank0Loc             Destination address         pushlong #P8End-P8Start        Length        _BlockMove                      Move it;................................................................;; Call our ProDOS 8 routine;         jsl   Bank0Loc                 Jump to it;................................................................;; Restore the borrowed bank 0 storage from our save buffer;         pushlong MemBlock              Source address         pushlong #Bank0Loc             Destination address         pushlong #Bank0Len             Length        _BlockMove                      Move it         plp                            Restore interrupt status; Free up the allocated memory, and return our userid         pushword MyId        _DisposeAll                     Free up all our allocated memory         pushword MyId        _DeleteId                       Delete the userid; Exit via our standard exit         brl   Exit;................................................................;; Data areas (16 bit mode);;................................................................EyeBall  dc    c'&SYSNAME v&VER - Copyright by Peter Watson &SYSDATE'MyId     ds    2                        UserId requested for ProDOS 8 codePathName str   'Screen.00'              Save filenameSuffix   equ   *-2                      Save filename suffixCreatPrm dp    PathName                 pathname         dc    i2'$C3'                  access (unlocked default)         dc    i2'$C1'                  file type (PIC)         dc    i4'0'                    aux type (Type 0)         dc    i2'1'                    storage type         dc    i2'0'                    create date         dc    i2'0'                    create timeOpenParm ds    2                        file refNum         dp    PathName                 pathname         dc    i4'0'                    reservedWritePrm ds    2                        file refNum         dc    i4'Screen'               data buffer         dc    i4'ScreenLen'            request count         ds    4                        transfer countClosePrm ds    2                        file refNum         end;................................................................;; ProDOS 8 save routine - will execute at $00/0B00;;................................................................ProDOS8  start         obj   Bank0LocP8Start  entry         phd                            Save D-page register         pea   0                        Set bank 0         pld                            New D-page         phb                            Save data bank         phk         plb                            New data bank         tsc                            Get stack pointer         tax         and   #$FF00                   High byte only         cmp   #$0100                   Page 1 stack?         beq   SaveSP                   Yes, leave it alone         lda   #$1FF                    Otherwise make it page 1         tcsSaveSP   phx                            Save original stack pointer         emulation                      Set emulation mode (e=1, x=1, m=1); Make sure no ProDOS problems by marking File Buffer as free in P8 bitmap         lda   Bitmap+1                 Get the byte         sta   BitmapByte               Save it         stz   Bitmap+1                 Free all the pages for simplicity; Make sure we have a valid prefix         stz   PfxFlag                  Say we don't have to restore prefix         lda   PREFLAG                  ProDOS 8 prefix already set?         bne   P8Create                 Yes, all OK already         jsr   CheckPfx                 Go check (and maybe set) it         bcs   GoP8Err                  Handle an error; Create the new fileP8Create anop        _P8_CREATE Cr_Parm         bcc   P8Save         cmp   #$47                     Duplicate pathname?         beq   NextName                 Yes, try another nameGoP8Err  brl   P8Error                  No, so some other error; Current name exists - move to the next nameNextName anop         inc   P8Suffix+1               Bump the 'units' digit         lda   P8Suffix+1         cmp   #'9'+1                   Increased past 9?         bne   P8Create                 No, so go try again         lda   #'0'                     Reset units to zero         sta   P8Suffix+1         inc   P8Suffix                 Now the 'tens' digit         lda   P8Suffix         cmp   #'9'+1                   Increased past 9?         bne   P8Create                 No, so go try again         bra   P8Error                  Oops, can't handle that; Open the fileP8Save   anop        _P8_OPEN O_Parm         bcs   P8Error         lda   O_RefNum                 Copy RefNum to Write and Close parms         sta   W_RefNum         sta   C_RefNum; Copy the screen image from bank $E1         lda   NEWVIDEO                 Get current value         pha                            Save it         ora   #$40                     Linearise hi-res mode         sta   NEWVIDEO         native                         Native mode with long registers         phb                            Save data bank         pushlong #Screen               Source = Screen buffer         pushlong #DataBuf              Target = Write buffer         pushlong #DataBufL             Buffer length        _BlockMove         plb                            Restore data bank         emulation         pla                            Recover old value         sta   NEWVIDEO                 And restore it; Write it out        _P8_WRITE W_Parm         bcs   P8Error; Close the file        _P8_CLOSE C_Parm         bcs   P8Error         stz   C_RefNum; If we set a prefix, remove it again         lda   PfxFlag                  Prefix set?         beq   P8Exit                   No, skip fixup        _P8_SET_PREFIX Nil_Parm         We only set it if there wasn't one!         bcs   P8Error; Return to our callerP8Exit   anop         lda   BitmapByte               Restore bitmap byte         sta   BitMap+1         native                         Set native mode (e=0, m=0, x=0)         plx                            Entry stack pointer         txs                            Restore it         plb                            Entry data bank         pld                            Entry D-page         rtl                            'long' return to our caller;................................................................;; P8Error - Routine for ProDOS 8 file handling errors         longa off         longi offP8Error  anop         jsr   BELL                     Let user know         lda   C_RefNum                 File open? (ie. RefNum not zero)         beq   ChkPfx                   No, skip close        _P8_CLOSE C_ParmChkPfx   lda   PfxFlag                  Prefix set?         beq   P8Exit                   No, skip fixup        _P8_SET_PREFIX Nil_Parm         We only set it if there wasn't one!         bra   P8Exit;................................................................;; CheckPfx - Routine for ensuring we have a valid PREFIX;; Use BASIC.SYSTEM default slot/drive (if present), else last ProDOS 8 unit.CheckPfx anop         ldy   #$0C                     Five JMP's start the BI Global Page         lda   #$4C                     JMP instructionCheckBI  cmp   BIGlobal,Y               Should be!         bne   NotBI         dey         dey         dey         bpl   CheckBI; Looks like BASIC.SYSTEM is there         lda   CURDRIVE                 Get default drive (1 or 2)         dec   A                        (0 or 1)         lsr   A                        Move to carry         ror   A                        Move to high bit of Acc         sta   On_Unit                  Save it         lda   CURSLOT                  Get default slot         asl   A                        Move to high nibble         asl   A         asl   A         asl   A         ora   On_Unit                  Insert 'drive' bit         bra   GetPrefix; Only ProDOS 8 itself (that we know about)NotBI    anop         lda   LASTDEV                  Get last accessed unit; Now issue an Online call to get the volume nameGetPrefix anop         sta   On_Unit                  Store in parm list        _P8_ONLINE On_Parm         bcs   PfxError         lda   VolBuf                   Did we find a volume name?         and   #$0F                     Strip unit info         beq   PfxError                 No volume name!         tax                            Make into an index         inc   A                        Allow for leading '/'         sta   PfxBuf                   Store in length byteCopyPfx  lda   VolBuf,X                 Copy into prefix buffer         sta   PfxBuf+1,X         dex         bne   CopyPfx         lda   #'/'                     Leading '/'         sta   PfxBuf+1; Finally, set the prefix        _P8_SET_PREFIX Pfx_Parm         bcs   PfxError         inc   PfxFlag                  Ensure we remove it later         clc                            Flag no error         rtsPfxError sec                            Flag error         rts;................................................................;; Data areas (8 bit mode);;................................................................BitMapByte ds  1                        Saved byte from P8 bitmapCr_Parm  dc    i1'7'                    pCount         dc    i2'P8File'               pathname         dc    i1'$C3'                  access (unlocked default)         dc    i1'$C1'                  file type (PIC)         dc    i2'0'                    aux type (Type 0)         dc    i1'2'                    storage type (sapling)         dc    i2'0'                    create date         dc    i2'0'                    create timeP8File   str   'Screen.00'              Save filenameP8Suffix equ   *-2                      Save filename suffixO_Parm   dc    i1'3'                    pCount         dc    i2'P8File'               pathnameO_Buf    dc    i2'FileBuf'              file bufferO_RefNum ds    1                        file refNumW_Parm   dc    i1'4'                    pCountW_RefNum ds    1                        file refNum         dc    i2'DataBuf'              data buffer         dc    i2'DataBufL'             request count         ds    2                        transfer countC_Parm   dc    i1'1'                    pCountC_RefNum ds    1                        file refnumPfxFlag  ds    1                        0 = Prefix already set; 1 = we set itOn_Parm  dc    i1'2'                    pCountOn_Unit  ds    1                        unitNum         dc    i2'VolBuf'               data bufferPfx_Parm dc    i1'1'                    pCount         dc    i2'PfxBuf'               pathnameNil_Parm dc    i1'1'                    pCount         dc    i2'NullBuf'              pathnameVolBuf   ds    16                       Volume buffer      (ONLINE)PfxBuf   ds    17                       Prefix buffer      (SET_PREFIX)NullBuf  dc    i1'0'                    No prefix required (SET_PREFIX); Consistency check         lcla  &codelen         lcla  &check&codelen seta  CodeLen&check   seta  *-P8Start         aif   &check<&codelen,.checkEnd         mnote 'ProDOS 8 code length (&check) more than &codelen bytes',8.checkEndP8End    entry         objend         end