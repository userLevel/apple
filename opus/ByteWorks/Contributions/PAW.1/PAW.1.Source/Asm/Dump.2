;.......................................;; This file is 'APPEND'ed onto the DUMP.1 source file.;; Copyright 1989-1999 by Peter Watson.;;.......................................;; GetToken - Look for the next command line token, if any.; ========   Maximum token length is normally 64 characters.;	    Quoted strings including spaces are honoured (without the quotes).;	    (Embedded quotes must be doubled).;	    Tokens ending in <cr> have it ignored (eg. ProSel command lines).;; On entry, Y = offset into command line pointed to by [ParmPtr];           m = 1 (8 bit accumulator mode); On exit,  ParmBuf contains the parameter;           ParmLen contains the length;           Y = offset of last token char + 1;           Exit via RTS; On error, GOTO ParmErr;GetToken	procname GetToken         longa off; Blank the parameter buffer for safety         ldx   #L:ParmBuf-1         lda   #' '	sta	GTDelim	Default delimiter is ' 'BlankIt  sta   ParmBuf,X         dex         bpl   BlankIt         stz   ParmLen                  Ensure parm length = 0         ldx   #0               ; Skip any leading blanks, and handle quoted parametersSkipBlnk anop         lda   [ParmPtr],Y         beq   GTExit                   End of string         cmp   #' '                     Non-blank yet?         bne   SkipDone                 Found first operand byte         iny         bne   SkipBlnkSkipDone anop	cmp	#'"'	Double quote?	beq	Quote	No	cmp	#"'"	Single quote?	bne	Qdone	NoQuote	sta	GTDelim	Use as delimiter         iny		Skip quote         lda   [ParmPtr],Y	Get next char	cmp	GTDelim	Empty quoted string?	beq	CopyDoneQDone	anop                                     ; Transfer the parameter to our bufferCopyTokn anop         sta   ParmBuf,X                Fill the parm buffer         inx                            Bump ParmBuf index         cpx   #L:ParmBuf               Token too long?         blt   CopyTok2                 No         pla                            Pop the...         pla                            ...return address         brl   ParmErrCopyTok2 iny                            Bump parm index         lda   [ParmPtr],Y         beq   CopyDone                 End of string - done!         cmp   GTDelim                  Delimiter?         bne   CopyTokn                 No, not done yet	cmp	#' '	Special case for ' ' delimiter?	beq	CopyDone	Yes	iny		Else skip over it         lda   [ParmPtr],Y         cmp   GTDelim                  Repeated delimiter?         beq   CopyTokn                 Yes, go store it for realCopyDone anop         txa                            Convert to 8 bits!!!         sta   ParmLen                  Save parameter length; Ensure no trailing <CR> from ProSel command lines	lda	ParmBuf-1,X	Get last char	cmp	#CR	<CR>?	bne	GTExit	No, all is OK	dec	ParmLen	Shrink the parameter lengthGTExit	anop         aif   .NOT.&Debug,.NoShowTok	longm         pha	phx	phy	writestr #'Token=['         writestr ParmLen	That is, display the buffer	writeln  #']'	ply	plx	pla	shortm.NoShowTok	rts         longa onGTDelim	ds	1	Current delimiter (' ' or '"' or "'");........................................;; GetOffset - Extract and convert the operand of the -O parameter.; =========;; On entry, Y = offset into command line;           m = 1 (8 bit accumulator mode); On exit,  StrtByte contains a 4-byte offset into the file;           Y = offset of last char + 1 of offset value;           Exit via RTS; On error, GOTO ParmErr2;GetOffset procname GetOffset         phy                            Save Y-reg         longm         pushlong #0                    Result space         lda   ParmBuf                  Get 1st character         and   #$007F                   1 byte value!         cmp   #'$'                     Hex offset?         beq   CvtHex         pushlong #Parmbuf              String address         lda   Parmlen         and   #$007F                   1 byte value!         pha                            String length         pea   0                        Unsigned        _Dec2Long                       Convert string to a long integer         bra   PullLongCvtHex   pushlong #Parmbuf+1            String address         lda   Parmlen         and   #$007F                   1 byte value!         dec   A         pha                            Length to convert        _Hex2Long                       Convert string to a long integerPullLong anop         pulllong StrtByte              Store in Set_Mark position parm         bcc   GetOExit                 Conversion error?         ply         pla                            Pop the return address         brl   ParmErr2                 Invalid offset valueGetOExit anop         shortm                         For caller         ply         rts         longa on;........................................;; GetTabWid - Extract and convert the operand of the -I parameter.; =========;; On entry, Y = offset into command line;           m = 1 (8 bit accumulator mode); On exit,  TabWidth contains a 2-byte default tab stop width;           Y = offset of last char + 1 of offset value;           Exit via RTS; On error, GOTO ParmErr3;GetTabWid procname GetTabWid         phy                            Save Y-reg         longm         pha		Result space         pushlong #Parmbuf              String address         lda   Parmlen         and   #$007F                   1 byte value!         pha                            String length         pea   0                        Unsigned        _Dec2Int                        Convert string to an integer         pla		Retrieve converted value         sta	TabWidth	Store in tab width variable	ply         bcc   GetIExit                 Conversion error?GoParmE3 pla                            Pop the return address	brl   ParmErr3                 Invalid offset valueGetIExit anop	cmp	#2	Reasonable value?	bcc	GoParmE3	No	cmp	#L:LineC	Reasonable value?	bcs	GoParmE3	No         shortm                         For caller         rts         longa on;.......................................;; ParmErr - Print error messages for invalid parameters; =======ParmErr  procname ParmErr	longm         writeln         writestr #'Error: Parameter token length more than &MaxBuf characters!'         writeln         brl   Prompt                   Go get a decent parmParmErr1 longm         writeln         writestr #'Error: Unknown parameter option ('ShowErr  writestr ParmLen               Write unknown char(s)         writeln  #')!'         lda   #$FFFF                   Set error code         brl   Exit2ParmErr2 longm         writeln         writestr #'Error: Invalid operand for -O or -@ option ('         brl   ShowErrParmErr3 longm         writeln         writestr #'Error: Operand for -I option not an integer from 2 to 79 ('         brl   ShowErr;.......................................;; FixFName - Copy pathname, converting ':' separators in the filename to '/'; ========;	    On entry, assumes m=x=0;	    On exit, ShowBuf contains a 'fixed' copy of PathBufFixFName procname FixFName	lda	#0	Ensure high byte of Acc is clear	shortm	lda	PathBuf   	Get length byte	sta	ShowBuf	Save in copy buffer	beq	FixFNexit	Nothing else to do for empty names	tax		Copy to index registerFxFNLoop	anop	lda	PathName,X	Get pathname character	cmp	#':'	Does it need conversion?	bne	FixFNok	No, go look at next character	lda	#'/'FixFNok	anop	sta	ShowPath,X	Set the new separator character	dex	bpl	FxFNLoop	Loop if still more to doFixFNexit anop	longm	rts;.......................................;; DispCHi - Convert a high-ASCII character to a string of one or more chars; =======   'JSR' entry;; On entry, Y = offset into command line;           m = 1 (8 bit accumulator mode); On exit,  LineC will be updated;           Y = offset of last char + 1 of offset value;           Exit via RTS if char is not high ASCII;           Exit via labels DoWriteC or SkipIt3C if char is high ASCII; No error exit;	longa	offDispCHi  procname DispCHi	cmp	#$80	High bit set?	bcs	DispCHi2	Yep	rts		Else just returnDispCHi2	anop	sta	LastChar	Remember this character	longm         and   #$007F	Strip high bit and byte	asl	A	Double	asl	A	Double again = Multiply by 4	tax		Make into an offset into HighTabl	lda	HighTabl,X	Get replacement character	cmp	#1	Easy convert?	bne	DispCHiX	Yes, Acc = Replacement char (0=Ignore)	lda	HighTabl+2,X	Get replacement data address         sta   Work; Don't check length as LineC has slip space on the end - so what if we wrap!	shortm	phy		Preserve caller's Y-reg	ldy	#0	ldx	CharIndxDispCHiL	anop	lda	(Work),Y	Get character of string	beq	DispCHiD	End of data	sta	LineC,X	inx	iny	bra	DispCHiL	Go get next character; Return to caller having inserted replacement string in output lineDispCHiD	anop	stx	CharIndx	ply		Restore caller's Y-reg         pla		Remove return address	pla         cpx   #L:LineC                 Finished a line?         blt   GoSkIt3C	brl	DoWriteC	Yes, write it outGoSkIt3C	brl	SkipIt3C	No, skip to next character; Return to caller with replacement char in Acc; (If Acc=0, it will be stripped by normal Control-Char handling)DispCHiX	anop	shortm	rts; Hi-ASCII Table (based on MiscTools 'StringToText' tool call);;Each entry is 4 bytes;	First word:;	= 0 - Ignore this character;	= 1 - Bytes 2 and 3 are the address of a replacement CString;	> 1 - Replacement character;	Second word:;	= Address of replacement string (or 0)                    HighTabl	anopH80	dc	c'A',i1'0',a'0'H81	dc	c'A',i1'0',a'0'H82	dc	c'C',i1'0',a'0'H83	dc	c'E',i1'0',a'0'H84	dc	c'N',i1'0',a'0'H85	dc	c'O',i1'0',a'0'H86	dc	c'U',i1'0',a'0'H87	dc	c'a',i1'0',a'0'H88	dc	c'a',i1'0',a'0'H89	dc	c'a',i1'0',a'0'H8A	dc	c'a',i1'0',a'0'H8B	dc	c'a',i1'0',a'0'H8C	dc	c'a',i1'0',a'0'H8D	dc	c'c',i1'0',a'0'H8E	dc	c'e',i1'0',a'0'H8F	dc	c'e',i1'0',a'0'H90	dc	c'e',i1'0',a'0'H91	dc	c'e',i1'0',a'0'H92	dc	c'i',i1'0',a'0'H93	dc	c'i',i1'0',a'0'H94	dc	c'i',i1'0',a'0'H95	dc	c'i',i1'0',a'0'H96	dc	c'n',i1'0',a'0'H97	dc	c'o',i1'0',a'0'H98	dc	c'o',i1'0',a'0'H99	dc	c'o',i1'0',a'0'H9A	dc	c'o',i1'0',a'0'H9B	dc	c'o',i1'0',a'0'H9C	dc	c'u',i1'0',a'0'H9D	dc	c'u',i1'0',a'0'H9E	dc	c'u',i1'0',a'0'H9F	dc	c'u',i1'0',a'0'HA0	dc	i'0',a'0'HA1	dc	i'0',a'0'HA2	dc	c'c',i1'0',a'0'HA3	dc	i'1',a'sHA3'	Pound Sterling (Removed by StringToText)HA4	dc	i'0',a'0'HA5	dc	c'*',i1'0',a'0'HA6	dc	i'0',a'0'HA7	dc	i'1',a'sHA7'HA8	dc	i'1',a'sHA8'HA9	dc	i'1',a'sHA9'HAA	dc	i'1',a'sHAA'HAB	dc	c'''',i1'0',a'0'	Single quoteHAC	dc	i'0',a'0'HAD	dc	i'1',a'sHAD'HAE	dc	i'1',a'sHAE'HAF	dc	c'0',i1'0',a'0'	Character '0'HB0	dc	i'1',a'sHB0'	Infinity (Removed by StringToText)HB1	dc	i'1',a'sHB1'HB2	dc	i'1',a'sHB2'HB3	dc	i'1',a'sHB3'HB4	dc	c'Y',i1'0',a'0'HB5	dc	c'u',i1'0',a'0'HB6	dc	i'0',a'0'HB7	dc	i'0',a'0'HB8	dc	i'0',a'0'HB9	dc	i'1',a'sHB9'	Pi (Removed by StringToText)HBA	dc	i'0',a'0'HBB	dc	c'a',i1'0',a'0'HBC	dc	c'o',i1'0',a'0'HBD	dc	c'O',i1'0',a'0'HBE	dc	i'1',a'sHBE'HBF	dc	c'0',i1'0',a'0'	Character '0'HC0	dc	c'?',i1'0',a'0'HC1	dc	c'!',i1'0',a'0'HC2	dc	c'!',i1'0',a'0'	EBCDIC Not (Removed by StringToText)HC3	dc	i'1',a'sHC3'	Square Root (Removed by StringToText)HC4	dc	c'f',i1'0',a'0'HC5	dc	i'0',a'0'HC6	dc	i'0',a'0'HC7	dc	i'1',a'sHC7'HC8	dc	i'1',a'sHC8'HC9	dc	i'1',a'sHC9'HCA	dc	c' ',i1'0',a'0'	SpaceHCB	dc	c'A',i1'0',a'0'HCC	dc	c'A',i1'0',a'0'HCD	dc	c'O',i1'0',a'0'HCE	dc	i'1',a'sHCE'HCF	dc	i'1',a'sHCF'HD0	dc	c'-',i1'0',a'0'HD1	dc	i'1',a'sHD1'HD2	dc	c'"',i1'0',a'0'HD3	dc	c'"',i1'0',a'0'HD4	dc	c'''',i1'0',a'0'	Single quoteHD5	dc	c'''',i1'0',a'0'	Single quoteHD6	dc	c'/',i1'0',a'0'	Division sign (removed by StringToText)HD7	dc	i'0',a'0'HD8	dc	c'y',i1'0',a'0'HD9	dc	c'Y',i1'0',a'0'HDA	dc	c'/',i1'0',a'0'HDB	dc	c'o',i1'0',a'0'HDC	dc	c'<',i1'0',a'0'HDD	dc	c'>',i1'0',a'0'HDE	dc	i'1',a'sHDE'HDF	dc	i'1',a'sHDF'HE0	dc	c'|',i1'0',a'0'	StringToText returns unchangedHE1	dc	c',',i1'0',a'0'HE2	dc	c'.',i1'0',a'0'HE3	dc	i'1',a'sHE3'HE4	dc	c'%',i1'0',a'0'	StringToText returns unchangedHE5	dc	c'A',i1'0',a'0'HE6	dc	c'E',i1'0',a'0'HE7	dc	c'A',i1'0',a'0'HE8	dc	c'E',i1'0',a'0'HE9	dc	c'E',i1'0',a'0'HEA	dc	c'I',i1'0',a'0'HEB	dc	c'I',i1'0',a'0'HEC	dc	c'I',i1'0',a'0'HED	dc	c'I',i1'0',a'0'HEE	dc	c'O',i1'0',a'0'HEF	dc	c'O',i1'0',a'0'HF0	dc	i'0',a'0'HF1	dc	c'O',i1'0',a'0'HF2	dc	c'U',i1'0',a'0'HF3	dc	c'U',i1'0',a'0'HF4	dc	c'U',i1'0',a'0'HF5	dc	c'i',i1'0',a'0'; StringToText returns following chars (they are accent marks) unchangedHF6	dc	i'0',a'0'HF7	dc	i'0',a'0'HF8	dc	i'0',a'0'HF9	dc	i'0',a'0'HFA	dc	i'0',a'0'HFB	dc	i'0',a'0'HFC	dc	i'0',a'0'HFD	dc	i'0',a'0'HFE	dc	i'0',a'0'HFF	dc	i'0',a'0'; Conversion strings (null terminated)sHA3	dc	c'Stg',i1'0'	Pound Sterling symbolsHA7	dc	c'ss',i1'0'sHA8	dc	c'(R)',i1'0'sHA9	dc	c'(C)',i1'0'sHAA	dc	c'(TM)',i1'0'sHAD	dc	c'<>',i1'0'sHAE	dc	c'AE',i1'0'sHB0	dc	c'inf',i1'0'	InfinitysHB1	dc	c'+-',i1'0'sHB2	dc	c'<=',i1'0'sHB3	dc	c'>=',i1'0'sHB9	dc	c'(pi)',i1'0'	pi = 3.14159sHBE	dc	c'ae',i1'0'sHC3	dc	c'sqrt',i1'0'	Square rootsHC7	dc	c'<<',i1'0'sHC8	dc	c'>>',i1'0'sHC9	dc	c'...',i1'0'sHCE	dc	c'OE',i1'0'sHCF	dc	c'oe',i1'0'sHD1	dc	c'--',i1'0'sHDE	dc	c'fi',i1'0'sHDF	dc	c'fl',i1'0'sHE3	dc	c',,',i1'0'                   ;.......................................;;      STOP_PAUSE;;  Handles key press pause and resume, AND CANCEL;;  *** Special version for DUMP recognises '?' and JSL's to label ShowInfo;;  Returns 1 for Open-Apple-Period;          2 for Option-Period;;  Example of use :-;;      JSL   STOP_PAUSE                 ;Look for keypress or Apple-Period;      CMP   #1                         ;Apple-Period pressed;      BEQ   Exit                       ;Yes, so exit;      CMP   #2                         ;Option-Period pressed;      BEQ   Exit                       ;Yes, so exit;      ...;  SHOWINFO anop	;Routine invoked if '?' pressed;      PHB;      PHK;      PLB;      ...;      PLB;      RTL;               ;.......................................;;  Source code based on APW V1.0 reference manual, P.215.;;  v1.0  Modified to preserve X and Y registers; and support Option-Period.;  v1.1  Display an 'hourglass' icon while paused.;  v1.11 Call 'ShowInfo' if '?' or '/' pressed while pausing;;.......................................         case    on         msb     on                     Need high bit on for comparesSTOP_PAUSE procname STOP_PAUSE	phb	phk	plb         php                            Save m & x flag status         sep   #$20         longa off                      Change to 8 bit memory/accumulator mode         lda   #$00                     Preset default result...         xba		...in high bits as well         lda   $E1C000                  test for keypress	bmi	GotKey1	lda	#0	Clear key pressed         brl   Done                     no keypress, so all doneGotKey1	anop         cmp   #'.'                     Test for period (high bit still set)         bne   Key                      No, just treat as a 'pause' request	lda   $E1C025                  Look for Open-Apple/Option modifiers	sta	CharMod	Save in local storage for BIT	bit   CharMod                  Look for Open-Apple/Option modifiers         bvs   HaltSet                  Look for Option modifier         bmi   StopSet                  Look for Apple  modifierKey      anop		A key was pressed!	phx		Preserve x & y regs	phy	php		Preserve 8-bit status         rep   #$30	16-bit mode for tool calls!	longa on	~WriteCString #WaitMsg	plp		Restore 8-bit mode	longa off                  Loop0	lda   $E1C010                  Reset strobeLoop     lda   $E1C000                  Test for keystroke...         bpl   Loop	...until one is pressed	cmp	#'/'	Unshifted '?' key?	beq	WantInfo	Yes, request for ShowInfo	cmp	#'?'	Shifted '?' key?         bne   GotKey2                  No, handle as a normal keypress; '?' key pressed - call user 'ShowInfo' routine to print a line of dataWantInfo	anop	php		Save 8-bit status         rep	#$30	16-bit mode for safety	jsl	SHOWINFO	Call the user 'ShowInfo' routine	plp		Restore 8-bit mode	longa off         bra   Loop0	Continue waiting; Clear hourglass (and 'info' line, if any)     GotKey2	anop	pha		Save character	php		Preserve 8-bit status         rep   #$30	16-bit mode for tool calls!	longa on	~WriteCString #GoMsg	plp		Restore 8-bit mode	longa off	pla   	Get character	ply	plx; Did user press 'stop' key during pause?         cmp   #'.'                     Test for period (high bit still set)         bne   NoneSet                  No, so simply exit	lda   $E1C025                  Look for Open-Apple/Option modifiers	sta	CharMod	Save in local storage for BIT	bit   CharMod                  Look for Open-Apple/Option modifiers         bvs   HaltSet                  Look for Option modifier         bmi   StopSet                  Look for Apple  modifierNoneSet  lda   #0                       Restore default result         bra   Out                      and leaveHaltSet  lda   #2                       Return value for stop of ALL files         bra   OutStopSet  lda   #1                       Set return value for STOPOut      sta   $E1C010                  Reset strobe always	bra	DoneDone     anop         plp                            Back to 16 bit mode (maybe)	plb         rtl                            Return to our callerCharMod	ds	2	Save value of $E1C025 (char modifiers)WaitMsg	dc	i1'31,13,27,15,67,14,24,0'	Mousetext hourglassGoMsg	dc	i1'31,13,29,0'	Erase line from beginning;...............................................................;; SHOWINFO - Display some status info if '?' pressed while paused;	    Also displayed after I/O errors.;;...............................................................	longa	on	longi	onSHOWINFO	procname ShowInfo	~Long2Hex Address,#InfoAddH,#L:InfoAddH	~Long2Hex EOF,#EOFH,#L:EOFH	~Long2Dec Address,#InfoAddD,#L:InfoAddD,#0	~Long2Dec EOF,#EOFD,#L:EOFD,#0	~WriteCString #InfoMsg1	Display title and offset details         writestr ShowBuf               Display current pathname	~WriteCString #InfoMsg2	Write conclusion	rtlInfoMsg1	anop	dc  	i1'31,13,15'	Start of line and inverse text	dc	c' Offset: $'InfoAddH	dc	c'000000'	dc	c'/'EOFH	dc	c'000000'	dc	c' ('InfoAddD	dc	c'00000000'	dc	c'/'EOFD	dc	c'00000000'	dc	c')   File: '	dc	i1'0'InfoMsg2	anop		End of line and normal text	dc	c' '	dc	i1'14,0'        ;...............................................................;; Restore case and MSB settings!;         case    off         msb     off                    Need high bit on for compares; end of DUMP.2