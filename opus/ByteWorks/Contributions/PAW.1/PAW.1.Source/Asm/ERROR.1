         mcopy error.mac         gen   on;................................................................;; ERROR - APW shell utility to display an error message for the;         supplied error code (GS/OS or Toolbox), using the Shell's;         own error message routine. The Shell does not have a message;         for all codes, but what it has is a lot better than nothing!;         Code should be reusable/restartable.;;         Syntax:  ERROR  error_code;           (will prompt if error_code omitted);;         Copyright by Peter Watson, December 1988.;;................................................................         longa on         longi onERROR    startParmPtr  equ   0                        Offset into direct page         phb         phk         plb                            Make data bank = program bank         sty   ParmPtr                  Save parameter...         stx   ParmPtr+2                ...address on entry; Start the Integer Math toolset, just in case it wasn't started by the locator        _IMStartUp                      Start integer math toolset;................................................................;; First check for the Id string from APW or ORCA/M;;................................................................         ldy   #L:IdString-2ChkId    lda   [ParmPtr],Y              Check for legit parameter...         cmp   IdString,Y               ...starting with 'BYTEWRKS'         beq   *+5         brl   NotShell         dey         dey         bpl   ChkId;................................................................;; Now we can look for our real command operand (Skip command name first);;................................................................         short                          8-bit memory & registers         ldy   #L:IdString              Point to first byte of command lineLook1    anop         lda   [ParmPtr],Y              Get character         beq   Prompt                   End of string - Not enough!         cmp   #' '                     End of command yet?         beq   Look2                    Yes, Go skip some blanks         iny         bne   Look1Look2    anop         lda   [ParmPtr],Y              Get character         beq   Prompt                   End of string         cmp   #' '                     Non-blank yet?         bne   LookDone                 Found first operand byte         iny         bne   Look2LookDone anop         stz   CodeLen                  Initialise code length for reuse;................................................................;; Transfer the parameter to the error code buffer;;................................................................         ldx   #0                       Initialise offset into CodeBufLoop3    anop         sta   CodeBuf,X                Fill the error code buffer         inx                            Bump CodeBuf index         cpx   #L:CodeBuf               Error code too long?         blt   *+5         brl   ParmErr                  Yes, go whinge about it         inc   CodeLen                  Increment length         iny                            Bump Parameter index         lda   [ParmPtr],Y              Get next character         bne   Loop3                    Not done yet         long                           16 bit memory & registers         brl   GotCode                  Continue processing;................................................................;; Prompt the caller for an error code;;................................................................Prompt   anop         long                           16 bit memory & registers         writeln         writestr #'Enter error code (0 to $FFFF) >'         pea   0                        Result - Character count         pushlong #CodeBuf              Code buffer         pea   L:CodeBuf                Maximum line length+1 for ease-of-use         pea   13                       End-of-Line character = <Return>         pea   1                        1 = Echo characters        _ReadLine;; Store the length - if zero, then exit;         writeln                        Move to new line after answer         pla                            Get character count         bne   ReadOK         brl   Exit                     None, time to goReadOK   anop         shortm         sta   CodeLen                  Store length         longm;................................................................;; Convert the code from character to integer - hex only, leading '$' optional;;................................................................GotCode  anop         pea   0                        Space for Hex2Int result         ldx   CodeLen                  Get length         lda   CodeBuf                  Look at first character         and   #$007F                   Ignore second byte and high bit         cmp   #'$'                     Leading '$' sign (to be ignored)         bne   NoDollar         pushlong #CodeBuf+1            String address         dex                            String is now shorter         bra   CvtHexNoDollar pushlong #CodeBuf              String addressCvtHex   anop         cpx   #5                       Maximum of 4 characters allowable         bge   CvtError                 Ooops, too long         phx                            String length        _Hex2Int                        Convert string to integer         bcc   TellUserCvtError anop         pla                            Ignore result         writech #$07                   Bell character         writeln #'Invalid characters, or error code too long - please re-enter'         brl   Prompt                   Go prompt for code again;................................................................;; Finally we can get the Shell to tell us what the problem was;;................................................................TellUser anop         pullword ErrCode               Place in parameter list        _Error ErrCode;................................................................;; Exit - Return to our caller;;................................................................Exit     anop         lda   #0                       Set a good return codeExit2    anop         pha                            Save return code        _IMShutDown                     Shut down integer math toolset         pla                            Restore return code         plb                            Restore data bank        _Quit QuitParm                  Return to our caller (Shell traps Quit);................................................................;; ToolErr - Print an error message after a tool or OS error, then exit;;................................................................ToolErr  anop         sta   ErrCode         writeln #'Internal &SYSNAME error :-'        _Error ErrCode         lda   ErrCode                  Restore error code for us         bra   Exit2;................................................................;; Return to someone other than a Shell-based caller;; Display a text-based alert dialogue first;;................................................................NotShell anop         pea   0                        Result - Button that was pressed         pushlong #MsgLine1         pushlong #MsgLine2         pushlong #MsgBut1         pushlong #MsgBut2        _TLTextMountVolume         pla                            Ignore the result         brl   Exit;................................................................;; ParmErr - Print an error message for a parameter that is too long;;................................................................ParmErr  anop         long                           16 bit memory & registers         writeln         writestr ParmMsg               'Parameter too long'         brl   Prompt                   Go get a decent parameter;................................................................;; Data areas;;................................................................IdString dc    c'BYTEWRKS'              Shell id stringEyeball  dc    c'&SYSNAME - Copyright Peter Watson, &SYSDATE &SYSTIME'ParmMsg  str    'Parameter length more than 5 characters'CodeBuf  dc    6c' '                    Buffer to hold input error codeCodeLen  dc    i'0'                     Actual length of inputErrCode  ds    2                        Error code in integer formatQuitParm dp    0                        Pathname (return via quit stack)         dc    i'0'                     FlagsMsgLine1 str   '  &SYSNAME must be called from'MsgLine2 str   '  the APW or ORCA shell!'MsgBut1  dc    i1'13',i1'27,15',c'M',i1'14,24',c' = Oops!'MsgBut2  str   'Esc = Cancel'         end