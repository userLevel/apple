         mcopy getil.mac         gen   on;................................................................;; GETIL - Shell utility to display the interleave of a 3.5" disk.;         Also displays 'single/double sided' status.;         Return codes 1-16 are the interleave value, else ProDOS error.;;         Nb: Relies on an UNSUPPORTED location (works on ROM 01 and ROM 03);;         Syntax:  GETIL device.or.volume;            (will prompt if device omitted);;         Requires the following <INC>lude files (or object modules) :-;           ReadLn.INC                  ReadLn Subroutine;;         V1.0 - Copyright by Peter Watson, May 1991;;...... ..........................................................         longa on         longi onGETIL    start         gblc  &VER         gblc  &MaxDBuf         gblb  &Debug&VER     setc  '1.0'                    Program version&MaxDBuf setc  '32'                     Maximum device name buffer size&debug   setb  0                        Debug mode OFFParmPtr  equ   0                        Offset into direct pageInterleave equ $E10F31 ***Unspported*** Interleave of last 3.5" disk read;................................................................         phk         plb                            Make data bank = program bank         ora   #$0100                   Make the UserId unique to us         sta   UserId                   Save supplied userid         sty   ParmPtr                  Save parameter...         stx   ParmPtr+2                ...address on entry         stz   DevBuf                   Initialise device name length; Start some toolsets, just in case they weren't started by the Tool Locator        _IMStartUp                      Start Integer Math toolset         writeln         writeln HelloMsg               Announce ourselves to the world         writeln;................................................................;; Set the Input Global parameters to remove the high bit from input.; The Shell does this for us, but let's be safe.;;................................................................         pushlong #0                    Result space        _GetInGlobals                   Leave result on stack for exit         pea   $7F                      AND mask - strip high bit         pea   $00                      OR  mask - don't change        _SetInGlobals;................................................................;; Check that we have a command line;;................................................................         lda   ParmPtr                  X = Y = 0?         ora   ParmPtr+2                Did we get a parm?         bne   *+5         brl   NotShell                 No, go exit now;................................................................;; Now we can look for our real command operand (Skip command name first);;................................................................         stz   ParmLen                  Ensure high byte is zero (Memory)         lda   #0                       Ensure high byte is zero (Acc)         shortm                         8-bit accumulator & memory         ldy   #8                       Point to first byte of command line data         jsr   GetToken                 Skip our command name;................................................................;; Transfer the first parameter to the device name buffer;;................................................................         jsr   GetToken                 Get name         lda   ParmLen                  Get parameter length         sta   DevBuf                   Store in length byte         bne   *+5         brl   Prompt1                  No pathname, go prompt         cmp   #&MaxDBuf+1              Too long?         blt   *+5         brl   ParmErr2                 Tell the user         tax                            Transfer 16 bits         dexLoop1    anop         lda   ParmBuf,X                Get next character         sta   DevBuf+1,X               Fill the device name buffer         dex                            Bump DevBuf index         bpl   Loop1                    Not done yet         brl   GotParms                 We now have all parameters;................................................................;; Prompt the caller for a device name, if necessary;;................................................................Prompt1  anop         longm                          16 bit memory         writeln         writestr #'Name of device to read interleave from >'         pushlong #DevBuf+1             Device name buffer         pea   &MaxDBuf                 Maximum line length         jsl   ReadLn                   Go get a line; Store the length - if zero, then exit         writeln                        Move to next line         writeln         pla                            Get character count         bne   *+5         brl   Exit                     None, time to go         shortm         sta   DevBuf;................................................................;; If he entered a volume name for the 'device name', we must convert it.; In any case, we need a device 'number' for Read_Block.;;................................................................GotParms anop         longm        _Get_Dev_Num GDNoParm           Get the device number         bcc   *+5         brl   ToolErr                  ...if possible;................................................................;; Read a block of the disk to ensure we have updated the interleave value;;................................................................DoVolume anop        _Read_Block RBParm              Read a block to force update of byte         bcc   ReadOK                   Lot's of choice with errors here         cmp   #$52                     Unsupported volume type?         beq   ReadOK                   Yes, who cares?         brl   ToolErr                  No,  use our standard error handlerReadOK   anop;................................................................;; Finally, get the interleave and display it to the user.; The format of the byte is : ..s. iiii;        where 's' is the no. of sides (0=single sided, 1=double sided);        and 'iiii' is the interleave value (0-15);;................................................................         lda   #0                       Clear high byte         shortm         lda   InterLeave               Read the byte         longm         pha                            Save for no. of sides message         and   #$000F                   Want interleave value only         sta   ErrCode                  Save for reading by the Shell         pha                            Push value         pushlong #ILeave+1             Target string address after length byte         pea   2                        Target string length         pea   0                        Unsigned string        _Int2Dec                        Convert address to Decimal         writestr #'The interleave value on '         writestr DevBuf         writestr #' is '         writestr ILeave         writeln #':1'         pla                            Retrieve the byte again         and   #$0020                   Want 'sides' value only         beq   Single         lda   #'od'                    'do'uble sided         sta   SidesTxt         lda   #'bu'                    do'ub'le sided         sta   SidesTxt+2         bra   WriteSidesSingle   anop         lda   #'is'                    'si'ngle sided         sta   SidesTxt         lda   #'gn'                    si'ng'le sided         sta   SidesTxt+2WriteSides anop         writeln SidesMsg               Tell the user         lda   ErrCode                  Get the interleave value         bra   Exit2                    Use it as the return code;................................................................;; Exit - Return to our caller;;................................................................Exit     anop         lda   #0Exit2    anop         sta   ErrCode                  Save for exit        _SetInGlobals                   Parameters already on stack        _IMShutDown                     Close down the Integer Math toolset         lda   ErrCode                  Load return code (if any)        _Quit  QuitParm                 Return to our caller (Shell traps Quit);................................................................;; Return to someone other than a Shell-based caller;; Display a message dialogue first;;................................................................NotShell anop         pea   0                        Result - Button that was pressed         pushlong #MsgLine1         pushlong #MsgLine2         pushlong #MsgBut1         pushlong #MsgBut2        _TLTextMountVolume         bra   Exit;................................................................;; GetToken - Look for the next command line token, if any.; ========   Maximum token length is 64 characters.;; On entry, Y = offset into command line;           m = 1 (8 bit accumulator mode); On exit,  ParmBuf contains the parameter;           ParmLen contains the length;           Exit via RTS; On error, GOTO ParmErr;;................................................................GetToken anop         longa off; Blank the parameter buffer for safety         ldx   #L:ParmBuf-1         lda   #' 'BlankIt  sta   ParmBuf,X                Blank parameter buffer for safety         dex         bpl   BlankIt         stz   ParmLen                  Ensure parameter length is zero; Skip any leading blanksSkipBlnk anop         lda   [ParmPtr],Y              Get character         beq   GTExit                   End of string         cmp   #' '                     Non-blank yet?         bne   SkipDone                 Found first operand byte         iny         bne   SkipBlnkSkipDone anop; Transfer the parameter to the pathname buffer         ldx   #0               CopyTokn anop         sta   ParmBuf,X                Fill the parameter buffer         inx                            Bump ParmBuf index         cpx   #L:ParmBuf               Token too long?         blt   CopyTok2         pla                            Pop the...         pla                                   ...return address         brl   ParmErr                  Yes, go whinge about itCopyTok2 iny                            Bump Parameter index         lda   [ParmPtr],Y              Get next character         beq   CopyDone                 End of string - done!         cmp   #' '                     Blank delimiter?         bne   CopyTokn                 No, not done yetCopyDone anop         txa                            Convert to 8 bits         sta   ParmLen                  Save parameter lengthGTExit   rts         longa on;................................................................;; ToolErr - Print an error message after a tool error, then exit.; =======;           On entry, Acc = Error code;;................................................................ToolErr  anop         sta   ErrCode         cmp   #$27                     I/O error?         beq   ToolErr2                 Special message         cmp   #$2F                     Device not online (no disk in drive?         bne   *+5         brl   ToolErr3                 Special message        _Error ErrCode                  Use the Shell error messageErrExit  anop         lda   ErrCode                  Use as return code         brl   Exit2ToolErr2 anop         writestr #'An I/O error occurred - the disk appears to be '         writeln  #'uninitialised'         brl   ErrExitToolErr3 anop         writeln #'ProDOS: Device not online, or no disk in drive'         brl   ErrExit;................................................................;; ParmErr - Print an error message for a parameter that is too long; =======;................................................................ParmErr  anop         long                           16 bit memory & registers         writeln #'Parameter token longer than 64 characters'         lda   #$FFFF                   Set return code         brl   Exit2                    Give upParmErr1 anop         long                           16 bit memory & registers         writestr #'Unknown parameter option ('         writestr ParmLen               Write unknown character(s)         writeln  #')'         lda   #$FFFF                   Set error code         brl   Exit2                    Give upParmErr2 anop         long                           16 bit memory & registers         writeln #'Device name length more than &MaxDBuf characters'         brl   Prompt1                  Go get a decent device name;................................................................;; Data areas;;................................................................UserId   ds    2                        Memory Manager UserId (passed by caller)ErrCode  ds    2                        Tool error codeILeave   str   '..'                     Filled by Int2Dec with Interleave valueParmLen  ds    1                        Parameter token length (MUST stay...ParmBuf  ds    64                       Parameter token buffer  ...together)HelloMsg str    '&SYSNAME v&VER - Copyright 1991 by Peter Watson'Eyeball  dc    c'&SYSNAME v&VER - &SYSDATE &SYSTIME'DevBuf   dc    i1'0',&MaxDBuf.c' 'GDNoParm anop                           Get_Dev_Num parameter list         dp    DevBuf                   Device or volume name (input)RBParm   anop                           Read_Block parameter list         ds    2                        Device no. (Out:GetDevNo, In:ReadBlock)         dc    i4'BlockBuf'             Data buffer         dc    i2'0'                    Block numberQuitParm dp    0                        Pathname (Return via Quit stack)         dc    i'0'                     FlagsSidesMsg dc    i1'SidesEnd-SidesMsg'         dc    c'The disk is 'SidesTxt dc    c'....le sided'          Single or Double sidedSidesEnd anopMsgLine1 str   '  &SYSNAME must be called from a'MsgLine2 str   '  Shell supporting command lines'MsgBut1  dc    i1'13',i1'27,15',c'M',i1'14,24',c' = Oops!'  Mousetext <Return>MsgBut2  str   'Esc = Cancel'BlockBuf ds    512                      Buffer for Read_Block command         end