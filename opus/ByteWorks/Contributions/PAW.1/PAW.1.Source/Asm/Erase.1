         mcopy erase.mac         gen   on;................................................................;; ERASE - Shell utility to write an empty directory to a disk.;         Resembles the standard INIT, but does not format the disk first.;;         Syntax:  ERASE [-C] device [name];            (will prompt if device omitted; will attempt to reuse current;             name (if possible), otherwise will prompt for name.;             '-C' suppresses prompt before destroying current contents.);;         Requires the following <INC>lude files (or object modules) :-;           ReadLn.INC                  ReadLn Subroutine;;         V1.0  - Copyright by Peter Watson, February 1989.;         V1.1  - Use ReadLn subroutine. Don't confirm under GS/OS. Jan 1990.;         V1.2  - Ignore error '0' (<Esc> from GS/OS dialog).;                 Handle 31 char volume names. Delete ShowAcc code (use library);                 Only run under GS/OS. Better debug code. Jan 1992.;;...... ..........................................................         longa on         longi onERASE    start         gblc  &VER         gblc  &MaxDBuf         gblc  &MaxVBuf         gblb  &Debug&debug   setb  0                        Debug mode OFF&VER     setc  '1.2'                    Program version	aif	.NOT.&debug,.VerOK&VER	setc	'&VER.p'	Prototype version	.VerOK&MaxDBuf setc  '32'                     Max device name buffer size&MaxVBuf setc  '33'                     Max volume name buffer size (/vol31/)ParmPtr  equ   0                        Offset into direct page;................................................................         phk         plb                            Make data bank = program bank         ora   #$0100                   Make the UserId unique to us         sta   UserId                   Save supplied userid         sty   ParmPtr                  Save parameter...         stx   ParmPtr+2                ...address on entry         stz   GSOSFlag                 Initialise 'GS/OS' flag         stz   Parm1Flg                 Initialise 'Found -C parameter' flag         stz   Parm3Flg                 Initialise 'Found a volume name' flag         stz   DevBuf+2                 Initialise device name length         stz   VolBufO+2                Initialise old volume name length         stz   VolBuf                   Initialise volume name length; Start Integer toolset, just in case it wasn't started by the Tool Locator        _IMStartUp                      Start Integer Math toolset         writeln         writeln HelloMsg               Announce ourselves to the world         aif   .NOT.&debug,.debug1         writeln #'===DoErase: Debug mode started'.debug1;................................................................;; Set the Input Global parameters to remove the high bit from input.; The Shell does this for us, but let's be safe (eg. from Finder).;;................................................................         pushlong #0                    Result space        _GetInGlobals                   Leave result on stack for exit         pea   $7F                      AND mask - strip high bit         pea   $00                      OR  mask - don't change        _SetInGlobals;................................................................;; Check for our OS version - some parameters are a bit different under GS/OS;;................................................................        _GetVersion GetVParm            Get OS version         bcc   *+5         brl   ToolErr         lda   GetVParm                 Get version         xba                            Put major version in low byte         and   #$007F                   Strip minor version and prototype flag         dec   a                        Make version 1 (ProDOS) = 0 = False         sta   GSOSFlag                 Make version 2 (GS/OS)  > 0 = True         bne   ChkParms	GSOS it is!         writeln #'GS/OS required to run &SYSNAME'         lda   #-1         brl   Exit2       	Home we go;................................................................;; Check for the Id string from APW or ORCA/M;;................................................................ChkParms anop         lda   ParmPtr                  X = Y = 0?         ora   ParmPtr+2                Did we get a parm?         beq   GoNoShel                 No, go exit now         ldy   #L:IdString-2ChkId    lda   [ParmPtr],Y              Check for legit parameter...         beq   GoNoShel         cmp   IdString,Y               ...starting with 'BYTEWRKS'         beq   *+5GoNoShel brl   NotShell                 Not from Shell, so exit with a message         dey         dey         bpl   ChkId;................................................................;; Now we can look for our real command operands (Skip command name first);;................................................................         stz   ParmLen                  Ensure high byte is zero (Memory)         lda   #0                       Ensure high byte is zero (Acc)         shortm                         8-bit accumulator & memory         ldy   #L:IdString              Point to first byte of command line data         jsr   GetToken                 Skip our command name;................................................................;; Transfer the first parameter to the device name buffer, unless; its the 'check with user' parameter (-C) switch.;;................................................................         jsr   GetToken                 Get pathname         lda   ParmBuf                  Check first character         cmp   #'-'                     Switch caharcter?         bne   GetDev                   No, treat as a device name         lda   ParmLen                  Get parameter length         cmp   #2                       Two characters?         bne   GoPErr1                  No, invalid switch parameter         lda   ParmBuf+1                Get actual switch         and   #$DF                     Ensure it's upper case         cmp   #'C'                     Is it the 'check with user' switch?         beq   *+5GoPErr1  brl   ParmErr1                 No, invalid switch parameter         inc   Parm1Flg                 Say we got a '-C' parameter         jsr   GetToken; Now get the device name parameterGetDev   anop         lda   ParmLen                  Get parameter length         sta   DevBuf+2                 Store in length         bne   *+5         brl   Prompt1                  No pathname, go prompt         cmp   #&MaxDBuf+1              Too long?         blt   *+5         brl   ParmErr2                 Tell the user         tax                            Transfer 16 bits         dexLoop1    anop         lda   ParmBuf,X                Get next character         sta   DevBuf+2+2,X             Fill the device name buffer         dex                            Bump DevBuf index         bpl   Loop1                    Not done yet;................................................................;; Transfer the second parameter to the volume name buffer;;................................................................         jsr   GetToken                 Get pathname         lda   ParmLen                  Get parameter length         sta   VolBuf                   Store in length         bne   *+5         brl   GotParms                 No new volume name, use current name         cmp   #&MaxVBuf+1              Too long?         blt   *+5         brl   ParmErr3                 Tell the user         tax                            Transfer 16 bits         dexLoop2    anop         lda   ParmBuf,X                Get next character         sta   VolBuf+2,X               Fill the volume name buffer         dex                            Bump VolBuf index         bpl   Loop2                    Not done yet         inc   Parm3Flg                 Say we have a volume name parameter         brl   GotParms                 We now have all parameters;................................................................;; Prompt the caller for a device name;;................................................................Prompt1  anop         longm                          16 bit memory         writeln         writestr #'Name of device to erase >'         pushlong #DevBuf+2+2           Device name buffer         pea   &MaxDBuf                 Maximum line length         jsl   ReadLn                   Go get a line; Store the length - if zero, then exit         writeln                        Move to next line         pla                            Get character count         bne   *+5         brl   Exit                     None, time to go         shortm         sta   DevBuf+2;................................................................;; Prompt the caller for a volume name;; We only do this if a) no volume parameter was supplied (but a device name was);                and b) we are unable to read the current volume name;;................................................................Prompt2  anop         longm                          16 bit memory         writestr #'New name for volume     >'         pushlong #VolBuf+2             Volume name buffer         pea   &MaxVBuf                 Maximum line length         jsl   ReadLn                   Go get a line; Store the length - if zero, then exit         writeln                        Move to next line         pla                            Get character count         bne   GotVol                   Got a volume name         lda   Parm3Flg                 Did we already have one?         beq   GotParms                 No, so try using current disk name         brl   Exit                     Otherwise, time to goGotVol   anop         inc   Parm3Flg                 Say we now have a volume name parameter         shortm         sta   VolBuf;................................................................;; Got all required parameters;; If he omitted the volume name's leading '/', then we will add it;; If he entered a volume name for the 'device name', we must convert it;;................................................................GotParms anop         short                          Ensure 8 bit memory & registers         lda   Parm3Flg                 Have we got a volume name yet?         beq   GoodVol                  'Nothing' cannot be incorrect!         lda   VolBuf+2                 Get first character         cmp   #'/'                     Is it a valid volume name?         beq   GoodVol                  Well, it starts out OK         cmp   #':'                     Is it a valid GS/OS volume name?         beq   GoodVol                  Well, it starts out OK         lda   VolBuf                   Get length         cmp   #&MaxVBuf                Too long (when we've finished)?         blt   *+5         brl   ParmErr3                 Tell the user         inc   VolBuf                   Set new length         tax                            Offset in X for copyShiftVol lda   VolBuf+1,X         sta   VolBuf+2,X               Move right one byte         dex         bne   ShiftVol         lda   #':'                     Now the character we need         sta   VolBuf+2                 As the leading character of our timeGoodVol  anop         long                           Ensure 16 bit memory & registers         lda   DevBuf+2+2               Get first character of devicename         and   #$00FF                   Ensure one byte only         cmp   #'/'                     Is it actually a volume?         beq   DoGDN                    Yes, go do GetDevNumber         cmp   #':'                     Is it actually a volume?         beq   DoGDN         brl   DoVolume                 No, so can do Volume callDoGDN    anop         aif   .NOT.&debug,.debug2         writeln #'===DoErase: Executing GetDevNumberGS'.debug2        _GetDevNumberGS GDNoParm        Get the device number         bcc   *+5         brl   ToolErr                  ...if possible         aif   .NOT.&debug,.debug3         writeln #'===DoErase: Executing DInfoGS'.debug3         lda   DevnoIn         sta   DevnoOut        _DInfoGS DInfParm               Get the device name;................................................................;; Get the current volume name for the prompt (even for '-C' to trap errors);;................................................................DoVolume anop         aif   .NOT.&debug,.debug4         writeln #'===DoErase: Executing VolumeGS'.debug4        _VolumeGS VolParm               Get current volume name (in VolBufO)         bcc   VolOK                    Lot's of choice with errors here         cmp   #$52                     Unsupported volume type?         beq   *+5         brl   ToolErr                  No,  use our standard error handler         lda   Parm3Flg                 Was a volume name supplied?         beq   *+5         brl   DoCheck                  Yes, go ahead with Erase anyway         inc   Parm3Flg                 Pretend we have a volume name parameter;                                       ...to allow user a 'change of heart'         brl   Prompt2                  No,  go ask for oneVolOK    anop         lda   Parm3Flg                 If required, copy old name to new name         beq   *+5         brl   DoCheck                  Already have a volume name         pushlong #VolBufO+2            Source      pointer         pushlong #VolBuf               Destination pointer         lda   VolBufO+2                Get length         inc   a                        Allow for length...         inc   a                                        ...word too         pea   0                        Length to move - High word         pha                            Length to move - Low  word        _BlockMove                      Copy old name to new name         lda   Parm1Flg                 Did he wish to be prompted?         beq   DoCheck                  Yes, so he will see the 'default' anyway         lda   GSOSFlag                 GSOS will tell him too!         bne   DoCheck                  Yes, so he will see the 'default' anyway         writestr #'New volume name will default to '         lda   VolBufO+2         pha                            Save length word for later         xba         sta   VolBufO+2         writeln  VolBufO3         pla                            Retrieve the original length word         sta   VolBufO+2         bra   DoCheck;................................................................;; Give the user a last chance, if required;;................................................................DoCheck  anop         lda   Parm1Flg                 '-C' specified?         ora   GSOSFlag                 or GS/OS (which prompts itself)?         beq   *+5         brl   DoErase                  Yes, skip check up         lda   VolBufO+2                Do we have an old volume name?         bne   DoAsk                    Yes, use it         lda   #$01                     Dummy length         sta   VolBufO+2         lda   #'/'                     Dummy name ('/')         sta   VolBufO+2+2              Dummy volume for messageDoAsk    anop         writeln         writestr #'Destroy '         lda   VolBufO+2         pha                            Save length word for later         xba         sta   VolBufO+2         writeln  VolBufO3         pla                            Retrieve the original length word         sta   VolBufO+2         writestr #'(Y or N)? 'GetChar  anop         pea   0                        Space for result         pea   0                        Don't echo the keystroke        _ReadChar                       Get a keystroke         pla                            What was it?         pha                            Save it again         cmp   #' '                     Don't echo control characters         blt   NewLine         writech                        Echo the characterNewLine  writeln         pla                            Get the character back again         and   #$DF                     Upper case         cmp   #'N'                     No?         bne   *+5                      No!         brl   Exit                     Let's get out of here!         cmp   #'Y'                     Yes?         beq   DoErase                  Yes!         writestr #'(Y or N, please)? '         bra   GetChar                  Try again;................................................................;; Do the actual Erase_Disk call (at last!);;................................................................DoErase  anop         aif   .NOT.&debug,.erase         writeln  #'===DoErase: Executing EraseGS'         writestr #'===DoErase: [device],[volume] = ['         lda   DevBuf+2         pha                            Save length word for later         xba         sta   DevBuf+2         writestr DevBuf3         pla                            Retrieve the original length word         sta   DevBuf+2         writestr #'],['         lda   VolBuf         pha                            Save length word for later         xba         sta   VolBuf         writestr VolBuf1         pla                            Retrieve the original length word         sta   VolBuf         writeln  #']'         clc.erase        _EraseDiskGS ErasParm         bcc   Exit                     No errors         tax                            Test Acc (not necessarily set by GS/OS)         beq   Exit                     c=1, A=0 just means he changed his mind         cmp   #$2B                     Write protect should be the only error         beq   *+5                      Handle it         brl   ToolErr                  Handle anything else         writestr #'Volume is write protected - Retry (Y or N)? '         brl   GetChar                  Check routine code will work fine;................................................................;; Exit - Return to our caller;;................................................................Exit     anop         lda   #0Exit2    anop         sta   ErrCode                  Save for exit        _SetInGlobals                   Parameters already on stack        _IMShutDown                     Close down the Integer Math toolset         lda   ErrCode                  Load return code (if any)        _Quit  QuitParm                 Return to our caller (Shell traps Quit);................................................................;; Return to someone other than a Shell-based caller;; Display a message dialogue first;;................................................................NotShell anop         pea   0                        Result - Button that was pressed         pushlong #MsgLine1         pushlong #MsgLine2         pushlong #MsgBut1         pushlong #MsgBut2        _TLTextMountVolume         bra   Exit;................................................................;; GetToken - Look for the next command line token, if any.; ========   Maximum token length is 64 characters.;; On entry, Y = offset into command line;           m = 1 (8 bit accumulator mode); On exit,  ParmBuf contains the parameter;           ParmLen contains the length;           Exit via RTS; On error, GOTO ParmErr;;................................................................GetToken anop         longa off; Blank the parameter buffer for safety         ldx   #L:ParmBuf-1         lda   #' 'BlankIt  sta   ParmBuf,X                Blank parameter buffer for safety         dex         bpl   BlankIt         stz   ParmLen                  Ensure parameter length is zero; Skip any leading blanksSkipBlnk anop         lda   [ParmPtr],Y              Get character         beq   GTExit                   End of string         cmp   #' '                     Non-blank yet?         bne   SkipDone                 Found first operand byte         iny         bne   SkipBlnkSkipDone anop; Transfer the parameter to the pathname buffer         ldx   #0               CopyTokn anop         sta   ParmBuf,X                Fill the parameter buffer         inx                            Bump ParmBuf index         cpx   #L:ParmBuf               Token too long?         blt   CopyTok2         pla                            Pop the...         pla                                   ...return address         brl   ParmErr                  Yes, go whinge about itCopyTok2 iny                            Bump Parameter index         lda   [ParmPtr],Y              Get next character         beq   CopyDone                 End of string - done!         cmp   #' '                     Blank delimiter?         bne   CopyTokn                 No, not done yetCopyDone anop         txa                            Convert to 8 bits         sta   ParmLen                  Save parameter lengthGTExit   rts         longa on;................................................................;; ToolErr - Print an error message after a tool error, then exit.; =======;           On entry, Acc = Error code;;................................................................ToolErr  anop         sta   ErrCode         cmp   #$27                     I/O error?         beq   ToolErr2                 Special message         cmp   #$2F                     Device not online (no disk in drive?         bne   *+5         brl   ToolErr3                 Special message        _Error ErrCode                  Use the Shell error messageErrExit  anop         lda   Errcode                  Use as return code         brl   Exit2ToolErr2 anop         writestr #'An I/O error occurred - you probably need to use '         writeln  #'the INIT command'         writeln  #'to format the volume first'         brl   ErrExitToolErr3 anop         writeln #'GS/OS: Device not online, or no disk in drive'         brl   ErrExit;................................................................;; ParmErr - Print an error message for a parameter that is too long; =======;................................................................ParmErr  anop         long                           16 bit memory & registers         writeln #'Parameter token longer than 64 characters'         lda   #$FFFF                   Set return code         brl   Exit2                    Give upParmErr1 anop         long                           16 bit memory & registers         writestr #'Unknown parameter option ('         writestr ParmLen               Write unknown character(s)         writeln  #')'         lda   #$FFFF                   Set error code         brl   Exit2                    Give upParmErr2 anop         long                           16 bit memory & registers         writeln #'Device name length more than &MaxDBuf characters'         brl   Prompt1                  Go get a decent device nameParmErr3 anop         long                           16 bit memory & registers         writeln #'Volume name length more than &MaxVBuf characters'         brl   Prompt2                  Go get a decent volume name;................................................................;; Data areas;;................................................................IdString dc    c'BYTEWRKS'              Shell id stringUserId   ds    2                        Memory Manager UserId (passed by caller)GSOSFlag ds    2                        0 = Not running under GSOSParm1Flg ds    2                        0 = No '-C' parameterParm3Flg ds    2                        0 = No volume name parameterErrCode  ds    2                        Tool error codeParmLen  ds    1                        Parameter token length (MUST stay...ParmBuf  ds    64                       Parameter token buffer  ...together)HelloMsg str    '&SYSNAME v&VER - Copyright 1989-92 by Peter Watson'Eyeball  dc    c'&SYSNAME v&VER - &SYSDATE &SYSTIME'DevBuf   dc    i'&MaxDBuf+4',i'0',&MaxDBuf.c' 'DevBuf3  equ   DevBuf+3VolBufO  dc    i'&MaxVBuf+4',i'0',&MaxVBuf.c' '  Old (or Original) volume nameVolBufO3 equ   VolBufO+3VolBuf   dc    i'0',&MaxVBuf.c' 'VolBuf1  equ   VolBuf+1GetVParm anop                           Get_Version parameter list         ds    2                        ProDOS / GS/OS version numberGDNoParm anop                           Get_Dev_Num parameter list         dc    i'2'                     parm count         dp    DevBuf+2                 Device or volume name (input)DevnoIn  ds    2                        Device no. (output)DInfParm anop                           D_Info parameter list         dc    i'2'                     parm countDevnoOut ds    2                        Device no. (input)         dp    DevBuf                   Device name (output)VolParm  anop                           Volume parameter list         dc    i'2'                     parm count         dp    DevBuf+2                 Device name (input)         dp    VolBufO                  Volume name (pre Erase_Disk) (output)ErasParm anop                           Erase_Disk parameter list         dc    i'3'                     parm count         dp    DevBuf+2                 Device name (input)         dp    VolBuf                   Volume name (input)         ds    2                        Selected file system id (output)         dc    i'$0001'                 File system id (ignored, but 1 = ProDOS)QuitParm dp    0                        Pathname (Return via Quit stack)         dc    i'0'                     FlagsMsgLine1 str   '  &SYSNAME must be called from'MsgLine2 str   '  the APW or ORCA shell!'MsgBut1  dc    i1'13',i1'27,15',c'M',i1'14,24',c' = Oops!'  Mousetext <Return>MsgBut2  str   'Esc = Cancel'         end