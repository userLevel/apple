         mcopy if.exist.mac         gen   on;................................................................;; IF.EXIST  -  APW shell utility to test for the existence of a file;              and set a status code reflecting the result.;              Code should be reusable/restartable.;              Nb: Remember to 'UNSET EXIT' before use in an EXEC file!;;              Syntax:  IF.EXIST pathname;                 (will prompt if pathname omitted);;              {Status} = 0  -  File exists;                       = 4  -  File/path/volume not found;                       > 4  -  GS/OS error (message also issued);;              V1.0 - Copyright by Peter Watson, December 1988.;              V1.1 - Fix intolerance of trailing parm blanks. Feb 89.;;................................................................         longa on         longi onIF_EXIST start         gblc  &VER         gblc  &MaxBuf&VER     setc  '1.1'                    Program version&MaxBuf  setc  64                       Maximum pathname buffer sizeParmPtr  equ   0                        Offset into direct page;................................................................         phk         plb         sty   ParmPtr                  Save parameter...         stx   ParmPtr+2                ...address on entry         stz   ParmFlag                 Initialise 'Found a parm' flag         stz   PathBuf                  Initialise pathname length for reuse;................................................................;; Check for the Id string from APW or ORCA/M;;................................................................         lda   ParmPtr                  X = Y = 0?         ora   ParmPtr+2                Did we get a parm?         beq   GoNoShel                 No, go complain         ldy   #L:IdString-2ChkId    lda   [ParmPtr],Y              Check for legit parameter...         cmp   IdString,Y               ...starting with 'BYTEWRKS'         beq   *+5GoNoShel brl   NotShell         dey         dey         bpl   ChkId;................................................................;; Now we can look for our real command operand (Skip command name first);;................................................................         short                          8-bit memory & registers         ldy   #L:IdString              Point to first byte of command lineLook1    anop         lda   [ParmPtr],Y              Get character         beq   Prompt                   End of string - Not enough!         cmp   #' '                     End of command yet?         beq   Look2                    Yes, Go skip some blanks         iny         bne   Look1Look2    anop         lda   [ParmPtr],Y              Get character         beq   Prompt                   End of string         cmp   #' '                     Non-blank yet?         bne   LookDone                 Found first operand byte         iny         bne   Look2LookDone anop         sta   ParmFlag                 Set 'Parm found' to TRUE (ie. non-zero);................................................................;; Transfer the parameter to the pathname buffer;;................................................................         ldx   #0                       Offset into PathBufLoop3    anop         sta   PathBuf+1,X              Fill the pathname buffer         inx                            Bump PathBuf index         cpx   #&MaxBuf                 Pathname too long?         blt   *+5         brl   ParmErr                  Yes, go whinge about it         iny                            Bump Parameter index         lda   [ParmPtr],Y              Get next character         beq   GoGetInf                 End-of-string - Done!         cmp   #' '                     Trailing blanks?         bne   Loop3                    No, not done yetGoGetInf anop         stx   PathBuf                  Store length byte         brl   GetInfo                  Go look for the file;................................................................;; Prompt the caller for a pathname;;................................................................Prompt   anop         long                           16 bit memory & registers         writeln         writestr #'Enter pathname >'         pea   0                        Result - Character count         pushlong #PathBuf+1            Pathname buffer         pea   &MaxBuf                  Maximum line length         pea   13                       End-of-Line character = <Return>         pea   1                        1 = Echo characters        _ReadLine; Store the length - if zero, then exit         writeln         pla                            Get character count         bne   ReadOK         brl   Exit                     None, time to goReadOK   anop         shortm         sta   PathBuf;................................................................;; Call Get_File_Info to test for the file's existence;;................................................................GetInfo  anop         long                           16 bit memory & registers        _Get_File_Info InfoParm         Look for file; At this stage, Acc = 0 if path is found or > 0 otherwise.; Supply a generic return code of '4' for 'path/volume/file not found' errors.         beq   Exit                     All OK         cmp   #$0044                   'Path not found' error?         beq   Exit4         cmp   #$0045                   'Vol  not found' error?         beq   Exit4         cmp   #$0046                   'File not found' error?         beq   Exit4         bra   ToolErr                  Otherwise print a real message;................................................................;; Exit - Return to our caller;;................................................................Exit4    lda   #0004                    'Path not found' codeExit     anop        _Quit QuitParm                  Return to our caller (trapped by Shell);................................................................;; ToolErr - Print an error message after a tool or OS error, then exit;;................................................................ToolErr  anop         sta   ErrCode        _Error ErrCode         lda   ErrCode                  Restore error code         bra   Exit;................................................................;; Return to someone other than a Shell-based caller;; Display a message first;;................................................................NotShell anop         pea   0                        Result - Button that was pressed         pushlong #MsgLine1         pushlong #MsgLine2         pushlong #MsgBut1         pushlong #MsgBut2        _TLTextMountVolume         pla                            Ignore the result         brl   Exit;................................................................;; ParmErr - Print an error message for a parameter that is too long;;................................................................ParmErr  anop         long                           16 bit memory & registers         writeln         writestr #'Parameter length more than &MaxBuf characters'         brl   Prompt                   Go get a decent parameter;................................................................;; Data areas;;................................................................IdString dc    c'BYTEWRKS'              Shell id stringParmFlag ds    2                        0 = No parameter found (ie. must prompt)Eyeball  dc    c'&SYSNAME - Copyright by Peter Watson, &SYSDATE &SYSTIME'PathBuf  dc    i1'0',&MaxBuf.c' '       Set by ReadLine; Input to InitialLoadInfoParm anop                           Get_File_Info parameter list         dp    PathBuf                  Pathname         ds    22                       Result space (unused)ErrCode  ds    2                        Tool error codeMsgLine1 str   '  &SYSNAME must be called from'MsgLine2 str   '  the APW or ORCA shell!'MsgBut1  dc    i1'13',i1'27,15',c'M',i1'14,24',c' = Oops!'MsgBut2  str   'Esc = Cancel'QuitParm dp    0                        Pathname         dc    i'0'                     Flags - Return via Quit stack         end