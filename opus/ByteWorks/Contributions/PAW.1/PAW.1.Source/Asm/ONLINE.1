         mcopy online.mac         gen   on;................................................................;; ONLINE  -  Display info about all online devices.;;            Syntax: ONLINE  [M(ount)];;            Copyright by Peter Watson, 1988-1996;;	    Requires STOP_PAUSE2 routine from PAW.LIB (or STOP_PAUSE);;            V1.1  - Correct code for 'Unsupported volume type'.;                  - Add 'hello' message. Minor style updates. April 1989.;            V2.0  - Incorporate old SLOTS program functionality.;                    Print volume name of HFS volumes if FST unavailable.;                    Program now requires GSOS. Nov 91.;            V2.1  - Fix volume name GSOS buffer length. Reformat display.Nov 91;            V2.2  - Display MS-DOS volume name if FST is unavailable. Mar 92;            V2.21 - Wait for keypress before exit if called from Finder. Mar 93;            V2.25 - Display format fixes. Handle ISO 9660 FST & MSDOS hard-disk;		      partitions. Device No. in decimal. Use STOP_PAUSE2. Jul 93;            V2.26 - Ignore Windows 95 long filenames on DOS disks. Aug 95;            V2.27 - Handle MSDOS partitions that look like boot blocks. Nov 95;            V2.3  - Attempt to mount offline SCSI volumes if the M(ount);		      parameter is specified. FDHD 'Drive' -> 'Disk'. Jul 96;            V2.31 - Handle $27, $2D, $2E errors. Sep 96;            V2.32 - Was checking parm buffer in 'standalone' mode. Dec 96;................................................................         longa on         longi onONLINE   start         gblc  &VER&VER     setc  '2.32'	Program version numberWorkPtr  equ   0                        Direct page workarea         phb                            Save data bank         phk                            Push program bank         plb                            Data bank = program bank	sty	WorkPtr	stx	WorkPtr+2         txa	ora	WorkPtr	Did we have a 'command line'?	sta	StandAlone	Save answer as 'StandAlone' flag	stz	MountFlag	Init the Mount flag; Was the 'M'ount parameter specified?	lda	StandAlone	Running 'StandAlone'?	beq   NoParm	Yes, can't have any parameters	shortm	ldy   #8	Skip shell idGetParm1	anop		Skip command name	lda   [WorkPtr],Y	Get command line byte	beq   NoParm	No parm found	iny	cmp   #' '	Skip command name	bne   GetParm1GetParm2 anop		Skip blanks	lda   [WorkPtr],y	beq   NoParm	No parm found	iny	cmp   #' '	Skip blanks	beq   GetParm2GetParm3 anop		Test parameter	cmp	#'-'	-M(ount) specified?	beq	GetParm2	Yes, get the next character	and   #$DF                     Make uppercase	cmp	#'M'	M(ount) specified?	bne	NoParm	No	inc	MountFlag	Set the flag!NoParm	anop	longm; Say hello to the user         ConsoleOut CursOff             Cursor off for speed         writeln         writeln HelloMsg               Announce ourselves	lda	MountFlag	Volume mount requested?	beq	DoTitle	No         writeln MountMsg               Remind the user what will happenDoTitle	anop         writeln         writeln TitleMsg               Make headings for the columns...         writeln Titl2Msg               ...and underline them;................................................................;; Check for GS/OS before going any further.;;................................................................        _GetVersionGS GetVParm          Get ProDOS version no.         bcs   GoQuit                   Leave early         lda   GetVParm_version         Get version word         and   #$7F00                   Isolate major release         cmp   #$0200                   Version 2 (GS/OS) or better?         bge   GotGSOS                  Yes, soldier onGoQuit   anop         writeln #'&SYSNAME requires GS/OS'         lda   #$FFFF                   Flag error to shell         brl   DoQuit                   Leave earlyGotGSOS  anop;................................................................;; Loop through device table requesting volume info for each device found;;................................................................         lda   #$0001         sta   DevNum                   Initialise device number;................................................................;; Display the device details;DevLoop  anop        _DInfoGS DInfParm               Get device name of a device         bcc   *+5                      Only error is $11 - 'Invalid Device'GoDone   brl   Done                     Yes, let's get out of here         jsr   WriteDevNum              Write the device number         jsr   WriteSlot                Write the slot and drive/unit         jsr   WriteDevName             Write the device name         jsr   WriteDevType             Write the device type;................................................................;; Display the volume details (if a blocked device); (Always use our own 'volume' code for MSDOS thanks to Windows 95!);	stz	MountTry	Reset loop detectorDoVolume	anop        _VolumeGS VolParm               Get volume name of a device         bcc   *+5         brl   VolErr                   Handle error         lda   File_Id         cmp   #$000A                   MS-DOS file system?         bne   NotMSDOS1                No, don't use our 'volume' routine         jsr   CheckDOS                 We must redo MS-DOS ourselves         bra   NextNotMSDOS1 anop         jsr   WriteVolName             Write the volume name (if available)         jsr   WriteFSTName             Write the FST name (if available)Next     anop         writeln                        Line is complete	jsl	STOP_PAUSE2	Pause or exit?	tax		Test return code	bne	GoDone	User wanted 'out'         inc   DevNum                   Next device number         brl   DevLoop                  Go again;................................................................;; Subroutine to write the device number;WriteDevNum anop         pushword DevNum                Push device number for Int2Hex         PushLong #Dev_String+1         Pointer to target string         pea   2                        Length of target string	pea	0	Value is unsigned        _Int2Dec         writestr Dev_String         rts;................................................................;; Subroutine to display the slot and drive of a unit;WriteSlot anop         lda   #'nI'                    Default is internal slot (backwards!)         sta   SlotType                 Store in message         lda   DevSlot         pha                            Save value         and   #$0008                   Get bit 3 = internal/external flag         beq   NotExt                   Was internal slot         lda   #'xE'                    Backwards!         sta   SlotType                 Store in messageNotExt   anop         pla                            Restore original value         and   #$0007                   Trim high bit!         pha                            Push Slot for Int2Hex         PushLong #SlotMsg              Pointer to target string         pea   1                        Length of target string        _Int2Hex         pushword DevUnit               Push Unit for Int2Hex         PushLong #UnitMsg              Pointer to target string         pea   1                        Length of target string        _Int2Hex         writestr SlotText              Slot and unit message part         rts;................................................................;; Subroutine to display the device name.; For aesthetic reasons, we will pad the field to a minimum of 18 chars;WriteDevName anop         lda   DevName2         pha                            Save it         xba                            Cheat to get a 1-byte length field         sta   DevName2         writestr DevName3              Device name message part         pla                            Retrieve saved length word         sta   DevName2; Now make sure that the field is at least 18 chars wide (.APPLESCSI.HD01.00).; This will line things up for the majority of device names.         cmp   #18                      At least 18 chars?         bge   EndWDN                   Yes, leave now         lda   #18                      Else make it 18...         sec         sbc   DevName2                 ...by printing an appropriate number...         tayWDNLoop  phy         writech #' '                   ...of blanks         ply         dey         bne   WDNLoopEndWDN   rts;................................................................;; Subroutine to display the device 'type';WriteDevType anop         writestr #'  ['         lda   DevId         cmp   #MaxId                   Too big?         blt   *+5         lda   #MaxId                   Make 'unknown' entry         asl   a                        Double it for offset         tax         lda   Offsets,X                Get offset to description         sta   0                        Save in temporary storage         ldy   #^Descs                  Bank of start of table         lda   #Descs                   Offset of start of table         clc         adc   0                        Add description offset         bcc   *+3         iny                            Oops, moved into next bank         sta   WorkPtr                  Save for later         sty   WorkPtr+2         writestr                       ; Address in Y, A regs         writestr #'] '; Now make sure that the field is at least 15 chars wide [FDHD (MFM) Disk].; This will line things up for the majority of device types.; (We make a special exception for CD-ROM which has a *very* long device name)         lda   [WorkPtr]                Get length (+ first character)         and   #$00FF                   Make into a length byte         sta   WorkPtr                  Save it; Hard coded fudge to improve the appearance of a special case	ldx	DevId	cpx	#CDRomId	CD-ROM?	bne	Check15	No, normal handling	cmp	#11	At least 11 chars?	bge	EndWDT	Yes, leave now         lda   #11                      Else make it 11...	bra	doWDT;Check14 cmp   #14                      At least 14 chars?    (Pre v2.30)Check15  cmp   #15                      At least 15 chars?         bge   EndWDT                   Yes, leave now         lda   #15                      Else make it 15...doWDT    sec         sbc   WorkPtr                  ...by printing an appropriate number...         tayWDTLoop  phy         writech #' '                   ...of blanks         ply         dey         bne   WDTLoopEndWDT   rts;................................................................;; Subroutine to display the volume name;WriteVolName anop         writestr #' '         lda   VolName2         xba                            Cheat to get a 1-byte length field         sta   VolName2         shortm         lda   #'/'                     Change ':' to '/' for old time's sake         sta   VolName3+1         longm         writestr VolName3              Volume name message part         rts;................................................................;; Subroutine to display the file system id; (when/if GS/OS provides the FST's to support it);WriteFSTName anop         writestr #' ('         lda   File_Id         cmp   #$0001                   ProDOS file system?         bne   NotPro                   No, skip specific message         writestr #'ProDOS'         brl   FsidExitNotPro   anop         cmp   #$0002                   DOS 3.3 file system?         bne   NotDOS                   No, skip specific message         writestr #'DOS 3.3'         brl   FsidExitNotDOS   anop         cmp   #$0004                   Pascal ][ file system?         bne   NotPasc                  No, skip specific message         writestr #'Pascal'         brl   FsidExitNotPasc  anop         cmp   #$0005                   Mac MFS file system?         bne   NotMFS                   No, skip specific message         writestr #'Mac MFS'         brl   FsidExitNotMFS   anop         cmp   #$0006                   Mac HFS file system?         bne   NotHFS                   No, skip specific message         writestr #'Mac HFS'         brl   FsidExitNotHFS   anop         cmp   #$000A                   MS-DOS file system?         bne   NotMSDOS                 No, skip specific message         writestr #'MS-DOS'         brl   FsidExitNotMSDOS anop         cmp   #$000B                   High Sierra file system? (CD-ROM)         bne   NotHiSi                  No, skip specific message         writestr #'High Sierra'         brl   FsidExitNotHiSi  anop         cmp   #$000C                   ISO 9660 file system? (CD-ROM)         bne   NotISO96                 No, skip specific message         writestr #'ISO 9660'         brl   FsidExitNotISO96 anop         cmp   #$000D                   AppleShare file system?         bne   NotAShar                 No, skip specific message         writestr #'AppleShare'         brl   FsidExitNotAShar anop; Display the id in hex         pha                            Push File_Id for Int2Hex         PushLong #Id_String+1          Pointer to target string         pea   4                        Length of target string        _Int2Hex         writestr #'file system id = $'         writestr Id_StringFsidExit anop         writech  #')'         rts;................................................................;; Error during VOLUME call;;................................................................VolErr   anop         cmp   #$0011                   Invalid device (End of list)?         bne   *+5                      No, skip next statement         brl   Done                     Yes, let's get out of here; Handle errors that may not be 'errors' (or that we have our own message for)         cmp   #$0058                   Not a block device?         bne   *+5         brl   NotBlock                 Yes, different error message         cmp   #$0027                   I/O error?         bne   *+5         brl   IOerror                  Yes, different error message         cmp   #$002E                   Disk switched?         beq   GoDoVol                  Yes, simply retry         cmp   #$002F                   Device not online?         beq   Offline                  Yes, different error message         cmp   #$0052                   Unsupported volume type?         bne   *+5GoUnkTyp brl   UnkType                  Yes, different error message; We come here on failed attempts to determine the volume type ourselvesVolErr2  anop         cmp   #$002D                   Invalid block? (eg. 1 blk partition!)         bne   *+5         brl   UnkType2                 Yes, treat as unknown/unsupported type; Oh well. I guess it *was* an error         pha                            Integer to convert         PushLong #Err_String+1         Pointer to target string         pea   4                        Length of string        _Int2Hex         writestr #'- Error $'         writestr  Err_String         brl   Next                     Go look for another device; Handle special cases; Offline has a special message, unless we are going to try to remount it firstOffline  anop	lda	MountFlag	'Mount' specified?	beq	Offline2	No, normal handling	lda	MountTry	'Mount' already tried?	bne	Offline2	Yes, normal handling	inc	MountTry	Set loop detector; SCSI block device?	ldx	#0Offline1 anop	lda	SCSItab,X	Get next SCSI device Id	beq	Offline2	End of table, normal handling	cmp	DevId	SCSI device?	beq	ReMount	Yes, try to remount it	inx	inx	bra	Offline1	Keep looking; Attempt to mount the deviceReMount	anop	lda	Devnum	sta	DCtlDev        _DControlGS DCtlParm            Set volume status	bcs   Offline2	Ignore errorsGoDoVol	brl	doVolume	Go attempt volume call again; Remount not required, or failed, so tell the user the device is offlineOffline2 anop	writestr #' <offline>'         brl   Next                     Go look for another device; Not a block deviceNotBlock anop;;;;;;   writestr #'- Not a block device'  Just ignore it now         brl   Next                     Go look for another device; I/O errorIOerror  anop	writestr #'- I/O error'         brl   Next                     Go look for another device; Unknown type - Check for HFS or MSDOS before complainingUnkType  anop         jsr   CheckHFS                 We can handle HFS ourselves         bcc   GoNext         jsr   CheckDOS                 We can handle MS-DOS ourselves         bcc   GoNextUnkType2 anop         writestr #'- Unsupported volume type'GoNext   brl   Next                     Go look for another device;................................................................;; Subroutine to check for, and handle HFS volumes (if HFS FST not present).; The volume name (and the FST name) will be displayed.;;................................................................CheckHFS anop         lda   DevNum         sta   DRdDevno                 Insert device number         lda   #2	Read block 2         sta   DRdBlkNo                 Insert block number        _DReadGS DReadParm         bcc   ChkId         plx                            Remove the RTS address         brl   VolErr2                  Use volume error handlerChkId    lda   BlkBuf                   Get 'id bytes'         cmp   HFSid                    Are they HFS bytes?         sec                            Flag the error up the line         bne   ChkExit         writestr #' :'         writestr HFSName               Write the volume name; Pretend GSOS actually recognised the HFS volume         lda   #$0006                   HFS file system id         sta   File_Id         jsr   WriteFSTName             Use our subroutine         clc                            Say we found itChkExit  rts;................................................................;; Subroutine to check for and handle MS-DOS volumes (if MS-DOS FST not present).; The volume name (and the FST name) will be displayed.; ;................................................................CheckDOS anop         lda   DevNum         sta   DRdDevno                 Insert device number         lda   #0	Read block 0 (boot block)         sta   DRdBlkNo                 Insert block number        _DReadGS DReadParm         bcc   ChkId2         plx                            Remove the RTS address         brl   VolErr2                  Use volume error handlerChkId2   lda   BlkBuf+$1FE              Get last two bytes         cmp   #DOSid	MS-DOS?	beq	GotId1	Yes         sec                            Flag the error up the line         brl   ChkExit2GotId1	anop* It's MSDOS - is a boot block, or a partition table?	lda   BlkBuf	Get 1st byte	and	#$00FF	1 byte only         cmp   #BPBid1	Boot block?	beq	GotId2	Yes         cmp   #BPBid2	Boot block? (Alternate id byte)	beq	GotId2	Yes* Must be a partition table - possible, but too hard, to try for volume name         brl   DOSFST	Skip volume nameGotId2	anop                     ; Get boot block info so we can find the directory blocks	lda	FATcnt	Get no. of FATs	and	#$00FF	1 byte only	cmp	#2	Standard value?	bne	goDOSFST	No, maybe it really was a partition map	pha	ldx	FATsize	Get size of FAT in sectorsFATloop	dex	                         Counted enough?	beq	SkipFAT	clc		FATcnt * FATsize	adc	1,s	bra	FATloop	(Lucky these are small numbers!)SkipFAT	anop	inc	A         sta   DRdBlkNo                 Insert block number	pla		Fix stack         lda   DirSize	Get no. of directory entries	sta	DirEnts	Save it; Loop through directory entries looking for a volume label entryDirLoop	anop        _DReadGS DReadParm	Read directory entry	ldx	#16	No. of entries per block	ldy	#0	Pointer in blockBlkLoop	anop	lda	FileName,y	Get 1st byte of name	and	#$00FF	beq	goDOSFST	0 = Last Used entry (no label found)	cmp	#delFile	Deleted file?	beq	SkipEnt	Yes, skip entry	lda	Attrib,y	Get attribute byte	and	#VolLabBit	Volume label?	beq	SkipEnt	lda	Attrib,y	Get attribute byte again	and	#LNameBits	cmp	#LNameBits	Windows 95 long filename entry?	beq	SkipEnt         bra	GotLabel                 Found it!SkipEnt	anop	tya		Get buffer pointer	clc	adc	#DirEntLen	Point to next entry	tay	dex	                         Any more entries in this block?	bne	BlkLoop	Yes, go look some more; Need to read another block (maybe)         inc   DRdBlkNo                 Increment block number         lda   dirEnts	Get number of entries	sec	sbc	#16	Reduce by number we've just scanned         sta   dirEnts	Save again	bne	DirLoop	Go read another onegoDOSFST	bra	DOSFST	No label, but we'll write the 'FST'; Have a volume label - copy itGotLabel	anop	tya	clc	adc	#11-1	11 chars in volume label	tay	ldx	#11-1	shortmDOScopy	anop	                         Copy the volume label	lda	FileName,y	cmp	#$05	Substitutes for $E5	bne	NotE5	lda	#$E5                     Make it $E5NotE5	and	#$7F	Strip high bit; Final safety check for invalid names (or if we got lost along the way!)	cmp	#$20	Control character	bge	NotCtl	No	adc	#$40	Make (safely) printableNotCtl	anop	sta	DOSName+3,x	dey	dex         bpl	DOScopy	longm         writestr DOSName               Write the volume name; Pretend GSOS actually recognised the volumeDOSFST	anop         lda   #$000A                   MS-DOS file system id         sta   File_Id         jsr   WriteFSTName             Use our subroutine         clc                            Say we found itChkExit2 rts;................................................................;; Finished - let's go home;;................................................................Done     anop         lda   #0                       Set return codeDoQuit   anop         pha		Save return code	lda	StandAlone	Called from Finder?	bne	DoQuit2	No, skip 'press a key' message	writeln	writeln #'(Press any key to exit)'	shortm	lda	>$E1C010	Clear keyboard strobeKeyLoop	lda	>$E1C000	Wait for a keypress	bpl	KeyLoop	lda	>$E1C010	Clear keyboard strobe	longmDoQuit2	anop         ConsoleOut CursOn              Cursor on again         pla         plb                            Restore data bank register        _Quit QuitParm                  Return to caller (trapped by shell)	brk	$99	GS/OS busy?;................................................................;; Data areas;;................................................................HelloMsg str    '&SYSNAME v&VER - Copyright 1989-96 by Peter Watson'Eyeball  dc    c'&SYSNAME v&VER - Copyright &SYSDATE &SYSTIME'MountMsg str    '-- Attempting to remount offline SCSI volumes --'TitleMsg str    'Dev Slot        Device name        Device type        Volume'Titl2Msg str    '--- ----        -----------        -----------        ------'CursOff  dc    i'6'                     Turn the cursor offCursOn   dc    i'5'                     Turn the cursor onStandAlone ds	2	= 0 if program called from the FinderMountFlag  ds	2	> 0 if Mount parameter specifiedMountTry   ds	2	> 0 if Mount attempt already madeId_String  dc  i1'4',c'0000'            File_Id - filled by _Int2HexErr_String dc  i1'4',c'0000'            Error code - filled by _Int2HexDev_String dc  i1'2',c'00'              Device number - filled by _Int2Hex; HFS disk constantsHFSid    dc    h'4244'                  Id bytes for HFS volume directory blockHFSName  equ   BlkBuf+$24               Offset to HFS volume name in vol dir blk; MS-DOS disk constants and variablesDOSid 	equ	$AA55	MSDOS id boot id (at offset $1FE)BPBid1	equ	$E9	MSDOS boot block idBPBid2	equ	$EB	MSDOS boot blockid (alternate)delFile	equ	$E5	Deleted file flagFATcnt	equ	BlkBuf+$10	No. of FATsFatsize	equ	BlkBuf+$16	No. of sectors per FATDirSize	equ	BlkBuf+$11	No. of 32-byte directory entriesFileName	equ	BlkBuf+$00	FilenameAttrib	equ	BlkBuf+$0B	Attribute byte in directory entryVolLabBit equ	$08	.... 1... Volume label flag bitLNameBits equ	$0F	.... 1111 Windows 95 long filename flagDirEntLen equ	32	Size of a directory entrydirEnts	ds	2	No. of directory entriesDOSname	str	' \vvvvvvvvvvv'	Volume name (11 bytes); Slot and unit/drive message skeletonSlotText dc    i1'SlotTxtL'         dc    c'  'SlotType dc    c'Int s'SlotMsg  dc    c'0,d'UnitMsg  dc    c'0  'SlotTxtL equ   *-SlotText-1; _GetVersionGS parameter listGetVParm VersionRecGS 1                 pMMMMMMMmmmmmmmm (Prototype|Major|minor); _DInfoGS parameter listDInfParm dc    i'10'                    10 (out of 2-11) parametersDevNum   ds    2                        Device number         dp    DevName                  Device name pointerDevChar  ds    2                        Device characteristics         ds    4                        Total blocksDevSlot  ds    2                        Slot numberDevUnit  ds    2                        Unit number         ds    2                        Version numberDevId    ds    2                        Device id number         ds    4                        Head and forward links; _VolumeGS parameter listVolParm  anop                           VOLUMEGS parameter list         dc    i'5'                     5 (out of 2-6) parameters         dp    DevName2                 Device name pointer         dp    VolName                  Volume name pointer         ds    4                        Total blocks on device         ds    4                        Free blocks on deviceFile_Id  ds    2                        File system id; _DControlGS parameter list  (See System 6.0 Reference, P. 321-322)DCtlParm dc    i'5'                     5 parametersDCtlDev  ds    2                        Device number	dc	i'$F001'	Set volume status	dp    VolStatus                Volume status pointer	dc    i4'2'                    Request  count	ds    4                        Transfer count; Volume status buffer  (See System 6.0 Reference, P. 322)VolStatus dc   i'$4000'                 Remount; Don't change R/W status; _DReadGS parameter listDReadParm anop                          DReadGS parameter list         dc    i'6'                     6 (out of 6-6) parametersDRdDevno ds    2                        Device number         dp    BlkBuf                   Block buffer         dc    i4'512'                  Read 1 blockDRdBlkNo dc    i4'2'                    Block 2         dc    i'512'                   Block size         ds    4                        Transfer count; Device name bufferDevName  dc    i'2+2+32'                Input length = 36DevName2 ds    2                        Output lengthDevName3 equ   *-1         ds    32                       Device name <= 32 chars; Volume name bufferVolName  dc    i'2+2+32'                Input length = 36VolName2 ds    2                        Output lengthVolName3 equ   *-1         ds    32                       Volume name (any file system!); QuitGS parameter listQuitParm dp    0                        Pathname         dc    i'0'                     Flags;................................................................;; Device Id Translation Tables;;................................................................; Table of offsets to descriptionsOffsets  anop         dc    i'Id00-Descs'         dc    i'Id01-Descs'         dc    i'Id02-Descs'         dc    i'Id03-Descs'         dc    i'Id04-Descs'         dc    i'Id05-Descs'         dc    i'Id06-Descs'         dc    i'Id07-Descs'         dc    i'Id08-Descs'         dc    i'Id09-Descs'         dc    i'Id0A-Descs'         dc    i'Id0B-Descs'         dc    i'Id0C-Descs'         dc    i'Id0D-Descs'         dc    i'Id0E-Descs'         dc    i'Id0F-Descs'         dc    i'Id10-Descs'         dc    i'Id11-Descs'         dc    i'Id12-Descs'         dc    i'Id13-Descs'         dc    i'Id14-Descs'         dc    i'Id15-Descs'         dc    i'Id16-Descs'         dc    i'Id17-Descs'         dc    i'Id18-Descs'         dc    i'Id19-Descs'         dc    i'Id1A-Descs'         dc    i'Id1B-Descs'         dc    i'Id1C-Descs'         dc    i'Id1D-Descs'         dc    i'Id1E-Descs'         dc    i'Id1F-Descs'MaxId0   equ   *-Offsets-2              Assembler problem workaroundMaxId    equ   MaxId0/2                 Maximum valid offset         dc    i'IdUnk-Descs'           Maximum+1 = 'Unknown type'; Table of descriptionsCDRomId	equ	7	Device id for SCSI CD-ROMDescs    anopId00     str   'Disk ]['Id01     str   'Profile 5 Meg'Id02     str   'Profile 10 Meg'Id03     str   'Disk 3.5'Id04     str   'SCSI (generic)'Id05     str   'SCSI Hard Disk'Id06     str   'SCSI Tape Drive'Id07     str   'SCSI CD Rom'Id08     str   'SCSI Printer'Id09     str   'Modem'Id0A     str   'Console Driver'Id0B     str   'Serial Printer'Id0C     str   'Serial LaserWriter'Id0D     str   'AppleTalk LaserWriter'Id0E     str   'RAM Disk'Id0F     str   'ROM Disk'Id10     str   'File Server'Id11     str   'IBX'Id12     str   'Apple Desktop Bus'Id13     str   'Hard Disk (generic)'Id14     str   'Floppy Disk (generic)'Id15     str   'Tape Drive (generic)'Id16     str   'Character Device Driver (generic)'Id17     str   'FDHD (MFM) Disk'Id18     str   'AppleTalk Network (generic)'Id19     str   'Sequential Access Device'Id1A     str   'SCSI Scanner'Id1B     str   'Other Scanner'Id1C     str   'LaserWriter SC'Id1D     str   'AppleTalk main driver'Id1E     str   'AppleTalk file service driver'Id1F     str   'AppleTalk RPM driver'IdUnk    str   'Unknown type'           *** Must be last in table ***; Table of (probable) 'SCSI' block device types (null terminated); Note: When this table is checked, non-block devices have already been skippedSCSItab	dc	i'4,5,6,7,13,0'	Generic hard disk included just in caseBlkBuf   ds    512                      Buffer for (possible) block read         end