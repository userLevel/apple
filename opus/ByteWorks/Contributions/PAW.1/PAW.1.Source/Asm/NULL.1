         mcopy NULL.mac         gen   on;................................................................;; NULL   -  GS/OS device driver to implement 'write-only' memory.;           Any 'write/format' type call simply returns with no error.;           The device is basically a small (<= 64K) ROM disk.;           Read type calls will return 512 bytes of zeroes, except for :-;;              Block 2 - A dummy directory (volume /Null with one file NULL);              Block 6 - A dummy bit map;;           Load file must have filetype '$BB'   (device driver);           and auxtype '$0101'                  (GS/OS driver, 1 device);;           'Extended' utility macro set required (APW Interfaces v1.1 or later);;           V1.0 - Copyright by Peter Watson, October 1990.;;................................................................         longa on         longi onDriver_Data data;................................................................DevBlks  GEQU  128  (64K)               No. of blocks in device;................................................................badSystemCall  GEQU $0001 ; error - bad system call numberinvalidPcount  GEQU $0004 ; error - invalid parameter countinvalidDevNum  GEQU $0011 ; error - invalid device numberdrvrBadReq     GEQU $0020 ; error - bad request or commanddrvrBadCode    GEQU $0021 ; error - bad control or status codedrvrBadParm    GEQU $0022 ; error - bad call parameterdrvrNotOpen    GEQU $0023 ; error - character device not opendrvrPriorOpen  GEQU $0024 ; error - character device already openirqTableFull   GEQU $0025 ; error - interrupt table fulldrvrNoResrc    GEQU $0026 ; error - resources not availabledrvrIOError    GEQU $0027 ; error - I/O errordrvrNoDevice   GEQU $0028 ; error - device not connecteddrvrBusy       GEQU $0029 ; error - call aborted, driver is busydrvrWrtProt    GEQU $002B ; error - device is write protecteddrvrBadCount   GEQU $002C ; error - invalid byte countdrvrBadBlock   GEQU $002D ; error - invalid block addressdrvrDiskSwitch GEQU $002E ; error - disk has been switcheddrvrOffLine    GEQU $002F ; error - device off line/ no media present;................................................................;; GS/OS Direct Page equates;;................................................................               dsect 0                  Start a dsectdrvr_dev_num   word                     Device Numberdrvr_call_num  word                     Call numberdrvr_buf_ptr   long                     Buffer pointerdrvr_slist_ptr gequ  drvr_buf_ptr       Buffer pointerdrvr_clist_ptr gequ  drvr_buf_ptr       Buffer pointerdrvr_id_ref    gequ  drvr_buf_ptr       Indirect device iddrvr_req_cnt   long                     Request countdrvr_tran_cnt  long                     Transfer countdrvr_blk_num   long                     Block numberdrvr_blk_size  word                     Block sizedrvr_fst_num   word                     FST numberdrvr_stat_code gequ  drvr_fst_num       Status call status codedrvr_ctrl_code gequ  drvr_fst_num       Control call control codedrvr_vol_id    word                     Driver volume id numberdrvr_cache     word                     Cache prioritydrvr_cach_ptr  long                     Pointer to cached blockdrvr_dib_ptr   long                     Pointer to active DIB&DummyPC       SETA  $74                Move 'dsect' pointersib_ptr        long                     Pointer to active SIBsup_parm_ptr   long                     Pointer to supervisor parms;................................................................;; All loaded drivers must contain a header (GS/OS Beta manual, P. 632);;................................................................here     entry         dc    i'DIB-here'              Offset to first DIB         dc    i'1'                     No. of devices         dc    i'CONFLIST-here'         Offset to first config. list;CONFLIST dc    i'0'                     0 bytes in parm listDEFLTLST dc    i'0'                     0 bytes in default list;; Format Options;format_tbl entry         dc    i'2'                     # of entries (looks good for Format!)         dc    i'2'                     # of displayed entries         dc    i'1'                     Recommended option         dc    i'1'                     Current option;format1  anop         dc    i'1'                     RefNum         dc    i'0'                     LinkRef         dc    i'$04'                   Universal format / size in Kb         dc    i4'DevBlks'              block count         dc    i'512'                   Blocksize         dc    i'0'                     Interleave factor         dc    i'DevBlks/2'             'Media' size in Kb;format2  anop         dc    i'2'                     RefNum         dc    i'0'                     LinkRef         dc    i'$04'                   Universal format / size in Kb         dc    i4'DevBlks'              block count         dc    i'512'                   Blocksize         dc    i'2'                     Interleave factor         dc    i'DevBlks/2'             'Media' size in Kb;; DIB (Device Information Block);DIB      entry         dp    0                        Next DIB         dp    DISPATCH                 Entry pointer         dc    i'$83E8'                 Device characteristics;                                       (ROM disk, any speed, block, R/W, fmt)         dc    i4'DevBlks'              Block count         dc    i1'4'                    Device name length         dc    c'NULL',27c' '           Device name (32 chars)         dc    i'$8000'                 Slot (Independent of slots)         dc    i'1'                     Unit #         dc    i'$100E'                 Version 0.90 experimental         dc    i'$000F'                 Device id # (ROM disk)         dc    i'0'                     Head device link         dc    i'0'                     Forward device link         dc    i'0'                     Reserved         dc    i'0'                     Reserved         dc    i'0'                     DIB device number;; Dispatch Table;disp_tbl entry         dc    i'STARTUP'               Startup         dc    i'OK'                    Open (Char only)         dc    i'READ'                  Read         dc    i'OK'                    Write         dc    i'OK'                    Close (Char only)         dc    i'STATUS'                Status         dc    i'OK'                    Control         dc    i'BADCMD'                Flush (Char only)         dc    i'SHUTDOWN'              Shutdown;; Status Table;stat_tbl entry         dc    i'Dev_Stat'              Device status         dc    i'Get_Ctrl'              Get control parms         dc    i'Get_Wait'              Get wait         dc    i'Get_Format'            Get format         dc    i'Get_Parts'             Get parts map;; Control Table;ctrl_tbl entry         dc    i'OK'                    Device reset         dc    i'OK'                    Format         dc    i'OK'                    Media eject         dc    i'OK'                    Set control parms         dc    i'OK'                    Set wait         dc    i'OK'                    Set format         dc    i'OK'                    Set parts owner         dc    i'OK'                    Arm signal         dc    i'OK'                    Disarm signal         dc    i'OK'                    Set parts map;; Device Status;dstat_tbl entry         dc    i'$10'                   General status word (device is Online)         dc    i4'DevBlks'              Device block count;; Config List, Wait Mode, Format Mode Tables;clist_tbl entry         dc    i'CONFLIST'              Config list 1wait_mode_tbl entry         dc    i'0'                     Unit 1 current wait modeformat_mode_tbl entry         dc    i'1'                     Unit 1 current format modeInUseCnt dc    i'0'                     No. of current users of this device;;................................................................;; Dummy Directory Entry, with one dummy seedling file;DummyDir anopHeader   dc    i'0,0'                   Link pointers         dc    i1'$F4'                  Storage type; Name length         dc    c'NULL',11i1'0'          Volume name         dc    i6'0'                    Reserved         dc    i'$B800'                 Mixed case flags (Yes!)         dc    i'0'                     Creation date         dc    i'0'                     Creation time         dc    i1'0'                    Version         dc    i1'0' '                  Min version         dc    i1'$03'                  Access (Visible, Read-Write)         dc    i1'$27'                  Entry length         dc    i1'$0D'                  Entries per block         dc    i'1'                     File count         dc    i'6'                     Bit map block         dc    i'DevBlks'               Total blocks;................................................................File1    dc    i1'$14'                  Storage type; Name length         dc    c'NULL',11i1'0'          File name (15 bytes)         dc    i1'$06'                  File type (BIN)         dc    i'3'                     Key block pointer (Block 3)         dc    i'1'                     Blocks in use         dc    i3'512'                  EOF mark         dc    i'0'                     Creation date         dc    i'0'                     Creation time         dc    i1'0'                    Version (and mixed case info)         dc    i1'$B8'                  Min version (mixed case)         dc    i1'$03'                  Access (Visible, Read-Write)         dc    i'0'                     Aux type         dc    i'0'                     Modify date         dc    i'0'                     Modify time         dc    i'2'                     Directory head pointer;................................................................File_X   ds    $27*11                   Remaining empty directory entries         dc    i1'0'                    Lucky last little byte         end;................................................................;; Entry in 16 bit native mode via JSL; Acc = Call number; D = GS/OS direct page (Do not modify, except for 'drvr_trans_cnt' field);;................................................................NULL     start         using driver_dataDispatch entry         phk         plb                            We're allowed to do this!         cmp   #9                       Command # too big?         bge   BADCMD2                  Yes, handle it         tay                            Save it         ldx   #0SaveParms anop         lda   <drvr_dev_num,x          Save GS/OS call parms         pha         lda   <drvr_blk_num,x         pha         inx         inx         cpx   #$0C                     Up to but not including drvr_tran_cnt         bne   SaveParms         tya                            Retrieve the command #         asl   a                        Double it         tax         jsr   (disp_tbl,x)             Go do the function         tay                            Save error code         ldx   #$0A                     No. of words to restoreRestParms anop                          Restore GS/OS call parms         pla         sta   <drvr_blk_num,x         pla         sta   <drvr_dev_num,x         dex         dex         bpl   RestParms         tya                            Restore error code         bne   SEC         clc                            Flag a good return         rtlSEC      sec                            Flag an error return         rtl;................................................................;; Subroutines;OK       entry         lda   #0                       Return with no error         clc                            Ditto         rts                            'I wish I was in Kansas! I wish....'BADCMD   entry         lda   #drvrBadReq              Return with a 'Bad Command' error         sec                            Oh-oh!         rts                            Bye-bye!BADCMD2  entry         lda   #drvrBadReq              Return with a 'Bad Command' error         sec                            Oh-oh!         rtl                            Bye-bye!         end;................................................................;; Handle a STARTUP call;;................................................................STARTUP  start         longa on         longi on         using driver_data         inc   InUseCnt                 Say we're being 'used'         lda   #0         clc         rts         end;................................................................;; Handle a READ call;; On entry,; <drvr_dev_num  = Device number; <drvr_buf_ptr  = Pointer to I/O buffer; <drvr_blk_num  = Initial block number; <drvr_req_cnt  = Number of bytes to be transferred; <drvr_blk_size = Size of blocks to be accessed; <drvr_tran_cnt = 0 (on entry), # of bytes transferred on exit;; The following code assumes 512 byte blocks and < 64K bytes in the device.; Block 2 returns a dummy directory containing 1 seedling file (/Null/Null).;;................................................................READ     start         longa on         longi on         using driver_data         lda   <drvr_buf_ptr         ora   <drvr_buf_ptr+2         beq   BadRead                  Buffer pointer = NIL         lda   <drvr_blk_num+2          Validate block #         bne   BadBlock                 Bad!         lda   <drvr_blk_num         cmp   #DevBlks                 We have blocks numbered 0 - 127         bge   BadBlock         tax                            Save it         lda   <drvr_req_cnt+2          Validate request count         bne   BadRead                  Bad!         lda   <drvr_req_cnt         xba         and   #$00FF                   Convert to (whole) blocks         lsr   a         cmp   #DevBlks+1               We can read 128 blocks, at most         bge   BadRead         clc         adc   <drvr_blk_num            More than we've got?         cmp   #DevBlks+1               Start block + block count <= 128!         blt   OKReadBadRead  anop         lda   #drvrBadParm             Invalid request         sec         rtsBadBlock anop         lda   #drvrBadBlock            Invalid block #         sec         rts;; Request count is valid.;OKRead   anop         stz   <drvr_tran_cnt+2         lda   <drvr_blk_num         cmp   #2                       Block 2 is a 'special' block         bne   ChkBitMap                No, check for bit map (blk 6);; Return a dummy directory block;         ldy   #512                     One block         sty   <drvr_tran_cnt         dey         dey                            OffsetDirLoop  anop         lda   DummyDir,Y         sta   [<drvr_buf_ptr],Y         dey         dey         bpl   DirLoop         brl   EndRead;; Return a dummy volume bit map;ChkBitMap anop         cmp   #6                       Bit map block?         bne   ZeroBlk                  Not 2, so return block(s) of zeroes         ldy   #512                     One block         sty   <drvr_tran_cnt         dey                            Offset         dey         lda   #$0000                   Invalid blocks are 'used'VTOCLoop anop         sta   [<drvr_buf_ptr],Y         dey         dey         bpl   VTOCLoop         ldy   #(DevBlks/8)-2           Fix 'free' blocks         lda   #$FFFF                   Mark them freeVTOCLoop2 anop         sta   [<drvr_buf_ptr],Y         dey         dey         bpl   VTOCLoop2         lda   #$FF0D                   Blocks 0, 1, 2, 3, 6 in use         sta   [<drvr_buf_ptr]         brl   EndRead;; Return one or more zero blocks;ZeroBlk  anop         lda   <drvr_req_cnt            Get # of bytes         sta   <drvr_tran_cnt         tay         dey                            Make into an offset         dey         lda   #$0000ZeroLoop anop         sta   [<drvr_buf_ptr],Y         dey         dey         bpl   ZeroLoopEndRead  anop         lda   #0         clc         rts         end;................................................................;; Handle STATUS call;;................................................................STATUS   start         longa on         longi on         using driver_data         lda   <drvr_stat_code          Is this a legal request?         cmp   #4         blt   LegalStat                Yes!         lda   #drvrBadCode         sec         rtsLegalStat anop         asl   a                        Double for offset         tax         jsr   (|stat_tbl,x)            Go do the function         rts;................................................................;; STATUS subcommands;; Device Status;Dev_Stat entry         lda   #drvrBadParm             Assume invalid request         ldx   <drvr_req_cnt+2          Validate request count         bne   BadDevStat               Bad!         ldx   <drvr_req_cnt         cpx   #2         blt   BadDevStat               Bad!         cpx   #7         blt   OKDevStatBadDevStat anop         sec         rts;; Request count is valid.  Return status details;OKDevStat anop         ldx   #dstat_tbl               Get pointer to device status list         ldy   #0                       Status list pointer         shortmCopyDStat anop         lda   |0,X                     Copy device status list to slist_ptr         sta   [<drvr_slist_ptr],Y         inx         iny         cpy   <drvr_req_cnt            Copied enough?         bne   CopyDStat         longm         brl   SetXferCnt               Go set the transfer count;................................................................;; Get Control status;Get_Ctrl entry         lda   #drvrBadParm             Assume invalid request         ldx   <drvr_req_cnt+2          Validate request count         bne   BadGetCtrl               Bad!         ldx   <drvr_req_cnt         cpx   #2         bge   OKGetCtrlBadGetCtrl anop         sec         rts;; Request count is valid.  Return details;OKGetCtrl anop         lda   #0         sta   [<drvr_slist_ptr]         lda   #2                       We are only going to return 2 bytes         brl   SetXferCnt2              Go set the transfer count;................................................................;; Get Wait status;Get_Wait entry         lda   #drvrBadParm             Assume invalid request         ldx   <drvr_req_cnt+2          Validate request count         bne   BadGetWait               Bad!         ldx   <drvr_req_cnt         cpx   #2         beq   OKGetWaitBadGetWait anop         sec         rts;; Request count is valid.  Return details;OKGetWait anop         lda   wait_mode_tbl         sta   [<drvr_slist_ptr]         brl   SetXferCnt               Go set the transfer count;................................................................;; Get Format status;Get_Format entry         lda   #drvrBadParm             Assume invalid request         ldx   <drvr_req_cnt+2          Validate request count         bne   BadGetFmt                Bad!         ldx   <drvr_req_cnt         cpx   #2         bge   OKGetFmtBadGetFmt anop         sec         rts;; Request count is valid.  Return details;OKGetFmt anop         ldx   #format_tbl              Get pointer to format option list         lda   |0,X                     Get # entries in option list         asl   a                        List length = (a * 16) + 8         asl   a         asl   a         asl   a         clc         adc   #8                       Now have option list length         cmp   <drvr_req_cnt            Is request longer than list length?         bge   ReqCountOK         sta   <drvr_req_cnt            Else fix itReqCountOK anop         ldy   #0                       Status list index         shortmCopyFormat anop         lda   |0,X                     Copy format option list to slist_ptr         sta   [<drvr_slist_ptr],Y         inx         iny         cpy   <drvr_req_cnt            Copied enough?         bne   CopyFormat         longm         brl   SetXferCnt               Go set the transfer count;................................................................;; Get Partition map;Get_Parts entry         lda   #0                       Not supported, but no error         clc         rts;................................................................;; Common exit routine to set the transfer count; - Always set transfer count = request count, and return with no error;SetXferCnt entry         lda   <drvr_req_cnt            Set transfer count for request countSetXferCnt2 anop         sta   <drvr_tran_cnt         lda   <drvr_req_cnt+2         sta   <drvr_tran_cnt+2         lda   #0                       No error         clc         rts         end;................................................................;; Handle a SHUTDOWN call;;................................................................SHUTDOWN start         longa on         longi on         using driver_data         dec   InUseCnt                 Say we're not being 'used'         bne   NotLast         lda   #0         clc         rtsNotLast  anop         lda   #drvrBusy         sec         rts         end