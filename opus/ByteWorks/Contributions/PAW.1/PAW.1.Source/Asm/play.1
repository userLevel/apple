         mcopy play.mac         gen   on;................................................................;; PLAY  - Utility to load and play an uncompressed digitised sound file.;;         Syntax:  PLAY [-C] [pathname] [speed];              -C gives continuous play (press '<Open-Apple>-.' to stop);;            - Will prompt if pathname omitted; will not prompt for speed.;            - If prompting, '\' as a pathname will replay last file, if any.;                            '#speed' will make 'speed' the playback rate.;            - To stop a playing sound, press '<Open-Apple>-.'.;;         'Speed' is the playback rate, 0-4095 (or $000-$FFF). If omitted,;         the auxtype of the file will be used (or 428 if auxtype = 0).;;         PLAY is designed for the APW (ORCA/M) Shell, but will work;         correctly as a system file if converted to filetype S16 ($B3).;; ******* Requires PAW.LIB file for READLN subroutine (or append READLN.INC);;         V1.0  - Copyright by Peter Watson, January 1989.;         V1.1  - January 1989. Add speed parm and Apple-. stop option.;         V1.2  - February 1989. Change default speed from 400 to 428.;         V1.3  - February 1989. Continous '-C' and repeat play '\' options.;         V1.4  - March 1989. DOC buffer size = $8000; Always start with 'stop'!;         V1.41 - March 1989. Use READLN routine for decent input ability.;         V1.5  - April 1989. Support MessageCenter. Support multiple sounds.;                 Don't play DIR files! DOC bufsize = $2000; Add '#' prompt opt.;         V1.51 - October 2000. Ignore DIR files quietly (esp. for wildcards!).;.................................................................         longa on         longi onPLAY     start         gblc  &VER         gblc  &DefFreq         gblc  &MaxBuf         gblb  &Debug&VER     setc  '1.51'                   Program version&DefFreq setc  '428'                    Default playback frequency&MaxBuf  setc  '64'                     Maximum parameter/pathname buffer size&Debug   setb  0                        Set debugging mode offParmPtr  equ   0                        Offset into direct pageHandle   equ   4                        Handle to requested memory bufferMsgHndle equ   8                        Handle  to Message Center messageMsgAddr  equ   12                       Pointer to Message Center messageZeroPage equ   $100                     Offset to direct page for Sound Tools;................................................................         phk         plb                            Make data bank = program bank         ora   #$0100                   Make the UserId unique to us         sta   UserId                   Save supplied userid         sty   ParmPtr                  Save parameter...         stx   ParmPtr+2                ...address on entry         stz   Parm1Flg                 Initialise 'Found a pathname' flag         stz   Parm2Flg                 Initialise 'Found a speed parm' flag         stz   Parm3Flg                 Initialise 'Continuous play parm' flag         stz   Replay                   Initialise 'Repeat last play' flag         stz   Played                   Initialise '# of files played' counter         stz   ShellPgm                 Initialise 'Running under Shell' flag         stz   MsgCFlag                 Initialise 'Message Center data' flag         stz   PathBuf                  Initialise pathname length for reuse         stz   SFreq                    Initialise sound frequency for reuse         stz   AuxType                  Initialise aux file type field for reuse         stz   Handle                   Say we have...         stz   Handle+2                            ...no allocated memory         stz   MsgHndle                 Say we have...         stz   MsgHndle+2                          ...no allocated memory; Start some toolsets, just in case they weren't started by the Tool Locator        _IMStartUp                      Start Integer Math toolset        _TextStartUp                    Start Text Tool toolset         writeln         writeln HelloMsg               Announce ourselves to the world         aif   .NOT.&Debug,.NoEye         writeln Eyeball                Minute to minute version data!.NoEye;................................................................;; Set the Input Global parameters to remove the high bit from input.; The Shell does this for us, but we may not be under the Shell!;;................................................................         pushlong #0                    Result space        _GetInGlobals         pulllong InGlobals             Save original values         pea   $7F                      AND mask - strip high bit         pea   0                        OR  mask - don't change        _SetInGlobals;................................................................;; Check for the Id string from APW or ORCA/M;;................................................................         lda   ParmPtr                  X = Y = 0?         ora   ParmPtr+2                Did we get a parm?         bne   *+5         brl   MsgCenter                No, check for name passed by Finder         ldy   #L:IdString-2ChkId    lda   [ParmPtr],Y              Check for legit parameter...         beq   GoPrompt         cmp   IdString,Y               ...starting with 'BYTEWRKS'         beq   *+5GoPrompt brl   Prompt                   Not from Shell, so must always prompt         dey         dey         bpl   ChkId         inc   ShellPgm                 Set ShellPgm = TRUE (non-zero);................................................................;; Now we can look for our real command operand (Skip command name first);;................................................................         stz   ParmLen                  Ensure high byte is zero (Memory)         lda   #0                       Ensure high byte is zero (Acc)         shortm                         8-bit accumulator & memory         ldy   #L:IdString              Point to first byte of command line data         jsr   GetToken                 Skip our command name;................................................................;; Transfer the first parameter to the pathname buffer, unless; its the 'continous play' parameter (-C) switch.;;................................................................         jsr   GetToken                 Get pathname         lda   ParmBuf                  Get first character         cmp   #'-'                     Switch parameter?         bne   GetPath                  No, go get the pathname         lda   Parmlen                  Get the length         cmp   #2                       Two characters?         bne   GoPErr1                  No, invalid switch parameter         lda   ParmBuf+1                Get actual switch         and   #$DF                     Make upper case         cmp   #'C'                     Is the 'continuous play' switch?         beq   *+5GoPErr1  brl   ParmErr3                 No, invalid switch parameter         inc   Parm3Flg                 Say we found a '-C' parameter         jsr   GetToken                 Find next parameter; Now get the pathname parameterGetPath  anop         lda   ParmLen                  Get parameter length (low byte only)         sta   PathBuf                  Store in length byte         bne   *+5         brl   Prompt                   No pathname, go prompt         tax         dex                            Turn length into offsetLoop1    anop         lda   ParmBuf,X                Get next character         sta   PathBuf+1,X              Fill the pathname buffer         dex                            Bump PathBuf index         bpl   Loop1                    Not done yet         inc   Parm1Flg                 Say we got a pathname parameter;................................................................;; Transfer the second parameter to the auxtype buffer as the playback rate;;................................................................         jsr   GetToken                 Get next parameter (playback rate)         lda   ParmLen                  Get parameter length         sta   AuxLen                   Store in length field         bne   *+5         brl   GotPath                  No playback rate, use default         tax                            Transfer 16 bits!         dex                            Turn length into offset         cpx   #L:AuxBuf                Parameter too long?         blt   Loop2         jsr   ParmErr2                 Too long!         brl   GotPathLoop2    lda   ParmBuf,X                Get next character         sta   AuxBuf,X                 Fill the auxtype buffer         dex                            Bump AuxBuf index         bpl   Loop2                    Not done yet         longm; Convert value into an integer word value         pea   0                        Space for tool call result         lda   AuxBuf         and   #$007F                   Ignore high byte and bit         cmp   #'$'                     Hex parameter         beq   CvtHex         pushlong #AuxBuf               String address         pushword AuxLen                String length         pea   0                        Unsigned integer only        _Dec2Int                        Convert decimal string to integer         bcc   StorFreq                 All done, let's leave         jsr   ParmErr2         brl   GotPathCvtHex   anop         pushlong #AuxBuf+1             String address (ignore '$' sign)         ldx   AuxLen                   String length         dex                            Ignore '$'         phx        _Hex2Int                        Convert hexadecimal string to integer         bcc   StorFreq                 All done, let's leave         jsr   ParmErr2         brl   GotPathStorFreq anop         pullword SFreq                 Store in sound frequency parameter         inc   Parm2Flg                 Say we got a playback rate parameter         brl   GotPath                  We already have a pathname;................................................................;; Check the Message Center for a pathname passed by the Finder;; The returned Message Center handle points to a structure :-;        dp    NextMessage              Internal link;        dc    i'Type'                  Type = 1 (always at present);        dc    i'Action'                Action = 0 = Open files;                                              = 1 = Print files;        str   'Pathname 1'             Pathname of first file;        str   'Pathname 2'             Pathname of second file (if present);        ...                            Pathnames of other files (if present);        dc    i1'0'                    Byte terminator;;................................................................MsgCenter anop         lda   Played                   Done any yet?         beq *+5         brl NextMsg         pushlong #0                    Result - Handle         pushlong #8                    Input  - Size required         pushword UserId                Input  - UserId         pea      0000                  Input  - Attributes         pushlong #0                    Input  - Required address (ignored)        _NewHandle         bcc   *+5         brl   ToolErr                  Handle any error         pla         sta   MsgHndle                 Store the handle         pla         sta   MsgHndle+2         pea   0002                     Action = 2 = Get         pea   0001                     Type = 1 = Information         pushlong MsgHndle              Handle to message        _MessageCenter                  Call message center         bcc   *+5         brl   Prompt                   Error = No message available         inc   MsgCFlag                 Say we have been passed a 'message'; Found a 'message' - treat as a pathname         lda   [MsgHndle]               Dereference handle         sta   MsgAddr         ldy   #2         lda   [MsgHndle],Y         sta   MsgAddr+2         lda   MsgAddr         clc         adc   #8                       Skip header info         sta   MsgAddr         bcc   *+4         inc   MsgAddr+2         bra   CopyMsg                  Go copy the message; Handle repeated multiple filesNextMsg  anop         lda   [MsgAddr]                Get length of last message         and   #$00FF                   One byte only!         inc   A                        Add 1 for length byte         clc         adc   MsgAddr         sta   MsgAddr                  Point to next message         bcc   CopyMsg         inc   MsgAddr+2; Copy to the pathname bufferCopyMsg  anop         short         lda   [MsgAddr]                Get length         beq   MsgDone                  Zero - no more messages         cmp   #&MaxBuf+1               Can we handle it?         bcs   Prompt                   No, just go prompt         tay                            Make length into an indexMsgCLoop anop         lda   [MsgAddr],Y              Get a byte         sta   PathBuf,Y                Copy to pathname buffer         dey         bpl   MsgCLoop                 Copy length byte as well         long         brl   GotPath                  Go process the fileMsgDone  anop         long         brl   Exit                     No more files!;................................................................;; Prompt the caller for a pathname;;................................................................Prompt   anop         longm                          16 bit memory & registers         writeln         writestr PrmptMsg         pushlong #PathBuf+1            Pathname buffer         pea   PathLen                  Maximum line length         jsl   ReadLn                   Go get an input line; Store the length - if zero, then exit         writeln                        Move to next line         pla                            Get character count         bne   *+5         brl   Exit                     None, time to go         stz   Replay                   Reset 'replay' flag         shortm         sta   PathBuf                  Store length in Pstring         cmp   #1                       One character only?         bne   ChkPlyBk                 No, continue normally         lda   PathBuf+1                Get the character         cmp   ReplayCh                 Was it the 'replay' flag         bne   ChkPlyBk                 No, continue normally         longm         lda   Handle                   Do we have anything to replay?         ora   Handle+2         beq   Prompt                   No, so can't repeat it         inc   Replay                   Set 'replay' flag         brl   PlayIt                   Play it again, Sam...;................................................................;; See whether we got a request to change the default playback rate;;................................................................ChkPlyBk anop         longa off         lda   PathBuf+1                Get the first character         cmp   ChangeCh                 Was it the 'change rate' flag         beq   *+5         brl   GotPath         lda   PathBuf                  Get parameter length         dec   A                        Ignore flag character         sta   AuxLen                   Store in length field         bne   *+5         brl   Prompt                   No actual rate, go prompt again         tax                            Transfer 16 bits!         dex                            Turn length into offset         cpx   #L:AuxBuf                Parameter too long?         blt   Loop2P         bra   RateErr                  Too long!Loop2P   lda   PathBuf+2,X              Get next character         sta   AuxBuf,X                 Fill the auxtype buffer         dex                            Bump AuxBuf index         bpl   Loop2P                   Not done yet         longm; Convert value into an integer word value         pea   0                        Space for tool call result         lda   AuxBuf         and   #$007F                   Ignore high byte and bit         cmp   #'$'                     Hex parameter         beq   CvtHexP         pushlong #AuxBuf               String address         pushword AuxLen                String length         pea   0                        Unsigned integer only        _Dec2Int                        Convert decimal string to integer         bcc   StorFrqP                 All done, let's leave         bra   RateErrCvtHexP  anop         pushlong #AuxBuf+1             String address (ignore '$' sign)         ldx   AuxLen                   String length         dex                            Ignore '$'         phx        _Hex2Int                        Convert hexadecimal string to integer         bcs   RateErrStorFrqP anop         pullword SFreq                 Store in sound frequency parameter         inc   Parm2Flg                 Say we have a playback rate parameter         writeln #'New playback rate set'         brl   Prompt                   Back to prompting; Handle an error in the new rateRateErr  anop         jsr   ParmErr2                 Just a variation on a normal parm error         stz   Parm2Flg                 Invalidate the current value (for msg)         lda   AuxType                  Get last used file type         bne   StoreIt                  We did actually have one!         lda   #&DefFreq                Use default if we mustStoreIt  sta   SFreq                    Reset frequency value         brl   Prompt;................................................................;; Got a pathname - handle wildcards if under the Shell;;................................................................GotPath  anop         longm                          Ensure 16 bit memory & registers         lda   ShellPgm                 Running under the Shell?         bne   *+5         brl   DoGetInf                 No, can't handle wild cards        _Init_WildCard WildParm         bcc   *+5                      Check that we found a pathname         brl   ToolErr* Get next pathnameGetNext  anop        _Next_WildCard WildParm         Get next (first) filename, if any; Check that we actually found a valid pathname - else PathBuf is now blank         lda   PathBuf                  Get length byte         and   #$00FF                   Interested in first byte only         beq   *+5         brl   DoGetInf                 Pathname present (and found!)         lda   Played                   How many done so far?         beq   *+5                      None, means a problem         brl   GoAgain                  Else just means we've finished         bra   BadPath;................................................................;; Some path or file or whatever that we couldn't handle - tell the user;;................................................................DirPath  anop         writestr #'Cannot process directory file - '         bra   BadPath3BadPath  anop         pha                            Save pathname length         writestr #'Unable to find or access '         pla         beq   BadPath4                 Pathname unavailableBadPath3 writeln  PathBuf         brl   PromptBadPath4 writeln  #'the specified file'         brl   Prompt;................................................................;; Get file info for length and auxtype (= 'standard' playback rate);;................................................................DoGetInf anop        _Get_File_Info InfoParm         Get file's directory details         bcc   GetInfOK         jsr   ChkError                 Error we can handle?         bcc   *+5         brl   BadPath                  Yes, a group we will call 'bad path'         brl   ToolErr; In order, use parm value, auxtype value or default value for playback rateGetInfOK anop         lda   FileType                 Check file type         cmp   #$0F                     DIR file?         bne   *+5;;;;     brl   DirPath                  Treat like a bad pathname         brl   EndFile                  Simply ignore it!; Check that we are not trying to play ourself! (eg. clicking on PLAY in Finder); Make the assumption that we will never explicitly play an EXE or S16 file.         cmp   #$B3                     EXE file?         beq   DoLoadF                  Yes         cmp   #$B5                     S16 file?         bne   NotLoad                  NoDoLoadF  anop         stz   MsgCFlag                 Prevent Message Center functions         brl   Prompt                   Go prompt for a real pathnameNotLoad  anop; Get the playback rate (from somewhere)         lda   Parm2Flg                 Were we given a playback frequency?         beq   UseAux                   No, so use auxtype         lda   SFreq                    Have we got a (valid) value already?         bne   DoOpen                   Yes, use itUseAux   lda   AuxType                  Get low word of auxtype         bne   SetFreq                  Check for a zero value         lda   #&DefFreq                Get the default frequencySetFreq  sta   SFreq                    Use as the frequency;................................................................;; Open the file, allocate a buffer and load the file into the buffer;;................................................................DoOpen   anop         writestr PathBuf               Write the pathname         pushword SFreq                 Push playback rate         pushlong #RateStr              Target string address         pea   L:RateStr                Length of target string        _Int2Hex                        Convert to hexadecimal         writeln  RateMsg               Tell the user the playback rate        _Open  OpenParm                 Open the file (no error after GetInfo)         lda   ORefNum                  Copy reference number...         sta   RRefNum                  ...to READ parmlist         sta   ERefNum                  ...to GetEOF parmlist        _Get_EOF GEofParm               Get end-of-file         lda   EOF                      Copy length...         sta   RBufSize                 ...to NewHandle parameter list         lda   EOF+2         sta   RBufSize+2         lda   EOF+1                    Copy length in 'pages'...         sta   SBufSize                 ...to FFStartSound parameter list; Allocate a buffer and store its address         jsr   FreeMem                  Free any previously allocated memory         pushlong #0                    Result - Handle to buffer         pushlong RBufSize              Input - Amount to allocate         pushword UserId                Input - UserId (with our auxid)         pushword #$C008                Input - Attributes (fixed/locked/normal)         Pushlong #0                    Input - 0 = Dummy address        _NewHandle         bcc   *+5         brl   ToolErr                  Handle an unexpected error         pulllong Handle                Store handle in direct page         lda   [Handle]                 Dereference the handle         sta   RBufAddr                 Read parm list         sta   SbufAddr                 Sound parm list         ldy   #2         lda   [Handle],Y         sta   RBufAddr+2               Read parm list         sta   SbufAddr+2               Sound parm list; Read the file into the buffer        _Read  ReadParm        _Close OpenParm;................................................................;; DisPLAY the results (so to speak, or sing, or ...);;................................................................PlayIt   anop; Support continuous mode by placing the parm addr. in the next p/block addr.         stz   NxtSound                 Default is once-off mode         stz   NxtSound+2         lda   Parm3Flg                 Continuous mode?         beq   InitSnd                  No, go initialise the sound tools         lda   #<SoundPrm               Point 'next' address to this parm. block         sta   NxtSound         lda   #^SoundPrm         sta   NxtSound+2InitSnd  anop; Start the sound tools         phd                            Get...         pla                            ...Direct page address         clc         adc   #ZeroPage                Point to our ZP gift to sound tools         pha                            1 page of direct page for sound tools        _SoundStartUp         bcc   StartSnd         cmp   #$0818                   Sound Tools already started?         beq   StartSnd                 Yes, ignore the error         brl   ToolErr                  Handle an unexpected errorStartSnd anop         pea   $0002                    Generator 1 (= B'00000000 00000010')        _FFStopSound                    Stop the generator (just for safety)         pea   $0101                    FreeForm mode=01, channel=0, generator=1         pushlong #SoundPrm             Parameter block address        _FFStartSound                   Start the sound playing         bcc   *+5         brl   ToolErr                  Handle an unexpected error; Wait around until the sound finishes ('never' by default in continuous mode!)ChkSound anop         jsr   ChkStop                  <Option>-. or <Apple>-. pressed to stop?         cmp   #0                       This test IS required!         bne   EndSound                 Yes, finish up early         pea   0000                     Result - Sound status         pea   0001                     Input  - Generator 1        _FFSoundDoneStatus              Sound finished yet?         pla         beq   ChkSound                 Zero, so not finished yet         lda   #0                       Fake stop flag; Shut down the sound tools completely (also stops any generators)EndSound anop         pha                            Save Acc        _SoundShutDown         pla         cmp   #2                       <Option>-. pressed?         beq   Exit                     Yes, abandon all files         inc   Played                   Increment '# of files played' counter;................................................................;; Go around again if we were in 'prompt' mode or wildcard mode;;................................................................EndFile  anop         lda   ShellPgm                 Shell program?         beq   *+5         brl   GetNext                  Get next (wildcard) filename, if any         lda   MsgCFlag                 Message center data present?         beq   *+5         brl   MsgCenter                Get next Message Center filename, if anyGoAgain  anop         lda   Parm1Flg                 Did we get a path parm (ie. no prompt)?         bne   Exit                     Yes, so exit immediately         brl   Prompt                   Otherwise, go again;................................................................;; Exit - Return to our caller;;................................................................Exit     anop         jsr   FreeMem                  Free any memory we have allocated         jsr   FreeMem2                 Free any Message Center memory         pushlong InGlobals             Restore global variables        _SetInGlobals        _TextShutDown                   Close down the Text Tool toolset        _IMShutDown                     Close down the Integer Math toolset         lda   #0                       Return code of zero        _Quit  QuitParm                 Return to our caller (Shell traps Quit);................................................................;; FreeMem - Free the currently allocated memory; =======;           On entry: m, x = 0;                     Handle contains handle of area to be freed (or null);;................................................................FreeMem  anop         lda   Handle                   Nothing to free?         ora   Handle+2         beq   FreeMemX                 No, return immediately         pushlong Handle                Our program requested memory        _DisposeHandle                  Free it for someone else         bcs   GoTErr                   Handle any error         stz   Handle                   Reset...         stz   Handle+2                      ...handleFreeMemX rts; Handle tool errors - Pop return address from stack firstGoTErr   anop         tax                            Save Acc         pla                            Pop return address from stack         txa         brl   ToolErr                  Go handle error;................................................................;; FreeMem2 - Free any allocated Message Center memory; ========;           On entry: m, x = 0;                     MsgHndle contains handle of area to be freed (or null);;................................................................FreeMem2 anop         lda   MsgHndle                 Nothing to free?         ora   MsgHndle+2         beq   FreeMem2X                No, return immediately         pushlong MsgHndle        _DisposeHandle                  Free the memory         bcs   GoTErr                   Handle any error         stz   MsgHndle                 Reset...         stz   MsgHndle+2                    ...handleFreeMem2X rts;................................................................;; GetToken - Look for the next command line token, if any.; ========   Maximum token length is 64 characters.;; On entry, Y = offset into command line;           m = 1 (8 bit accumulator mode); On exit,  ParmBuf contains the parameter;           ParmLen contains the length;           Y = offset of last token char + 1;           Exit via RTS; On error, GOTO ParmErr;;................................................................GetToken anop         longa off; Blank the parameter buffer for safety         ldx   #L:ParmBuf-1         lda   #' 'BlankIt  sta   ParmBuf,X                Blank parameter buffer for safety         dex         bpl   BlankIt         stz   ParmLen                  Ensure parameter length is zero; Skip any leading blanksSkipBlnk anop         lda   [ParmPtr],Y              Get character         beq   GTExit                   End of string         cmp   #' '                     Non-blank yet?         bne   SkipDone                 Found first operand byte         iny         bne   SkipBlnkSkipDone anop; Transfer the parameter to the pathname buffer         ldx   #0               CopyTokn anop         sta   ParmBuf,X                Fill the parameter buffer         inx                            Bump ParmBuf index         cpx   #L:ParmBuf               Token too long?         blt   CopyTok2         pla                            Pop the...         pla                                   ...return address         brl   ParmErr                  Yes, go whinge about itCopyTok2 iny                            Bump Parameter index         lda   [ParmPtr],Y              Get next character         beq   CopyDone                 End of string - done!         cmp   #' '                     Blank delimiter?         bne   CopyTokn                 No, not done yetCopyDone anop         txa                            Convert to 8 nits         sta   ParmLen                  Save parameter lengthGTExit   rts         longa on;................................................................;; ChkStop - Check to see if <Open-Apple>-Period or <Option>-Period have been; =======   pressed to leave early.;; On exit, Acc = 1 if <Open-Apple>-Period has been pressed. (Stop one file);              = 2 if <Option>-Period has been pressed. (Stop all files);              = 0 otherwise.;          X,Y unchanged; m = 0;          Keyboard strobe has been reset always;;................................................................ChkStop  anop         lda   #$E1                     Ensure high byte is zero in 16 bit mode         shortm         phb                            Save data bank         pha                            Set bank to $E10000         plb                            Set data bank         lda   $C000                    Key pressed?         bpl   EndStop1                 No, so all done         msb   on                       High bit needed for next test         cmp   #'.'                     Test for period (.)         msb   off         bne   EndStop1                 No, just leave         bit   $C025                    Look for Open-Apple or Option modifier         bvs   HaltSet                  <Option> key         bpl   EndStop1                 Not <Apple> key, just leaveStopSet  lda   #1                       Flag 'stop' requested         bra   EndStop2HaltSet  lda   #2                       Flag 'halt' requested         bra   EndStop2EndStop1 lda   #0                       No action resultEndStop2 anop         sta   $C010                    Reset keystrobe always         plb                            Restore data bank         longm                          Restore long accumulator         rts                            Return to our caller;................................................................;; ChkError - Test for ProDOS / GS/OS errors which we can treat as 'bad pathname'; ========;            On entry, Acc = Error code;            On exit,  Acc, X, Y unchanged;                      Carry set if 'recognised error';                      Carry clear if any other error;;................................................................ChkError anop         aif   .NOT.&Debug,.ChkGo       'Debug only' code         pha                            Save error code         writestr #'ChkError: Code = '         pla         pha         jsr   ShowAcc                  Show the code         writeln         pla.ChkGo         cmp   #$10                     Device not found         blt   ChkErr2                  Error too small!         beq   ChkErrX         cmp   #$11                     Invalid device request         beq   ChkErrX         cmp   #$28                     No device connected         beq   ChkErrX         cmp   #$2F                     Device not online         beq   ChkErrX         cmp   #$40                     Syntax error?         beq   ChkErrX         cmp   #$44                     Path/Volume/File error?         blt   ChkErr2                  No, too small         cmp   #$47         blt   ChkErrX                  Yes ($44, $45, $46)         cmp   #$4E                     Access not allowed?         beq   ChkErrXChkErr2  clc                            Must be some other error         rts                            Return to our callerChkErrX  sec                            Default 'bad path' error         rts                            Return to our caller;................................................................;; ToolErr - Print an error message after a tool error, then restart; =======   at 'Prompt'. Use the Shell's utility routine, if possible.;;           On entry, Acc = Error code;;................................................................ToolErr  anop         sta   ErrCode         cmp   #$0201                   'Unable to allocate memory' error?         beq   ToolErr3                 Always handle it ourselves         ldx   ShellPgm                 Test for Shell facilities         beq   ToolErr2                 Not running under Shell; can't use ERROR        _Error ErrCode         brl   Prompt; Oh well, we have to do it ourselvesToolErr2 anop                           Second best error message from us         cmp   #$0027                   I/O error?         beq   ToolErr4                 Real error message         pha                            Push error code         pushlong #ErrorStr             Target string address         pea   L:ErrorStr               Length of target string        _Int2Hex                        Convert to hexadecimal         writeln ErrorMsg               Tell the user         brl   PromptToolErr3 anop                           A worthwhile message         writestr #'Insufficient memory to load '         writestr PathBuf         brl   PromptToolErr4 anop                           A worthwhile message         writestr #'I/O error on '         writestr PathBuf         brl   Prompt;................................................................;; ParmErr - Print an error message for a parameter that is too long; =======;................................................................ParmErr  anop         long                           16 bit memory & registers         writeln         writestr #'Pathname length more than &MaxBuf characters'         brl   Prompt                   Go get a decent pathnameParmErr2 anop                           SUBROUTINE!!!         long                           16 bit memory & registers         writeln         writeln  #'Speed parameter too long, or syntax is invalid.'         writestr #'Speed will default to AUXTYPE value, or &DefFreq if '         writeln  #'AUXTYPE = 0'         rts                            Continue processingParmErr3 anop         long                           16 bit memory & registers         writeln         writestr #'Uknown parameter option ('         writestr ParmLen               Write unknown character(s)         writeln  #')'         brl   Exit                     Leave in a huff         aif   .NOT.&Debug,.sa2;................................................................;; ShowAcc - Display the contents of the Accumulator on the screen in hexadecimal; =======;           On entry, Acc = Value to be displayed (eg. abcd).;           On exit,  'abcd' has been written to standard output.;;................................................................ShowAcc  anop         gblb  &longa         gblb  &longi&longa   setb  S:longa&longi   setb  S:longi         php                            Save m & x status         rep   #$30                     Ensure long registers for tool call         longa on         longi on         pha                            Value to display         pushlong #HexBuf               Output buffer         pea   L:HexBuf                 Output buffer length        _Int2Hex         writestr HexMsg                Display the results         plp                            Restore m & x status         rtsHexMsg   dc    i1'L:HexBuf+1',c'$'HexBuf   ds    4         aif   &longa,.sa1         longa off.sa1     aif   &longi,.sa2         longi off.sa2;................................................................;; Data areas;;................................................................IdString dc    c'BYTEWRKS'              Shell id stringUserId   ds    2                        Memory Manager UserId (passed by caller)InGlobals ds   4                        Save area for input global parametersShellPgm ds    2                        0 = Not running under the Shell / ORCA/MParm1Flg ds    2                        0 = No pathname parm (ie. must prompt)Parm2Flg ds    2                        0 = No playback rate parm foundParm3Flg ds    2                        0 = No continuous play parm foundReplay   ds    2                        0 = Repeat play not requestedPlayed   ds    2                        0 = No files played yetMsgCFlag ds    2                        0 = No 'Message Center' dataParmLen  ds    1                        Parameter token lengthParmBuf  ds    &MaxBuf                  Parameter token bufferHelloMsg str   '&SYSNAME v&VER - Copyright 1989-2000 by Peter Watson'Eyeball  str   '&SYSNAME v&VER - &SYSDATE &SYSTIME'PrmptMsg dc    i1'LenPMsg'              'Prompt for pathname' message         dc    c'File to play ('ReplayCh dc    c'\'                     Replay last sound character         dc    c' to replay, '''ChangeCh dc    c'#'         dc    c'rate'' to change rate) >'LenPMsg  equ   *-PrmptMsg-1AuxBuf   ds    4                        Speed parameter token bufferAuxLen   ds    2                        Speed parameter token lengthPathBuf  dc    i1'0',&MaxBuf.c' '       Set by ReadLine, or command linePathLen  equ   *-PathBuf-1WildParm anop                           Parm for Init_Wildcard & Next_WildCard         dp    PathBuf                  Pathname pointer         dc    i'$0000'                 '?' wildcards OK; use all of themInfoParm anop                           Get_File_Info parameter list         dp    PathBuf                  Pathname         ds    2                        AccessFileType ds    2                        FiletypeAuxType  ds    4                        Auxtype         ds    14                       Other odds and endsOpenParm anop                           Open & Close parameter listORefNum  ds    2                        RefNum         dp    PathBuf                  PathnameGEofParm anop                           Get_EOF parameter listERefNum  ds    2                        RefNumEOF      ds    4                        End of file (= length)ReadParm anop                           Read parameter listRRefNum  ds    2                        RefNumRBufAddr ds    4                        Buffer addressRBufSize ds    4                        Requested amount to read         ds    4                        Amount actually readSoundPrm anop                           FFStartSound parameter listSBufAddr ds    4                        Wave start addressSBufSize ds    2                        Waveform size (in pages)SFreq    ds    2                        Waveform playback frequency         dc    i2'$0100'                DOC buffer start address         dc    i2'$2000'                DOC buffer size (max. is $8000)NxtSound dc    i4'0'                    Next waveform buffer (or null)         dc    i2'255'                  VolumeRateMsg  dc    i1'RMsgLen'              Playback rate message         dc    c' (Rate=$'RateStr  dc    c'0000'         dc    c')'RMsgLen  equ   *-RateMsg-1ErrorMsg dc    i1'EMsgLen'              Error message         dc    c'Error $'ErrorStr dc    c'0000'                  Filled by Int2Hex         dc    c' occurred'EMsgLen  equ   *-ErrorMsg-1ErrCode  ds    2                        Tool error codeQuitParm dp    0                        Pathname (Return via Quit stack)         dc    i'0'                     Flags         end