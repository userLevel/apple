{---------------------------------------------------------------}{                                                               }{  Convert 1.0                                                  }{                                                               }{  Converts interpreted Integer BASIC programs from the         }{  interpreted file format ($F2) to an ASCII file format        }{  suitable for use by the Integer BASIC compiler.              }{                                                               }{  By Mike Westerfield                                          }{  June 1991                                                    }{                                                               }{  Copyright 1991                                               }{  By the Byte Works, Inc.                                      }{                                                               }{---------------------------------------------------------------}{                                                               }{  Use:                                                         }{                                                               }{  CONVERT sourceName                                           }{                                                               }{  sourceName   Input file name.                                }{                                                               }{---------------------------------------------------------------}{$keep 'Convert'}{$optimize 1}program Convert (input, output, errorOutput);uses Common, ORCAShell, ProDOS, MemoryMgr;const   SRC = $B0;                           {source file type}   IBASIC = 4;                          {Integer BASIC language number}   maxUnknown = 10;                     {# unknown tokens before abort}type   fileName = string[64];               {ProDOS file name}var                                        {command line and tokens}                                        {-----------------------}   cLine: string[255];                  {command line}   cDisp: integer;                      {disp of next char in cLine}   cLength: integer;                    {length(cLine) - for efficiency}   token: string[255];                  {token from cLine, null if no more}                                        {file name}                                        {---------}   sourceName: fileName;                {Integer BASIC input file}                                        {input file buffer}                                        {-----------------}   cHandle: handle;                     {file buffer handle}   cPtr: ptr;                           {next byte in the file buffer}   cLen: longint;                       {number of bytes left in the file}                                        {errors}                                        {------}   peekPokeCall: boolean;               {any found?}   anyUnknown: boolean;                 {unknown tokens?}   totalUnknown: integer;               {# unknown tokens found}procedure NextToken;{ Read the next word from the command line                      }var   len: integer;                        {length of token}   function IsWhite (ch: char): boolean;   { See if the character is whitespace                         }   {                                                            }   { Parameters:                                                }   {    ch - character to check                                 }   {                                                            }   { Returns: true if whitespace, else false                    }   const      tab = 9;                          {tab character code}   begin {IsWhite}   IsWhite := ch in [' ', chr(tab)];   end; {IsWhite}begin {NextToken}len := 0;while (cDisp <= cLength) and IsWhite(cLine[cDisp]) do   cDisp := cDisp+1;while (cDisp <= cLength) and (not IsWhite(cLine[cDisp])) do begin   len := len+1;   token[len] := cLine[cDisp];   cDisp := cDisp+1;   end; {while}token[0] := chr(len);end; {NextToken}function GetNames: boolean;{ Read the input and output names from the command line         }{                                                               }{ Returns: true if successful, false for an error               }var   error: integer;                      {ToolError result}   iwRec: initWildcardDCB;              {init wildcard record}   nxRec: nextWildcardDCB;              {next wildcard record}   tName: fileName;                     {temp name for expansion phase}begin {GetNames}NextToken;                              {skip the command name}if length(token) = 0 then begin         {ask for a command name}   write('Integer BASIC file name: ');   readln(cLine);   cDisp := 1;   cLength := length(cLine);   NextToken;   end; {if}if length(token) = 0 then   GetNames := false                    {no name given - quit}else begin   GetNames := true;   sourceName := token;                 {record the source name}   NextToken;                           {get the next field (if any)}   iwRec.wFile := @sourceName;          {expand wildcards, .., devices}   iwRec.flags := $4000;   Init_Wildcard(iwRec);   error := ToolError;   if error = 0 then begin      nxRec.nextFile := @tName;      Next_Wildcard(nxRec);      error := ToolError;      if (error = 0) and (length(tName) = 0) then         error := $46 {file not found}      else         sourceName := tName;      end; {if}   if error <> 0 then begin             {flag the error}      writeln(errorOutput, 'The file ', sourceName,         ' could not be read.  (Error ', error:1, '.)');      GetNames := false;      end; {else}   if length(token) <> 0 then begin     {check for garbage on the line}      writeln(errorOutput, 'Extra input ignored - processing stopped.');      GetNames := false;      end; {if}   end; {else}end; {GetNames}procedure HandleErrors;{ Print any warnings                                            }begin {HandleErrors}if peekPokeCall then   writeln(errorOutput, 'WARNING: This program contains peeks, pokes, calls.');if anyUnknown then   writeln(errorOutput, 'WARNING: This program could not be converted (search file for "[").');end; {HandleErrors}procedure Initialize;{ Set up global variables and the command line scanner          }begin {Initialize}cHandle := nil;                         {no file buffer handle allocated}CommandLine(cLine);                     {read the command line}cDisp := 1;                             {set up to read the first character}cLength := length(cLine);               {set the length of the command line}NextToken;                              {read the first token}peekPokeCall := false;                  {none found}anyUnknown := false;                    {no unknown tokens so far}totalUnknown := 0;                      {no unknown tokens so far}end; {Initialize}function ReadSourceFile: boolean;{ Read the source file                                          }{                                                               }{ Returns: true if successful, false for an error               }var   clRec: closeDCB;                     {Close record}   error: integer;                      {ToolError result}   efRec: eofDCB;                       {GetEOF record}   rdRec: readWriteDCB;                 {Read record}   opRec: openDCB;                      {Open record}   function FileType (fName: fileName): integer;   { Find the file type of a file                               }   {                                                            }   { Parameters:                                                }   {    fName - file name to check                              }   {                                                            }   { Returns: file type; -1 for error                           }   var      giRec: getFileInfoDCB;            {GetFileInfo record}   begin {FileType}   giRec.pathName := @fName;   P16Get_File_Info(giRec);   if ToolError = 0 then      FileType := giRec.fileType   else      FileType := -1;   end; {FileType}begin {ReadSourceFile}if FileType(sourceName) = $FA then begin   opRec.pathName := @sourceName;   opRec.reserved := 0;   P16Open(opRec);   error := ToolError;   if error = 0 then begin      rdRec.refnum := opRec.refNum;      clRec.refnum := opRec.refnum;      efRec.refNum := opRec.refnum;      P16Get_EOF(efRec);      error := ToolError;      if error = 0 then begin         cHandle := NewHandle (efRec.fileSize, userID, $C000, nil);         error := ToolError;         if error = 0 then begin            cPtr := cHandle^;            cLen := efRec.fileSize;            end; {if}         end; {if}      if error = 0 then begin         rdRec.dataBuffer := cPtr;         rdRec.requestCount := efRec.fileSize;         P16Read(rdRec);         error := ToolError;         end; {if}      P16Close(clRec);      end; {if}   if error = 0 then      ReadSourceFile := true   else begin      ReadSourceFile := false;      writeln(errorOutput, sourceName,         ' could not be read.  (Error ', error:1, '.)');      end; {else}   end {if}else begin   ReadSourceFile := false;   writeln(ErrorOutput, sourceName, ' is not an Integer BASIC program.');   end; {else}end; {ReadSourceFile}procedure SetFileType (fName: fileName; fType, auxType: integer);{ Set the file type and auxiliary file type for a file          }{                                                               }{ Parameters:                                                   }{    fName - file name                                          }{    fType - file type                                          }{    auxType - auxiliary file type                              }var   giRec: getFileInfoDCB;               {GetFileInfo record}   siRec: setFileInfoDCB;               {SetFileInfo record}begin {SetFileType}giRec.pathName := @fName;               {get the current info}P16Get_File_Info(giRec);if ToolError = 0 then begin   siRec.pathName := @fName;            {set the new info}   siRec.access := giRec.access;   siRec.fileType := fType;   siRec.auxType := auxType;   siRec.nullField := 0;   siRec.createDate := giRec.createDate;   siRec.createTime := giRec.createTime;   siRec.modDate := 0;   siRec.modTime := 0;   P16Set_File_Info(siRec);   end {if}else   writeln(errorOutput, 'Could not set the filetype for ', fName);end; {SetFileType}procedure Translate;{ Translate the interpreted program to text                     }   procedure TranslateLine;   { Translate one line from the program                        }   var      lineLength: integer;              {bytes left in the line}      function GetByte: integer;      { Read one byte from the output file                      }      begin {GetByte}      GetByte := cPtr^;      if cLen <> 0 then begin         cLen := cLen-1;         cPtr := pointer(ord4(cPtr)+1);         end; {if}      end; {GetByte}      procedure WriteToken (token: integer);      { Write one token to the output file                      }      begin {WriteToken}      case token of         $01: ;         $03: write(': ');         $04: write('LOAD ');         $05: write('SAVE ');         $07: write('RUN ');         $09: write('DEL ');         $0A: write(',');         $0B: write('NEW ');         $0C: write('CLR ');         $0D: write('AUTO ');         $0F: write('MAN ');         $10: write('HIMEM: ');         $11: write('LOMEM: ');         $12: write('+');         $13: write('-');         $14: write('*');         $15: write('/');         $16: write('=');         $17: write('#');         $18: write('>=');         $19: write('>');         $1A: write('<=');         $1B: write('<>');         $1C: write('<');         $1D: write(' AND ');         $1E: write(' OR ');         $1F: write(' MOD ');         $20: write('^');         $22: write('(');         $23: write(',');         $24,         $25: write(' THEN ');         $26,         $27: write(',');         $28: begin              write('"');              repeat                 token := GetByte;                 lineLength := lineLength-1;                 if token = $29 then                    write('"')                 else                    write(chr(token));              until (token = $29) or (lineLength = 0);              end;         $2A: write('(');         $2D: write('(');         $2E: begin              write('PEEK');              peekPokeCall := true;              end;         $2F: write('RND');         $30: write('SGN');         $31: write('ABS');         $32: write('PDL ');         $34: write('(');         $35: write('+');         $36: write('-');         $37: write('NOT ');         $38: write('(');         $39: write('=');         $3A: write('#');         $3B: write('LEN (');         $3C: write('ASC (');         $3D: write('SCRN (');         $3E: write(',');         $3F: write(' (');         $40: write('$');         $42: write('(');         $43,         $44: write(',');         $45,         $46,         $47: write(';');         $48,         $49: write(',');         $4A: write(',');         $4B: write('TEXT');         $4C: write('GR');         $4D: begin              write('CALL ');              peekPokeCall := true;              end;         $4E,         $4F: write('DIM ');         $50: write('TAB ');         $51: write('END');         $52,         $53,         $54: write('INPUT ');         $55: write('FOR ');         $56: write(' = ');         $57: write(' TO ');         $58: write(' STEP ');         $59: write('NEXT ');         $5A: write(',');         $5B: write('RETURN');         $5C: write('GOSUB ');         $5D: begin              write('REM ');              repeat                 token := GetByte;                 lineLength := lineLength-1;                 if token <> $01 then                    write(chr(token));              until (token = $01) or (lineLength = 0);              end;         $5E: write('LET ');         $5F: write('GOTO ');         $60: write('IF ');         $61,         $62: write('PRINT ');         $63: write('PRINT');         $64: begin              write('POKE ');              peekPokeCall := true;              end;         $65: write(',');         $66: write('COLOR=');         $67: write('PLOT ');         $68: write(',');         $69: write('HLIN ');         $6A: write(',');         $6B: write(' AT ');         $6C: write('VLIN ');         $6D: write(',');         $6E: write(' AT ');         $6F: write('VTAB ');         $70,         $71: write(' = ');         $72: write(')');         $74: write('LIST ');         $75: write(',');         $77: write('POP ');         $79: write('NO DSP ');         $7A: write('NO TRACE ');         $7B,         $7C: write('DSP ');         $7D: write('TRACE ');         $7E: write('PR #');         $7F: write('IN #');         $B0,$B1,$B2,$B3,$B4,$B5,$B6,$B7,$B8,$B9: begin              write(GetByte+GetByte*256:1);              lineLength := lineLength-2;              end;         $C1,$C2,$C3,$C4,$C5,$C6,$C7,$C8,$C9,$CA,$CB,$CC,$CD,$CE,$CF,$D0,         $D1,$D2,$D3,$D4,$D5,$D6,$D7,$D8,$D9,$DA: begin              write(chr(token&$7F));              while (cPtr^ > 127) and (chr(cPtr^&$7F) in ['A'..'Z','0'..'9'])                 do begin                 write(chr(GetByte&$7F));                 lineLength := lineLength-1;                 end; {while}              end;         otherwise: begin              write('[', token:1, ']');              anyUnknown := true;              totalUnknown := totalUnknown+1;              if totalUnknown = maxUnknown then begin                 writeln(errorOutput, 'Too many unknown tokens (probably machine code); aborting.');                 lineLength := 1;                 cLen := 0;                 end; {if}              end;         end; {case}      end; {WriteToken}   begin {TranslateLine}   lineLength := GetByte;               {get the length of the line}   lineLength := lineLength-3;          {write the line number}   write(GetByte+GetByte*256:1, ' ');   while lineLength <> 0 do begin      WriteToken(GetByte);      lineLength := lineLength-1;      end; {while}   writeln;   end; {TranslateLine}begin {Translate}while cLen <> 0 do   TranslateLine;end; {Translate}beginInitialize;                             {set up global variables}if GetNames then                        {read the file names}   if ReadSourceFile then               {read in the source file}      Translate;                        {translate the program}HandleErrors;                           {print appropriate error messages}if cHandle <> nil then                  {if we allocated memory, free it}   DisposeHandle(cHandle);end.