{---------------------------------------------------------------}{                                                               }{  Scanner                                                      }{                                                               }{  The scanner is responsible for reading and converting the    }{  source file into a series of tokens the compiler             }{  understands.  This scanner is also the interface between     }{  the compiler and the ORCA shell.                             }{                                                               }{  Copyright 1991                                               }{  By the Byte Works, Inc.                                      }{                                                               }{---------------------------------------------------------------}{                                                               }{  Global subroutines:                                          }{                                                               }{  FlagError - Flag an error                                    }{  InitScanner - Initialize the scanner                         }{  NextCh - Read the next character from the source file        }{  NextToken - Read the next token from the source file         }{  ShutDownScanner - Shut down the scanner                      }{  TermError - Handle a terminal error                          }{                                                               }{---------------------------------------------------------------} unit Scanner; interfaceuses Common, ProDOS, ORCAShell, MemoryMgr;{$libprefix '0/obj/'}uses BASICCom;{---------------------------------------------------------------}const                                        {special character codes}                                        {-----------------------}   ch_eoln = 13;                        {end of line}   ch_eof = 0;                          {end of file}var   ch: char;                            {current character}{---------------------------------------------------------------}procedure InitScanner;{ Initialize the file input module                              }procedure FlagError (errNum: integer);{ Flag an error                                                 }{                                                               }{ Parameters:                                                   }{    errNum - error number                                      }procedure NextCh;{ Read the next character from the source file                  }{                                                               }{ Variables:                                                    }{    ch - character read from the file                          }{    cp - pointer to the next character                         }{    fileLength - number of characters left in the file         }procedure NextToken;{ Read the next token from the source file                      }{                                                               }{ Variables:                                                    }{    ch - current character                                     }{    token - token read                                         }procedure ShutDownScanner;{ Shut down the file input module                               }procedure TermError (err: integer);{ Handle a terminal error                                       }{                                                               }{ Parameters:                                                   }{    err - terminal error number                                }{- Private declarations ----------------------------------------}implementationconst   minCh = 0;                           {range of characters}   maxCh = 127;   maxErrors = 6;                       {max errors on one source line}                                        {bit masks for GetLInfo flags}                                        {----------------------------}   flag_d       = $10000000;            {generate debug code?}   flag_e       = $08000000;            {abort to editor on terminal error?}   flag_l       = $00100000;            {list source lines?}   flag_m       = $00080000;            {memory based compile?}   flag_s       = $00002000;            {list text code and symbols?}   flag_t       = $00001000;            {treat all errors as terminal?}   flag_w       = $00000200;            {wait when an error is found?}                                        {tokens}                                        {------}   tokenLength = 8;                     {length of a token string}type                                        {character types}   chType = (chLetter, chNumber, chQuote, chIllegal, chcolon,             chComma, chSemicolon, chLParen, chRParen, chEq,             chLt, chGt, chPound, chPlus, chMinus,             chMult, chDivd, chExp, chSpace, chDollar,             chEof, chEoln);   tokenString = packed array[1..8] of char; {token string}var                                        {error tracking and reporting}                                        {----------------------------}   numErr: integer;                     {number of errors found on this line}   errors: array[1..maxErrors] of       {array of errors on the current line}      record      err: integer;                     {error number}      pos: integer;                     {position in source line}      lineNumber: integer;              {source line number}      end;                                        {lexical variables}                                        {-----------------}   chTypes: array[char] of chType;      {character types array}                                        {shell interface variables}                                        {-------------------------}   lInfo: lInfoDCB;                     {shell interface info}   names: cString;                      {partial compile name list (not used)}   parameters: cString;                 {language dependent parms (not used)}                                        {source file variables}                                        {---------------------}   cp: bytePtr;                         {pointer to the next char in the file}   cpos: integer;                       {column number for ch}   tpos: integer;                       {cpos at start of last token}   tlineNumber: integer;                {lineNumber at start of last token}   fileLength: longint;                 {number of characters left in the file}   lineStart: bytePtr;                  {cp at start of current line}   ofileLength: longint;                {original file length}                                        {tokens}                                        {------}   tokenNames: array[abssy..vtabsy] of tokenString; {names of the tokens}   tokenIndex: array['A'..'['] of tokens; {start index for each letter}{- Subroutines -------------------------------------------------}procedure FlagError {errNum: integer};{ Flag an error                                                 }{                                                               }{ Parameters:                                                   }{    errNum - error number                                      }begin {FlagError}if numErr < maxErrors then begin        {prevent an array overflow}   numErr := numErr+1;                  {record the error}   numErrors := numErrors+1;   if numErr = maxErrors then      errNum := 2;   with errors[numErr] do begin      err := errNum;      pos := tpos;      lineNumber := tlineNumber;      end; {with}   end; {if}end; {FlagError}procedure NextCh;{ Read the next character from the source file                  }{                                                               }{ Variables:                                                    }{    ch - character read from the file                          }{    cp - pointer to the next character                         }{    fileLength - number of characters left in the file         }   procedure PrintLine;   { Print the current line (if necessary)                      }   {                                                            }   { Variables:                                                 }   {    lineStart - cp at the start of the last line            }   {    listSource - list the source file?                      }   {    numErr - number of errors on this line                  }   {    lineNumber - current line number                        }   var      i: 1..maxErrors;                  {loop variable}      ptr: bytePtr;                     {used to print the line}      function KeyPress: boolean;      { See if a key has been pressed; clear strobe if so       }      var         cp: bytePtr;                   {work pointer}      begin {KeyPress}      cp := pointer($00C000);           {get the keyboard latch}      KeyPress := false;                {assume to char}      if (cp^ & $0080) <> 0 then begin         KeyPress := true;              {found a character}         if cp^ = ord('.')+$80 then     {check for abort (open-apple .)}            begin            cp := pointer($00C061);            if (cp^ & $0080) <> 0 then               TermError(4);            {abort the compile}            end; {if}         cp := pointer($00C010);        {clear the keyboard strobe}         cp^ := 0;         end; {if}      end; {KeyPress}   begin {PrintLine}   if listSource or (numErr <> 0) then begin      write(lineNumber:4, ' ');         {print the line number}      ptr := lineStart;                 {print the line}      while (ptr^ <> ch_eoln) do begin         write(chr(ptr^));         ptr := bytePtr(ord4(ptr)+1);         end; {while}      writeln;      for i := 1 to numErr do begin     {print any errors}         case errors[i].err of            1:  msg := 'illegal character';            2:  msg := 'further errors supressed';            3:  msg := '''='' expected';            4:  msg := concat('identifiers must be ', cnvis(nameLength),                              ' or fewer characters long');            5:  msg := concat('integers cannot exceed ', cnvis(maxint));            6:  msg := concat('string constants must be ', cnvis(stringLength),                              ' or fewer characters long');            7:  msg := '''"'' expected';            8:  msg := 'illegal line number';            9:  msg := 'line number expected';            10: msg := 'extra symbols ignored';            11: msg := 'error in expression';            12: msg := 'expression type must be integer';            13: msg := ''','' expected';            14: msg := '''at'' expected';            15: msg := '''then'' expected';            16: msg := 'too many nested for loops';            17: msg := 'loop variable must be an integer';            18: msg := '''to'' expected';            19: msg := 'integer constant expected';            20: msg := 'next without for';            21: msg := 'next does not match for';            22: msg := 'duplicate variable';            23: msg := '''('' expected';            24: msg := ''')'' expected';            25: msg := 'operation cannot be performed on a string';            26: msg := 'array size must be greater than 0';            27: msg := 'identifier expected';            28: msg := 'implementation restriction: program is too large';            29: msg := 'implementation restriction: too many local labels';            30: msg := 'implementation restriction: too many string constants';            31: msg := 'variable is not an array';            32: msg := 'type conflict';            33: msg := 'expression type must be string';            34: msg := 'string compares for =, # only';            end; {case}         if lineNumber = errors[i].lineNumber then            writeln('^ ':6+errors[i].pos, msg)         else            writeln('Error at character ', errors[i].pos:1, ' of line ',               errors[i].lineNumber:1, ': ', msg);         if terminal then            TermError(0);         end; {for}      if KeyPress or (wait and (numErr <> 0)) then         while not KeyPress do ;      end; {if}   lineNumber := lineNumber+1;          {start a new line}   lineStart := cp;   cpos := 0;   numErr := 0;   end; {PrintLine}begin {NextCh}if ch = chr(ch_eoln) then begin         {if we finished a line then...}   PrintLine;                           {print the line}   lineType := step;                    {assume this is a normal line}   end; {if}if fileLength <> 0 then begin           {get the next character}   ch := chr(cp^);   cp := bytePtr(ord4(cp)+1);   fileLength := fileLength-1;   cpos := cpos+1;   if ch = chr($84) then begin          {check for auto-go, break point}      lineType := breakpoint;      lineStart := cp;      NextCh;      end {if}   else if ch = chr($81) then begin      lineType := autogo;      lineStart := cp;      NextCh;      end; {else if}   end {if}else   ch := chr(ch_eof);end; {NextCh}procedure InitScanner;{ Initialize the file input module                              }   procedure InitArrays;   { Initialize the scanner arrays                              }   const      TAB = 9;                          {tab key code}   var      ch: char;                         {loop variable}   begin {InitArrays}   for ch := chr(minCh) to chr(maxCh) do {set up the char types array}      chTypes[ch] := chIllegal;   for ch := 'a' to 'z' do      chTypes[ch] := chLetter;   for ch := 'A' to 'Z' do      chTypes[ch] := chLetter;   for ch := '0' to '9' do      chTypes[ch] := chNumber;   chTypes['"'] := chQuote;   chTypes[':'] := chColon;   chTypes[','] := chComma;   chTypes[';'] := chSemicolon;   chTypes['('] := chLParen;   chTypes[')'] := chRParen;   chTypes['='] := chEq;   chTypes['<'] := chLt;   chTypes['>'] := chGt;   chTypes['#'] := chPound;   chTypes['+'] := chPlus;   chTypes['-'] := chMinus;   chTypes['*'] := chMult;   chTypes['/'] := chDivd;   chTypes['^'] := chExp;   chTypes[' '] := chSpace;   chTypes['$'] := chDollar;   chTypes[chr(TAB)] := chSpace;   chTypes[chr(ch_eof)] := chEof;   chTypes[chr(ch_eoln)] := chEoln;   tokenNames[abssy    ] := 'ABS';      {initialize the token names array}   tokenNames[andsy    ] := 'AND';   tokenNames[ascsy    ] := 'ASC';   tokenNames[atsy     ] := 'AT';   tokenNames[callsy   ] := 'CALL';   tokenNames[colorsy  ] := 'COLOR';   tokenNames[dimsy    ] := 'DIM';   tokenNames[endsy    ] := 'END';   tokenNames[forsy    ] := 'FOR';   tokenNames[gosubsy  ] := 'GOSUB';   tokenNames[gotosy   ] := 'GOTO';   tokenNames[grsy     ] := 'GR';   tokenNames[hgrsy    ] := 'HGR';   tokenNames[hlinsy   ] := 'HLIN';   tokenNames[ifsy     ] := 'IF';   tokenNames[inputsy  ] := 'INPUT';   tokenNames[lensy    ] := 'LEN';   tokenNames[letsy    ] := 'LET';   tokenNames[modsy    ] := 'MOD';   tokenNames[nextsy   ] := 'NEXT';   tokenNames[notsy    ] := 'NOT';   tokenNames[orsy     ] := 'OR';   tokenNames[pdlsy    ] := 'PDL';   tokenNames[plotsy   ] := 'PLOT';   tokenNames[popsy    ] := 'POP';   tokenNames[printsy  ] := 'PRINT';   tokenNames[remsy    ] := 'REM';   tokenNames[returnsy ] := 'RETURN';   tokenNames[rndsy    ] := 'RND';   tokenNames[scrnsy   ] := 'SCRN';   tokenNames[sgnsy    ] := 'SGN';   tokenNames[stepsy   ] := 'STEP';   tokenNames[tabsy    ] := 'TAB';   tokenNames[textsy   ] := 'TEXT';   tokenNames[text80sy ] := 'TEXT80';   tokenNames[thensy   ] := 'THEN';   tokenNames[tosy     ] := 'TO';   tokenNames[vlinsy   ] := 'VLIN';   tokenNames[vtabsy   ] := 'VTAB';   tokenIndex['A'] := abssy;            {initialize the token index array}   tokenIndex['B'] := callsy;   tokenIndex['C'] := callsy;   tokenIndex['D'] := dimsy;   tokenIndex['E'] := endsy;   tokenIndex['F'] := forsy;   tokenIndex['G'] := gosubsy;   tokenIndex['H'] := hgrsy;   tokenIndex['I'] := ifsy;   tokenIndex['J'] := lensy;   tokenIndex['K'] := lensy;   tokenIndex['L'] := lensy;   tokenIndex['M'] := modsy;   tokenIndex['N'] := nextsy;   tokenIndex['O'] := orsy;   tokenIndex['P'] := pdlsy;   tokenIndex['Q'] := remsy;   tokenIndex['R'] := remsy;   tokenIndex['S'] := scrnsy;   tokenIndex['T'] := tabsy;   tokenIndex['U'] := vlinsy;   tokenIndex['V'] := vlinsy;   tokenIndex['W'] := succ(vtabsy);   tokenIndex['X'] := succ(vtabsy);   tokenIndex['Y'] := succ(vtabsy);   tokenIndex['Z'] := succ(vtabsy);   tokenIndex['['] := succ(vtabsy);   end; {InitArrays}   procedure InitScalars;   { Initialize the scanner's scalars                           }   begin {InitScalars}   numErrors := 0;                      {no errors so far}   numErr := 0;   maxErrorLevel := 0;                  {max error level is 0}   lineNumber := 1;                     {first line in the file}   lineStart := cp;                     {record the start of the 1st line}   cpos := 0;                           {initialize the column number}   ofileLength := fileLength;           {save the starting file length}   lineType := step;                    {normal debugger line type}   end; {InitScalars}   procedure InitShell;   { Handle the initial communication with the shell            }   var      destroyRec: destroyDCB;           {P16Destroy record}      name: pathName;                   {path name}      suffix: string[2];                {suffix character}   begin {InitShell}   with lInfo do begin                  {set up the pointers}      sFile := @sourceFile;      dFile := @keepFile;      namesList := @names;      iString := @parameters;      end; {with}   GetLInfo(lInfo);                     {read the command line stuff}   if ToolError <> 0 then      TermError(1);   destroyRec.pathName := @name;        {delete any old obj files}   name := concat(keepFile, '.root');   P16Destroy(destroyRec);   suffix := '.a';   repeat      name := concat(keepFile, suffix);      P16Destroy(destroyRec);      suffix[2] := succ(suffix[2]);   until ToolError <> 0;   keep := lInfo.keepFlag <> 0;         {set the command line flag variables}   debug := (lInfo.pFlags & flag_d) <> 0;   edit := (lInfo.pFlags & flag_e) <> 0;   listSource := (lInfo.pFlags & flag_l) <> 0;   memory := (lInfo.pFlags & flag_m) <> 0;   listSymbols := (lInfo.pFlags & flag_s) <> 0;   terminal := (lInfo.pFlags & flag_t) <> 0;   wait := (lInfo.pFlags & flag_w) <> 0;   end; {InitShell}   procedure ReadFile;   { Read the source file                                          }   {                                                               }   { Variables:                                                    }   {    sourceFile - source file name                              }   {    cp - pointer to the first character in the file            }   {    fileLength - number of characters in the file              }   var      ffRec: fastFileDCB;               {FastFile record}   begin {ReadFile}   with ffRec do begin                  {read the file from disk}      action := 0;      index := 0;      flags := $C000;      name := @sourceFile;      end; {with}   FastFile(ffRec);   if ToolError <> 0 then      TermError(2);   fileLength := ffRec.file_length;     {record the file length}   cp := bytePtr(ffRec.file_handle^);   {set the file pointer}   end; {ReadFile}begin {InitScanner}InitShell;                              {read and process the command line info}ReadFile;                               {read the source file}InitScalars;                            {initialize the scalars}InitArrays;                             {initialize the constant arrays}NextCh;                                 {get the first character}NextToken;                              {get the first token}end; {InitScanner}procedure NextToken;{ Read the next token from the source file                      }{                                                               }{ Variables:                                                    }{    ch - current character                                     }{    token - token read                                         }label 1;var   digit: integer;                      {value of a numeric character}   len: integer;                        {length of a stringConst or ident}   s: tokens;                           {loop variable}begin {NextToken}while chTypes[ch] in [chSpace,chDollar,chIllegal] do begin   if chTypes[ch] in [chIllegal,chDollar] then begin      tpos := cpos;      tlineNumber := lineNumber;      FlagError(1);      end; {if}   NextCh;   end; {while}tpos := cpos;                           {remember where this token starts}tlineNumber := lineNumber;case chTypes[ch] of   chLetter: begin      token.kind := ident;              {assume it is an identifier}      len := 0;                         {read the identifier}      while chTypes[ch] in [chLetter, chDollar, chNumber] do begin         if len = nameLength then begin            FlagError(4);            len := 0;            end; {if}         len := len+1;         if ch in ['a'..'z'] then            ch := chr(ord(ch)-ord('a')+ord('A'));         token.name[len] := ch;         NextCh;         end; {while}      token.name[0] := chr(len);      for s := tokenIndex[token.name[1]] to {check for reserved words}         pred(tokenIndex[succ(token.name[1])]) do         if token.name = tokenNames[s] then begin            token.kind := s;            goto 1;            end; {if}1:      end;   chNumber: begin      token.kind := intconst;      token.ival := 0;      while chTypes[ch] = chNumber do begin         digit := ord(ch) - ord('0');         if ((token.ival = (maxint div 10)) and (digit > (maxint mod 10)))            or (token.ival > (maxint div 10)) then begin            FlagError(5);            token.ival := 0;            end;         token.ival := token.ival*10 + digit;         NextCh;         end; {while}      end;   chQuote: begin      token.kind := stringconst;      len := 0;      NextCh;      while not (chTypes[ch] in [chQuote, chEoln, chEof]) do begin         if len = stringLength then begin            FlagError(6);            len := 0;            end; {if}         len := len+1;         token.str[len] := ch;         NextCh;         end; {while}      if chTypes[ch] = chQuote then         NextCh      else         FlagError(7);      token.str[0] := chr(len);      end;   chColon: begin      token.kind := colon;      NextCh;      end;   chComma: begin      token.kind := comma;      NextCh;      end;   chSemicolon: begin      token.kind := semicolon;      NextCh;      end;   chLParen: begin      token.kind := lParen;      NextCh;      end;   chRParen: begin      token.kind := rParen;      NextCh;      end;   chEq: begin      token.kind := eq;      NextCh;      end;   chLt: begin      NextCh;      if ch = '=' then begin         token.kind := le;         NextCh;         end {if}      else if ch = '>' then begin         token.kind := ne;         NextCh;         end {else if}      else         token.kind := lt;      end;   chGt: begin      NextCh;      if ch = '=' then begin         token.kind := ge;         NextCh;         end {if}      else         token.kind := gt;      end;   chPound: begin      NextCh;      token.kind := ne;      end;   chPlus: begin      token.kind := plus;      NextCh;      end;   chMinus: begin      token.kind := minus;      NextCh;      end;   chMult: begin      token.kind := mult;      NextCh;      end;   chDivd: begin      token.kind := divd;      NextCh;      end;   chExp: begin      token.kind := exp;      NextCh;      end;   chEoln: begin      token.kind := eolnsy;      NextCh;      end;   chEOF:      token.kind := eofsy;   end; {case}end; {NextToken}procedure ShutDownScanner;{ Shut down the file input module                               }var   ffRec: fastFileDCB;                  {FastFile record}begin {ShutDownScanner}with ffRec do begin                     {mark the source file as purgeable}   action := 7;   index := 0;   flags := $C000;   name := @sourceFile;   end; {with}FastFile(ffRec);if numErrors <> 0 then begin            {set the correct error codes}   lInfo.opFlags := 0;   if terminal then      lInfo.merrf := 128   else      lInfo.merrf := maxErrorLevel;   end {if}else begin   lInfo.opFlags := lInfo.opFlags & $FFFE; {set the opflags field}   if lInfo.keepFlag = 0 then      lInfo.opFlags := 0;   lInfo.sFile := @keepFile;            {set the link file name}   end; {else}Set_LInfo(lInfo);                       {pass the info back to the shell}end; {ShutDownScanner}procedure TermError {err: integer};{ Handle a terminal error                                       }{                                                               }{ Parameters:                                                   }{    err - terminal error number                                }begin {TermError}case err of                             {print the error}   0 : ; {used for +t errors}   1 : msg := concat('Error calling the shell.');   2 : msg := concat('Error reading ', sourceFile);   3 : msg := concat('Error writting ', keepFile);   4 : msg := concat('Compile aborted.');   end; {case}writeln('Terminal error: ', msg);       {write the error to stdout}lInfo.opFlags := 0;                     {stop subsequent compiles/links}if terminal then   lInfo.merrf := 128else   lInfo.merrf := 16;lInfo.origin := ofileLength-fileLength;lInfo.namesList := @msg;Set_LInfo(lInfo);Halt(-1);                               {stop execution}end; {TermError}end.