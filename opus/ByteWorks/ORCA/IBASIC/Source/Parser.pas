{---------------------------------------------------------------}{                                                               }{  Parser                                                       }{                                                               }{  The scanner is responsible for checking the syntax of the    }{  program.  In the process, it calls the symbol table          }{  subroutines.  The symmantics are built into the parser; the  }{  symmantic subroutines call the code generator.               }{                                                               }{  Copyright 1991                                               }{  By the Byte Works, Inc.                                      }{                                                               }{---------------------------------------------------------------}{                                                               }{  Global subroutines:                                          }{                                                               }{  Compile - Compile the program                                }{  InitParser - Initialize the parser                           }{                                                               }{---------------------------------------------------------------} unit Parser; interfaceuses Common;{$libprefix '0/obj/'}uses BASICCom, Scanner, CodeGen;procedure Compile;{ Compile the program                                           }procedure InitParser;{ Initialize the parser                                         }{- Private declarations ----------------------------------------}implementationconst   maxFor = 16;                         {max # of nested for statements}                                        {direct page map}                                        {---------------}   tempDP = 0;                          {temp work area}   index = 2;                           {index for lvalue}   wptr = 4;                            {work pointer}type                                        {labels}                                        {------}   labPtr = ^labRecord;                 {ptr to a label record}   labRecord = record                   {label record}      next: labPtr;                        {next record}      slineNumber: integer;                {line number for this label}      labelNumber: integer;                {label number for this line}      defined: boolean;                    {is the label defined?}      end;                                        {call statement permanent name list}                                        {----------------------------------}   callListPtr = ^callListRecord;       {ptr to a call list record}   callListRecord = record              {call list record}      next: callListPtr;                   {next record}      name: nameType;                      {subroutine name}      end;var   callList: callListPtr;               {call statement permanent name list}   expressionKind: expressionTypes;     {type of the last expression}   firstFor: boolean;                   {any for statements, yet?}   forStuff: array[1..maxFor] of record {for loop information}      symbol: symbolPtr;                  {loop variable}      step: integer;                      {step size}      top: integer;                       {top of loop variable}      exit: integer;                      {exit loop variable}      end;   slineNumber: -1..maxint;             {current BASIC source line number}   numFor: 0..maxFor;                   {number of active for statements}   minNumFor: 0..maxFor;                {max numFor during a GOSUB}                                        {lvalues}                                        {-------}   id: tokenType;                       {identifier}   indexed: boolean;                    {is the value indexed?}   lkind: expressionTypes;              {lvalue expression kind}                                        {labels}                                        {------}   labList: labPtr;                     {list of labels/line numbers}   symlabel: integer;                   {symbol table subroutine label}{- General Use Subroutines -------------------------------------}procedure InitParser;{ Initialize the parser                                         }begin {InitParser}slineNumber := -1;                      {no line numbers found, yet}numFor := 0;                            {no active for loops}minNumFor := 0;                         {no active for loops}firstFor := true;                       {no for statements}labList := nil;                         {no labels in the label list}callList := nil;                        {no subroutine names called, yet}end; {InitParser}procedure Match (sym: tokens; err: integer);{ Make sure the next token is sym                               }{                                                               }{ Parameters:                                                   }{    sym - expected symbol                                      }{    err - error to flag if sym is not found                    }begin {Match}if token.kind = sym then   NextTokenelse   FlagError(err);end; {Match}{- Symbol Tables -----------------------------------------------}function FindSymbol (var name: nameType): symbolPtr;{ Find a symbol in the symbol table, creating one if needed     }{                                                               }{ Parameters:                                                   }{    name - name of the symbol to find                          }{                                                               }{ Returns: Pointer to the symbol table entry                    }   function CreateSymbol: symbolPtr;   { Create a new symbol table entry                            }   {                                                            }   { Returns: Pointer to the symbol table entry                 }   var      sym: symbolPtr;                   {pointer to the new entry}   begin {CreateSymbol}   new(sym);                            {get space for the entry}   sym^.left := nil;                    {initialize the tree links}   sym^.right := nil;   sym^.name := name;                   {record the name}   if name[length(name)] = '$' then     {find and record the type}      sym^.kind := str   else      sym^.kind := int;   sym^.size := 0;                      {default size is 0}   sym^.newSymbol := true;              {this is a new symbol}   CreateSymbol := sym;   end; {CreateSymbol}   function Find (sym: symbolPtr): symbolPtr;   { Traverse the tree, looking for the symbol                  }   {                                                            }   { Parameters:                                                }   {    sym - pointer to the symbol to check                    }   {                                                            }   { Returns: Pointer to the symbol table entry                 }   begin {Find}   if sym^.name = name then begin      sym^.newSymbol := false;      Find := sym;      end {if}   else if sym^.name < name then begin      if sym^.left = nil then begin         sym^.left := CreateSymbol;         Find := sym^.left;         end {if}      else         Find := Find(sym^.left);      end {else if}   else {if sym^.name > name then} begin      if sym^.right = nil then begin         sym^.right := CreateSymbol;         Find := sym^.right;         end {if}      else         Find := Find(sym^.right);      end; {else}   end; {Find}begin {FindSymbol}if symbolTable = nil then begin   symbolTable := CreateSymbol;   FindSymbol := symbolTable;   end {if}else   FindSymbol := Find (symbolTable);end; {FindSymbol}{- Line Number Labels ------------------------------------------}function StatementLabel (lnum: integer; definition: boolean): integer;{ Find/create a label for a statement                           }{                                                               }{ Parameters:                                                   }{    lnum - line number                                         }{    definition - is this a definition?                         }{                                                               }{ Variables:                                                    }{    labList - head of the label list                           }{                                                               }{ Returns: label number for the line number                     }label 1;var   p: labPtr;                           {work pointer}begin {StatementLabel}p := labList;                           {find an existing label}while p <> nil do   if p^.slineNumber = lnum then      goto 1   else      p := p^.next;new(p);                                 {no label - create one}p^.next := labList;labList := p;p^.slineNumber := lnum;p^.labelNumber := GetLabel;p^.defined := false;1:if definition then                      {set the defined flag}   p^.defined := true;StatementLabel := p^.labelNumber;       {return the label number}end; {StatementLabel}procedure CheckLabels;{ Check for line number labels used but not found               }{                                                               }{ Variables:                                                    }{    labList - head of the label list                           }var   p: labPtr;                           {work pointer}begin {CheckLabels}p := labList;while p <> nil do begin   if not p^.defined then begin      msg := concat('Line number ', cnvis(p^.slineNumber),         ' was used but not defined.');      writeln('***  ', msg);      if terminal then         TermError(0);      numErrors := numErrors+1;      end; {if}   p := p^.next;   end; {while}end; {CheckLabels}{- Expressions -------------------------------------------------}procedure Expression (stop: tokenSet);{ Compile an expression                                         }{                                                               }{ Parameters:                                                   }{    stop - symbols other than eolnsy, eofsy and colon that     }{       can end the expression                                  }{                                                               }{ Variables:                                                    }{    expressionKind - type of the expression                    }   procedure CnvStrInt;   { Generate the code to convert a string to an integer        }   begin {CnvStrInt}   Gen0(m_pla);   Gen0(m_pla);   Gen1Byte(m_sta_dir, wptr);   Gen0(m_pla);   Gen1Byte(m_sta_dir, wptr+2);   Gen1Byte(m_lda_indl, wptr);   Gen1(m_and_imm, $00FF);   end; {CnvStrInt}   procedure AndOp;   { Compile an and operation                                   }      procedure CmpOp;         { Compile a compare                                       }         var         ekind: expressionTypes;        {temp expression kind}         operation: tokens;             {operation being performed}                        procedure PlusMinus;            { Compile a plus or minus                              }            var            operation: tokens;          {operation being performed}                  procedure MulOp;               { Compile a *, / or mod                             }               var               operation: tokens;       {operation being performed}                     procedure Exponent;                  { Compile an exponent operation                  }                        procedure Term;                     { Compile a term                              }                     var                     id: tokenType;     {identifier}                     symbol: symbolPtr; {symbol table entry}                     begin {Term}                  case token.kind of                     notsy: begin       {not}                        NextToken;                        Term;                        if expressionKind = str then begin                           FlagError(25);                           expressionKind := int;                           end; {if}                        Gen0Name(m_jsl, @'~LOGICAL');                        Gen1(m_eor_imm, 1);                        end;                        minus: begin       {-}                        NextToken;                        Term;                        if expressionKind = str then begin                           FlagError(25);                           expressionKind := int;                           end; {if}                        Gen1(m_eor_imm, $FFFF);                        Gen0(m_inc_A);                        end;                        plus: begin        {+}                        NextToken;                        Term;                        if expressionKind = str then begin                           FlagError(25);                           expressionKind := int;                           end; {if}                        end;                        lparen: begin      {(}                        NextToken;                        Expression(stop+[rparen]);                        Match(rparen, 24);                        end; {lparen}                        intconst: begin    {integer constant}                        Gen1(m_lda_imm, token.ival);                        NextToken;                        expressionKind := int;                        end;                        stringconst: begin {string constant}                        Gen0String(d_str, @token.str);                        NextToken;                        expressionKind := str;                        end;                        ident: begin       {identifier}                        id := token;    {find the identifier}                        symbol := FindSymbol(token.name);                        expressionKind := symbol^.kind;                        NextToken;                        if token.kind = lparen then begin                                        {handle an array}                           if symbol^.newSymbol then begin                              symbol^.newSymbol := false;                              symbol^.size := 10;                              end; {if}                           NextToken;                           if symbol^.kind = str then begin                                        {for strings, generate partial string}                              Gen0NameShift(m_pea, @id.name);                              Gen0Name(m_pea, @id.name);                              Expression(stop+[comma]);                              Gen0(m_pha);                              Match(comma, 13);                              Expression(stop+[rparen]);                              Gen0(m_pha);                              Gen0Name(m_jsl, @'~PARTIALSTRING');                              end {if}                           else begin                              if symbol^.size = 0 then                                 FlagError(31);                              Expression(stop+[rparen]);                              Gen0(m_asl);                              Gen0(m_tax);                              Gen0Name(m_lda_absx, @id.name);                              end; {else}                           Match(rparen, 24);                           end {if}                        else if expressionKind = str then begin                           Gen0NameShift(m_pea, @id.name);                           Gen0Name(m_pea, @id.name);                           Gen1(m_pea, 0);                           end {else if}                        else                           Gen0Name(m_lda_abs, @id.name);                        expressionKind := symbol^.kind;                        end;                        ascsy: begin       {asc function}                        NextToken;                        Match(lparen, 23);                        Expression(stop+[rparen]);                        if expressionKind <> str then                           FlagError(33);                        CnvStrInt;                        Match(rparen, 24);                        expressionKind := int;                        end;                        lensy: begin       {len function}                        NextToken;                        Match(lparen, 23);                        Expression(stop+[rparen]);                        if expressionKind <> str then                           FlagError(33);                        Gen0Name(m_jsl, @'~STRINGLENGTH');                        Match(rparen, 24);                        expressionKind := int;                        end;                        abssy: begin       {abs function}                        NextToken;                        Match(lparen, 23);                        Expression(stop+[rparen]);                        if expressionKind <> int then                           FlagError(12);                        Gen0Name(m_jsl, @'~INTABS');                        Match(rparen, 24);                        end;                        sgnsy: begin       {sgn function}                        NextToken;                        Match(lparen, 23);                        Expression(stop+[rparen]);                        if expressionKind <> int then                           FlagError(12);                        Gen0Name(m_jsl, @'~INTSGN');                        Match(rparen, 24);                        end;                        pdlsy: begin       {pdl function}                        NextToken;                        Match(lparen, 23);                        Expression(stop+[rparen]);                        if expressionKind <> int then                           FlagError(12);                        Gen0Name(m_jsl, @'~PDL');                        Match(rparen, 24);                        end;                        rndsy: begin       {rnd function}                        NextToken;                        Match(lparen, 23);                        Expression(stop+[rparen]);                        if expressionKind <> int then                           FlagError(12);                        Gen0Name(m_jsl, @'~RND');                        Match(rparen, 24);                        end;                        scrnsy: begin      {scrn function}                        NextToken;                        Match(lparen, 23);                        Expression(stop+[comma,rparen]);                        if expressionKind <> int then                           FlagError(12);                        Match(comma, 13);                        Gen0(m_pha);                        Expression(stop+[rparen]);                        if expressionKind <> int then                           FlagError(12);                        Gen0(m_plx);                        Gen0Name(m_jsl, @'~SCRN');                        Match(rparen, 24);                        end;                        otherwise:                        FlagError(27);                        end; {case}                  end; {Term}                     begin {Exponent}               Term;               while token.kind = exp do begin                  if expressionKind = str then begin                     FlagError(25);                     expressionKind := int;                     end; {if}                  NextToken;                  Gen0(m_pha);                  Term;                  if expressionKind = str then begin                     FlagError(25);                     expressionKind := int;                     end; {if}                  Gen0(m_plx);                  Gen0Name(m_jsl, @'~EXP');                  end; {while}               end; {MulOp}                  begin {MulOp}            Exponent;            while token.kind in [mult, divd, modsy] do begin               operation := token.kind;               if expressionKind = str then begin                  FlagError(25);                  expressionKind := int;                  end; {if}               NextToken;               Gen0(m_pha);               Exponent;               if expressionKind = str then begin                  FlagError(25);                  expressionKind := int;                  end; {if}               Gen0(m_plx);               if operation = mult then                  Gen0Name(m_jsl, @'~MULT')               else if operation = divd then                  Gen0Name(m_jsl, @'~DIVD')               else                  Gen0Name(m_jsl, @'~MOD');               end; {while}            end; {MulOp}               begin {PlusMinus}         MulOp;         while token.kind in [plus, minus] do begin            operation := token.kind;            if expressionKind = str then begin               FlagError(25);               expressionKind := int;               end; {if}            NextToken;            Gen0(m_pha);            MulOp;            if expressionKind = str then begin               FlagError(25);               expressionKind := int;               end; {if}            if operation = plus then begin               Gen0(m_clc);               Gen1Byte(m_adc_s, 1);               Gen0(m_plx);               end {if}            else begin               Gen1Byte(m_sta_dir, tempDP);               Gen0(m_pla);               Gen0(m_sec);               Gen1Byte(m_sbc_dir, tempDP);               end; {else}            end; {while}         end; {PlusMinus}      begin {CmpOp}      PlusMinus;                        {evaluate the term}      while token.kind in [eq, lt, gt, le, ge, ne] do begin         ekind := expressionKind;       {save the expression kind}         operation := token.kind;       {record the operation}         NextToken;                     {skip the operation}         if ekind = int then            {save the value}            Gen0(m_pha);         PlusMinus;                     {get the other term}         if expressionKind <> ekind then {check for type conflict}            FlagError(32);         if ekind = str then            {do the compare}            case operation of               eq: Gen0Name(m_jsl, @'~CMP_STR_EQ');               ne: Gen0Name(m_jsl, @'~CMP_STR_NE');               otherwise: FlagError(34);               end {case}         else {if ekind = int then}            case operation of               eq: Gen0Name(m_jsl, @'~CMP_EQ');               lt: Gen0Name(m_jsl, @'~CMP_LT');               gt: Gen0Name(m_jsl, @'~CMP_GT');               le: Gen0Name(m_jsl, @'~CMP_LE');               ge: Gen0Name(m_jsl, @'~CMP_GE');               ne: Gen0Name(m_jsl, @'~CMP_NE');               end; {case}         expressionKind := int;         end; {while}      end; {CmpOp}         begin {AndOp}   CmpOp;   while token.kind = andsy do begin      if expressionKind = str then begin         FlagError(25);         expressionKind := int;         end; {if}      NextToken;      Gen0Name(m_jsl, @'~LOGICAL');      Gen0(m_pha);      CmpOp;      if expressionKind = str then begin         FlagError(25);         expressionKind := int;         end; {if}      Gen0Name(m_jsl, @'~LOGICAL');      Gen1Byte(m_and_s, 1);      Gen0(m_plx);      end; {while}   end; {AndOp}begin {Expression}AndOp;                                  {evaluate the term}while token.kind = orsy do begin        {handle or operations}   if expressionKind = str then begin      FlagError(25);      expressionKind := int;      end; {if}   NextToken;   Gen0Name(m_jsl, @'~LOGICAL');   Gen0(m_pha);   AndOp;   if expressionKind = str then begin      FlagError(25);      expressionKind := int;      end; {if}   Gen0Name(m_jsl, @'~LOGICAL');   Gen1Byte(m_ora_s, 1);   Gen0(m_plx);   end; {while}                                        {skip any extraneous tokens}if not (token.kind in stop+[eolnsy, eofsy, colon]) then begin   FlagError(11);   while not (token.kind in stop+[eolnsy, eofsy, colon]) do      NextToken;   end; {if}end; {Expression}procedure LValue;{ Compile an l-value                                            }var   symbol: symbolPtr;                   {symbol table entry}begin {LValue}if token.kind = ident then begin   id := token;                         {save the identifier}   symbol := FindSymbol(token.name);   lkind := symbol^.kind;               {record the type}   NextToken;                           {skip the identifier}   if token.kind = lparen then begin      if symbol^.newSymbol then begin   {make sure the variable is declared}         symbol^.newSymbol := false;         symbol^.size := 10;         end; {if}      if (symbol^.kind = int) and (symbol^.size = 0) then         FlagError(31);      indexed := true;                  {find the index}      NextToken;      Expression([rparen]);      Match(rparen, 24);      if symbol^.kind = int then         Gen0(m_asl)      else         Gen0(m_dec_a);      Gen1Byte(m_sta_dir, index);      end {if}   else      indexed := false;                 {not indexed}   end {if}else   FlagError(27);end; {LValue}procedure Store;{ Store a result                                                }begin {Store}if expressionKind <> lkind then         {check for type conflict}   FlagError(32);if indexed then begin   if lkind = str then begin      Gen0NameShift(m_pea, @id.name);   {handle indexed string}      Gen0Name(m_pea, @id.name);      Gen1Byte(m_lda_dir, index);      Gen0(m_clc);      Gen1Byte(m_adc_s, 1);      Gen1Byte(m_sta_s, 1);      Gen0Name(m_jsl, @'~ASSIGNSTRING');      end {if}   else begin      Gen1Byte(m_ldx_dir, index);       {handle int array assignment}      Gen0Name(m_sta_absx, @id.name);      end; {else}   end {if}else begin   if lkind = str then begin      Gen0NameShift(m_pea, @id.name);   {handle unindexed string}      Gen0Name(m_pea, @id.name);      Gen0Name(m_jsl, @'~ASSIGNSTRING');      end {if}   else      Gen0Name(m_sta_abs, @id.name);    {handle int assignment}   end; {else}end; {Store}{- Statements --------------------------------------------------}procedure Statement;{ Compile a statement                                           }   procedure CheckEol;   { Check for garbage at the end of the line                   }   begin {CheckEol}   if not (token.kind in [colon, eolnsy]) then begin      FlagError(10);      while not (token.kind in [colon, eolnsy, eofsy]) do         NextToken;      end; {if}   end; {CheckEol}   procedure CallStatement;   { compile a call statement                                   }   var      nPtr: callListPtr;                {work pointer}      i: integer;                       {loop variable}   begin {CallStatement}   NextToken;                           {skip the call}   if token.kind = ident then begin      new(nPtr);                        {allocate a new name record}      nPtr^.next := callList;      callList := nPtr;      for i := 1 to length(token.name) do {uppercase the name}         if token.name[i] in ['a'..'z'] then            token.name[i] := chr(ord(token.name[i])-ord('a')+ord('A'));      nPtr^.name := token.name;         {make a permanent copy of the name}      Gen0Name(m_jsl, @nPtr^.name);      NextToken;                        {skip the subroutine name}      CheckEol;                         {check for garbage on the line}      end {if}   else      FlagError(27);   end; {CallStatement}   procedure ColorStatement;   { compile a color statement                                  }   begin {ColorStatement}   NextToken;   Match(eq, 3);   Expression([]);   if expressionKind <> int then      FlagError(12);   Gen0Name(m_jsl, @'~COLOR');   end; {ColorStatement}   procedure DimStatement;   { compile a dim statement                                    }   var      done: boolean;                    {loop termination variable}      symbol: symbolPtr;                {symbol table pointer}   begin {DimStatement}   NextToken;                           {skip the dim}   done := false;                       {loop until done}   repeat      if token.kind = ident then begin  {declare the identifier}         symbol := FindSymbol(token.name);         if not symbol^.newSymbol then  {make sure it is unique}            FlagError(22);         symbol^.newSymbol := false;         NextToken;         Match(lparen, 23);             {make suer the ( exists}         if token.kind = intconst then  {find the array dimension}            begin            if token.ival > 0 then               symbol^.size := token.ival            else               FlagError(26);            NextToken;            end {if}         else            FlagError(19);         Match(rparen, 24);             {make sure the ) exists}         if token.kind = comma then     {check for another array}            NextToken         else            done := true;         end {if}      else begin         FlagError(27);                 {handle a missing identifier}         while not (token.kind in [colon, eolnsy, eofsy]) do            NextToken;         end; {else}   until done;   CheckEol;                            {check for garbage on the line}   end; {DimStatement}   procedure ForStatement;   { compile a for statement                                    }   var      forTemp: nameType;                {fortemp label name space}      negative: boolean;                {is the step negative?}      symbol: symbolPtr;                {pointer to the for loop symbol}   begin {ForStatement}   if firstFor then begin               {if this is the first, create ~FORTEMPS}      firstFor := false;      forTemp := '~FORTEMPS';      symbol := FindSymbol(forTemp);      symbol^.size := maxFor-1;      end; {if}   if numFor = maxFor then begin        {handle too many nested for statements}      FlagError(16);      while not (token.kind in [colon, eolnsy, eofsy]) do         NextToken;      end {if}   else begin      numFor := numFor + 1;             {get a for array area}      if numFor < minNumFor then         numFor := minNumFor;      NextToken;                        {skip the for}      if token.kind = ident then begin  {do the initial assignment}         symbol := FindSymbol(token.name);         forStuff[numFor].symbol := symbol;         if (symbol^.kind <> int) or (symbol^.size <> 0) then            FlagError(17);         NextToken;         end {if}      else         FlagError(17);      Match(eq, 3);      Expression([tosy]);      Gen0Name(m_sta_abs, @symbol^.name);      Match(tosy, 18);                  {check for the to}      Expression([stepsy]);             {evaluate and save the stop value}      if expressionKind = str then begin         FlagError(25);         expressionKind := int;         end; {if}      Gen1Name(m_sta_abs, @'~FORTEMPS', (numFor-1)*2);      if token.kind = stepsy then begin {evaluate the step size}         NextToken;         negative := false;         if token.kind = minus then begin            negative := true;            NextToken;            end; {if}         if token.kind = intconst then begin            if negative then               forStuff[numFor].step := -token.ival            else               forStuff[numFor].step := token.ival;            NextToken;            end {if}         else            FlagError(19);         end {if}      else         forStuff[numFor].step := 1;      with forStuff[numFor] do begin    {allocate loop variables}         top := GetLabel;         Gen0Label(d_lab, top);         end; {with}      end; {else}   CheckEol;                            {check for junk at the end of the line}   end; {ForStatement}   procedure GosubStatement;   { compile a gosub statement                                  }   begin {GosubStatement}   NextToken;   if token.kind = intconst then begin      if numFor <> 0 then         if numFor >= minNumFor then            minNumFor := numFor + 1;      Gen0Label(m_jsr, StatementLabel(token.ival, false));      NextToken;      end {if}   else      FlagError(9);   CheckEol;   end; {GosubStatement}   procedure GotoStatement;   { compile a goto statement                                   }   begin {GotoStatement}   NextToken;   if token.kind = intconst then begin      if numFor <> 0 then         if numFor >= minNumFor then            minNumFor := numFor + 1;      Gen0Label(m_jmp, StatementLabel(token.ival, false));      NextToken;      end {if}   else      FlagError(9);   CheckEol;   end; {GotoStatement}   procedure HlinStatement;   { compile an hlin statement                                  }   begin {HlinStatement}   NextToken;   Expression([comma]);   Gen0(m_pha);   Match(comma, 13);   Expression([atsy]);   Gen0(m_pha);   Match(atsy, 14);   Expression([]);   Gen0(m_plx);   Gen0(m_ply);   Gen0Name(m_jsl, @'~HLIN');   end; {HlinStatement}   procedure IfStatement;   { compile an if statement                                    }   var      lab, lab2: integer;               {branch points}   begin {IfStatement}   NextToken;                           {skip the if}   Expression([thensy]);                {evaluate the condition}   if expressionKind = str then begin      FlagError(25);      expressionKind := int;      end; {if}   Gen0(m_tax);   Match(thensy, 15);                   {make sure the then is there}   lab := GetLabel;                     {get a true branch label}   if token.kind = intconst then begin      Gen0Relative(m_beq, lab);         {branch if false}      Gen0Label(m_jmp,                  {handle an "if exp then number"}         StatementLabel(token.ival, false));      Gen0Label(d_lab, lab);      NextToken;      CheckEol;      end {if}   else begin      Gen0Relative(m_bne, lab);         {branch if true}      lab2 := GetLabel;                 {handle a statement after the then}      Gen0Label(m_jmp, lab2);      Gen0Label(d_lab, lab);      Statement;      Gen0Label(d_lab, lab2);      end; {else}   end; {IfStatement}   procedure InputStatement;   { compile a input statement                                  }   var      done: boolean;                    {loop termination}   begin {InputStatement}   NextToken;                           {skip INPUT}   if token.kind = stringconst then     {print the prompt, if any}      begin      Expression([comma]);      Gen0Name(m_jsl, @'~PRINTSTRING');      Match(comma, 13);      end {if}   else      Gen0Name(m_jsl, @'~PROMPT');      {print the input prompt}   done := false;                       {read the values}   repeat      LValue;      if lkind = int then         Gen0Name(m_jsl, @'~INPUT')      else         Gen0Name(m_jsl, @'~INPUTSTR');      expressionKind := lkind;      Store;      if token.kind = comma then         NextToken      else         done := true;   until done;   Gen0Name(m_jsl, @'~ENDINPUT');       {dump the rest of the input line}   CheckEol;                            {make sure we are at the end of line}   end; {InputStatement}   procedure LetStatement;   { compile an assingment statement                            }   begin {LetStatement}   LValue;   Match(eq, 3);   Expression([]);   Store;   CheckEol;   end; {LetStatement}   procedure NextStatement;   { compile a next statement                                   }   label 1;   var      exit: integer;                    {temp label; for long branch}      symbol: symbolPtr;                {for loop variable}   begin {NextStatement}1: if numFor = 0 then begin      FlagError(20);      while not (token.kind in [colon, eolnsy, eofsy]) do         NextToken;      end {if}   else begin      NextToken;                        {skip the next or comma}      if token.kind = ident then begin  {check the loop variable}         symbol := FindSymbol(token.name);         if symbol <> forStuff[numFor].symbol then            FlagError(21);         NextToken;         end {if}      else         FlagError(17);      with forStuff[numFor] do begin         Gen0(m_clc);                   {increment/decrement the loop variable}         Gen0Name(m_lda_abs, @symbol^.name);         Gen1(m_adc_imm, step);         Gen0Name(m_sta_abs, @symbol^.name);         if step < 0 then begin         {test loop condition}            Gen0Name(m_lda_abs, @symbol^.name);            Gen0(m_pha);            Gen1Name(m_lda_abs, @'~FORTEMPS', (numFor-1)*2);            end {if}         else begin            Gen1Name(m_lda_abs, @'~FORTEMPS', (numFor-1)*2);            Gen0(m_pha);            Gen0Name(m_lda_abs, @symbol^.name);            end; {else}         Gen0Name(m_jsl, @'~CMP_GE');         Gen0(m_tax);         exit := GetLabel;         Gen0Relative(m_beq, exit);         Gen0Label(m_jmp, top);         {loop}         Gen0Label(d_lab, exit);        {exit loop label}         end; {with}      numFor := numFor-1;      end; {else}   if token.kind = comma then           {allow for multiple next vars}      goto 1;   CheckEol;                            {check for junk at the end of the line}   end; {NextStatement}   procedure PlotStatement;   { compile a plot statement                                   }   begin {PlotStatement}   NextToken;   Expression([comma]);   Gen0(m_pha);   Match(comma, 13);   Expression([]);   Gen0(m_plx);   Gen0Name(m_jsl, @'~PLOT');   end; {PlotStatement}   procedure PrintStatement;   { compile a print statement                                  }   var      lastWasSemicolon: boolean;        {was the last token a semicolon?}   begin {PrintStatement}   NextToken;   lastWasSemicolon := false;   repeat      if token.kind = comma then begin         lastWasSemicolon := true;         Gen0Name(m_jsl, @'~PRINTTAB');         NextToken;         end {if}      else if token.kind = semicolon then begin         lastWasSemicolon := true;         NextToken;         end {else if}      else if not (token.kind in [colon, eolnsy, eofsy]) then begin         lastWasSemicolon := false;         Expression([comma,semicolon]);         if expressionKind = int then            Gen0Name(m_jsl, @'~PRINTINT')         else            Gen0Name(m_jsl, @'~PRINTSTRING');         end; {else}   until token.kind in [colon, eolnsy, eofsy];   if not lastWasSemicolon then      Gen0Name(m_jsl, @'~PRINTEOL');   end; {PrintStatement}   procedure RemStatement;   { compile a rem statement                                    }   begin {RemStatement}   while not (ch in [chr(ch_eoln), chr(ch_eof)]) do      NextCh;   NextToken;   end; {RemStatement}   procedure TabStatement;   { compile a tab statement                                    }   begin {TabStatement}   NextToken;   Expression([]);   Gen0Name(m_jsl, @'~TAB');   end; {TabStatement}   procedure VlinStatement;   { compile an vlin statement                                  }   begin {VlinStatement}   NextToken;   Expression([comma]);   Gen0(m_pha);   Match(comma, 13);   Expression([atsy]);   Gen0(m_pha);   Match(atsy, 14);   Expression([]);   Gen0(m_plx);   Gen0(m_ply);   Gen0Name(m_jsl, @'~VLIN');   end; {VlinStatement}   procedure VtabStatement;   { compile a vtab statement                                   }   begin {VtabStatement}   NextToken;   Expression([]);   Gen0Name(m_jsl, @'~VTAB');   end; {VtabStatement}begin {Statement}case token.kind of   dimsy:       DimStatement;   callsy:      CallStatement;   colorsy:     ColorStatement;   endsy:       begin NextToken; Gen0Name(m_jml, @'~END'); end;   forsy:       ForStatement;   gosubsy:     GosubStatement;   gotosy:      GotoStatement;   grsy:        begin NextToken; Gen0Name(m_jsl, @'~GR'); end;   hgrsy:       begin NextToken; Gen0Name(m_jsl, @'~HGR'); end;   hlinsy:      HlinStatement;   ifsy:        IfStatement;   inputsy:     InputStatement;   nextsy:      NextStatement;   plotsy:      PlotStatement;   popsy:       begin NextToken; Gen0(m_ply); end;   printsy:     PrintStatement;   remsy:       RemStatement;   returnsy:    begin NextToken; Gen0(m_rts); end;   tabsy:       TabStatement;   textsy:      begin NextToken; Gen0Name(m_jsl, @'~TEXT'); end;   text80sy:    begin NextToken; Gen0Name(m_jsl, @'~TEXT80'); end;   vlinsy:      VlinStatement;   vtabsy:      VtabStatement;   letsy:       begin NextToken; LetStatement; end;   otherwise:   LetStatement;   end; {case}end; {Statement}{- Main Compiler -----------------------------------------------}procedure Compile;{ Compile the program                                           }begin {Compile}Gen0Name(d_bgn, @'BASIC');              {generate the start of the program}Gen0Name(m_jsl, @'~BASICSTARTUP');      {set up the BASIC environment}if debug then begin                     {set up the debugger}   Gen0String(d_sub, @'BASIC');   Gen0String(d_fil, @sourceFile);   symlabel := GetLabel;   Gen0Label(m_jsr, symLabel);   end; {if}while token.kind <> eofsy do begin   if debug then                        {generate the line number}      case lineType of         step:          Gen1(d_lnm, lineNumber);         breakpoint:    Gen1(d_brk, lineNumber);         autogo:        Gen1(d_ago, lineNumber);         end; {case}   if token.kind = intconst then begin  {handle a line number}      if token.ival <= slineNumber then         FlagError(8);      slineNumber := token.ival;      Gen0Label(d_lab, StatementLabel(token.ival, true));      NextToken;      end {if}   else      FlagError(9);   Statement;                           {compile a statement}   while token.kind = colon do begin    {compile any other statements}      NextToken;      Statement;      end; {while}   if token.kind <> eolnsy then begin   {check for garbage on the line}      FlagError(10);      while not (token.kind in [eolnsy, eofsy]) do         NextToken;      end {if}   else      NextToken;                        {skip the eoln}   while token.kind = eolnsy do         {allow blank lines}      NextToken;   end; {while}if debug then                           {shut down the debugger}   Gen0(d_exi);Gen0Name(m_jsl, @'~BASICSHUTDOWN');     {return to the launcher}if debug then begin                     {generate the symbol table}   Gen0Label(d_lab, symlabel);   GenDebugSymbols;   end; {if}GenStrings;                             {generate any string constants}Gen0(d_end);                            {flag the end of the program}GenSymbols;                             {create the symbol segment}CheckLabels;                            {check for undefined labels}end; {Compile}end.