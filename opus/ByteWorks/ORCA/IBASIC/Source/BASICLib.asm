	keep	obj/basiclib	mcopy basiclib.macros******************************************************************  BASICLib - Run-time library for the integer BASIC compiler.**  by Mike Westerfield*  May 1990**  Copyright 1990*  Byte Works, Inc.*******************************************************************  Libraries 1.0.2, November 1996, Mike Westerfield**  1.  Added code to BASICStartup and BASICShutdown to start*      and shut down the ORCA I/O system, making Integer BASIC*      compatible with the 2.0 ORCA libraries.*  2.  Removed output of LF from PrintEOL for compatibility*      with .CONSOLE as used by the ORCA libraries.*  3.  Added code to VTAB for compatibility with .CONSOLE.*******************************************************************  Libraries 1.0.1, November 1991, Mike Westerfield**  1.  ~InputStr now pushes the length of the string on the*      stack, rather than 0.******************************************************************BASICLib start		dummy subroutine	end******************************************************************  BasicCommon - common data area******************************************************************BasicCommon privdata;;  Common variables for line input;cnt	ds	2	chars left in line (see ~Input, ~EndInput)disp	ds	2	disp in lineline	dstr	,255	input line	dc	i'0'	buffer for null terminating the line;;  Common variables for text output;ch	ds	2	output column numberchMask	ds	2	40 column screen mask (for inverse)col80	dc	i'1'	1 -> 80 column output; 0 -> 40 column ouputcolor	ds	2	lowres graphics colorcolumn	ds	2	column number; tracked by output routinescv	ds	2	output line numberscreenSize dc	i'81'	screen width + 1top	ds	2	top line of text displaylineDisp dc	i'$400,$480,$500,$580,$600,$680,$700,$780'	dc	i'$428,$4A8,$528,$5A8,$628,$6A8,$728,$7A8'	dc	i'$450,$4D0,$550,$5D0,$650,$6D0,$750,$7D0';;  Misc global variables;QDHandle ds	4	handle for QD memoryuserID	ds	2	memory manager user ID	end******************************************************************  BASICStartup - set up the run-time environment******************************************************************~BASICStartup start	using BasicCommon	phk		establish local bank addressing	plb	sta	userID	save the user ID	stz	cnt	start with no input line	pha		if event manager not started then	_EMStatus	  {indicates prizm is not active}	pla	bne	lb1	pea	0	  initialize the mouse for ~Pdl	_InitMouselb1	jsl	SystemEnvironmentInit	set up the ORCA I/O system	jsl	SysIOStartup	rtl	end******************************************************************  BASICShutdown - shut down the run-time environment******************************************************************~BASICShutdown start~End	entry	using BasicCommon	jsl	SysIOShutDown	shut down the ORCA I/O system	jsl	~Text80	make sure quickdraw, 40 col text is off	lda	#0	return to the launcher	Quit	qtRecqtRec	dc	a4'qtFlags'	addr of next prog to launchqtFlags	dc	i'0'	flags; doubles as null string	end******************************************************************  AssignString - assign a string**  Parameters:*	from - address of the string to assign*	num - number of characters to assign; 0 for all*	to - address of the string to assign to******************************************************************~AssignString start	using BasicCommon	subroutine (4:from,2:len,4:to),0lb1	lda	[from]	while [addr]^ <> 0 do begin	and	#$00FF	beq	lb2!			  {long assign also assigns null terminator}	sta	[to]	  [to]^ := [from]^	inc4	from	  advance to the next character	inc4	to	dec	len	  loop	bne	lb1lb2	return	end******************************************************************  Bell - beep the bell******************************************************************Bell	start	lda	#7	jsr	~ChOut	rtl	end******************************************************************  ~ChOut - write a character**  Inputs:*	A - character to write******************************************************************~ChOut	private	using BasicCommon	phb		use local addressing	phk	plb	ldx	col80	split based on screen type	beq	lb1	pha		write using the text tools	jsl	SysCharOut	plb	rtslb1	jsr	~Write40	write to the 40 column screen	plb	rts	end******************************************************************  Clear - Clear the 40 column text screen**  Inputs:*	top - top line to clear*	A - value to store in screen space******************************************************************~Clear	private	using BasicCommon	phb		use local addressing	phk	plb	sta	screen	save the screen value	lda	top	get the initial index into lineDisp	asl	A	sta	indexlb1	ldx	index	branch if at end of screen	cpx	#48	bge	lb3	lda	lineDisp,X	get line address	inx		update index	inx	stx	index	tax		set initial line index	ldy	#20	we will store 20 words	lda	screen	get the value to storelb2	sta	>0,X	fill the line	inx	inx	dey	bne	lb2	bra	lb1	next linelb3	plb	rtsindex	ds	2	index into lineDispscreen	ds	2	screen value	end******************************************************************  ClearEOL - Clear to the end of the line******************************************************************ClearEOL start	lda	#29	jsr	~ChOut	rtl	end******************************************************************  ClearEOS - Clear to the end of the screen******************************************************************ClearEOS start	lda	#11	jsr	~ChOut	rtl	end******************************************************************  ClearStrobe - clear the keyboard strobe******************************************************************ClearStrobe start	short M	sta	>$C010	long	M	rtl	end******************************************************************  Click - click the speaker******************************************************************Click	start	short M	click the speaker	lda	>$C030	long	M	ldx	#175	simulate an integer BASIC delaylb1	dex	bne	lb1	rtl	end******************************************************************  CMP_EQ - compare two values for equality**  Inputs:*	stack - first operand*	A - second operand**  Outputs:*	A - result******************************************************************~CMP_EQ	start	cmp	4,S	beq	true	lda	#0	bra	lb1true	lda	#1lb1	phb	plx	ply	plb	plb	phy	phx	plb	rtl	end******************************************************************  CMP_GE - see if the first value is greater than or equal to the second**  Inputs:*	stack - first operand*	A - second operand**  Outputs:*	A - result******************************************************************~CMP_GE	start	ldx	#1	sec	sbc	4,S	beq	true	bvs	lb1	eor	#$8000lb1	bpl	true	dextrue	phb	pla	ply	plb	plb	phy	pha	plb	txa	rtl	end******************************************************************  CMP_GT - see if the first value is greater than the second**  Inputs:*	stack - first operand*	A - second operand**  Outputs:*	A - result******************************************************************~CMP_GT	start	ldx	#1	sec	sbc	4,S	beq	false	bvs	lb1	eor	#$8000lb1	bpl	truefalse	dextrue	phb	pla	ply	plb	plb	phy	pha	plb	txa	rtl	end******************************************************************  CMP_LE - see if the first value is less than or equal to the second**  Inputs:*	stack - first operand*	A - second operand**  Outputs:*	A - result******************************************************************~CMP_LE	start	ldx	#1	sec	sbc	4,S	beq	true	bvs	lb1	eor	#$8000lb1	bmi	true	dextrue	phb	pla	ply	plb	plb	phy	pha	plb	txa	rtl	end******************************************************************  CMP_LT - see if the first value is less than the second**  Inputs:*	stack - first operand*	A - second operand**  Outputs:*	A - result******************************************************************~CMP_LT	start	ldx	#1	sec	sbc	4,S	beq	false	bvs	lb1	eor	#$8000lb1	bmi	truefalse	dextrue	phb	pla	ply	plb	plb	phy	pha	plb	txa	rtl	end******************************************************************  CMP_NE - compare two values for inequality**  Inputs:*	stack - first operand*	A - second operand**  Outputs:*	A - result******************************************************************~CMP_NE	start	cmp	4,S	bne	true	lda	#0	bra	lb1true	lda	#1lb1	phb	plx	ply	plb	plb	phy	phx	plb	rtl	end******************************************************************  CMP_STR_EQ - compare two strings for equality**  Inputs:*	str1 - first string*	len1 - length of first string*	str2 - second string*	len2 - length of second string**  Outputs:*	A - 1 if the strings are equal, else 0******************************************************************~CMP_STR_EQ startresult	equ	0	resultch	equ	2	temp character	subroutine (4:str1,2:len1,4:str2,2:len2),4	stz	result	assume we will faillb1	lda	[str1]	check for a mismatch	and	#$00FF	sta	ch	lda	[str2]	and	#$00FF	cmp	ch	bne	lb4	tax		done if at end of the strings	beq	lb3	inc	str1	next characters	inc	str2	dec	len1	check for a forced end of string	beq	lb2	dec	len2	bne	lb1	lda	[str1]	handle a zero length check for str2	and	#$00FF	beq	lb3	bra	lb4lb2	dec	len2	handle a zero length check for str1	beq	lb3	lda	[str2]	and	#$00FF	bne	lb4lb3	inc	result	the strings are equallb4	anop		branch here if the strings are not equal	return 2:result	end******************************************************************  CMP_STR_NE - compare two strings for inequality**  Inputs:*	str1 - first string*	len1 - length of first string*	str2 - second string*	len2 - length of second string**  Outputs:*	A - 1 if the strings are not equal, else 0******************************************************************~CMP_STR_NE start	phb	phk	plb	pla	sta	S	pla	sta	S+2	jsl	~CMP_STR_EQ	ldx	S+2	phx	ldx	S	phx	plb	eor	#1	rtlS	ds	4	end******************************************************************  Color - set the pen color**  Inputs:*	A - color******************************************************************~Color	start	using BasicCommon	phb	phk	plb	and	#$000F	sta	color	ldx	col80	beq	lb1	pha	_SetSolidPenPatlb1	plb	rtl	end******************************************************************  CursorLeft - move the cursor left******************************************************************CursorLeft start	lda	#8	jsr	~ChOut	rtl	end******************************************************************  Divd - division**  Inputs:*	X - 1st operand*	A - 2nd operand**  Outputs:*	A - result******************************************************************~Divd	start	pha	pha	phx	pha	_SDivide	pla	plx	rtl	end******************************************************************  ~EndInput - dump anything remaining in the input line**  Outputs:*	cnt - set to 0******************************************************************~EndInput start	using BasicCommon	lda	#0	sta	>cnt	rtl	end******************************************************************  Exp - exponentiation**  Inputs:*	X - 1st operand*	A - 2nd operand**  Outputs:*	A - result******************************************************************~Exp	start	phb		use local addressing	phk	plb	stx	op	save the argument	sta	cnt	save the exponent	lda	#1	initialize the result	sta	val	lda	cnt	check for negative exponents	bpl	lb1	lda	op	cmp	#1	beq	lb3	stz	val	bra	lb3lb1	beq	lb3	allow for 0 exponentlb2	pha		do the operation	pha	lda	val	pha	lda	op	pha	_Multiply	pla	sta	val	pla	dec	cnt	bne	lb2lb3	lda	val	return the result	plb		restore the caller's bank	rtlval	ds	2	resultop	ds	2	argumentcnt	ds	2	exponent (also a loop counter)	end******************************************************************  GR - start the low-res graphics screen******************************************************************~GR	start	using BasicCommon	phb		use local addressing	phk	plb	short I,M	set screen to 40 column, mixed text	stz	col80	 and graphics	sta	>$C050	sta	>$C053	sta	>$C054	sta	>$C056	sta	>$C00C	long	I,M	stz	top	clear the screen	lda	#0	jsr	~Clear	lda	#20	set the top text line to 20	sta	top	sta	cv	home the cursor	stz	ch	lda	#$A0A0	clear the text part of the screen	jsr	~Clear	lda	#15	pen color starts as white	sta	color	lda	#$00FF	set the screen mask	sta	chMask	plb	rtl	end******************************************************************  GROff - turn off 40 column text/graphics******************************************************************~GROff	private	using BasicCommon	phb		use local addressing	phk	plb	lda	col80	skip if not in use	bne	lb1	short I,M	set screen to 80 column text	lda	#1	sta	col80	sta	>$C051	sta	>$C052	sta	>$C00D	long	I,M	ph2	#12	clear the 80 col screen	jsl	SysCharOutlb1	plb	rts	end******************************************************************  HGR - start the super high-res graphics screen******************************************************************~HGR	start	using BasicCommon	jsr	~GROff	turn off 40 col text/graphics	lda	QDHandle	skip if already started	ora	QDHandle+2	bne	lb1	pha		get memory for QD	pha	ph4	#256*3	ph2	userID	ph2	#$C015	ph4	#0	_NewHandle	pla	plx	sta	QDHandle	stx	QDHandle+2	sta	0	stx	2	lda	[0]	start quickdraw	pha	ph2	#0	ph2	#0	ph2	userID	_QDStartUplb1	rtl	end******************************************************************  HLin - draw a horizontal line**  Inputs:*	X - h1*	Y - h2*	A - v******************************************************************~HLin	start	using BasicCommon	phb		use local addressing	phk	plb	stx	h1	save the coordinates	sty	h2	sta	v	lda	col80	split based on screen type	beq	lb0	lda	v	call QuickDraw	phx	pha	phy	pha	_MoveTo	_LineTo	plb	rtllb0	cpy	h1	make sure h1 <= h2	bge	lb1	sty	h1	stx	h2lb1	ldx	h1	plot the linelb2	lda	v	jsl	~Plot	inc	h1	ldx	h1	cpx	h2	ble	lb2	plb		return	rtlh1	ds	2	first horizontal pointh2	ds	2	second horizontal pointv	ds	2	vertical location	end******************************************************************  Home - clear the screen and home the cursor******************************************************************Home	start	lda	#12	jsr	~ChOut	rtl	end******************************************************************  IntAbs - absolute value**  Inputs:*	A - number**  Outputs:*	A - result******************************************************************~IntAbs	start	tax	bpl	lb1	eor	#$FFFF	inc	Alb1	rtl	end******************************************************************  IntSgn - sgn function**  Inputs:*	A - number**  Outputs:*	A - result******************************************************************~IntSgn	start	tax	beq	lb1	bpl	lb2	lda	#-1	bra	lb1lb2	lda	#1lb1	rtl	end******************************************************************  Input - read a number**  Outputs:*	A - number read******************************************************************~Input	start	using BasicCommonTAB	equ	$09	tab key code	phb		use local bank addressing	phk	plblb1	lda	cnt	while cnt = 0 do	bne	lb2	jsr	~ReadLine	  read a line	lda	line+1	  cnt = length(line)	and	#$00FF	sta	cnt	lda	#2	  disp = 2	sta	disp	bra	lb1lb2	ldx	disp	skip whitespace and commas	lda	line,X	and	#$00FF	cmp	#' '	beq	lb3	cmp	#','	beq	lb3	cmp	#TAB	bne	lb4lb3	inc	disp	dec	cnt	bne	lb2	jsl	~Prompt	bra	lb1lb4	stz	neg	neg = false	cmp	#'-'	if char is '-' then	bne	lb4a	inc	neg	  neg = true	inc	disp	  next char	dec	cnt	bra	lb5lb4a	jsr	IsDigit	else if char is not a digit then	bcs	lb5	ph4	#error	  flag the error	ph2	#0	jsl	~PrintString	jsl	~Prompt	stz	cnt	  get a new line	bra	lb1lb5	stz	value	convert digits to a valuelb6	ldx	disp	lda	line,X	and	#$00FF	jsr	IsDigit	bcc	lb7	and	#$000F	pha	lda	value	ldx	#10	jsl	~Mult	clc	adc	1,S	plx	sta	value	inc	disp	dec	cnt	bne	lb6lb7	lda	neg	if neg then	beq	lb8	sub2	#0,value,value	  value = -valuelb8	lda	value	return the result	plb	rtl;;  IsDigit - see if a character is a digit;IsDigit	cmp	#'0'	blt	no	cmp	#'9'+1	bge	no	sec	rtsno	clc	rts;;  Local data;error	dc	c'Retype line.',i1'0'	error messageneg	ds	2	was the value negative?value	ds	2	value read from line	end******************************************************************  InputStr - read a string**  Outputs:*	address of string, len pushed on stack (for AssignString)******************************************************************~InputStr start	using BasicCommon	phb		use local bank addressing	phk	plblb1	lda	cnt	if cnt = 0 then	bne	lb2	jsr	~ReadLine	  read a line	lda	line+1	  cnt = length(line)	and	#$00FF	sta	cnt	lda	#2	  disp = 2	sta	displb2	lda	line+1	null terminate the line	and	#$00FF	tax	stz	line+2,X	plx		place string address on stack	ply	pea	line|-16	clc	lda	#line	adc	disp	pha	lda	cnt	place string len on stack	pha	stz	cnt	set cnt to 0 (indicating no string left)	phy	phx	plb	rtl	end******************************************************************  Inverse - write inverse characters******************************************************************Inverse	start	lda	#15	jsr	~ChOut	rtl	end******************************************************************  KeyBoard - read the keyboard**  Outputs:*	Stores the rsult in KEY, which should be defined in*	the Integer BASIC program.******************************************************************KeyBoard start	short M	lda	>$C000	long	M	and	#$00FF	sta	>Key	rtl	end******************************************************************  Logical - convert an integer to a 0 or 1**  Inputs:*	A - integer to convert**  Outputs:*	A - 0 if the input was 0, 1 otherwise******************************************************************~Logical start	tax	beq	lb1	lda	#1lb1	rtl	end******************************************************************  Mod - modulus**  Inputs:*	X - 1st operand*	A - 2nd operand**  Outputs:*	A - result******************************************************************~Mod	start	pha	pha	phx	pha	_SDivide	plx	pla	rtl	end******************************************************************  Mult - multiply**  Inputs:*	X - 1st operand*	A - 2nd operand**  Outputs:*	A - result******************************************************************~Mult	start	pha	pha	phx	pha	_Multiply	pla	plx	rtl	end******************************************************************  Normal - write normal characters******************************************************************Normal	start	lda	#14	jsr	~ChOut	rtl	end******************************************************************  PartialString - convert partial string indecies**  Converts a string address and two indecies into the address*  of the first indexed character and the number of chacters*  refered to.**  Inputs:*	addr - string address*	ind1 - 1st index*	ind2 - 2nd index**  Outputs:*	addr - string address*	ind1 - length of string elements******************************************************************~PartialString startaddr	equ	8	string addressind1	equ	6	1st indexind2	equ	4	2nd index	clc		update the address	lda	ind1,S	adc	addr,S	dec	A	sta	addr,S	sec		set the length	lda	ind2,S	sbc	ind1,S	inc	A	sta	ind1,S	lda	2,S	return to caller	sta	4,S	pla	sta	1,S	rtl	end******************************************************************  Pdl - read the mouse (replaces the old paddle)**  Inputs:*	A - read what:*		0 - horizontal position*		1 - vertical position*		2 - button up?*		otherwise - status/mode word (see ReadMouse)**  Outputs:*	Mouse position, button, or status******************************************************************~Pdl	start	pha		save the input	pha		read the mouse	pha	pha	_ReadMouse	lda	7,S	if input = 0 then	bne	lb1	pla		   return X	pla	pla	plx	rtllb1	dec	A	if input = 1 then	bne	lb2	pla		   return Y	pla	plx	plx	rtllb2	dec	A	if input = 2 then	bne	lb3	pla		   return mouse button state	rol	A	lda	#0	rol	A	plx	plx	plx	rtllb3	pla		return mouse status	plx	plx	plx	rtl	end******************************************************************  Plot - plot a point**  Inputs:*	X - x coordinate*	A - y coordinate******************************************************************~Plot	start	using BasicCommon	phb		use local addressing	phk	plb	ldy	col80	branch if using 40 column mode	beq	lb1	phx		draw a point using QuickDraw	pha	phx	pha	_MoveTo	_LineTo	plb	rtllb1	cpx	#40	skip if off screen	bge	lb3	cmp	#40	bge	lb3	lsr	A	convert to row + top/bottom flag	php		save top/bottom flag	asl	A	add column to row address	tay	txa	clc	adc	lineDisp,Y	tax	lda	color	get the color nibble and mask	ldy	#$F0	plp	short M	bcc	lb2	ldy	#$0F	asl	A	asl	A	asl	A	asl	Alb2	pha		paint the point	tya	and	>0,X	ora	1,S	sta	>0,X	pla	long	Mlb3	plb	rtl	end******************************************************************  PrintEOL - print an end of line******************************************************************~PrintEOL start	using BasicCommon	lda	#13	jsr	~ChOut	lda	#0	sta	>column	rtl	end******************************************************************  PrintInt - print an integer******************************************************************~PrintInt start	using BasicCommon	phb		use local addressing	phk	plb	pha		convert the int to a string	ph4	#str	ph2	#l:str	ph2	#1	_Int2Dec	ldx	#-1	skip leading spaceslb1	inx	lda	str,X	and	#$00FF	cmp	#' '	beq	lb1lb2	cpx	#l:str	print the characters	beq	lb3	lda	str,X	and	#$00FF	phx	jsr	~ChOut	plx	inx	inc	column	bra	lb2lb3	plb	rtlstr	ds	6	string work area	end******************************************************************  PrintTAB - print a tab******************************************************************~PrintTAB start	using BasicCommontabSize	equ	15	size of a tab field	phb		use local addressing	phk	plb	lda	column	while column > 0 dolb1	sec		  column -= tabSize	sbc	#tabSize	bpl	lb1	clc	sta	loop	save the loop counterlb2	lda	#' '	repeat	jsr	~ChOut	  print(' ')	inc	column	  ++column	inc	loop	  ++loop	bne	lb2	until loop=0	plb		restore the caller's bank	rtlloop	ds	2	loop counter	end******************************************************************  PrintString - print a string**  Parameters:*	addr - address of the string*	len - # chars to write; 0 for write to end of string******************************************************************~PrintString start	using BasicCommon	subroutine (4:addr,2:len),0	phb	phk	plblb1	lda	[addr]	while [addr]^ <> 0 do begin	and	#$00FF	beq	lb2	jsr	~ChOut	  write the char	inc	column	  ++column	inc4	addr	  advance to the next character	dec	len	  loop	bne	lb1lb2	plb	return	end******************************************************************  Prompt - print the input prompt******************************************************************~Prompt	start	lda	#'?'	jsr	~ChOut	rtl	end******************************************************************  QDOff - turn off quickdraw (if it is on)******************************************************************~QDOff	private	using BasicCommon	lda	QDHandle	skip if not started	ora	QDHandle+2	beq	lb1	_QDShutDown	shut down QD	stz	QDHandle	stz	QDHandle+2lb1	rts	end******************************************************************  ReadKey - read a key using the cursor**  Outputs:*	A - key read******************************************************************~ReadKey private	using BasicCommontime	equ	$5000	changes flash rate	lda	cv	find the character address	asl	A	tax	lda	lineDisp,X	adc	ch	sta	addr	tax		get the initial character	lda	>0,X	and	#$00FF	sta	initialCharlb1	lda	#time	set the timer	sta	timerlb2	short M	check for a keystroke	lda	>$C000	long	M	and	#$0080	bne	lb5	dec	timer	loop	bne	lb2	short M	invert the character	ldx	addr	lda	>0,X	cmp	#$20	bge	lb3	ora	#$40lb3	eor	#$80	cmp	#'@'	blt	lb4	cmp	#'_'+1	bge	lb4	and	#$3Flb4	sta	>0,X	long	M	bra	lb1	looplb5	short M	lda	initialChar	reset the screen character	ldx	addr	sta	>0,X	lda	>$C000	get the character	sta	>$C010	long	M	and	#$00FF	rtsaddr	ds	2	character address in bank 0initialChar ds 2	original screen charactertimer	ds	2	flash loop timer	end******************************************************************  ReadLine - read a line**  Outputs:*	line - line read**  Notes: Assumes local bank******************************************************************~ReadLine private	using BasicCommon	lda	col80	if 80 column display then	beq	lb1	gets	line,cr=t	  use ORCA/M's line input	rts		  return;;  40 Column input routine;lb1	short I,M	fill in the line with spaces	ldx	line	lda	#' 'lb2	sta	line+1,X	dex	bne	lb2	stz	line+1	long	I,Mlb3	jsr	~ReadKey	get a keypress	and	#$007F	cmp	#8	if key is <-- then	bne	lb4	lda	line+1	  if no characters typed then	and	#$00FF	beq	lb3	    loop	dec	line+1	  erase the character	jsl	CursorLeft	  back up on the screen	bra	lb3	  looplb4	short I	if max characters typed then	ldx	line+1	cpx	line	long	I	beq	lb3	  loop	cmp	#28	if key is --> then	bne	lb5	lda	line+1	  write the buffer character	and	#$00FF	tax	lda	line+2,X	and	#$00FF	jsr	~ChOut	inc	line+1	  next spot	bra	lb3	  looplb5	cmp	#13	if key is RETURN then	bne	lb6	jsr	~ChOut	  write to screen	lda	#10	jsr	~ChOut	rts		  we're donelb6	short I,M	place character in buffer	ldx	line+1	sta	line+2,X	inc	line+1	long	I,M	jsr	~ChOut	write char to screen	bra	lb3	loop	end******************************************************************  Rnd - return a random number**  Inputs:*	A - return a value below this one**  Outputs:*	A - random number******************************************************************~Rnd	start	phb		use local addressing	phk	plb	pha		save the limit	lda	seed	if no seed has been obtained, get one	ora	seed+2	bne	lb1	pha	pha	pha	pha	_ReadTimeHex	pl4	seed	pla	plalb1	sec		do the randomness thing, using the	tsc		 formula	sbc	#16	 seed = (seed*31415821+1) mod 100000000	tcs	ph4	seed	ph4	#31415821	_LongMul	clc	pla	adc	#1	sta	3,S	pla	adc	#0	sta	3,S	ph4	#100000000	_LongDivide	pla	pla	pl4	seed	lda	seed+2	get a random value	and	#$7FFF	make it positive	tax		restrict the range	pla	plb	jml	~Modseed	dc	i4'0'	end******************************************************************  Scrn - read a point**  Inputs:*	X - x coordinate*	A - Y coordinate******************************************************************~Scrn	start	using BasicCommon	phb		use local addressing	phk	plb	ldy	col80	branch if using 40 column mode	beq	lb1	pha		read a point using QuickDraw	phx	pha	_GetPixel	pla	plb	rtllb1	cpx	#40	skip if off screen	bge	lb4	cmp	#40	bge	lb4	lsr	A	convert to row + top/bottom flag	php		save top/bottom flag	asl	A	add column to row address	tay	txa	clc	adc	lineDisp,Y	tax	lda	#$000F	get the color mask	plp	php	bcc	lb2	lda	#$00F0lb2	and	>0,X	read the point	plp		if needed, shift the point	bcc	lb3	lsr	A	lsr	A	lsr	A	lsr	Alb3	and	#$000Flb4	plb	rtl	end******************************************************************  StringLength - find the length of a string**  Parameters:*	addr - address of the string*	len - max # of characters; 0 for the entire string******************************************************************~StringLength start	using BasicCommonval	equ	0	return value	subroutine (4:addr,2:len),2	stz	val	val = 0lb1	lda	[addr]	while [addr]^ <> 0 do begin	and	#$00FF	beq	lb2	inc	val	  ++val	inc4	addr	  advance to the next character	dec	len	  loop	bne	lb1lb2	return 2:val	return the string length	end******************************************************************  Tab - Move to an absolute column number**  Inputs:*	A - column to move to******************************************************************~Tab	start	using BasicCommon	phb		use local addressing	phk	plb	tax		quit if range exceeded	beq	lb3	cmp	screenSize	bge	lb3	sta	tabval	save the tab value	sta	column	lda	#13	start in column 1	jsr	~ChOutlb2	dec	tabval	move right tabval-1 columns	beq	lb3	lda	#28	jsr	~ChOut	bra	lb2lb3	plb		return	rtltabval	ds	2	tab value	end******************************************************************  Text - switch to 40 column text mode******************************************************************~Text	start	using BasicCommon	phb		use local addressing	phk	plb	short I,M	set screen to 40 column text	stz	col80	sta	>$C051	sta	>$C054	sta	>$C00C	long	I,M	stz	top	clear the screen	lda	#$A0A0	jsr	~Clear	stz	cv	home the cursor	stz	ch	stz	column	lda	#$00FF	set the screen mask	sta	chMask	lda	#41	set the screen size	sta	screenSize	plb	rtl	end******************************************************************  Text80 - switch to 80 column text mode******************************************************************~Text80	start	using BasicCommon	jsr	~QDOff	turn off quickdraw	jsr	~GROff	turn off 40 col text/graphics	lda	#81	set the screen size	sta	screenSize	rtl	end******************************************************************  VLin - draw a vertical line**  Inputs:*	X - v1*	Y - v2*	A - h******************************************************************~VLin	start	using BasicCommon	phb		use local addressing	phk	plb	stx	v1	save the coordinates	sty	v2	sta	h	lda	col80	split based on screen type	beq	lb0	lda	h	call QuickDraw	pha	phx	pha	phy	_MoveTo	_LineTo	plb	rtllb0	cpy	v1	make sure h1 <= h2	bge	lb1	sty	v1	stx	v2lb1	lda	v1	plot the linelb2	ldx	h	jsl	~Plot	inc	v1	lda	v1	cmp	v2	ble	lb2	plb		return	rtlv1	ds	2	first vertical pointv2	ds	2	second vertical pointh	ds	2	horizontal location	end******************************************************************  VTab - Move to an absolute line number**  Inputs:*	A - line to move to******************************************************************~VTab	start	using BasicCommon	phb		use local addressing	phk	plb	tax		quit if range exceeded	beq	lb3	cmp	#25	bge	lb3	ldx	col80	if 40 column screen then	bne	lb0	sta	cv	  move to the line	plb	rtllb0	sta	tabval	save the tab value	ph2	#21	don't scroll	jsl	SysCharOut	ph2	#$0017	jsl	SysCharOut	lda	#24	start on line 1	sta	looplb1	ph2	#31	jsl	SysCharOut	dec	loop	bne	lb1	ph2	#21	turn scrolling back on	jsl	SysCharOut	ph2	#$001F	jsl	SysCharOutlb2	dec	tabval	move down tabval-1 lines	beq	lb3	ph2	#10	jsl	SysCharOut	bra	lb2lb3	plb		return	rtltabval	ds	2	tab valueloop	ds	2	loop counter	end******************************************************************  Write40 - write a character to the 40 column screen**  Inputs:*	A - character to write******************************************************************~Write40 private	using BasicCommon;;  Check for special characters;	and	#$007F	cmp	#30	jge	wr1	cmp	#7	Bell	bne	sp1	_SysBeep	rtssp1	cmp	#10	linefeed	bne	sp2Newline	inc	cv	lda	cv	cmp	#24	blt	sp1a	lda	#23	sta	cv	jsr	Scrollsp1a	rtssp2	cmp	#11	clear to end of screen	bne	sp3	jsr	ClearEOL	ph2	top	lda	cv	inc	cv	cmp	#24	bge	sp2a	sta	top	lda	#$A0A0	jsr	~Clearsp2a	pl2	top	rtssp3	cmp	#12	home	bne	sp4	stz	ch	lda	top	sta	cv	lda	#$A0A0	jsr	~Clear	rtssp4	cmp	#13	move to column 0	bne	sp5Return	stz	ch	rtssp5	cmp	#14	normal	bne	sp6	lda	#$00FF	sta	chMask	rtssp6	cmp	#15	inverse	bne	sp7	lda	#$7F	sta	chMask	rtssp7	cmp	#8	move left	bne	sp8	dec	ch	bpl	sp7a	inc	chsp7a	rtssp8	cmp	#29	clear to end of line	bne	sp9ClearEOL ldy	ch	lda	cv	asl	A	tax	lda	lineDisp,X	adc	ch	tax	short M	lda	#$A0sp8a	cpy	#40	bge	sp8b	sta	>0,X	inx	iny	bra	sp8asp8b	long	M	rtssp9	cmp	#28	move forward	bne	wr1Forward	inc	ch	update ch	lda	ch	if ch = 40 then	cmp	#40	blt	sp9a	jsr	Return	  new line	jsr	Newlinesp9a	rts;;  Do a normal character write;wr1	pha		save the character	lda	cv	write to the 40 column screen	asl	A	get the character address	tax	lda	lineDisp,X	adc	ch	tax	pla		convert to screen character	short M	ora	#$80	and	chMask	cmp	#'@'	blt	wr2	cmp	#'_'+1	bge	wr2	and	#$3Fwr2	sta	>0,X	write the character	long	M	jsr	Forward	update ch	rts;;  Scroll subroutine;Scroll	lda	top	line = top	sta	linesc1	lda	line	while line < 23 do	cmp	#23	bge	sc3	asl	A	  get line disps	tax	lda	lineDisp+2,X	tay	lda	lineDisp,X	tax	lda	#20	  move one line of characters	sta	loop	phb	ph2	#0	plb	plbsc2	lda	|0,Y	sta	|0,X	inx	inx	iny	iny	lda	>loop	dec	A	sta	>loop	bne	sc2	plb	inc	line	  ++line	bra	sc1	endwhilesc3	ldx	lineDisp+23*2	clear the bottom line	lda	#$A0A0	ldy	#20sc4	sta	>0,X	inx	inx	dey	bne	sc4	rtsline	ds	2	line numberloop	ds	2	column loop counter	end