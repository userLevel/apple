{---------------------------------------------------------------}{                                                               }{  BASIC Common                                                 }{                                                               }{  This module contains global variables, constants, types,     }{  and subroutines used throughout the compiler.                }{                                                               }{  Copyright 1991                                               }{  By the Byte Works, Inc.                                      }{                                                               }{---------------------------------------------------------------}{                                                               }{  Global subroutines:                                          }{                                                               }{  InitCommon - Initialize the globals area                     }{                                                               }{---------------------------------------------------------------} unit BASIC_Common; interfaceuses Common;const   nameLength = 100;                    {max length of a variable name}   stringLength = 255;                  {max length of a string constant}   m_adc_imm    = $69;                  {machine code instructions}   m_adc_s      = $63;   m_and_imm    = $29;   m_and_s      = $23;   m_asl        = $0A;   m_beq        = $F0;   m_bge        = $B0;   m_bne        = $D0;   m_clc        = $18;   m_cop        = $02;   m_dec_a      = $3A;   m_eor_imm    = $49;   m_inc_a      = $1A;   m_lda_imm    = $A9;   m_ora_s      = $03;   m_jml        = $5C;   m_jmp        = $4C;   m_jsl        = $22;   m_jsr        = $20;   m_lda_abs    = $AD;   m_lda_absx   = $BD;   m_lda_indl   = $A7;   m_lda_dir    = $A5;   m_ldx_dir    = $A6;   m_sbc_dir    = $E5;   m_sta_abs    = $8D;   m_sta_absx   = $9D;   m_sta_dir    = $85;   m_sta_longx  = $9F;   m_sta_s      = $83;   m_pea        = $F4;   m_pha        = $48;   m_pla        = $68;   m_plx        = $FA;   m_ply        = $7A;   m_rep        = $C2;   m_rts        = $60;   m_sec        = $38;   m_sep        = $E2;   m_tax        = $AA;   d_bgn        = $0101;   d_end        = $0102;   d_lab        = $0103;   d_str        = $0104;   d_lnm        = $0105;   d_brk        = $0106;   d_ago        = $0107;   d_sub        = $0108;   d_exi        = $0109;   d_fil        = $010A;type   bytePtr = ^byte;                     {pointer to a single byte}   long = record                        {used to convert longint to integer}      case boolean of         true:  (l: longint);         false: (lsw,msw: integer);      end;                                        {tokens}                                        {------}   nameType = string[nameLength];       {symbol name}   namePtr = ^nameType;                 {symbol name pointer}   stringType = string[stringLength];   {string constant}   stringPtr = ^stringType;             {string constant pointer}   tokens = (eofsy, eolnsy,             {special symbols}                                        {constants and identifiers}             ident, intconst, stringconst,                                        {operators}             colon, comma, semicolon, lparen, rparen,             eq, lt, gt, le, ge,             ne, plus, minus, mult, divd,             exp,                                        {reserved words}             abssy, andsy, ascsy, atsy, callsy,             colorsy, dimsy, endsy, forsy, gosubsy,             gotosy, grsy, hgrsy, hlinsy, ifsy,             inputsy, lensy, letsy, modsy, nextsy,             notsy, orsy, pdlsy, plotsy, popsy,             printsy, remsy, returnsy, rndsy, scrnsy,             sgnsy, stepsy, tabsy, textsy, text80sy,             thensy, tosy, vlinsy, vtabsy);   tokenset = set of tokens;            {set of tokens}   tokenType = record                   {information about a token}      case kind: tokens of         ident:         (name: nameType);         intconst:      (ival: integer);         stringconst:   (str: stringType);         eofsy, eolnsy, colon, comma, semicolon,         lparen, rparen, eq, lt, gt,         le, ge, ne, plus, minus,         mult, divd, exp, abssy, andsy,         ascsy, atsy, callsy, colorsy, dimsy,         endsy, forsy, gosubsy, gotosy, grsy,         hgrsy, hlinsy, ifsy, inputsy, lensy,         letsy, modsy, nextsy, notsy, orsy,         pdlsy, plotsy, popsy, printsy, remsy,         returnsy, rndsy, scrnsy, sgnsy, stepsy,         tabsy, textsy, text80sy, thensy, tosy,         vlinsy, vtabsy: ();      end;                                        {symbols}                                        {-------}   expressionTypes = (int, str);        {types of expressions}   symbolPtr = ^symbolType;             {pointer to a symbol table entry}   symbolType = record                  {symbol table entry}      left,right: symbolPtr;              {tree links}      name: nameType;                     {symbol name}      kind: expressionTypes;              {type of the symbol}      size: integer;                      {array size (1 if not an array)}      newSymbol: boolean;                 {was this symbol just created?}      end;var                                        {command line flags}                                        {------------------}   debug: boolean;                      {generate debug code?}   edit: boolean;                       {eneter the editor on exit?}   keep: boolean;                       {keep the output file?}   listSource: boolean;                 {create a source listing?}   listSymbols: boolean;                {list symbols and code?}   memory: boolean;                     {compile to memory? (or disk)}   terminal: boolean;                   {treat all errors as terminal?}   wait: boolean;                       {pause after an error?}                                        {error tracking and reporting}                                        {----------------------------}   msg: pString;                        {terminal error message}   maxErrorLevel: integer;              {max error level}   numErrors: integer;                  {number of errors found}                                        {scanner}                                        {-------}   keepFile: stringType;                {output file name}   lineNumber: integer;                 {current line number}   token: tokenType;                    {current token}   sourceFile: stringType;              {input file name}   lineType: (step,breakpoint,autogo);  {debugger step type for the line}                                        {symbols}                                        {-------}   symbolTable: symbolPtr;              {symbols in the program}{---------------------------------------------------------------}procedure InitCommon;{ Initialize the globals area                                   }{---------------------------------------------------------------}implementationprocedure InitCommon;{ Initialize the globals area                                   }begin {InitCommon}symbolTable := nil;                     {no entries in the symbol table}end; {InitCommon}end.