{---------------------------------------------------------------}{                                                               }{  Code Generator                                               }{                                                               }{  The code generator creates the obj file, writing the         }{  approproate machine code instructions based on the           }{  intermediate code calls from the parser.                     }{                                                               }{  Copyright 1991                                               }{  By the Byte Works, Inc.                                      }{                                                               }{---------------------------------------------------------------}{                                                               }{  Global subroutines:                                          }{                                                               }{  Gen0 - Generate an implied operand instruction               }{  Gen0Name - Generate an instruction with a named label        }{  Gen0NameShift - Generate an instruction with a named label,  }{       shifted by 16 bits                                      }{  Gen0Label - Generate an instruction with a numbered label    }{  Gen0Relative - Generate an instruction with an offset to a   }{       numbered label                                          }{  Gen0String - Generate an instruction with a string constant  }{       operand                                                 }{  Gen1 - Generate a two byte constant operand instruction      }{  Gen1Byte - Generate a one byte constant operand instruction  }{  Gen1Name - Generate an instruction with a named label and    }{       offset                                                  }{  GetLabel - Allocale a new numbered label                     }{  GenDebugSymbols - Generate the debugger symbol table         }{  GenStrings - Generate string constants                       }{  GenSymbols - Generate space for variables in the symbol      }{       table                                                   }{                                                               }{---------------------------------------------------------------} unit CodeGen; interfaceuses Common, ORCAShell, MemoryMgr;{$libPrefix '0/obj/'}uses BASICCom, Scanner;{---------------------------------------------------------------}procedure Gen0 (op: integer);{ Generate an implied operand instruction                       }{                                                               }{ Parameters:                                                   }{    op - instruction to generate                               }procedure Gen0Name (op: integer; name: namePtr);{ Generate an instruction with a named label                    }{                                                               }{ Parameters:                                                   }{    op - instruction to generate                               }{    name - pointer to the named operand                        }procedure Gen0NameShift (op: integer; name: namePtr);{ Generate an instruction with a named label shifted by 16 bits }{                                                               }{ Parameters:                                                   }{    op - instruction to generate                               }{    name - pointer to the named operand                        }procedure Gen0Label (op,lab: integer);{ Generate an instruction with a numbered label                 }{                                                               }{ Parameters:                                                   }{    op - instruction to generate                               }{    label - label number                                       }procedure Gen0Relative (op,lab: integer);{ Generate an instruction with an offset to a numbered label    }{                                                               }{ Parameters:                                                   }{    op - instruction to generate                               }{    label - label number                                       }procedure Gen0String (op: integer; str: stringPtr);{ Generate an instruction with a string constant operand        }{                                                               }{ Parameters:                                                   }{    op - instruction to generate                               }{    str - pointer to the string constant                       }procedure Gen1 (op, opnd: integer);{ Generate a two byte constant operand instruction              }{                                                               }{ Parameters:                                                   }{    op - instruction to generate                               }{    opnd - operand                                             }{                                                               }{ Note:  This procedure is declared as extern in Scanner.Pas.   }{        If the name or parameter list changes, be sure and     }{        make a corresponding change there.                     }procedure Gen1Byte (op, opnd: integer);{ Generate a one byte constant operand instruction              }{                                                               }{ Parameters:                                                   }{    op - instruction to generate                               }{    opnd - operand                                             }procedure Gen1Name (op: integer; name: namePtr; opnd: integer);{ Generate an instruction with a named label and offset         }{                                                               }{ Parameters:                                                   }{    op - instruction to generate                               }{    name - pointer to the named operand                        }{    opnd - numeric offset                                      }function GetLabel: integer;{ Allocale a new numbered label                                 }procedure GenDebugSymbols;{ Generate the debugger symbol table                            }procedure GenStrings;{ Generate string constants                                     }procedure GenSymbols;{ Generate space for variables in the symbol table              }{- Private declarations ----------------------------------------}implementationconst                                        {object segment info}                                        {-------------------}   csize = $BF;                         {size of the constant buffer}   segmentSize = maxint;                {max size of a segment}                                        {labels}                                        {------}   labelSize = 1000;                    {max # of local labels}                                        {strings}                                        {-------}   ssize = 4000;                        {length of the constant string buffer}type                                        {object segment info}                                        {-------------------}   segmentType = array[0..segmentSize] of byte; {segment buffer type}   segmentPtr = ^segmentType;           {pointer to a segment buffer}                                        {labels}                                        {------}   labelRefPtr = ^labelRefRecord;       {ptr to a label reference}   labelRefRecord = record              {label reference}      next: labelRefPtr;                { next entry}      disp: 0..segmentSize;             { disp to label reference in segment}      end;   labelRecord = record                 {label entry}      defined: boolean;                 { is the label defined?}      disp: 0..segmentSize;             { disp to label location}      refs: labelRefPtr;                { unresolved label list}      end;var                                        {object segment info}                                        {-------------------}   clen: 0..csize;                      {index into the constant buffer}   cbuff: array[1..csize] of byte;      {constant buffer}   codeLength: 0..segmentSize;          {bytes of code in the loaded segment}   disp: 0..segmentSize;                {disp into the segment}   segment: segmentPtr;                 {pointer to the current segment}   segmentHandle: handle;               {segment handle}                                        {labels}                                        {------}   labels: array[1..labelSize] of labelRecord; {label table}   nextLabel: 0..labelSize;             {next label to allocate}                                        {strings}                                        {-------}   sbuff: packed array[1..ssize] of char; {string buffer}   slabel: 0..labelSize;                {string pool label}   slen: 0..ssize;                      {disp to next spot in sbuff}{- OMF Creation ------------------------------------------------}procedure Purge; forward;procedure Put1 (val: integer);{ Write one byte to the object segment                          }{                                                               }{ Parameters:                                                   }{    val - value to write                                       }{                                                               }{ Variables:                                                    }{    disp - disp in the object segment                          }{    segment - object segment pointer                           }begin {Put1}if clen <> 0 then                       {write any bytes in the constant buffer}   Purge;segment^[disp] := val;                  {put the byte in the segment buffer}if disp = segmentSize then begin        {update the segment size}   FlagError(28);   disp := 0;   end {if}else   disp := disp+1;end; {Put1}procedure Purge;{ write any bytes in the constant buffer                        }{                                                               }{ Variables:                                                    }{    clen - # of bytes in the constant buffer                   }{    cbuff - constant buffer                                    }var   len: integer;                        {local copy of clen}   i: integer;                          {loop variable}begin {Purge}if clen <> 0 then begin   len := clen;                         {save the length}   clen := 0;                           {zero the length (prevents re-call by Put1)}   Put1(len);                           {write the number of bytes}   for i := 1 to len do                 {write the bytes}      Put1(cbuff[i]);   end; {if}end; {Purge}procedure Put2 (val: integer);{ Write two bytes to the object segment                         }{                                                               }{ Parameters:                                                   }{    val - value to write                                       }begin {Put2}Put1(val & $00FF);Put1(val >> 8);end; {Put2}procedure Put4 (val: longint);{ Write four bytes to the object segment                        }{                                                               }{ Parameters:                                                   }{    val - value to write                                       }type   long = record      case boolean of         true:  (l: longint);         false: (b1,b2,b3,b4: byte);      end;begin {Put4}Put1(long(val).b1);Put1(long(val).b2);Put1(long(val).b3);Put1(long(val).b4);end; {Put4}procedure PutName (name: namePtr; disp, len, shift: integer);{ write an expression with a name to the object file            }{                                                               }{ Parameters:                                                   }{    name - pointer to the name                                 }{    disp - disp past the name                                  }{    len - length of the code created by the expression         }{    shift - # of bits to shift value                           }var   i: integer;                          {loop variable}begin {PutName}Put1($EB);                              {write the expression op-code}Put1(len);                              {write the # of bytes to generate}Put1($83);                              {write the name}Put1(length(name^));for i := 1 to length(name^) do   Put1(ord(name^[i]));if disp <> 0 then begin                 {write the displacement}   Put1($81);   Put4(disp);   Put1(1);   end; {if}if shift <> 0 then begin                {shift the value}   Put1($81);   Put4(shift);   Put1(7);   end; {if}Put1(0);                                {mark the end of the expression}end; {PutName}procedure CPut1 (val: integer);{ place one byte in the constant buffer                         }{                                                               }{ Parameters:                                                   }{    val - value to write                                       }{                                                               }{ Variables:                                                    }{    cbuff - constant buffer                                    }{    clen - # of bytes in the constant buffer                   }begin {CPut1}if clen = csize then                    {if the buffer is full, purge it}   Purge;clen := clen+1;                         {put the byte in the buffer}cbuff[clen] := val;end; {CPut1}procedure CPut2 (val: integer);{ place two bytes to the constant buffer                        }{                                                               }{ Parameters:                                                   }{    val - value to write                                       }begin {CPut2}CPut1(val & $00FF);CPut1(val >> 8);end; {CPut2}procedure StartSegment (name: namePtr);{ Start an object segment                                       }{                                                               }{ Parameters:                                                   }{    name - pointer to the nane of the segment                  }var   i: integer;                          {loop variable}begin {StartSegment}                                        {allocate the memory for the segment}segmentHandle := NewHandle(segmentSize, UserID, $C010, nil);segment := segmentPtr(segmentHandle^);disp := 0;                              {nothing in the segment}codeLength := 0;clen := 0;slen := 0;nextLabel := 0;                         {no labels allocated}slabel := GetLabel;                     {get a label for the string pool}Put4(0);                                {block count (not yet known)}Put4(0);                                {reserved space (0 bytes)}Put4(0);                                {segment code length (not yet known)}Put1(0);                                {segment kind (static code)}Put1(0);                                {label length (variable)}Put1(4);                                {length of numbers}Put1(1);                                {OMF version}Put4($010000);                          {bank size}Put4(0);                                {unused}Put4(0);                                {org}Put4(0);                                {alignment}Put1(0);                                {number "sex" (least sig. byte first)}Put1(0);                                {language card used (no)}Put2(0);                                {segment number}Put4(0);                                {entry (enter at first byte)}Put2(disp+4);                           {disp to names}Put2(disp+13+length(name^));            {disp to opcodes}Put4($20202020);                        {load segment name ('          ')}Put4($20202020);Put2($2020);Put1(length(name^));                    {code segment name}for i := 1 to length(name^) do   Put1(ord(name^[i]));end; {StartSegment}procedure EndSegment (filename: namePtr);var   tdisp: integer;                      {temp storage for disp}   procedure WriteFile;   { Write a file to disk                                       }   {                                                            }   { Variables:                                                 }   {    filename - file name                                    }   {    segment - pointer to the first char in the file         }   {    disp - length of the file                               }   const      OBJ = $B1;                        {OBJ file type}   var      ffRec: fastFileDCB;               {FastFile record}   begin {WriteFile}   with ffRec do begin                  {write the file to disk}      if memory then begin         action := 4;         flags := $0000;         end {if}      else begin         action := 3;         flags := $C000;         end; {else}      index := 0;      file_handle := segmentHandle;      file_length := disp;      name := pointer(filename);      access := $C3;      file_type := OBJ;      auxType := 0;      storage_type := 1;      create_date := 0;      create_time := 0;      mod_date := 0;      mod_time := 0;      blocks_used := 0;      end; {with}   FastFile(ffRec);   if ToolError <> 0 then      TermError(3);   if not memory then begin             {mark the file as purgeable}      ffRec.action := 7;      FastFile(ffRec);      end; {if}   end; {WriteFile}begin {EndSegment}Put1(0);                                {write the end opcode}if disp mod 512 <> 0 then               {even out the block}   disp := disp + (512 - disp mod 512);tdisp := disp;                          {save the segment length}disp := 0;                              {write the block count}Put4(tdisp >> 9);disp := 8;                              {segment code length}Put4(codeLength);disp := tdisp;                          {restore the segment length}if keep then                            {write the file to disk}   WriteFile;end; {EndSegment}{- Labels ------------------------------------------------------}function GetLabel{: integer};{ Allocale a new numbered label                                 }begin {GetLabel}if nextLabel = labelSize then           {find and fill in a label record}   FlagError(29)else begin   nextLabel := nextLabel+1;   with labels[nextLabel] do begin      defined := false;      refs := nil;      end; {with}   end; {else}GetLabel := nextLabel;                  {return the label number}end; {GetLabel}procedure MakeReference (pdisp,value: integer);{ place a label reference in the code file                      }{                                                               }{ Parameters:                                                   }{    pdisp - location of the reference in the OBJ file          }{    value - label value                                        }var   ldisp: integer;                      {local copy of disp}begin {MakeReference}Purge;                                  {write any constants}ldisp := disp;                          {save the actual OMF length}disp := pdisp;                          {go back to the reference location}Put4(value);                            {place the value in the OMF file}disp := ldisp;                          {restore the OMF length}end; {MakeReference}procedure DefineLabel (lab: integer);{ Define a label                                                }{                                                               }{ Parameters:                                                   }{    lab - label number to define                               }{                                                               }{ Variables:                                                    }{    codeLength - disp into the code segment                    }var   lptr: labelRefPtr;                   {work pointer}begin {DefineLabel}with labels[lab] do begin   disp := codeLength;                  {define the label}   defined := true;   while refs <> nil do begin           {resolve existing references}      lptr := refs;      refs := lptr^.next;      with lptr^ do         MakeReference(disp, codeLength);      dispose(lptr);      end; {while}   end; {with}end; {DefineLabel}procedure ReferenceLabel (lab, poffset: integer; prelative: boolean; psize: integer);{ Create a reference to a label                                 }{                                                               }{ Parameters:                                                   }{    lab - label number                                         }{    poffset - offset from the start of the label               }{    prelative - is the reference to a relative label?          }{    psize - size of the label field, in bytes                  }{                                                               }{ Variables:                                                    }{    disp - location of the label reference in the OBJ file     }var   i: integer;                          {loop variable}   ldisp: integer;                      {local copy of disp}   lptr: labelRefPtr;                   {work pointer}begin {ReferenceLabel}if prelative then begin   Put1($EE);                           {write the expression opcode}   Put1(psize);                         {write the expression size}   Put4(psize);                         {write the disp to the end of the exp}   end {if}else begin   Put1($EB);                           {write the expression opcode}   Put1(psize);                         {write the expression size}   end; {else}Put1($87);                              {save space & loc of label value}ldisp := disp;Put4(0);if poffset <> 0 then begin              {add in the offset}   Put1($81);   Put4(poffset);   Put1(1);   end; {if}Put1(0);                                {end of expression}with labels[lab] do                     {create the label reference}   if defined then      MakeReference(ldisp, disp)   else begin      new(lptr);      with lptr^ do begin         next := refs;         disp := ldisp;         end; {with}      refs := lptr;      end; {else}end; {ReferenceLabel}{- Code Generation Interface -----------------------------------}procedure ListOp (op: integer);{ List a label field and op code                                }begin {ListOp}if not (op in [d_lab,d_bgn]) then   write('         ');case op of   m_adc_imm    ,   m_adc_s      : write('adc');   m_and_imm    ,   m_and_s      : write('and');   m_asl        : write('asl    A');   m_beq        : write('beq');   m_bge        : write('bge');   m_bne        : write('bne');   m_clc        : write('clc');   m_cop        : write('cop');   m_dec_a      : write('dec    A');   m_eor_imm    : write('eor');   m_inc_a      : write('inc    A');   m_jml        : write('jml');   m_jmp        : write('jmp');   m_jsl        : write('jsl');   m_jsr        : write('jsr');   m_ldx_dir    : write('ldx');   m_lda_abs    ,   m_lda_absx   ,   m_lda_dir    ,   m_lda_imm    ,   m_lda_indl   : write('lda');   m_ora_s      : write('ora');   m_sta_abs    ,   m_sta_absx   ,   m_sta_dir    ,   m_sta_longx  ,   m_sta_s      : write('sta');   m_pea        : write('pea');   m_pha        : write('pha');   m_pla        : write('pla');   m_plx        : write('plx');   m_ply        : write('ply');   m_rep        : write('rep');   m_rts        : write('rts');   m_sbc_dir    : write('sbc');   m_sec        : write('sec');   m_sep        : write('sep');   m_tax        : write('tax');   d_bgn        : write(' START');   d_end        : write('END');   d_lab        : write(' ANOP');   d_str        : write('STR');   d_lnm        : write('LNM');   d_ago        : write('AGO');   d_brk        : write('BRK');   d_sub        : write('SUB');   d_exi        : write('EXI');   d_fil        : write('FIL');   end; {case}if op in [m_adc_imm, m_adc_s, m_and_imm, m_and_s, m_beq,          m_bge, m_bne, m_cop, m_eor_imm, m_jml,          m_jmp, m_jsl, m_jsr, m_lda_abs, m_lda_absx,          m_lda_imm, m_lda_indl, m_ldx_dir, m_ora_s, m_pea,          m_sep, m_sbc_dir, m_sta_abs, m_sta_absx, m_sta_dir,          m_sta_longx, m_sta_s, m_rep, d_str, d_lnm,          d_ago, d_brk, d_sub, d_exi, d_fil] then begin   write('   ');   if op in [m_adc_imm, m_and_imm, m_eor_imm, m_lda_imm] then      write('#')   else if op = m_sta_longx then      write('>')   else if op = m_lda_indl then      write('[');   end; {if}end; {ListOp}procedure Gen0 {op: integer};{ Generate an implied operand instruction                       }{                                                               }{ Parameters:                                                   }{    op - instruction to generate                               }var   name: nameType;                      {segment name}begin {Gen0}if listSymbols then begin               {list the instruction}   write(codelength:4, ' ');   ListOp(op);   writeln;   end; {if}if op = d_end then begin   name := concat(keepFile, '.root');   {end the segment}   EndSegment(@name);   end {if}else if op = d_exi then begin           {generate the end cop instruction}   CPut1(m_cop);   CPut1(4);   codeLength := codeLength+2;   end {else if}else begin   CPut1(op);                           {write the opcode}   codeLength := codeLength+1;          {update the length of the code}   end; {else}end; {Gen0}procedure Gen0Label {op,lab: integer};{ Generate an instruction with a numbered label                 }{                                                               }{ Parameters:                                                   }{    op - instruction to generate                               }{    label - label number                                       }begin {Gen0Label}if listSymbols then begin               {list the instruction}   if op = d_lab then begin      write(codelength:4, ' ');      write('L', lab:1);      if lab < 1000 then         write(' ');      if lab < 100 then         write(' ');      if lab < 10 then         write(' ');      write('   ');      ListOp(op);      writeln;      end {if}   else begin      write(codelength:4, ' ');      ListOp(op);      writeln('L', lab:1);      end; {else}   end; {if}if op = d_lab then   DefineLabel(lab)                     {define a new label}else begin   CPut1(op);                           {write the opcode}   ReferenceLabel(lab, 0, false, 2);    {reference a label}   codeLength := codeLength+3;          {update the length of the code}   end; {else}end; {Gen0Label}procedure Gen0Name {op: integer; name: namePtr};{ Generate an instruction with a named label                    }{                                                               }{ Parameters:                                                   }{    op - instruction to generate                               }{    name - pointer to the named operand                        }var   i: integer;                          {loop variable}   size: integer;                       {size of the operand}begin {Gen0Name}if listSymbols then begin               {list the instruction}   write(codelength:4, ' ');   if op in [d_bgn,d_lab] then begin      write(name^);      for i := length(name^) to 7 do         write(' ');      end; {if}   ListOp(op);   if not (op in [d_bgn,d_lab]) then      write(name^);   if op in [m_lda_absx, m_sta_absx] then      write(',X');   writeln;   end; {if}if op = d_bgn then   StartSegment(name)                   {start a segment}else if op = d_lab then begin   Put1($E6);                           {create a global label}   Put1(0);   Put1(ord('M'));   Put1(0);   Put1(length(name^));   for i := 1 to length(name^) do      Put1(ord(name^[i]));   end {else if}else begin   CPut1(op);                           {write the opcode}   size := 2;                           {write the name}   if op in [m_jml, m_jsl, m_sta_longx] then      size := 3;   PutName(name, 0, size, 0);   codeLength := codeLength+size+1;     {update the length of the code}   end; {else}end; {Gen0Name}procedure Gen0NameShift {op: integer; name: namePtr};{ Generate an instruction with a named label shifted by 16 bits }{                                                               }{ Parameters:                                                   }{    op - instruction to generate                               }{    name - pointer to the named operand                        }var   i: integer;                          {loop variable}   size: integer;                       {size of the operand}begin {Gen0NameShift}if listSymbols then begin               {list the instruction}   write(codelength:4, ' ');   ListOp(op);   writeln(name^, '|-16');   end; {if}CPut1(op);                              {write the opcode}PutName(name, 0, 2, -16);codeLength := codeLength+3;             {update the length of the code}end; {Gen0NameShift}procedure Gen0Relative {op,lab: integer};{ Generate an instruction with an offset to a numbered label    }{                                                               }{ Parameters:                                                   }{    op - instruction to generate                               }{    label - label number                                       }begin {Gen0Relative}if listSymbols then begin               {list the instruction}   write(codelength:4, ' ');   ListOp(op);   writeln('L', lab:1);   end; {if}CPut1(op);                              {write the opcode}ReferenceLabel(lab, 0, true, 1);        {reference a label}codeLength := codeLength+2;             {update the length of the code}end; {Gen0Relative}procedure Gen0String {op: integer; str: stringPtr};{ Generate an instruction with a string constant operand        }{                                                               }{ Parameters:                                                   }{    op - instruction to generate                               }{    str - pointer to the string constant                       }var   i: integer;                          {loop variable}   len: integer;                        {length of str^}begin {Gen0String}if listSymbols then begin               {list the instruction}   write(codelength:4, ' ');   ListOp(op);   writeln('"', str^, '"');   end; {if}if op in [d_sub, d_fil] then begin   CPut1(m_cop);                        {generate the cop instruction}   if op = d_sub then                   {generate the cop type byte}      CPut1(3)   else      CPut1(6);   ReferenceLabel(slabel, slen, false, 4); {generate the string addr}   codeLength := codeLength+6;          {update the code size}   len := length(str^);                 {get the length of the string}   if slen+len+1 > ssize then begin     {save the string}      FlagError(30);      slen := 0;      end; {if}   sbuff[slen+1] := chr(len);   for i := 1 to len do      sbuff[slen+i+1] := str^[i];   slen := slen+len+1;   end {if}else begin   CPut1(m_pea);                        {push the bank byte}   Put1($EB);   Put1(2);   Put1($87);   Put4(0);   Put1($81);   Put4(-16);   Put1(7);   Put1(0);   CPut1(m_pea);                        {push the string buffer address}   ReferenceLabel(slabel, slen, false, 2);   CPut1(m_pea);                        {push the string length}   CPut2(0);   codeLength := codeLength+9;          {update the code size}   len := length(str^);                 {get the length of the string}   if slen+len+1 > ssize then begin     {save the string}      FlagError(30);      slen := 0;      end; {if}   for i := 1 to len do      sbuff[slen+i] := str^[i];   sbuff[slen+len+1] := chr(0);   slen := slen+len+1;   end; {else}end; {Gen0String}procedure Gen1 {op, opnd: integer};{ Generate a two byte constant operand instruction              }{                                                               }{ Parameters:                                                   }{    op - instruction to generate                               }{    opnd - operand                                             }{                                                               }{ Note:  This procedure is declared as extern in Scanner.Pas.   }{        If the name or parameter list changes, be sure and     }{        make a corresponding change there.                     }begin {Gen1}if listSymbols then begin               {list the instruction}   write(codelength:4, ' ');   ListOp(op);   write(opnd:1);   if op = m_sta_longx then      write(',X');   writeln;   end; {if}if op in [d_lnm, d_ago, d_brk] then begin   CPut1(m_cop);                        {write the opcode}   CPut1(ord(op)-ord(d_lnm));           {write the cop code}   CPut2(opnd);                         {write the operand}   codeLength := codeLength+4;          {update the length of the code}   end {if}else begin   CPut1(op);                           {write the opcode}   CPut2(opnd);                         {write the operand}   codeLength := codeLength+3;          {update the length of the code}   end; {else}end; {Gen1}procedure Gen1Byte {op, opnd: integer};{ Generate a one byte constant operand instruction              }{                                                               }{ Parameters:                                                   }{    op - instruction to generate                               }{    opnd - operand                                             }begin {Gen1Byte}if listSymbols then begin               {list the instruction}   write(codelength:4, ' ');   ListOp(op);   write(opnd:1);   if op in [m_adc_s, m_and_s, m_ora_s, m_sta_s] then      write(',S')   else if op = m_lda_indl then      write(']');   writeln;   end; {if}CPut1(op);                              {write the opcode}CPut1(opnd);                            {write the operand}codeLength := codeLength+2;             {update the length of the code}end; {Gen1Byte}procedure Gen1Name {op: integer; name: namePtr; opnd: integer};{ Generate an instruction with a named label and offset         }{                                                               }{ Parameters:                                                   }{    op - instruction to generate                               }{    name - pointer to the named operand                        }{    opn1 - numeric offset                                      }begin {Gen1Name}if listSymbols then begin               {list the instruction}   write(codelength:4, ' ');   ListOp(op);   writeln(name^, '+', opnd:1);   end; {if}CPut1(op);                              {write the opcode}PutName(name, opnd, 2, 0);              {write the name}codeLength := codeLength+3;             {update the length of the code}end; {Gen1Name}procedure GenDebugSymbols;{ Generate the debugger symbol table                            }var   size: integer;                       {size of the symbol table}   function TableSize (sym: symbolPtr): integer;   { Find the size of the symbol table                          }   {                                                            }   { Parameters:                                                }   {    sym - pointer to the top symbol                         }   {                                                            }   { Returns the size of the debugger symbol table in bytes     }   var      i: integer;                       {loop variable}      size: integer;                    {# of bytes to generate}   begin {TableSize}   if sym <> nil then begin      size := TableSize(sym^.left);     {do the left part of the tree}      if sym^.kind = int then begin     {add in the size of this entry}         if sym^.size = 0 then            size := size+12         else            size := size+24;         end {if}      else         size := size+12;      size := size + TableSize(sym^.right); {do the right part of the tree}      end {if}   else      size := 0;   TableSize := size;                   {return the size}   end; {TableSize}   procedure GenSymbol (sym: symbolPtr);   { Generate the code for one symbol                           }   {                                                            }   { Parameters:                                                }   {    sym - pointer to the symbol to generate                 }   var      i: integer;                       {loop variable}      len: integer;                     {length of the variable}   begin {GenSymbol}   if sym <> nil then begin      GenSymbol(sym^.left);             {do the left part of the tree}      if listSymbols then begin         {handle text output}         writeln(codeLength:4, '          dc    a4''L', slabel:1, '+', slen:1, '''');         writeln(codeLength+4:4, '          dc    a4''', sym^.name, '''');         writeln(codeLength+8:4, '          dc    i1''1''');         end; {if}      ReferenceLabel(slabel, slen, false, 4); {generate the string addr}      len := length(sym^.name);         {get the length of the string}      if slen+len+1 > ssize then begin  {save the string}         FlagError(30);         slen := 0;         end; {if}      sbuff[slen+1] := chr(len);      for i := 1 to len do         sbuff[slen+i+1] := sym^.name[i];      slen := slen+len+1;      PutName(@sym^.name, 0, 4, 0);     {generate the name}      CPut1(1);                         {absolute address flag}      if sym^.kind = int then begin         CPut1(1);                      {int variable}         if listSymbols then            writeln(codeLength+9:4, '          dc    i1''1''');         if sym^.size = 0 then begin            CPut2(0);                   {not an array}            if listSymbols then               writeln(codeLength+10:4, '          dc    i''0''');            end {if}         else begin            CPut2(1);                   {singly subscripted array}            CPut2(0);                   {min subscript value}            CPut2(0);            CPut2(sym^.size+1);         {max subscript value}            CPut2(0);            CPut2(2);                   {elements are 2 bytes long}            CPut2(0);            if listSymbols then begin               writeln(codeLength+10:4, '          dc    i''1''');               writeln(codeLength+12:4, '          dc    i4''0''');               writeln(codeLength+16:4, '          dc    i4''', sym^.size+1:1, '''');               writeln(codeLength+20:4, '          dc    i4''2''');               end; {if}            codeLength := codeLength+12;            end; {else}         end {if}      else begin         CPut1(6);                      {string variable}         CPut2(0);                      {not an array}         if listSymbols then begin            writeln(codeLength+9:4, '          dc    i1''6''');            writeln(codeLength+10:4, '          dc    i''0''');            end; {if}         end; {else}      codeLength := codeLength+12;      {update the code size}      GenSymbol(sym^.right);            {do the right part of the tree}      end; {if}   end; {GenSymbol}begin {GenDebugSymbols}if symbolTable <> nil then begin   Gen1Byte(m_cop, 5);                  {write the opcode}   size := TableSize(symbolTable);      {find the size of the table}   CPut2(size);   if listSymbols then      writeln(codeLength:4, '          dc    i''', size:1, '''');   codeLength := codeLength+2;   GenSymbol(symbolTable);              {generate the symbols}   end; {if}Gen0(m_rts);                            {return to caller}end; {GenDebugSymbols}procedure GenStrings;{ Generate string constants                                     }var   clen: integer;                       {code length}   i: 1..ssize;                         {loop variable}   lastType: (none, ch, int);           {type of last variable}begin {GenStrings}Gen0Label(d_lab, slabel);               {create the string label}if listSymbols and (slen <> 0) then     {list the instruction}   begin   clen := codeLength;   for i := 1 to slen do begin      if ((i-1) mod 32) = 0 then begin         if i <> 1 then begin            writeln('''');            clen := clen+32;            end; {if}         write(clen:4, '          dc    ');         lastType := none;         end; {if}      if sbuff[i] >= ' ' then begin         if lastType <> ch then begin            if lastType = int then               write(''',');            write('c''');            lastType := ch;            end; {if}         write(sbuff[i]);         end {if}      else begin         if lastType = int then            write(',')         else begin            if lastType = ch then               write(''',');            write('i1''');            lastType := int;            end; {if}         write(ord(sbuff[i]):1);         end; {else}      end; {for}   writeln('''');   end; {if}for i := 1 to slen do                   {write the string bytes}   CPut1(ord(sbuff[i]));codeLength := codeLength+slen;          {update the code size}end; {GenStrings}procedure GenSymbols;{ Generate space for variables in the symbol table              }var   name: nameType;                      {segment name}   procedure GenSymbol (sym: symbolPtr);   { Generate the code for one symbol                           }   {                                                            }   { Parameters:                                                }   {    sym - pointer to the symbol to generate                 }   var      i: integer;                       {loop variable}      size: integer;                    {# of bytes to generate}   begin {GenSymbol}   if sym <> nil then begin      GenSymbol(sym^.left);             {do the left part of the tree}      if sym^.kind = int then           {find the size of the symbol}         size := 2*sym^.size + 2      else begin         size := sym^.size+1;         if size = 1 then               {(strings default to 10 characters)}            size := 11;         end; {else}      Put1($E6);                        {create the label}      Put1(length(sym^.name));      for i := 1 to length(sym^.name) do         Put1(ord(sym^.name[i]));      Put1(0);      Put1(ord('N'));      Put1(0);      Put1($F1);                        {reserve the space}      Put4(size);      codeLength := codeLength+size;    {update the code size}      if listSymbols then               {write the text version}         writeln(sym^.name, ' ':9-length(sym^.name), 'ds    ', size:1);      GenSymbol(sym^.right);            {do the right part of the tree}      end; {if}   end; {GenSymbol}begin {GenSymbols}if symbolTable <> nil then begin   StartSegment(@'VARIABLES');          {start a segment}   if listSymbols then begin      writeln;      writeln('VARIABLES start');      end; {if}   GenSymbol(symbolTable);              {generate the symbols}   name := concat(keepFile, '.a');      {end the segment}   EndSegment(@name);   if listSymbols then      writeln('         end');   end; {if}end; {GenSymbols}end.