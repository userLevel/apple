         KEEP  CHECK         MCOPY CK.MACROS******************************************************************  CHECK 1.0*  28 March 1987**  Takes input from standard in or, if provided, a file.  The*  input file is echoed to standard out, with all lowercase*  characters converted to uppercase.**  CHECK [-V] volume**        -S    Set return codes only.*        -V    Print version number and copyright.**  By Phil Montoya and Mike Westerfield**  Copyright 1987*  By the Byte Works, Inc.*  All rights reserved******************************************************************CHECK    START         JSR   SINIT         JSR   SMAIN         JSR   SFINI         LDA   #0         RTL         DC    C'CHECK 1.0'         DC    C'Copyright 1987, Byte Works, Inc.'         END******************************************************************  COMMON - Common Data Areas******************************************************************COMMON   DATA;;  Constants;RETURN   EQU   $D                       RETURN key codeLINEFEED EQU   $A                       line feed key codeFALSE    EQU   0                        boolean constantsTRUE     EQU   1;;  Zero Page Equates;R0       GEQU  $0                       general purpose registersR1       GEQU  $1R2       GEQU  $2R3       GEQU  $3R4       GEQU  $4R5       GEQU  $5R6       GEQU  $6R7       GEQU  $7R8       GEQU  $8R9       GEQU  $9R10      GEQU  $AR11      GEQU  $BR12      GEQU  $CR13      GEQU  $DR14      GEQU  $ER15      GEQU  $FINLINE   GEQU  $10                      pointer to input lineCLDISP   GEQU  $14                      disp in INLINESTANDARDIN GEQU $16                     standard in?FILEPTR  GEQU  $18                      pointer to next characterLOCKP    GEQU  $1C                      work area for LOCK;;  Flagged variables;COPYRIGHT GEQU $40                      display copyright?QUIET    GEQU  $42                      run in quiet mode?;;  DCBs;QT_DCB   ANOP                           quit DCB         DC    A4'QT_FLAGS'QT_FLAGS DC    I'0'ER_DCB   ANOP                           system error DCBER_NUM   DS    2;;  Global Variables;DEVICE   DS    65                       name of the disk to checkTOKEN    DSTR  ,255                     command line tokenUSER_ID  DS    2                        User ID         END******************************************************************  SFINI - Program Termination******************************************************************SFINI    START         USING COMMON         LONGA ON         LONGI ON         CLOSE CL_DCB                   close all open files         DISPOSEALL USER_ID             dispose of all memory         RTSCL_DCB   ANOP         DC    I'0'         END******************************************************************  SFLAG - Read a flag from the command line**  Inputs:*        TOKEN - token to check to see if its a flag**  Outputs:*        A - flag character; MSB set for +, clear for -*        C - set if flag found, else clear******************************************************************SFLAG    START         USING COMMON         LONGA ON         LONGI ON         SHORT I,M         LDA   TOKEN+1         CMP   #2         BNE   NOT         LDA   #0         LDX   TOKEN+2         CPX   #'-'         BEQ   MINUS         CPX   #'+'         BEQ   PLUSNOT      CLC         LONG  I,M         RTS         LONGI OFF         LONGA OFFPLUS     LDA   #$80MINUS    ORA   TOKEN+3         LONG  I,M         AND   #$00FF         PHA         JSR   STOKN         PLA         CMP   #'a'         BLT   LB1         CMP   #'z'+1         BLT   LB0         CMP   #'a'+$80         BLT   LB1         CMP   #'z'+$80+1         BGE   LB1LB0      AND   #$00DFLB1      SEC         RTS         END******************************************************************  SINIT - Program Initialization******************************************************************SINIT    START         USING COMMON         LONGA ON         LONGI ON;;  Save O/S supplied values;         PHK                            set data bank         PLB         ORA   #$0100                   save user ID         STA   USER_ID         STX   INLINE+2                 save addr of input line         STY   INLINE;;  Initialize global variables;         STZ   COPYRIGHT                COPYRIGHT = FALSE         STZ   QUIET                    write output to screen;;  Read flags.;         LDA   #8                       skip shell identifier         STA   CLDISP         JSR   STOKN                    read the command name         JSR   STOKN                    skip if there is no token on the lineLB1      LDA   TOKEN+1         AND   #$00FF         BEQ   VL1         JSR   SFLAG         BCC   VL1         CMP   #'V'                     if -V then         BNE   LB2         LDA   #TRUE                      COPYRIGHT = TRUE         STA   COPYRIGHT         BRA   LB1LB2      CMP   #'S'                     else if -S then         BNE   BADFLAG         LDA   #TRUE                      QUIET = TRUE         STA   QUIET         BRA   LB1BADFLAG  PUTS  #'Illegal flag',CR=T,ERROUT=T         JSR   SFINIQUIT     LDA   #$FFFF         QUIT  QT_DCB;;  Get the name of the volume to check.;VL1      LDA   TOKEN+1                  if there is no token then         AND   #$00FF         BNE   VL2         PUTS  #'Volume to check: '       prompt for one         GETS  TOKEN         LDA   TOKEN+1                    if there is still no token then         AND   #$00FF         BEQ   NOTFOUND                     abort!                                         endifVL2      ANOP                           endif         MOVE  TOKEN+1,DEVICE,#L:DEVICE save the device name         JSR   STOKN                    get next token         LDA   TOKEN+1                  flag error if tere are more parms         AND   #$00FF         BNE   BADPARM         RTSBADPARM  PUTS  #'Too many parameters on command line',CR=T,ERROUT=T         JSR   SFININOTFOUND LDA   #$FFFF         QUIT  QT_DCB         RTS         END******************************************************************  SMAIN - Top level control******************************************************************SMAIN    START         USING COMMON         LONGA ON         LONGI ON         STZ   ST_STOP                  don't stop yet         LDA   COPYRIGHT                if V flag then write copyright         BEQ   LB1         PUTS  #'Check Disk 1.0',CR=T         PUTS  #'Copyright 1987, Byte Works, Inc.',CR=T         PUTCRLB1      GET_DEV_NUM DN_DCB             get the device number         JCS   ERR         LDA   DN_NUM                   set device number         STA   RB_NUM         STZ   TOTERR                   set number of errors to 0         STZ   TOTERR+2         LLA   RB_BLOCK,2               read the root block         READ_BLOCK RB_DCB         JCS   ERR                      branch if there was an error         MOVE  BLOCK+$29,NUM_BLOCKS     print the number of blocks         STZ   NUM_BLOCKS+2         LDA   QUIET         BNE   LB1A         PUTS  #'There are '         PUT4  NUM_BLOCKS         PUTS  #' blocks on the disk.',CR=T         PUTCRLB1A     STZ   RB_BLOCK                 start reading at block 0LB2      STOP  ST_DCB                   check for user-stop         LDA   ST_STOP                  exit if a stop has been flagged         JNE   ERTS         READ_BLOCK RB_DCB              read a block         BCC   LB3                      if there was an error then         STA   ER_NUM         LDA   QUIET         BNE   LB2A         PUTS  #'Error reading block ',ERROUT=T         PUT4  RB_BLOCK,ERROUT=T         PUTS  #': ',ERROUT=T         ERROR ER_DCBLB2A     INC4  TOTERRLB3      INC4  RB_BLOCK                 inc # blocks read         DEC4  NUM_BLOCKS         LDA   NUM_BLOCKS         ORA   NUM_BLOCKS+2         JNE   LB2         LDA   TOTERR                   if there were some errors then         ORA   TOTERR+2         BEQ   LB4         LDA   QUIET         JNE   BRTS         PUTS  #'There are ',ERROUT=T     tell how many         PUT4  TOTERR,ERROUT=T         PUTS  #' bad blocks.',CR=T,ERROUT=T         BRA   BRTS                     elseLB4      LDA   QUIET         BNE   LB5         PUTS  #'All blocks can be read.',CR=T tell the user all's OKLB5      RTS                            endifERR      LDA   QUIET         BNE   ERTS         PUTS  #'Could not read ',ERROUT=T         PUTS  DEVICE-1,CR=T,ERROUT=TERTS     LDA   #$FFFF         QUIT  QT_DCBBRTS     LDA   #1         QUIT  QT_DCB;;  Local data;DN_DCB   ANOP                           GET_DEV_NUM DCB         DC    A4'DEVICE'DN_NUM   DS    2RB_DCB   ANOP                           READ_BLOCK DCBRB_NUM   DS    2         DC    A4'BLOCK'RB_BLOCK DS    4ER_DCB   ANOP                           ERROR DCBER_NUM   DS    2NUM_BLOCKS DS  4                        number of blocks on the diskTOTERR   DS    4                        number of errors foundBLOCK    DS    512                      space to read block intoST_DCB   ANOP                           STOP DCBST_STOP  DS    2         END******************************************************************  STOKN - Read a token from the command line**  Outputs:*        TOKEN - token read******************************************************************STOKN    START         USING COMMON         LONGA ON         LONGI ON         STZ   TOKEN+1                  set token to null         LDA   INLINE                   quit if no command line         ORA   INLINE+2         BEQ   LB5         SHORT I,M         LDY   CLDISP                   skip leading blanksLB1      LDA   [INLINE],Y         CMP   #' '         BNE   LB2         INY         BRA   LB1LB2      LDX   #0                       read the tokenLB3      LDA   [INLINE],Y         BEQ   LB4         CMP   #' '         BEQ   LB4         STA   TOKEN+2,X         INY         INX         BPL   LB3LB4      STX   TOKEN+1                  set the string length         STY   CLDISP                   save the new disp         LONG  I,MLB5      RTS         END