         KEEP  TCMP         MCOPY TC.MACROS******************************************************************  TCMP 1.0*  25 February 1987**  Two ASCII files are read into memory and compared.  If a*  difference is found, the differing lines are printed.**  TCMP [-B] [-F] [-I] [-N] [-S n] [-V] [-W] file1 file2**       -B     Ignore leading blanks.*       -F     Fold uppercase into lowercase.*       -I     Ignore non-printing characters.*       -N     Print line numbers of mis matches.*       -S n   Resyncronize after n lines match.*       -V     Print version number and copyright.*       -W     Runs of white space compare equal.**  By Mike Westerfield**  Copyright 1987*  By the Byte Works, Inc.*  All rights reserved******************************************************************TCMP     START         JSR   SINIT         JSR   SMAIN         PHA         JSR   SFINI         PLA         RTL         DC    C'TCMP 1.0'         DC    C'Copyright 1987, Byte Works, Inc.'         END******************************************************************  COMMON - Common Data Areas******************************************************************COMMON   DATA;;  Constants;RETURN   EQU   $D                       RETURN key codeLINEFEED EQU   $A                       line feed key codeFALSE    EQU   0                        boolean constantsTRUE     EQU   1;;  Zero Page Equates;R0       GEQU  $0                       general purpose registersR1       GEQU  $1R2       GEQU  $2R3       GEQU  $3R4       GEQU  $4R5       GEQU  $5R6       GEQU  $6R7       GEQU  $7R8       GEQU  $8R9       GEQU  $9R10      GEQU  $AR11      GEQU  $BR12      GEQU  $CR13      GEQU  $DR14      GEQU  $ER15      GEQU  $FINLINE   GEQU  $10                      pointer to input lineCLDISP   GEQU  $14                      disp in INLINEFILEPTR  GEQU  $18                      pointer to start of file being loadedLOCKP    GEQU  $1C                      work area for LOCKFILE1    GEQU  $20                      pointer to start of file 1FLEN1    GEQU  $24                      length of file 1FILE2    GEQU  $28                      pointer to start of file 2FLEN2    GEQU  $2C                      length of file 2LEFT     GEQU  $30                      disp in file 1RIGHT    GEQU  $34                      disp in file 2;;  Flagged variables;COPYRIGHT GEQU $40                      display copyright?FLAGB    GEQU  $42                      -B; ignore leading spacesFLAGF    GEQU  $44                      -F; fold uppercase to lowerFLAGI    GEQU  $46                      -I; ignore chars outside $20..$7EFLAGW    GEQU  $48                      -W; runs of whitespace compare equalFLAGN    GEQU  $4A                      -N; print line numbersANYFLAG  GEQU  $4C                      have any of -B, -F, -I, -W been set?SYNC     GEQU  $4E                      number of lines to resync afterDIFF     GEQU  $50                      are files different?;;  DCBs;QT_DCB   ANOP                           quit DCB         DC    A4'QT_FLAGS'QT_FLAGS DC    I'0'ST_DCB   ANOP                           stop DCBST_STOP  DS    2ER_DCB   ANOP                           system error DCBER_NUM   DS    2;;  Global Variables;LINE     DSTR  ,255                     input line         DS    1LN       DS    4                        line number for printingLN1      DS    4                        line number for file 1LN2      DS    4                        line number for file 2TOKEN    DSTR  ,255                     command line tokenUSER_ID  DS    2                        User ID         END******************************************************************  SCOMP - Compare two lines**  Inputs:*        R8 - pointer to first line*        R12 - pointer to second line*        various flag settings**  Outputs:*        status flags set as if a numeric compare were done******************************************************************SCOMP    START         USING COMMON         LONGA ON         LONGI ON;;  If any line modifying flags are set, copy the lines to local buffers;         LDA   ANYFLAG                  skip if no flags were set         JEQ   LB0         SHORT I,M                      copy the first line to LINE1         LDY   #0AF1      LDA   [R8],Y         STA   LINE1,Y         CMP   #RETURN         BEQ   AF2         INY         BNE   AF1         LDA   #RETURN         STA   LINE1+255AF2      LDY   #0                       copy the second line to LINE2AF3      LDA   [R12],Y         STA   LINE2,Y         CMP   #RETURN         BEQ   AF4         INY         BNE   AF3         LDA   #RETURN         STA   LINE1+255AF4      LONG  I,M         LLA   R8,LINE1                 set the new line addresses         LLA   R12,LINE2;;  If -F, fold uppercase to lowercase;         LDA   FLAGF         BEQ   FF1         LDY   #LINE1         JSR   SFLGF         LDY   #LINE2         JSR   SFLGFFF1      ANOP;;  If -I, ignore characters outside $20..$7E;         LDA   FLAGI         BEQ   FI1         LDY   #LINE1         JSR   SFLGI         LDY   #LINE2         JSR   SFLGIFI1      ANOP;;  If -W, runs of whitespace compare equal;         LDA   FLAGW         BEQ   FW1         LDY   #LINE1         JSR   SFLGW         LDY   #LINE2         JSR   SFLGWFW1      ANOP;;  If -B ignore leading white space;         LDA   FLAGB         BEQ   FB1         LDY   #LINE1         JSR   SFLGB         LDY   #LINE2         JSR   SFLGBFB1      ANOP;;  Compare the two lines;LB0      SHORT M         LDY   #0LB1      LDA   [R12],Y         CMP   #RETURN         BEQ   LB2         LDA   [R8],Y         CMP   #RETURN         BEQ   LB3         CMP   [R12],Y         BNE   RTS         INY         BRA   LB1LB2      CMP   [R8],Y         BEQ   RTS         CMP   #RETURN-1         BRA   RTSLB3      CMP   #RETURN+1RTS      LONG  M         RTSLINE1    DS    256                      local line buffersLINE2    DS    256         END******************************************************************  SDIFF - Write differing lines**  Inputs:*        LEFT - # differing lines in file1*        RIGHT - # differing lines in file2*        FILE1 - points to lines in file1*        FILE2 - points to lines in file2******************************************************************SDIFF    START         USING COMMON         LONGI ON         LONGA ON         PUTCR                          write header         PUTS  #'---- Files differ:',CR=T         PUTCR                          write file 1 header         PUTS  #'-- File 1:',CR=T         PUTCR         MOVE4 FILE1,R0                 R0 = file1;         MOVE4 LEFT,R4                  R4 = left;         MOVE4 LN1,LN                   LN = LN1;         JSR   SLIST                    <list lines>;         PUTCR         LDA   ST_STOP         BNE   RTS                      write file 2 header         PUTS  #'-- File 2:',CR=T         PUTCR         MOVE4 FILE2,R0                 R0 = file2;         MOVE4 RIGHT,R4                 R4 = right;         MOVE4 LN2,LN                   LN = LN2;         JSR   SLIST                    <list lines>;         PUTCRRTS      RTS         END******************************************************************  SFILE - Read a file**  Inputs:*        A - disp in DP of file record - consists of:*              4 byte pointer to start of file*              4 byte file length*        TOKEN - name of file; 0 if none supplied**  Outputs:*        TOKEN - next token on the command line*        C - set if file read, else clear******************************************************************SFILE    START         USING COMMON         LONGI ON         LONGA ON         STA   R4                       save sidp to file record         LDA   TOKEN+1                  if strlen(token) == 0 then         AND   #$00FF         BNE   LB1         PUTS  #'File name: '             printf("File name: ");         GETS  LINE                       set input line to file name         LLA   INLINE,LINE+2         SHORT I,M         LDX   LINE+1         STZ   LINE+1,X         LONG  I,M         STZ   CLDISP         JSR   STOKN                      read token         LDA   TOKEN+1                    if strlen(token) == 0 then         AND   #$00FF         BNE   LB1         CLC                                return with carry clear         RTS                              endifLB1      ANOP                           endif         INIT_WILDCARD IN_DCB           expand devices, prefixes and wildcards         JCS   ERR         NEXT_WILDCARD IN_DCB         LDA   TOKEN+1         AND   #$00FF         JEQ   ERR         OPEN  OP_DCB                   open the file         JCS   ERR         LDA   OP_REF         STA   RD_REF         STA   CL_REF         STA   EF_REF         GET_EOF EF_DCB                 find its length         JCS   SSERR         MOVE4 EF_EOF,RD_REQ         ADD4  EF_EOF,#2                get space for the file         NEW   HAND,EF_EOF         JCS   SSERR         LOCK  HAND,FILEPTR         JCS   SSERR         ADD4  FILEPTR,RD_REQ,R0        set the null terminator         LDA   #0         STA   [R0]         MOVE4 FILEPTR,RD_BUFF          read the file         READ  RD_DCB         JCS   SSERR         CLOSE CL_DCB                   close the file         JCS   SSERR         LDX   R4                       set file pointer         LDA   FILEPTR         STA   0,X         LDA   FILEPTR+2         STA   2,X         LDA   RD_REQ                   set file length         STA   4,X         LDA   RD_REQ+2         STA   6,X         JSR   STOKN                    read next token         SEC         RTSERR      PUTS  TOKEN,ERROUT=T         PUTS  #' could not be opened.',CR=T,ERROUT=T         LDA   #$FFFF         QUIT  QT_DCBIN_DCB   ANOP                           INIT_WILDCARD DCB         DC    A4'TOKEN+1'         DC    I'$4000'OP_DCB   ANOP                           OPEN DCBOP_REF   DS    2         DC    A4'TOKEN+1'OP_BUFF  DS    4EF_DCB   ANOP                           GET_EOF DCBEF_REF   DS    2EF_EOF   DS    4RD_DCB   ANOP                           READ DCBRD_REF   DS    2RD_BUFF  DS    4RD_REQ   DS    4         DS    4CL_DCB   ANOP                           CLOSE DCBCL_REF   DS    2HAND     DS    4         END******************************************************************  SFINI - Program Termination******************************************************************SFINI    START         USING COMMON         LONGA ON         LONGI ON         CLOSE CL_DCB                   close all open files         DISPOSEALL USER_ID             dispose of all memory         RTSCL_DCB   ANOP         DC    I'0'         END******************************************************************  SFLAG - Read a flag from the command line**  Inputs:*        TOKEN - token to check to see if its a flag**  Outputs:*        A - flag character; MSB set for +, clear for -*        C - set if flag found, else clear******************************************************************SFLAG    START         USING COMMON         LONGA ON         LONGI ON         SHORT I,M         LDA   TOKEN+1         CMP   #2         BNE   NOT         LDA   #0         LDX   TOKEN+2         CPX   #'-'         BEQ   MINUS         CPX   #'+'         BEQ   PLUSNOT      CLC         LONG  I,M         RTS         LONGI OFF         LONGA OFFPLUS     LDA   #$80MINUS    ORA   TOKEN+3         LONG  I,M         AND   #$00FF         PHA         JSR   STOKN         PLA         CMP   #'a'         BLT   LB1         CMP   #'z'+1         BLT   LB0         CMP   #'a'+$80         BLT   LB1         CMP   #'z'+$80+1         BGE   LB1LB0      AND   #$00DFLB1      SEC         RTS         END******************************************************************  SFLGB - Handle -B Conversion (ignore leading spaces)**  Inputs:*        Y - disp in data bank to start of line******************************************************************SFLGB    START         USING COMMON         LONGI ON         LONGA ON         TYX                            save disp to start of line         SHORT M                        skip initial whitespace in LINEFB1      LDA   |0,Y         CMP   #RETURN         BEQ   FB3         CMP   #' '         BEQ   FB2         CMP   #9         BLT   FB3         CMP   #$C+1         BGE   FB3FB2      INY         BRA   FB1FB3      LDA   |0,Y                     copy remainder of line to start         STA   |0,X         CMP   #RETURN         BEQ   FB4         INY         INX         BRA   FB3FB4      LONG  M         RTS         END******************************************************************  SFLGF - Handle -F Conversion (fold uppercase to lower)**  Inputs:*        Y - disp in data bank to start of line******************************************************************SFLGF    START         USING COMMON         LONGI ON         LONGA ON         SHORT MFF1      LDA   |0,Y         CMP   #RETURN         BEQ   FF3         CMP   #'A'         BLT   FF2         CMP   #'Z'+1         BGE   FF2         ORA   #$20         STA   |0,YFF2      INY         BRA   FF1FF3      LONG  M         RTS         END******************************************************************  SFLGI - Handle -I Conversion (ignore chars outside $20..$7E)**  Inputs:*        Y - disp in data bank to start of line******************************************************************SFLGI    START         USING COMMON         LONGI ON         LONGA ON         TYX                            set X to start of line         SHORT MLB1      LDA   |0,Y                     quit if at end of line         CMP   #RETURN         BEQ   LB3         CMP   #$20                     if the character no good, go to LB2         BLT   LB2         CMP   #$7F         BGE   LB2         STA   |0,X                     character is good - save it         INXLB2      INY                            next character         BRA   LB1LB3      STA   |0,X                     save the RETURN         LONG  M         RTS         END******************************************************************  SFLGW - Handle -W Conversion (runs of whitespace compare equal)**  Inputs:*        Y - disp in data bank to start of line******************************************************************SFLGW    START         USING COMMON         LONGI ON         LONGA ON         TYX                            set X to start of line         SHORT MLB1      LDA   |0,Y                     get the character         JSR   WHITE                    if whitespace (but not RETURN) then         BCC   LB3LB2      INY                              read chars until not whitespace         LDA   |0,Y         JSR   WHITE         BCS   LB2         DEY                              prepare to skip this char         LDA   #' '                       save a blankLB3      STA   |0,X                     save the character         INX         INY                            next character         CMP   #RETURN                  if this was not RETURN, loop         BNE   LB1         LONG  M         RTS         LONGA OFFWHITE    CMP   #' '         BEQ   YES         CMP   #RETURN         BEQ   NO         CMP   #9         BLT   NO         CMP   #$C+1         BGE   NOYES      SEC         RTSNO       CLC         RTS         LONGA ON         END******************************************************************  SINCL - Increment line pointer to next line**  Inputs:*        R0 - pointer to line**  Outputs:*        R0 - pointer to next line******************************************************************SINCL    START         USING COMMON         LONGA ON         LONGI ON         SHORT M                        while not at end of line or end of file         LDY   #0                         doLB1      LDA   [R0],Y         BEQ   LB3         CMP   #RETURN         BEQ   LB2         INY                              next character         BRA   LB1LB2      INY                            skip end of line markerLB3      LONG  M                        add line length to line pointer         CLC         TYA         ADC   R0         STA   R0         BCC   LB4         INC   R2LB4      RTS         END******************************************************************  SINIT - Program Initialization******************************************************************SINIT    START         USING COMMON         LONGA ON         LONGI ON;;  Save O/S supplied values;         PHK                            set data bank         PLB         ORA   #$0100                   save user ID         STA   USER_ID         STX   INLINE+2                 save addr of input line         STY   INLINE;;  Initialize global variables;         STZ   ST_STOP                  don't stop yet         STZ   COPYRIGHT                COPYRIGHT = FALSE         STZ   FLAGB                    FLAGB = FALSE         STZ   FLAGF                    FLAGF = FALSE         STZ   FLAGI                    FLAGI = FALSE         STZ   FLAGW                    FLAGW = FALSE         STZ   FLAGN                    FLAGN = FALSE         STZ   ANYFLAG                  ANYFLAG = FALSE         LA    SYNC,5                   resync after 5 lines         STZ   DIFF                     files are not different         STZ   LN1+2                    set line numbers to 1         STZ   LN2+2         LDA   #1         STA   LN1         STA   LN2;;  Read flags.;         LDA   #8                       skip shell identifier         STA   CLDISP         JSR   STOKN                    read the command name         JSR   STOKN                    skip if there is no token on the lineLB1      LDA   TOKEN+1         AND   #$00FF         JEQ   FL1         JSR   SFLAG                    read any flags on the line         JCC   FL1         CMP   #'V'                     if -V then         BNE   LB2         LDA   #TRUE                      COPYRIGHT = TRUE         STA   COPYRIGHT         BRA   LB1LB2      CMP   #'B'                     else if -B then         BNE   LB3         LDA   #TRUE                      FLAGB = TRUE         STA   FLAGB         STA   ANYFLAG                    ANYFLAG = TRUE         BRA   LB1LB3      CMP   #'F'                     else if -F then         BNE   LB4         LDA   #TRUE                      FLAGF = TRUE         STA   FLAGF         STA   ANYFLAG                    ANYFLAG = TRUE         BRA   LB1LB4      CMP   #'I'                     else if -I then         BNE   LB5         LDA   #TRUE                      FLAGI = TRUE         STA   FLAGI         STA   ANYFLAG                    ANYFLAG = TRUE         BRA   LB1LB5      CMP   #'W'                     else if -W then         BNE   LB6         LDA   #TRUE                      FLAGW = TRUE         STA   FLAGW         STA   ANYFLAG                    ANYFLAG = TRUE         BRL   LB1LB6      CMP   #'N'                     else if -N then         BNE   LB7         LDA   #TRUE                      FLAGN = TRUE         STA   FLAGN         BRL   LB1LB7      CMP   #'S'                     else if -S then         BNE   BADFLAG         CNVS2 TOKEN,SYNC                 SYNC = value(TOKEN)         BVS   BADVAL         LDA   SYNC         BEQ   BADVAL         BMI   BADVAL         JSR   STOKN                      get next token         BRL   LB1BADVAL   PUTS  #'-S value must be in [1..32767]',CR=T,ERROUT=T         BRA   BF1BADFLAG  PUTS  #'Illegal flag',CR=T,ERROUT=TBF1      JSR   SFINI         LDA   #$FFFF         QUIT  QT_DCB;;  Set up the input file;FL1      LDA   #FILE1                   set up standard in         JSR   SFILE         BCC   NOTFOUND         LDA   #FILE2         JSR   SFILE         BCC   NOTFOUND         LDA   TOKEN+1         AND   #$00FF         BNE   BADPARM         RTSBADPARM  PUTS  #'Too many parameters on command line',CR=T,ERROUT=T         JSR   SFININOTFOUND LDA   #$FFFF         QUIT  QT_DCB         END******************************************************************  SLIST - List lines**  Inputs:*        R0 - pointer to lines to list*        R4 - # lines to list*        LN - starting line number*        FLAGN - print line numbers?******************************************************************SLIST    START         USING COMMON         LONGA ON         LONGI ONKEYBOARD EQU   $C000                    keyboard locationSTROBE   EQU   $C010                    keyboard strobeLB1      LDA   R4                       while (R4 > 0)         ORA   R6         JEQ   LB4         LDA   FLAGN                      {if (FLAGN)         BEQ   PN1         PUT4  LN,#5                        {write(ln:5,' ');         PUTC  #' '         INC4  LN                           ++ln;PN1      ANOP                               }         LDY   #0LB2      LDA   [R0],Y                     if (<end of file>)         AND   #$00FF         BEQ   LB4                          break;         CMP   #RETURN                    if (<char> != RETURN)         BEQ   LB3         PHY                                putchar;         PHA         _WRITECHAR         PLY         INY         BRA   LB2LB3      ANOP                             else         JSR   SINCL                        {++R0;         DEC4  R4                           --R4;         PUTCR                              putchar('\n');         STOP  ST_DCB                       if (stop())         LDA   ST_STOP                        return;         BNE   LB4         SHORT M                            if (keypress())         LDA   >KEYBOARD         BPL   KB2         STA   >STROBEKB1      LDA   >KEYBOARD                      do while (!keypress());         BPL   KB1         STOP  ST_DCB         LDA   ST_STOP         BNE   LB4         STA   >STROBEKB2      LONG  M         BRL   LB1                          }!                                         }LB4      RTS         END******************************************************************  SMAIN - Top level control******************************************************************SMAIN    START         USING COMMON         LONGA ON         LONGI ON         STZ   ST_STOP                  don't stop yet         LDA   COPYRIGHT                if V flag then write copyright         BEQ   LB1         PUTS  #'Text Compare 1.0',CR=T         PUTS  #'Copyright 1987, Byte Works, Inc.',CR=T         PUTCRLB1      LDA   [FILE1]                  while (not at either end of file)         AND   #$00FF         JEQ   SF1         LDA   [FILE2]         AND   #$00FF         JEQ   FF1         MOVE4 FILE1,R8                   {if (*file1 == *file2)         MOVE4 FILE2,R12         JSR   SCOMP         BNE   LB2         MOVE4 FILE1,R0                     {++file1;         JSR   SINCL         MOVE4 R0,FILE1         MOVE4 FILE2,R0                     ++file2;         JSR   SINCL         MOVE4 R0,FILE2         INC4  LN1                          ++<Line # for file 1>;         INC4  LN2                          ++<Line # for file 2>;         STOP  ST_DCB                       <check for abort>;         LDA   ST_STOP         JNE   ERR         BRA   LB1                          }LB2      ANOP                             else         LA    DIFF,1                       {diff = TRUE;         LLA   DELTA,1                      delta = 1;DF1      ANOP                               for (,,)         STOP  ST_DCB                         {<check for abort>;         LDA   ST_STOP         JNE   ERR         MOVE4 DELTA,LEFT                     left = delta;         STZ   RIGHT                          right = 0;         STZ   RIGHT+2DF2      LDA   LEFT+2                         while (left >= 0)         BMI   DF4         JSR   SSYNC                            {if (sync(left,right))         BCC   DF3         JSR   SDIFF                              {<write differing lines>;         LDA   ST_STOP         JNE   ERR         ADD4  LN1,LEFT                           <update line # for file 1>;         ADD4  LN2,RIGHT                          <update line # for file 2>;         MOVE4 FILE1,R0                           skip(file1,left);         MOVE4 LEFT,R4         JSR   SSKIP         MOVE4 R0,FILE1         MOVE4 FILE2,R0                           skip(file2,right);         MOVE4 RIGHT,R4         JSR   SSKIP         MOVE4 R0,FILE2         BRL   LB1                                break(2);DF3      ANOP                                     }         DEC4  LEFT                             --left;         INC4  RIGHT                            ++right;         BRA   DF2                              }DF4      INC4  DELTA                          ++delta;         LDA   DELTA+2                        if (<file1 is diff/2 from end>)         LSR   A         STA   R6         LDA   DELTA         ROR   A         STA   R4         MOVE4 FILE1,R0         JSR   SSKIP         LDA   [R0]         AND   #$00FF         JNE   DF1         LDA   DELTA+2                          if (<file2 is diff/2 from end>)         LSR   A         STA   R6         LDA   DELTA         ROR   A         STA   R4         MOVE4 FILE2,R0         JSR   SSKIP         LDA   [R0]         AND   #$00FF         JNE   DF1         MOVE4 DELTA,LEFT                         {<write differing lines>;         MOVE4 DELTA,RIGHT         JSR   SDIFF         BRA   ERR                                skip(file1,delta);!                                                 skip(file2,delta);!                                                 break;!                                                 }!                                             }!                                           }!                                         };;  First file is longer.;FF1      PUTCR                          print extra lines in first file         PUTS  #'---- First file is longer.  Extra lines:',CR=T         PUTCR         MOVE4 FILE1,R0         LLA   R4,-1         JSR   SLISTERR      LDA   #$FFFF         RTS;;  Check for second file longer than first.;SF1      LDA   [FILE2]                  branch if at end of second file         AND   #$00FF         BEQ   CM1         PUTCR                          print extra lines in second file         PUTS  #'---- Second file is longer.  Extra lines:',CR=T         PUTCR         MOVE4 FILE2,R0         LLA   R4,-1         JSR   SLIST         LDA   #$FFFF         RTS;;  Check for match.;CM1      LDA   #$FFFF         LDX   DIFF                     if (!diff)         JNE   ERR         PUTS  #'Files match.',CR=T       <write message>         LDA   #0                       return 0;         RTSDELTA    DS    4                        # differing lines         END******************************************************************  SSERR - Flag a system error**  Inputs:*        A - error number******************************************************************SSERR    START         USING COMMON         LONGA ON         LONGI ON         STA   ER_NUM         PUTCR         ERROR ER_DCB         JSR   SFINI         LDA   ER_NUM         QUIT  QT_DCBER_DCB   ANOPER_NUM   DS    2         END******************************************************************  SSKIP - Skip R4 lines past *R0**  Inputs:*        R0 - pointer to file to skip in*        R4 - # lines to skip**  Outputs:*        R0 - points to correct line or end of file******************************************************************SSKIP    START         USING COMMON         LONGA ON         LONGI ONLB1      LDA   R4         ORA   R6         BEQ   LB2         JSR   SINCL         DEC4  R4         BRA   LB1LB2      RTS         END******************************************************************  SSYNC - See if files have syncronized**  Inputs:*        LEFT - # lines to skip on left side*        RIGHT - # lines to skip on right side*        FILE1 - start position in file 1*        FILE2 - start position in file 2**  Outputs:*        C - set if files are syncronized******************************************************************SSYNC    START         USING COMMON         LONGA ON         LONGI ON         MOVE4 FILE1,R0                 skip to start point in file 1         MOVE4 LEFT,R4         JSR   SSKIP         MOVE4 R0,P1         MOVE4 FILE2,R0                 skip to start point in file 2         MOVE4 RIGHT,R4         JSR   SSKIP         MOVE4 R0,P2         MOVE  SYNC,CNT                 for (cnt = sync; cnt --; cnt >0)LB1      MOVE4 P1,R8         MOVE4 P2,R12         LDA   [R8]                       {if (<end of file 1>)         AND   #$00FF         BEQ   NO                           return FALSE;         LDA   [R12]                      if (<end of file 2>)         AND   #$00FF         BEQ   NO                           return FALSE;         JSR   SCOMP                      if (!compare(R8,R12))         BNE   NO                           return FALSE;         MOVE4 P1,R0                      ++R8;         JSR   SINCL         MOVE4 R0,P1         MOVE4 P2,R0                      ++R12;         JSR   SINCL         MOVE4 R0,P2         DEC   CNT                        }         BNE   LB1         SEC                            return TRUE;         RTSNO       CLC         RTSCNT      DS    2                        loop counterP1       DS    4                        work pointersP2       DS    4         END******************************************************************  STOKN - Read a token from the command line**  Outputs:*        TOKEN - token read******************************************************************STOKN    START         USING COMMON         LONGA ON         LONGI ON         STZ   TOKEN+1                  set token to null         LDA   INLINE                   quit if no command line         ORA   INLINE+2         BEQ   LB5         SHORT I,M         LDY   CLDISP                   skip leading blanksLB1      LDA   [INLINE],Y         CMP   #' '         BNE   LB2         INY         BRA   LB1LB2      LDX   #0                       read the tokenLB3      LDA   [INLINE],Y         BEQ   LB4         CMP   #' '         BEQ   LB4         STA   TOKEN+2,X         INY         INX         BPL   LB3LB4      STX   TOKEN+1                  set the string length         STY   CLDISP                   save the new disp         LONG  I,MLB5      RTS         END