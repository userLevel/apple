         KEEP  CMP         MCOPY CP.MACROS******************************************************************  CMP 1.0*  23 January 1987**  Two files are read into memory and compared.  If they differ,*  the location in the file (in hex and decimal) and the values*  of the bytes (first file first, in hex) are printed.  If the*  files are the same, the return code is 0.  If they differ, it*  is 1.  If there was an error, it is 2.**  CMP [-L] [-S] [-V] file1 file2**        -L    List all differences, not just the first.*        -S    Print nothing - set status only.*        -V    Print version number and copyright.*        file1 First file to compare.*        file2 Second file to compare.**  By Mike Westerfield**  Copyright 1987*  By the Byte Works, Inc.*  All rights reserved******************************************************************CMP      START         JSR   SINIT         JSR   SMAIN         PHA         JSR   SFINI         PLA         RTL         DC    C'CMP 1.0'         DC    C'Copyright 1987, Byte Works, Inc.'         END******************************************************************  COMMON - Common Data Areas******************************************************************COMMON   DATA;;  Constants;RETURN   EQU   $D                       RETURN key codeLINEFEED EQU   $A                       line feed key codeFALSE    EQU   0                        boolean constantsTRUE     EQU   1;;  Zero Page Equates;R0       GEQU  $0                       general purpose registersR1       GEQU  $1R2       GEQU  $2R3       GEQU  $3R4       GEQU  $4R5       GEQU  $5R6       GEQU  $6R7       GEQU  $7R8       GEQU  $8R9       GEQU  $9R10      GEQU  $AR11      GEQU  $BR12      GEQU  $CR13      GEQU  $DR14      GEQU  $ER15      GEQU  $FINLINE   GEQU  $10                      pointer to input lineCLDISP   GEQU  $14                      disp in INLINEFILEPTR  GEQU  $18                      pointer to start of file being loadedLOCKP    GEQU  $1C                      work area for LOCKFILE1    GEQU  $20                      pointer to start of file 1FLEN1    GEQU  $24                      length of file 1FILE2    GEQU  $28                      pointer to start of file 2FLEN2    GEQU  $2C                      length of file 2MINLEN   GEQU  $30                      length of the smallest fileDISPINFILE GEQU $34                     disp into the file so farDIFF     GEQU  $38                      are files different?;;  Flagged variables;COPYRIGHT GEQU $40                      display copyright?PRINTALL GEQU  $42                      print all differences?PRINTDIF GEQU  $44                      print nothing - only do error return?;;  DCBs;QT_DCB   ANOP                           quit DCB         DC    A4'QT_FLAGS'QT_FLAGS DC    I'0'ER_DCB   ANOP                           system error DCBER_NUM   DS    2;;  Global Variables;LINE     DSTR  ,255                     input line         DS    1TOKEN    DSTR  ,255                     command line tokenUSER_ID  DS    2                        User ID         END******************************************************************  SDIFF - Handle a difference in the file**  Inputs:*        PRINTALL - print more that one difference?*        PRINTDIFF - print nothing?*        DISPINFILE - disp into the file (not counting Y)*        Y - disp into the bank*        FILE1 - points to current bank in first file*        FILE2 - points to current bank in second file**  Outputs:*        DIFF - set to true**  Notes:*        1) Exits if PRINTALL is false.*        2) X, Y are undisturbed*        3) Entry and exit with M=1******************************************************************SDIFF    START         USING COMMON         LONGA ON         LONGI ON         PHX                            save registers         PHY         LDA   PRINTDIF                 if not PRINTDIF then         JNE   LB1         CLC                              print disp in file         LDA   1,S         ADC   DISPINFILE         STA   NUM         LDA   DISPINFILE+2         ADC   #0         STA   NUM+2         PUT4  NUM,#5         PUTS  #' ($'         LDA   NUM+2         JSR   SPRHX         LDA   NUM+1         JSR   SPRHX         LDA   NUM         JSR   SPRHX         PUTS  #') '                      print value in first file         PLY         PHY         LDA   [FILE1],Y         JSR   SPRHX         PUTC  #' '                       print value in second file         PLY         PHY         LDA   [FILE2],Y         JSR   SPRHX         PUTCRLB1      ANOP                           endif         LDA   PRINTALL                 if not PRINTALL then         BNE   LB2         LDA   #1                         return(1)         QUIT  QT_DCBLB2      ANOP                           endif         LDA   #TRUE                    DIFF = TRUE         STA   DIFF         PLY                            restore registers         PLX         RTSNUM      DS    4         END******************************************************************  SFILE - Read a file**  Inputs:*        A - disp in DP of file record - consists of:*              4 byte pointer to start of file*              4 byte file length*        TOKEN - name of file; 0 if none supplied**  Outputs:*        TOKEN - next token on the command line*        C - set if file read, else clear******************************************************************SFILE    START         USING COMMON         LONGI ON         LONGA ON         STA   R4                       save sidp to file record         LDA   TOKEN+1                  if strlen(token) == 0 then         AND   #$00FF         BNE   LB1         PUTS  #'File name: '             printf("File name: ");         GETS  LINE                       set input line to file name         LLA   INLINE,LINE+2         SHORT I,M         LDX   LINE+1         STZ   LINE+1,X         LONG  I,M         STZ   CLDISP         JSR   STOKN                      read token         LDA   TOKEN+1                    if strlen(token) == 0 then         AND   #$00FF         BNE   LB1         CLC                                return with carry clear         RTS                              endifLB1      ANOP                           endif         INIT_WILDCARD IN_DCB           expand devices, prefixes and wildcards         JCS   ERR         NEXT_WILDCARD IN_DCB         LDA   TOKEN+1         AND   #$00FF         JEQ   ERR         OPEN  OP_DCB                   open the file         JCS   ERR         LDA   OP_REF         STA   RD_REF         STA   CL_REF         STA   EF_REF         GET_EOF EF_DCB                 find its length         JCS   SSERR         MOVE4 EF_EOF,RD_REQ         ADD4  EF_EOF,#2                get space for the file         NEW   HAND,EF_EOF         JCS   SSERR         LOCK  HAND,FILEPTR         JCS   SSERR         ADD4  FILEPTR,RD_REQ,R0        set the null terminator         LDA   #0         STA   [R0]         MOVE4 FILEPTR,RD_BUFF          read the file         READ  RD_DCB         JCS   SSERR         CLOSE CL_DCB                   close the file         JCS   SSERR         LDX   R4                       set file pointer         LDA   FILEPTR         STA   0,X         LDA   FILEPTR+2         STA   2,X         LDA   RD_REQ                   set file length         STA   4,X         LDA   RD_REQ+2         STA   6,X         JSR   STOKN                    read next token         SEC         RTSERR      PUTS  TOKEN,ERROUT=T         PUTS  #' could not be opened.',CR=T,ERROUT=T         LDA   #-1         QUIT  QT_DCBIN_DCB   ANOP                           INIT_WILDCARD DCB         DC    A4'TOKEN+1'         DC    I'$4000'OP_DCB   ANOP                           OPEN DCBOP_REF   DS    2         DC    A4'TOKEN+1'OP_BUFF  DS    4EF_DCB   ANOP                           GET_EOF DCBEF_REF   DS    2EF_EOF   DS    4RD_DCB   ANOP                           READ DCBRD_REF   DS    2RD_BUFF  DS    4RD_REQ   DS    4         DS    4CL_DCB   ANOP                           CLOSE DCBCL_REF   DS    2HAND     DS    4         END******************************************************************  SFINI - Program Termination******************************************************************SFINI    START         USING COMMON         LONGA ON         LONGI ON         CLOSE CL_DCB                   close all open files         DISPOSEALL USER_ID             dispose of all memory         RTSCL_DCB   ANOP         DC    I'0'         END******************************************************************  SFLAG - Read a flag from the command line**  Inputs:*        TOKEN - token to check to see if its a flag**  Outputs:*        A - flag character; MSB set for +, clear for -*        C - set if flag found, else clear******************************************************************SFLAG    START         USING COMMON         LONGA ON         LONGI ON         SHORT I,M         LDA   TOKEN+1         CMP   #2         BNE   NOT         LDA   #0         LDX   TOKEN+2         CPX   #'-'         BEQ   MINUS         CPX   #'+'         BEQ   PLUSNOT      CLC         LONG  I,M         RTS         LONGI OFF         LONGA OFFPLUS     LDA   #$80MINUS    ORA   TOKEN+3         LONG  I,M         AND   #$00FF         PHA         JSR   STOKN         PLA         CMP   #'a'         BLT   LB1         CMP   #'z'+1         BLT   LB0         CMP   #'a'+$80         BLT   LB1         CMP   #'z'+$80+1         BGE   LB1LB0      AND   #$00DFLB1      SEC         RTS         END******************************************************************  SINIT - Program Initialization******************************************************************SINIT    START         USING COMMON         LONGA ON         LONGI ON;;  Save O/S supplied values;         PHK                            set data bank         PLB         ORA   #$0100                   save user ID         STA   USER_ID         STX   INLINE+2                 save addr of input line         STY   INLINE;;  Initialize global variables;         STZ   COPYRIGHT                COPYRIGHT = FALSE         STZ   PRINTALL                 PRINTALL = FALSE         STZ   PRINTDIF                 PRINTDIF = FALSE         STZ   DISPINFILE               DISPINFILE = 0         STZ   DISPINFILE+2         STZ   DIFF                     DIFF = FALSE;;  Read flags.;         LDA   #8                       skip shell identifier         STA   CLDISP         JSR   STOKN                    read the command name         JSR   STOKN                    skip if there is no token on the lineLB1      LDA   TOKEN+1         AND   #$00FF         BEQ   FL1         JSR   SFLAG                    read any flags on the line         BCC   FL1         CMP   #'V'                     if -V then         BNE   LB2         LDA   #TRUE                      COPYRIGHT = TRUE         STA   COPYRIGHT         BRA   LB1LB2      CMP   #'L'                     if -L then         BNE   LB3         LDA   #TRUE                      PRINTALL = TRUE         STA   PRINTALL         BRA   LB1LB3      CMP   #'S'                     if -S then         BNE   BADFLAG         LDA   #TRUE                      PRINTDIF = TRUE         STA   PRINTDIF         BRA   LB1BADFLAG  PUTS  #'Illegal flag',CR=T,ERROUT=T         JSR   SFINI         LDA   #$FFFF         QUIT  QT_DCB;;  Set up the input file;FL1      LDA   #FILE1                   set up standard in         JSR   SFILE         BCC   NOTFOUND         LDA   #FILE2         JSR   SFILE         BCC   NOTFOUND         LDA   TOKEN+1         AND   #$00FF         BNE   BADPARM         RTSBADPARM  PUTS  #'Too many parameters on command line',CR=T,ERROUT=T         JSR   SFININOTFOUND LDA   #$FFFF         QUIT  QT_DCB         END******************************************************************  SMAIN - Top level control******************************************************************SMAIN    START         USING COMMON         LONGA ON         LONGI ON         STZ   ST_STOP                  don't stop yet         LDA   COPYRIGHT                if V flag then write copyright         BEQ   LB0         PUTS  #'Compare 1.0',CR=T         PUTS  #'Copyright 1987, Byte Works, Inc.',CR=T         PUTCRLB0      MOVE4 FLEN1,MINLEN             MINLEN = min(FLEN1,FLEN2)         LDA   FLEN1+2         CMP   FLEN2+2         BNE   LB1         LDA   FLEN1         CMP   FLEN2LB1      BLT   LB2         MOVE4 FLEN2,MINLENLB2      LDA   MINLEN+2                 while MINLEN > $10000 do         BEQ   LB6         LDY   #0                         for Y = 0 to $FFFF do         SHORT MLB3      LDA   [FILE1],Y                    if bytes differ then         CMP   [FILE2],Y         BEQ   LB4         LONG  M         JSR   SDIFF                          sdiff         STOP  ST_DCB                         check for user-stop         LDA   ST_STOP         JNE   ERROUT         SHORT MLB4      ANOP                               endif         INY                              next Y         BNE   LB3LB5      LONG  M                          FILE1 = FILE1+$10000         INC   FILE1+2         INC   FILE2+2                    FILE2 = FILE2+$10000         INC   DISPINFILE+2               DISPINFILE = DISPINFILE+$10000         DEC   MINLEN+2                   MINLEN = MINLEN-$10000         STOP  ST_DCB                     check for user-stop         LDA   ST_STOP         JNE   ERROUT         BRA   LB2                      endwhileLB6      LDX   MINLEN                   for Y = 0 to MINLEN do         BEQ   LB9         LDY   #0         SHORT MLB7      LDA   [FILE1],Y                  if bytes differ then         CMP   [FILE2],Y         BEQ   LB8         LONG  M         JSR   SDIFF                        sdiff         STOP  ST_DCB                       check for user-stop         LDA   ST_STOP         JNE   ERROUT         SHORT MLB8      ANOP                             endif         INY                            next Y         DEX         BNE   LB7LB9      LONG  M         LDA   FLEN1+2                  if flen1 < flen2 then         CMP   FLEN2+2         BNE   LB10         LDA   FLEN1         CMP   FLEN2LB10     BGE   LB11         LDA   PRINTDIF         BNE   LB12         PUTS  #'First file is shorter.',CR=T,ERROUT=T         BRA   LB12                       DIFF = TRUELB11     BEQ   LB13                     else if flen1 > flen2 then         LDA   PRINTDIF         BNE   LB12         PUTS  #'First file is longer.',CR=T,ERROUT=TLB12     LDA   #TRUE                      DIFF = TRUE         STA   DIFFLB13     ANOP                           endif         LDA   DIFF                     if not DIFF then         BNE   LB14         LDA   PRINTDIF         BNE   LB14         PUTS  #'Files are equal.',CR=T   OKLB14     ANOP                           endif         LDA   DIFF                     return DIFF         RTSERROUT   LDA   #$FFFF                   quit with user exit         RTSST_DCB   ANOPST_STOP  DS    2         END******************************************************************  SPRHX - Print a hex byte**  Inputs:*        A - byte to print******************************************************************SPRHX    START         LONGA ON         LONGI ON         PHA                            save byte         LSR   A                        shift in most sig. nibble         LSR   A         LSR   A         LSR   A         JSR   LB1                      print it         PLA                            recall byteLB1      AND   #$000F                   print a nibble         ORA   #'0'         CMP   #'9'+1         BLT   LB2         ADC   #'A'-'9'-2LB2      PHA         LDX   #$190C         JSL   $E10000         RTS         END******************************************************************  SSERR - Flag a system error**  Inputs:*        A - error number******************************************************************SSERR    START         USING COMMON         LONGA ON         LONGI ON         STA   ER_NUM         PUTCR         ERROR ER_DCB         JSR   SFINI         LDA   ER_NUM         QUIT  QT_DCBER_DCB   ANOPER_NUM   DS    2         END******************************************************************  STOKN - Read a token from the command line**  Outputs:*        TOKEN - token read******************************************************************STOKN    START         USING COMMON         LONGA ON         LONGI ON         STZ   TOKEN+1                  set token to null         LDA   INLINE                   quit if no command line         ORA   INLINE+2         BEQ   LB5         SHORT I,M         LDY   CLDISP                   skip leading blanksLB1      LDA   [INLINE],Y         CMP   #' '         BNE   LB2         INY         BRA   LB1LB2      LDX   #0                       read the tokenLB3      LDA   [INLINE],Y         BEQ   LB4         CMP   #' '         BEQ   LB4         STA   TOKEN+2,X         INY         INX         BPL   LB3LB4      STX   TOKEN+1                  set the string length         STY   CLDISP                   save the new disp         LONG  I,MLB5      RTS         END