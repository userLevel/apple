         KEEP  TEE         MCOPY TE.MACROS******************************************************************  TEE 1.0*  20 January 1987**  Takes input from standard in or, if provided, a file.  The*  input file is echoed to standard out and error out.**  TEE [-V] [file]**        -V    Print version number and copyright.**  By Mike Westerfield**  Copyright 1987*  By the Byte Works, Inc.*  All rights reserved******************************************************************TEE      START         JSR   SINIT         JSR   SMAIN         JSR   SFINI         LDA   #0         RTL         DC    C'TEE 1.0'         DC    C'Copyright 1987, Byte Works, Inc.'         END******************************************************************  COMMON - Common Data Areas******************************************************************COMMON   DATA;;  Constants;RETURN   EQU   $D                       RETURN key codeLINEFEED EQU   $A                       line feed key codeFALSE    EQU   0                        boolean constantsTRUE     EQU   1;;  Zero Page Equates;R0       GEQU  $0                       general purpose registersR1       GEQU  $1R2       GEQU  $2R3       GEQU  $3R4       GEQU  $4R5       GEQU  $5R6       GEQU  $6R7       GEQU  $7R8       GEQU  $8R9       GEQU  $9R10      GEQU  $AR11      GEQU  $BR12      GEQU  $CR13      GEQU  $DR14      GEQU  $ER15      GEQU  $FINLINE   GEQU  $10                      pointer to input lineCLDISP   GEQU  $14                      disp in INLINESTANDARDIN GEQU $16                     standard in?FILEPTR  GEQU  $18                      pointer to next characterLOCKP    GEQU  $1C                      work area for LOCK;;  Flagged variables;COPYRIGHT GEQU $40                      display copyright?;;  DCBs;QT_DCB   ANOP                           quit DCB         DC    A4'QT_FLAGS'QT_FLAGS DC    I'0'ER_DCB   ANOP                           system error DCBER_NUM   DS    2;;  Global Variables;TOKEN    DSTR  ,255                     command line tokenUSER_ID  DS    2                        User ID         END******************************************************************  SFINI - Program Termination******************************************************************SFINI    START         USING COMMON         LONGA ON         LONGI ON         CLOSE CL_DCB                   close all open files         DISPOSEALL USER_ID             dispose of all memory         RTSCL_DCB   ANOP         DC    I'0'         END******************************************************************  SFLAG - Read a flag from the command line**  Inputs:*        TOKEN - token to check to see if its a flag**  Outputs:*        A - flag character; MSB set for +, clear for -*        C - set if flag found, else clear******************************************************************SFLAG    START         USING COMMON         LONGA ON         LONGI ON         SHORT I,M         LDA   TOKEN+1         CMP   #2         BNE   NOT         LDA   #0         LDX   TOKEN+2         CPX   #'-'         BEQ   MINUS         CPX   #'+'         BEQ   PLUSNOT      CLC         LONG  I,M         RTS         LONGI OFF         LONGA OFFPLUS     LDA   #$80MINUS    ORA   TOKEN+3         LONG  I,M         AND   #$00FF         PHA         JSR   STOKN         PLA         CMP   #'a'         BLT   LB1         CMP   #'z'+1         BLT   LB0         CMP   #'a'+$80         BLT   LB1         CMP   #'z'+$80+1         BGE   LB1LB0      AND   #$00DFLB1      SEC         RTS         END******************************************************************  SGETC - Get a character**  Inputs:*        STANDARDIN - standard in?*        FILEPTR - pointer to next char in file (if not stdin)**  Outputs:*        A - character read******************************************************************SGETC    START         USING COMMON         LONGA ON         LONGI ON         LDA   STANDARDIN         BNE   LB1         LDA   [FILEPTR]         AND   #$00FF         INC4  FILEPTR         RTSLB1      PHA         PEA   0         LDX   #$220C         JSL   $E10000         PLA         AND   #$00FF         RTS         END******************************************************************  SINIT - Program Initialization******************************************************************SINIT    START         USING COMMON         LONGA ON         LONGI ON;;  Save O/S supplied values;         PHK                            set data bank         PLB         ORA   #$0100                   save user ID         STA   USER_ID         STX   INLINE+2                 save addr of input line         STY   INLINE;;  Initialize global variables;         STZ   COPYRIGHT                COPYRIGHT = FALSE;;  Read flags.;         LDA   #8                       skip shell identifier         STA   CLDISP         JSR   STOKN                    read the command nameLB1      JSR   STOKN                    skip if there is no token on the line         LDA   TOKEN+1         AND   #$00FF         BEQ   FL1         JSR   SFLAG                    read any flags on the line         BCC   FL1         CMP   #'V'         BNE   BADFLAG         LDA   #TRUE         STA   COPYRIGHT         BRA   FL1BADFLAG  PUTS  #'Illegal flag',CR=T,ERROUT=T         JSR   SFINI         LDA   #$FFFF         QUIT  QT_DCB;;  Set up the input file;FL1      JSR   STDIN                    set up standard in         JSR   STOKN         RTS         END******************************************************************  SMAIN - Top level control******************************************************************SMAIN    START         USING COMMON         LONGA ON         LONGI ON         STZ   ST_STOP                  don't stop yet         LDA   COPYRIGHT                if V flag then write copyright         BEQ   LB1         PUTS  #'Tee 1.0',CR=T         PUTS  #'Copyright 1987, Byte Works, Inc.',CR=T         PUTCRLB1      JSR   SGETC                    get next char         AND   #$00FF                   if at end of file, quit         BEQ   LB4         CMP   #RETURN                  if return then         BNE   LB3         PHA                              write RETURN-LINEFEED         PHA         STOP  ST_DCB                     check for user-stop         LDX   #$180C         JSL   $E10000         LDX   #$190C         JSL   $E10000         LDA   #LINEFEEDLB3      PHA                            write the character         PHA         LDX   #$180C         JSL   $E10000         LDX   #$190C         JSL   $E10000         LDA   ST_STOP                  exit if a stop has been flagged         BEQ   LB1         RTSLB4      LDA   TOKEN+1                  if there is another file, do it         AND   #$00FF         BEQ   RTS         JSR   STDIN         JSR   STOKN         BRA   LB1RTS      RTSST_DCB   ANOPST_STOP  DS    2         END******************************************************************  SSERR - Flag a system error**  Inputs:*        A - error number******************************************************************SSERR    START         USING COMMON         LONGA ON         LONGI ON         STA   ER_NUM         PUTCR         ERROR ER_DCB         JSR   SFINI         LDA   ER_NUM         QUIT  QT_DCBER_DCB   ANOPER_NUM   DS    2         END******************************************************************  STDIN - Set up stanadard in**  Inputs:*        TOKEN - file name (if any)**  Outputs:*        FILEHANDLE - if file read, this is the handle******************************************************************STDIN    START         USING COMMON         LONGA ON         LONGI ON         LDA   #TRUE                    assume standard in         STA   STANDARDIN         LDA   TOKEN+1                  if no token, use standard in         AND   #$00FF         BNE   LB1         RTSLB1      STZ   STANDARDIN               not standard in         INIT_WILDCARD IN_DCB           expand wildcards         JCS   ERR         NEXT_WILDCARD IN_DCB         LDA   TOKEN+1         AND   #$00FF         JEQ   ERR         OPEN  OP_DCB                   open the file         JCS   ERR         LDA   OP_REF         STA   RD_REF         STA   CL_REF         STA   EF_REF         GET_EOF EF_DCB                 find its length         JCS   SSERR         MOVE4 EF_EOF,RD_REQ         ADD4  EF_EOF,#2                get space for the file         NEW   HAND,EF_EOF         JCS   SSERR         LOCK  HAND,FILEPTR         JCS   SSERR         ADD4  FILEPTR,RD_REQ,R0        set the null terminator         LDA   #0         STA   [R0]         MOVE4 FILEPTR,RD_BUFF          read the file         READ  RD_DCB         JCS   SSERR         CLOSE CL_DCB                   close the file         JCS   SSERR         RTSERR      PUTS  TOKEN,ERROUT=T         PUTS  #' could not be opened.',CR=T,ERROUT=T         LDA   #$FFFF         QUIT  QT_DCBIN_DCB   ANOP                           INIT_WILDCARD, NEXT_WILDCARD DCB         DC    A4'TOKEN+1'         DC    I'$4000'OP_DCB   ANOP                           OPEN DCBOP_REF   DS    2         DC    A4'TOKEN+1'OP_BUFF  DS    4EF_DCB   ANOP                           GET_EOF DCBEF_REF   DS    2EF_EOF   DS    4RD_DCB   ANOP                           READ DCBRD_REF   DS    2RD_BUFF  DS    4RD_REQ   DS    4         DS    4CL_DCB   ANOP                           CLOSE DCBCL_REF   DS    2HAND     DS    4         END******************************************************************  STOKN - Read a token from the command line**  Outputs:*        TOKEN - token read******************************************************************STOKN    START         USING COMMON         LONGA ON         LONGI ON         STZ   TOKEN+1                  set token to null         LDA   INLINE                   quit if no command line         ORA   INLINE+2         BEQ   LB5         SHORT I,M         LDY   CLDISP                   skip leading blanksLB1      LDA   [INLINE],Y         CMP   #' '         BNE   LB2         INY         BRA   LB1LB2      LDX   #0                       read the tokenLB3      LDA   [INLINE],Y         BEQ   LB4         CMP   #' '         BEQ   LB4         STA   TOKEN+2,X         INY         INX         BPL   LB3LB4      STX   TOKEN+1                  set the string length         STY   CLDISP                   save the new disp         LONG  I,MLB5      RTS         END