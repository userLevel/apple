         KEEP  UNIQ         MCOPY UN.MACROS******************************************************************  UNIQ 1.0*  18 January 1987**  Takes input from standard in or, if provided, a file.  Duplicate*  lines are removed, and the result sent to standard out.**  UNIQ [-U] [-D] [-C] [-V] [file]**        -U    If coded, only lines that have no duplicates*              are printed.  Normally, a line that is duplicated*              will be printed once.**        -D    If coded, only lines that are duplicated are printed.*              They are only printed once.**        -C    If coded, the lines that are printed are preceded with*              sequence count of the number of times they appear*              in the file.**        -V    Print version number and copyright.**  By Mike Westerfield**  Copyright 1987*  By the Byte Works, Inc.*  All rights reserved******************************************************************UNIQ     START         JSR   SINIT         JSR   SMAIN         JSR   SFINI         LDA   #0         RTL         DC    C'UNIQ 1.0'         DC    C'Copyright 1987, Byte Works, Inc.'         END******************************************************************  COMMON - Common Data Areas******************************************************************COMMON   DATA;;  Constants;RETURN   EQU   $D                       RETURN key codeLINEFEED EQU   $A                       line feed key codeFALSE    EQU   0                        boolean constantsTRUE     EQU   1MAXLINE  EQU   255                      max length of a line;;  Zero Page Equates;R0       GEQU  $0                       general purpose registersR1       GEQU  $1R2       GEQU  $2R3       GEQU  $3R4       GEQU  $4R5       GEQU  $5R6       GEQU  $6R7       GEQU  $7R8       GEQU  $8R9       GEQU  $9R10      GEQU  $AR11      GEQU  $BR12      GEQU  $CR13      GEQU  $DR14      GEQU  $ER15      GEQU  $FINLINE   GEQU  $10                      pointer to input lineCLDISP   GEQU  $14                      disp in INLINESTANDARDIN GEQU $16                     standard in?FILEPTR  GEQU  $18                      pointer to next characterLOCKP    GEQU  $1C                      work area for LOCKENDFOUND GEQU  $20                      has the end of file been found?DUPCOUNT GEQU  $22                      number of duplicate lines;;  Flagged variables;COPYRIGHT GEQU $40                      display copyright?PRINTUNIQ GEQU $42                      print only unique lines?PRINTDUPS GEQU $44                      print only duplicate lines?PRINTCOUNT GEQU $46                     print # of occurances?;;  DCBs;QT_DCB   ANOP                           quit DCB         DC    A4'QT_FLAGS'QT_FLAGS DC    I'0'ER_DCB   ANOP                           system error DCBER_NUM   DS    2;;  Global Variables;LASTLINE DSTR  ,MAXLINE                 last input lineLINE     DSTR  ,MAXLINE                 input lineTOKEN    DSTR  ,255                     command line tokenUSER_ID  DS    2                        User ID         END******************************************************************  SFINI - Program Termination******************************************************************SFINI    START         USING COMMON         LONGA ON         LONGI ON         CLOSE CL_DCB                   close all open files         DISPOSEALL USER_ID             dispose of all memory         RTSCL_DCB   ANOP         DC    I'0'         END******************************************************************  SFLAG - Read a flag from the command line**  Inputs:*        TOKEN - token to check to see if its a flag**  Outputs:*        A - flag character; MSB set for +, clear for -*        C - set if flag found, else clear******************************************************************SFLAG    START         USING COMMON         LONGA ON         LONGI ON         SHORT I,M         LDA   TOKEN+1         CMP   #2         BNE   NOT         LDA   #0         LDX   TOKEN+2         CPX   #'-'         BEQ   MINUS         CPX   #'+'         BEQ   PLUSNOT      CLC         LONG  I,M         RTS         LONGI OFF         LONGA OFFPLUS     LDA   #$80MINUS    ORA   TOKEN+3         LONG  I,M         AND   #$00FF         PHA         JSR   STOKN         PLA         CMP   #'a'         BLT   LB1         CMP   #'z'+1         BLT   LB0         CMP   #'a'+$80         BLT   LB1         CMP   #'z'+$80+1         BGE   LB1LB0      AND   #$00DFLB1      SEC         RTS         END******************************************************************  SGETC - Get a character**  Inputs:*        STANDARDIN - standard in?*        FILEPTR - pointer to next char in file (if not stdin)**  Outputs:*        A - character read******************************************************************SGETC    START         USING COMMON         LONGA ON         LONGI ON         LDA   STANDARDIN         BNE   LB1         LDA   [FILEPTR]         AND   #$00FF         INC4  FILEPTR         RTSLB1      PHA         PEA   0         LDX   #$220C         JSL   $E10000         PLA         AND   #$00FF         RTS         END******************************************************************  SINIT - Program Initialization******************************************************************SINIT    START         USING COMMON         LONGA ON         LONGI ON;;  Save O/S supplied values;         PHK                            set data bank         PLB         ORA   #$0100                   save user ID         STA   USER_ID         STX   INLINE+2                 save addr of input line         STY   INLINE;;  Initialize global variables;         STZ   COPYRIGHT                COPYRIGHT = FALSE         STZ   ENDFOUND                 ENDFOUND = FALSE         STZ   PRINTDUPS                PRINTDUPS = FALSE         STZ   PRINTCOUNT               PRINTCOUNT = FALSE         STZ   PRINTUNIQ                PRINTUNIQ = FALSE         STZ   DUPCOUNT                 DUPCOUNT = 0         STZ   DUPCOUNT+2         STZ   LASTLINE+1               LASTLINE = "";;  Read flags.;         LDA   #8                       skip shell identifier         STA   CLDISP         JSR   STOKN                    read the command name         JSR   STOKN                    skip if there is no token on the lineLB1      LDA   TOKEN+1         AND   #$00FF         BEQ   CP1         JSR   SFLAG                    read any flags on the line         BCC   CP1         CMP   #'V'                     if flag = -V then         BNE   LB2         LDA   #TRUE                      COPYRIGHT = TRUE         STA   COPYRIGHT         BRA   LB1LB2      CMP   #'U'                     if flag = -U then         BNE   LB3         LDA   #TRUE                      PRINTUNIQ = TRUE         STA   PRINTUNIQ         BRA   LB1LB3      CMP   #'D'                     if flag = -D then         BNE   LB4         LDA   #TRUE                      PRINTDUPS = TRUE         STA   PRINTDUPS         BRA   LB1LB4      CMP   #'C'                     if flag = -C then         BNE   BADFLAG         LDA   #TRUE                      PRINTCOUNT = TRUE         STA   PRINTCOUNT         BRA   LB1BADFLAG  PUTS  #'Illegal flag',CR=T,ERROUT=T         JSR   SFINI         LDA   #$FFFF         QUIT  QT_DCB;;  Check for conflicting parms;CP1      LDA   PRINTUNIQ                if ((printuniq) && printdups)         BEQ   FL1         LDA   PRINTDUPS         BEQ   FL1         PUTS  #'Conflicting options specified',CR=T,ERROUT=T         LDA   #-1         QUIT  QT_DCB;;  Set up the input file;FL1      JSR   STDIN                    set up standard in         JSR   STOKN         RTS         END******************************************************************  SMAIN - Top level control******************************************************************SMAIN    START         USING COMMON         LONGA ON         LONGI ON         STZ   ST_STOP                  don't stop yet         LDA   COPYRIGHT                if V flag then write copyright         BEQ   LB1         PUTS  #'Unique 1.0',CR=T         PUTS  #'Copyright 1987, Byte Works, Inc.',CR=T         PUTCRLB1      JSR   SNLIN                    while ((NextLine(line) != EOF) &&         BCC   LB5                        (!Stop()))         STOP  ST_DCB         LDA   ST_STOP         BNE   LB6         SHORT I,M                        {if (strcmp(lastline,thisline) == 0)         LDX   LINE+1LB2      LDA   LINE+1,X         CMP   LASTLINE+1,X         BNE   LB3         DBNE  X,LB2         LDA   LINE+1         CMP   LASTLINE+1         BNE   LB3         LONG  I,M                          dupcount++;         INC4  DUPCOUNT         BRA   LB1LB3      LONG  I,M                        else         JSR   SPUTL                        {PutLine(lastline,dupcount);         SHORT I,M                          strcpy(lastline,thisline);         LDX   LINE+1         STX   LASTLINE+1LB4      LDA   LINE+1,X         STA   LASTLINE+1,X         DBNE  X,LB4         LONG  I,M         LDA   #1                           dupcount = 1;         STA   DUPCOUNT         STZ   DUPCOUNT+2                   }         BRA   LB1                        }LB5      JSR   SPUTL                    PutLine(lastline,dupcount);LB6      RTSST_DCB   ANOPST_STOP  DS    2         END******************************************************************  SNLIN - Next Line**  Outputs:*        LINE - line read*        C - clear if at emd of file**  Notes:*        If an end of file is reached, and more files are available,*        the next one is opened.******************************************************************SNLIN    START         USING COMMON         LONGA ON         LONGI ON         LDA   ENDFOUND                 if (endfound) return EOF;         BEQ   LB1         CLC         RTSLB1      STZ   CC                       cc = 0;LB2      JSR   SGETC                    while (((ch = NextCH()) != '\r') &&         AND   #$007F                     (ch != EOF))         STA   CH         BEQ   LB4         CMP   #RETURN         BEQ   LB4         SHORT M                          if (cc < (MAXLINE-1))         LDX   CC         CPX   #MAXLINE         BGE   LB3         STA   LINE+2,X                     line[cc++] = ch;         INC   CCLB3      LONG  M         BRA   LB2LB4      LDA   CH                       if (ch == EOF)         BNE   LB5         LDA   TOKEN+1                    if (strlen(token) != 0)         AND   #$00FF         BEQ   LB4A         JSR   STDIN                        {fopen(infile,token);         JSR   STOKN                        NextToken();         BRA   LB1                          goto lb1;!                                           }LB4A     ANOP                             else         INC   ENDFOUND                     {endfound = TRUE;         LDA   CC                           if (cc == 0) return EOF;         BNE   LB5         CLC         RTSLB5      ANOP                               }         SHORT I,M                      line[cc] = 0;         LDA   CC         STA   LINE+1         LONG  I,M         SEC                            return TRUE;         RTSCC       DS    2CH       DS    2         END******************************************************************  SPUTL - Write a line to standard out**  Inputs:*        LASTLINE - line to write*        DUPCOUNT - number of occurrances******************************************************************SPUTL    START         USING COMMON         LONGA ON         LONGI ON         LDA   DUPCOUNT                 if (dupcount == 0)         ORA   DUPCOUNT+2                 goto LB4;         BEQ   LB4         LDA   PRINTDUPS                if (printdups)         BEQ   LB1         LDA   DUPCOUNT+2                 if (dupcount == 1) goto LB4;         BNE   LB2         LDA   DUPCOUNT         DEC   A         BEQ   LB4LB1      LDA   PRINTUNIQ                if (printuniq)         BEQ   LB2         LDA   DUPCOUNT+2                 if (dupcount > 1) goto LB4;         BNE   LB4         LDA   DUPCOUNT         CMP   #2         BGE   LB4LB2      LDA   PRINTCOUNT                 {if (printcount)         BEQ   LB3         PUT4  DUPCOUNT,#5                  {put4(dupcount,5);         PUTC  #' '                         putchar(' ');LB3      ANOP                               }         PUTS  LASTLINE,CR=T               puts(lastline,0); putchar('\r');LB4      RTS                              }         END******************************************************************  SSERR - Flag a system error**  Inputs:*        A - error number******************************************************************SSERR    START         USING COMMON         LONGA ON         LONGI ON         STA   ER_NUM         PUTCR         ERROR ER_DCB         JSR   SFINI         LDA   ER_NUM         QUIT  QT_DCBER_DCB   ANOPER_NUM   DS    2         END******************************************************************  STDIN - Set up stanadard in**  Inputs:*        TOKEN - file name (if any)**  Outputs:*        FILEHANDLE - if file read, this is the handle******************************************************************STDIN    START         USING COMMON         LONGA ON         LONGI ON         LDA   #TRUE                    assume standard in         STA   STANDARDIN         LDA   TOKEN+1                  if no token, use standard in         AND   #$00FF         BNE   LB1         RTSLB1      STZ   STANDARDIN               not standard in         INIT_WILDCARD IN_DCB           expand wildcards         JCS   ERR         NEXT_WILDCARD IN_DCB         LDA   TOKEN+1         AND   #$00FF         JEQ   ERR         OPEN  OP_DCB                   open the file         JCS   ERR         LDA   OP_REF         STA   RD_REF         STA   CL_REF         STA   EF_REF         GET_EOF EF_DCB                 find its length         JCS   SSERR         MOVE4 EF_EOF,RD_REQ         ADD4  EF_EOF,#2                get space for the file         NEW   HAND,EF_EOF         JCS   SSERR         LOCK  HAND,FILEPTR         JCS   SSERR         ADD4  FILEPTR,RD_REQ,R0        set the null terminator         LDA   #0         STA   [R0]         MOVE4 FILEPTR,RD_BUFF          read the file         READ  RD_DCB         JCS   SSERR         CLOSE CL_DCB                   close the file         JCS   SSERR         RTSERR      PUTS  TOKEN,ERROUT=T         PUTS  #' could not be opened.',CR=T,ERROUT=T         LDA   #$FFFF         QUIT  QT_DCBIN_DCB   ANOP                           INIT_WILDCARD, NEXT_WILDCARD DCB         DC    A4'TOKEN+1'         DC    I'$4000'OP_DCB   ANOP                           OPEN DCBOP_REF   DS    2         DC    A4'TOKEN+1'OP_BUFF  DS    4EF_DCB   ANOP                           GET_EOF DCBEF_REF   DS    2EF_EOF   DS    4RD_DCB   ANOP                           READ DCBRD_REF   DS    2RD_BUFF  DS    4RD_REQ   DS    4         DS    4CL_DCB   ANOP                           CLOSE DCBCL_REF   DS    2HAND     DS    4         END******************************************************************  STOKN - Read a token from the command line**  Outputs:*        TOKEN - token read******************************************************************STOKN    START         USING COMMON         LONGA ON         LONGI ON         STZ   TOKEN+1                  set token to null         LDA   INLINE                   quit if no command line         ORA   INLINE+2         BEQ   LB5         SHORT I,M         LDY   CLDISP                   skip leading blanksLB1      LDA   [INLINE],Y         CMP   #' '         BNE   LB2         INY         BRA   LB1LB2      LDX   #0                       read the tokenLB3      LDA   [INLINE],Y         BEQ   LB4         CMP   #' '         BEQ   LB4         STA   TOKEN+2,X         INY         INX         BPL   LB3LB4      STX   TOKEN+1                  set the string length         STY   CLDISP                   save the new disp         LONG  I,MLB5      RTS         END