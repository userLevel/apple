         KEEP  SORT         MCOPY SO.MACROS******************************************************************  SORT 1.0*  24 February 1987**  Takes input from standard in or, if provided, a file.  The lines*  are sorted and written to standard out.**  SORT [-B] [-C] [-D] [-F] [-I] [-R] [-V] [-W] [file]**       -B      Ignore leading spaces.**       -C      Check to make sure the file is sorted, but do not*               write it - simply write a message indicating if*               it is sorted.**       -D      Sort in dictionary order; i.e. only spaces, characters*               and digits are significant.**       -F      Fold uppercase into lowercase.**       -I      Ignore characters outside $20..$7E**       -R      Reverse the sense of the comparisons.**       -V      Print version, copyright.**       -W      Runs of whitespace compare as equal.**  By Mike Westerfield**  Copyright 1987*  By the Byte Works, Inc.*  All rights reserved******************************************************************SORT     START         JSR   SINIT         JSR   SMAIN         JSR   SFINI         RTL         DC    C'SORT 1.0'         DC    C'Copyright 1987, Byte Works, Inc.'         END******************************************************************  COMMON - Common Data Areas******************************************************************COMMON   DATA;;  Constants;RETURN   EQU   $D                       RETURN key codeLINEFEED EQU   $A                       line feed key codeFALSE    EQU   0                        boolean constantsTRUE     EQU   1;;  Zero Page Equates;R0       GEQU  $0                       general purpose registersR1       GEQU  $1R2       GEQU  $2R3       GEQU  $3R4       GEQU  $4R5       GEQU  $5R6       GEQU  $6R7       GEQU  $7R8       GEQU  $8R9       GEQU  $9R10      GEQU  $AR11      GEQU  $BR12      GEQU  $CR13      GEQU  $DR14      GEQU  $ER15      GEQU  $FINLINE   GEQU  $10                      pointer to input lineCLDISP   GEQU  $14                      disp in INLINEFILEPTR  GEQU  $18                      pointer to start of file being loadedLOCKP    GEQU  $1C                      work area for LOCKFILE1    GEQU  $20                      pointer to start of file 1FLEN1    GEQU  $24                      length of file 1ARR      GEQU  $28                      pointer to array of pointersT        GEQU  $2C                      work variables for SSORTV        GEQU  $30I        GEQU  $34J        GEQU  $38;;  Flagged variables;COPYRIGHT GEQU $40                      display copyright?FLAGB    GEQU  $42                      -B; ignore leading spacesFLAGD    GEQU  $44                      +D; only spaces, chars, digits are sig.FLAGF    GEQU  $46                      +F; fold uppercase to lowerFLAGI    GEQU  $48                      -I; ignore chars outside $20..$7EFLAGR    GEQU  $4A                      -R; reverse sense of comparesFLAGW    GEQU  $4C                      -W; runs of whitespace compare equalANYFLAG  GEQU  $4E                      have any of -B, +D, +F, -I, +N, -W been!                                        set?;;  DCBs;QT_DCB   ANOP                           quit DCB         DC    A4'QT_FLAGS'QT_FLAGS DC    I'0'ER_DCB   ANOP                           system error DCBER_NUM   DS    2;;  Global Variables;ARRHAND  DS    4                        handle of array of pointersLINE     DSTR  ,255                     input line         DS    1NL       DS    4                        number of lines in the fileTOKEN    DSTR  ,255                     command line tokenUSER_ID  DS    2                        User IDCURRS    DS    2                        current sort depth         END******************************************************************  SCOMP - Compare two lines**  Inputs:*        R8 - pointer to first line*        R12 - pointer to second line*        various flag settings**  Outputs:*        status flags set as if a numeric compare were done******************************************************************SCOMP    START         USING COMMON         LONGA ON         LONGI ON;;  If -R (reverse sense of compares) then reverse the pointers;         LDA   FLAGR         BEQ   RF1         LDA   R8         LDX   R12         STA   R12         STX   R8         LDA   R10         LDX   R14         STA   R14         STX   R10RF1      ANOP;;  If any line modifying flags are set, copy the lines to local buffers;         LDA   ANYFLAG                  skip if no flags were set         JEQ   LB0         SHORT I,M                      copy the first line to LINE1         LDY   #0AF1      LDA   [R8],Y         STA   LINE1,Y         CMP   #RETURN         BEQ   AF2         INY         BNE   AF1         LDA   #RETURN         STA   LINE1+255AF2      LDY   #0                       copy the second line to LINE2AF3      LDA   [R12],Y         STA   LINE2,Y         CMP   #RETURN         BEQ   AF4         INY         BNE   AF3         LDA   #RETURN         STA   LINE1+255AF4      LONG  I,M         MOVE4 R8,TR8                   save the originals for tie breaks         MOVE4 R12,TR12         LLA   R8,LINE1                 set the new line addresses         LLA   R12,LINE2;;  If -F, fold uppercase to lowercase;         LDA   FLAGF         BEQ   FF1         LDY   #LINE1         JSR   SFLGF         LDY   #LINE2         JSR   SFLGFFF1      ANOP;;  If -D, ignore all but spaces, chars, digits;         LDA   FLAGD         BEQ   FD1         LDY   #LINE1         JSR   SFLGD         LDY   #LINE2         JSR   SFLGDFD1      ANOP;;  If -I, ignore characters outside $20..$7E;         LDA   FLAGI         BEQ   FI1         LDY   #LINE1         JSR   SFLGI         LDY   #LINE2         JSR   SFLGIFI1      ANOP;;  If -W, runs of whitespace compare equal;         LDA   FLAGW         BEQ   FW1         LDY   #LINE1         JSR   SFLGW         LDY   #LINE2         JSR   SFLGWFW1      ANOP;;  If -B ignore leading white space;         LDA   FLAGB         BEQ   FB1         LDY   #LINE1         JSR   SFLGB         LDY   #LINE2         JSR   SFLGBFB1      ANOP;;  Compare the two lines;         LDA   #1                       indicate that a tie break is possible         STA   TIEBREAKLB0      SHORT M         LDY   #0LB1      LDA   [R12],Y         CMP   #RETURN         BEQ   LB2         LDA   [R8],Y         CMP   #RETURN         BEQ   LB3         CMP   [R12],Y         BNE   RTS         INY         BRA   LB1LB2      CMP   [R8],Y         BEQ   EQUAL         CMP   #RETURN-1         BRA   RTSLB3      CMP   #RETURN+1RTS      LONG  M         RTS         LONGA OFFEQUAL    LDX   TIEBREAK                 break the tie         BEQ   RTS         DEC   TIEBREAK         LONG  M         MOVE4 TR8,R8         MOVE4 TR12,R12         BRA   LB0LN       DS    2                        length of numeric stringLINE1    DS    256                      local line buffersLINE2    DS    256TIEBREAK DS    2                        tie break flagTR8      DS    4                        temp pointer locationsTR12     DS    4         END******************************************************************  SFILE - Read a file**  Inputs:*        A - disp in DP of file record - consists of:*              4 byte pointer to start of file*              4 byte file length*        TOKEN - name of file; 0 if none supplied**  Outputs:*        TOKEN - next token on the command line*        C - set if file read, else clear******************************************************************SFILE    START         USING COMMON         LONGI ON         LONGA ON;;  See if a file name was supplied;         STA   R4                       save disp to file record         LDA   TOKEN+1                  if strlen(token) == 0 then         AND   #$00FF         BNE   LB1;;  No - read from standard in;         LDA   R4         JSR   SRSIN         RTS;;  Yes - read it;LB1      ANOP                           endif         INIT_WILDCARD IN_DCB           expand devices, prefixes and wildcards         JCS   ERR         NEXT_WILDCARD NX_DCB         LDA   FNAME         AND   #$00FF         JEQ   ERR         OPEN  OP_DCB                   open the file         JCS   ERR         LDA   OP_REF         STA   RD_REF         STA   CL_REF         STA   EF_REF         GET_EOF EF_DCB                 find its length         JCS   SSERR         MOVE4 EF_EOF,RD_REQ         ADD4  EF_EOF,#2                get space for the file         NEW   HAND,EF_EOF         JCS   SSERR         LOCK  HAND,FILEPTR         JCS   SSERR         ADD4  FILEPTR,RD_REQ,R0        set the null terminator         LDA   #0         STA   [R0]         MOVE4 FILEPTR,RD_BUFF          read the file         READ  RD_DCB         JCS   SSERR         CLOSE CL_DCB                   close the file         JCS   SSERR         LDX   R4                       set file pointer         LDA   FILEPTR         STA   0,X         LDA   FILEPTR+2         STA   2,X         LDA   RD_REQ                   set file length         STA   4,X         LDA   RD_REQ+2         STA   6,X         JSR   STOKN                    read next token         SEC         RTSERR      PUTS  TOKEN,ERROUT=T         PUTS  #' could not be opened.',CR=T,ERROUT=T         LDA   #$FFFF         QUIT  QT_DCBIN_DCB   ANOP                           INIT_WILDCARD DCB         DC    A4'TOKEN+1'         DC    I'$4000'NX_DCB   ANOP                           NEXT_WILDCARD DCB         DC    A4'FNAME'OP_DCB   ANOP                           OPEN DCBOP_REF   DS    2         DC    A4'FNAME'OP_BUFF  DS    4EF_DCB   ANOP                           GET_EOF DCBEF_REF   DS    2EF_EOF   DS    4RD_DCB   ANOP                           READ DCBRD_REF   DS    2RD_BUFF  DS    4RD_REQ   DS    4         DS    4CL_DCB   ANOP                           CLOSE DCBCL_REF   DS    2HAND     DS    4FNAME    DS    65                       file name buffer         END******************************************************************  SFINI - Program Termination******************************************************************SFINI    START         USING COMMON         LONGA ON         LONGI ON         CLOSE CL_DCB                   close all open files         DISPOSEALL USER_ID             dispose of all memory         RTSCL_DCB   ANOP         DC    I'0'         END******************************************************************  SFLAG - Read a flag from the command line**  Inputs:*        TOKEN - token to check to see if its a flag**  Outputs:*        A - flag character; MSB set for +, clear for -*        C - set if flag found, else clear******************************************************************SFLAG    START         USING COMMON         LONGA ON         LONGI ON         SHORT I,M         LDA   TOKEN+1         CMP   #2         BNE   NOT         LDA   #0         LDX   TOKEN+2         CPX   #'-'         BEQ   MINUS         CPX   #'+'         BEQ   PLUSNOT      CLC         LONG  I,M         RTS         LONGI OFF         LONGA OFFPLUS     LDA   #$80MINUS    ORA   TOKEN+3         LONG  I,M         AND   #$00FF         PHA         JSR   STOKN         PLA         CMP   #'a'         BLT   LB1         CMP   #'z'+1         BLT   LB0         CMP   #'a'+$80         BLT   LB1         CMP   #'z'+$80+1         BGE   LB1LB0      AND   #$00DFLB1      SEC         RTS         END******************************************************************  SFLGB - Handle -B Conversion (ignore leading spaces)**  Inputs:*        Y - disp in data bank to start of line******************************************************************SFLGB    START         USING COMMON         LONGI ON         LONGA ON         TYX                            save disp to start of line         SHORT M                        skip initial whitespace in LINEFB1      LDA   |0,Y         CMP   #RETURN         BEQ   FB3         CMP   #' '         BEQ   FB2         CMP   #9         BLT   FB3         CMP   #$C+1         BGE   FB3FB2      INY         BRA   FB1FB3      LDA   |0,Y                     copy remainder of line to start         STA   |0,X         CMP   #RETURN         BEQ   FB4         INY         INX         BRA   FB3FB4      LONG  M         RTS         END******************************************************************  SFLGD - Handle +D Conversion (only spaces, chars & digits sig.)**  Inputs:*        Y - disp in data bank to start of line******************************************************************SFLGD    START         USING COMMON         LONGI ON         LONGA ON         TYX                            set X to start of line         SHORT MLB1      LDA   |0,Y                     if the character is good, go to LB2;         CMP   #RETURN                   otherwise, go to LB3         BEQ   LB2         CMP   #' '         BEQ   LB2         CMP   #'0'         BLT   LB3         CMP   #'z'+1         BGE   LB3         CMP   #'9'+1         BLT   LB2         CMP   #'A'         BLT   LB3         CMP   #'Z'+1         BLT   LB2         CMP   #'a'         BLT   LB3LB2      STA   |0,X                     character is good - save it         INXLB3      INY                            next character         CMP   #RETURN                  if this was not RETURN, loop         BNE   LB1         LONG  M         RTS         END******************************************************************  SFLGF - Handle +F Conversion (fold uppercase to lower)**  Inputs:*        Y - disp in data bank to start of line******************************************************************SFLGF    START         USING COMMON         LONGI ON         LONGA ON         SHORT MFF1      LDA   |0,Y         CMP   #RETURN         BEQ   FF3         CMP   #'A'         BLT   FF2         CMP   #'Z'+1         BGE   FF2         ORA   #$20         STA   |0,YFF2      INY         BRA   FF1FF3      LONG  M         RTS         END******************************************************************  SFLGI - Handle -I Conversion (ignore chars outside $20..$7E)**  Inputs:*        Y - disp in data bank to start of line******************************************************************SFLGI    START         USING COMMON         LONGI ON         LONGA ON         TYX                            set X to start of line         SHORT MLB1      LDA   |0,Y                     quit if at end of line         CMP   #RETURN         BEQ   LB3         CMP   #$20                     if the character no good, go to LB2         BLT   LB2         CMP   #$7F         BGE   LB2         STA   |0,X                     character is good - save it         INXLB2      INY                            next character         BRA   LB1LB3      STA   |0,X                     save the RETURN         LONG  M         RTS         END******************************************************************  SFLGW - Handle -W Conversion (runs of whitespace compare equal)**  Inputs:*        Y - disp in data bank to start of line******************************************************************SFLGW    START         USING COMMON         LONGI ON         LONGA ON         TYX                            set X to start of line         SHORT MLB1      LDA   |0,Y                     get the character         JSR   WHITE                    if whitespace (but not RETURN) then         BCC   LB3LB2      INY                              read chars until not whitespace         LDA   |0,Y         JSR   WHITE         BCS   LB2         DEY                              prepare to skip this char         LDA   #' '                       save a blankLB3      STA   |0,X                     save the character         INX         INY                            next character         CMP   #RETURN                  if this was not RETURN, loop         BNE   LB1         LONG  M         RTS         LONGA OFFWHITE    CMP   #' '         BEQ   YES         CMP   #RETURN         BEQ   NO         CMP   #9         BLT   NO         CMP   #$C+1         BGE   NOYES      SEC         RTSNO       CLC         RTS         LONGA ON         END******************************************************************  SINIT - Program Initialization******************************************************************SINIT    START         USING COMMON         LONGA ON         LONGI ON;;  Save O/S supplied values;         PHK                            set data bank         PLB         ORA   #$0100                   save user ID         STA   USER_ID         STX   INLINE+2                 save addr of input line         STY   INLINE;;  Initialize global variables;         STZ   COPYRIGHT                COPYRIGHT = FALSE         STZ   FLAGB                    FLAGB = FALSE         STZ   FLAGD                    FLAGD = FALSE         STZ   FLAGF                    FLAGF = FALSE         STZ   FLAGI                    FLAGI = FALSE         STZ   FLAGR                    FLAGR = FALSE         STZ   FLAGW                    FLAGW = FALSE         STZ   ANYFLAG                  ANYFLAG = FALSE;;  Read flags.;         LDA   #8                       skip shell identifier         STA   CLDISP         JSR   STOKN                    read the command name         JSR   STOKN                    skip if there is no token on the lineLB1      LDA   TOKEN+1         AND   #$00FF         JEQ   FL1         JSR   SFLAG                    read any flags on the line         JCC   FL1         CMP   #'V'                     if -V then         BNE   LB2         LDA   #TRUE                      COPYRIGHT = TRUE         STA   COPYRIGHT         BRA   LB1LB2      CMP   #'B'                     else if -B then         BNE   LB3         LDA   #TRUE                      FLAGB = TRUE         STA   FLAGB         STA   ANYFLAG                    ANYFLAG = TRUE         BRA   LB1LB3      CMP   #'D'                     else if -D then         BNE   LB5         LDA   #TRUE                      FLAGD = TRUE         STA   FLAGD         STA   ANYFLAG                    ANYFLAG = TRUE         BRA   LB1LB5      CMP   #'F'                     else if -F then         BNE   LB6         LDA   #TRUE                      FLAGF = TRUE         STA   FLAGF         STA   ANYFLAG                    ANYFLAG = TRUE         BRA   LB1LB6      CMP   #'I'                     else if -I then         BNE   LB7         LDA   #TRUE                      FLAGI = TRUE         STA   FLAGI         STA   ANYFLAG                    ANYFLAG = TRUE         BRA   LB1LB7      CMP   #'R'                     else if -R then         BNE   LB8         LDA   #TRUE                      FLAGR = TRUE         STA   FLAGR         BRA   LB1LB8      CMP   #'W'                     else if -W then         BNE   BADFLAG         LDA   #TRUE                      FLAGW = TRUE         STA   FLAGW         STA   ANYFLAG                    ANYFLAG = TRUE         BRL   LB1BADFLAG  PUTS  #'Illegal flag',CR=T,ERROUT=T         JSR   SFINI         LDA   #$FFFF         QUIT  QT_DCB;;  Set up the input file;FL1      LDA   #FILE1                   set up standard in         JSR   SFILE         BCC   NOTFOUND         LDA   TOKEN+1         AND   #$00FF         BNE   BADPARM         RTSBADPARM  PUTS  #'Too many parameters on command line',CR=T,ERROUT=T         JSR   SFININOTFOUND LDA   #$FFFF         QUIT  QT_DCB         END******************************************************************  SMAIN - Top level control******************************************************************SMAIN    START         USING COMMON         LONGA ON         LONGI ON;;  Print the copyright message;         STZ   ST_STOP                  don't stop yet         LDA   COPYRIGHT                if V flag then write copyright         BEQ   LB1         PUTS  #'Sort 1.0',CR=T         PUTS  #'Copyright 1987, Byte Works, Inc.',CR=T         PUTCR;;  Count the lines in the file;LB1      STZ   NL                       NL = 0;         STZ   NL+2         MOVE4 FILE1,R4         LDA   #RETURN         LDX   FLEN1+2                  for each 64K block do         BEQ   LB3A         LDY   #0                         for Y := $FFFF downto 0 do         SHORT MLB2      CMP   [R4],Y                       if char = RETURN then         BNE   LB3         LONG  M                              NL := NL+1         INC4  NL         SHORT MLB3      ANOP                               endif         DBNE  Y,LB2                      next         INC   R6         DBNE  X,LB2                    nextLB3A     LDY   FLEN1                    for each remaining byte do         BEQ   LB7         DEY         BEQ   LB6LB4      CMP   [R4],Y                     if char = RETURN then         BNE   LB5         LONG  M                            NL := NL+1         INC4  NL         SHORT MLB5      ANOP                             endif         DBNE  Y,LB4                    nextLB6      CMP   [R4]         BNE   LB7         LONG  M         INC4  NLLB7      LONG  M         LDA   NL                       quit if NL = 0         ORA   NL+2         JEQ   RTS;;  Find space for the array of pointers;         LDA   NL                       N := NL*4;         ASL   A         STA   N         LDA   NL+2         ROL   A         ASL   N         ROL   A         STA   N+2         NEW   ARRHAND,N                reserve the space         JCS   SSERR         LOCK  ARRHAND,ARR;;  Set up the array of pointers;         MOVE4 ARR,R0                   R0 = pointer to array element         MOVE4 FILE1,R4                 R4 = pointer to line in file         MOVE4 NL,R8                    R8 = # of lines         LDY   #2         BRA   SA3SA1      ANOP                           repeatSA2      LDA   [R4]                       while [R4] <> RETURN do         AND   #$00FF         CMP   #RETURN         BEQ   SA2A         INC4  R4                           R4 := R4+1;         BRA   SA2                        endwhile;SA2A     INC4  R4                         R4 := R4+1;SA3      LDA   R4                         [R0] := R4;         STA   [R0]         LDA   R6         STA   [R0],Y         ADD4  R0,#4                      R0 := R0+4;         DEC4  R8                         R8 := R8-1;         LDA   R8                       until R8 = 0;         ORA   R8+2         BNE   SA1;;  Sort the file;         MOVE4 ARR,R0         SUB4  NL,#1,R4         ASL   R4         ROL   R6         ASL   R4         ROL   R6         ADD4  R4,ARR         STZ   CURRS                    initialize sort depth counter         JSR   SSORT;;  Print the file;PF1      ANOP                           repeat         LDA   [ARR]                      writeln([[ARR]]);         STA   R0         LDY   #2         LDA   [ARR],Y         STA   R2PF2      LDA   [R0]         AND   #$00FF         CMP   #RETURN         BEQ   PF3         PHA         _WRITECHAR         INC4  R0         BRA   PF2PF3      PUTCR         ADD4  ARR,#4                     ARR := ARR+4;         DEC4  NL                         NL := NL-1;         STOP  ST_DCB                     check for user-stop         LDA   ST_STOP         BNE   RTS         LDA   NL                       until NL = 0;         ORA   NL+2         BNE   PF1RTS      RTSN        DS    4ST_DCB   ANOPST_STOP  DS    2         END******************************************************************  SRSIN - Read a file from standard in**  Inputs:*        A - disp in DP of file record - consists of:*              4 byte pointer to start of file*              4 byte file length**  Outputs:*        C - set if file read, else clear******************************************************************SRSIN    START         USING COMMON         LONGI ON         LONGA ONPTR      EQU   R0                       pointer to current file sectionGROWSIZE EQU   4096                     grow size for file buffer         STA   DPDISP                   dpdisp = A         NEW   HAND,#GROWSIZE           HAND = new(growsize)         JCS   SSERR         LOCK  HAND,PTR                 ptr = lock(HAND)         JCS   SSERR         LLA   SIZE,GROWSIZE            size = growsize         STZ   DISP                     disp = 0         LDA   #' '                     ch = ' '         STA   CHLB1      ANOP                           repeat         LDA   DISP                       if disp = growsize then         CMP   #GROWSIZE         JNE   LB2         ADD4  SIZE,#GROWSIZE               size = size+growsize         UNLOCK HAND                        unlock(hand)         JCS   SSERR         GROW  HAND,SIZE                    grow(hand,size)         JCS   SSERR         LOCK  HAND,PTR                     ptr = lock(hand)+size-growsize         JCS   SSERR         ADD4  PTR,SIZE         SUB4  PTR,#GROWSIZE         STZ   DISP                         disp = 0LB2      ANOP                             endifLB3      LDA   CH                         while (ch <> 0) and         BEQ   LB4         LDA   DISP                         (disp < growsize) do         CMP   #GROWSIZE         BGE   LB4         PHA                                ch = _readchar         PEA   0         LDX   #$220C         JSL   $E10000         PLA         AND   #$00FF         STA   CH         SHORT M                            ptr[disp] = ch         LDY   DISP         STA   [PTR],Y         LONG  M         INC   DISP                         disp = disp+1         BRA   LB3                        endwhileLB4      LDA   CH                       until ch = 0         JNE   LB1         LOCK  HAND,PTR                 DP[dpdisp] = lock(hand)         LDX   DPDISP         LDA   PTR         STA   0,X         LDA   PTR+2         STA   2,X         SUB4  SIZE,#GROWSIZE           DP[dpdisp+4] = size-growsize+disp         ADD4  SIZE,DISP         LDA   SIZE         STA   4,X         LDA   SIZE+2         STA   6,X         SEC         RTSDPDISP   DS    2                        disp into DP to place resultsHAND     DS    4                        handle of fileSIZE     DS    4                        size of file bufferDISP     DS    4                        disp in current section of fileCH       DS    2                        last char read         END******************************************************************  SSERR - Flag a system error**  Inputs:*        A - error number******************************************************************SSERR    START         USING COMMON         LONGA ON         LONGI ON         STA   ER_NUM         PUTCR         ERROR ER_DCB         JSR   SFINI         LDA   ER_NUM         QUIT  QT_DCBER_DCB   ANOPER_NUM   DS    2         END******************************************************************  SSORT - QuickSort**  Inputs:*        L,R - left and right index to sort*        ARR - pointer to unsorted array of pointers**  Outputs:*        ARR - sorted array of pointers******************************************************************SSORT    START         USING COMMON         LONGA ON         LONGI ONL        EQU   R0R        EQU   R4         INC   CURRS         LDA   CURRS         CMP   #89         BLT   LB0         PUTS  #'Quicksort failed due to stack overflow.',CR=T         LDA   #$FFFF         QUIT  QT_DCBLB0      STOP  ST_DCB                   check for user abort         LDA   ST_STOP         BEQ   LB1         JSR   SFINI         LDA   #$FFFF         QUIT  QT_DCBLB1      LDA   R+2                      if (r > l)         CMP   L+2         BNE   LB2         LDA   R         CMP   LLB2      JLE   LB7         SUB4  R,L,T                      {/* the initial swap makes         LSR   T+2                            nearly sorted files work */         LDA   T                          t = (r-l) div 2;         ROR   A         AND   #$FFFC         STA   T         ADD4  T,L         LDY   #2                         swap(arr[r],arr[t]);         LDA   [R]         TAX         LDA   [T]         STA   [R]         TXA         STA   [T]         LDA   [R],Y         TAX         LDA   [T],Y         STA   [R],Y         TXA         STA   [T],Y         LDY   #2                         v = arr[r];         LDA   [R]         STA   V         LDA   [R],Y         STA   V+2         MOVE4 R,J                        j = r;         SUB4  L,#4,I                     i = l-1;LB3      ANOP                             doLB4      ANOP                               {do         ADD4  I,#4                           ++i;         LDY   #2                           while (Compare(arr[i],v) < 0);         LDA   [I]         STA   R8         LDA   [I],Y         STA   R10         MOVE4 V,R12         JSR   SCOMP         BLT   LB4LB5      ANOP                               do         SUB4  J,#4                           --j;         LDY   #2                           while (Compare(arr[j],v) > 0)         LDA   [J]         STA   R8         LDA   [J],Y         STA   R10         MOVE4 V,R12         JSR   SCOMP         BGT   LB5         LDA   [I]                          t = arr[i];         STA   T                            arr[i] = arr[j];         TAX                                arr[j] = t;         LDA   [J]         STA   [I]         TXA         STA   [J]         LDY   #2         LDA   [I],Y         STA   T+2         TAX         LDA   [J],Y         STA   [I],Y         TXA         STA   [J],Y!                                           }         LDA   J+2                        while (j > i);         CMP   I+2         BNE   LB6         LDA   J         CMP   ILB6      JGT   LB3         LDY   #2                         arr[j] = arr[i];         LDA   [I]         STA   [J]         LDA   [I],Y         STA   [J],Y         LDA   [R]                        arr[i] = arr[r];         STA   [I]         LDA   [R],Y         STA   [I],Y         LDA   T                          arr[r] = t;         STA   [R]         LDA   T+2         STA   [R],Y         PH4   I                          SortFile(l,i-1);         PH4   R         SUB4  I,#4,R         JSR   SSORT         PL4   R         PL4   L         ADD4  L,#4                       SortFile(i+1,r);         JSR   SSORTLB7      DEC   CURRS         RTS                              }ST_DCB   ANOPST_STOP  DS    2         END******************************************************************  STOKN - Read a token from the command line**  Outputs:*        TOKEN - token read******************************************************************STOKN    START         USING COMMON         LONGA ON         LONGI ON         STZ   TOKEN+1                  set token to null         LDA   INLINE                   quit if no command line         ORA   INLINE+2         BEQ   LB5         SHORT I,M         LDY   CLDISP                   skip leading blanksLB1      LDA   [INLINE],Y         CMP   #' '         BNE   LB2         INY         BRA   LB1LB2      LDX   #0                       read the tokenLB3      LDA   [INLINE],Y         BEQ   LB4         CMP   #' '         BEQ   LB4         STA   TOKEN+2,X         INY         INX         BPL   LB3LB4      STX   TOKEN+1                  set the string length         STY   CLDISP                   save the new disp         LONG  I,MLB5      RTS         END