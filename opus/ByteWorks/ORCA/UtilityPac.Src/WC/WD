         KEEP  WC         MCOPY WD.MACROS******************************************************************  WC 1.0*  11 January 1986**  Takes input from standard in or, if provided, a file.  The*  number of words, lines and characters are printed.**  WC [-C] [-L] [-V] [-W] [file]**        -C    If coded, characters are counted.  Note that*              if no options are coded, the default is*              -C -L -W, but if any one is coded, all*              desired options must be specified.  Characters*              are any byte that is not a carriage return.**        -L    If coded, lines are counted.  Lines are the number*              of carriage returns found in a file.**        -V    Print version number and copyright.**        -W    If coded, words are counted.  Words are any*              sequence of characters separated by whitespace.**  By Mike Westerfield**  Copyright 1987*  By the Byte Works, Inc.*  All rights reserved******************************************************************WC       START         JSR   SINIT         JSR   SMAIN         JSR   SFINI         LDA   #0         RTL         DC    C'WC 1.0'         DC    C'Copyright 1987, Byte Works, Inc.'         END******************************************************************  COMMON - Common Data Areas******************************************************************COMMON   DATA;;  Constants;RETURN   EQU   $D                       RETURN key codeLINEFEED EQU   $A                       line feed key codeFORMFEED EQU   $C                       form feed key codeTAB      EQU   $9                       TAB key codeFALSE    EQU   0                        boolean constantsTRUE     EQU   1;;  Zero Page Equates;R0       GEQU  $0                       general purpose registersR1       GEQU  $1R2       GEQU  $2R3       GEQU  $3R4       GEQU  $4R5       GEQU  $5R6       GEQU  $6R7       GEQU  $7R8       GEQU  $8R9       GEQU  $9R10      GEQU  $AR11      GEQU  $BR12      GEQU  $CR13      GEQU  $DR14      GEQU  $ER15      GEQU  $FINLINE   GEQU  $10                      pointer to input lineCLDISP   GEQU  $14                      disp in INLINESTANDARDIN GEQU $16                     standard in?FILEPTR  GEQU  $18                      pointer to next characterLOCKP    GEQU  $1C                      work area for LOCKLINECOUNT GEQU $20                      # linesCHARCOUNT GEQU $24                      # charsWORDCOUNT GEQU $28                      # wordsLASTSPACE GEQU $2C                      was last char whitespace?DOLC     GEQU  $2E                      do line counts?DOWC     GEQU  $30                      do word counts?DOCC     GEQU  $32                      do char counts?;;  Flagged variables;COPYRIGHT GEQU $40                      display copyright?;;  DCBs;QT_DCB   ANOP                           quit DCB         DC    A4'QT_FLAGS'QT_FLAGS DC    I'0'ER_DCB   ANOP                           system error DCBER_NUM   DS    2;;  Global Variables;TOKEN    DSTR  ,255                     command line tokenUSER_ID  DS    2                        User ID         END******************************************************************  SFINI - Program Termination******************************************************************SFINI    START         USING COMMON         LONGA ON         LONGI ON         CLOSE CL_DCB                   close all open files         DISPOSEALL USER_ID             dispose of all memory         RTSCL_DCB   ANOP         DC    I'0'         END******************************************************************  SFLAG - Read a flag from the command line**  Inputs:*        TOKEN - token to check to see if its a flag**  Outputs:*        A - flag character; MSB set for +, clear for -*        C - set if flag found, else clear******************************************************************SFLAG    START         USING COMMON         LONGA ON         LONGI ON         SHORT I,M         LDA   TOKEN+1         CMP   #2         BNE   NOT         LDA   #0         LDX   TOKEN+2         CPX   #'-'         BEQ   MINUS         CPX   #'+'         BEQ   PLUSNOT      CLC         LONG  I,M         RTS         LONGI OFF         LONGA OFFPLUS     LDA   #$80MINUS    ORA   TOKEN+3         LONG  I,M         AND   #$00FF         PHA         JSR   STOKN         PLA         CMP   #'a'         BLT   LB1         CMP   #'z'+1         BLT   LB0         CMP   #'a'+$80         BLT   LB1         CMP   #'z'+$80+1         BGE   LB1LB0      AND   #$00DFLB1      SEC         RTS         END******************************************************************  SGETC - Get a character**  Inputs:*        STANDARDIN - standard in?*        FILEPTR - pointer to next char in file (if not stdin)**  Outputs:*        A - character read******************************************************************SGETC    START         USING COMMON         LONGA ON         LONGI ON         LDA   STANDARDIN         BNE   LB1         LDA   [FILEPTR]         AND   #$00FF         INC4  FILEPTR         RTSLB1      PHA         PEA   0         LDX   #$220C         JSL   $E10000         PLA         AND   #$00FF         RTS         END******************************************************************  SINIT - Program Initialization******************************************************************SINIT    START         USING COMMON         LONGA ON         LONGI ON;;  Save O/S supplied values;         PHK                            set data bank         PLB         ORA   #$0100                   save user ID         STA   USER_ID         STX   INLINE+2                 save addr of input line         STY   INLINE;;  Initialize global variables;         STZ   COPYRIGHT                COPYRIGHT = FALSE         STZ   WORDCOUNT                WORDCOUNT = 0         STZ   WORDCOUNT+2         STZ   LINECOUNT                LINECOUNT = 0         STZ   LINECOUNT+2         STZ   CHARCOUNT                CHARCOUNT = 0         STZ   CHARCOUNT+2         LDA   #1                       LASTSPACE = TRUE         STA   LASTSPACE;;  Read flags.;         LDA   #8                       skip shell identifier         STA   CLDISP         JSR   STOKN                    read the command nameLB1      JSR   STOKN                    skip if there is no token on the line         LDA   TOKEN+1         AND   #$00FF         BEQ   FL1         LDA   TOKEN+2                  if the first token is an option then         AND   #$007F         CMP   #'-'         BNE   OP6         STZ   DOLC                       DOLC = FALSE         STZ   DOWC                       DOWC = FALSE         STZ   DOCC                       DOCC = FALSEOP1      JSR   SFLAG                        read the next flag         BCC   FL1         CMP   #'L'                         if flag is -L then         BNE   OP2         LDA   #TRUE                          DOLC = TRUE         STA   DOLC         BRA   OP1                            go do another flagOP2      CMP   #'W'                         else if flag is -W then         BNE   OP3         LDA   #TRUE                          DOWC = TRUE         STA   DOWC         BRA   OP1                            go do another flagOP3      CMP   #'C'                         else if flag is -C then         BNE   OP4         LDA   #TRUE                          DOCC = TRUE         STA   DOCC         BRA   OP1                            go do another flagOP4      CMP   #'V'                         else if flag is -V then         BNE   OP5         LDA   #TRUE                          COPYRIGHT = TRUE         STA   COPYRIGHT         BRA   OP1                            go do another flagOP5      PUTS  #'Illegal flag',CR=T,ERROUT=T         JSR   SFINI         LDA   #$FFFF         QUIT  QT_DCBOP6      LDA   #1         STA   DOLC                       DOLC = TRUE         STA   DOWC                       DOWC = TRUE         STA   DOCC                       DOCC = TRUE;;  Set up the input file;FL1      JSR   STDIN                    set up standard in         JSR   STOKN         RTS         END******************************************************************  SMAIN - Top level control******************************************************************SMAIN    START         USING COMMON         LONGA ON         LONGI ON         STZ   ST_STOP                  don't stop yet         LDA   COPYRIGHT                if V flag then write copyright         BEQ   LB1         PUTS  #'Word Count 1.0',CR=T         PUTS  #'Copyright 1987, Byte Works, Inc.',CR=T         PUTCRLB1      JSR   SGETC                    get next char         AND   #$007F                   if at end of file then         BNE   LB1A         LDA   TOKEN+1                    if no more files then         AND   #$00FF         BEQ   LB5A                         go print results!                                         endif         JSR   STDIN                      open the new file         JSR   STOKN                      fetch next file name         BRA   LB1                        get the first characterLB1A     ANOP                           endif         CMP   #RETURN                  if RETURN then         BNE   LB2         STOP  ST_DCB                     check for user-stop         LDA   ST_STOP         JNE   LB9         INC4  LINECOUNT                  ++LINECOUNT         LDA   #RETURN         BRA   LB3                      elseLB2      INC4  CHARCOUNT                  ++CHARCOUNTLB3      ANOP                           endif         CMP   #' '                     if not isspace then         BEQ   LB4         CMP   #TAB         BEQ   LB4         CMP   #RETURN         BEQ   LB4         CMP   #LINEFEED         BEQ   LB4         CMP   #FORMFEED         BEQ   LB4         LDA   LASTSPACE                  if LASTSPACE then         BEQ   LB5         INC4  WORDCOUNT                    ++WORDCOUNT         STZ   LASTSPACE                    LASTSPACE = FALSE         BRA   LB5                        endifLB4      ANOP                           else         LDA   #1                         LASTSPACE = TRUE         STA   LASTSPACELB5      ANOP                           endif         BRL   LB1LB5A     LDA   DOCC                     if (docc)         BEQ   LB6         PUT4  CHARCOUNT                  put4(CHARCOUNT,0)         PUTS  #' characters.',CR=T       puts(" characters.\r")LB6      ANOP                           endif         LDA   DOWC                     if (dowc)         BEQ   LB7         PUT4  WORDCOUNT                  put4(WORDCOUNT,0)         PUTS  #' words.',CR=T            puts(" words.\r")LB7      ANOP                           endif         LDA   DOLC                     if (dolc)         BEQ   LB8         PUT4  LINECOUNT                  put4(LINECOUNT,0)         PUTS  #' lines.',CR=T            puts(" lines.\r")LB8      ANOP                           endifLB9      RTSST_DCB   ANOPST_STOP  DS    2         END******************************************************************  SSERR - Flag a system error**  Inputs:*        A - error number******************************************************************SSERR    START         USING COMMON         LONGA ON         LONGI ON         STA   ER_NUM         PUTCR         ERROR ER_DCB         JSR   SFINI         LDA   ER_NUM         QUIT  QT_DCBER_DCB   ANOPER_NUM   DS    2         END******************************************************************  STDIN - Set up stanadard in**  Inputs:*        TOKEN - file name (if any)**  Outputs:*        FILEHANDLE - if file read, this is the handle******************************************************************STDIN    START         USING COMMON         LONGA ON         LONGI ON         LDA   #TRUE                    assume standard in         STA   STANDARDIN         LDA   TOKEN+1                  if no token, use standard in         AND   #$00FF         BNE   LB1         RTSLB1      STZ   STANDARDIN               not standard in         INIT_WILDCARD IN_DCB           expand wildcards         JCS   ERR         NEXT_WILDCARD IN_DCB         LDA   TOKEN+1         AND   #$00FF         JEQ   ERR         OPEN  OP_DCB                   open the file         JCS   ERR         LDA   OP_REF         STA   RD_REF         STA   CL_REF         STA   EF_REF         GET_EOF EF_DCB                 find its length         JCS   SSERR         MOVE4 EF_EOF,RD_REQ         ADD4  EF_EOF,#2                get space for the file         NEW   HAND,EF_EOF         JCS   SSERR         LOCK  HAND,FILEPTR         JCS   SSERR         ADD4  FILEPTR,RD_REQ,R0        set the null terminator         LDA   #0         STA   [R0]         MOVE4 FILEPTR,RD_BUFF          read the file         READ  RD_DCB         JCS   SSERR         CLOSE CL_DCB                   close the file         JCS   SSERR         RTSERR      PUTS  TOKEN,ERROUT=T         PUTS  #' could not be opened.',CR=T,ERROUT=T         LDA   #$FFFF         QUIT  QT_DCBIN_DCB   ANOP                           INIT_WILDCARD, NEXT_WILDCARD DCB         DC    A4'TOKEN+1'         DC    I'$4000'OP_DCB   ANOP                           OPEN DCBOP_REF   DS    2         DC    A4'TOKEN+1'OP_BUFF  DS    4EF_DCB   ANOP                           GET_EOF DCBEF_REF   DS    2EF_EOF   DS    4RD_DCB   ANOP                           READ DCBRD_REF   DS    2RD_BUFF  DS    4RD_REQ   DS    4         DS    4CL_DCB   ANOP                           CLOSE DCBCL_REF   DS    2HAND     DS    4         END******************************************************************  STOKN - Read a token from the command line**  Outputs:*        TOKEN - token read******************************************************************STOKN    START         USING COMMON         LONGA ON         LONGI ON         STZ   TOKEN+1                  set token to null         LDA   INLINE                   quit if no command line         ORA   INLINE+2         BEQ   LB5         SHORT I,M         LDY   CLDISP                   skip leading blanksLB1      LDA   [INLINE],Y         CMP   #' '         BNE   LB2         INY         BRA   LB1LB2      LDX   #0                       read the tokenLB3      LDA   [INLINE],Y         BEQ   LB4         CMP   #' '         BEQ   LB4         STA   TOKEN+2,X         INY         INX         BPL   LB3LB4      STX   TOKEN+1                  set the string length         STY   CLDISP                   save the new disp         LONG  I,MLB5      RTS         END