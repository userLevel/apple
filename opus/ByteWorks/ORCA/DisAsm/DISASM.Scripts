*-----------------------------------------------------------------------**									**	Sample scripts for ORCA/Disassembler by Paul Elseth			**	Copyright (c) 1988-90, Byte Works, Inc.				**									**-----------------------------------------------------------------------***		HISTORY*	Vers	Date	Description*	1.0	09/89	First release* 1.1 11/89 Added GS/OS device driver and FST scripts* 1.2 04/90 Updated TOOLTBL, added StartStopRec***  Disassemble_ROMs - This script allows the desktop user to easily*		disassemble the Apple IIGS ROM.*	SCRIPT	Disassemble_ROMs	ROM	ENDS***  TOOL - This script creates a toolset header for the current segment.*	SCRIPT	TOOL	CLEAR	@NUM=[0]-1	IF	@NUM>255,TERROR	ECHO	"Creating toolset header..."	DC	0,I4	COMMENT	0,number of entries	@ADDR=0.TLOOP	IF	@NUM=0,TDONE	@ADDR=@ADDR+4	DC	@ADDR,I4-	@NUM=@NUM-1	GO	TLOOP.TDONE	ECHO	"Toolset header defined.   "	GO	TSTOP.TERROR	ECHO	"Illegal call count - not a toolset!".TSTOP	ENDS***  LOCINFO - Create a QuickDraw II LocInfo structure.*	SCRIPT	LOCINFO	CLEAR	ECHO	"Creating LocInfo structure..."	@A=@ARG! Define the LocInfo record:	DC	@A,I	COMMENT	@A,SCB byte	@A=@A+2	DC	@A,I4	COMMENT	@A,pointer to pixel image	@A=@A+4	DC	@A,I2	COMMENT	@A,width	@A=@A+2	RECT	@A	COMMENT	@A,bounds rect	ENDS***  GRAFPORT - Create a QuickDraw II GrafPort structure.*	SCRIPT	GRAFPORT! Define the LocInfo record:	EXEC	LOCINFO	@ARG! Port info:	ECHO	"Creating GrafPort structure..."	@A=@A+8	RECT	@A	COMMENT	@A,port rect	@A=@A+8	DC	@A,I4	COMMENT	@A,clip rgn	@A=@A+4	DC	@A,I4	COMMENT	@A,vis rgn	@A=@A+4	DC	@A.@A+1F	COMMENT	@A,bkgrd pattern! Pen info:	@A=@A+20	DC	@A.@A+3,I2	COMMENT	@A,pen loc	@A=@A+4	DC	@A.@A+3,I2	COMMENT	@A,pen size	@A=@A+4	DC	@A,I2	COMMENT	@A,pen mode	@A=@A+2	DC	@A.@A+1F	COMMENT	@A,pen pattern	@A=@A+20	DC	@A.@A+7	COMMENT	@A,pen mask	@A=@A+8	DC	@A,I2	COMMENT	@A,pen vis! Font info:	@A=@A+2	COMMENT	@A,font handle	@A=@A+4	DC	@A,I4	COMMENT	@A,font id	@A=@A+4	DC	@A,I2	COMMENT	@A,font flags	@A=@A+2	DC	@A,I2	COMMENT	@A,text size	@A=@A+2	DC	@A,I2	COMMENT	@A,text style	@A=@A+2	DC	@A,I2	COMMENT	@A,text mode	@A=@A+2	DC	@A,I4	COMMENT	@A,space extra	@A=@A+4	DC	@A,I4	COMMENT	@A,char extra! Misc info:	@A=@A+4	DC	@A,I2	COMMENT	@A,foreground color	@A=@A+2	DC	@A,I2	COMMENT	@A,background color	@A=@A+2	DC	@A,I4	COMMENT	@A,pic save handle	@A=@A+4	DC	@A,I4	COMMENT	@A,rgn save handle	@A=@A+4	DC	@A,I4	COMMENT	@A,poly save handle	@A=@A+4	DC	@A,I4	COMMENT	@A,QDProcs ptr	@A=@A+4	DC	@A,I2	COMMENT	@A,arc rotation	@A=@A+2	DC	@A,I4	COMMENT	@A,user field	@A=@A+4	DC	@A,I4	COMMENT	@A,system field	ECHO	"Done!                         "	ENDS***  CDA - Create a CDA header.*	SCRIPT	CDA	CLEAR	ECHO	"Creating CDA header..."	DW	0	@A=([0]&FF)+1	DC	@A,I4	COMMENT	@A,ptr to code start	DC	@A+4,I4	COMMENT	@A+4,ptr to shutdown routine	ECHO	"Done!                 "	ENDS***  NDA - Create an NDA header.*	SCRIPT	NDA	CLEAR	ECHO	"Creating NDA header..."	DC	0,I4	COMMENT	0,open routine	DC	4,I4	COMMENT	4,close routine	DC	8,I4	COMMENT	8,action routine	DC	C,I4	COMMENT	C,init routine	DC	10,I2	COMMENT	10,period	DC	12,I2	COMMENT	12,event mask	@A=14.NDALOOP	IF	([@A]&FF)=0,NDADONE	IF	([@A]&FF)=D,NDADONE	@A=@A+1	GO	NDALOOP.NDADONE	DC	14.@A-1,C	DC	@A	ECHO	"Done!                 "	ENDS***  ALERT - Create an ALERT template.*         SCRIPT  ALERT         CLEAR         ECHO    "Creating ALERT template..."         @A=@ARG         RECT    @A         COMMENT @A,alert rect         @A=@A+8         DC      @A,I2         COMMENT @A,alert ID         @A=@A+2         DC      @A,H         COMMENT @A,first stage byte         @A=@A+1         DC      @A,H         COMMENT @A,second stage byte         @A=@A+1         DC      @A,H         COMMENT @A,third stage byte         @A=@A+1         DC      @A,H         COMMENT @A,fourth stage byte         @A=@A+1.ALERTLOOP         DC      @A,I4         IF      ([@A]|[@A+2])=0,ALERTDONE         COMMENT @A,ptr to item template         IF      [@A+2]=0,ALERTDOITEM         IF      [@A+2]<>@CURSEG,ALERTSKIP.ALERTDOITEM         EXEC    DOITEM [@A].ALERTSKIP         @A=@A+4         GO      ALERTLOOP.ALERTDONE         COMMENT @A,item list terminator         ECHO    "Done!                     "         ENDS***  DIALOG - Create a DIALOG template.*         SCRIPT  DIALOG         CLEAR         ECHO    "Creating DIALOG template..."         @A=@ARG         RECT    @A         COMMENT @A,dtBoundsRect         @A=@A+8         DC      @A,I2         COMMENT @A,dtVisible         @A=@A+2         DC      @A,I4         COMMENT @A,dtRefCon         @A=@A+4         DC      @A,H.DLGLOOP         DC      @A,I4         IF      ([@A]|[@A+2])=0,DLGDONE         COMMENT @A,itemPtr         IF      [@A+2]=0,DLGDOITEM         IF      [@A+2]<>@CURSEG,DLGSKIP.DLGDOITEM         EXEC    DOITEM [@A].DLGSKIP         @A=@A+4         GO      DLGLOOP.DLGDONE         COMMENT @A,terminator         ECHO    "Done!                      "         ENDS***  AITEM - Create an ALERT ITEM template.*         SCRIPT  AITEM         ECHO    "Creating ALERT ITEM template..."         CLEAR         EXEC    DOITEM @ARG         ECHO    "Done!                          "         ENDS         SCRIPT  DOITEM         @Z=@ARG         DC      @Z,I2         COMMENT @Z,item ID         @Z=@Z+2         RECT    @Z         COMMENT @Z,item rect         @Z=@Z+8         DC      @Z,I         COMMENT @Z,type of item         @IT=[@Z]&7FFF         ON @IT-0A,AIBUTTON,AICHECK,AIRADIO,AISCROLL,AIUSER,AITEXT,AITEXT         ON @IT-11,AIEDIT,AIICON,AIPIC,AIUSER,AIUSER,AITEXT         COMMENT @Z,type of item         GO      AICONT.AIBUTTON         COMMENT @Z,std button         GO      AICONT.AICHECK         COMMENT @Z,std check box         GO      AICONT.AIRADIO         COMMENT @Z,std radio button         GO      AICONT.AISCROLL         COMMENT @Z,dialog scroll bar         GO      AICONT.AIUSER         COMMENT @Z,user item         GO      AICONT.AITEXT         COMMENT @Z,static text         GO      AICONT.AIEDIT         COMMENT @Z,editable text         GO      AICONT.AIICON         COMMENT @Z,icon item         GO      AICONT.AIPIC         COMMENT @Z,QuickDraw II picture         GO      AICONT.AICONT         @Z=@Z+2         DC      @Z,I4         COMMENT @Z,item descriptor         @Z=@Z+4         DC      @Z,I2         COMMENT @Z,item value         @Z=@Z+2         DC      @Z,I2         COMMENT @Z,bit flag         @Z=@Z+2         DC      @Z,I4         COMMENT @Z,ptr to color table         ENDS***  WINDOW - Create a NewWindow parameter list.*         SCRIPT  WINDOW         CLEAR         @A=@ARG         ECHO    "Creating Window parm list..."         DC      @A,I2         @A=@A+2         DC      @A,I2         COMMENT @A,frame bits         @A=@A+2         DC      @A,I4         COMMENT @A,title ptr         @A=@A+4         DC      @A,I4         COMMENT @A,refcon         @A=@A+4         RECT    @A         COMMENT @A,zoom rect         @A=@A+8         DC      @A,I4         COMMENT @A,color table ptr         @A=@A+4         DC      @A.@A+3,I2         COMMENT @A,origin         @A=@A+4         DC      @A.@A+3,I2         COMMENT @A,data size         @A=@A+4         DC      @A.@A+3,I2         COMMENT @A,max size         @A=@A+4         DC      @A.@A+3,I2         COMMENT @A,scroll size         @A=@A+4         DC      @A.@A+3,I2         COMMENT @A,page size         @A=@A+4         DC      @A,I4         COMMENT @A,info bar refcon         @A=@A+4         DC      @A,I2         COMMENT @A,info bar hite         @A=@A+2         DC      @A,I4         COMMENT @A,window defproc         @A=@A+4         DC      @A,I4         COMMENT @A,info bar defproc         @A=@A+4         DC      @A,I4         COMMENT @A,content defproc         @A=@A+4         RECT    @A         COMMENT @A,content rect         @A=@A+8         DC      @A,I4         COMMENT @A,starting plane         @A=@A+4         DC      @A,I4         COMMENT @A,storage ptr         ECHO  "Done!                       "         ENDS***  PAINTPARAM - Create a PaintPixels parameter block.*         SCRIPT  PAINTPARAM         CLEAR         @A=@ARG         ECHO    "Creating PaintPixels parm list..."         DC      @A,I4         COMMENT @A,ptr to source locinfo         @A=@A+4         DC      @A,I4         COMMENT @A,ptr to dest locinfo         @A=@A+4         DC      @A,I4         COMMENT @A,ptr to source rect         @A=@A+4         DC      @A,I4         COMMENT @A,ptr to dest point         @A=@A+4         DC      @A,I2         COMMENT @A,mode         @A=@A+2         DC      @A,I4         COMMENT @A,clip rgn handle         ECHO  "Done!                              "         ENDS***  FONT - Create a font definition.*         SCRIPT  FONT         CLEAR         @A=@ARG         ECHO    "Creating Font definition..."         @B=@A+[@A]*2         DC      @A,I2         COMMENT @A,offset to Mac font         @A=@A+2         DC      @A,I2         COMMENT @A,font family number         @A=@A+2         DC      @A,I2         COMMENT @A,font's style         @A=@A+2         DC      @A,I2         COMMENT @A,point size         @A=@A+2         DC      @A,I2         COMMENT @A,version number         @A=@A+2         DC      @A,I2         COMMENT @A,fbr extent         @A=@A+2         IF      @A=@B,FONTSKIP1         DC      @A.@B-1         COMMENT @A,unknown         @A=@B.FONTSKIP1         DC      @A,I2         COMMENT @A,font type         @A=@A+2         DC      @A,I2         COMMENT @A,ASCII code if 1st char         @A=@A+2         DC      @A,I2         COMMENT @A,ASCII code of last char         @N=(([@A]-[@A-2])+3)*2         @A=@A+2         DC      @A,I2         COMMENT @A,max char width         @A=@A+2         DC      @A,I2         COMMENT @A,maximum left kern         @A=@A+2         DC      @A,I2         COMMENT @A,negative of descent         @A=@A+2         DC      @A,I2         COMMENT @A,width of font rect         @A=@A+2         DC      @A,I2         COMMENT @A,hite of font rect         @H=[@A]         @A=@A+2         DC      @A,I2         COMMENT @A,offset to offet/width table         @A=@A+2         DC      @A,I2         COMMENT @A,font ascent         @A=@A+2         DC      @A,I2         COMMENT @A,font descent         @A=@A+2         DC      @A,I2         COMMENT @A,leading         @A=@A+2         DC      @A,I2         COMMENT @A,width of font strike         @B=(([@A]*@H)*2)         @A=@A+2         IF      @B=0,FONTSKIP2         DC      @A.@A+@B-1         COMMENT @A,font strike.FONTSKIP2         @A=@A+@B         DC      @A.@A+@N-1         COMMENT @A,location table         @A=@A+@N         DC      @A.@A+@N-1         COMMENT @A,offset/width table         ECHO  "Done!                        "         ENDS***  TOOLTBL - Create a _LoadTools Tool Table.*         SCRIPT  TOOLTBL         CLEAR         ECHO    "Creating LoadTools parm block..."         @A=@ARG         @N=[@A]         DC      @A,I2         COMMENT @A,number of tools         @A=@A+2         IF    @N=0,LTPDONE.LTPLOOP         DC      @A.@A+3,I2         @T=[@A]         ON @T-01,LTP01,LTP02,LTP03,LTP04,LTP05,LTP06,LTP07,LTP08,LTP09,LTP0A         ON @T-0B,LTP0B,LTP0C,LTPCONT,LTP0E,LTP0F,LTP10,LTP11,LTP12,LTP13,LTP14         ON @T-15,LTP15,LTP16,LTP17,LTPCONT,LTP19,LTP1A,LTP1B,LTP1C,LTP1D,LTP1E         ON @T-1F,UNKSET,LTP20,LTP21,LTP22.UNKSET         COMMENT @A,--Unknown toolset--         GO      LTPCONT.LTP01         COMMENT @A,tool locator         GO      LTPCONT.LTP02         COMMENT @A,memory manager         GO      LTPCONT.LTP03         COMMENT @A,misc tool set         GO      LTPCONT.LTP04         COMMENT @A,quickdraw II         GO      LTPCONT.LTP05         COMMENT @A,desk manager         GO      LTPCONT.LTP06         COMMENT @A,event manager         GO      LTPCONT.LTP07         COMMENT @A,scheduler         GO      LTPCONT.LTP08         COMMENT @A,sound tool set         GO      LTPCONT.LTP09         COMMENT @A,ADB tool set         GO      LTPCONT.LTP0A         COMMENT @A,SANE tool set         GO      LTPCONT.LTP0B         COMMENT @A,int math tool set         GO      LTPCONT.LTP0C         COMMENT @A,text tool set         GO      LTPCONT.LTP0E         COMMENT @A,window manager         GO      LTPCONT.LTP0F         COMMENT @A,menu manager         GO      LTPCONT.LTP10         COMMENT @A,control manager         GO      LTPCONT.LTP11         COMMENT @A,system loader         GO      LTPCONT.LTP12         COMMENT @A,quickdraw II aux         GO      LTPCONT.LTP13         COMMENT @A,print manager         GO      LTPCONT.LTP14         COMMENT @A,lineedit tool set         GO      LTPCONT.LTP15         COMMENT @A,dialog manager         GO      LTPCONT.LTP16         COMMENT @A,scrap manager         GO      LTPCONT.LTP17         COMMENT @A,std file tool set         GO      LTPCONT.LTP19         COMMENT @A,note synth         GO      LTPCONT.LTP1A         COMMENT @A,note sequencer         GO      LTPCONT.LTP1B         COMMENT @A,font manager         GO      LTPCONT.LTP1C         COMMENT @A,list manager         GO      LTPCONT.LTP1D         COMMENT @A,ACE         GO      LTPCONT.LTP1E         COMMENT @A,resource manager         GO      LTPCONT.LTP20         COMMENT @A,MIDI tool set         GO      LTPCONT.LTP21         COMMENT @A,video overlay tool set         GO      LTPCONT.LTP22         COMMENT @A,textedit tool set.LTPCONT         @A=@A+4         @N=@N-1         IF      @N>0,LTPLOOP.LTPDONE         ECHO  "Done!                             "         ENDS***  StartStopRec - Create a _StartUpTools StartStopRec.*         SCRIPT  StartStopRec         CLEAR         ECHO    "Creating StartStopRec..."         @A=@ARG         DC      @A,I2         COMMENT @A,flags         DC      @A+2,I2         COMMENT @A+2,videoMode         DC      @A+4,I2         COMMENT @A+4,resFileID         DC      @A+6,I4         DC      @A+6,dPageHandle         EXEC    ToolTbl @A+0A         ENDS***  EVENTREC - Create a event record.*         SCRIPT  EVENTREC         CLEAR         ECHO    "Creating event record..."         EXEC    EVENTREC2 @ARG         ECHO    "Done!                   "         ENDS         SCRIPT  EVENTREC2         @A=@ARG         DC      @A,I2         COMMENT @A,event code         @A=@A+2         DC      @A,I4         COMMENT @A,event message         @A=@A+4         DC      @A,I4         COMMENT @A,tick count         @A=@A+4         DC      @A.@A+3,I         COMMENT @A,mouse location         @A=@A+4         DC      @A,I2         COMMENT @A,modifiers         ENDS***  TASKREC - Create a Window Manager task record.*        SCRIPT  TASKREC        CLEAR        ECHO    "Creating task record..."        EXEC    TASKREC2        ECHO    "Done!                  "        ENDS        SCRIPT  TASKREC2        EXEC    EVENTREC2 @ARG        @A=@A+2        DC      @A,I4        COMMENT @A,task data        @A=@A+4        DC      @A,I4        COMMENT @A,task mask        ENDS***  TASKRECX - Create a Window Manager extended task record.*        SCRIPT  TASKRECX        CLEAR        ECHO    "Creating extended task record..."        EXEC    TASKREC2        @A=@A+4        DC      @A,I4        COMMENT @A,tick count at last mouse click        @A=@A+4        DC      @A,I2        COMMENT @A,click count (single, double, triple)        @A=@A+2        DC      @A,I4        COMMENT @A,additional taskmaster return data        @A=@A+4        DC      @A,I4        COMMENT @A,additional taskmaster return data        @A=@A+4        DC      @A,I4        COMMENT @A,additional taskmaster return data        @A=@A+4        DC      @A.@A+3,I2        COMMENT @A,location of last mouse click        ECHO    "Done!                           "        ENDS***  CURSOR - Create a cursor image.*         SCRIPT  CURSOR         CLEAR         ECHO    "Creating cursor image..."         @A=@ARG         @H=[@A]         DC      @A,I2         COMMENT @A,cursor height         @A=@A+2         @W=[@A]         DC      @A,I2         COMMENT @A,cursor width         @A=@A+2         @N=@H         COMMENT @A,cursor image.CRSLOOP1         DC      @A.@A+(@W*2)-1         @A=@A+@W*2         @N=@N-1         IF      @N>0,CRSLOOP1         @N=@H         COMMENT @A,cursor mask.CRSLOOP2         DC      @A.@A+(@W*2)-1         @A=@A+@W*2         @N=@N-1         IF      @N>0,CRSLOOP2         COMMENT @A,hot spot         DC      @A.@A+3,I2         ECHO    "Done!                   "         ENDS***  LISTREC - Create a List Record.*         SCRIPT  LISTREC         CLEAR         @A=@ARG         ECHO    "Creating List Record..."         RECT    @A         COMMENT @A,listRect         @A=@A+4         DC      @A,I2         COMMENT @A,listSize         @A=@A+2         DC      @A,I2         COMMENT @A,listView         @A=@A+2         DC      @A,I2         @T=[@A]&0003         ON @T,LRT00,LRT01,LRT10,LRT11         GO      LRTCONT.LRT00         COMMENT @A,listType (Pascal strings/arbitrary selection)         GO      LRTCONT.LRT01         COMMENT @A,listType (C strings/arbitrary selection)         GO      LRTCONT.LRT10         COMMENT @A,listType (Pascal strings/single selection)         GO      LRTCONT.LRT11         COMMENT @A,listType (C strings/single selection).LRTCONT         @A=@A+2         DC      @A,I2         COMMENT @A,listStart         @A=@A+2         DC      @A,I4         COMMENT @A,listCtl         @A=@A+4         DC      @A,I4         COMMENT @A,listDraw         @A=@A+4         DC      @A,I2         COMMENT @A,listMemHeight         @A=@A+2         DC      @A,I2         COMMENT @A,listMemSize         @A=@A+2         DC      @A,I4         COMMENT @A,listPtr         @A=@A+4         DC      @A,I4         COMMENT @A,listRefCon         @A=@A+4         DC      @A,I4         COMMENT @A,listScrollClr         ECHO  "Done!                    "         ENDS***  GSOS_Buffer - GS/OS result buffer*        SCRIPT  GSOS_Result_Buffer        @A=@ARG        DC      @A,I        COMMENT @A,buffer size        DC      @A+2,I        COMMENT @A+2,length        DS      @A+4.@A+[@A]-1        COMMENT @A+4,data        ENDS***  GSOS_BeginSession - BeginSessionGS parameter block*        SCRIPT  GSOS_BeginSession        @A=@ARG        DC      @A,I2        COMMENT @A,pCount        ENDS***  GSOS_BindInt - BindIntGS parameter block*        SCRIPT  GSOS_BindInt        @A=@ARG        DC      @A,I2        COMMENT @A,pCount        DC      @A+2,I2        COMMENT @A+2,interrupt number        DC      @A+4,I2        COMMENT @A+4,vector reference number        DC      @A+6,I4        COMMENT @A+6,interrupt handler        ENDS***  GSOS_ChangePath - ChangePathGS parameter block*        SCRIPT  GSOS_ChangePath        @A=@ARG        DC      @A,I2        COMMENT @A,pCount        DC      @A+2,I4        COMMENT @A+2,pathname        DC      @A+6,I4        COMMENT @A+6,new pathname        ENDS***  GSOS_ClearBackup - ClearBackupGS parameter block*        SCRIPT  GSOS_ClearBackup        @A=@ARG        DC      @A,I2        COMMENT @A,pCount        DC      @A+2,I4        COMMENT @A+2,pathname        ENDS***  GSOS_Close - CloseGS parameter block*        SCRIPT  GSOS_Close        @A=@ARG        DC      @A,I2        COMMENT @A,pCount        DC      @A+2,I2        COMMENT @A+2,refNum        ENDS***  GSOS_Create - CreateGS parameter block*        SCRIPT  GSOS_Create        @A=@ARG        @P=[@A]        DC      @A,I2        COMMENT @A,pCount        @A=@A+2        DC      @A,I4        COMMENT @A,pathname        @A=@A+4        IF      @P<2,doneCreate        DC      @A,I2        COMMENT @A,access        @A=@A+2        IF      @P<3,doneCreate        DC      @A,I2        COMMENT @A,file type        @A=@A+2        IF      @P<4,doneCreate        DC      @A,I4        COMMENT @A,aux type        @A=@A+4        IF      @P<5,doneCreate        DC      @A,I2        COMMENT @A,storage type        @A=@A+2        IF      @P<6,doneCreate        DC      @A,I4        COMMENT @A,eof        @A=@A+4        IF      @P<7,doneCreate        DC      @A,I4        COMMENT @A,resource eof.doneCreate        ENDS***  GSOS_DControl - DControlGS parameter block*        SCRIPT  GSOS_DControl        @A=@ARG        DC      @A,I2        COMMENT @A,pCount        DC      @A+2,I2        COMMENT @A+2,device number        DC      @A+4,I2        COMMENT @A+4,code        DC      @A+6,I4        COMMENT @A+6,list        DC      @A+A,I4        COMMENT @A+A,request count        DC      @A+C,I4        COMMENT @A+C,transfer count        ENDS***  GSOS_Destroy - DestroyGS parameter block*        SCRIPT  GSOS_Destroy        @A=@ARG        DC      @A,I2        COMMENT @A,pCount        DC      @A+2,I4        COMMENT @A+2,pathname        ENDS***  GSOS_DInfo - DInfoGS parameter block*        SCRIPT  GSOS_DInfo        @A=@ARG        @P=[@A]        DC      @A,I2        COMMENT @A,pCount        @A=@A+2        DC      @A,I2        COMMENT @A,device number        @A=@A+2        DC      @A,I4        COMMENT @A,device name        @A=@A+4        IF      @P<3,doneDInfo        DC      @A,I2        COMMENT @A,characteristics        @A=@A+2        IF      @P<4,doneDInfo        DC      @A,I4        COMMENT @A,total blocks        @A=@A+4        IF      @P<5,doneDInfo        DC      @A,I2        COMMENT @A,slot number        @A=@A+2        IF      @P<6,doneDInfo        DC      @A,I2        COMMENT @A,unit number        @A=@A+2        IF      @P<7,doneDInfo        DC      @A,I2        COMMENT @A,version        @A=@A+2        IF      @P<8,doneDInfo        DC      @A,I2        COMMENT @A,device ID        @A=@A+2        IF      @P<9,doneDInfo        DC      @A,I2        COMMENT @A,head link        @A=@A+2        IF      @P<A,doneDInfo        DC      @A,I2        COMMENT @A,forward link        @A=@A+2        IF      @P<B,doneDInfo        DC      @A,I4        COMMENT @A,extended DIB ptr.doneDInfo        ENDS***  GSOS_DReadWrite - DRead/DWriteGS parameter block*        SCRIPT  GSOS_DReadWrite        @A=@ARG        DC      @A,I2        COMMENT @A,pCount        DC      @A+2,I2        COMMENT @A+2,device number        DC      @A+4,I4        COMMENT @A+4,buffer        DC      @A+8,I4        COMMENT @A+8,request count        DC      @A+C,I4        COMMENT @A+C,starting block        DC      @A+10,I2        COMMENT @A+10,block size        DC      @A+12,I4        COMMENT @A+12,transfer count        ENDS***  GSOS_DStatus - DStatusGS parameter block*        SCRIPT  GSOS_DStatus        @A=@ARG        DC      @A,I2        COMMENT @A,pCount        DC      @A+2,I2        COMMENT @A+2,device number        DC      @A+4,I2        COMMENT @A+4,code        DC      @A+6,I4        COMMENT @A+6,list        DC      @A+A,I4        COMMENT @A+A,request count        DC      @A+E,I4        COMMENT @A+E,transfer count        ENDS***  GSOS_EndSession - EndSessionGS parameter block*        SCRIPT  GSOS_EndSession        @A=@ARG        DC      @A,I2        COMMENT @A,pCount        ENDS***  GSOS_EraseDisk - EraseDiskGS parameter block*        SCRIPT  GSOS_EraseDisk        @A=@ARG        @P=[@A]        DC      @A,I2        COMMENT @A,pCount        DC      @A+2,I4        COMMENT @A+2,device name        DC      @A+6,I4        COMMENT @A+6,volume name        DC      @A+A,I2        COMMENT @A+A,file system ID        @A=@A+C        IF      @P<4,doneEraseDisk        DC      @A,I2        COMMENT @A,reqested file system ID.doneEraseDisk        ENDS***  GSOS_ExpandPath - ExpandPathGS parameter block*        SCRIPT  GSOS_ExpandPath        @A=@ARG        @P=[@A]        DC      @A,I2        COMMENT @A,pCount        DC      @A+2,I4        COMMENT @A+2,input path        DC      @A+6,I4        COMMENT @A+6,output path        @A=@A+A        IF      @P<3,doneExpandPath        DC      @A,I2        COMMENT @A,flags.doneExpandPath        ENDS***  GSOS_Flush - FlushGS parameter block*        SCRIPT  GSOS_Flush        @A=@ARG        DC      @A,I2        COMMENT @A,pCount        DC      @A+2,I2        COMMENT @A+2,refNum        ENDS***  GSOS_Format - FormatGS parameter block*        SCRIPT  GSOS_Format        @A=@ARG        @P=[@A]        DC      @A,I2        COMMENT @A,pCount        DC      @A+2,I4        COMMENT @A+2,device name        DC      @A+6,I4        COMMENT @A+6,volume name        DC      @A+A,I2        COMMENT @A+A,file system ID        @A=@A+C        IF      @P<4,doneFormat        DC      @A,I2        COMMENT @A,reqested file system ID.doneFormat        ENDS***  GSOS_GetBootVol - GetBootVolGS parameter block*        SCRIPT  GSOS_GetBootVol        @A=@ARG        DC      @A,I2        COMMENT @A,pCount        DC      @A+2,I4        COMMENT @A+2,data buffer        ENDS***  GSOS_GetDevNumber - GetDevNumberGS parameter block*        SCRIPT  GSOS_GetDevNumber        @A=@ARG        DC      @A,I2        COMMENT @A,pCount        DC      @A+2,I4        COMMENT @A+2,device name        DC      @A+6,I2        COMMENT @A+6,device number        ENDS***  GSOS_GetDirEntry - GetDirEntryGS parameter block*        SCRIPT  GSOS_GetDirEntry        @A=@ARG        @P=[@A]        DC      @A,I2        COMMENT @A,pCount        @A=@A+2        DC      @A,I2        COMMENT @A,refNum        @A=@A+2        DC      @A,I2        COMMENT @A,flags        @A=@A+2        DC      @A,I2        COMMENT @A,base        @A=@A+2        DC      @A,I2        COMMENT @A,displacement        @A=@A+2        DC      @A,I4        COMMENT @A,name buffer        @A=@A+4        IF      @P<6,doneDirEntry        DC      @A,I2        COMMENT @A,entry number        @A=@A+2        IF      @P<7,doneDirEntry        DC      @A,I2        COMMENT @A,file type        @A=@A+2        IF      @P<8,doneDirEntry        DC      @A,I4        COMMENT @A,eof        @A=@A+4        IF      @P<9,doneDirEntry        DC      @A,I4        COMMENT @A,block count        @A=@A+4        IF      @P<A,doneDirEntry        DC      @A,I8        COMMENT @A,create date/time        @A=@A+8        IF      @P<B,doneDirEntry        DC      @A,I8        COMMENT @A,last mod date/time        @A=@A+8        IF      @P<C,doneDirEntry        DC      @A,I2        COMMENT @A,access        @A=@A+2        IF      @P<D,doneDirEntry        DC      @A,I4        COMMENT @A,aux type        @A=@A+4        IF      @P<E,doneDirEntry        DC      @A,I2        COMMENT @A,file system ID        @A=@A+2        IF      @P<F,doneDirEntry        DC      @A,I4        COMMENT @A,option list        @A=@A+4        IF      @P<10,doneDirEntry        DC      @A,I4        COMMENT @A,resource eof        @A=@A+4        IF      @P<11,doneDirEntry        DC      @A,I4        COMMENT @A,resource blocks.doneDirEntry        ENDS***  GSOS_FileInfo - Get/SetFileInfoGS parameter block*        SCRIPT  GSOS_FileInfo        @A=@ARG        @P=[@A]        DC      @A,I2        COMMENT @A,pCount        @A=@A+2        DC      @A,I4        COMMENT @A,pathname        @A=@A+4        DC      @A,I2        COMMENT @A,access        @A=@A+2        IF      @P<3,doneFileInfo        DC      @A,I2        COMMENT @A,file type        @A=@A+2        IF      @P<4,doneFileInfo        DC      @A,I4        COMMENT @A,aux type        @A=@A+4        IF      @P<5,doneFileInfo        DC      @A,I2        COMMENT @A,storage type        @A=@A+2        IF      @P<6,doneFileInfo        DC      @A,I8        COMMENT @A,create date/time        @A=@A+8        IF      @P<7,doneFileInfo        DC      @A,I8        COMMENT @A,last mod date/time        @A=@A+8        IF      @P<8,doneFileInfo        DC      @A,I4        COMMENT @A,option list        @A=@A+4        IF      @P<9,doneFileInfo        DC      @A,I4        COMMENT @A,eof        @A=@A+4        IF      @P<A,doneFileInfo        DC      @A,I4        COMMENT @A,blocks used        @A=@A+4        IF      @P<B,doneFileInfo        DC      @A,I4        COMMENT @A,resource eof        @A=@A+4        IF      @P<C,doneFileInfo        DC      @A,I4        COMMENT @A,resource blocks.doneFileInfo        ENDS***  GSOS_GetFSTInfo - GetFSTInfoGS parameter block*        SCRIPT  GSOS_GetFSTInfo        @A=@ARG        @P=[@A]        DC      @A,I2        COMMENT @A,pCount        @A=@A+2        DC      @A,I2        COMMENT @A,fst number        @A=@A+2        DC      @A,I2        COMMENT @A,file system ID        @A=@A+2        IF      @P<3,doneFSTInfo        DC      @A,I4        COMMENT @A,fst name        @A=@A+4        IF      @P<4,doneFSTInfo        DC      @A,I2        COMMENT @A,version        @A=@A+2        IF      @P<5,doneFSTInfo        DC      @A,I2        COMMENT @A,attributes        @A=@A+2        IF      @P<6,doneFSTInfo        DC      @A,I2        COMMENT @A,block size        @A=@A+2        IF      @P<7,doneFSTInfo        DC      @A,I4        COMMENT @A,max volume size        @A=@A+4        IF      @P<8,doneFSTInfo        DC      @A,I4        COMMENT @A,max file size.doneFSTInfo        ENDS***  GSOS_Level - Get/SetLevelGS parameter block*        SCRIPT  GSOS_Level        @A=@ARG        DC      @A,I2        COMMENT @A,pCount        DC      @A+2,I2        COMMENT @A+2,level        ENDS***  GSOS_GetMarkEOF - GetMark/EOFGS parameter block*        SCRIPT  GSOS_GetMarkEOF        @A=@ARG        DC      @A,I2        COMMENT @A,pCount        DC      @A+2,I2        COMMENT @A+2,refNum        DC      @A+4,I4        COMMENT @A+4,position        ENDS***  GSOS_GetName - GetNameGS parameter block*        SCRIPT  GSOS_GetName        CLEAR        @A=@ARG        DC      @A,I        COMMENT @A,pCount        DC      @A+2,I4        COMMENT @A+2,dataBuffer        ENDS***  GSOS_Prefix - Get/SetPrefixGS parameter block*        SCRIPT  GSOS_Prefix        CLEAR        @A=@ARG        DC      @A,I        COMMENT @A,pCount        DC      @A+2,I2        COMMENT @A+2,prefix number        DC      @A+4,I4        COMMENT @A+4,prefix        ENDS***  GSOS_SysPrefs - Get/SetSysPrefsGS parameter block*        SCRIPT  GSOS_SysPrefs        @A=@ARG        DC      @A,I2        COMMENT @A,pCount        DC      @A+2,I2        COMMENT @A+2,preferences        ENDS***  GSOS_GetVersion - GetVersionGS parameter block*        SCRIPT  GSOS_GetVersion        @A=@ARG        DC      @A,I2        COMMENT @A,pCount        DC      @A+2,I2        COMMENT @A+2,version        ENDS***  GSOS_NewLine - NewLineGS parameter block*        SCRIPT  GSOS_NewLine        @A=@ARG        DC      @A,I2        COMMENT @A,pCount        DC      @A+2,I2        COMMENT @A+2,refNum        DC      @A+4,I2        COMMENT @A+4,enable mask        DC      @A+6,I2        COMMENT @A+6,number of characters        DC      @A+8,I4        COMMENT @A+8,newline table        ENDS***  GSOS_Null - NullGS parameter block*        SCRIPT  GSOS_Null        @A=@ARG        DC      @A,I2        COMMENT @A,pCount        ENDS***  GSOS_Open - OpenGS parameter block*        SCRIPT  GSOS_Open        @A=@ARG        @P=[@A]        DC      @A,I2        COMMENT @A,pCount        @A=@A+2        DC      @A,I2        COMMENT @A,refNum        @A=@A+2        DC      @A,I4        COMMENT @A,pathname        @A=@A+4        IF      @P<3,doneOpen        DC      @A,I2        COMMENT @A,requested access        @A=@A+2        IF      @P<4,doneOpen        DC      @A,I2        COMMENT @A,resource number        @A=@A+2        IF      @P<5,doneOpen        DC      @A,I2        COMMENT @A,access        @A=@A+2        IF      @P<6,doneOpen        DC      @A,I2        COMMENT @A,file type        @A=@A+2        IF      @P<7,doneOpen        DC      @A,I4        COMMENT @A,aux type        @A=@A+4        IF      @P<8,doneOpen        DC      @A,I2        COMMENT @A,storage type        @A=@A+2        IF      @P<9,doneOpen        DC      @A,I8        COMMENT @A,create date/time        @A=@A+8        IF      @P<A,doneOpen        DC      @A,I8        COMMENT @A,last mod date/time        @A=@A+8        IF      @P<B,doneOpen        DC      @A,I4        COMMENT @A,option list        @A=@A+4        IF      @P<C,doneOpen        DC      @A,I4        COMMENT @A,eof        @A=@A+4        IF      @P<D,doneOpen        DC      @A,I4        COMMENT @A,blocks used        @A=@A+4        IF      @P<E,doneOpen        DC      @A,I4        COMMENT @A,resource eof        @A=@A+4        IF      @P<F,doneOpen        DC      @A,I4        COMMENT @A,resource blocks.doneOpen        ENDS***  GSOS_OSShutdown - OSShutdownGS parameter block*        SCRIPT  GSOS_OSShutdown        @A=@ARG        DC      @A,I2        COMMENT @A,pCount        DC      @A+2,I2        COMMENT @A+2,shutdown flag        ENDS***  GSOS_Quit - QuitGS parameter block*        SCRIPT  GSOS_Quit        @A=@ARG        @P=[@A]        DC      @A,I2        COMMENT @A,pCount        @A=@A+2        IF      @P<1,doneQuit        DC      @A,I4        COMMENT @A,pathname        @A=@A+4        IF      @P<2,doneQuit        DC      @A,I4        COMMENT @A,flags.doneQuit        ENDS***  GSOS_SessionStatus - SessionStatusGS parameter block*        SCRIPT  GSOS_SessionStatus        @A=@ARG        DC      @A,I2        COMMENT @A,pCount        DC      @A+2,I2        COMMENT @A+2,status        ENDS***  GSOS_SetMarkEOF - SetMark/EOFGS parameter block*        SCRIPT  GSOS_SetMarkEOF        @A=@ARG        DC      @A,I2        COMMENT @A,pCount        DC      @A+2,I2        COMMENT @A+2,refNum        DC      @A+4,I2        COMMENT @A+4,base        DC      @A+6,I4        COMMENT @A+6,displacement        ENDS***  GSOS_UnbindInt - UnbindIntGS parameter block*        SCRIPT  GSOS_UnbindInt        @A=@ARG        DC      @A,I2        COMMENT @A,pCount        DC      @A+2,I2        COMMENT @A+2,interrupt number        ENDS***  GSOS_Volume - VolumeGS parameter block*        SCRIPT  GSOS_Volume        @A=@ARG        @P=[@A]        DC      @A,I2        COMMENT @A,pCount        @A=@A+2        DC      @A,I4        COMMENT @A,device name        @A=@A+4        DC      @A,I4        COMMENT @A,volume name        @A=@A+4        IF      @P<3,doneVolume        DC      @A,I4        COMMENT @A,total blocks        @A=@A+4        IF      @P<4,doneVolume        DC      @A,I4        COMMENT @A,free blocks        @A=@A+4        IF      @P<5,doneVolume        DC      @A,I2        COMMENT @A,file system ID        @A=@A+2        IF      @P<6,doneVolume        DC      @A,I2        COMMENT @A,block size.doneVolume        ENDS***  P16_ALLOC_INTERRUPT - ALLOC_INTERRUPT parameter block*        SCRIPT  P16_ALLOC_INTERRUPT        @A=@ARG        DC      @A,I2        COMMENT @A,interrupt number        DC      @A+2,I4        COMMENT @A+2,interrupt handler        ENDS***  P16_CHANGE_PATH - CHANGE_PATH parameter block*        SCRIPT  P16_CHANGE_PATH        @A=@ARG        DC      @A,I4        COMMENT @A,pathname        DC      @A+4,I4        COMMENT @A+4,new pathname        ENDS***  P16_CLEAR_BACKUP_BIT - CLEAR_BACKUP_BIT parameter block*        SCRIPT  P16_CLEAR_BACKUP_BIT        @A=@ARG        DC      @A,I4        COMMENT @A,pathname        ENDS***  P16_CLOSE - CLOSE parameter block*        SCRIPT  P16_CLOSE        @A=@ARG        DC      @A,I2        COMMENT @A,file refNum        ENDS***  P16_CREATE - CREATE parameter block*        SCRIPT  P16_CREATE        @A=@ARG        DC      @A,I4        COMMENT @A,pathname        DC      @A+4,I2        COMMENT @A+4,access        DC      @A+6,I2        COMMENT @A+6,file type        DC      @A+8,I4        COMMENT @A+8,aux type        DC      @A+C,I2        COMMENT @A+C,storage type        DC      @A+E,I2        COMMENT @A+E,create date        DC      @A+10,I2        COMMENT @A+10,create time        ENDS***  P16_DEALLOC_INTERRUPT - DEALLOC_INTERRUPT parameter block*        SCRIPT  P16_DEALLOC_INTERRUPT        @A=@ARG        DC      @A,I2        COMMENT @A,interrupt number        ENDS***  P16_DESTROY - DESTROY parameter block*        SCRIPT  P16_DESTROY        @A=@ARG        DC      @A,I4        COMMENT @A,pathname        ENDS***  P16_D_INFO - D_INFO parameter block*        SCRIPT  P16_D_INFO        @A=@ARG        DC      @A,I2        COMMENT @A,device number        DC      @A+2,I4        COMMENT @A+2,device name        ENDS***  P16_ERASE_DISK - ERASE_DISK parameter block*        SCRIPT  P16_ERASE_DISK        @A=@ARG        DC      @A,I4        COMMENT @A,device name        DC      @A+4,I4        COMMENT @A+4,volume name        DC      @A+8,I2        COMMENT @A+8,file system ID        ENDS***  P16_EXPAND_PATH - EXPAND_PATH parameter block*        SCRIPT  P16_EXPAND_PATH        @A=@ARG        DC      @A,I4        COMMENT @A,input pathname        DC      @A+4,I4        COMMENT @A+4,output pathname        DC      @A+8,I2        COMMENT @A+8,flage        ENDS***  P16_FLUSH - FLUSH parameter block*        SCRIPT  P16_FLUSH        @A=@ARG        DC      @A,I2        COMMENT @A,file refNum        ENDS***  P16_FORMAT - FORMAT parameter block*        SCRIPT  P16_FORMAT        @A=@ARG        DC      @A,I4        COMMENT @A,device name        DC      @A+4,I4        COMMENT @A+4,volume name        DC      @A+8,I2        COMMENT @A+8,file system ID        ENDS***  P16_GET_BOOT_VOL - GET_BOOT_VOL parameter block*        SCRIPT  P16_GET_BOOT_VOL        @A=@ARG        DC      @A,I4        COMMENT @A,data buffer        ENDS***  P16_GET_DEV_NUM - GET_DEV_NUM parameter block*        SCRIPT  P16_GET_DEV_NUM        @A=@ARG        DC      @A,I4        COMMENT @A,device name        DC      @A+4,I2        COMMENT @A+4,device number        ENDS***  P16_GET_DIR_ENTRY - GET_DIR_ENTRY parameter block*        SCRIPT  P16_GET_DIR_ENTRY        @A=@ARG        DC      @A,I2        COMMENT @A,refNum        DC      @A+2,I2        COMMENT @A+2,flags        DC      @A+4,I2        COMMENT @A+4,base        DC      @A+6,I2        COMMENT @A+6,displacement        DC      @A+8,I4        COMMENT @A+8,name buffer        DC      @A+C,I2        COMMENT @A+C,entry number        DC      @A+E,I2        COMMENT @A+E,file type        DC      @A+10,I4        COMMENT @A+10,end of file        DC      @A+14,I4        COMMENT @A+14,block count        DC      @A+18,I8        COMMENT @A+18,create date/time        DC      @A+20,I8        COMMENT @A+20,last mod date/time        DC      @A+28,I2        COMMENT @A+28,access        DC      @A+2A,I4        COMMENT @A+2A,aux type        DC      @A+2E,I2        COMMENT @A+2E,file system ID        ENDS***  P16_EOF - GET/SET_EOF parameter block*        SCRIPT  P16_EOF        @A=@ARG        DC      @A,I2        COMMENT @A,file refNum        DC      @A+2,I4        COMMENT @A+2,end of file        ENDS***  P16_FILE_INFO - GET/SET_FILE_INFO parameter block*        SCRIPT  P16_FILE_INFO        @A=@ARG        DC      @A,I4        COMMENT @A,pathname        DC      @A+4,I2        COMMENT @A+4,access        DC      @A+6,I2        COMMENT @A+6,file type        DC      @A+8,I4        COMMENT @A+8,aux type        DC      @A+C,I2        COMMENT @A+C,storage type        DC      @A+E,I2        COMMENT @A+E,create date        DC      @A+10,I2        COMMENT @A+10,create time        DC      @A+12,I2        COMMENT @A+12,last mod date        DC      @A+14,I2        COMMENT @A+14,last mod time        DC      @A+16,I4        COMMENT @A+16,blocks used        ENDS***  P16_GET_LAST_DEV - GET_LAST_DEV parameter block*        SCRIPT  P16_GET_LAST_DEV        @A=@ARG        DC      @A,I2        COMMENT @A,device number        ENDS***  P16_LEVEL - GET/SET_LEVEL parameter block*        SCRIPT  P16_LEVEL        @A=@ARG        DC      @A,I2        COMMENT @A,level        ENDS***  P16_MARK - GET/SET_MARK parameter block*        SCRIPT  P16_MARK        @A=@ARG        DC      @A,I2        COMMENT @A,file refNum        DC      @A+2,I4        COMMENT @A+2,position        ENDS***  P16_GET_NAME - GET_NAME parameter block*        SCRIPT  P16_GET_NAME        @A=@ARG        DC      @A,I4        COMMENT @A,data buffer        ENDS***  P16_PREFIX - GET/SET_PREFIX parameter block*        SCRIPT  P16_PREFIX        @A=@ARG        DC      @A,I2        COMMENT @A,prefix number        DC      @A+2,I4        COMMENT @A+2,prefix        ENDS***  P16_GET_VERSION - GET_VERSION parameter block*        SCRIPT  P16_GET_VERSION        @A=@ARG        DC      @A,I2        COMMENT @A,version        ENDS***  P16_NEWLINE - NEWLINE parameter block*        SCRIPT  P16_NEWLINE        @A=@ARG        DC      @A,I2        COMMENT @A,file refNum        DC      @A+2,I2        COMMENT @A+2,enable mask        DC      @A+4,I2        COMMENT @A+4,newline character        ENDS***  P16_OPEN - OPEN parameter block*        SCRIPT  P16_OPEN        @A=@ARG        DC      @A,I2        COMMENT @A,file refNum        DC      @A+2,I4        COMMENT @A+2,pathname        DC      @A+6,I4        COMMENT @A+6,reserved        ENDS***  P16_QUIT - QUIT parameter block*        SCRIPT  P16_QUIT        @A=@ARG        DC      @A,I4        COMMENT @A,pathname        DC      @A+4,I2        COMMENT @A+4,flags        ENDS***  P16_RW - READ/WRITE parameter block*        SCRIPT  P16_RW        @A=@ARG        DC      @A,I2        COMMENT @A,file refNum        DC      @A+2,I4        COMMENT @A+2,data buffer        DC      @A+6,I4        COMMENT @A+6,request count        DC      @A+A,I4        COMMENT @A+A,transfer count        ENDS***  P16_BLOCK - READ/WRITE_BLOCK parameter block*        SCRIPT  P16_BLOCK        @A=@ARG        DC      @A,I2        COMMENT @A,device number        DC      @A+2,I4        COMMENT @A+2,data buffer        DC      @A+6,I4        COMMENT @A+6,block number        ENDS***  P16_VOLUME - VOLUME parameter block*        SCRIPT  P16_VOLUME        @A=@ARG        DC      @A,I4        COMMENT @A,device name        DC      @A+4,I4        COMMENT @A+4,volume name        DC      @A+8,I4        COMMENT @A+8,total blocks        DC      @A+C,I4        COMMENT @A+C,free blocks        DC      @A+10,I2        COMMENT @A+10,file system ID        ENDS***  DEVICE_HEADER - Create GS/OS device driver header.*        SCRIPT  DEVICE_HEADER        DC      0,I2        COMMENT 0,offset to 1st DIB        DC      2,I2        COMMENT 2,number of devices        @N=[2]        @A=4.deviceHeaderLoop        DC      @A,I2        COMMENT @A,offset to configuration list        @A=@A+2        @N=@N-1        IF      @N>0,deviceHeaderLoop        ENDS***  DIB - Create GS/OS device driver device information block.*        SCRIPT  DIB        @A=@ARG.nextDIB        DC      @A,I4        COMMENT @A,pointer to the next DIB        START   [@A+4],Dispatch        DC      @A+4,I4        COMMENT @A+4,driver entry point        DC      @A+8,I2        COMMENT @A+8,characteristics        DC      @A+A,I4        COMMENT @A+A,block count        DW      @A+E        COMMENT @A+E,device name        IF      ([@A+E]&FF)>1E,fullLengthName        DC      @A+F+([@A+E]&FF).@A+2D,C.fullLengthName        DC      @A+2E,I2        COMMENT @A+2E,slot number        DC      @A+30,I2        COMMENT @A+30,unit number        DC      @A+32,I2        COMMENT @A+32,version        DC      @A+34,I2        COMMENT @A+34,device ID        DC      @A+36,I2        COMMENT @A+36,first linked device        DC      @A+38,I2        COMMENT @A+38,next linked device        DC      @A+3A,I4        COMMENT @A+3A,extended DIB ptr        DC      @A+3E,I2        COMMENT @A+3E,device number        @A=[@A]        IF      @A<>0,nextDIB        ENDS***  FORMAT_OPTIONS - Create GS/OS device driver format options table.*        SCRIPT  FORMAT_OPTIONS        @A=@ARG        DC      @A,I2        COMMENT @A,number of options        DC      @A+2,I2        COMMENT @A+2,number of displayed options        DC      @A+4,I2        COMMENT @A+4,recommended option        DC      @A+6,I2        COMMENT @A+6,current media's option        @N=[@A]        @A=@A+8.nextFOEntry        DC      @A,I2        COMMENT @A,-- option number        DC      @A+2,I2        COMMENT @A+2,linked option        DC      @A+4,I2        COMMENT @A+4,flags        DC      @A+6,I4        COMMENT @A+6,block count        DC      @A+A,I2        COMMENT @A+A,block size (bytes)        DC      @A+C,I2        COMMENT @A+C,interleave factor        DC      @A+E,I2        COMMENT @A+E,media size        @A=@A+10        @N=@N-1        IF      @N>0,nextFOEntry        ENDS***  FST_HEADER - Create GS/OS FST header.*        SCRIPT  FST_HEADER        DC      0.3,C        COMMENT 0,FST signature        DC      4,I4        COMMENT 4,call handler entry point        DC      8,I4        COMMENT 8,GS/OS internal entry point?        DC      C,I2        COMMENT C,file system ID        DC      E,I2        COMMENT E,attributes        DC      10,I2        COMMENT 10,version        DC      12,I2        COMMENT 12,block size        DC      14,I4        COMMENT 14,max volume size (blocks)        DC      18,I4        DC      1C,I4        COMMENT 1C,max file size (bytes)        DC      20,I4        DW      24        COMMENT 24,FST name        DC      2B.4B,C        DC      4C,I2        DW      4E        ENDS***  JumpTableSeg - Disassemble a jump table segment.*        SCRIPT  JumpTableSeg        IF      @SEGKIND=2,.IsJTS        NOTE    "This segment is not a jump table segment."        GO      .Really.IsJTS        DS      0.7        COMMENT 0,unused        @A=8.Loop        IF      (@A+d)>=@SEGLEN,.Done        DC      @A,I2        COMMENT @A,user ID        DC      @A+2,I2        COMMENT @A+2,load-file number        DC      @A+4,I2        COMMENT @A+4,load-segment number        DC      @A+6,I4        COMMENT @A+6,load-segment offset        @A=@A+E        GO      .Loop.Done        IF      @A>=(@SEGLEN-1),.Really        DS      @A.@SEGLEN-1.Really        ENDS