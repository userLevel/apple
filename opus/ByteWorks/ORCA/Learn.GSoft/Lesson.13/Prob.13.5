      REM This sort uses quick sort for large arrays and when there      REM is plenty of memory, then switches to shell sort for      REM smaller arrays or low memory.      CONST SIZE = 50      DIM A(SIZE) AS INTEGER :! array to sort      ! do the trial runs      CALL FILL      CALL SORT(1, (SIZE))      CALL PRINTARRAY      PRINT      END      !----------------------------------------------------------      !      ! Fill - fill an array      !      ! Shared Variables      !    A - array to fill      !    size - number of elements to fill      !      !----------------------------------------------------------      SUB FILL      SHARED A(), SIZE      DIM I AS INTEGER :! loop variable      FOR I = 1 TO SIZE        A(I) = RANDOMVALUE((SIZE))      NEXT      END SUB      !----------------------------------------------------------      !      ! PrintArray - print the array      !      ! Shared Variables      !    A - array to sort      !    size - number of elements to print      !      !----------------------------------------------------------      SUB PRINTARRAY      SHARED A(), SIZE      DIM I AS INTEGER :! loop variable      FOR I = 1 TO SIZE        PRINT A(I), ;      NEXT      END SUB      !----------------------------------------------------------      !      ! RandomValue - Return a random number in the range 1 to max      !      ! Parameters:      !    max - maximum allowed value for the random number      !      ! Returns: Random number in the range 1..max      !      !----------------------------------------------------------      FUNCTION RANDOMVALUE(MAX AS INTEGER ) AS INTEGER      DIM VALUE AS INTEGER :! Random value to return      VALUE = 1 + RND (1) * MAX      IF VALUE = MAX + 1 THEN        VALUE = MAX      END IF      RANDOMVALUE = VALUE      END FUNCTION      !----------------------------------------------------------      !      ! ShellSort - sort elements of an array      !      ! Shared Variables      !    A - array to sort      !      ! Parameters:      !    left, right - range of indecies to sort      !      ! Notes: Assumes there are at least 2 elements to sort.      !      !----------------------------------------------------------      SUB SHELLSORT(LEFT AS INTEGER , RIGHT AS INTEGER )      SHARED A()      DIM I AS INTEGER :! loop variable/array index      DIM SWAP AS BOOLEAN:! was a value swapped?      DIM TEMP AS INTEGER :! temp; used for swapping      IF RIGHT > LEFT THEN        DO          SWAP = FALSE          FOR I = LEFT TO RIGHT - 1            IF A(I) > A(I + 1) THEN              TEMP = A(I)              A(I) = A(I + 1)              A(I + 1) = TEMP              SWAP = TRUE            END IF          NEXT        LOOP WHILE SWAP      END IF      END SUB      !----------------------------------------------------------      !      ! Sort - sort an array      !      ! Shared Variables:      !    A - array to sort      !      ! Parameters:      !    left, right - range of indecies to sort      !      !----------------------------------------------------------      SUB SORT(LEFT AS INTEGER , RIGHT AS INTEGER )      SHARED A()      CONST SHELLSIZE = 15:! use shell sort for partitions smaller than this      CONST MEMLIMIT = 2000:! use shell sort if free memory is less than this      DIM I AS INTEGER , J AS INTEGER :! array indices      DIM PIVOT AS INTEGER :! pivot value      DIM TEMP AS INTEGER :! used to swap values      DIM LOWMEMORY AS INTEGER :! is the memory getting low?      ! see if we're getting low on memory      LOWMEMORY = FRE (0) < MEMLIMIT      ! find the pivot index      I = (LEFT - 1) + (RIGHT - LEFT + 1) / 2      ! put the pivot at the end and save it for compares      PIVOT = A(I)      A(I) = A(RIGHT)      A(RIGHT) = PIVOT      ! set up the start indices      I = LEFT      J = RIGHT - 1      ! partition the array      WHILE I <> J        WHILE A(I) <= PIVOT AND I <> J          I = I + 1        WEND        WHILE A(J) >= PIVOT AND I <> J          J = J - 1        WEND        TEMP = A(I)        A(I) = A(J)        A(J) = TEMP      WEND      ! find the pivot insert point      IF A(I) < PIVOT THEN        I = I + 1      END IF      ! replace the pivot      TEMP = A(I)      A(I) = A(RIGHT)      A(RIGHT) = TEMP      ! sort to the left of the pivot      IF LOWMEMORY OR (I - LEFT) < SHELLSIZE THEN        CALL SHELLSORT(LEFT, I - 1)      ELSE        CALL SORT(LEFT, I - 1)      END IF      ! sort to the right of the pivot      IF LOWMEMORY OR (RIGHT - I) < SHELLSIZE THEN        CALL SHELLSORT(I + 1, RIGHT)      ELSE        CALL SORT(I + 1, RIGHT)      END IF      END SUB