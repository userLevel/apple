      REM XREF      REM      REM This program generates a cross reference of a BASIC program,      REM showing where any symbol is used.      ! line number list      TYPE LINERECORD        NEXTP AS POINTER TO LINERECORD        NUMBER AS INTEGER      END TYPE      TYPE LINEPTR AS POINTER TO LINERECORD      ! symbol table entry      TYPE SYMBOLRECORD        LEFT AS POINTER TO SYMBOLRECORD        RIGHT AS POINTER TO SYMBOLRECORD        SYMBOL AS STRING        LINES AS LINEPTR      END TYPE      TYPE SYMBOLPTR AS POINTER TO SYMBOLRECORD      CONST F = 1:! file number      DIM CH AS STRING :! current character      DIM FNAME AS STRING :! file name      DIM LINE$ AS STRING :! current line      DIM LINEINDEX AS INTEGER :! index into line$      DIM LINENUMBER AS INTEGER :! current line number      DIM SYMBOLS AS SYMBOLPTR:! symbol table      DIM TOKEN AS STRING :! current token      DIM TOKENLINE AS INTEGER :! line number at start of token      ! nothing in the symbol table      SYMBOLS = NIL      ! first line      LINENUMBER = 0      ! get the file name      FNAME = GETFILENAME      IF LEN (FNAME) <> 0 THEN        ! initialize the scanner      OPEN FNAME FOR INPUT AS #F        CH = " "        LINE$ = ""        LINEINDEX = 0        CALL NEXTCH        ! find all of the symbols        DO          CALL NEXTTOKEN          IF LEN (TOKEN) <> 0 THEN            CALL INSERT(SYMBOLS)          END IF        LOOP UNTIL LEN (TOKEN) = 0        ! print the symbols        CALL PRINTSYMBOLS(SYMBOLS)        ! dispose of the symbol table        CALL DISPOSESYMBOLS(SYMBOLS)        ! close the file        CLOSE #F      END IF      END      !----------------------------------------------------------      !      ! DisposeSymbols - dispose of the symbol table      !      ! Parameters:      !    symbols - pointer to the first entry in the symbol table      !      !----------------------------------------------------------      SUB DISPOSESYMBOLS(SYMBOLS AS SYMBOLPTR)      DIM LPTR AS LINEPTR:! work line pointer      IF SYMBOLS <> NIL THEN        ! dispose of the children        CALL DISPOSESYMBOLS(SYMBOLS^.LEFT)        CALL DISPOSESYMBOLS(SYMBOLS^.RIGHT)        ! dispose of the lines        WHILE SYMBOLS^.LINES <> NIL          ! remove the line from the line list          LPTR = SYMBOLS^.LINES          SYMBOLS^.LINES = LPTR^.NEXTP          ! dispose of the line record          DISPOSE (LPTR)        WEND        ! dispose of the symbol record        DISPOSE (SYMBOLS)      END IF      END SUB      !----------------------------------------------------------      !      ! GetFileName - get the name of the file to cross-reference      !      !----------------------------------------------------------      FUNCTION GETFILENAME AS STRING      DIM NAME$ AS STRING :! file name      INPUT "File to cross-reference: ";NAME$      GETFILENAME = NAME$      END FUNCTION      !----------------------------------------------------------      !      ! Insert - insert a symbol use in the symbol table      !      ! Shared Variables:      !    tokenLine - line number at the start of the token      !    token - symbol to insert      !      ! Parameters:      !    symbols - pointer to the first entry in the sybol table      !      !----------------------------------------------------------      SUB INSERT(SYMBOLS AS SYMBOLPTR)      SHARED TOKENLINE, TOKEN      DIM LPTR AS LINEPTR:! new  line number pointer      ! if the symbol does not exist then create a new one      IF SYMBOLS = NIL THEN        ALLOCATE (SYMBOLS)        IF SYMBOLS <> NIL THEN          SYMBOLS^.LEFT = NIL          SYMBOLS^.RIGHT = NIL          SYMBOLS^.SYMBOL = TOKEN          SYMBOLS^.LINES = NIL        END IF      END IF      IF SYMBOLS <> NIL THEN        ! if this is a match then add the line number        IF SYMBOLS^.SYMBOL = TOKEN THEN          ALLOCATE (LPTR)          IF LPTR <> NIL THEN            LPTR^.NEXTP = SYMBOLS^.LINES            SYMBOLS^.LINES = LPTR            LPTR^.NUMBER = TOKENLINE          END IF          ! if it wasn't a match, find the right node        ELSE IF SYMBOLS^.SYMBOL < TOKEN THEN          CALL INSERT(SYMBOLS^.RIGHT)        ELSE          CALL INSERT(SYMBOLS^.LEFT)        END IF      END IF      END SUB      !----------------------------------------------------------      !      ! NextCh - get the next character from the file      !      ! Shared Variables:      !    ch - next character from the file      !    f - file number      !    line$ - current line from the file      !    lineindex - index of the character ch in line$      !    linenumber - current line number      !      ! Notes: The end of a line is reported as a space      !    character.  All characters are converted to uppercase.      !      !----------------------------------------------------------      SUB NEXTCH      SHARED CH, F, LINE$, LINEINDEX, LINENUMBER      ! if we need one, get a new line      IF LINEINDEX > LEN (LINE$) THEN        IF EOF (F) THEN          CH = ""        ELSE          LINE INPUT #F, LINE$          LINEINDEX = 0          LINENUMBER = LINENUMBER + 1        END IF      END IF      ! check for an end of file      IF LEN (CH) <> 0 THEN        LINEINDEX = LINEINDEX + 1        IF LINEINDEX > LEN (LINE$) THEN          ! handle an end of line          CH = " "        ELSE          ! report the next character          CH = MID$ (LINE$, LINEINDEX, 1)          IF CH >= "a" AND CH <= "z" THEN            CH = CHR$ ( ASC (CH) - 32)          END IF        END IF      END IF      END SUB      !----------------------------------------------------------      !      ! NextToken - read a word from the file      !      ! Shared Variables:      !    ch - next character from the file      !    token - string in which to return the token      !      !----------------------------------------------------------      SUB NEXTTOKEN      SHARED CH, TOKEN, TOKENLINE, LINENUMBER      ! initialize the token      TOKEN = ""      ! find the next token      DO        ! record the line number for the token        TOKENLINE = LINENUMBER        IF CH = "!" THEN          ! handle a comment          WHILE ASC (CH) <> 0 AND TOKENLINE = LINENUMBER            CALL NEXTCH          WEND        ELSE IF CH >= "0" AND CH <= "9" THEN          ! handle a number          WHILE CH >= "0" AND CH <= "9"            CALL NEXTCH          WEND          IF CH = "E" OR CH = "D" THEN            CALL NEXTCH            IF CH = "-" OR CH = "+" THEN              CALL NEXTCH            END IF            WHILE CH >= "0" AND CH <= "9"              CALL NEXTCH            WEND          END IF        ELSE IF ASC (CH) = 34 THEN          ! handle a string constant          CALL NEXTCH          WHILE ASC (CH) <> 34 AND TOKENLINE = LINENUMBER            CALL NEXTCH          WEND          IF ASC (CH) = 34 THEN            CALL NEXTCH          END IF        ELSE IF (CH >= "A" AND CH <= "Z") OR (CH = "_") THEN          ! handle a token          WHILE (CH >= "A" AND CH <= "Z") OR (CH >= "0" AND CH <= "9") OR (CH = "_")            TOKEN = TOKEN + CH            CALL NEXTCH          WEND        ELSE IF ASC (CH) <> 0 THEN          ! handle any other character          CALL NEXTCH        END IF      LOOP UNTIL ASC (CH) = 0 OR LEN (TOKEN) <> 0      END SUB      !----------------------------------------------------------      !      ! PrintNumber - recursively print the line numbers      !      ! Parameters:      !    nPtr - pointer to the remainder of the line number list      !      !----------------------------------------------------------      SUB PRINTNUMBER(NPTR AS LINEPTR)      IF NPTR <> NIL THEN        CALL PRINTNUMBER(NPTR^.NEXTP)        PRINT NPTR^.NUMBER;" ";      END IF      END SUB      !----------------------------------------------------------      !      ! PrintSymbols - print the symbols and line numbers      !      ! Parameters:      !    symbols - pointer to the top entry in the symbol table      !      !----------------------------------------------------------      SUB PRINTSYMBOLS(SYMBOLS AS SYMBOLPTR)      IF SYMBOLS <> NIL THEN        CALL PRINTSYMBOLS(SYMBOLS^.LEFT)        PRINT SYMBOLS^.SYMBOL, ;        CALL PRINTNUMBER(SYMBOLS^.LINES)        PRINT        CALL PRINTSYMBOLS(SYMBOLS^.RIGHT)      END IF      END SUB