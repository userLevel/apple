      REM XREF      REM      REM This program generates a cross reference of a BASIC program,      REM showing where any symbol is used.      ! line number list      TYPE LINERECORD        NEXTP AS POINTER TO LINERECORD        NUMBER AS INTEGER      END TYPE      TYPE LINEPTR AS POINTER TO LINERECORD      ! symbol table entry      TYPE SYMBOLRECORD        LEFT AS POINTER TO SYMBOLRECORD        RIGHT AS POINTER TO SYMBOLRECORD        SYMBOL AS STRING        RESERVED AS BOOLEAN        LINES AS LINEPTR      END TYPE      TYPE SYMBOLPTR AS POINTER TO SYMBOLRECORD      CONST F = 1:! file number      DIM CH AS STRING :! current character      DIM FNAME AS STRING :! file name      DIM LINE$ AS STRING :! current line      DIM LINEINDEX AS INTEGER :! index into line$      DIM LINENUMBER AS INTEGER :! current line number      DIM SYMBOLS AS SYMBOLPTR:! symbol table      DIM TOKEN AS STRING :! current token      DIM TOKENLINE AS INTEGER :! line number at start of token      ! nothing in the symbol table      SYMBOLS = NIL      ! first line      LINENUMBER = 0      ! get the file name      FNAME = GETFILENAME      IF LEN (FNAME) <> 0 THEN        ! initialize the scanner      OPEN FNAME FOR INPUT AS #F        CH = " "        LINE$ = ""        LINEINDEX = 0        CALL NEXTCH        ! insert the reserved words        CALL INSERTRESERVEDWORDS        ! find all of the symbols        DO          CALL NEXTTOKEN          IF LEN (TOKEN) <> 0 THEN            CALL INSERT(SYMBOLS)          END IF        LOOP UNTIL LEN (TOKEN) = 0        ! print the symbols        CALL PRINTSYMBOLS(SYMBOLS)        ! dispose of the symbol table        CALL DISPOSESYMBOLS(SYMBOLS)        ! close the file        CLOSE #F      END IF      END      !----------------------------------------------------------      !      ! DisposeSymbols - dispose of the symbol table      !      ! Parameters:      !    symbols - pointer to the first entry in the symbol table      !      !----------------------------------------------------------      SUB DISPOSESYMBOLS(SYMBOLS AS SYMBOLPTR)      DIM LPTR AS LINEPTR:! work line pointer      IF SYMBOLS <> NIL THEN        ! dispose of the children        CALL DISPOSESYMBOLS(SYMBOLS^.LEFT)        CALL DISPOSESYMBOLS(SYMBOLS^.RIGHT)        ! dispose of the lines        WHILE SYMBOLS^.LINES <> NIL          ! remove the line from the line list          LPTR = SYMBOLS^.LINES          SYMBOLS^.LINES = LPTR^.NEXTP          ! dispose of the line record          DISPOSE (LPTR)        WEND        ! dispose of the symbol record        DISPOSE (SYMBOLS)      END IF      END SUB      !----------------------------------------------------------      !      ! GetFileName - get the name of the file to cross-reference      !      !----------------------------------------------------------      FUNCTION GETFILENAME AS STRING      DIM NAME$ AS STRING :! file name      INPUT "File to cross-reference: ";NAME$      GETFILENAME = NAME$      END FUNCTION      !----------------------------------------------------------      !      ! Insert - insert a symbol use in the symbol table      !      ! Shared Variables:      !    tokenLine - line number at the start of the token      !    token - symbol to insert      !      ! Parameters:      !    symbols - pointer to the first entry in the sybol table      !      !----------------------------------------------------------      SUB INSERT(SYMBOLS AS SYMBOLPTR)      SHARED TOKENLINE, TOKEN      DIM LPTR AS LINEPTR:! new  line number pointer      ! if the symbol does not exist then create a new one      IF SYMBOLS = NIL THEN        ALLOCATE (SYMBOLS)        IF SYMBOLS <> NIL THEN          SYMBOLS^.LEFT = NIL          SYMBOLS^.RIGHT = NIL          SYMBOLS^.RESERVED = FALSE          SYMBOLS^.SYMBOL = TOKEN          SYMBOLS^.LINES = NIL        END IF      END IF      IF SYMBOLS <> NIL THEN        ! if this is a match then add the line number        IF SYMBOLS^.SYMBOL = TOKEN THEN          ALLOCATE (LPTR)          IF LPTR <> NIL THEN            LPTR^.NEXTP = SYMBOLS^.LINES            SYMBOLS^.LINES = LPTR            LPTR^.NUMBER = TOKENLINE          END IF          ! if it wasn't a match, find the right node        ELSE IF SYMBOLS^.SYMBOL < TOKEN THEN          CALL INSERT(SYMBOLS^.RIGHT)        ELSE          CALL INSERT(SYMBOLS^.LEFT)        END IF      END IF      END SUB      !----------------------------------------------------------      !      ! InsertReservedWord - insert a reserved word into the      !    symbol table      !      ! Parameters:      !    symbols - top node in the symbol table      !    token - name of the symbol to insert      !      !----------------------------------------------------------      SUB INSERTRESERVEDWORD(SYMBOLS AS SYMBOLPTR, TOKEN AS STRING )      IF SYMBOLS = NIL THEN        ! create the node        ALLOCATE (SYMBOLS)        IF SYMBOLS <> NIL THEN          SYMBOLS^.LEFT = NIL          SYMBOLS^.RIGHT = NIL          SYMBOLS^.RESERVED = TRUE          SYMBOLS^.SYMBOL = TOKEN          SYMBOLS^.LINES = NIL        END IF      ELSE        ! traverse the tree        IF SYMBOLS^.SYMBOL < TOKEN THEN          CALL INSERTRESERVEDWORD(SYMBOLS^.RIGHT, TOKEN)        ELSE          CALL INSERTRESERVEDWORD(SYMBOLS^.LEFT, TOKEN)        END IF      END IF      END SUB      !----------------------------------------------------------      !      ! InsertReservedWords insert the reserved words in the      !    symbol table      !      ! Shared Variables:      !    symbols - top node in the symbol table      !      !----------------------------------------------------------      SUB INSERTRESERVEDWORDS      SHARED SYMBOLS      CALL INSERTRESERVEDWORD(SYMBOLS, "LOG")      CALL INSERTRESERVEDWORD(SYMBOLS, "ELSE")      CALL INSERTRESERVEDWORD(SYMBOLS, "CINT")      CALL INSERTRESERVEDWORD(SYMBOLS, "BINARY")      CALL INSERTRESERVEDWORD(SYMBOLS, "AS")      CALL INSERTRESERVEDWORD(SYMBOLS, "AND")      CALL INSERTRESERVEDWORD(SYMBOLS, "ABS")      CALL INSERTRESERVEDWORD(SYMBOLS, "ALLOCATE")      CALL INSERTRESERVEDWORD(SYMBOLS, "APPEND")      CALL INSERTRESERVEDWORD(SYMBOLS, "AT")      CALL INSERTRESERVEDWORD(SYMBOLS, "ASC")      CALL INSERTRESERVEDWORD(SYMBOLS, "ATN")      CALL INSERTRESERVEDWORD(SYMBOLS, "CASE")      CALL INSERTRESERVEDWORD(SYMBOLS, "BYTE")      CALL INSERTRESERVEDWORD(SYMBOLS, "BREAK")      CALL INSERTRESERVEDWORD(SYMBOLS, "CALL")      CALL INSERTRESERVEDWORD(SYMBOLS, "CHDIR")      CALL INSERTRESERVEDWORD(SYMBOLS, "CDBL")      CALL INSERTRESERVEDWORD(SYMBOLS, "CHR$")      CALL INSERTRESERVEDWORD(SYMBOLS, "CURDIR$")      CALL INSERTRESERVEDWORD(SYMBOLS, "CONT")      CALL INSERTRESERVEDWORD(SYMBOLS, "CLNG")      CALL INSERTRESERVEDWORD(SYMBOLS, "CLEAR")      CALL INSERTRESERVEDWORD(SYMBOLS, "CLOSE")      CALL INSERTRESERVEDWORD(SYMBOLS, "CSRLIN")      CALL INSERTRESERVEDWORD(SYMBOLS, "COS")      CALL INSERTRESERVEDWORD(SYMBOLS, "CSNG")      CALL INSERTRESERVEDWORD(SYMBOLS, "DIR$")      CALL INSERTRESERVEDWORD(SYMBOLS, "DEF")      CALL INSERTRESERVEDWORD(SYMBOLS, "DATA")      CALL INSERTRESERVEDWORD(SYMBOLS, "DIM")      CALL INSERTRESERVEDWORD(SYMBOLS, "DO")      CALL INSERTRESERVEDWORD(SYMBOLS, "DISPOSE")      CALL INSERTRESERVEDWORD(SYMBOLS, "DOUBLE")      CALL INSERTRESERVEDWORD(SYMBOLS, "HOME")      CALL INSERTRESERVEDWORD(SYMBOLS, "FRE")      CALL INSERTRESERVEDWORD(SYMBOLS, "ERROR")      CALL INSERTRESERVEDWORD(SYMBOLS, "ERL")      CALL INSERTRESERVEDWORD(SYMBOLS, "END")      CALL INSERTRESERVEDWORD(SYMBOLS, "EOF")      CALL INSERTRESERVEDWORD(SYMBOLS, "ERR")      CALL INSERTRESERVEDWORD(SYMBOLS, "FN")      CALL INSERTRESERVEDWORD(SYMBOLS, "EXP")      CALL INSERTRESERVEDWORD(SYMBOLS, "FOR")      CALL INSERTRESERVEDWORD(SYMBOLS, "GOTO")      CALL INSERTRESERVEDWORD(SYMBOLS, "GET")      CALL INSERTRESERVEDWORD(SYMBOLS, "FUNCTION")      CALL INSERTRESERVEDWORD(SYMBOLS, "GOSUB")      CALL INSERTRESERVEDWORD(SYMBOLS, "HCOLOR")      CALL INSERTRESERVEDWORD(SYMBOLS, "GSOS")      CALL INSERTRESERVEDWORD(SYMBOLS, "HGR")      CALL INSERTRESERVEDWORD(SYMBOLS, "KILL")      CALL INSERTRESERVEDWORD(SYMBOLS, "INPUT")      CALL INSERTRESERVEDWORD(SYMBOLS, "HTAB")      CALL INSERTRESERVEDWORD(SYMBOLS, "HPLOT")      CALL INSERTRESERVEDWORD(SYMBOLS, "IF")      CALL INSERTRESERVEDWORD(SYMBOLS, "INTEGER")      CALL INSERTRESERVEDWORD(SYMBOLS, "INT")      CALL INSERTRESERVEDWORD(SYMBOLS, "INVERSE")      CALL INSERTRESERVEDWORD(SYMBOLS, "LINE")      CALL INSERTRESERVEDWORD(SYMBOLS, "LEN")      CALL INSERTRESERVEDWORD(SYMBOLS, "LEFT$")      CALL INSERTRESERVEDWORD(SYMBOLS, "LET")      CALL INSERTRESERVEDWORD(SYMBOLS, "LOC")      CALL INSERTRESERVEDWORD(SYMBOLS, "LOADLIBRARY")      CALL INSERTRESERVEDWORD(SYMBOLS, "LOF")      CALL INSERTRESERVEDWORD(SYMBOLS, "SELECT")      CALL INSERTRESERVEDWORD(SYMBOLS, "POINTER")      CALL INSERTRESERVEDWORD(SYMBOLS, "NORMAL")      CALL INSERTRESERVEDWORD(SYMBOLS, "MOUSETEXT")      CALL INSERTRESERVEDWORD(SYMBOLS, "MID$")      CALL INSERTRESERVEDWORD(SYMBOLS, "LONG")      CALL INSERTRESERVEDWORD(SYMBOLS, "LOOP")      CALL INSERTRESERVEDWORD(SYMBOLS, "MKDIR")      CALL INSERTRESERVEDWORD(SYMBOLS, "NEXT")      CALL INSERTRESERVEDWORD(SYMBOLS, "NAME")      CALL INSERTRESERVEDWORD(SYMBOLS, "NIL")      CALL INSERTRESERVEDWORD(SYMBOLS, "OPEN")      CALL INSERTRESERVEDWORD(SYMBOLS, "ON")      CALL INSERTRESERVEDWORD(SYMBOLS, "NOT")      CALL INSERTRESERVEDWORD(SYMBOLS, "ONERR")      CALL INSERTRESERVEDWORD(SYMBOLS, "OUTPUT")      CALL INSERTRESERVEDWORD(SYMBOLS, "OR")      CALL INSERTRESERVEDWORD(SYMBOLS, "PEEK")      CALL INSERTRESERVEDWORD(SYMBOLS, "REM")      CALL INSERTRESERVEDWORD(SYMBOLS, "PRINT")      CALL INSERTRESERVEDWORD(SYMBOLS, "POP")      CALL INSERTRESERVEDWORD(SYMBOLS, "POKE")      CALL INSERTRESERVEDWORD(SYMBOLS, "POS")      CALL INSERTRESERVEDWORD(SYMBOLS, "RANDOM")      CALL INSERTRESERVEDWORD(SYMBOLS, "PUT")      CALL INSERTRESERVEDWORD(SYMBOLS, "READ")      CALL INSERTRESERVEDWORD(SYMBOLS, "RIGHT$")      CALL INSERTRESERVEDWORD(SYMBOLS, "RESUME")      CALL INSERTRESERVEDWORD(SYMBOLS, "RESTORE")      CALL INSERTRESERVEDWORD(SYMBOLS, "RETURN")      CALL INSERTRESERVEDWORD(SYMBOLS, "RND")      CALL INSERTRESERVEDWORD(SYMBOLS, "RMDIR")      CALL INSERTRESERVEDWORD(SYMBOLS, "SEEK")      CALL INSERTRESERVEDWORD(SYMBOLS, "TCP ")      CALL INSERTRESERVEDWORD(SYMBOLS, "SQR")      CALL INSERTRESERVEDWORD(SYMBOLS, "SINGLE")      CALL INSERTRESERVEDWORD(SYMBOLS, "SGN")      CALL INSERTRESERVEDWORD(SYMBOLS, "SETMEM")      CALL INSERTRESERVEDWORD(SYMBOLS, "SIN")      CALL INSERTRESERVEDWORD(SYMBOLS, "SPC")      CALL INSERTRESERVEDWORD(SYMBOLS, "SIZEOF")      CALL INSERTRESERVEDWORD(SYMBOLS, "SPEED")      CALL INSERTRESERVEDWORD(SYMBOLS, "STRING")      CALL INSERTRESERVEDWORD(SYMBOLS, "STOP")      CALL INSERTRESERVEDWORD(SYMBOLS, "STEP")      CALL INSERTRESERVEDWORD(SYMBOLS, "STR$")      CALL INSERTRESERVEDWORD(SYMBOLS, "TAB")      CALL INSERTRESERVEDWORD(SYMBOLS, "SUB")      CALL INSERTRESERVEDWORD(SYMBOLS, "TAN")      CALL INSERTRESERVEDWORD(SYMBOLS, "UNTIL")      CALL INSERTRESERVEDWORD(SYMBOLS, "TOOL")      CALL INSERTRESERVEDWORD(SYMBOLS, "THEN")      CALL INSERTRESERVEDWORD(SYMBOLS, "TEXT")      CALL INSERTRESERVEDWORD(SYMBOLS, "TO")      CALL INSERTRESERVEDWORD(SYMBOLS, "TYPE")      CALL INSERTRESERVEDWORD(SYMBOLS, "TOOLERROR")      CALL INSERTRESERVEDWORD(SYMBOLS, "UNLOADLIBRARY")      CALL INSERTRESERVEDWORD(SYMBOLS, "VTAB")      CALL INSERTRESERVEDWORD(SYMBOLS, "USING")      CALL INSERTRESERVEDWORD(SYMBOLS, "LIBRARY")      CALL INSERTRESERVEDWORD(SYMBOLS, "VAL")      CALL INSERTRESERVEDWORD(SYMBOLS, "WEND")      CALL INSERTRESERVEDWORD(SYMBOLS, "WAIT")      CALL INSERTRESERVEDWORD(SYMBOLS, "WHILE")      END SUB      !----------------------------------------------------------      !      ! NextCh - get the next character from the file      !      ! Shared Variables:      !    ch - next character from the file      !    f - file number      !    line$ - current line from the file      !    lineindex - index of the character ch in line$      !    linenumber - current line number      !      ! Notes: The end of a line is reported as a space      !    character.  All characters are converted to uppercase.      !      !----------------------------------------------------------      SUB NEXTCH      SHARED CH, F, LINE$, LINEINDEX, LINENUMBER      ! if we need one, get a new line      IF LINEINDEX > LEN (LINE$) THEN        IF EOF (F) THEN          CH = ""        ELSE          LINE INPUT #F, LINE$          LINEINDEX = 0          LINENUMBER = LINENUMBER + 1        END IF      END IF      ! check for an end of file      IF LEN (CH) <> 0 THEN        LINEINDEX = LINEINDEX + 1        IF LINEINDEX > LEN (LINE$) THEN          ! handle an end of line          CH = " "        ELSE          ! report the next character          CH = MID$ (LINE$, LINEINDEX, 1)          IF CH >= "a" AND CH <= "z" THEN            CH = CHR$ ( ASC (CH) - 32)          END IF        END IF      END IF      END SUB      !----------------------------------------------------------      !      ! NextToken - read a word from the file      !      ! Shared Variables:      !    ch - next character from the file      !    token - string in which to return the token      !      !----------------------------------------------------------      SUB NEXTTOKEN      SHARED CH, TOKEN, TOKENLINE, LINENUMBER      ! initialize the token      TOKEN = ""      ! find the next token      DO        ! record the line number for the token        TOKENLINE = LINENUMBER        IF CH = "!" THEN          ! handle a comment          WHILE ASC (CH) <> 0 AND TOKENLINE = LINENUMBER            CALL NEXTCH          WEND        ELSE IF CH >= "0" AND CH <= "9" THEN          ! handle a number          WHILE CH >= "0" AND CH <= "9"            CALL NEXTCH          WEND          IF CH = "E" OR CH = "D" THEN            CALL NEXTCH            IF CH = "-" OR CH = "+" THEN              CALL NEXTCH            END IF            WHILE CH >= "0" AND CH <= "9"              CALL NEXTCH            WEND          END IF        ELSE IF ASC (CH) = 34 THEN          ! handle a string constant          CALL NEXTCH          WHILE ASC (CH) <> 34 AND TOKENLINE = LINENUMBER            CALL NEXTCH          WEND          IF ASC (CH) = 34 THEN            CALL NEXTCH          END IF        ELSE IF (CH >= "A" AND CH <= "Z") OR (CH = "_") THEN          ! handle a token          WHILE (CH >= "A" AND CH <= "Z") OR (CH >= "0" AND CH <= "9") OR (CH = "_")            TOKEN = TOKEN + CH            CALL NEXTCH          WEND        ELSE IF ASC (CH) <> 0 THEN          ! handle any other character          CALL NEXTCH        END IF      LOOP UNTIL ASC (CH) = 0 OR LEN (TOKEN) <> 0      END SUB      !----------------------------------------------------------      !      ! PrintNumber - recursively print the line numbers      !      ! Parameters:      !    nPtr - pointer to the remainder of the line number list      !      !----------------------------------------------------------      SUB PRINTNUMBER(NPTR AS LINEPTR)      IF NPTR <> NIL THEN        CALL PRINTNUMBER(NPTR^.NEXTP)        PRINT NPTR^.NUMBER;" ";      END IF      END SUB      !----------------------------------------------------------      !      ! PrintSymbols - print the symbols and line numbers      !      ! Parameters:      !    symbols - pointer to the top entry in the symbol table      !      !----------------------------------------------------------      SUB PRINTSYMBOLS(SYMBOLS AS SYMBOLPTR)      IF SYMBOLS <> NIL THEN        CALL PRINTSYMBOLS(SYMBOLS^.LEFT)        IF NOT SYMBOLS^.RESERVED THEN          PRINT SYMBOLS^.SYMBOL, ;          CALL PRINTNUMBER(SYMBOLS^.LINES)          PRINT        END IF        CALL PRINTSYMBOLS(SYMBOLS^.RIGHT)      END IF      END SUB