(*$Keep 'Frame'*)(*---------------------------------------------------------------*)(*                                                               *)(*  Frame                                                        *)(*                                                               *)(*  This desktop program is about as simple as they get.  It     *)(*  brings up the Apple menu, a file menu with Quit and Close,   *)(*  and an edit menu with Undo, Cut, Copy, Paste and Clear.      *)(*  This is the minimum configuration for supporting desk        *)(*  accessories.  (All of these menus have pre-assigned numbers, *)(*  assigned by Apple.)                                          *)(*                                                               *)(*  The purpose of this rather simple program is to show how     *)(*  simple a desktop program can really be, and to give you a    *)(*  framework to use in developing your own programs.            *)(*                                                               *)(*  Mike Westerfield                                             *)(*  with subroutines from Peter Easdown's Draw                   *)(*                                                               *)(*  Copyright 1987-1990, 1993                                    *)(*  Byte Works, Inc.                                             *)(*                                                               *)(*---------------------------------------------------------------*)MODULE Frame;FROM ASCII IMPORT EOL, nul;FROM Common IMPORT String255, TextArray, TextArrayPtr, SCB, Ref,  ConvStrToPStr;FROM DeskManager IMPORT FixAppleMenu;FROM DialogManager IMPORT AlertTemplate, ItemTemplate, buttonItem, statText,  itemDisable, Alert, StopAlert, NoteAlert, CautionAlert, FilterProc;FROM EventManager IMPORT GetNextEvent, EventBit, EventMask;FROM EZTools IMPORT EZStartDesk, EZEndDesk;FROM M2Lib IMPORT HighWORD, LoWORD;FROM MenuManager IMPORT MenuHandle, NewMenu, InsertMenu,  FixMenuBar, DrawMenuBar, HiliteMenu;FROM QuickDrawII IMPORT SetForeColor, SetBackColor, InitCursor, scbColorMode,  scbStayInGraph;FROM Storage IMPORT ALLOCATE, DEALLOCATE;FROM Strings IMPORT Concat;FROM SYSTEM IMPORT ADR, BYTE;FROM ToolLocator IMPORT StartStopRecordPtr;FROM WindowManager IMPORT TaskRec, TaskMaskBit, TaskMaster, wInSpecial,  wInMenuBar, TaskMask;CONST  AppleAbout   = 257;			(*Menu ID #s*)  FileQuit     = 256;TYPE  alertKind = (norml,stop,note,caution); (*kinds of alerts*)  convert =    RECORD				(*for splitting 4 bytes to 2 bytes*)      CASE :BOOLEAN OF        TRUE:   long: LONGINT;      | FALSE:  lsw,msw: CARDINAL;      END;    END;VAR  done:       BOOLEAN;			(*tells if the program should stop*)  event:      CARDINAL;			(*event #; returned by TaskMaster*)  lastEvent:  TaskRec;			(*last event returned in event loop*)  myTools:    StartStopRecordPtr;  cr:         ARRAY [0..1] OF CHAR;PROCEDURE DoAlert(kind: alertKind; msg: ARRAY OF CHAR);(* handle an alert box                                         *)(*                                                             *)(* parameters:                                                 *)(*     kind - kind of alert                                    *)(*     msg - alert message                                     *) VAR  message:  ItemTemplate;  button:   ItemTemplate;		(*button & message items*)  alertRec: AlertTemplate;		(*alert box*)  junk:     CARDINAL;			(*for receiving NoteAlert value*)  pString:  String255;  okString: String255; BEGIN  ConvStrToPStr(msg, pString);  ConvStrToPStr('OK', okString);  SetForeColor(0);			(*set text colors*)  SetBackColor(15);  WITH alertRec DO			(*initialize alert box*)    WITH atBoundsRect DO      v1 := 50;      h1 := 180;      v2 := 107;      h2 := 480;    END;    atAlertID := 2;    atStage1 := VAL(BYTE, 80H);    atStage2 := VAL(BYTE, 80H);    atStage3 := VAL(BYTE, 80H);    atStage4 := VAL(BYTE, 80H);    tItemList[1] := ADR(button);    tItemList[2] := ADR(message);    tItemList[3] := NIL;  END;  WITH button DO			(*initialize button item*)    itemID := 1;    WITH itemRect DO       v1 := 36;      h1 := 15;      v2 := 0;      h2 := 0;    END;    itemType := buttonItem;    itemDescr := Ref(ADR(okString));    itemValue := 0;    itemFlag := 0;    itemColor := NIL;  END;  WITH message DO			(*initialize message item*)    itemID := 100;    WITH itemRect DO      v1 := 5;      h1 := 100;      v2 := 62;      h2 := 310;    END;    itemType := itemDisable+statText;    itemDescr := Ref(ADR(pString));    itemValue := 0;    itemFlag := 0;    itemColor := NIL;  END;  CASE kind OF				(*handle the alert*)    norml:      junk := Alert(ADR(alertRec), FilterProc(NIL));  | stop:       junk := StopAlert(ADR(alertRec), FilterProc(NIL));  | note:       junk := NoteAlert(ADR(alertRec), FilterProc(NIL));  | caution:    junk := CautionAlert(ADR(alertRec), FilterProc(NIL));  END; (*case*)END DoAlert;PROCEDURE InitMenus;(* Initialize the menu bar. *)VAR  height:   CARDINAL;			(*height of the largest menu*)  menuHand: MenuHandle;			(*for 'handling' windows*)  s:        TextArrayPtr;		(*for builing menus*)BEGIN  NEW(s);				(*create the edit menu*)  Concat('>> Edit \N3', cr, s^);  Concat(s^, '--Undo\N250V*Zz', s^);  Concat(s^, cr, s^);  Concat(s^, '--Cut\N251*Xx', s^);  Concat(s^, cr, s^);  Concat(s^, '--Copy\N252*Cc', s^);  Concat(s^, cr, s^);  Concat(s^, '--Paste\N253*Vv', s^);  Concat(s^, cr, s^);  Concat(s^, '--Clear\N254', s^);  Concat(s^, cr, s^);  Concat(s^, '.', s^);  Concat(s^, cr, s^);  menuHand := NewMenu(s);  InsertMenu(menuHand, 0);  NEW(s);				(*create the file menu*)  Concat('>> File \N2', cr, s^);  Concat(s^, '--Close\N255V', s^);  Concat(s^, cr, s^);  Concat(s^, '--Quit\N256*Qq', s^);  Concat(s^, cr, s^);  Concat(s^, '.', s^);  Concat(s^, cr, s^);  menuHand := NewMenu(s);  InsertMenu(menuHand, 0);  NEW(s);				(*create the apple menu*)  Concat('>>@\XN1', cr, s^);  Concat(s^, '--About...\N257V', s^);  Concat(s^, cr, s^);  Concat(s^, '.', s^);  Concat(s^, cr, s^);  menuHand := NewMenu(s);  InsertMenu(menuHand, 0);  FixAppleMenu(1);			(*add desk accessories*)  height := FixMenuBar();		(*draw the completed menu bar*)  DrawMenuBar;END InitMenus;PROCEDURE HandleMenu(menuNum: CARDINAL);(* Handle a menu selection. *)   PROCEDURE MenuAbout;  (* Show About alert box. *)  VAR    msg: TextArray;  BEGIN    Concat('Frame 1.0', cr, msg);    Concat(msg, 'Copyright 1988-1993', msg);    Concat(msg, cr, msg);    Concat(msg, 'Byte Works, Inc.', msg);    Concat(msg, cr, msg);    Concat(msg, cr, msg);    Concat(msg, 'by Mike Westerfield', msg);    DoAlert(note, msg);  END MenuAbout;BEGIN  CASE menuNum OF			(*go handle the menu*)    AppleAbout: MenuAbout;  | FileQuit:   done := TRUE;    ELSE  END; (*CASE*)  HiliteMenu(FALSE, HighWORD(VAL(LONGINT, lastEvent.wmTaskData)));END HandleMenu;CONST  eventMask = EventMask{ebDown, ebUp, ebKeyDown, ebAutoKey, ebUpdate,                         ebActivate, ebSwitch, ebDeskAcc};BEGIN  cr[0] := EOL;  cr[1] := nul;  myTools := EZStartDesk(SCB{scbColorMode, scbStayInGraph});  InitMenus;				(*set up the menu bar*)  lastEvent.wmTaskMask := TaskMask{tmMenuKey, tmUpdate, tmFindW, tmMenuSel,                                    tmOpenDA, tmSysClick, tmDragW, tmContent,                                    tmClose, tmZoom, tmGrow, tmScroll,                                     tmSpecial, tmCRedraw, tmInactive, tmInfo,                                    tmContentControls};  InitCursor;				(*show the cursor*)  done := FALSE;			(*MAIN EVENT LOOP*)  REPEAT    event := TaskMaster(eventMask, lastEvent);    CASE event OF			(*handle the events we need to*)      wInSpecial,      wInMenuBar: HandleMenu(LoWORD(VAL(LONGINT, lastEvent.wmTaskData)));      ELSE    END; (*CASE*)  UNTIL done;  EZEndDesk(myTools);END Frame.