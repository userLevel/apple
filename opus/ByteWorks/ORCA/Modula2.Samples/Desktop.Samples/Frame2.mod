(*$Keep 'Frame2'*)(*---------------------------------------------------------------*)(*                                                               *)(*  Frame                                                        *)(*                                                               *)(*  This desktop program is about as simple as they get.  It     *)(*  brings up the Apple menu, a file menu with Quit and Close,   *)(*  and an edit menu with Undo, Cut, Copy, Paste and Clear.      *)(*  This is the minimum configuration for supporting desk        *)(*  accessories.  (All of these menus have pre-assigned numbers, *)(*  assigned by Apple.)                                          *)(*                                                               *)(*  The purpose of this rather simple program is to show how     *)(*  simple a desktop program can really be, and to give you a    *)(*  framework to use in developing your own programs.            *)(*                                                               *)(*  Mike Westerfield                                             *)(*  with subroutines from Peter Easdown's Draw                   *)(*                                                               *)(*  Copyright 1987-1990, 1993                                    *)(*  Byte Works, Inc.                                             *)(*                                                               *)(*---------------------------------------------------------------*)MODULE Frame;FROM ASCII IMPORT EOL;FROM Common IMPORT SCB;FROM DeskManager IMPORT FixAppleMenu;FROM EventManager IMPORT GetNextEvent, EventBit, EventMask;FROM EZTools IMPORT EZStartDesk, EZEndDesk;FROM M2Lib IMPORT HighWORD, LoWORD;FROM MenuManager IMPORT SetSysBar, FixMenuBar, DrawMenuBar,  HiliteMenu, NewMenuBar2, SetMenuBar, MenuBarHandle;FROM QuickDrawII IMPORT InitCursor, scbColorMode, scbStayInGraph, GrafPortPtr;FROM Storage IMPORT ALLOCATE, DEALLOCATE;FROM ToolLocator IMPORT StartStopRecordPtr;FROM WindowManager IMPORT TaskRec, TaskMaskBit, TaskMaster, wInSpecial,  wInMenuBar, TaskMask, AlertWindow;CONST  AppleAbout   = 257;			(*Menu ID #s*)  FileQuit     = 256;TYPE  alertKind = (norml,stop,note,caution); (*kinds of alerts*)  convert =    RECORD				(*for splitting 4 bytes to 2 bytes*)      CASE :BOOLEAN OF        TRUE:   long: LONGINT;      | FALSE:  lsw,msw: CARDINAL;      END;    END;   lReference = LONGINT; (* debug *)VAR  done:       BOOLEAN;			(*tells if the program should stop*)  event:      CARDINAL;			(*event #; returned by TaskMaster*)  lastEvent:  TaskRec;			(*last event returned in event loop*)  myTools:    StartStopRecordPtr;PROCEDURE InitMenus;(* Initialize the menu bar. *)PROCEDURE NewMenuBar3(refDescriptor:  CARDINAL; 	(* debug *)                      menuBarTRef:    lReference;                      theWindow:      GrafPortPtr): MenuBarHandle; TOOL 430FH;CONST  menuID = 1;				(*menu bar resource ID*)VAR  height: CARDINAL;			(*height of the largest menu*)BEGIN  SetSysBar(NewMenuBar3(2, lReference(menuID), NIL)); (*create the menu bar*)  SetMenuBar(NIL);  FixAppleMenu(1);			(*add desk accessories*)  height := FixMenuBar();		(*draw the completed menu bar*)  DrawMenuBar;END InitMenus;PROCEDURE HandleMenu(menuNum: CARDINAL);(* Handle a menu selection. *)   PROCEDURE MenuAbout;  (* Show About alert box. *)  CONST    alertID = 1;			(*alert resource ID*)  VAR    button: CARDINAL;			(*button pushed*)  BEGIN  button := AlertWindow(5, NIL, alertID);  END MenuAbout;BEGIN  CASE menuNum OF			(*go handle the menu*)    AppleAbout: MenuAbout;  | FileQuit:   done := TRUE;    ELSE  END; (*CASE*)  HiliteMenu(FALSE, HighWORD(VAL(LONGINT, lastEvent.wmTaskData)));END HandleMenu;CONST  eventMask = EventMask{ebDown, ebUp, ebKeyDown, ebAutoKey, ebUpdate,                          ebActivate, ebSwitch, ebDeskAcc};BEGIN  myTools := EZStartDesk(SCB{scbColorMode, scbStayInGraph});  InitMenus;				(*set up the menu bar*)  lastEvent.wmTaskMask := TaskMask{tmMenuKey, tmUpdate, tmFindW, tmMenuSel,                                    tmOpenDA, tmSysClick, tmDragW, tmContent,                                    tmClose, tmZoom, tmGrow, tmScroll,                                     tmSpecial, tmCRedraw, tmInactive, tmInfo,                                    tmContentControls};  InitCursor;				(*show the cursor*)  done := FALSE;			(*MAIN EVENT LOOP*)  REPEAT    event := TaskMaster(eventMask, lastEvent);    CASE event OF			(*handle the events we need to*)      wInSpecial,      wInMenuBar: HandleMenu(LoWORD(VAL(LONGINT, lastEvent.wmTaskData)));      ELSE    END; (*CASE*)  UNTIL done;  EZEndDesk(myTools);END Frame.