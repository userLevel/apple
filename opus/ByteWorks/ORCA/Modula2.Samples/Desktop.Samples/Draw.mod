(*$Keep 'Draw'*)(*---------------------------------------------------------------*)(*                                                               *)(*  Draw                                                         *)(*                                                               *)(*  Draw is a (very) simple CAD program based on the Frame       *)(*  program.  With Draw, you can open new windows, close         *)(*  windows that are on the desktop, and draw lines using the    *)(*  mouse.  Multiple windows are supported.                      *)(*                                                               *)(*  Mike Westerfield                                             *)(*                                                               *)(*  Ported to Modula-2 by Peter Easdown                          *)(*                                                               *)(*  Copyright 1989, 1990, 1993                                   *)(*  Byte Works, Inc.                                             *)(*                                                               *)(*---------------------------------------------------------------*)MODULE Draw;FROM ASCII IMPORT EOL, nul;FROM Common IMPORT String255, TextArray, TextArrayPtr, SCB,  ConvStrToPStr, Ref;FROM DeskManager IMPORT FixAppleMenu;FROM DialogManager IMPORT AlertTemplate, ItemTemplate, buttonItem, statText,  itemDisable, Alert, StopAlert, NoteAlert, CautionAlert, FilterProc;FROM EventManager IMPORT EventRecord, GetNextEvent, mUpMask, EventMask,  EventBit;FROM EZTools IMPORT EZStartDesk, EZEndDesk;FROM M2Lib IMPORT HighWORD, LoWORD, ToolError;FROM MenuManager IMPORT MenuHandle, NewMenu, InsertMenu,  FixMenuBar, DrawMenuBar, DisableMItem, EnableMItem, HiliteMenu;FROM QuickDrawII IMPORT GrafPortPtr, Point, SetForeColor, SetBackColor,  SetPenMode, SetSolidPenPat, SetPenSize, GetPort, MoveTo, LineTo, modeXOR,  modeCopy, GlobalToLocal, InitCursor, scbColorMode, scbStayInGraph;FROM Storage IMPORT ALLOCATE, DEALLOCATE;FROM Strings IMPORT Assign, Concat, Length;FROM SYSTEM IMPORT ADR, BYTE;FROM ToolLocator IMPORT StartStopRecordPtr;FROM WindowManager IMPORT GetWRefCon, FrontWindow, CloseWindow,  ParamList, topMost, TaskRec, TaskMaster, NewWindow, StartDrawing,  wInSpecial, wInMenuBar, wInGoAway, wInContent, FrameDefProc,  DrawInfoBarProc, TaskMask, TaskMaskBit;CONST  AppleAbout   = 257;			(*Menu ID #s*)  FileQuit     = 256;  FileNew      = 258;  FileClose    = 255;  maxWindows   = 4;			(*max # of drawing windows*)  maxLines     = 50;			(*max # of lines in a window*)TYPE  alertKind = (norml,stop,note,caution); (*kinds of alerts*)  convert =    RECORD				(*for splitting 4 bytes to 2 bytes*)      CASE :BOOLEAN OF        TRUE:   long: LONGINT;      | FALSE:  lsw,msw: CARDINAL;      END;    END;  aWindowRecord =    RECORD				(*holds all info about one window*)      wPtr:     GrafPortPtr;		(*pointer to the window's port*)      name:     String255;		(*name of the window*)      numLines: [0..maxLines];		(*number of lines in this window*)      lines:    ARRAY [1..maxLines] OF	(*lines in the drawing*)        RECORD          p1,p2: Point;        END;    END;VAR  done:       BOOLEAN;			(*tells if the program should stop*)  event:      CARDINAL;			(*event #; returned by TaskMaster*)  lastEvent:  TaskRec;			(*last event returned in event loop*)  windows:    ARRAY [1..maxWindows] OF aWindowRecord; (*drawing windows*)  myTools:    StartStopRecordPtr;  cr:       ARRAY [0..1] OF CHAR;PROCEDURE DoAlert(kind: alertKind; msg: ARRAY OF CHAR);(* handle an alert box                                         *)(*                                                             *)(* parameters:                                                 *)(*     kind - kind of alert                                    *)(*     msg - alert message                                     *) VAR  message:  ItemTemplate;  button:   ItemTemplate;		(*button & message items*)  alertRec: AlertTemplate;		(*alert box*)  junk:     CARDINAL;			(*for receiving NoteAlert value*)  pString:  String255;  okString: String255; BEGIN  ConvStrToPStr(msg, pString);  ConvStrToPStr('OK', okString);  SetForeColor(0);			(*set text colors*)  SetBackColor(15);  WITH alertRec DO			(*initialize alert box*)    WITH atBoundsRect DO      v1 := 50;      h1 := 160;      v2 := 117;      h2 := 480;    END;    atAlertID := 2;    atStage1 := VAL(BYTE, 80H);    atStage2 := VAL(BYTE, 80H);    atStage3 := VAL(BYTE, 80H);    atStage4 := VAL(BYTE, 80H);    tItemList[1] := ADR(button);    tItemList[2] := ADR(message);    tItemList[3] := NIL;  END;  WITH button DO			(*initialize button item*)    itemID := 1;    WITH itemRect DO       v1 := 36;      h1 := 15;      v2 := 0;      h2 := 0;    END;    itemType := buttonItem;    itemDescr := Ref(ADR(okString));    itemValue := 0;    itemFlag := 0;    itemColor := NIL;  END;  WITH message DO			(*initialize message item*)    itemID := 100;    WITH itemRect DO      v1 := 5;      h1 := 100;      v2 := 62;      h2 := 310;    END;    itemType := itemDisable+statText;    itemDescr := Ref(ADR(pString));    itemValue := 0;    itemFlag := 0;    itemColor := NIL;  END;  CASE kind OF				(*handle the alert*)    norml:      junk := Alert(ADR(alertRec), FilterProc(NIL));  | stop:       junk := StopAlert(ADR(alertRec), FilterProc(NIL));  | note:       junk := NoteAlert(ADR(alertRec), FilterProc(NIL));  | caution:    junk := CautionAlert(ADR(alertRec), FilterProc(NIL));  END; (*case*)END DoAlert;(*$DataBank+*)PROCEDURE InitMenus;(* Initialize the menu bar. *)VAR  height:   CARDINAL;			(*height of the largest menu*)  menuHand: MenuHandle;			(*for 'handling' windows*)  s:        TextArrayPtr;		(*for builing menus*)BEGIN  NEW(s);				(*create the edit menu*)  Concat('>> Edit \N3', cr, s^);  Concat(s^, '--Undo\N250V*Zz', s^);  Concat(s^, cr, s^);  Concat(s^, '--Cut\N251*Xx', s^);  Concat(s^, cr, s^);  Concat(s^, '--Copy\N252*Cc', s^);  Concat(s^, cr, s^);  Concat(s^, '--Paste\N253*Vv', s^);  Concat(s^, cr, s^);  Concat(s^, '--Clear\N254', s^);  Concat(s^, cr, s^);  Concat(s^, '.', s^);  Concat(s^, cr, s^);  menuHand := NewMenu(s);  InsertMenu(menuHand, 0);  NEW(s);				(*create the file menu*)  Concat('>> File \N2', cr, s^);  Concat(s^, '--New\N258*Nn', s^);  Concat(s^, cr, s^);  Concat(s^, '--Close\N255V', s^);  Concat(s^, cr, s^);  Concat(s^, '--Quit\N256*Qq', s^);  Concat(s^, cr, s^);  Concat(s^, '.', s^);  Concat(s^, cr, s^);  menuHand := NewMenu(s);  InsertMenu(menuHand, 0);  NEW(s);				(*create the apple menu*)  Concat('>>@\XN1', cr, s^);  Concat(s^, '--About...\N257V', s^);  Concat(s^, cr, s^);  Concat(s^, '.', s^);  Concat(s^, cr, s^);  menuHand := NewMenu(s);  InsertMenu(menuHand, 0);  FixAppleMenu(1);			(*add desk accessories*)  height := FixMenuBar();		(*draw the completed menu bar*)  DrawMenuBar;END InitMenus;(*$DataBank-*)PROCEDURE InitWindows;(* Initialize the window RECORDs. *)VAR  i: CARDINAL;				(*loop variable*)BEGIN  FOR i := 1 TO maxWindows DO		(*initialize the window pointers*)    windows[i].wPtr := NIL;  END;  ConvStrToPStr('Paint 1', windows[1].name); (*initialize the window names*)  ConvStrToPStr('Paint 2', windows[2].name);  ConvStrToPStr('Paint 3', windows[3].name);  ConvStrToPStr('Paint 4', windows[4].name);END InitWindows;PROCEDURE DrawWindow;(* Draw the contents of the current window. *)VAR  i:    [1..maxWindows];		(*window's index*)  j:    CARDINAL;BEGIN  i := SHORT(GetWRefCon(GetPort()));  WITH windows[i] DO    IF numLines <> 0 THEN		(*skip the work if there aren't any lines*)      SetPenMode(modeCopy);		(*set up to draw*)      SetSolidPenPat(0);      SetPenSize(2, 1);      FOR j := 1 TO numLines DO		(*draw each of the lines*)        WITH lines[j] DO          MoveTo(p1.x, p1.y);          LineTo(p2.x, p2.y);        END; (*WITH*)      END;    END; (*IF*)  END; (*WITH*)END DrawWindow;PROCEDURE DoClose;(* Close the front drawing window (if there is one). *)VAR  i: CARDINAL;				(*index variable*)BEGIN  IF FrontWindow() <> NIL THEN     i := SHORT(GetWRefCon(FrontWindow())); (*find out which window to close*)    CloseWindow(windows[i].wPtr);	(*close it*)    windows[i].wPtr := NIL;    EnableMItem(FileNew);		(*we have room for new windows, now*)  END; (*IF*)END DoClose;PROCEDURE HandleMenu(menuNum: CARDINAL);(* Handle a menu selection. *)   PROCEDURE MenuAbout;  (* Show About alert box. *)  VAR    msg: TextArray;  BEGIN    Concat('Mini-Draw 1.0', cr, msg);    Concat(msg, 'Copyright 1988-1990', msg);    Concat(msg, cr, msg);    Concat(msg, 'Byte Works, Inc.', msg);    Concat(msg, cr, msg);    Concat(msg, cr, msg);    Concat(msg, 'Pascal by Mike Westerfield', msg);    Concat(msg, cr, msg);    Concat(msg, 'Modula-2 by Peter Easdown', msg);    DoAlert(note, msg);  END MenuAbout;  PROCEDURE DoNew;  (* Open a new drawing window. *)  VAR    i:      CARDINAL;			(*index variable*)    wParms: ParamList;			(*parameters for NewWindow*)  BEGIN    i := 1;				(*find an empty RECORD*)    WHILE windows[i].wPtr <> NIL DO      INC(i);    END;    windows[i].numLines := 0;		(*no lines drawn, yet*)    WITH wParms DO			(*initialize the window RECORD*)      paramLength := 78;      wFrameBits := 0DDA7H;      wTitle := ADR(windows[i].name);      wRefCon := i;      wZoom.h1 := 0;      wZoom.h2 := 615;      wZoom.v1 := 25;      wZoom.v2 := 188;      wColor := NIL;      wYOrigin := 0;      wXOrigin := 0;      wDataH := 0;      wDataW := 0;      wMaxH := 0;      wMaxW := 0;      wScrollVer := 10;      wScrollHor := 10;      wPageVer := 0;      wPageHor := 0;      wInfoRefCon := 0;      wInfoHeight := 0;      wFrameDefProc := FrameDefProc(NIL);      wInfoDefProc := DrawInfoBarProc(NIL);      wContDefProc := DrawWindow;      wPosition.v1 := 25;      wPosition.h1 := 0;      wPosition.v2 := 188;      wPosition.h2 := 615;      wPlane := VAL(GrafPortPtr, topMost);      wStorage := NIL;    END; (*WITH*)    windows[i].wPtr := NewWindow(ADR(wParms)); (*open the window*)    IF ToolError() <> 0 THEN      DoAlert(stop, 'Error opening the window.');      windows[i].wPtr := NIL;    ELSIF i = 4 THEN			(*don't allow more than 4 open windows*)      DisableMItem(FileNew);    END;  END DoNew;BEGIN  CASE menuNum OF			(*go handle the menu*)    AppleAbout: MenuAbout;  | FileQuit:   done := TRUE;  | FileNew:    DoNew;  | FileClose:  DoClose;    ELSE  END; (*CASE*)  HiliteMenu(FALSE, HighWORD(VAL(LONGINT, lastEvent.wmTaskData)));END HandleMenu;PROCEDURE Sketch;(* Track the mouse, drawing lines to connect the points. *)VAR   endPoint:   Point;			(*the end point of the line*)  firstPoint: Point;			(*the initial point*)  i:          [1..maxWindows];		(*window index*)  sEvent:     EventRecord;		(*last event returned in event loop*)  msg:        TextArray;		(*for error messages*)BEGIN   (*get the window's index*)  i := SHORT(GetWRefCon(FrontWindow()));  (*check for too many lines*)  IF windows[i].numLines = maxLines THEN    Concat('The window is full - ', cr, msg);    Concat(msg, 'more lines cannot be ', msg);    Concat(msg, cr, msg);    Concat(msg, 'added.', msg);    DoAlert(stop, msg);  ELSE     (*initialize the pen*)    StartDrawing(FrontWindow());    SetSolidPenPat(15);    SetPenSize(2, 1);    SetPenMode(modeXOR);    (*record the initial pen location*)    firstPoint := VAL(Point, lastEvent.wmWhere);    GlobalToLocal(firstPoint);    WITH firstPoint DO       MoveTo(x, y);      LineTo(x, y);    END; (*WITH*)    endPoint := firstPoint;    (*follow the pen, rubber-banding the line*)    WHILE NOT GetNextEvent(mUpMask, sEvent) DO       GlobalToLocal(sEvent.where);      WITH sEvent.where DO        IF (endPoint.x <> x) OR (endPoint.y <> y) THEN          MoveTo(firstPoint.x, firstPoint.y);          LineTo(endPoint.x, endPoint.y);          MoveTo(firstPoint.x, firstPoint.y);          LineTo(x, y);          endPoint.x := x;          endPoint.y := y;        END; (*if*)      END;    END; (*while*)    (*erase the last XORed line*)    MoveTo(firstPoint.x, firstPoint.y);    LineTo(endPoint.x, endPoint.y);    (*if we have a line (not a point), RECORD it in the window's line list*)    IF (firstPoint.x <> endPoint.x) OR (firstPoint.y <> endPoint.y) THEN      WITH windows[i] DO         numLines := numLines+1;        lines[numLines].p1 := firstPoint;        lines[numLines].p2 := endPoint;      END; (*WITH*)      SetPenMode(modeCopy);      SetSolidPenPat(0);      MoveTo(firstPoint.x, firstPoint.y);      LineTo(endPoint.x, endPoint.y);    END; (*if*)  END; (*else*)END Sketch;CONST  eventMask = EventMask{ebDown, ebUp, ebKeyDown, ebAutoKey, ebUpdate,                          ebActivate, ebSwitch, ebDeskAcc};BEGIN  cr[0] := EOL;  cr[1] := nul;  myTools := EZStartDesk(SCB{scbColorMode, scbStayInGraph});  InitMenus;				(*set up the menu bar*)  InitWindows;				(*initialize the window RECORDs*)  lastEvent.wmTaskMask := TaskMask{tmMenuKey, tmUpdate, tmFindW, tmMenuSel,                                    tmOpenDA, tmSysClick, tmDragW, tmContent,                                    tmClose, tmZoom, tmGrow, tmScroll,                                     tmSpecial, tmCRedraw, tmInactive, tmInfo,                                    tmContentControls};  InitCursor;				(*show the cursor*)  done := FALSE;			(*MAIN EVENT LOOP*)  REPEAT    event := TaskMaster(eventMask, lastEvent);    CASE event OF			(*handle the events we need to*)      wInSpecial,      wInMenuBar: HandleMenu(LoWORD(VAL(LONGINT, lastEvent.wmTaskData)));    | wInGoAway:  DoClose;    | wInContent: Sketch;      ELSE    END; (*CASE*)  UNTIL done;  EZEndDesk(myTools);END Draw.