MODULE ProcSieve;(*  This program supplies a simple example of the use of co-routines.  It uses the  console driver to create two "windows" or text ports on the screen.  Each  window is associated with a co-routine.  The user may type into the top port, whilst an implementation of the  Erastothenes sieve found in the file "Sieve.MOD" executes in the bottom port.  The user may quit the program by typing Control-Q.  If the sieve has  completed, then s/he may re-initiate the sieve by typing Control-R.*)FROM ASCII IMPORT  bs, vt;FROM ConsoleIO IMPORT  GotoXY, WriteChar, scPopTextPort, SetTextPort, NewPort, DisposePort, ReadChar,  GetTextPort, scRingBell, aTextPortRec, pTextPortRec, scClearAndHome;FROM InOut IMPORT  WriteInt, WriteLongInt, WriteCard;FROM EZStorage IMPORT   ALLOCATESTACK;FROM SYSTEM IMPORT  NEWPROCESS, TRANSFER, ADDRESS, BYTE;FROM Terminal IMPORT  WriteString, WriteLn;CONST  line1         = 0;          (* the line of "-" at the top of the screen *)  port1Top      = 1;          (* the dimensions of the first port. *)  port1Left     = 5;  port1Width    = 70;  port1Length   = 10;  line2         = 11;         (* the line of "-" separating the two ports *)  port2Top      = 12;         (* the dimensions of the second  port. *)  port2Left     = 5;  port2Width    = 70;  port2Length   = 10;  line3         = 22;         (* the line of "-" below the second port *)  workSpaceSize = 1024;       (* the size of the stack for the sub-process *)  theSize       = 8190;       (* Sample space for the sieve *)VAR  mainProcess, subProcess:  ADDRESS;  (* the two process descriptors *)  port1, port2:             pTextPortRec;  (* the two port records *)  terminate:                BOOLEAN;  (* flag to allow the program to terminate *)  workSpace:                ADDRESS; (* the address of the co-routine workspace *)  (*    doSieve is used to cause the sieve to execute.  When the sieve completes,    it sets this flag to FALSE.  By typing Control-R, the user causes this    flag to be set TRUE, which causes the sieve to restart the next time the    sub process gains control  *)  doSieve:  BOOLEAN;  Flags:    ARRAY [0..theSize] OF BOOLEAN;PROCEDURE GetTick(): LONGINT; TOOL 2503H;PROCEDURE DoSieve;(*  OPERATION:    This procedure forms the body of the sub process.  It performs the sieve    whilst the flag "doSieve" is TRUE.*)VAR     I,        Prime,        K,        Count,        Iterations: CARDINAL;        Starttime,        Endtime: LONGINT;BEGIN  (*    When the co-routine starts, we should initialise it's state before    entering the loop.    In this case, we have nothing in particular to do.  *)  LOOP    IF NOT doSieve THEN      (*        The sieve has completed, just return control to the main process.      *)      TRANSFER(subProcess, mainProcess);    ELSE      (*        We must set and get the port around any screen io.  Since there is        more than one place from which we can transfer back to the main        process, we can't guarantee the state of the current port, so        where ever we want to do screen io.  We could just setup the port        every time we gain control, but that would be a waste, since there        will be times when the sieve is not outputing anything.      *)      SetTextPort(port2);      WriteString('10 iterations of the Sieve of Erastothenes ');      WriteLn;      GetTextPort(port2^);      Starttime := GetTick();      FOR Iterations := 1 TO 10 DO        (*          Give the other process a go first.        *)        TRANSFER(subProcess, mainProcess);        SetTextPort(port2);        WriteChar('.');        GetTextPort(port2^);        Count := 0;        FOR I := 0 TO theSize DO          Flags[I] := TRUE;          (*            Putting a transfer in here would slow things down considerably,            so we won't do so.          *)        END;        FOR I := 0 TO theSize DO          IF Flags[I] THEN            Prime := I + I + 3;            K := I + Prime;            WHILE K <= theSize DO              Flags[K] := FALSE;              INC(K, Prime);            END;            INC(Count);          END;          (*            We have given the sieve a pass, now allow the main process to have            a look in.          *)          TRANSFER(subProcess, mainProcess);        END;      END;      Endtime := GetTick();      SetTextPort(port2);      WriteInt(Count, 3);      WriteString(' primes in ');      WriteLongInt(Endtime-Starttime, 10);      WriteString(' 60ths of a second.');      WriteLn;      WriteLn;      GetTextPort(port2^);      (*        The sieve is complete, set the flag to FALSE.      *)      doSieve := FALSE;    END;  END;END DoSieve;PROCEDURE MonitorKeyboard;(*  OPERATION:    This procedure is the main loop of the main process.  It polls the keyboard,    and displays any keys.  When no key is pressed, control is passed back to    the main process.*)VAR  ch: CHAR;  OK: BOOLEAN;BEGIN  REPEAT    ReadChar(ch, OK);    IF NOT OK THEN      (*        No key, give control back to the sub process (sieve).      *)      TRANSFER(mainProcess, subProcess);    ELSE      IF ((ch >= " ") AND (ch <= 177C)) THEN        (*          A printable character, so display it.        *)        SetTextPort(port1);        WriteChar(ch);        GetTextPort(port1^);      ELSIF ch = bs THEN        (*          Implement a simple backspace mechanism.        *)        IF port1^.ch > VAL(BYTE, port1Left) THEN          SetTextPort(port1);          WriteChar(bs);          WriteChar(vt);          GetTextPort(port1^);        END;      ELSIF ch = 21C THEN        (*          Control-Q, allow the main process to terminate.        *)        SetTextPort(port1);        WriteLn;        WriteString('Quitting...');        WriteLn;        GetTextPort(port1^);        terminate := TRUE;      ELSIF (ch = 22C) AND NOT doSieve THEN        (*          Control-R, AND the sieve has completed, so re-initiate it.        *)        SetTextPort(port1);        WriteString('Initiating Sieve...');        WriteLn;        GetTextPort(port1^);        doSieve := TRUE;      ELSE        (*          Something else, ring the bell        *)        SetTextPort(port1);        WriteChar(scRingBell);        GetTextPort(port1^);      END;    END;  UNTIL terminate;END MonitorKeyboard;PROCEDURE InitPorts;(*  OPERATION:    Draw the three lines on the screen, and create the two ports.*)BEGIN  WriteChar(scClearAndHome);  GotoXY(5, line1);  WriteString(".--------------------------------------------------------------------.");  GotoXY(5, line2);  WriteString("|--------------------------------------------------------------------|");  GotoXY(5, line3);  WriteString("'--------------------------------------------------------------------'");  port2 := NewPort(port2Top, port2Left, port2Length, port2Width);  port1 := NewPort(port1Top, port1Left, port1Length, port1Width);END InitPorts;BEGIN  (*    Initialise things  *)  terminate := FALSE;  doSieve := TRUE;  ALLOCATESTACK(workSpace, workSpaceSize);  NEWPROCESS(DoSieve, workSpace, workSpaceSize, subProcess);  InitPorts;  (*    This is not necessary, but I like to give the sub process a look in before    we go into full swing with the main process.  *)  TRANSFER(mainProcess, subProcess);  (*    Enter the main loop of the main process  *)  MonitorKeyboard;  (*    By popping the text port, without having saved any, the console driver    sets the current port to the default values (the entire screen) which is    a good way to leave it when quitting.  *)  WriteChar(scPopTextPort);  GotoXY(0, 23);  (*    Give back the memory used up by the two ports.  *)  DisposePort(port1);  DisposePort(port2);END ProcSieve.