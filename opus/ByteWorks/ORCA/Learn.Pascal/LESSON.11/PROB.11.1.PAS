{ Do a random walk with 10 random shapes                         }program RandomWalk;uses Common, QuickDrawII;const   numShapes = 10;              {# of shapes to animate}   walkLength = 100;            {# of "steps" in the walk}   maxX = 320;                  {size of the graphics screen}   maxY = 200;type   shapeKind = (triangle, square, star);   shapeType = record           {information about one shape}      color: 0..3;      case kind: shapeKind of         triangle: (            tx1,tx2,tx3: integer;            ty1,ty2,ty3: integer;            );         square: (            sx1,sx2,sx3,sx4: integer;            sy1,sy2,sy3,sy4: integer;            );         star: (            px1,px2,px3,px4,px5: integer;            py1,py2,py3,py4,py5: integer;            );      end;var   i,j: integer;                 {loop variables}                                 {shapes: current array of shapes}                                 {oldShapes: shapes in last position}   shapes,oldShapes: array[1..numShapes] of shapeType;   procedure InitGraphics;   { Standard graphics initialization.                            }   var      r: rect;                  {screen size}   begin {InitGraphics}   StartGraph(320);             {initialize QuickDraw}   SetPenMode(2);               {pen mode = xor}   SetPenSize(1,1);             {use a square pen}   SetSolidPenPat(15);          {paint the screen white}   GetPortRect(r);   PaintRect(r);   SetSolidPenPat(0);           {use a black pen}   end; {InitGraphics}   function RandomValue(max: integer): integer;   { Return a pseudo-random number in the range 1..max.           }   {                                                              }   { Parameters:                                                  }   {    max - largest number to return                            }   begin {RandomValue}   RandomValue := (RandomInteger mod max) + 1;   end; {RandomValue}   procedure DrawShape(s: shapeType);   { This subroutine draws one of the shapes on the screen.       }   {                                                              }   { Parameters:                                                  }   {    s - shape to draw                                         }   begin {DrawShape}   SetSolidPenPat(s.color);     {set the pen color for the shape}   case s.kind of      triangle: begin           {draw a triangle}         MoveTo(s.tx1,s.ty1);         LineTo(s.tx2,s.ty2);         LineTo(s.tx3,s.ty3);         LineTo(s.tx1,s.ty1);         end;      square: begin             {draw a square}         MoveTo(s.sx1,s.sy1);         LineTo(s.sx2,s.sy2);         LineTo(s.sx4,s.sy4);         LineTo(s.sx3,s.sy3);         LineTo(s.sx1,s.sy1);         end;      star: begin               {draw a star}         MoveTo(s.px1,s.py1);         LineTo(s.px2,s.py2);         LineTo(s.px3,s.py3);         LineTo(s.px4,s.py4);         LineTo(s.px5,s.py5);         LineTo(s.px1,s.py1);         end;      end; {case}   end; {DrawShape}   procedure CreateShape(var s: shapeType);   { This subroutine creates a shape.  The color and initial      }   { position of the shape are chosen randomly.  The size of the  }   { shape is based on pre-computed values.                       }   {                                                              }   { Parameters:                                                  }   {    s - shape to create                                       }   var      cx,cy: integer;           {center point for the shape}   begin {CreateShape}   s.color := RandomValue(15);  {get a color}   cx := RandomValue(300)+10;   {get the center position, picking the}   cy := RandomValue(184)+8;    {points so the shape is in the window}      case RandomValue(3) of       {set the initial positions}      1: begin                  {set up a triangle}         s.kind := triangle;         s.tx1 := cx-10;         s.ty1 := cy+4;         s.tx2 := cx;         s.ty2 := cy-8;         s.tx3 := cx+10;         s.ty3 := cy+4;         end;      2: begin                  {set up a square}         s.kind := square;         s.sx1 := cx-8;         s.sy1 := cy-6;         s.sx2 := cx+8;         s.sy2 := cy-6;         s.sx3 := cx-8;         s.sy3 := cy+6;         s.sx4 := cx+8;         s.sy4 := cy+6;         end;      3: begin                  {set up a star}         s.kind := star;         s.px1 := cx-7;         s.py1 := cy+7;         s.px2 := cx;         s.py2 := cy-8;         s.px3 := cx+7;         s.py3 := cy+7;         s.px4 := cx-11;         s.py4 := cy-3;         s.px5 := cx+11;         s.py5 := cy-3;         end;      end; {case}   end; {CreateShape}   procedure UpdateShape(var s: shapeType);   { This subroutine moves a shape across the screen in a random  }   { walk.                                                        }   {                                                              }   { Parameters:                                                  }   {    s - shape to update                                       }   var      dx,dy: integer;           {movement direction}   begin {UpdateShape}   dx := RandomValue(3)-2;     {get the walk direction}   dy := RandomValue(3)-2;      case s.kind of              {make sure we don't walk off of the}                                { screen, then update the position }      triangle: begin           {check a triangle}         if dx = -1 then            if s.tx1 < 1 then               dx := 0;         if dx = 1 then            if s.tx3 >= maxX then               dx := 0;         if dy = -1 then            if s.ty2 < 1 then               dy := 0;         if dy = 1 then            if s.ty3 >= maxY then               dy := 0;         s.tx1 := s.tx1+dx;     {update a triangle}         s.ty1 := s.ty1+dy;         s.tx2 := s.tx2+dx;         s.ty2 := s.ty2+dy;         s.tx3 := s.tx3+dx;         s.ty3 := s.ty3+dy;         end;      square: begin             {check a square}         if dx = -1 then            if s.sx1 < 1 then               dx := 0;         if dx = 1 then            if s.sx2 >= maxX then               dx := 0;         if dy = -1 then            if s.sy1 < 1 then               dy := 0;         if dy = 1 then            if s.sy3 >= maxY then               dy := 0;         s.sx1 := s.sx1+dx;     {update a square}         s.sy1 := s.sy1+dy;         s.sx2 := s.sx2+dx;         s.sy2 := s.sy2+dy;         s.sx3 := s.sx3+dx;         s.sy3 := s.sy3+dy;         s.sx4 := s.sx4+dx;         s.sy4 := s.sy4+dy;         end;      star: begin               {check a star}         if dx = -1 then            if s.px4 < 1 then               dx := 0;         if dx = 1 then            if s.px5 >= maxX then               dx := 0;         if dy = -1 then            if s.py2 < 1 then               dy := 0;         if dy = 1 then            if s.py1 >= maxY then               dy := 0;         s.px1 := s.px1+dx;     {update a star}         s.py1 := s.py1+dy;         s.px2 := s.px2+dx;         s.py2 := s.py2+dy;         s.px3 := s.px3+dx;         s.py3 := s.py3+dy;         s.px4 := s.px4+dx;         s.py4 := s.py4+dy;         s.px5 := s.px5+dx;         s.py5 := s.py5+dy;         end;      end; {case}   end; {UpdateShape}beginInitGraphics;                   {set up the graphics window}Seed(6289);                     {initialize the random number generator}for i := 1 to numShapes do      {set up and draw the initial shapes}   begin   CreateShape(shapes[i]);   DrawShape(shapes[i]);   end; {for}for i := 1 to walkLength do     {do the random walk}   begin   oldShapes := shapes;         {move the shapes}   for j := 1 to numShapes do      UpdateShape(shapes[j]);   for j := 1 to numShapes do   {redraw the shapes}      begin      DrawShape(shapes[j]);      DrawShape(oldShapes[j]);      end; {for}   end; {for}EndGraph;                       {shut down QuickDraw}end.