program Robot (input, output);{ Move a "robot" around on the graphics screen }uses Common, QuickDrawII;const   maxLength = 10;                      {length of a word}   maxLine = 255;                       {max length of a line}   moveX = 30; moveY = 10;              {distance of one move}type   subjectType = (none,up,down,left,right); {command subjects}   verbType = (nada,go,stop);               {commands}var   cline: string[maxLine];              {command line}   lineIndex: integer;                  {index of next char in line}   token: string[maxLength];            {last word read}   x,y: integer;                        {position of the robot}   subject: subjectType;                {subject of the last command}   verb: verbType;                      {verb of the last command}   procedure GetToken;      { Read a word from the source file                           }   {                                                            }   { Variables:                                                 }   {    f - source file                                         }   {    token - string read                                     }      var      len: integer;                     {length of the string}      function ToUpper (ch: char): char;      { Return the uppercase equivalent of a character          }      {                                                         }      { Parameters:                                             }      {    ch - character to convert                            }      {                                                         }      { Returns: Uppercase equivalent of ch                     }      begin {ToUpper}      if ch in ['a'..'z'] then         ch := chr(ord(ch)-ord('a')+ord('A'));      ToUpper := ch;      end; {ToUpper}      begin {GetToken}   {initialize the length of the string}   len := 0;   {skip to the first character}   while (not (cline[lineIndex] in ['a'..'z','A'..'Z']))      and (lineIndex <= length(cline)) do      lineIndex := lineIndex+1;   {read the word}   while (lineIndex <= length(cline))      and (cline[lineIndex] in ['a'..'z','A'..'Z']) do begin      if len < maxLength then begin         len := len+1;         token[len] := ToUpper(cline[lineIndex]);         end; {if}      lineIndex := lineIndex+1;      end; {while}   {set the length of the string}   token[0] := chr(len);   end; {GetToken}   procedure GetAction;      { Find out what the player wants to do                       }   {                                                            }   { Variables:                                                 }   {    verb - action to take                                   }   {    subject - what we do the action to or with              }      var      done: boolean;                    {loop exit variable}      begin {GetAction}   done := false;                       {cycle until we get a good command}   repeat      readln(cline);                    {get a command line}      lineIndex := 1;      verb := nada;                     {start with no subject,verb}      subject := none;      repeat         GetToken;                      {get a token}                                        {handle a subject}         if (token = 'NORTH') or (token = 'UP') then            subject := up         else if (token = 'SOUTH') or (token = 'DOWN') then            subject := down         else if (token = 'EAST') or (token = 'RIGHT') then            subject := right         else if (token = 'WEST') or (token = 'LEFT') then            subject := left                                        {handle a verb}         else if (token = 'QUIT') or (token = 'STOP') then            verb := stop         else if (token = 'GO') or (token = 'MOVE') then            verb := go;      until length(token) = 0;      case verb of                      {make sure the input is consistent}         nada:            writeln('Please tell me what to do (go or stop).');            stop:            done := true;            go:            if subject = none then               writeln('Please tell me which way to go.')            else               done := true;         end; {case}   until done;   end; {GetAction}   procedure DrawPoint (x,y,color: integer);   { Draw the robot                                             }   {                                                            }   { Variables:                                                 }   {    x,y - position of the robot                             }   {    color - robot color                                     }   begin {DrawPoint}   SetSolidPenPat(color);   SetPenMode(0);   SetPenSize(9,3);   MoveTo(x,y);   LineTo(x,y);   end; {DrawPoint}beginx := 60;                                {set up the initial robot}y := 20;DrawPoint(x,y,0);repeat   GetAction;                           {find out what we are supposed to do}   if verb = go then begin              {if it is a movement then move}      DrawPoint(x,y,3);                 {erase the old robot}      case subject of                   {move the robot}         up:    y := y-moveY;         down:  y := y+moveY;         left:  x := x-moveX;         right: x := x+moveX;         end; {case}      DrawPoint(x,y,0);                 {draw the robot in the new spot}      end; {if}until verb = stop;end.