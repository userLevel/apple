{ Rotate a cube in the graphics window.         }{                                               }{ This program makes use of two constants,      }{ xScale and yScale, to decide how to convert   }{ from the real numbers used to represent the   }{ points of the cube into the integer           }{ coordinates used by QuickDraw.  These values  }{ will convert from inches to pixels in 640     }{ mode on a 12" monitor.                        }program RotateCube;uses Common, QuickDrawII;const   xScale = 86;                 {x conversion factor}   yScale = 33;                 {y conversion factor}   pi = 3.1415927;              {circumference of a circle}type   fourReals = array[1..4] of real; {array of four reals}var   x,y: fourReals;              {points in the square}   oldX,oldY: fourReals;        {points in the last square drawn}   i: integer;                  {loop variable}   procedure InitGraphics;   { Standard graphics initialization           }   begin {InitGraphics}   SetPenMode(0);               {pen mode = copy}   SetSolidPenPat(0);           {pen color = black}   SetPenSize(3,1);             {use a square pen}   end; {InitGraphics}   procedure Rotate (var x,y: real; angle,ox,oy: real);   { Rotate the point x,y about ox,oy through   }   { the angle given.                           }   {                                            }   { Parameters:                                }   {    x,y - point to rotate                   }   {    angle - angle to rotate (in radians)    }   {    ox,oy - point to rotate around          }   var      cosAngle,sinAngle: real;  {sin and cos of angle}      nx: real;                 {new x}   begin {Rotate}   x := x-ox;                   {move the point}   y := y-oy;   cosAngle := cos(angle);      {this takes time - save the results}   sinAngle := sin(angle);   nx := x*cosAngle + y*sinAngle; {rotate the point}   y := y*cosAngle - x*sinAngle;   x := nx+ox;                  {move the point back}   y := y+oy;   end; {Rotate}   procedure RotateSquare(var x,y: fourReals);   { Rotate the square 9 degrees                }   {                                            }   { Parameters:                                }   {    x,y - coordinates of square             }   var      i: integer;               {loop variable}   begin {RotateSquare}   for i := 1 to 4 do      Rotate(x[i], y[i], pi/20.0, 1.5, 1.5);   end; {RotateSquare}   procedure DrawSquare (color: integer);   { Draw the square                            }   {                                            }   { Parameters:                                }   {    color - color to draw                   }   begin {DrawSquare}   SetSolidPenPat(color);       {set the pen color}                                {draw the square}   MoveTo(round(x[1]*xScale), round(y[1]*yScale));   LineTo(round(x[2]*xScale), round(y[2]*yScale));   LineTo(round(x[3]*xScale), round(y[3]*yScale));   LineTo(round(x[4]*xScale), round(y[4]*yScale));   LineTo(round(x[1]*xScale), round(y[1]*yScale));   end; {DrawSquare}beginInitGraphics;                   {set up the graphics window}x[1] := 1.0;   y[1] := 1.0;     {initialize the square}x[2] := 2.0;   y[2] := 1.0;x[3] := 2.0;   y[3] := 2.0;x[4] := 1.0;   y[4] := 2.0;DrawSquare(0);                  {draw the square}for i := 1 to 10 do begin   oldX := x;                   {save the current location}   oldY := y;   RotateSquare(oldX,oldY);     {rotate}   DrawSquare(3);               {erase the old square}   x :=oldX;                    {set the new location}   y := oldY;   DrawSquare(0);               {draw the square}   end; {for}end.