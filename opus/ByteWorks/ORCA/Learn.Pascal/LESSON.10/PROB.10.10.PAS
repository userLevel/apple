{ Do a random walk with 10 random shapes                         }program RandomWalk;uses Common, QuickDrawII;const   numShapes = 10;              {# of shapes to animate}   walkLength = 100;            {# of "steps" in the walk}   maxX = 316;                  {size of the graphics screen}   maxY = 83;type   shapeKind = (triangle, square, star);   shapeType = record           {information about one shape}      color: 0..3;      case kind: shapeKind of         triangle: (            tx1,tx2,tx3: integer;            ty1,ty2,ty3: integer;            );         square: (            sx1,sx2,sx3,sx4: integer;            sy1,sy2,sy3,sy4: integer;            );         star: (            px1,px2,px3,px4,px5: integer;            py1,py2,py3,py4,py5: integer;            );      end;var   i,j: integer;                {loop variables}                                {shapes: current array of shapes}                                {oldShapes: shapes in last position}   shapes,oldShapes: array[1..numShapes] of shapeType;   procedure InitGraphics;   { Standard graphics initialization.                            }   begin {InitGraphics}   SetPenMode(2);               {pen mode = xor}   SetPenSize(3,1);             {use a square pen}   end; {InitGraphics}   function RandomValue(max: integer): integer;   { Return a pseudo-random number in the range 1..max.           }   {                                                              }   { Parameters:                                                  }   {    max - largest number to return                            }   begin {RandomValue}   RandomValue := (RandomInteger mod max) + 1;   end; {RandomValue}   procedure DrawShape(s: shapeType);   { This subroutine draws one of the shapes on the screen.       }   {                                                              }   { Parameters:                                                  }   {    s - shape to draw                                         }   begin {DrawShape}   SetSolidPenPat(s.color);     {set the pen color for the shape}   with s do      case kind of            triangle: begin        {draw a triangle}            MoveTo(tx1,ty1);            LineTo(tx2,ty2);            LineTo(tx3,ty3);            LineTo(tx1,ty1);            end;            square: begin          {draw a square}            MoveTo(sx1,sy1);            LineTo(sx2,sy2);            LineTo(sx4,sy4);            LineTo(sx3,sy3);            LineTo(sx1,sy1);            end;            star: begin            {draw a star}            MoveTo(px1,py1);            LineTo(px2,py2);            LineTo(px3,py3);            LineTo(px4,py4);            LineTo(px5,py5);            LineTo(px1,py1);            end;         end; {case}   end; {DrawShape}   procedure CreateShape(var s: shapeType);   { This subroutine creates a shape.  The color and initial      }   { position of the shape are chosen randomly.  The size of the  }   { shape is based on pre-computed values.                       }   {                                                              }   { Parameters:                                                  }   {    s - shape to create                                       }   var      cx,cy: integer;           {center point for the shape}   begin {CreateShape}   s.color := RandomValue(3);   {get a color}   cx := RandomValue(279)+19;   {get the center position, picking the}   cy := RandomValue(73)+8;     {points so the shape is in the window}      with s do      case RandomValue(3) of    {set the initial positions}         1: begin               {set up a triangle}            kind := triangle;            tx1 := cx-19;            ty1 := cy+4;            tx2 := cx;            ty2 := cy-8;            tx3 := cx+19;            ty3 := cy+4;            end;            2: begin               {set up a square}            kind := square;            sx1 := cx-15;            sy1 := cy-6;            sx2 := cx+15;            sy2 := cy-6;            sx3 := cx-15;            sy3 := cy+6;            sx4 := cx+15;            sy4 := cy+6;            end;            3: begin               {set up a star}            kind := star;            px1 := cx-13;            py1 := cy+7;            px2 := cx;            py2 := cy-8;            px3 := cx+13;            py3 := cy+7;            px4 := cx-21;            py4 := cy-3;            px5 := cx+21;            py5 := cy-3;            end;         end; {case}   end; {CreateShape}   procedure UpdateShape(var s: shapeType);   { This subroutine moves a shape across the screen in a random  }   { walk.                                                        }   {                                                              }   { Parameters:                                                  }   {    s - shape to update                                       }   var      dx,dy: integer;           {movement direction}   begin {UpdateShape}   dx := RandomValue(3)-2;      {get the walk direction}   dy := RandomValue(3)-2;   with s do      case kind of              {make sure we don't walk off of the}                                { screen, then update the position }         triangle: begin        {check a triangle}            if dx = -1 then               if tx1 < 1 then                  dx := 0;            if dx = 1 then               if tx3 >= maxX then                  dx := 0;            if dy = -1 then               if ty2 < 1 then                  dy := 0;            if dy = 1 then               if ty3 >= maxY then                  dy := 0;            tx1 := tx1+dx;      {update a triangle}            ty1 := ty1+dy;            tx2 := tx2+dx;            ty2 := ty2+dy;            tx3 := tx3+dx;            ty3 := ty3+dy;            end;            square: begin          {check a square}            if dx = -1 then               if sx1 < 1 then                  dx := 0;            if dx = 1 then               if sx2 >= maxX then                  dx := 0;            if dy = -1 then               if sy1 < 1 then                  dy := 0;            if dy = 1 then               if sy3 >= maxY then                  dy := 0;            sx1 := sx1+dx;      {update a square}            sy1 := sy1+dy;            sx2 := sx2+dx;            sy2 := sy2+dy;            sx3 := sx3+dx;            sy3 := sy3+dy;            sx4 := sx4+dx;            sy4 := sy4+dy;            end;            star: begin            {check a star}            if dx = -1 then               if px4 < 1 then                  dx := 0;            if dx = 1 then               if px5 >= maxX then                  dx := 0;            if dy = -1 then               if py2 < 1 then                  dy := 0;            if dy = 1 then               if py1 >= maxY then                  dy := 0;            px1 := px1+dx;      {update a star}            py1 := py1+dy;            px2 := px2+dx;            py2 := py2+dy;            px3 := px3+dx;            py3 := py3+dy;            px4 := px4+dx;            py4 := py4+dy;            px5 := px5+dx;            py5 := py5+dy;            end;         end; {case}   end; {UpdateShape}beginInitGraphics;                   {set up the graphics window}Seed(6289);                     {initialize the random number generator}for i := 1 to numShapes do      {set up and draw the initial shapes}   begin   CreateShape(shapes[i]);   DrawShape(shapes[i]);   end; {for}for i := 1 to walkLength do     {do the random walk}   begin   oldShapes := shapes;         {move the shapes}   for j := 1 to numShapes do      UpdateShape(shapes[j]);   for j := 1 to numShapes do   {redraw the shapes}      begin      DrawShape(shapes[j]);      DrawShape(oldShapes[j]);      end; {for}   end; {for}end.