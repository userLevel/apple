{ Read a file and echo it to the console }program ReadFile (output);uses Common, ProDOS, MemoryMgr;const   fNameLength = 64;                      {max length of a file name}type   fNameType = string[fNameLength];       {type of a file name}   bytePtr = ^byte;                       {pointer into the file buffer}var   fName: fNameType;                      {file name}   fPtr: bytePtr;                         {file pointer}   fLength: longint;                      {length of the file}procedure ReadFile (fName: fNameType; var ptr: bytePtr;                    var length: longint);{ Read a file from disk                                        }{                                                              }{ Parameters:                                                  }{    fName - file name to load                                 }{    ptr - return a pointer to the 1st char in the file        }{    length - length of the file, in characters (also bytes)   }label 99;var   openRec: openDCB;                      {ProDOS records}   eofRec: eofDCB;   readRec: readWriteDCB;   closeRec: closeDCB;   fileHandle: handle;                    {file handle}   procedure Error(err: integer; close: boolean);   { Flag a ProDOS disk error                                  }   {                                                           }   { Parameters:                                               }   {    err - error number                                     }   {    close - close the file?                                }   begin {Error}   writeln('ProDOS error ', toolerror:1, ' processing ', fname);   if close then      P16Close(closeRec);   goto 99;   end; {Error}begin {ReadFile}ptr := nil;                               {assume we will get an error}length := 0;openRec.pathName := @fName;               {open the file}openRec.reserved := 0;P16Open(openRec);if toolerror = 0 then begin   closeRec.refNum := openRec.refNum;     {get ready for a close}   eofRec.refNum := openRec.refNum;       {find the length of the file}   P16Get_EOF(eofRec);   if toolerror <> 0 then      Error(toolerror, true);   length := eofRec.fileSize;   if length <> 0 then begin                                          {get some memory file the file}      fileHandle := NewHandle(length, UserID, $C000, nil);      if toolerror <> 0 then         Error(toolerror, true);      readRec.refNum := eofRec.refNum;    {read the file}      readRec.dataBuffer := pointer(fileHandle^);      readRec.requestCount := length;      P16Read(readRec);      if toolerror <> 0 then         Error(toolerror, true);      ptr := bytePtr(fileHandle^);        {set the file pointer}      P16Close(closeRec);                 {close the file}      end; {if}   end {if}else   Error(toolerror, false);99:end; {ReadFile}beginfName := 'readfile.pas';                  {read the file}writeln('Reading the file...');ReadFile(fName, fPtr, fLength);writeln('...done.');while fLength <> 0 do begin               {echo the file}   if fPtr^ = 13 then      writeln   else      write(chr(fPtr^));   fPtr := pointer(ord4(fPtr)+1);   fLength := fLength-1;   end; {while}end.