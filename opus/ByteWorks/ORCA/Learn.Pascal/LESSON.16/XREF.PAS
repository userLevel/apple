{ XREF                                                          }{                                                               }{ This program generates a cross reference of a Pascal program, }{ showing where any symbol is used.  To use XREF, start by      }{ selecting the shell window.  Type                             }{                                                               }{    xref filename                                              }{                                                               }{ where filename is the name of the program you want to cross-  }{ reference.                                                    }program ReadFile (input, output);uses Common, ProDOS, MemoryMgr;const   fNameLength = 64;                      {max length of a file name}   symbolLength = 80;                     {max length of a symbol}type   bytePtr = ^byte;                       {pointer into the file buffer}   fNameType = string[fNameLength];       {type of a file name}   tokenType = string[symbolLength];      {type of a symbol name}   linePtr = ^lineRecord;                 {line number list}   lineRecord = record      next: linePtr;      number: integer;      end;   symbolPtr = ^symbolRecord;             {symbol table entry}   symbolRecord = record      next: symbolPtr;      symbol: string[symbolLength];      lines: linePtr;      end;var   ch: char;                              {current character}   fLength: longint;                      {length of the file}   fName: fNameType;                      {file name}   fPtr: bytePtr;                         {file pointer}   lineNumber: integer;                   {current line number}   symbols: symbolPtr;                    {symbol table}   token: tokenType;                      {current token}   tokenLine: integer;                    {line number at start of token}procedure GetFileName (var fName: fNameType);{ Read a file name from the command line.  If none is given,   }{ prompt for one.  Return a null string if no name is given    }{ when a name is asked for.                                    }{                                                              }{ Parameters:                                                  }{    fName - the file name is returned here                    }var   cline: string[255];                    {command line}   i,j: integer;                          {string indices}   procedure SkipBlanks;   { Skip blanks in the command line                           }   begin {SkipBlanks}   while (i < length(cline)) and (cline[i] = ' ') do      i := i+1;   end; {SkipBlanks}begin {GetFileName}CommandLine(cline);                       {read the command line}i := 1;SkipBlanks;                               {skip leading blanks}while (i < length(cline))                 {skip the program name}   and (cline[i] <> ' ') do   i := i+1;SkipBlanks;                               {skip to the file name}if i >= length(cline) then begin          {if needed, prompt for a name}   write('File to cross reference: ');   readln(cline);   i := 1;   SkipBlanks;   end; {if}if i <= length(cline) then begin   j := 0;                                {read the file name}   while (j < fNameLength)      and (i <= length(cline))      and (cline[i] <> ' ') do begin      j := j+1;      fName[j] := cline[i];      i := i+1;      end; {while}   fName[0] := chr(j);                    {set the length}   SkipBlanks;                            {check for extra input}   if i <= length(cline) then      writeln('Extra input ignored');   end {if}else   fName := '';                           {return a null string}end; {GetFileName}procedure ReadFile (var fName: fNameType; var ptr: bytePtr;                    var length: longint);{ Read a file from disk                                        }{                                                              }{ Parameters:                                                  }{    fName - file name to load                                 }{    ptr - return a pointer to the 1st char in the file        }{    length - length of the file, in characters (also bytes)   }label 99;var   openRec: openDCB;                      {ProDOS records}   eofRec: eofDCB;   readRec: readWriteDCB;   closeRec: closeDCB;   fileHandle: handle;                    {file handle}   procedure Error(err: integer; close: boolean);   { Flag a ProDOS disk error                                  }   {                                                           }   { Parameters:                                               }   {    err - error number                                     }   {    close - close the file?                                }   begin {Error}   writeln('ProDOS error ', toolerror:1, ' processing ', fname);   if close then      P16Close(closeRec);   goto 99;   end; {Error}begin {ReadFile}ptr := nil;                               {assume we will get an error}length := 0;openRec.pathName := @fname;               {open the file}openRec.reserved := 0;P16Open(openRec);if toolerror = 0 then begin   closeRec.refNum := openRec.refNum;     {get ready for a close}   eofRec.refNum := openRec.refNum;       {find the length of the file}   P16Get_EOF(eofRec);   if toolerror <> 0 then      Error(toolerror, true);   length := eofRec.fileSize;   if length <> 0 then begin                                          {get some memory file the file}      fileHandle := NewHandle(length, UserID, $C000, nil);      if toolerror <> 0 then         Error(toolerror, true);      readRec.refNum := eofRec.refNum;    {read the file}      readRec.dataBuffer := pointer(fileHandle^);      readRec.requestCount := length;      P16Read(readRec);      if toolerror <> 0 then         Error(toolerror, true);      ptr := bytePtr(fileHandle^);        {set the file pointer}      P16Close(closeRec);                 {close the file}      end; {if}   end {if}else   Error(toolerror, false);99:end; {ReadFile}procedure GetToken;{ Read a word from the source file                                }{                                                                 }{ Variables:                                                      }{    fPtr - pointer to the next character in the file             }{    fLength - number of characters left in the file              }{    lineNumber - current line number                             }{    token - string read                                          }{    tokenLine - line number at the start of the token            }var   len: integer;                          {length of the string}   tPtr: ^byte;                           {used for 1 char look-ahead}   procedure NextCh;   { Get the next character from the file, skipping comments      }      procedure GetCh;      { get the next character from the file                      }      begin {GetCh}      if fLength = 0 then         ch := chr(0)      else begin         fPtr := pointer(ord4(fPtr)+1);         fLength := fLength-1;         ch := chr(fPtr^);         end; {else}      end; {GetCh}      procedure SkipComment;      { Skip comments in the program                              }      begin {SkipComment}      repeat         GetCh;         if ch = '*' then begin            GetCh;            if ch = ')' then               ch := '}';            end; {if}      until ch in ['}', chr(0)];      end; {SkipComment}   begin {NextCh}   GetCh;                                 {get the next character}   if ch = chr(13) then                   {handle the end of a line}      lineNumber := lineNumber+1   else if ch = '{' then                  {skip comments}      SkipComment   else if ch = '(' then begin      tPtr := pointer(ord4(fPtr)+1);      if chr(tPtr^) = '*' then begin         GetCh;         GetCh;         SkipComment;         end; {if}      end; {else if}   end; {NextCh}begin {GetToken}len := 0;                                 {no token, yet}if fLength <> 0 then begin                                          {skip to the next token}   while not (ch in ['a'..'z','A'..'Z','_',chr(0)]) do      NextCh;   tokenLine := lineNumber;               {record the line number}                                          {record the token}   while ch in ['a'..'z','A'..'Z','_','0'..'9'] do begin      if len < symbolLength then begin         len := len+1;         token[len] := ch;         end; {if}      NextCh;      end; {while}   end; {if}token[0] := chr(len);                     {set the length of the string}end; {GetToken}procedure Insert;{ Insert a symbol use in the symbol table.  If the symbol does    }{ not exist, create a new entry.                                  }{                                                                 }{ Variables:                                                      }{    tokenLine - line number at the start of the token            }{    token - symbol to insert                                     }{    symbols - pointer to the first entry in the symbol table     }label 1;var   lPtr: linePtr;                         {current line number pointer}   sPtr: symbolPtr;                       {current symbol pointer}   function Match (s1, s2: tokenType): boolean;   { Do a case insensitive compare of two strings for equality    }   {                                                              }   { Parameters:                                                  }   {    s1,s2 - strings to compare                                }   {                                                              }   { Returns:                                                     }   {    True if the strings are equal, else false                 }   label 1;   var      i: integer;                         {loop variable}      len: integer;                       {length of the first string}      function ToUpper(ch: char): char;      { Return the uppercase equivalent of ch                     }      begin {ToUpper}      if ch in ['a'..'z'] then         ch := chr(ord(ch)-ord('a')+ord('A'));      ToUpper := ch;      end; {ToUpper}   begin {Match}   len := length(s1);   if len = length(s2) then begin      Match := true;      for i := 1 to len do         if ToUpper(s1[i]) <> ToUpper(s2[i]) then begin            Match := false;            goto 1;            end; {if}      end {if}   else      Match := false;   1:   end; {Match}begin {Insert}sPtr := symbols;                          {try to find the symbol}while sPtr <> nil do begin   if Match(token, sPtr^.symbol) then      goto 1;   sPtr := sPtr^.next;   end; {while}new(sPtr);                                {none exists: create a new entry}sPtr^.next := symbols;symbols := sPtr;sPtr^.symbol := token;sPtr^.lines := nil;1:new(lPtr);                                {enter the line number}lPtr^.next := sPtr^.lines;sPtr^.lines := lPtr;lPtr^.number := tokenLine;end; {Insert}procedure PrintSymbols;{ Print the symbols found and line numbers                        }{                                                                 }{ Variables:                                                      }{    symbols - pointer to the first entry in the symbol table     }var   sPtr: symbolPtr;                       {current symbol pointer}   procedure PrintNumber (nPtr: linePtr);   { Recursively print the line numbers in reverse order          }   {                                                              }   { Parameters:                                                  }   {    nPtr - pointer to the remainder of the line number list   }   begin {PrintNumber}   if nPtr <> nil then begin      PrintNumber(nPtr^.next);      write(nPtr^.number:1, ' ');      end; {if}   end; {PrintNumber}begin {PrintSymbols}sPtr := symbols;while sPtr <> nil do begin   write(sPtr^.symbol:16, '  ');   PrintNumber(sPtr^.lines);   writeln;   sPtr := sPtr^.next;   end; {while}end; {PrintSymbols}beginsymbols := nil;                           {nothing in the symbol table}lineNumber := 1;                          {first line}ch := ' ';                                {initialize the scanner}GetFileName(fName);                       {get the file name}if length(fName) <> 0 then begin   ReadFile(fName, fPtr, fLength);        {read the file}   fPtr := pointer(ord4(fPtr)-1);         {scanner will skip to 1st char}   if fPtr <> nil then begin      repeat                              {find all of the symbols}         GetToken;         if length(token) <> 0 then            Insert;      until length(token) = 0;      PrintSymbols;                       {print the symbols}      end; {if}   end; {if}end.