{ XREF                                                          }{                                                               }{ This program generates a cross reference of a Pascal program, }{ showing where any symbol is used.  To use XREF, start by      }{ selecting the shell window.  Type                             }{                                                               }{    xref filename                                              }{                                                               }{ where filename is the name of the program you want to cross-  }{ reference.                                                    }program ReadFile (input, output);uses Common, ProDOS, MemoryMgr;const   fNameLength = 64;                      {max length of a file name}   symbolLength = 80;                     {max length of a symbol}type   bytePtr = ^byte;                       {pointer into the file buffer}   fNameType = string[fNameLength];       {type of a file name}   tokenType = string[symbolLength];      {type of a symbol name}   linePtr = ^lineRecord;                 {line number list}   lineRecord = record      next: linePtr;      number: integer;      end;   symbolPtr = ^symbolRecord;             {symbol table entry}   symbolRecord = record      left,right: symbolPtr;      symbol: string[symbolLength];      reservedWord: boolean;      lines: linePtr;      end;var   ch: char;                              {current character}   fLength: longint;                      {length of the file}   fName: fNameType;                      {file name}   fPtr: bytePtr;                         {file pointer}   lineNumber: integer;                   {current line number}   symbols: symbolPtr;                    {symbol table}   token: tokenType;                      {current token}   tokenLine: integer;                    {line number at start of token}procedure GetFileName (var fName: fNameType);{ Read a file name from the command line.  If none is given,   }{ prompt for one.  Return a null string if no name is given    }{ when a name is asked for.                                    }{                                                              }{ Parameters:                                                  }{    fName - the file name is returned here                    }var   cline: string[255];                    {command line}   i,j: integer;                          {string indices}   procedure SkipBlanks;   { Skip blanks in the command line                           }   begin {SkipBlanks}   while (i < length(cline)) and (cline[i] = ' ') do      i := i+1;   end; {SkipBlanks}begin {GetFileName}CommandLine(cline);                       {read the command line}i := 1;SkipBlanks;                               {skip leading blanks}while (i < length(cline))                 {skip the program name}   and (cline[i] <> ' ') do   i := i+1;SkipBlanks;                               {skip to the file name}if i >= length(cline) then begin          {if needed, prompt for a name}   write('File to cross reference: ');   readln(cline);   i := 1;   SkipBlanks;   end; {if}if i <= length(cline) then begin   j := 0;                                {read the file name}   while (j < fNameLength)      and (i <= length(cline))      and (cline[i] <> ' ') do begin      j := j+1;      fName[j] := cline[i];      i := i+1;      end; {while}   fName[0] := chr(j);                    {set the length}   SkipBlanks;                            {check for extra input}   if i <= length(cline) then      writeln('Extra input ignored');   end {if}else   fName := '';                           {return a null string}end; {GetFileName}procedure ReadFile (var fName: fNameType; var ptr: bytePtr;                    var flength: longint);{ Read a file from disk                                        }{                                                              }{ Parameters:                                                  }{    fName - file name to load                                 }{    ptr - return a pointer to the 1st char in the file        }{    flength - length of the file, in characters (also bytes)  }label 99;var   openRec: openDCB;                      {ProDOS records}   eofRec: eofDCB;   readRec: readWriteDCB;   closeRec: closeDCB;   fileHandle: handle;                    {file handle}   procedure Error(err: integer; close: boolean);   { Flag a ProDOS disk error                                  }   {                                                           }   { Parameters:                                               }   {    err - error number                                     }   {    close - close the file?                                }   begin {Error}   writeln('ProDOS error ', toolerror:1, ' processing ', fname);   if close then      P16Close(closeRec);   goto 99;   end; {Error}begin {ReadFile}ptr := nil;                               {assume we will get an error}flength := 0;openRec.pathName := @fName;               {open the file}openRec.reserved := 0;P16Open(openRec);if toolerror = 0 then begin   closeRec.refNum := openRec.refNum;     {get ready for a close}   eofRec.refNum := openRec.refNum;       {find the length of the file}   P16Get_EOF(eofRec);   if toolerror <> 0 then      Error(toolerror, true);   flength := eofRec.fileSize;   if flength <> 0 then begin                                          {get some memory file the file}      fileHandle := NewHandle(flength, UserID, $C000, nil);      if toolerror <> 0 then         Error(toolerror, true);      readRec.refNum := eofRec.refNum;    {read the file}      readRec.dataBuffer := pointer(fileHandle^);      readRec.requestCount := flength;      P16Read(readRec);      if toolerror <> 0 then         Error(toolerror, true);      ptr := bytePtr(fileHandle^);        {set the file pointer}      P16Close(closeRec);                 {close the file}      end; {if}   end {if}else   Error(toolerror, false);99:end; {ReadFile}procedure GetToken;{ Read a word from the source file                                }{                                                                 }{ Variables:                                                      }{    fPtr - pointer to the next character in the file             }{    fLength - number of characters left in the file              }{    lineNumber - current line number                             }{    token - string read                                          }{    tokenLine - line number at the start of the token            }var   len: integer;                          {length of the string}   tPtr: ^byte;                           {used for 1 char look-ahead}   procedure NextCh;   { Get the next character from the file, skipping comments      }      procedure GetCh;      { get the next character from the file                      }      begin {GetCh}      if fLength = 0 then         ch := chr(0)      else begin         fPtr := pointer(ord4(fPtr)+1);         fLength := fLength-1;         ch := chr(fPtr^);         end; {else}      end; {GetCh}      procedure SkipComment;      { Skip comments in the program                              }      begin {SkipComment}      repeat         GetCh;         if ch = '*' then begin            GetCh;            if ch = ')' then               ch := '}';            end; {if}      until ch in ['}', chr(0)];      end; {SkipComment}   begin {NextCh}   GetCh;                                 {get the next character}   if ch = chr(13) then                   {handle the end of a line}      lineNumber := lineNumber+1   else if ch = '{' then                  {skip comments}      SkipComment   else if ch = '(' then begin      tPtr := pointer(ord4(fPtr)+1);      if chr(tPtr^) = '*' then begin         GetCh;         GetCh;         SkipComment;         end; {if}      end; {else if}   end; {NextCh}begin {GetToken}len := 0;                                 {no token, yet}if fLength <> 0 then begin                                          {skip to the next token}   while not (ch in ['a'..'z','A'..'Z','_',chr(0)]) do      NextCh;   tokenLine := lineNumber;               {record the line number}                                          {record the token}   while ch in ['a'..'z','A'..'Z','_','0'..'9'] do begin      if len < symbolLength then begin         len := len+1;         token[len] := ch;         end; {if}      NextCh;      end; {while}   end; {if}token[0] := chr(len);                     {set the length of the string}end; {GetToken}procedure Insert (reserved: boolean);{ Insert a symbol use in the symbol table.  If the symbol does    }{ not exist, create a new entry.                                  }{                                                                 }{ Parameters:                                                     }{    reserved - is this a reserved word? (else a symbol)          }{                                                                 }{ Variables:                                                      }{    tokenLine - line number at the start of the token            }{    token - symbol to insert                                     }{    symbols - pointer to the first entry in the symbol table     }var   lPtr: linePtr;                         {current line number pointer}   sPtr: symbolPtr;                       {current symbol pointer}   function FindSymbol (var ptr: symbolPtr): symbolPtr;   { Find a symbol; create one if none exists                     }   {                                                              }   { Parameters:                                                  }   {    ptr - pointer to the next symbol to check                 }   {                                                              }   { Returns:                                                     }   {    a pointer to the symbol table entry                       }   {                                                              }   { Variables:                                                   }   {    token - name of the symbol to find                        }   var      test: integer;                      {result of the string compare}      tPtr: symbolPtr;                    {symbol to return}      function Compare (s1, s2: tokenType): integer;         { Do a case insensitive compare of two strings              }      {                                                           }      { Parameters:                                               }      {    s1,s2 - strings to compare                             }      {                                                           }      { Returns:                                                  }      {    -1   if s1 < s2                                        }      {     0   if s1 = s2                                        }      {     1   if s1 > s2                                        }         label 1;         var         c1, c2: char;                    {uppercase characters}         i: integer;                      {loop variable}         len: integer;                    {length of the smallest string}               function ToUpper(ch: char): char;            { Return the uppercase equivalent of ch                  }            begin {ToUpper}         if ch in ['a'..'z'] then            ch := chr(ord(ch)-ord('a')+ord('A'));         ToUpper := ch;         end; {ToUpper}            begin {Compare}      len := length(s1);                  {find the length of the shorter string}      if length(s2) < len then         len := length(s2);      for i := 1 to len do begin          {check the characters}         c1 := ToUpper(s1[i]);         c2 := ToUpper(s2[i]);         if c1 < c2 then begin            Compare := -1;                {handle s1 < s2}            goto 1;            end {if}         else if c1 > c2 then begin            Compare := 1;                 {handle s1 > s2}            goto 1;            end; {else if}         end; {for}      if length(s1) < length(s2) then     {characters match - check lengths}         Compare := -1      else if length(s1) > length(s2) then         Compare := 1      else         Compare := 0;      1:      end; {Compare}   begin {FindSymbol}   if ptr = nil then begin      new(tPtr);                         {none exists: create a new entry}      with tPtr^ do begin         left := nil;         right := nil;         symbol := token;         lines := nil;         reservedWord := reserved;         end; {with}      ptr := tPtr;      end {if}   else begin      test := Compare(token, ptr^.symbol); {compare the token to this entry}      if test < 0 then         tPtr := FindSymbol(ptr^.left)    {too big: move left}      else if test > 0 then         tPtr := FindSymbol(ptr^.right)   {too small: move right}      else         tPtr := ptr;                     {else just right: return ptr}      end; {else}   FindSymbol := tPtr;   end; {FindSymbol}begin {Insert}sPtr := FindSymbol(symbols);              {find or create a symbol}if not reserved then begin                {for symbols, record the line}   new(lPtr);                             {enter the line number}   lPtr^.next := sPtr^.lines;   sPtr^.lines := lPtr;   lPtr^.number := tokenLine;   end; {if}end; {Insert}procedure PrintSymbols (ptr: symbolPtr);{ Print the symbols found and line numbers                        }{                                                                 }{ Parameters:                                                     }{    ptr - pointer to the current entry in the symbol table       }   procedure PrintNumber (nPtr: linePtr);   { Recursively print the line numbers in reverse order          }   {                                                              }   { Parameters:                                                  }   {    nPtr - pointer to the remainder of the line number list   }   begin {PrintNumber}   if nPtr <> nil then begin      PrintNumber(nPtr^.next);      write(nPtr^.number:1, ' ');      end; {if}   end; {PrintNumber}begin {PrintSymbols}if ptr <> nil then begin   PrintSymbols(ptr^.left);   if not ptr^.reservedWord then begin      write(ptr^.symbol:16, '  ');      PrintNumber(ptr^.lines);      writeln;      end; {if}   PrintSymbols(ptr^.right);   end; {if}end; {PrintSymbols}procedure InitReservedWords;{ Record the reserved words in the symbol table.                  }{                                                                 }{ Note: The reserved words are entered in a strange order to      }{ balance the binary tree used by Insert.                         }begin {InitReservedWords}token := 'nil';                 Insert(true);token := 'file';                Insert(true);token := 'div';                 Insert(true);token := 'begin';               Insert(true);token := 'array';               Insert(true);token := 'and';                 Insert(true);token := 'const';               Insert(true);token := 'case';                Insert(true);token := 'else';                Insert(true);token := 'downto';              Insert(true);token := 'do';                  Insert(true);token := 'end';                 Insert(true);token := 'implementation';      Insert(true);token := 'goto';                Insert(true);token := 'function';            Insert(true);token := 'for';                 Insert(true);token := 'if';                  Insert(true);token := 'label';               Insert(true);token := 'interface';           Insert(true);token := 'in';                  Insert(true);token := 'mod';                 Insert(true);token := 'string';              Insert(true);token := 'procedure';           Insert(true);token := 'or';                  Insert(true);token := 'of';                  Insert(true);token := 'not';                 Insert(true);token := 'packed';              Insert(true);token := 'otherwise';           Insert(true);token := 'repeat';              Insert(true);token := 'record';              Insert(true);token := 'program';             Insert(true);token := 'set';                 Insert(true);token := 'until';               Insert(true);token := 'type';                Insert(true);token := 'to';                  Insert(true);token := 'then';                Insert(true);token := 'univ';                Insert(true);token := 'unit';                Insert(true);token := 'while';               Insert(true);token := 'var';                 Insert(true);token := 'uses';                Insert(true);token := 'with';                Insert(true);end; {InitReservedWords}beginsymbols := nil;                           {nothing in the symbol table}lineNumber := 1;                          {first line}ch := ' ';                                {initialize the scanner}InitReservedWords;                        {record the reserved words}GetFileName(fName);                       {get the file name}if length(fName) <> 0 then begin   ReadFile(fName, fPtr, fLength);        {read the file}   fPtr := pointer(ord4(fPtr)-1);         {scanner will skip to 1st char}   if fPtr <> nil then begin      repeat                              {find all of the symbols}         GetToken;         if length(token) <> 0 then            Insert(false);      until length(token) = 0;      PrintSymbols(symbols);              {print the symbols}      end; {if}   end; {if}end.