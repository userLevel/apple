{ A simple, recursive descent expression evaluator.  This       }{ program handles +, -, * and /, as well as parenthesis.  All   }{ operations are integer operations.                            }program Expression (input, output);type                                        {tokens in an expression}   tokenType = (add,subtract,multiply,divide,int,lparen,rparen,eol);var   ch: char;                            {last char read by GetCh}   index: integer;                      {index into str}   str: string[80];                     {string read from the keyboard}   token: tokenType;                    {last token read}   tokenValue: integer;                 {value of last integer token}   procedure GetToken;   { Read a token from the input string                         }      procedure GetCh;      { Read the next character from str                        }      {                                                         }      { Variables:                                              }      {    ch - char read; chr(0) if at the end of the string   }      {    index - index into str                               }      {    str - string to read the character from              }      begin {GetCh}      if index >= length(str) then         ch := chr(0)      else begin         index := index+1;         ch := str[index];         end; {else}      end; {GetCh}   begin {GetToken}   while ch = ' ' do                    {skip to the first real character}      GetCh;   if ch = chr(0) then      token := eol                      {handle an end of line}   else if ch = '+' then begin      token := add;                     {handle add}      GetCh;      end {else if}   else if ch = '-' then begin      token := subtract;                {handle subtract}      GetCh;      end {else if}   else if ch = '*' then begin      token := multiply;                {handle multiply}      GetCh;      end {else if}   else if ch = '/' then begin      token := divide;                  {handle divide}      GetCh;      end {else if}   else if ch = '(' then begin      token := lparen;                  {handle ( }      GetCh;      end {else if}   else if ch = ')' then begin      token := rparen;                  {handle ) }      GetCh;      end {else if}   else if ch in ['0'..'9'] then begin      token := int;                     {handle a number}      tokenValue := 0;      while ch in ['0'..'9'] do begin         tokenValue := tokenValue*10 + ord(ch)-ord('0');         GetCh;         end; {while}      end {else if}   else begin                           {handle bad input}      writeln('"', ch, '" is an illegal character');      GetCh;      end; {else}   end; {GetToken}   function Expression: integer;   { Evaluate an expression                                     }   var      value, newValue: integer;         {values from Factor}      operation: tokenType;             {type of the operation}      function Factor: integer;         { Do multiplies and divides                               }         var         value, newValue: integer;      {values from Term}         operation: tokenType;          {type of the operation}         function Term: integer;         { Handle a number or parenthesis                       }         begin {Term}         if token = int then begin            Term := tokenValue;         {handle an integer}            GetToken;            end {if}         else if token = lparen then begin            GetToken;                   {skip the ( }            Term := Expression;         {evaluate the expression}            if token = rparen then      {skip the ) }               GetToken            else               writeln(') expected');            end; {else}         end; {term}         begin {Factor}      value := Term;                    {get the first value}      while token in [multiply,divide] do begin         operation := token;            {skip the operation}         GetToken;         newValue := Term;              {get the second value}         if operation = multiply then   {do the operation}            value := value*newValue         else            value := value div newValue;         end; {while}      Factor := value;                  {return the result}      end; {Factor}   begin {Expression}   value := Factor;                     {get the first value}   while token in [add,subtract] do begin      operation := token;               {skip the operation}      GetToken;      newValue := Factor;               {get the second value}      if operation = add then           {do the operation}         value := value+newValue      else         value := value-newValue;      end; {while}   Expression := value;                 {return the result}   end; {Expression}beginrepeat   write('Expression: ');   readln(str);   if length(str) <> 0 then begin      ch := ' ';      index := 0;      GetToken;      writeln('The value is ', Expression:1);      writeln;      end; {if}until length(str) = 0;end.