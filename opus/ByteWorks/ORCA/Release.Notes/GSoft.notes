GSoft BASIC 1.2.0Copyright 1999, Byte Works Inc.This document describes changes and error corrections made to GSoft BASIC after the 1.0 manual was created.The name of the first or principle person to report a problem or bug is listed in parenthesis after the description. Thanks for taking the time to report these problems and make these suggestions!Contents--------New Features Introduced in GSoft BASIC 1.2.0   RENUMBER Parameters are Optional   Control of CTRL-C Stops and CTRL-S Pauses   Control of Tool Shutdown Errors   Named Labels   Early Exit from Loops   Type Characters Allowed in Tool Interfaces   New Function: HEX$New Features Introduced in GSoft BASIC 1.1.0   PRINT Works With Graphics   Global Variables   Constants   Control Automatic Dimensioning of Variables   Tool CallbacksManual ErrataBugs From Version 1.0.0 That Are Fixed in Version 1.1.0Bugs From Version 1.1.0 That Are Fixed in Version 1.2.0-- New Features Introduced in GSoft BASIC 1.2.0 -------------------------------RENUMBER Parameters are Optional--------------------------------RENUMBER [first [',' [step] [',' [start] [',' [end]]]]]   All numbers for a RENUMBER command are now optional.   If a value is omitted, the assumed value is:    parameter value    --------- -----    first     10    step      10    start     0    end       65535(Peter Watson)Control of CTRL-C Stops and CTRL-S Pauses-----------------------------------------   You can stop a running program with CRTL-C, ESC or Command-., and you can pause a running program with CTRL-S.  While that's useful while developing or debugging a program, it's not something that should happen in a completed program.  GSoft BASIC now supports an option to turn this feature on or off.  The syntax is:      PRAGMA STOPS '=' ( "ON" | "OFF" )   The default is ON, which allows these keys to stop or pause a program.  When this option is OFF, these keys are still trapped by the keyboard input routine used by INPUT and GET, but the result is ignored completely.  Desktop programs can read these keys, since they normally use the Event Manager to handle the keyboard instead of the GSoft BASIC INPUT routine.(Jeff Fink)Control of Tool Shutdown Errors-------------------------------   GSoft BASIC watches tool startup calls and issues a warning message if your program exits without shutting down all of the tools it started.  This check is inapropriate in at least two situations:   1. It is possible for a desk accessory, Init or Finder Extension to start a tool while a GSoft BASIC program is running.  GSoft BASIC will see this tool startup, but since your program did not start the tool, it is not responsible for shutting it down.   2. Your program may have some reason for starting a tool but not shutting the tool down.   A new pragma allows you to control whether the tool shutdown checks are made.  If you turn TOOLCHECKS off, GSoft BASIC does not print warning messages indicating that a tool was not shut down.  It also does not shut down tools that have been started but not shut down.      PRAGMA TOOLCHECKS '=' ( "ON" | "OFF" )(Peter Watson)Named Labels------------   The GOTO, GOSUB, ON-GOTO, ON-GOSUB and ONERR statements all support named labels.   Named labels are an alternative to the traditional numbered labels supported by BASIC.  A named label works the same way as a numbered label and a line number, but you can use meaningful text names for the labels.   Label names begin with an alphabetic letter or an underscore.  This letter is followed by zero to 254 additional letters, underscore characters, or digits.   To place a label on a line, follow the label name with a colon, as shown in the example.   GOTO THERE   PRINT "This line is not executed."   THERE: PRINT "Execution continues with this line."   There is one place where numbered labels are allowed but named labels are not, and that is the abreviated form of the IF statement.  For example,   IF X < 4 THEN 60branches to statement 60, but a named label cannot be used here because there is no reliable way to distinguish the named label from statements consisting of a single word, such as a tool call.  This is not a severe limitation, though, since the longer form of the statement still works.  Here's an example that does the same thing using the longer form.   IF X < 4 THEN GOTO THERE(Eric Shepherd)Early Exit from Loops---------------------   It is now legal to exit a loop early using GOTO.  This is supported primarily for the purpose of error exits.   In past versions of GSoft BASIC, exiting a FOR loop, WHILE-WEND loop, DO-LOOP statement, a bloxk IF-END IF statement or a CASE SELECT statement early generated an error.  For example, the following program ended with an error message stating that a FOR statement had ended without finding a NEXT.      FOR I = 1 to 10        IF I = 5 THEN GOTO 10      NEXT   10 REMThis program is now legal.   There is one limitation to this feature.  Internally, GSoft BASIC uses a stack to track these statements.  This stack has a limit, which imposes a maximum nesting limit on these statements of 10 nested control statements.  Normally you can place hundreds of control statements in a row with no problem, but exiting a loop early does not give GSoft BASIC a chance to remove the statement from this stack.  Because of this, we recommend that early exits from loops using a GOTO only be used inside subroutines (or functions), where exiting the subroutine will clean up the stack, and that the subroutine exit as soon after the GOTO is used as possible.(Eric Shepherd)Type Characters Allowed in Tool Interfaces------------------------------------------   Type characters are now allowed as the last character of identifiers in tool interface files compiled by CompileTool. For example, it is now possible to create a user tool that returns a string, and use $ as the last character of the function name, just like you see in built-in BASIC commands. Type characters can also be used on any other kind of identifier, including parameters, constants, types, and the fields or records.   The type characters allowed are ~, %, &, !, # and $.   The type character serves no purpose other than as a character in the identifier. You must still specify the type in the normal way. Of course, it is possible, although perverse, to use a type character on a function and then declare a completely different type for the variable.   There are places in tool interface files where a type character can follow a text word. Here is an example from GSoftTools.int:      Tool $04, $A8 FUNCTION CharWidth (Char) as %In situations like this you must put at least one space between "as" and "%" so CompileTool does not become confused and try to create the identifier as% from these two tokens.(Eric Shepherd)New Function: HEX$------------------HEX$ '(' expression ')'   Returns the result of the expression as a hexadecimal string.   The type of the expression determines the exact structure of the string returned, but the string is always an accurate reflection of the value's internal binary form represented as a string using hexadecimal numbers. The value is always shown with the most significant byte first, proceeding to the least significant byte.   Integer values are returned as a four character string. For example, HEX$(100) returns "0064".   Long integer values are returned as an eight character string. For example, HEX$(-100000) returns "FFFE7960".   All foating-point numbers are stored using the IEEE format for floating-point numbers. See "Apple Numerics Manual" for a detailed description of the format. Single-precision floating-point values are returned as an eight character string. For example, HEX$(1.0) returns "3F800000".   Double-precision floating-point values are returned as a sixteen character string. For example, HEX$(1d0) returns "3FF0000000000000".   All pointers are converted to long integers before conversion. Bytes are converted to integers before conversion.(Eric Shepherd)-- New Features Introduced in GSoft BASIC 1.1.0 -------------------------------PRINT Works With Graphics-------------------------   The PRINT command and other text output commands now print to the graphics screen as well as the text screen. This makes it easy to write text to windows or even to the graphics screen of a program that uses HGR and other BASIC commands to draw simple graphics.   When QuickDraw II is active and the Super High Resolution Graphics Page is visible, text is written using the QuickDraw II command DrawChar rather than by writing the character to the text screen. The only formatting character that is respected is the end of line mark (CHR$(13)), which causes the next character written to appear at the start of a new "line." This means the next character appears lower than the previous one by an amount equal to the ascent, descent and leading amount for the current font and with a horizontal coordinate equal to the horizontal coordinate when the first character was written.   With some limitations, you can set the starting position for text and the remaining text output will start new lines in a sensible way. When the first character is written, the output routine records the pen position and uses this position as the position of the first line. If you move the pen using MoveTo (or any other command that moves the pen) and print more text, the output routine detects the move and uses the position you set as a new starting position. The only limitation is that the position must differ from the previous pen position. A foolproof way to make sure the starting position is set is the following:		MOVETO(H% + 1, V%)		PRINT " "		MOVETO(H%, V%)   Scrolling is not supported in any way.   Text input is not supported on the graphics screen. Characters written during text input still appear on the text screen.(Eric Shepherd)Global Variables----------------   There is now a way to create variables that are global, allowing subroutines and functions to use and change the value of the variable without passing the variable as a parameter.   Any variable or constant that appears in the main program can be accessed from any subroutine by using the SHARED statement. The SHARED statement tells GSoft BASIC to use the variable by the same name in the program rather than creating a new, local variable. The syntax for the SHARED command is:      SHARED identifier [ '(' ')' ] [ ',' identifier [ '(' ')' ] ]*   For example, this simple program prints the values 2 and 3, since the variable I is shared by the subroutine:      I = 1      CALL TEST      I = I + 1      PRINT I      END      SUB TEST      SHARED I      I = I + 1      PRINT I      END SUB   This program is almost identical, but does not use SHARED to access the variable I from the main program. In this case, the subroutine TEST creates a local variable by the same name that has nothing to do with the global variable. This program prints the values 1 and 2.      I = 1      CALL TEST      I = I + 1      PRINT I      END      SUB TEST      SHARED I      I = I + 1      PRINT I      END SUB   You can share any kind of variable, including an array. Since you can create an array and a non-array with the same name, though, SHARED needs some way to distinguish between the two. Just as with passed parameters, if you are sharing an array, follow the name with an open and close parenthesis, like this:      SHARED A()Do not include a subscript, and do not include commas between the parenthesis, even if the array uses more than one subscript. The number of subscripts and the maximum allowed subscript value are detected automatically, and will be the same as the number of subscripts and maximum allowed subscripts for the array in the main program.   You can share several variables with a single SHARED command by separating the variable names with commas, as in      SHARED I, J, A()   A shared variable must exist in the main program. If you try to share a variable that does not exist, the program stops with the error "Undefined variable."   You can share variables and constants, but not types or functions defined with DEF FN. Types are already available throughout the program anyway, so there is no need to share a type. If you try to share a type or a function defined with DEF FN, the program stops with the error "Types cannot be SHARED."(Eric Shepherd)Constants---------   You can create constants that work and act like variables, but cannot be changed.   The syntax for the CONST statement is:      CONST identifier = expressionIn almost every way, this statement works exactly like the statement      LET identifier = expressionLike the LET statement, a variable whose name is given by the identifier is created, the expression is evaluated, and the value of the expression is assigned to the new variable. There are, however, three important differences.   First, a variable created by the CONST statement can never be changed. It is protected from all attempts to assign a new value. If you try to assign a new value, the program will stop with the error "Misuse of a constant." In one situation, you will get this error even if the variable is not actually changed. You cannot pass a CONST to a subroutine or function as a variable parameter, since that would allow the subroutine or function to change the value. When passing a constant, always remember to enclose the name in parenthesis so it is passed as a value, like this:      CONST RED = 1      CALL MYSUBROUTINE (4, (RED))   Next, a variable created by the CONST statement can't already exist.Finally, CONST can be used to create any simple numeric variable and any string variable, as the examples below show, but you cannot create arrays or records.   Here are a few examples of constant statements:      CONST MAXINDEX% = 30      CONST PI = 3.1415926535      CONST FILENAME$ = "/disk/folder/file"(Eric Shepherd)Control Automatic Dimensioning of Variables-------------------------------------------   While being able to use a variable without DIMensioning it is a handy feature for quick hacks, it often leads to subtle bugs in longer programs. A classic example is misspelling a variable name, only to have BASIC create a new variable with the misspelled name, automatically assigning the new variable a value of 0. This can be a very difficult bug to locate!   GSoft BASIC now supports an option to turn this feature on or off. The syntax is:      PRAGMA AUTODIM '=' ( "ON" | "OFF" )   The default is ON, which allows variables to be dimensioned automatically when encountered in a program. When this option is OFF, all variables must be declared in a DIM or CONST statement, or as a parameter, before being used.   For example, this program will stop with an error rather than looping an incorrect number of times:      PRAGMA AUTODIM = OFF      CONST LAST% = 10      DIM I%, SUM      FOR I% = 1 TO LAST         SUM = SUM + I%      NEXT      PRINT "The sum of all numbers from 1 to "; I%; " is "; SUMTool Callbacks--------------   Tool callbacks, such as the window draw routine called by TaskMaster up update a window, present a special problem for an interpreter, since the tools cannot call interpreted code directly.   The solution is similar to Apple's method used on Power PC computers: To create a callback the tools can use, you pass the name of the interpreted subroutine to a new command, ALLOCATEPROC. This command returns a pointer that is type compatible with the type procPtr, declared in GSoftTools.int. This value can be passed to the tools. The syntax for ALLOCATEPROC is:      ALLOCATEPROC "(" identifier ")"   The callback procedure created by ALLOCATEPROC must be disposed of when you are finished with the callback. Use DISPOSEPROC to dispose of the callback.      DISPOSEPROC "(" expression ")"   A typical sequence would look like this: In the program's initialization code, you would create the callback.      DIM PROC AS PROCPTR      PROC = ALLOCATEPROC(DRAW) : ! DRAW is a BASIC subroutine   PROC is then passed to NewWindow2 when windows are created. The tools call DRAW to draw the contents of the window. When the program shuts down, dispose of the callback like this:      DISPOSEPROC(PROC)   For an example, see Draw.bas in the :GSoft:Samples:Desktop.Samples folder.-- Manual Errata --------------------------------------------------------------This errata details omissions and factual errors. While we would like to hear about any grammatical errors or typographical errors you find so we can improve our manuals, they are not listed here.1. p. 7: The list of command lines for the SysCmnd file shown in the next to last paragraph should include     DETOKE        *U                       GSoft BASIC tokenized file converter2. p. 36: The list of command lines for the SysCmnd file shown above the heading ":GSoft:Shell:SysTabs" should include the line     COMPILETOOL   U                        GSoft BASIC Tool Compiler3. p. 51. All numbers for a RENUMBER command are now optional. Because of this change, the correct model line for the RENUMBER command is   RENUMBER [first [',' [step] [',' [start] [',' [end]]]]]If a value is omitted, the assumed value is:    first     10    step      10    start     0    end       655354. p. 87. The description of the string data type should note that the maximum number of characters allowed in a single string is 32767.5. p. 87. In the second paragraph of the description of pointers, the text says that NULL is the name of a special pointer that points to nothing. This should be NIL, not NULL.6. p. 93. In the code snippet, the line    DIM MAILLIST AS ADDRESS(500)should read    DIM MAILLIST(500) AS ADDRESS7. pp. 112: The two lines of the sample that read    PRINT_LOGICAL(L OR 0)    PRINT_LOGICAL(L% OR 0)are missing CALL commands. They should read:    CALL PRINT_LOGICAL(L OR 0)    CALL PRINT_LOGICAL(L% OR 0)8. p. 142: The model line for MID$ should show the third parameter is optional.  It should read:   MID$ '(' string-expression ',' expression [ ',' expression ] ')'Add to the description of MID$:   "The last parameter is optional.  If it is omitted, all of the characters from the position identified by the second parameter to the end of the string are returned."9. p. 147: Delete the sentences:   "It is also illegal to jump out of a DO loop without completing it; this leaves incomplete DO statements in an internal stack, and will generate an error when you exit the program. It can also cause the stack to overflow, generating a different message."10. p. 150: Delete the sentences:   "It is also illegal to jump out of a FOR loop without completing it; this leaves incomplete FOR statements in an internal stack, and will generate an error when you exit the program. It can also cause the stack to overflow, generating a different message."   "It is also illegal to jump out of a WHILE loop without completing it; this leaves incomplete WHILE statements in an internal stack, and will generate an error when you exit the program. It can also cause the stack to overflow, generating a different message."11. pp. 152: The description of the block IF-THEN-ELSE command should include a note about a restriction. You cannot put any other statement on the line after the THEN. GSoft BASIC needs to know if the IF-THEN statement is a classic IF-THEN, with everything on one line, or a block IF-THEN, with an END IF and possibly an ELSE later in the program. It looks to see if there is anything after the THEN to tell the difference. If there is a statement after THEN, the line is treated as a classic IF-THEN statement; if nothing follows the THEN, GSoft BASIC looks for an ELSE or END IF later in the program.12. pp. 216: The text for the VERSION function does not explicitly state the number of digits used for each field of the version number. The format is:    mmiibbrvvwhere    mm    Two digit major version number.    ii    Two digit minor version number.    bb    Two digit bug version number.    r     One digit release type.    vv    Two digit release version.So, for example, VERSION returns the number 10203304 for the beta release 1.2.3 B4. Note that, while the major version is a two-digit field, leading zeros are not normally shown when you print a number, so the leading zero was not shown in the example value either.13. pp. 247: Error 21, "FOR without NEXT", is no longer used.  If you force this error with the ERROR statement it will print "Error 21".14. pp. 249: Add the following errors to the list of error messages. These errors were added in the 1.1 release.79   Undefined variable   An attempt was made to share a variable using SHARED, but no variable by that name existed in the main program.   Keep in mind that the main program might create the variable, but if the variable isn't created until after the subroutine containing the SHARED command is executed, this error will still be flagged. The best way to avoid this situation is to get in the habit of DIMing all variables at the beginning of the program.   Another possible problem is a spelling error. Make sure the variable named match exactly; if the variable in the main program ends with %, for example, the SHARED variable name must also end with %. If the variable in the main program is an array, the SHARED variable name must be followed with the characters ().   This error can also be generated when the      PRAGMA AUTODIM = OFFstatement has been used to turn off automatic dimensioning of variables. In this case, be sure to dimension the variable with a DIM statement. Keep in mind that scalars can be dimensioned. For example, the statement      DIM I%, Screates two variables, an integer named I% and a single-precision floating-point variable named S. Both are initialized to 0.80   Types cannot be SHARED   An attempt was made to share a type or DEF FN function using a SHARED statement.   You can't share types or DEF FN functions. Types are already accessible in a subroutine or function without using SHARED.81   CONST values must be simple variables   An attempt was made to create a constant that was an array or record. Constants must be simple values. This can include strings or any of the numeric types, but not arrays or records.15. p. 285: The description of DEL and LIST in the third paragraph should note that Applesoft BASIC allows the dash character in addition to the comma, but GSoft BASIC does not. For example,    DEL 10-20is allowed in Applesoft BASIC, but you must use    DEL 10,20in GSoft BASIC.16. p. 292: The first paragraph of the section "BASIC Tokens" refers to a section titled "File Organization and Organization in Memory." This should be "The Organization of Tokenized Programs." Also, this section appears earlier in the appendix, on page 291, not later in the appendix.17. p. 316: The model line for MID$ should show the third parameter is optional.  It should read:   MID$ '(' string-expression ',' expression [ ',' expression ] ')'-- Bugs From Version 1.0.0 That Are Fixed in Version 1.1.0 --------------------1. The resource fork could not be loaded in files executed from GSoft.Sys16 or the ORCA shell.(Eric Shepherd)2. In some situations, especially tight keyboard loops, it was possible for GSoft BASIC to eat characters entered from the keyboard.(Charles Hartley)3. VERSION is a reserved word, but it was also used in several places in GSoftTools.int. These uses have been changed to _Version.(Richard Cain)4. The GSoftTools.int file was left off of the distribution list.(Many people noticed this, but Glen Gunselman gets the brass ring for reporting it first.)5. Applesoft-style "IF-THEN statement" statements nested inside modern block IF-THEN statements caused errors.(John L. Graham)6. The RENUMBER command could fail in situations where the renumbered lines duplicated line numbers used before the RENUMBER command was invoked.(Mike Westerfield)7. CTRL-C did not stop listings or long CATALOG displays when the Event Manager was not is use.(Richard Bennett)8. If a create or modify date for a file was stamped as 2000 or later, the two digit year value printed in the CATALOG output was printed as a three digit number, with 100 added to the correct display value.(Mike Westerfield)9. When a resource fork was attached to a BASIC program, it was not loaded with the program and saved again by the save command. In version 1.1, the resource fork is loaded if one is attached to a GSoft BASIC tokenized file or an ORCA SRC file. If the input file is a TXT file or an Applesoft file, and resource fork found is ignored. The resource fork is saved when a GSoft BASIC tokenized file (SAVE command) or an ORCA source file (SSAVE command) is used. The resource fork is not saved when a text file (TSAVE command) is created.   There is some danger of unwanted resources creeping in. The ORCA editor attaches a resource to SRC files to record tab lines, cursor position, and other file related information. This resource will be picked up and copied by GSoft BASIC. There are several strategies for dealing with this situation. One is not to develop programs from the ORCA shell; this kind of resource will not be picked up by the GSoft shell. Another is to turn off the resource fork information. See the documentation for the ORCA editor to see how this is done. A final solution is to ignore the editor's resources until the program is complete, then delete the resource fork using the ORCA shell's COPY command or by doing a TSAVE, then loading the TXT file. Any resources you actually need can then be attached to the resource-less program.(Mike Westerfield)10. When a record declared in a tool header file contained a record field declared as "pointer to" something, the type was not handled correctly.(Mike Westerfield)11. When passing a UNIV parameter to a tool function, the actual value passed was a garbage value.(Mike Westerfield)12. In a desktop program, the error messages were still printed to the text screen, then the program generally crashed because the tools started by the BASIC program were not properly shut down.   GSoft BASIC now detects tool startup calls and user tool startup calls. With two exceptions that will be discussed below, when the program exits, GSoft BASIC checks to see if all of the tools that were started are also shut down. If the tool is not shut down, GSoft BASIC shuts it down. If the program is exiting normally (in other words, no error was detected up until this point) the first tool started that was not shut down is flagged as an error.   Two tools, the Memory Manager and the List Manager, are not shut down by Apple's own ShutdownTools call. This does not cause any particular problem, so GSoft BASIC does not track startup calls for these tools, nor does it shut them down if the application does not shut them down.   When GSoft BASIC shuts a tool down, it assumes nothing is passed to the tool's shutdown call. This assumption is valid for all of Apple's tools, and all of the third party tools and user tools I am aware of. If this assumption is not valid for a tool, and the program starts but does not shut down the tool, GSoft BASIC will try to shut the tool down without passing the required parameter--probably resulting in a crash.(Mike Westerfield)13. NIL was not type compatible with ptr parameters in tool calls.(Eric Shepherd)14. MakeRuntime created a bogus tool table whenever the total number of tools needed by a program caused the tool table to exceed 8K. In most cases, the failure would show up as a crash when the Finder-launchable GSoft BASIC application was executed, but it could also show up as a crash while MakeRuntime itself was executing.(Mike Westerfield)15. The constants TRUE and FALSE have been added to GSoftTools.int. Their values are 1 and 0, respectively.(Eric Shepherd)16. When a record declared in an interface file was used as the parameter type or function return type for a user-defined subroutine or function, the program failed when the procedure is called with an "Expected Type" error.(Eric Shepherd)17. In some situations, CompileTool started to fail repeatedly, even when the input file was completely valid, creating an empty output file. This problem was corrected by rebooting. The underlying problem was caused by a variable initialization error, which has been corrected in the 1.1 release.(Eric Shepherd)18. As a holdover from other header files, some tool calls were using a type for blocks of text that could be longer than 255 characters. GSoft BASIC doesn't need a special type for this situation. String or pointers to string have replaced all uses of the old text block type.(Eric Shepherd)19. The GSoftTools.int file did not have constants declared for the various resource types or for AlertWindow flags. These have been added.(Mike Westerfield & Eric Shepherd)20. In a tool that returned a pointer, like FrontWindow, the value was not placed on the expression stack correctly. Sometimes the program would appear to work, but with a slight change in the expression, like reordering the terms, the same program would fail.(Mike Westerfield)21. In several places, pointers to strings were not handled correctly. This included tool parameters (found by Eric) and type casting (found my Mike). The mechanism has been cleaned up so the address of a string variable or the value of a pointer to a string can always be passed as a parameter to a subroutine expecting a pointer to a sequence of characters.	Strings do present a special problem in BASIC, though, because of the way they are allocated, which differs from other languages. Because of these changes, there is one limitation on type casting. If you use type casting or the numeric conversion operations like CLNG to convert a string pointer to some other type, the result is a pointer or address of the first character of the string value. That's what you would expect in any language. The restriction is that the reverse operation cannot be performed: you cannot safely cast any pointer to the type POINTER TO STRING.(Mike Westerfield, Eric Shepherd)-- Bugs From Version 1.1.0 That Are Fixed in Version 1.2.0 --------------------1. GSoft BASIC 1.1 did not return an error if a tool function was used as if it were a subroutine, but the function value was also not removed from the expression stack. This would eventually fill the expression stack, resulting in an "Expression too complex" error.(Eric Shepherd)2. Turning off automatic dimensioning of variables inside a program survived normal termination of the program, causing some error message to change for commands used in the immediate execution mode.  AUTODIM is now reset to the default value of ON when a program terminates normally.This may cause problems in some circumstances.  Basically, the setting of AUTODIM is not garanteed after interrupting a program and restarting to with CONT or GOTO, or for immediate execution mode commands after a program has been stopped abnormally with STOP or CTRL-C.  If the setting of AUTODIM is important after these situations, don't use these commands, or do a full restart of the program or, for immediate execution mode commands, the GSoft shell to be sure the setting is correct.(Richard Cain)3. One of the parameters for NewList2 in GSoftDefs.int was a long. It should have been a univ.(Eric Shepherd)4. One of the parameters for GetCtlHandleFromID in GSoftDefs.int was a univ. It should have been a long.(Eric Shepherd)5. When QuickDraw II is started using direct calls to the toolbox rather than using HGR, HCOLOR and HPLOT fail with syntax errors.(Eric Shepherd)6. One of the things the HGR command does is clear the screen to black. When QuickDraw was started manually in 640 mode, HGR only cleared the left half of the screen.(Mike Westerfield)7. The SIZEOF operator returned an incorrect size for array types like cString from GSoftDefs.int.(Mike Westerfield)8. Type declarations that use array types from tool interface files, such as      DIM IPSTR AS CSTRINGdid not work.(Eric Shepherd)9. INPUT and READ didn't work when the variable is a BYTE variable.(Jeff Fink)10. When garbage collection occurred while a shared string variable or a shared string parameter passed by reference existed, the garbage collection routine trashed the string space, causing errors later in the program.(Mike Westerfield)11. The renumber command was broken by unrelated bug fixes just before the release of version 1.1.0.(Mike Westerfield)12. LINE INPUT should ignore quote marks in a string, but doesn't. If the entire line is quoted, the quote marks are removed. If the line starts with a quote mark bnut does not end with one, the program stops with a syntax error.For example, the program	10 LINE INPUT A$	20 PRINT A$should read and print any line of text exactly as typed, but failed for either of these lines:	"This is a test."	"This" should work.(Doug Cuff)13. Raising zero to a power, as in   X = 0   Y = 4   PRINT X^Yshould be allowed but resulted in NaN.(Jeff Fink)14. Sharing a variable that has the same name as a parameter, but where one is an array and the other is not, should be allowed, but was flagged as a duplicate variable error in version 1.1.(Peter Watson)15. The address operator failed when asked to return the address of an element of an array containing pointers to a simple type. Simple types include the predefined types BYTE, INTEGER, LONG, SINGLE, DOUBLE and STRING.(Mike Westerfield)16. Memory location $00008A was changed by the PRINT USING statement. This did not cause any known side effects.(Mike Westerfield)17. Using a function as a parameter to a subroutine or to a function that returned a different type of result caused an error.(Mike Westerfield)18. The PUT and GET commands can be used to write records to files and read them from files, but these commands failed to read and write records whose fields included string values.(Mike Westerfield)19. Fields were not correctly resolved for records containing arrays of records.(Geraldine A. Wright)