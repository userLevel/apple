/* A better sort than QuickSort                                 */#include <stdio.h>#include <stdlib.h>#define SIZE 100                        /* size of the array to sort */int a[SIZE];                            /* array to sort */void Fill (void)/* Fill an array                                                *//*                                                              *//* Variables:                                                   *//*    a - array to fill                                         */{int i;                                  /* loop variable */for (i = 0; i < SIZE; ++i)   a[i] = rand() % SIZE;}void Sort (int left, int right, int depth)/* Sort an array                                                *//*                                                              *//* Parameters:                                                  *//*    left - leftmost part of the array to sort                 *//*    right - rightmost part of the array to sort               *//*    depth - recursion depth                                   *//*                                                              *//* Variables:                                                   *//*    a - array to sort                                         */#define SHELLSIZE 19                    /* when a quick sort becomes faster */#define MAXDEPTH 100                    /* max recursion depth */{int i,j;                                /* array indices */int pivot;                              /* pivot value */int swap;                               /* was a value swapped? */int temp;                               /* used to swap values */if (((right - left) < SHELLSIZE) || (depth > MAXDEPTH)) {   do {                                 /* do a shell sort */      swap = 0;      for (i = left; i < right; ++i) {         if (a[i] > a[i+1]) {            temp = a[i];            a[i] = a[i+1];            a[i+1] = temp;            swap = 1;            }         }      }   while (swap);   }else {                                  /* do a quick sort */   if (right > left) {                  /* quit if there is only 1 element */      i = (left-1) + ((right-left+1) / 2); /* find the pivot index */      pivot = a[i];                     /* put the pivot at the end */      a[i] = a[right];                  /* (remember the pivot, too) */      a[right] = pivot;      i = left;                         /* set up the start indices */      j = right-1;      while (i != j) {                  /* partition the array */         while ((a[i] <= pivot) && (i != j))            ++i;         while ((a[j] >= pivot) && (i != j))            --j;         temp = a[i];         a[i] = a[j];         a[j] = temp;         }      if (a[i] < pivot)                 /* find the pivot insert point */         ++i;      temp = a[i];                      /* replace the pivot */      a[i] = a[right];      a[right] = temp;      Sort(left, i-1, depth+1);         /* sort to the left of the pivot */      Sort(i+1, right, depth+1);        /* sort to the right of the pivot */      }   }}void Print (void)/* Print the array                                              *//*                                                              *//* Variables:                                                   *//*    a - array to print                                        */{int i;for (i = 0; i < SIZE; ++i) {   printf("%4d", a[i]);   if ((i % 8) == 7)      printf("\n");   }}void main (void)/* main program                                                 */{srand(2345);                            /* initialize rand() */Fill();                                 /* fill the array */Sort(0, SIZE-1, 1);                     /* sort the array */Print();                                /* print the array */}