{$keep 'globals'}{------------------------------------------------------------------}{                                                                  }{ Globals - SpeakIts's global typs and variables.                  }{                                                                  }{ Written by Barbara Allred                                        }{                                                                  }{ Copyright 1991, Byte Works, Inc.                                 }{ Copyright 1987-1991, First Byte, Inc.                            }{                                                                  }{------------------------------------------------------------------}Unit Globals;interfaceuses   Common, DialogMgr, SFToolSet, GSOS, ControlMgr, MemoryMgr, TextEdit;{$LibPrefix '0/'}uses   Error;const   diskSwitchedErr =  $002E;            {System error constants}   volNotFoundErr  =  $0045;   fileNotFoundErr =  $0046;   maxWindows     =   10;               {user winds 0-9 + dict wind}   maxUserWindows =   9;                {allowing user windows 0-9}   dictWindNum    =   10;               {dict wind's index into array}   maxDCtls       =   15;               {# dict ctl hndls in rsrc fork}   maxListSize    =   $3FFF;            {max # members in dict list}   refIsPtr       =   0;                {Reference types}   refIsHndl      =   1;   refIsRsrc      =   2;   refIsSpecial   =   3;   startStopID    =   $00000001;        {Resource IDs}   menuBarID      =   $00000064;   appleMenuID    =   $00000001;   fileMenuID     =   $00000002;   editMenuID     =   $00000003;   speechMenuID   =   $00000004;   windowID       =   $00000006;   textEditID     =   $00000007;   dictWindID     =   $00000200;   dictCtlID      =   $00000201;   undoID         =   250;              {Menu item IDs}   cutID          =   251;   copyID         =   252;   pasteID        =   253;   clearID        =   254;   closeID        =   255;   aboutID        =   256;   newID          =   257;   openID         =   258;   saveID         =   259;   saveAsID       =   260;   pSetUpID       =   261;   printID        =   262;   quitID         =   263;   speakID        =   264;   phonID         =   265;   setID          =   266;   dictID         =   267;   activeID       =   268;   isDirty        =   $0040;            {mask to check dirty bit}type   windType = (textTyp, phonTyp, dictTyp); {window types}   dictControls = record      fnCtlHndl,                        {filename, static text}      listCtlHndl,                      {list control}      dontCare1,                        {window's title}      dontCare2,                        {phonetics prompt}      phonCtlHndl,                      {phonetics word, edit box}      dontCare3,                        {English word prompt}      englCtlHndl,                      {English word, edit box}      dontCare4,                        {word operations}      dontCare5,                        {add button}      dontCare6,                        {delete button}      dontCare7,                        {translate button}      dontCare8,                        {speak button}      dontCare9,                        {file operations}      dontCare10,                       {save button}      dontCare11,                       {load button}      dontCare12,                       {clear button}      dontCare13,                       {print button}      dontCare14: CtlRecHndl;           {exit button}      end;   dictCtlsPtr = ^dictControls;   windowRec = record      upFlag: boolean;                  {true if window is open}      fileFlag: boolean;                {true if wind assoc. with disk file}      windPtr: grafPortPtr;             {pointer to window's grafPort}      wNum: integer;                    {window's index in userWind array}      wName: packed array[0..17] of char; {window's title}      wPathName: gsosInStringPtr;       {pointer to window file's pathname}      wPathHandle: handle;              {handle to file's pathname, from SFO}      case wTyp: windType of         textTyp, phonTyp: (teHndl: teHandle);    {text edit control hndl}         dictTyp:          (dCtls:  dictCtlsPtr); {ptr to ctl hndl record}       end;   refConRec = record                   {track window #, window type}      case boolean of         true:  (long: longint);         false: (wNum: integer;                 wTyp: windType);      end;   hiLow = record                       {for type casting to extract hi and lo words}      case boolean of         true:  (long: longint);         false: (lo, hi: integer);      end;   windInfoRec = record      currWindow: grafPortPtr;          {front window's grafPort ptr}      currWindNum: integer;             {front window's #}      currWindTyp: windType;            {front window's type}      end;   gsosInString19 = record      size: integer;      name: packed array[1..19] of char;      end;   gsosInString15 = record      size: integer;      name: packed array[1..15] of char;      end;   minGSOSOutString = record      maxLength: integer;      currLength: integer;      end;   minPString = packed array[0..2] of char;   dialogTemplate2 = record             {expanded dialog template}      dtBoundsRect: rect;      dtVisible: boolean;      dtRefCon: longint;      dtItemList: array[1..15] of itemTempPtr;      end;var                                        {General variables}                                        {-----------------}   done: boolean;                       {true if user selects Quit}   numWindows: integer;                 {# currently open windows}   userWindows: integer;                {# open user windows}   userWind: array[0..maxWindows] of windowRec; {info to track windows}   dictCtls: dictControls;              {dict's control hndls}   myID: integer;                       {SpeakIt's user ID}   buffer: handle;                      {buffer for window's text}   bufferSize: longint;                 {size of this buffer}   textInfo: teInfoRec;                 {# chars/# lines in document}   listTempl: listControl;              {dict list control template}   nextEntry: integer;                  {entry #, next dict. element}   fileDName: gsosInString15;           {name when dict is from file}   dictChanged: boolean;                {true if dict. changed since saved}                                        {Common dialog button titles.}                                        {----------------------------}   okTitle: packed array[0..2] of char; {OK button's descriptor}   cancelTitle: packed array[0..6] of char; {Cancel button's descriptor}   yesTitle: packed array[0..3] of char; {Yes button's descriptor}   noTitle: packed array[0..2] of char; {No button's descriptor}                                        {Set parameters dialog data structures}                                        {-------------------------------------}   setParmsDlg: dialogTemplate2;        {Set parmaters dialog box}   maleParm: itemTemplate;              {Male voice radio button}   femaleParm: itemTemplate;            {Female voice radio button}   item02parm: itemTemplate;            {Set parameters title}   trebleParm: itemTemplate;            {Treble radio button}   bassParm: itemTemplate;              {Bass radio button}   item05parm: itemTemplate;            {Pitch edit line box}   item06parm: itemTemplate;            {Speed edit line box}   item07parm: itemTemplate;            {Volume edit line box}   item08parm: itemTemplate;            {title for Pitch edit box}   item09parm: itemTemplate;            {title for Speed edit box}   item10parm: itemTemplate;            {title for Volume edit box}   item11parm: itemTemplate;            {OK button}   item12parm: itemTemplate;            {Cancel button}   item00pointerparm: packed array[0..10] of char; {male btn's text}   item01pointerparm: packed array[0..12] of char; {female btn's text}   item02pointerparm: packed array[0..21] of char; {title text}   item03pointerparm: packed array[0..6]  of char; {treble btn's text}   item04pointerparm: packed array[0..4]  of char; {bass btn's text}   pitch: minPString;                   {pitch box's text}   speed: minPString;                   {speed box's text}   volume: minPString;                  {volume box's text}   item08pointerparm: packed array[0..5]  of char; {pitch btn's text}   item09pointerparm: packed array[0..5]  of char; {speed btn's text}   item10pointerparm: packed array[0..6]  of char; {volume btn's text}   PErrorAlert: alertTemplate;          {Set parameters error alert}   item00PErr: itemTemplate;            {Error message}   item01PErr: itemTemplate;            {OK button}   item00pointerPErr: packed array[0..30] of char; {actual msg}                                        {Data structures for GS/OS calls}                                        {-------------------------------}   options: optionListRecord;   openRec: openOSDCB;   readRec: readWriteOSDCB;   closeRec: closeOSDCB;   destroyRec: destroyOSDCB;   writeRec: readWriteOSDCB;   getFileInfoRec: getFileInfoOSDCB;   createRec: createOSDCB;   setEOFRec: setMarkOSDCB;function InitGlobals: boolean;implementation{---------------------------------------------------------------}{                                                               }{ InitGlobals - Initialize error unit.                          }{                                                               }{ Returns:  True if able to initialize; false otherwise.        }{                                                               }{---------------------------------------------------------------}function InitGlobals {:boolean};label 99;var   i: integer;begin {InitGlobals}InitGlobals := true;                    {assume all is well to start}{Allocate buffers to hold windows' text.}buffer := NewHandle(1024, myID, $8010, nil);if toolError <> 0 then begin   HandleError(toolError, memErr);   InitGlobals := false;   goto 99;   end; {if}bufferSize := 1024;{Initialize general global variables.}numWindows := 0;                        {no windows up yet}userWindows := 0;for i := 0 to maxUserWindows do   with userWind[i] do begin      upFlag := false;      fileFlag := false;      windPtr := nil;      wNum := 0;      wName := '                 ';      wPathName := nil;      wPathHandle := nil;      wTyp := textTyp;      teHndl := nil;      end; {with}with userWind[dictWindNum] do begin   upFlag := false;   fileFlag := false;   windPtr := nil;   wNum := dictWindNum;   wName := '                 ';   wPathName := nil;   wPathHandle := nil;   wTyp := dictTyp;   dCtls := @dictCtls;   end; {with}{Initialize GS/OS file handling data structures.}with options do begin   totalSize := 6;   requiredSize := 2;   end; {with}with openRec do begin   pCount := 15;   requestAccess := $0003;   resourceNumber := 0;   optionList := @options;   end; {with}with readRec do begin   pCount := 5;   cachePriority := 0;   end; {with}closeRec.pCount := 1;destroyRec.pCount := 1;with writeRec do begin   pCount := 5;   cachePriority := 0;   end; {with}with getFileInfoRec do begin   pCount := 12;   optionList := @options;   end; {with}with createRec do begin   pCount := 7;   access := $00C3;   fileType := 4;   auxType := 0;   storageType := 1;   dataEOF := 0;   resourceEOF := 0;   end; {with}with setEOFRec do begin   pCount := 3;   base := 0;   displacement := 0;   end; {with}{Initialize common dialog button titles.}okTitle := 'OK';cancelTitle := 'Cancel';yesTitle := 'Yes';noTitle := 'No';99:end; {InitGlobals}end. {Globals unit}