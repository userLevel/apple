{$keep 'SpeechCmds'}{------------------------------------------------------------------}{                                                                  }{ SpeechCmds - Commands to speak text and phonetics.               }{                                                                  }{ Written by Barbara Allred                                        }{                                                                  }{ Copyright 1991, Byte Works, Inc.                                 }{ Copyright 1987-1991, First Byte, Inc.                            }{                                                                  }{------------------------------------------------------------------}unit SpeechCmds;interfaceuses   Common, ToolLocator, DialogMgr, SFToolSet, GSOS, ControlMgr, MemoryMgr,   TextEdit, PrintMgr, WindowMgr, MenuMgr, SpeechTools, QuickDrawII, LineEdit;{$LibPrefix '0/'}uses   Globals, Error, MscCmds, FileCmds, DictCmds;procedure DoSetParameters;procedure DoShowPhonetics;procedure DoSpeak;procedure SetPhonWName (wNum: integer);function  InitSpeechCmds: boolean;implementationvar                                        {General speech variables}                                        {------------------------}   toolTbl: toolTable;                  {table of speech tools}                                        {Phonetics variables}                                        {-------------------}   phBuffSize: longint;                 {size of phonetics buffer}   phBuffer: handle;                    {handle to phonetics buffer}{used with expanded dialogs}function GetNewModalDialog2 (var dialog: dialogTemplate2): grafPortPtr;tool ($15, $32);{---------------------------------------------------------------}{                                                               }{ GetPhonetics - Call Text Edit's TEGetText routine to dump     }{                text into the phonetics buffer.                }{                                                               }{ Parameters:                                                   }{    size - size of text dumped                                 }{    wNum - front window's number                               }{                                                               }{ Returns:  True if text can be returned; false otherwise       }{                                                               }{                                                               }{ Global output:                                                }{    phBuffer   - handle to text                                }{    phBuffSize - size of buffer                                }{                                                               }{---------------------------------------------------------------}function GetPhonetics (var size: longint; wNum: integer): boolean;label 99;begin {GetPhonetics}GetPhonetics := true;   size := 0;{First call Text Edit's TEGetTextInfo to find the size of the window's text.}TEGetTextInfo(textInfo, 2, userWind[wNum].teHndl);if toolError <> 0 then begin   HandleError(toolError, teErr);   GetPhonetics := false;   goto 99;   end; {if}size := textInfo.charCount + 1;         {need 1 more byte for 1st length byte}{Attempt to get memory block for text from Memory Manager.}HUnlock(phBuffer);{If current handle isn't valid, allocate a new memory block.}if toolError <> 0 then begin   phBuffer := NewHandle(size, myID, $8010, nil);   if toolError <> 0 then begin      HandleError(toolError, memErr);      GetPhonetics := false;      goto 99;      end; {if}   end {if}{Otherwise, attempt to grow the current handle.}else begin   SetHandleSize(size, phBuffer);   if toolError <> 0 then begin      HandleError(toolError, memErr);      GetPhonetics := false;      goto 99;      end; {if}   end; {else}HLock(phBuffer);phBuffSize := size;{Call Text Edit's TEGetText to dump text into buffer.}size := TEGetText($0005, pointer(ord4(phBuffer^) + 1), size,   refIsPtr, nil, userWind[wNum].teHndl);if toolError <> 0 then begin   HandleError(toolError, teErr);   GetPhonetics := false;   end; {if}99:end; {GetPhonetics}{---------------------------------------------------------------}{                                                               }{ SpeakPhonetics - Speak selected phonetics.                    }{                                                               }{---------------------------------------------------------------}procedure SpeakPhonetics (wNum: integer);label 99;var   saveChar: byte;                      {character overwritten in phon buffer}   size: longint;                       {amount of text in phonetics buffer}   selStart,                            {chr position, start of selected text}   selEnd,                              {char position, end of selected text}   selLength: longint;                  {length of selection}   cPtr: ptr;                           {pointers into phonetics buffer}   tPtr: ^char;   pPtr: pStringPtr;   stop: boolean;                       {true if all text has been spoken}begin {SpeakPhonetics}if not GetPhonetics(size, wNum) then    {dump text into our buffer}   goto 99;                             {just return if unable to get text}{Call Text Edit's TEGetSelection to get starting/ending offsets }{for current selection.                                         }TEGetSelection(@selStart, @selEnd, userWind[wNum].teHndl);if toolError <> 0 then begin   HandleError(toolError, teErr);   goto 99;   end; {if}{If there is no current selection, we assume user wants to SPEAK the entire}{window.  In this case, we set start of selection to 0, end of selection to}{end of text.                                                              }if selStart = selEnd then begin   selStart := 0;   selEnd := size - 1;   end; {if}{Get the pointer to the text from the buffer handle,}{adjusting pointer to the start of the selection.   }selStart := selStart + 1;               {1st byte is for length}cPtr := pointer(ord4(phBuffer^) + selStart - 1);stop := false;{Now we're ready to enter our SPEAK loop.  As long as the text to be spoken}{exceeds 255 characters (SPEAK accepts a Pascal-style string), we need to  }{"doctor" the string to speak.                                             }repeat   selLength := selEnd - selStart + 1;  {get length of text to speak}   if selLength <= 0 then               {if length of string = 0, we're done}      stop := true   else begin      if selLength > 255 then           {ensure length doesn't exceed 255 chars.}         selLength := 255;      {Ensure string doesn't end in middle of 2-character phoneme.}      tPtr := pointer(ord4(cPtr) + selLength);      if (tPtr^ >= 'A') and (tPtr^ <= 'Z') then begin         tPtr := pointer(ord4(tPtr) - 1);         if (tPtr^ < 'A') or (tPtr^ > 'Z') then            selLength := selLength - 1;         end; {if}      {Save character we'll be overwriting in the buffer with length byte.}      saveChar := cPtr^;      cPtr^ := ord(selLength);      {SPEAK the string.  Call appropriate function based on current voice}      {setting.                                                           }      pPtr := pointer(cPtr);      if maleParm.itemValue = 1 then         MaleSpeak(ord(volume[1]) - ord('0'), ord(speed[1]) - ord('0'),                   ord(pitch[1]) - ord('0'), pPtr^)      else         FemaleSpeak(ord(volume[1]) - ord('0'), ord(speed[1]) - ord('0'),                     ord(pitch[1]) - ord('0'), pPtr^);      cPtr^ := saveChar;                {restore char we overwrote}      selStart := selStart + selLength; {update start of next string}                                        {  to SPEAK                 }      cPtr := pointer(ord4(cPtr) + selLength); {update pointer into text}      end; {if selLength > 0}until stop;99:HUnlock(phBuffer);end; {SpeakPhonetics}{---------------------------------------------------------------}{                                                               }{ SpeakText - Speak selected text.                              }{                                                               }{---------------------------------------------------------------}procedure SpeakText (wNum: integer);label 99;var   sayString: pString;                  {string to SAY}   selStart,                            {char position of start of selection}   selEnd,                              {char position of end of selection}   selLength: longint;                  {selection length}   size: longint;                       {amount of text in English text buffer}   cPtr: ^char;                         {pointer into buffer}   stop: boolean;                       {true if all text has been spoken}   i: integer;                          {index}begin {SpeakText}if not GetText(size, wNum) then         {dump text into our buffer}   goto 99;                             {just return if unable to get text}{Call Text Edit's TEGetSelection to get starting }{and ending offsets for current selection.       }TEGetSelection(@selStart, @selEnd, userWind[wNum].teHndl);if toolError <> 0 then begin   HandleError(toolError, teErr);   goto 99;   end; {if}{If there is no current selection, we assume user wants to SAY the entire  }{window.  In this case, we set start of selection to 0, end of selection to}{end of text.                                                              }if selStart = selEnd then begin   selStart := 0;   selEnd := size;   end; {if}{Get the pointer to the text from the buffer handle,}{adjusting pointer to the start of the selection.   }selEnd := selEnd - 1;                   {end is always 1 more than it should be}cPtr := pointer(ord4(buffer^) + selStart);{Now we're ready to enter our SAY loop.  As long as the text to be spoken}{exceeds 255 characters (SAY accepts a Pascal-style string), we need to  }{"doctor" the string to speak.                                           }stop := false;repeat   selLength := selEnd - selStart + 1;  {get length of text to speak}   if selLength <= 0 then               {if length of string = 0,   }      stop := true                      {  we're done               }   else begin      if selLength > 255 then           {ensure length doesn't exceed}         selLength := 255;              {  255 chars                 }      sayString[0] := chr(ord(selLength)); {stuff length byte into    }                                           {  start of string to speak}      {Move text from buffer to string to SAY.}      for i := 1 to ord(selLength) do begin         sayString[i] := cPtr^;         cPtr := pointer(ord4(cPtr) + 1);         end; {for}      Say(sayString);                   {SAY the string}      selStart := selStart + selLength; {update start of next string}                                        {  to SAY                   }      cPtr := pointer(ord4(cPtr) + 1);  {update pointer into text}      end; {selLength > 0}until stop;99:HUnlock(buffer);end; {SpeakText}{---------------------------------------------------------------}{                                                               }{ DoSetParameters - Set global speech parameters.               }{                                                               }{---------------------------------------------------------------}procedure DoSetParameters;label 99;const   okItem     = 1;                      {dialog's item IDs}   cancelItem = 2;   maleItem   = 3;   femaleItem = 4;   trebleItem = 6;   bassItem   = 7;   pitchItem  = 8;   speedItem  = 9;   volumeItem = 10;var   setParmsPtr: grafPortPtr;            {set parameters dialog's grafPort ptr}   savMale: integer;                    {original maleVoice value}   savFemale: integer;                  {original femaleVoice value}   savTreble: integer;                  {original treble value}   savBass: integer;                    {original bass value}   savPitch: minPString;                {original pitch value}   savSpeed: minPString;                {original speed value}   savVolume: minPString;               {original volume value}   item2: integer;                      {if radio button, other item to toggle}   itemHit: integer;                    {item selected in dialog}   theVoice: Gender;                    {new global voice value}   theTone: Tone;                       {new global tone value}   stop: boolean;                       {true if ready to exit set parms dlg}   tmp: minPString;                     {tmp text for dialog's edit-line boxes}   i: integer;   procedure Toggle;   { For radio buttons, set 1 family member "on" and the other  }   { "off."                                                     }   label 98;   begin {Toggle}   SetDItemValue(1, setParmsPtr, itemHit);   if toolError <> 0 then begin      HandleError(toolError, dlgErr);      goto 98;      end; {if}   SetDItemValue(0, setParmsPtr, item2);   if toolError <> 0 then begin      HandleError(toolError, dlgErr);      end; {if}   98:   end; {Toggle}begin {DoSetParameters}{Create the Set Parameters dialog box.}setParmsPtr := GetNewModalDialog2(setParmsDlg);if toolError <> 0 then begin   HandleError(toolError, windErr);   goto 99;   end; {if}{Save the original parameter values, in case user decides to cancel.}savMale := maleParm.itemValue;savFemale := femaleParm.itemValue;savTreble := trebleParm.itemValue;savBass := bassParm.itemValue;savPitch := pitch;savSpeed := speed;savVolume := volume;{Call Dialog Manager to get item selected, then handle appropriately.}stop := false;repeat   itemHit := ModalDialog(nil);   if toolError <> 0 then      FatalErr(toolError);   {Based on item selected, handle appropriately.}   if itemHit = okItem then begin      {If item = OK button, set global speech parameters.}      if maleParm.itemValue = 1 then         theVoice := Male      else         theVoice := Female;      if bassParm.itemValue = 1 then         theTone := Bass      else         theTone := Treble;      SetSayGlobals(theVoice, theTone, ord(pitch[1]) - ord('0'),                    ord(speed[1]) - ord('0'), ord(volume[1]) - ord('0'));      stop := true;      end {if OK selected}   else if itemHit = cancelItem then begin      {If Cancel button selected, we'll need to restore original values.}      maleParm.itemValue := savMale;      femaleParm.itemValue := savFemale;      bassParm.itemValue := savBass;      trebleParm.itemValue := savTreble;      pitch := savPitch;      speed := savSpeed;      volume := savVolume;      stop := true;      end {if Cancel selected}   else if itemHit = maleItem then begin      {If item selected is a radio button, we'll need to set}      {the selected button and then clear its family member.}      maleParm.itemValue := 1;      femaleParm.itemValue := 0;      item2 := femaleItem;      Toggle;      end {else if}   else if itemHit = femaleItem then begin      femaleParm.itemValue := 1;      maleParm.itemValue := 0;      item2 := maleItem;      Toggle;      end {else if}   else if itemHit = trebleItem then begin      trebleParm.itemValue := 1;      bassParm.itemValue := 0;      item2 := bassItem;      Toggle;      end {else if}   else if itemHit = bassItem then begin      bassParm.itemValue := 1;      trebleParm.itemValue := 0;      item2 := trebleItem;      Toggle;      end {else if}   else begin      {The last 3 items are edit-line boxes.  Error-check entered value.}      GetIText(setParmsPtr, itemHit, @tmp);      if toolError <> 0 then begin         HandleError(toolError, dlgErr);         stop := true;         end {if}      else begin         {To handle errors in edit-line boxes, bring up an error alert,}         {select the offensive text, then have user reenter the text.  }         if (tmp[1] < '0') or (tmp[1] > '9') then begin            i := CautionAlert(pErrorAlert, nil);            SelectIText(setParmsPtr, itemHit, 0, 1);            end {if}         else if itemHit = pitchItem then            pitch := tmp         else if itemHit = speedItem then            speed := tmp         else if itemHit = volumeItem then            volume := tmp;         end; {no err from GetIText}      end; {item = edit box}   until stop;   CloseDialog(setParmsPtr);99:end; {DoSetParameters}{---------------------------------------------------------------}{                                                               }{ DoShowPhonetics - Convert English text to phonetics.          }{                                                               }{---------------------------------------------------------------}procedure DoShowPhonetics;label 99;var   wInfo: windInfoRec;                  {information about the front window}   sayString,                           {strings to send to PARSE function}   phString: pString;   selStart,                            {char position of start of selection}   selEnd,                              {char position of end of selection}   selLength: longint;                  {selection length}   size: longint;                       {amount of text in English text window}   tmp: longint;                        {amount of phonetics text in buffer}   stop: boolean;                       {true when reach end of text buffer}   tPtr: ^char;                         {pointer into text buffer}   pPtr: ^char;                         {pointer into phonetics buffer}   phStart: integer;                    {position in English text to start parsing}   tmp2: longint;                       {temporaries}   i: integer;begin {ShowPhonetics}{Check abort conditions.}if not MyWindow(wInfo) then             {ensure front window is ours}   goto 99;if wInfo.currWindTyp = phonTyp then     {if the front window = phonetics}   goto 99;                             {  just return                  }if wInfo.currWindTyp = dictTyp then     {if front window = dictionary}   begin   DictConvertWord;                     {  call DictConvertWord and exit}   goto 99;   end; {if}if userWindows = 10 then                {ensure we can open 1 more window}   goto 99;                             {  to hold phonetic translation  }if not GetText(size, wInfo.currWindNum) then {dump English text into buffer}   goto 99;                             {just return if unable to get text}HLock(phBuffer);                        {ensure integrity of phon buffer}if toolError <> 0 then begin            {if can't lock buffer, alloc new one}   phBuffer := NewHandle(1024, myID, $8010, nil);   if toolError <> 0 then begin      HandleError(toolError, memErr);      goto 99;      end; {if}   phBuffSize := 1024;   end; {if}{Call Text Edit's GetSelection to get starting/ending}{offsets for current selection.                      }TEGetSelection(@selStart, @selEnd, userWind[wInfo.currWindNum].teHndl);if toolError <> 0 then begin   HandleError(toolError, teErr);   goto 99;   end; {if}{If there is no current selection, we assume user wants to convert the    }{entire text window to phonetics.  In this case, we set start of selection}{to 0, end of selection to end of text.                                   }if selStart = selEnd then begin   selStart := 0;   selEnd := size;   end; {if}{Get the pointer to the text from the buffer handle, }{adjusting pointer to the start of the selection.    }selEnd := selEnd - 1;                   {end is always 1 more than it should be}tPtr := pointer(ord4(buffer^) + selStart);pPtr := pointer(ord4(phBuffer^));tmp := 0;                               {tmp tracks size of phonetics}{Now we're ready to enter our PARSE loop.  As long as the text to be   }{parsed exceeds 255 characters (PARSE accepts 2 Pascal-style strings), }{we need to "doctor" the string to parse.                              }stop := false;repeat   selLength := selEnd - selStart + 1;  {get length of text to parse}   if selLength <= 0 then               {if length of string = 0,}      stop := true                      {  we're done            }   else begin      {Ensure length of string doesn't exceed 255 characters.}      if selLength > 255 then         selLength := 255;      {Move string to parse from buffer to sayString.  1st byte = length.}      sayString[0] := chr(ord(selLength));      for i := 1 to ord(selLength) do begin         sayString[i] := tPtr^;         tPtr := pointer(ord4(tPtr) + 1);         end; {for}      {Parse the string.}      phStart := 0;                     {start parsing at start of string}      while length(sayString) <> phStart do begin         phString[0] := chr(255);       {set length of phonetics string}         phStart := phStart + 1;         phStart := Parse(sayString, phString, phStart);         {Move phonetics string to buffer.  First check if buffer is}         {large enough; if not, attempt to allocate a bigger buffer.}         tmp2 := tmp;                   {save curr size of phonetics}         tmp := tmp + length(phString); {update size of phon created}         if tmp > phBuffSize then begin {check buffer large enough}            HUnlock(phBuffer);          {unlock block so MM can grow}            phBuffSize := phBuffSize + 1024; {grow by 1K increments}            SetHandleSize(phBuffSize, phBuffer);            if toolError <> 0 then begin               HandleError(toolError, memErr);               goto 99;               end; {if}            HLock(phBuffer);            pPtr := pointer(ord4(phBuffer^) + tmp2);            end; {buffer too small}         {Move phonetic string to buffer.}         for i := 1 to length(phString) do begin            pPtr^ := phString[i];            pPtr := pointer(ord4(pPtr) + 1);            end; {for}         end; {while length(sayString) <> phStart}      {Update start of next string to parse.}      selStart := selStart + selLength;      end; {selLength > 0}until stop;{Now that all the text has been converted, we need to show it in a phonetics}{window.  We'll need to create a new window, first.                         }if not InitWindow(wInfo) then           {init window data structures}   goto 99;SetPhonWName(wInfo.currWindNum);        {get name for new phonetics window}userWind[wInfo.currWindNum].wTyp := phonTyp;wInfo.currWindTyp := phonTyp;if not CreateWindow(wInfo) then   goto 99;{Finally, we need to dump the phonetics buffer into the phonetics window.}TESetText($0005, ord4(phBuffer^), tmp, refIsPtr, nil,   userWind[wInfo.currWindNum].teHndl);if toolError <> 0 then begin   HandleError(toolError, teErr);   CloseWindow(wInfo.currWindow);   goto 99;   end; {if}{Clean up:  disable Open and New commands, if necessary; set window's}{           upFlag to true; set window's dirty bit.                  }FiniWindow(wInfo.currWindNum);with userWind[wInfo.currWindNum] do begin   fileFlag := false;   teHndl^^.ctlFlag := teHndl^^.ctlFlag | isDirty;   end; {with}99:HUnlock(phBuffer);HUnlock(buffer);end; {DoShowPhonetics}{---------------------------------------------------------------}{                                                               }{ DoSpeak - Depending upon type of front-most window,           }{           speak text or phonetics.                            }{                                                               }{---------------------------------------------------------------}procedure DoSpeak;var   wInfo: windInfoRec;                  {information about the front window}begin {DoSpeak}{Don't do anything unless the front window is ours.}if MyWindow(wInfo) then   if wInfo.currWindTyp = textTyp then      SpeakText(wInfo.currWindNum)   else if wInfo.currWindTyp = phonTyp then      SpeakPhonetics(wInfo.currWindNum)   else      DictSpeakWord;end; {DoSpeak}{---------------------------------------------------------------}{                                                               }{ SetPhonWName - Create phonetic window's name.                 }{                                                               }{---------------------------------------------------------------}procedure SetPhonWName {wNum: integer};var   tmp: packed array[0..13] of char;begin {SetPhonWName}{Build window name from the string 'Phonetics' and the window's number.}tmp := ' Phonetics   ';tmp[12] := chr(ord(wNum) + ord('0'));userWind[wNum].wName := tmp;end; {SetPhonWName}{---------------------------------------------------------------}{                                                               }{ InitSpeechCmds - Initialize SpeechCmds unit.                  }{                                                               }{ Returns:  True if able to start speech tools; false otherwise.}{                                                               }{---------------------------------------------------------------}function InitSpeechCmds {: boolean};label 99;var   hndl: handle;begin {InitSpeechCmds}InitSpeechCmds := true;                 {assume all is well}{Start speech tools.}with toolTbl do begin   numToolsRequired := 4;   tool[1].toolNumber := 50;   tool[1].minVersion := 0;   tool[2].toolNumber := 51;   tool[2].minVersion := 0;   tool[3].toolNumber := 52;   tool[3].minVersion := 0;   tool[4].toolNumber := 53;   tool[4].minVersion := 0;   end; {with}LoadTools(toolTbl);if toolError <> 0 then begin   HandleError(toolError, toolErr);   InitSpeechCmds := false;   goto 99;   end; {if}FemaleStartUp;                          {start female speech tool}MaleStartUp;                            {start male speech tool}ParseStartUp(myID);                     {start parser}SpeechStartUp;                          {start OS interface tool}{Allocate buffer to hold phonetics text.}phBuffer := NewHandle(1024, myID, $8010, nil);if toolError <> 0 then begin   HandleError(toolError, memErr);   InitSpeechCmds := false;   goto 99;   end; {if}phBuffSize := 1024;{Initialize the set global speech parameters dialog box.}with setParmsDlg do begin   with dtBoundsRect do begin      v1 := $28;      h1 := $60;      v2 := $9C;      h2 := $1FB;      end; {with}   dtVisible := true;   dtRefCon := 0;   dtItemList[1] := @maleParm;   dtItemList[2] := @femaleParm;   dtItemList[3] := @item02parm;   dtItemList[4] := @trebleParm;   dtItemList[5] := @bassParm;   dtItemList[6] := @item05parm;   dtItemList[7] := @item07parm;   dtItemList[8] := @item06parm;   dtItemList[9] := @item08parm;   dtItemList[10] := @item09parm;   dtItemList[11] := @item10parm;   dtItemList[12] := @item11parm;   dtItemList[13] := @item12parm;   dtItemList[14] := nil;   end; {with}with maleParm do begin                  {Male voice radio button}   itemID := 3;   with itemRect do begin      v1 := 17;      h1 := 12;      v2 := 30;      h2 := 126;      end; {with}   itemType := $C;   itemDescr := @item00PointerParm;   itemValue := 1;   itemFlag := 1;   itemColor := nil;   end; {with}item00PointerParm := 'Male voice';with femaleParm do begin                {Female voice radio button}   itemID := 4;   with itemRect do begin      v1 := 30;      h1 := 11;      v2 := 43;      h2 := 140;      end; {with}   itemType := $C;   itemDescr := @item01PointerParm;   itemValue := 0;   itemFlag := 1;   itemColor := nil;   end; {with}item01PointerParm := 'Female voice';with item02parm do begin                {Set parameters title}   itemID := 5;   with itemRect do begin      v1 := 3;      h1 := 111;      v2 := 13;      h2 := 270;      end; {with}   itemType := $800F;   itemDescr := @item02PointerParm;   itemValue := 21;   itemFlag := 0;   itemColor := nil;   end; {with}item02PointerParm := 'Set speech parameters';with trebleParm do begin                {Treble radio button}   itemID := 6;   with itemRect do begin      v1 := 72;      h1 := 12;      v2 := 85;      h2 := 97;      end; {with}   itemType := $C;   itemDescr := @item03PointerParm;   itemValue := 0;   itemFlag := 2;   itemColor := nil;   end; {with}item03PointerParm := 'Treble';with bassParm do begin                  {Bass radio button}   itemID := 7;   with itemRect do begin      v1 := 58;      h1 := 10;      v2 := 71;      h2 := 80;      end; {with}   itemType := $C;   itemDescr := @item04PointerParm;   itemValue := 1;   itemFlag := 2;   itemColor := nil;   end; {with}item04PointerParm := 'Bass';with item05parm do begin                {Pitch edit line box}   itemID := 8;   with itemRect do begin      v1 := 19;      h1 := 355;      v2 := 32;      h2 := 378;      end; {with}   itemType := $11;   itemDescr := @pitch;   itemValue := 2;   itemFlag := 0;   itemColor := nil;   end; {with}pitch := '5';with item06parm do begin                {Speed edit line box}   itemID := 9;   with itemRect do begin      v1 := 35;      h1 := 355;      v2 := 48;      h2 := 378;      end; {with}   itemType := $11;   itemDescr := @speed;   itemValue := 2;   itemFlag := 0;   itemColor := nil;   end; {with}speed := '5';with item07parm do begin                {Volume edit line box}   itemID := 10;   with itemRect do begin      v1 := 51;      h1 := 355;      v2 := 64;      h2 := 378;      end; {with}   itemType := $0011;   itemDescr := @volume;   itemValue := 2;   itemFlag := 0;   itemColor := nil;   end; {with}volume := '5';with item08parm do begin                {Title for Pitch edit line box}   itemID := 11;   with itemRect do begin      v1 := 20;      h1 := 296;      v2 := 30;      h2 := 334;      end; {with}   itemType := $800F;   itemDescr := @item08PointerParm;   itemValue := 5;   itemFlag := 0;   itemColor := nil;   end; {with}item08PointerParm := 'Pitch';with item09parm do begin                {Title for Speed edit line box}   itemID := 12;   with itemRect do begin      v1 := 36;      h1 := 296;      v2 := 46;      h2 := 336;      end; {with}   itemType := $800F;   itemDescr := @item09PointerParm;   itemValue := 5;   itemFlag := 0;   itemColor := nil;   end; {with}item09PointerParm := 'Speed';with item10parm do begin                {Title for Volume edit line box}   itemID := 13;   with itemRect do begin      v1 := 52;      h1 := 297;      v2 := 62;      h2 := 347;      end; {with}   itemType := $800F;   itemDescr := @item10PointerParm;   itemValue := 6;   itemFlag := 0;   itemColor := nil;   end; {with}item10PointerParm := 'Volume';with item11parm do begin                {OK button}   itemID := 1;   with itemRect do begin      v1 := 94;      h1 := 100;      v2 := 107;      h2 := 155;      end; {with}   itemType := $000A;   itemDescr := @okTitle;   itemValue := 0;   itemFlag := 1;   itemColor := nil;   end; {with}with item12parm do begin                {Cancel button}   itemID := 2;   with itemRect do begin      v1 := 94;      h1 := 216;      v2 := 107;      h2 := 302;      end; {with}   itemType := $000A;   itemDescr := @cancelTitle;   itemValue := 0;   itemFlag := 0;   itemColor := nil;   end; {with}with PErrorAlert do begin               {Set parameters error alert}   with atBoundsRect do begin      v1 := $31;      h1 := $88;      v2 := $72;      h2 := $1D9;      end; {with}   atAlertID := 3;   atStage1 := $81;   atStage2 := $81;   atStage3 := $81;   atStage4 := $81;   atItemList[1] := @item00PErr;   atItemList[2] := @item01PErr;   atItemList[3] := nil;   end; {with}with item00PErr do begin                {Error message}   itemID := $64;   with itemRect do begin      v1 := 32;      h1 := 61;      v2 := 42;      h2 := 276;      end; {with}   itemType := $800F;   itemDescr := @item00pointerPErr;   itemValue := 30;   itemFlag := 1;   itemColor := nil;   end; {with}item00pointerPErr := 'Value must be between 0 and 9.';with item01PErr do begin                {OK button}   itemID := 1;   with itemRect do begin      v1 := 48;      h1 := 134;      v2 := 61;      h2 := 189;      end; {with}   itemType := $000A;   itemDescr := @okTitle;   itemValue := 0;   itemFlag := 1;   itemColor := nil;   end; {with}99:end; {InitSpeech}end. {SpeechCmds unit}