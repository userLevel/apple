{$keep 'DictCmds'}{------------------------------------------------------------------}{                                                                  }{ DictCmds - Commands to control TalkingTools' on-line dictionary. }{                                                                  }{ Written by Barbara Allred                                        }{                                                                  }{ Copyright 1991, Byte Works, Inc.                                 }{ Copyright 1987-1991, First Byte, Inc.                            }{                                                                  }{------------------------------------------------------------------}unit DictCmds;interfaceuses   Common, SpeechTools, ToolLocator, DialogMgr, SFToolSet, GSOS, ControlMgr,   MemoryMgr, TextEdit, PrintMgr, WindowMgr, MenuMgr, QuickDrawII, LineEdit;{$LibPrefix '0/'}uses   Globals, Error, MscCmds;procedure DoActivate;procedure DoDict;procedure DictAddWord;procedure DictClear;procedure DictConvertWord;procedure DictDeleteWord;procedure DictSpeakWord;function  EmptyDict: boolean;function  InitDictCmds: boolean;function  LoadDict (buffPtr: pString32Ptr; fileSize: longint): boolean;procedure OpenDict (theReply: replyRecord5_0);procedure SetDefaultDName;procedure SetDictName (theReply: replyRecord5_0);procedure SetNoFileDName;implementationconst   listMemberSize = 10;                 {sizeof(listMember) record}type   visMembers = record                  {array used for list display of curr dict}       memNum: integer;       english: pString32;       end;   listMember = record                  {list member record, for dict display}       phonPtr: pString32Ptr;       flag: integer;       visNum: integer;       memNum: integer;       end;   listMemberPtr = ^listMember;var                                        {Dictionary variables}                                        {--------------------}   actListSize: integer;                {# members can be held in curr list}   top: integer;                        {member # at top of list display}   bottom: integer;                     {member # at bottom of list display}   englishSize: integer;                {text size, English edit box}   englishText: pString32;              {English word in edit box}   phoneticSize: integer;               {text size, phonetic edit box}   phoneticText: pString32;             {phonetic word in edit box}   dActiveFlag: integer;                {non-zero if dict is active}   activeMsg: packed array[0..13] of char; {menu item when dict NOT active}   inactiveMsg: packed array[0..14] of char; {menu item when dict is active}   mountPrompt: packed array[0..30] of char; {prompt to mount boot disk}   defaultDName: gsosInstring19;        {default dictionary name}   noFileDName: gsosInString15;         {name when dict not from file}   visMems: array[0..4] of visMembers;  {dict elements curr. displayed}   fnTempl: statTextControl;            {dict filename template}function WantToSaveDict: boolean; extern;{Located in FileCmds unit, which USES this unit.}{---------------------------------------------------------------}{                                                               }{ MakeInvisible - Removes elements from currently               }{                 visible poriton of the list.                  }{                                                               }{ Parameters:                                                   }{    firstMem - 1st element to be removed                       }{    lastMem  - last element to be removed                      }{                                                               }{---------------------------------------------------------------}procedure MakeInvisible (firstMem, lastMem: integer);var   listPtr: listMemberPtr;              {pointer into list member array}   i, j: integer;                       {temporaries}begin {MakeInvisible}{Set member array elements' visMem# to -1.}listPtr := pointer(ord4(listTempl.listRef) + (firstMem * listMemberSize));for i := firstMem to lastMem do begin   j := listPtr^.visNum;   if j <> -1 then begin      visMems[j].memNum := -1;      listPtr^.visNum := -1;      end; {if}   listPtr := pointer(ord4(listPtr) + listMemberSize);   end; {for}end; {MakeInvisible}{---------------------------------------------------------------}{                                                               }{ MakeVisible - Adds elements to currently visible              }{               poriton of the list.                            }{                                                               }{ Parameters:                                                   }{    firstMem - 1st element to be added                         }{    lastMem  - last element to be added                        }{                                                               }{ Returns:  True if list has changed                            }{                                                               }{---------------------------------------------------------------}function MakeVisible (firstMem, lastMem: integer): boolean;label 99;var   oldTop,                              {former top, bottom display elements}   oldBottom: integer;   listPtr: listMemberPtr;              {pointer into list member array}   word1,                               {dictionary entry}   word2: pString32;   tmp: pString32Ptr;                   {temporaries}   bTmp: boolean;   long: longint;   i: integer;   function SetEndVars: boolean;   { Resets list variables after end-of-dictionary found.       }   {                                                            }   { Returns:  True if listSize not 0; false otherwise.         }   begin {SetEndVars}   SetEndVars := true;                  {assume list size not 0}   with listTempl do begin              {list size has changed}      listSize := nextEntry;      listStart := listSize - 4;      if listSize = 0 then begin         SetEndVars := false;         listStart := 0;         end {if}      else if listStart < 1 then         listStart := 1;      bottom := listSize - 1;           {we number from 0}      top := bottom - 4;      if top < 0 then         top := 0;      end; {with}   DictInit(0);                         {reset dict to top}   nextEntry := 0;   MakeVisible := true;   end; {SetEndVars}begin {MakeVisible}{Check need to reset dictionary to ensure ability to reach firstMem entry in it}if firstMem < nextEntry then begin   DictInit(0);                         {reset dict to top}   nextEntry := 0;   end; {if}{Loop to reach first dictionary entry, dumping unneeded entries.}while nextEntry < firstMem do begin   tmp := DictDump(word1, word2);   if length(word1) = 0 then begin      {if reach end of dict, }      if SetEndVars then                {  execute End routine }         bTmp := MakeVisible(top, bottom);      goto 99;      end; {if}   nextEntry := nextEntry + 1;   end; {while}{Loop to dump dictionary entries firstMem through lastMem, initializing}{our list data structures as we go.                                    }listPtr := pointer(listTempl.listRef + ord4(firstMem * listMemberSize));i := 0;while firstMem <= lastMem do begin   while visMems[i].memNum <> -1 do     {TAKEN FOR GRANTED THAT CALLER}      begin                             {HAS INITIALIZED VISMEMS      }      i := i + 1;      if i = 5 then         goto 99;      end; {while}   tmp := DictDump(word1, word2);       {get next dict entry}   {If end of dictionary, reset dictionary variables.}   if length(word1) = 0 then begin      oldTop := top;      oldBottom := bottom;      if not SetEndVars then         goto 99;      {Determine which entries for the changed display we still need to get.}      if (oldBottom >= top) and (oldBottom <= bottom) then         bTmp := MakeVisible(oldBottom+1, bottom)      else if (oldTop >= top) and (oldTop <= bottom) then         bTmp := MakeVisible(top, oldTop-1)      else         bTmp := MakeVisible(top, bottom);      goto 99;      end; {if}   with visMems[i] do begin             {init display array}      memNum := firstMem;      english := word1;      end; {with}   with listPtr^ do begin               {init member array element}      visNum := i;      flag := 0;      phonPtr := tmp;      end; {with}                                        {move to next member record}   listPtr := pointer(ord4(listPtr) + listMemberSize);   firstMem := firstMem + 1;   i := i + 1;                          {move to next display element}   nextEntry := nextEntry + 1;          {move to next dict element}   end; {while}MakeVisible := false;99:end; {MakeVisible}{---------------------------------------------------------------}{                                                               }{ AdjustList - After inserting or deleting a dictionary         }{              entry, scroll list display to page               }{              containing affected entry.                       }{                                                               }{ Parameters:                                                   }{    englPtr - pointer to English word of inserted/deleted entry}{                                                               }{---------------------------------------------------------------}procedure AdjustList (englPtr: pString32Ptr);var   found: boolean;                      {true when entry found or passed in list}   listPtr: listMemberPtr;              {pointer into list member array}   word1,                               {dictionary entry}   word2: pString32;   count, i: integer;                   {temporaries}   tmp: pString32Ptr;   bTmp: boolean;begin {AdjustList}{Scroll the display so that the new word will appear within the list.}{Start by removing all of the words currently visible, then search   }{the dictionary for our new word, filling the display array as we go.}with listTempl do begin   MakeInvisible(top, bottom);   found := false;   listStart := -4;   listPtr := pointer(listRef);   end; {with listTempl}{Outer loop: dump dictionary entries until we find the one we were passed.}repeat   listTempl.listStart := listTempl.listStart+5; {move to next display page}   top := nextEntry;   bottom := top + 4;   {Inner loop:  fill visMembers array with next group of 5 elements.}   count := 0;   while count < 5 do begin      tmp := DictDump(word1, word2);    {get next dict entry}      if length(word1) = 0 then              {if end-of-dict do}         with listTempl do begin            listSize := nextEntry;      {  adjust listSize}            bottom := listSize - 1;     {  adjust display}            top := bottom - 4;            if top < 0 then               top := 0;            listStart := top + 1;            DictInit(0);                {  reset dict. to top}            nextEntry := 0;            count := 5;                 {  bail out of inner loop}            found := true;              {  bail out of out loop}            end {with}      else begin         with visMems[count] do begin   {load English entry into display}            english := word1;            memNum := nextEntry;            end; {with}         if not found then              {check entry is one just inserted}            if englPtr^ <= word1 then               found := true;         with listPtr^ do begin         {set non-display values}            flag := 0;                  {  for this list member}            phonPtr := tmp;            end; {with}         count := count + 1;         nextEntry := nextEntry + 1;         listPtr := pointer(ord4(listPtr) + listMemberSize);         end; {not end-of-dict}      end; {while count < 5}until found;{Set visNums for elements in display.}i := top;count := 0;while (i <= bottom) and (count < 5) do begin   if visMems[count].memNum <> -1 then begin      listPtr := pointer(ord4(visMems[count].memNum * listMemberSize) +                         listTempl.listRef);      listPtr^.visNum := count;      end; {if}   i := i + 1;   count := count + 1;   end; {while}{We're now ready to recreate the control and exit.}with userWind[dictWindNum] do begin   dCtls^.listCtlHndl := NewControl2(windPtr, refIsPtr, listTempl);   if toolError <> 0 then begin      HandleError(toolError, ctlErr);      bTmp := DoClose;      end {if}   else      dictChanged := true;   end; {with}end; {AdjustList}{---------------------------------------------------------------}{                                                               }{ GetEnglishBox - Retrieves contents of English word edit box   }{                 in dictionary window, translating to upper    }{                 case.                                         }{                                                               }{ Global Output:                                                }{    englishSize - size of English text                         }{    englishWord - English text                                 }{                                                               }{---------------------------------------------------------------}procedure GetEnglishBox;var   tmp: leRecHndl;                      {handle to box' line-edit record}   theHandle: ctlRecHndl;               {"generic" control handle}   hndl: handle;                        {"generic" handle}   cPtr: ^char;                         {pointers to box' text}   tPtr: ptr;   i: integer;                          {index}begin {GetEnglishBox}{Get pointer to English word from the edit record.  Edit record handle is}{stored in the control's control record.                                 }theHandle := userWind[dictWindNum].dCtls^.englCtlHndl;tmp := leRecHndl(theHandle^^.ctlData);{Call Line Edit toolset for the English word's size and text.}englishSize := LEGetTextLen(tmp);hndl := LEGetTextHand(tmp);cPtr := pointer(hndl^);for i := 1 to englishSize do begin   englishText[i] := cPtr^;   {Shift English text to upper case.}   if (englishText[i] >= 'a') and (englishText[i] <= 'z') then      englishText[i] := chr(ord(englishText[i]) - $20);   cPtr := pointer(ord4(cPtr) + 1);   end; {for}{Stuff length byte into start of englishText array.}tPtr := pointer(ord4(@englishText));tPtr^ := ord(englishSize);end; {GetEnglishBox}{---------------------------------------------------------------}{                                                               }{ GetPhonBox - Retrieves contents of phonetics word edit box in }{              dictionary window.                               }{                                                               }{ Global Output:                                                }{    phoneticSize - size of phonetic text                       }{    phoneticWord - phonetic text                               }{                                                               }{---------------------------------------------------------------}procedure GetPhonBox;var   tmp: leRecHndl;                      {handle to box' line-edit record}   theHandle: ctlRecHndl;               {"generic" control handle}   hndl: handle;                        {"generic" handle}   cPtr: ^char;                         {pointers to box' text}   tPtr: ptr;   i: integer;                          {index}begin {GetPhonBox}{Get pointer to phonetic word from the edit record.  Edit record handle is}{stored in the control's control record.                                  }theHandle := userWind[dictWindNum].dCtls^.phonCtlHndl;tmp := leRecHndl(theHandle^^.ctlData);{Call Line Edit toolset for the English word's size and text.}phoneticSize := LEGetTextLen(tmp);hndl := LEGetTextHand(tmp);cPtr := pointer(hndl^);for i := 1 to phoneticSize do begin   phoneticText[i] := cPtr^;   cPtr := pointer(ord4(cPtr) + 1);   end; {for}{Stuff length byte into start of phoneticText array.}tPtr := pointer(ord4(@phoneticText));tPtr^ := ord(phoneticSize);end; {GetPhonBox}{---------------------------------------------------------------}{                                                               }{ ListDrawRtn - Draws dictionary list member into list control. }{                                                               }{ Parameters:                                                   }{    theRect - pointer to rect. enclosing member                }{    theMem  - pointer to member record to be drawn             }{    theList - list control handle                              }{                                                               }{---------------------------------------------------------------}{$databank+}procedure ListDrawRtn (theRect: rectPtr; theMem: listMemberPtr;                       theList: ctlRecHndl);label 99;var   oldTop: integer;                     {member at top of list display}   oldBottom: integer;                  {member at bottom of list display}   tmp: integer;                        {temporaries}   btmp: boolean;   wordPtr: textPtr;   i: integer;begin {ListDrawRtn}{Check whether requested element to be drawn is currently visible.}if theMem^.visNum = -1 then begin       {-1 signals not visible}   {If element not visible, will need to revise the list.            }   {First calculate the list display's new top and bottom members.   }   {The new top is derived from this member's position in the window.}   {Position is distance from top of member's rect to top of list    }   {control's rect divided by height of member's rectangle.          }   oldTop := top;   oldBottom := bottom;   with theList^^ do      tmp := (theRect^.v1 - ctlRect.v1) div (theRect^.v2 - theRect^.v1);   top := theMem^.memNum - tmp;   bottom := top + 4;   {Adjust the list of visible items.}   MakeInvisible(oldTop, oldBottom);   btmp := MakeVisible(top, bottom);   {The MakeVisible routine determines whether the list size has changed.}   {If so, we'll need to recreate the list control.                      }   if btmp then      with userWind[dictWindNum] do begin         HideControl(dCtls^.listCtlHndl);         DisposeControl(dCtls^.listCtlHndl);         dCtls^.listCtlHndl := NewControl2(windPtr, refIsPtr, listTempl);         if toolError <> 0 then            HandleError(toolError, ctlErr);         goto 99;         end; {else}   end; {member not visible}{The member is visible, access it from the visMems array.}EraseRect(theRect^);PenNormal;ShowPen;MoveTo(theRect^.h1+5, theRect^.v2-1);DrawString(pointer(@visMems[theMem^.visNum].english));{If the member was selected, copy its English word to the English edit-line}{box, and its phonetics word to the phonetics edit-line box.  Invert the   }{member's view rectangle to show it was selected.                          }if theMem^.flag <> 0 then   with userWind[dictWindNum].dCtls^ do begin      HideControl(englCtlHndl);      englishSize := length(visMems[theMem^.visNum].english);      wordPtr := pointer(ord4(@visMems[theMem^.visNum].english[1]));      LESetText(wordPtr, englishSize, englCtlHndl^^.ctlData);      if toolError <> 0 then         HandleError(toolError, ctlErr);      ShowControl(englCtlHndl);      HideControl(phonCtlHndl);      phoneticSize := length(theMem^.phonPtr^);      wordPtr := pointer(ord4(theMem^.phonPtr) + 1);      LESetText(wordPtr, phoneticSize, phonCtlHndl^^.ctlData);      if toolError <> 0 then         HandleError(toolError, ctlErr);      ShowControl(phonCtlHndl);      InvertRect(theRect^);           {invert member's rectangle}      end; {with}99:end; {ListDrawRtn}{$databank-}{---------------------------------------------------------------}{                                                               }{ DoActivate - Toggle dictionary state between on and off.      }{                                                               }{---------------------------------------------------------------}procedure DoActivate;var   flag: integer;                       {dict activate flag}   msg: pStringPtr;                     {pointer to menu item's text}begin {DoActivate}dActiveFlag := dActiveFlag ! $FFFF;     {toggle dict active flag with EOR op}if dActiveFlag = 0 then begin   flag := 0;                           {deactivate dictionary}   msg := @activeMsg;                   {menu item := 'Dictionary on'}   end {if}else begin   flag := 1;                           {activate dictionary}   msg := @inactiveMsg;                 {menu item := 'Dictionary off'}   end; {else}SetMItemName(msg, activeID);DictActivate(flag);end; {DoActivate}{---------------------------------------------------------------}{                                                               }{ DoDict - Bring up dictionary editor.  How the Dictionary...   }{          command functions is based on the dictionary         }{          window's position on the desktop.  If the window is  }{          front-most, the command closes the window; if the    }{          window is up, but not the front one, the command     }{          brings it to front; if the window is not up, the     }{          command creates it.                                  }{                                                               }{---------------------------------------------------------------}procedure DoDict;label 99;var   theCtls: ^CtlRecHndl;                {pointer to dict window's ctl handles}   wRefCon: refConRec;                  {window's number and type}   wInfo: windInfoRec;                  {information about the front window}   tmp: longint;                        {temporaries}   i: integer;   btmp: boolean;begin {DoDict}{First determine whether the dictionary window is up or not.}if userWind[dictWindNum].upFlag then    {if it is...}   begin   if MyWindow(wInfo) then      if wInfo.currWindNum = dictWindNum then {...if front wind = dict}         btmp := DoClose                      {  just close the window}      else         with userWind[dictWindNum] do  {else front wind = dict}            begin            SelectWindow(windPtr);            wInfo.currWindow := windPtr;            wInfo.currWindNum := dictWindNum;            wInfo.currWindTyp := dictTyp;            end; {with}   end {if window up}{Window creation routine.}else   with userWind[dictWindNum] do begin      with wRefCon do begin         wNum := dictWindNum;         wTyp := dictTyp;         end; {with}      windPtr := NewWindow2(nil, wRefCon.long, nil, nil, refIsRsrc,                            dictWindID, $800E);      if toolError <> 0 then begin         HandleError(toolError, windErr);         goto 99;         end; {if}      wInfo.currWindow := windPtr;      {Add controls to dictionary window.   }      {Filename and list are from templates.}      with dCtls^ do begin         fnCtlHndl := NewControl2(wInfo.currWindow, refIsPtr, fnTempl);         if toolError <> 0 then            HandleError(toolError, ctlErr);         listCtlHndl := NewControl2(wInfo.currWindow, refIsPtr, listTempl);         if toolError <> 0 then            HandleError(toolError, ctlErr);         end; {with}      {The other controls are in the resource fork.}      tmp := dictCtlID;                 {starting ID for controls}      theCtls := pointer(ord4(dCtls) + 8);      for i := 0 to maxDCtls do begin         theCtls^ := NewControl2(wInfo.currWindow, refIsRsrc, tmp);         if toolError <> 0 then            HandleError(toolError, ctlErr);         tmp := tmp + 1;         theCtls := pointer(ord4(theCtls) + 4);         end; {for}      {Finish setting window variables.}      wInfo.currWindNum := dictWindNum;      wInfo.currWindTyp := dictTyp;      upFlag := true;      numWindows := numWindows + 1;      end; {with userWind[dictWindNum]}99:end; {DoDict}{---------------------------------------------------------------}{                                                               }{ DictAddWord - Add new entry to dictionary.                    }{                                                               }{---------------------------------------------------------------}procedure DictAddWord;label 99;   function GrowList: boolean;   { Attempt to expand dictionary's list member array by 128    }   { members.                                                   }   {                                                            }   { Returns:  True if list was grown; false otherwise          }   {                                                            }   { Global output:                                             }   {  actListSize       - updated to reflect new list size      }   {  listTempl.refCon  - new handle for member array           }   {  listTempl.listRef - new pointer to member array           }   label 99;   var      size: integer;                    {# elements in expanded list}      memSize: longint;                 {amt. memory needed for expanded list}      listPtr: listMemberPtr;           {pointer into list member array}      hndl: handle;                     {temporaries}      i: integer;   begin {GrowList}   GrowList := false;                   {assume all is not well}   with listTempl do begin      {Calculate total amount of memory needed for array = }      {number of members  *  sizeof(memberRecord).         }      size := listSize + 128;           {ensure not exceeding maxListSize}      if size > maxListSize then begin         HandleError($1C01, listErr);         goto 99;         end; {if}      memSize := size * listMemberSize;      HUnlock(refCon);                  {unlock handle for SetHandleSize}      if toolError <> 0 then begin         HandleError(toolError, memErr);         goto 99;         end; {if}      SetHandleSize(memSize, refCon);   {grow member array}      if toolError <> 0 then begin         HandleError(toolError, memErr);         goto 99;         end; {if}      HLock(refCon);                    {lock down the array}      hndl := handle(refCon);      listRef := longint(hndl^);        {reset pointer to array}      actListSize := size;              {update size of array}      listPtr := pointer(ord4(listRef) + (listSize * listMemberSize));                                        {get pointer to new part}      end; {with}   {Initialize new part of member array.}   for i := listTempl.listSize to size-1 do begin      with listPtr^ do begin         visNum := -1;         memNum := i;         flag := 0;         phonPtr := nil;         end; {with}      listPtr := pointer(ord4(listPtr) + listMemberSize);   end; {for}   GrowList := true;   99:   end; {GrowList}begin {DictAddWord}{Get contents of English word edit box.  }{Get contents of phonetic word edit box. }GetEnglishBox;GetPhonBox;if (length(englishText) <> 0) and (length(phoneticText) <> 0) then begin   {Ensure that the new word will fit in the current list.}   if listTempl.listSize + 1 >= actListSize then      if not GrowList then         goto 99;   {Dispose of the list control, since we'll be redrawing it.}   with userWind[dictWindNum].dCtls^ do begin      HideControl(listCtlHndl);      DisposeControl(listCtlHndl);      end; {with}   {Add word to the dictionary; reset dictionary to top; adjust the list control.}   DictInsert(englishText, phoneticText);   DictInit(0);   nextEntry := 0;   listTempl.listSize := listTempl.listSize + 1;   AdjustList(englishText);   99:   end; {if}end; {DictAddWord}{---------------------------------------------------------------}{                                                               }{ DictClear - Clear current dictionary from memory.             }{                                                               }{---------------------------------------------------------------}procedure DictClear;label 99;begin {DictClear}{If the current dictionary has changed, ask user if want to save it}{before removing it from memory.                                   }if dictChanged then   if WantToSaveDict then               {give chance to cancel}      goto 99;if EmptyDict then   SetNoFileDName;99:end; {DictClear}{---------------------------------------------------------------}{                                                               }{ DictConvertWord - Convert English word to its phonetic        }{                   representation.                             }{                                                               }{---------------------------------------------------------------}procedure DictConvertWord;var   phString: pString;   i: integer;begin {DictConvertWord}{Get contents of English word edit-line box.}GetEnglishBox;{Convert the string to phonetics.}i := Parse(englishText, phString, 1);{Set phonetics edit box to returned phonetic string.}phoneticSize := length(phString);for i := 0 to phoneticSize do   phoneticText[i] := phString[i];{Recreate phonetics edit box control.}with userWind[dictWindNum].dCtls^ do begin   HideControl(phonCtlHndl);   LESetText(@phoneticText[1], phoneticSize, phonCtlHndl^^.ctlData);   if toolError <> 0 then      HandleError(toolError, ctlErr)   else      ShowControl(phonCtlHndl);   end; {with}end; {DictConvertWord}{---------------------------------------------------------------}{                                                               }{ DictDeleteWord - Delete entry from dictionary.                }{                                                               }{---------------------------------------------------------------}procedure DictDeleteWord;begin {DictDeleteWord}{Dispose of the list control, since we'll be redrawing it.}with userWind[dictWindNum].dCtls^ do begin   HideControl(listCtlHndl);   DisposeControl(listCtlHndl);   end; {with}{Get contents of English word edit box.}GetEnglishBox;{Delete word from the dictionary; reset     }{dictionary to top; adjust the list control.}DictDelete(englishText);DictInit(0);nextEntry := 0;AdjustList(englishText);end; {DictDeleteWord}{---------------------------------------------------------------}{                                                               }{ DictSpeakWord - Speak phonetic dictionary entry.              }{                                                               }{---------------------------------------------------------------}procedure DictSpeakWord;begin {DictSpeakWord}{Get contents of phonetic edit-line box.}GetPhonBox;{SPEAK the string.  Call appropriate function based on current voice setting}if maleParm.itemValue = 1 then   MaleSpeak(ord(volume[1]) - ord('0'), ord(speed[1]) - ord('0'),             ord(pitch[1]) - ord('0'), phoneticText)else   FemaleSpeak(ord(volume[1]) - ord('0'), ord(speed[1]) - ord('0'),               ord(pitch[1]) - ord('0'), phoneticText);end; {DictSpeakWord}{---------------------------------------------------------------}{                                                               }{ EmptyDict - Create "empty" dictionary.                        }{                                                               }{ Returns:  True if able to create empty dictionary; false      }{           otherwise.                                          }{                                                               }{---------------------------------------------------------------}function EmptyDict {: boolean};label 99;var   listPtr: listMemberPtr;              {pointer into list member array}   hndl: handle;                        {temporaries}   i: integer;   bTmp: boolean;begin {EmptyDict}EmptyDict := true;                      {assume all is well}{First remove all traces of the last dictionary, if there was one.}DictInit(1);                            {clear the dict in memory}nextEntry := 0;dictChanged := false;with listTempl do begin   if refCon <> 0 then begin            {deallocate members array}      DisposeHandle(handle(refCon));      refCon := 0;      end; {if}   listStart := 0;                      {no members in list now}   listSize := 0;   listRef := 0;   end; {with}with userWind[dictWindNum] do           {deallocate path handle}   if fileFlag then begin      if wPathHandle <> nil then begin         DisposeHandle(wPathHandle);         wPathHandle := nil;         end; {if}      fileFlag := false;      end; {if}for i := 0 to 4 do                      {make all list display slots available}   visMems[i].memNum := -1;top := 0;                               {reset display variables}bottom := 0;{Create new member array of minimum size.}hndl := NewHandle(1024, myID, $C010, nil);if toolError <> 0 then begin   HandleError(toolError, memErr);   EmptyDict := false;   goto 99;   end; {if}with listTempl do begin   refCon := ord4(hndl);   listRef := ord4(hndl^);   listPtr := pointer(listRef);   end; {with}for i := 0 to 127 do begin              {init. members array}   with listPtr^ do begin      visNum := -1;      memNum := i;      flag := 0;      phonPtr := nil;      end; {with}   listPtr := pointer(ord4(listPtr) + listMemberSize);   end; {for}actListSize := 128;{If dict window is up, recreate list control.}with userWind[dictWindNum] do   if upFlag then      with dCtls^ do begin         HideControl(listCtlHndl);         DisposeControl(listCtlHndl);         listCtlHndl := NewControl2(windPtr, refIsPtr, listTempl);         if toolError <> 0 then begin            HandleError(toolError, ctlErr);            bTmp := DoClose;            EmptyDict := false;            goto 99;            end; {if}         end; {with}99:end; {EmptyDict}{---------------------------------------------------------------}{                                                               }{ InitDictCmds - Initialize the DictCmds unit.                  }{                                                               }{ Returns:  True if able to initialize unit; false otherwise.   }{                                                               }{---------------------------------------------------------------}function InitDictCmds {: boolean};label 99;var   answer: integer;                     {response to TLMountBootVolume dialog}   hndl: handle;                        {handle for read buffer, default dict}   error: integer;                      {integer error code returned by GS/OS}   bTmp: boolean;   i: integer;begin {InitDictCmds}InitDictCmds := false;                  {assume all is not well to start}{Initialize dictionary variables.}dictChanged := false;                   {dictionary hasn't changed yet}dActiveFlag := -1;                      {dictionary currently active}activeMsg := 'Dictionary on';inactiveMsg := 'Dictionary off';mountPrompt := 'Please place boot disk on-line';with defaultDName do begin   size := 19;   name := '*/System/SpeechDict';   end; {with}with noFileDName do begin   size := 15;   name := '< no file >    ';   end; {with}with fileDName do begin   size := 15;   name := '               ';   end; {with}for i := 0 to 4 do begin                {no list members are visible yet}   visMems[i].memNum := -1;   visMems[i].english := '';   end; {for}with fnTempl do begin                   {init. filename control template}   pCount := 8;   ID := 8;   with boundsRect do begin       v1 := $5;       h1 := $133;       v2 := $F;       h2 := $18D;       end; {with}   procRef := $81000000;   flag := $0000;   moreFlags := $1000;   refCon := 0;   textRef := ord4(@noFileDName.name);   textSize := noFileDName.size;   end; {with}{Initialize list control template.}with listTempl do begin   pCount := 14;   ID := 9;   with boundsRect do begin      v1 := $16;      h1 := $24;      v2 := $4A;      h2 := $218;      end; {with}   procRef := $89000000;   flag := $0000;   moreFlags := $1400;   refCon := 0;   listSize := 0;   listView := 5;   listType := $0006;   listStart := 0;   listDraw := @ListDrawRtn;   listMemHeight := 10;   listMemSize := 10;   listRef := 0;   end; {with}{Initialize the dictionary.  First see if there's a dictionary file to load.}SetNoFileDName;                         {assume no dictionary file}openRec.pathname := @defaultDName;      {attempt to open */System/SpeechDict}OpenGS(openRec);{Use TLMountVolume call to prompt for boot disk.}if (toolError = diskSwitchedErr) or (toolError = volNotFoundErr) then begin   answer := TLMountVolume(20, 20,      {put dialog box at (20, 20)}                           mountPrompt, {pointer to 1st message line}                           nil,         {no 2nd message line in dialog}                           okTitle,     {pointer to OK button's text}                           cancelTitle); {pointer to Cancel button's text}   if answer = 1 then begin             {try again to open file}      OpenGS(openRec);      if (toolError = diskSwitchedErr) or (toolError = volNotFoundErr) or         (toolError = fileNotFoundErr) then begin         if EmptyDict then            InitDictCmds := true;         goto 99;         end {if}      else if toolError <> 0 then begin         HandleError(toolError, openErr);         goto 99;         end {else if}      end {attempt to reopen file}   else begin      if EmptyDict then         InitDictCmds := true;      goto 99;      end {user won't mount boot disk}   end {volNotFound, diskSwitched error detected}else if toolError = fileNotFoundErr then begin   if EmptyDict then      InitDictCmds := true;   goto 99;   end {else if}else if toolError <> 0 then begin   HandleError(toolError, openErr);   goto 99;   end {else if}else if openRec.dataEOF = 0 then begin   SetDefaultDName;   if EmptyDict then      InitDictCmds := true;   goto 99;   end; {else if}{If */System/SpeechDict exists, read the file, close the file, then}{load the dictionary.                                              }with openRec do begin   closeRec.refNum := refNum;   hndl := NewHandle(dataEOF, myID, $C010, nil);   if toolError <> 0 then begin      HandleError(toolError, memErr);      CloseGS(closeRec);      goto 99;      end; {if}   end; {with}with readRec do begin   refNum := openRec.refNum;   requestCount := openRec.dataEOF;   dataBuffer := hndl^;   ReadGS(readRec);   error := toolError;   CloseGS(closeRec);   if error <> 0 then begin      HandleError(error, readErr);      DisposeHandle(hndl);      goto 99;      end; {if}   btmp := LoadDict(pointer(dataBuffer), transferCount);   if not btmp then begin      DisposeHandle(hndl);      goto 99;      end; {if}   end; {with}SetDefaultDName;                       {set dict window's name}with userWind[dictWindNum] do begin   fileFlag := true;   wPathName := openRec.pathname;   wPathHandle := nil;   end; {with}DisposeHandle(hndl);InitDictCmds := true;99:end; {InitDict}{---------------------------------------------------------------}{                                                               }{ LoadDict - Load new dictionary from disk.                     }{                                                               }{ Parameters:                                                   }{    buffPtr  - pointer to buffer into which file has been read }{    fileSize - size of buffer                                  }{                                                               }{ Returns:  True if able to load new dictionary; false otherwise}{                                                               }{---------------------------------------------------------------}function LoadDict {buffPtr: pString32Ptr; fileSize: longint): boolean};label 99;var   hndl: handle;                        {handle to memory for new member array}   memSize: longint;                    {amount of memory needed for new array}   word2Ptr: pString32Ptr;              {pointer to phonetic dictionary entry}   listPtr: listMemberPtr;              {pointer into member array}   length1,                             {length of dictionary entries}   length2: integer;   bTmp: boolean;                       {temporaries}   tmp: longint;   i: integer;begin {LoadDict}LoadDict := true;with listTempl do begin                 {check need to deallocate old dict}   if refCon <> 0 then begin      DisposeHandle(handle(refCon));      listRef := 0;      refCon := 0;      end; {if}   listSize := 0;                       {initialize list to empty}   listStart := 0;   DictInit(1);                         {clear curr dict from memory}   {Process the file:  count # dict. entries, create dict. from file.}   tmp := 0;   while (tmp < fileSize) and (listSize < maxListSize) do begin      length1 := length(buffPtr^);      word2Ptr := pointer(ord4(buffPtr) + length1 + 1);      DictInsert(buffPtr^, word2Ptr^);      length2 := length(word2Ptr^);      buffPtr := pointer(ord4(word2Ptr) + length2 + 1);      listSize := listSize + 1;      tmp := tmp + length1 + length2 + 2;      end; {while}   {Build list for dictionary window:  allocate memory for members array,}   {                                   then initialize array.            }   tmp := listSize + 128;               {leave rm for inserts}   if tmp > maxListSize then      tmp := maxListSize;   actListSize := ord(tmp);   memSize := tmp * listMemberSize;   if memSize > MaxBlock then begin     {ensure enough memory for member array}      HandleError($0201, OOMErr);      LoadDict := false;      goto 99;      end; {if}   hndl := NewHandle(memSize, myID, $C010, nil); {allocate the memory}   if toolError <> 0 then begin      HandleError(toolError, memErr);      LoadDict := false;      goto 99;      end; {if}   refCon := ord4(hndl);   listStart := 1;   listRef := ord4(hndl^);   listPtr := pointer(listRef);   end; {with listTempl}for i := 0 to actListSize-1 do begin    {init. members array}   with listPtr^ do begin      phonPtr := nil;      flag := 0;      visNum := -1;      memNum := i;      end; {with}   listPtr := pointer(ord4(listPtr) + listMemberSize);   end; {for}top := 0;                               {init list display}bottom := 4;if bottom > listTempl.listSize then   bottom := listTempl.listSize - 1;DictInit(0);                            {set dict to top}nextEntry := 0;for i := 0 to 4 do                      {make all visMembers available}   visMems[i].memNum := -1;bTmp := MakeVisible(top, bottom);99:end; {LoadDict}{---------------------------------------------------------------}{                                                               }{ OpenDict - Load a new dictionary file.                        }{                                                               }{ Parameters:                                                   }{    theReply - reply record returned by SFGetFile2 call        }{                                                               }{---------------------------------------------------------------}procedure OpenDict {theReply: replyRecord5_0};label 99;var   error: integer;                      {error code returned by system}   hndl: handle;                        {temporaries}   bTmp: boolean;   procedure Return1;   { Helper routine 1 for OpenDict, disposing of SFO handles.   }   begin {Return1}   DisposeHandle(handle(theReply.nameRef));   DisposeHandle(handle(theReply.pathRef));   end; {Return1}   procedure Return2;   { Helper routine 2 for OpenDict, disposing of SFO handles    }   { and read buffer.                                           }   begin {Return2}   DisposeHandle(handle(theReply.nameRef));   DisposeHandle(handle(theReply.pathRef));   DisposeHandle(hndl);   end; {Return2}begin {OpenDict}{Before opening a new dictionary, check if the current dictionary has changed.}if dictChanged then   if WantToSaveDict then begin      Return1;      goto 99;      end; {if}{If the current dictionary is associated with a file, }{release the memory it uses.                          }with userWind[dictWindNum] do begin   if fileFlag then      if wPathHandle <> nil then begin         DisposeHandle(wPathHandle);         wPathHandle := nil;         wPathName := nil;         end; {if}   {We allow a dictionary file to be opened even if the dictionary editor }   {isn't currently up.  However, we need to ensure it's the front window.}   if upFlag then      SelectWindow(windPtr);   end; {with}{Open the file, read it into a buffer, and close the file.}{Convert handle to GS/OS output string to pointer to GS/OS input string.}with openRec do begin   hndl := handle(theReply.pathRef);   pathName := pointer(ord4(hndl^) + 2);   OpenGS(openRec);   if toolError <> 0 then begin      HandleError(toolError, openErr);      Return1;      goto 99;      end; {if}   readRec.refNum := refNum;   closeRec.refNum := refNum;   {If the file is empty, close the file and skip loading it.}   {Initialize the dictionary to empty.                      }   if dataEOF = 0 then begin      CloseGS(closeRec);      if not EmptyDict then begin         Return1;         goto 99;         end; {if}      SetDictName(theReply);      end {if file is empty}   else begin      hndl := NewHandle(dataEOF, myID, $C010, nil);      if toolError <> 0 then begin         HandleError(toolError, memErr);         Return1;         goto 99;         end; {if}      readRec.requestCount := dataEOF;      readRec.dataBuffer := hndl^;      ReadGS(readRec);      error := toolError;      CloseGS(closeRec);      if error <> 0 then begin         HandleError(error, readErr);         Return2;         goto 99;         end; {if}      if not LoadDict(readRec.dataBuffer, readRec.transferCount) then begin         Return2;         goto 99;         end; {if}      SetDictName(theReply);      DisposeHandle(hndl);      end; {if file not empty}   end; {with openRec}{If the dictionary editor is up, we need to recreate the   }{list, English edit-line, and phonetics edit-line controls.}with userWind[dictWindNum] do   if upFlag then      with dCtls^ do begin         HideControl(listCtlHndl);         DisposeControl(listCtlHndl);         listCtlHndl := NewControl2(windPtr, refIsPtr, listTempl);         if toolError <> 0 then begin            HandleError(toolError, ctlErr);            bTmp := DoClose;            goto 99;            end; {if}         HideControl(englCtlHndl);         englishSize := 0;         englishText := '';         LESetText(nil, englishSize, englCtlHndl^^.ctlData);         if toolError <> 0 then begin            HandleError(toolError, ctlErr);            bTmp := DoClose;            goto 99;            end; {if}         ShowControl(englCtlHndl);         HideControl(phonCtlHndl);         phoneticSize := 0;         phoneticText := '';         LESetText(nil, phoneticSize, phonCtlHndl^^.ctlData);         if toolError <> 0 then begin            HandleError(toolError, ctlErr);            bTmp := DoClose;            goto 99;            end; {if}         ShowControl(phonCtlHndl);         end; {with dCtls^}{Perform final clean-up.}with userWind[dictWindNum] do begin   fileFlag := true;   wPathName := openRec.pathName;   wPathHandle := handle(theReply.pathRef);   end; {with}DisposeHandle(theReply.nameRef);dictChanged := false;99:end; {OpenDict}{---------------------------------------------------------------}{                                                               }{ SetDefaultDName - Set dictionary's filename to reflect        }{                   dictionary loaded from default dictionary   }{                   (*/System/SpeechDict).                      }{                                                               }{---------------------------------------------------------------}procedure SetDefaultDName;begin {SetDefaultDName}{Set values in filename's control template and dictionary filename string.}with fnTempl do begin   fileDName.name := 'SpeechDict';   fileDName.size := length(fileDName.name);   textRef := ord4(@fileDName.name);   textSize := fileDName.size;   end; {with}with userWind[dictWindNum] do           {if dict window is up, recreate ctl}   if upFlag then      with dCtls^ do begin         HideControl(fnCtlHndl);         DisposeControl(fnCtlHndl);         fnCtlHndl := NewControl2(windPtr, refIsPtr, fnTempl);         if toolError <> 0 then            HandleError(toolError, ctlErr);         end; {with}end; {SetDefaultDName}{---------------------------------------------------------------}{                                                               }{ SetDictName - Build filename when open dictionary file.       }{                                                               }{---------------------------------------------------------------}procedure SetDictName {theReply: replyRecord5_0};var   tmp: gsosInStringPtr;                {temporaries}   theHandle: handle;begin {SetDictName}{Convert handle to GS/OS output string for filename, returned by SFO in}{reply record to pointer to text.                                      }with fileDName do begin   theHandle := handle(theReply.nameRef);   tmp := pointer(ord4(theHandle^) + 2);   size := tmp^.size;   if size > 15 then      size := 15;   name := tmp^.theString;   end; {with}with fnTempl do begin                   {set values in filename's ctl template}   textRef := ord4(@fileDName.name);   textSize := fileDName.size;   end; {with}with userWind[dictWindNum] do           {if dict window is up, recreate control}   if upFlag then with dCtls^ do begin      HideControl(fnCtlHndl);      DisposeControl(fnCtlHndl);      fnCtlHndl := NewControl2(windPtr, refIsPtr, fnTempl);      if toolError <> 0 then         HandleError(toolError, ctlErr);      end; {if}end; {SetDictName}{---------------------------------------------------------------}{                                                               }{ SetNoFileDName - Set dictionary's filename to < no file >.    }{                                                               }{---------------------------------------------------------------}procedure SetNoFileDName;begin {SetNoFileDName}with fnTempl do begin                   {set dict's filename to none}   textRef := ord4(@noFileDName.name);   textSize := noFileDName.size;   end; {with}with userWind[dictWindNum] do   {If dict window is up, recreate filename control.}   if upFlag then      with dCtls^ do begin         HideControl(fnCtlHndl);         DisposeControl(fnCtlHndl);         fnCtlHndl := NewControl2(windPtr, refIsPtr, fnTempl);         if toolError <> 0 then            HandleError(toolError, ctlErr);         end; {with}end; {SetNoFileDName}end. {DictCmds unit}