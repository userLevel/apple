{$keep 'FileCmds'}{------------------------------------------------------------------}{                                                                  }{ FileCmds - SpeakIt's interface with the file I/O system.         }{                                                                  }{ Written by Barbara Allred                                        }{                                                                  }{ Copyright 1991, Byte Works, Inc.                                 }{ Copyright 1987-1991, First Byte, Inc.                            }{                                                                  }{------------------------------------------------------------------}unit FileCmds;interfaceuses   Common, ToolLocator, DialogMgr, SFToolSet, GSOS, ControlMgr, MemoryMgr,   TextEdit, PrintMgr, WindowMgr, SpeechTools, MenuMgr, QuickDrawII, LineEdit;{$LibPrefix '0/'}uses   Globals, Error, DictCmds, MscCmds;function  CreateWindow (var wInfo: windInfoRec): boolean;function  DoSaveAs (saveDict: boolean): boolean;function  DoSave (saveDict: boolean): boolean;procedure DictSave;function  WantToSave (wNum: integer): boolean;function  WantToSaveDict: boolean;procedure DoNew;procedure DoOpen (dictOnly: boolean);procedure FiniWindow (wNum: integer);function  GetText (var size: longint; wNum: integer): boolean;procedure InitFileCmds;function  InitWindow (var wInfo: windInfoRec): boolean;implementationconst   dictFileType   =   $F2;              {File types}   phonFileType   =   $F1;   ASCIIFileType  =   $04;var                                        {Standard File Operations}                                        {data structures         }                                        {------------------------}   theReply: replyRecord5_0;            {returned by SFO}   openMsg: packed array[0..20] of char; {msg for SFO open dialog}   openTypes: typeList5_0;   saveMsg: packed array[0..27] of char; {msg for SFO save dialog}                                        {filenames for SFO save dialog}   saveTName: gsosInString15;           {default name for text file}   saveDName: gsosInString15;           {default name for dict file}   saveDFName: gsosInString15;          {curr. dict filename}   saveDictAlert: alertTemplate;        {Save dictionary alert}   item00dict: itemTemplate;            {prompt}   item01dict: itemTemplate;            {Yes button}   item02dict: itemTemplate;            {No button}   item03dict: itemTemplate;            {Cancel button}   item00pointerdict: packed array[0..46] of char; {actual prompt}   saveAlert: alertTemplate;            {WantToSave alert box}   item00Save: itemTemplate;            {save message}   item01Save: itemTemplate;            {filename for save}   item02Save: itemTemplate;            {Yes button}   item03Save: itemTemplate;            {No button}   item04Save: itemTemplate;            {Cancel button}   item00pointerSave: packed array[0..27] of char; {actual message}   saveFN: packed array[0..18] of char; {actual filename}{---------------------------------------------------------------}{                                                               }{ CreateWindow - Create new window on the desktop.              }{                                                               }{ Parameters:                                                   }{    wInfo - window number, type to assign to new window;       }{            sets window's grafPort pointer                     }{                                                               }{ Global output:                                                }{    userWind[wInfo.currWindNum].teHndl  - set                  }{    userWind[wInfo.currWindNum].windPtr - set                  }{                                                               }{---------------------------------------------------------------}function CreateWindow {var wInfo: windInfoRec): boolean};label 99;var   wRefCon: refConRec;                  {window's number and type}   bTmp: boolean;                       {temporary variable}begin {CreateWindow}CreateWindow := true;                   {assume all is well to start}with userWind[wInfo.currWindNum] do begin   {Create the window.}   wNum := wInfo.currWindNum;           {set window's number and type}   wTyp := wInfo.currWindTyp;   wRefCon.wNum := wNum;   wRefCon.wTyp := wTyp;   windPtr := NewWindow2(@wName, wRefCon.long, nil, nil, refIsRsrc,      windowID, $800E);   if toolError <> 0 then begin      HandleError(toolError, windErr);      CreateWindow := false;      goto 99;      end; {if}   wInfo.currWindow := windPtr;   {Create window's text edit control.}   teHndl := NewControl2(windPtr, refIsRsrc, textEditID);   if toolError <> 0 then begin      bTmp := DoClose;      HandleError(toolError, windErr);      CreateWindow := false;      end; {if}   end; {with}99:end; {CreateWindow}{---------------------------------------------------------------}{                                                               }{ FiniWindow - Disable New and Open commands if this is the     }{              10th window opened.                              }{                                                               }{ Parameters:                                                   }{    wNum - new window's number                                 }{                                                               }{ Global output:                                                }{    numWindows  - incremented by 1                             }{    userWindows - incremented by 1                             }{    userWind[wNum].upFlag - set to true                        }{                                                               }{---------------------------------------------------------------}procedure FiniWindow {wNum: integer};begin {FiniWindow}userWind[wNum].upFlag := true;            {set flag that window is up}numWindows := numWindows + 1;             {one more open window}userWindows := userWindows + 1;           {one more open user window}if userWindows = 9 then begin   DisableMItem(newID);                 {can't allow creation of new window}   DisableMItem(openID);                {  or opening of text file         }   end; {if}end; {FiniWindow}{---------------------------------------------------------------}{                                                               }{ GetText - Call Text Edit's TEGetText routine to dump text     }{           into the text buffer.                               }{                                                               }{ Parameters:                                                   }{    size - size of text in buffer                              }{    wNum - window's number                                     }{                                                               }{ Returns:  True if text can be returned; false otherwise.      }{                                                               }{ Global output:                                                }{    buffer     - handle to text                                }{    bufferSize - size of text                                  }{                                                               }{---------------------------------------------------------------}function GetText {var size: longint; wNum: integer): boolean};label 99;begin {GetText}GetText := true;size := 0;{Call Text Edit's TEGetTextInfo to determine if the current buffer}{is large enough to hold the text to write.                       }TEGetTextInfo(textInfo, 2, userWind[wNum].teHndl);if toolError <> 0 then begin   HandleError(toolError, teErr);   GetText := false;   goto 99;   end; {if}size := textInfo.charCount;{Attempt to get memory block for text from Memory Manager.}HUnlock(buffer);{If current handle isn't valid, allocate a new memory block.}if toolError <> 0 then begin   buffer := NewHandle(size, myID, $8010, nil);   if toolError <> 0 then begin      HandleError(toolError, memErr);      GetText := false;      goto 99;      end; {if}   end {if}{Otherwise, attempt to grow the current handle.}else begin   SetHandleSize(size, buffer);   if toolError <> 0 then begin      HandleError(toolError, memErr);      GetText := false;      goto 99;      end; {if}   end; {else}HLock(buffer);bufferSize := size;{Call Text Edit's GetText to dump text into buffer.}size := TEGetText($000D, buffer, size, refIsPtr, nil, userWind[wNum].teHndl);if toolError <> 0 then begin   HandleError(toolError, teErr);   GetText := false;   end; {if}99:end; {GetText}{---------------------------------------------------------------}{                                                               }{ InitWindow - Perform window initialization, common to both    }{              DoOpen and DoNew.                                }{                                                               }{ Parameters:                                                   }{    wInfo - sets currWindNum to first free slot in userWind    }{                                                               }{ Global output:                                                }{    userWind[currWindNum].wNum - set to wInfo.currWindNum      }{                                                               }{ Returns:  True if there aren't 10 user windows up yet;        }{           false otherwise.                                    }{                                                               }{---------------------------------------------------------------}function InitWindow {var wInfo: windInfoRec): boolean};label 99;var   i: integer;                          {index into userWind array}begin {InitWindow}InitWindow := true;                     {assume all is well to start}i := 0;                                 {track window # in array}while userWind[i].upFlag do begin       {loop to find empty slot in array}   i := i + 1;   if i > 9 then begin      InitWindow := false;      goto 99;      end; {if}   end; {while}userWind[i].wNum := i;                  {record index into userWind array}wInfo.currWindNum := i;99:end; {InitWindow}{---------------------------------------------------------------}{                                                               }{ SetFileWName - Build filename when open a file.               }{                                                               }{ Parameters:                                                   }{    wNum - window's number                                     }{                                                               }{ Global output:                                                }{    userWind[wNum].wName - set to file's name                  }{                                                               }{---------------------------------------------------------------}procedure SetFileWName(wNum: integer);var   tmp: handle;                         {handle to filename, returned by SFO}   namePtr: ptr;                        {pointer to GS/OS input string}   size: byte;                          {size of filename}   tmpPtr: pStringPtr;                  {pointer to filename}begin {SetFileWName}{Extract the filename from the GS/OS output string returned by SFO.}{We're restricting these names to 15 characters.                   }tmp := handle(theReply.nameRef);namePtr := pointer(ord4(tmp^) + 2);     {move beyond buffer length word}size := namePtr^;if size > 15 then   size := 15;{Convert the GS/OS input string portion of SFO's filename into a}{Pascal-style string in order to move it to the window's title. }namePtr := pointer(ord4(namePtr) + 1);namePtr^ := size;tmpPtr := pStringPtr(namePtr);userWind[wNum].wName := concat(' ', tmpPtr^, ' ');end; {SetFileWName}{---------------------------------------------------------------}{                                                               }{ SetTextWName - Create text window's name.                     }{                                                               }{ Parameters:                                                   }{    wNum - window's number                                     }{                                                               }{ Global output:                                                }{    userWind[wNum].wName - set to ' Text x '                   }{                                                               }{---------------------------------------------------------------}procedure SetTextWName (wNum: integer);var   tmp: packed array[0..8] of char;begin {SetTextWName}{Build window name from the string 'Text' and the window's number.}tmp := ' Text   ';tmp[7] := chr(ord(wNum) + ord('0'));userWind[wNum].wName := tmp;end; {SetTextWName}{---------------------------------------------------------------}{                                                               }{ WriteDictFile - Write dictionary to disk.                     }{                                                               }{ Returns - True if successful in writing file to disk;         }{           false otherwise.                                    }{                                                               }{---------------------------------------------------------------}function WriteDictFile: boolean;label 99;type   charPtr = ^char;var   buffPtr: ptr;                        {pointer to buffer to write to disk}   tmp: pString32Ptr;                   {return value from DictDump function}   stop: boolean;                       {true when reach end of dictionary}   word1,                               {dictionary entry}   word2: pString32;   function FillBuffer (bPtr: charPtr; var size: longint): boolean;   { Fill the write buffer with dictionary entries.             }   {                                                            }   { Parameters:                                                }   {    bPtr - pointer to buffer to fill                        }   {    size - number of characters to write                    }   {                                                            }   { Returns:  True if end of dictionary reached; false         }   {           otherwise.                                       }   var       theEnd: boolean;                 {true if end of dict or end of buffer reached}       len1, len2: integer;             {string sizes of next dictionary entry}       tSize: longint;                  {temporaries}       i: integer;   begin {FillBuffer}   FillBuffer := false;   theEnd := false;   size := 0;   while not theEnd do begin      len1 := length(word1);      len2 := length(word2);      if len1 = 0 then begin            {null English word if end of dictionary}         FillBuffer := true;         theEnd := true;         end {if}      else begin                        {if not at end, write entries to buffer}         tSize := size + len1 + len2 + 2;         if tSize < bufferSize then begin            for i := 0 to length(word1) do begin               bPtr^ := word1[i];               bPtr := pointer(ord4(bPtr) + 1);               end; {for}            for i := 0 to length(word2) do begin               bPtr^ := word2[i];               bPtr := pointer(ord4(bPtr) + 1);               end; {for}            tmp := DictDump(word1, word2);            size := tSize;            end {if}         else            theEnd := true;         end; {if}      end; {while}   end; {FillBuffer}begin {WriteFileDict}{Prepare to begin writing dictionary to disk:  reset dictionary to top, then}{check the buffer we'll be writing into.                                    }WriteDictFile := true;                  {assume all is well to start}stop := false;                          {we're not done yet}DictInit(0);                            {reset dictionary to top}nextEntry := 0;HLock(buffer);if (toolError <> 0) or (bufferSize < 1024) then begin   buffer := NewHandle(1024, myID, $C010, nil);   if toolError <> 0 then begin      HandleError(toolError, memErr);      WriteDictFile := false;      goto 99;      end; {if}   bufferSize := 1024;   end; {if}{Initialize variables prior to entering main loop.}buffPtr := pointer(buffer^);writeRec.dataBuffer := pointer(buffPtr);{Main loop:  while not at end of dictionary, fill the buffer with dictionary}{            entries, then write the buffer to disk.                        }while not stop do begin   tmp := DictDump(word1, word2);       {get 1st dict entry}   stop := FillBuffer(buffPtr, writeRec.requestCount); {fill write buffer}   WriteGS(writeRec);                   {write buffer to disk}   if toolError <> 0 then begin      HandleError(toolError, writeErr);      WriteDictFile := false;      goto 99;      end; {if}   end; {while}{Final clean-up:  Close the file, reset dictionary to top.}dictChanged := false;99:CloseGS(closeRec);DictInit(0);nextEntry := 0;HUnlock(buffer);end; {WriteDictFile}{---------------------------------------------------------------}{                                                               }{ WriteTextFile - Write text window to disk.                    }{                                                               }{ Returns:  True if able to write file to disk; false otherwise.}{                                                               }{---------------------------------------------------------------}function WriteTextFile (wNum: integer): boolean;label 99;var   tePtr: ctlPtr;                       {text window's text edit control handle}begin {WriteTextFile}WriteTextFile := true;                  {assume all is well to start}{Check the dirty bit in the window's text edit control record,}{to see if we really need to save the file.                   }tePtr := userWind[wNum].teHndl^;if (tePtr^.ctlFlag & isDirty) = 0 then   goto 99;{Get the window's text.}if not GetText(writeRec.requestCount, wNum) then begin   WriteTextFile := false;   goto 99;   end; {if}{Write the window to disk.}writeRec.dataBuffer := buffer^;WriteGS(writeRec);if toolError <> 0 then begin   HandleError(toolError, writeErr);   WriteTextFile := false;   goto 99;   end; {if}tePtr^.ctlFlag := tePtr^.ctlFlag & $BF; {clear window's dirty bit}99:CloseGS(closeRec);HUnlock(buffer);end; {WriteTextFile}{---------------------------------------------------------------}{                                                               }{ DoNew - Create new text window.                               }{                                                               }{---------------------------------------------------------------}procedure DoNew;var   wInfo: windInfoRec;begin {DoNew}if InitWindow(wInfo) then               {init window data structures}   with userWind[wInfo.currWindNum] do begin      SetTextWName(wInfo.currWindNum);  {create window's title}      wInfo.currWindTyp := textTyp;     {set window's type}      wTyp := textTyp;      if CreateWindow(wInfo) then begin {create new window on desktop}         fileFlag := false;             {window not assoc. with file}         FiniWindow(wInfo.currWindNum); {disable Open, New commands,}         end; {if}                      {  if necessary             }      end; {with}end; {DoNew}{---------------------------------------------------------------}{                                                               }{ DoOpen - Open an ASCII file and display in new window on the  }{          desktop.                                             }{                                                               }{ Parameters:                                                   }{    dictOnly - true if can only open a dictionary file         }{                                                               }{---------------------------------------------------------------}procedure DoOpen {dictOnly: boolean};label 99;var   wInfo: windInfoRec;                  {information about front wind}   error: integer;                      {error code returned by system}   hndl: handle;                        {temporaries}   bTmp: boolean;   procedure Return1;   { Helper routine 1 for DoOpen, disposing of SFO handles.     }   begin {Return1}   DisposeHandle(handle(theReply.nameRef));   DisposeHandle(handle(theReply.pathRef));   end; {Return1}   procedure Return2;   { Helper routine 2 for DoOpen, disposing of SFO handles and  }   { read buffer.                                               }   begin {Return2}   DisposeHandle(handle(theReply.nameRef));   DisposeHandle(handle(theReply.pathRef));   DisposeHandle(hndl);   end; {Return2}begin {DoOpen}{Set types of files allowed to be opened, based on whether user is}{restricted to opening a dictionary or can open ASCII file, tool. }with openTypes do   if dictOnly then      numEntries := 1   else      numEntries := 4;{Make SFGetFile2 call to bring up SFO Open dialog and get filename and}{pathname of file to open.                                            }SFGetFile2(20, 20, refIsPtr, openMsg, nil, openTypes, theReply);if toolError <> 0 then begin   HandleError(toolError, SFOerr);   goto 99;   end; {if}if theReply.good = 0 then              {Does user want to open a file?}   goto 99;{If user has opened a dictionary file, call OpenDict for it.}if theReply.fileType = dictFileType then begin   OpenDict(theReply);   goto 99;   end; {if}if InitWindow(wInfo) then   if theReply.fileType = phonFileType then      with wInfo do begin         currWindTyp := phonTyp;         userWind[currWindNum].wTyp := phonTyp;         end {with}   else      with wInfo do begin         currWindTyp := textTyp;         userWind[currWindNum].wTyp := textTyp;         end {with}else begin   Return1;   goto 99;   end; {else}{Open the file, read it into a buffer, and close the file.}{Convert handle to GS/OS output string to pointer to GS/OS input string.}with openRec do begin   hndl := handle(theReply.pathRef);   pathName := pointer(ord4(hndl^) + 2);   OpenGS(openRec);   if toolError <> 0 then begin      HandleError(toolError, openErr);      Return1;      goto 99;      end; {if}   readRec.refNum := refNum;   closeRec.refNum := refNum;   {If the file is empty, close the file and skip loading it.}   if dataEOF = 0 then begin      CloseGS(closeRec);      SetFileWName(wInfo.currWindNum);      if not(CreateWindow(wInfo)) then begin          Return1;          goto 99;          end; {if}      FiniWindow(wInfo.currWindNum);      end {if file is empty}   {If the file is not empty, we need to read it into a buffer,       }   {create its window, and fill its text edit control from the buffer.}   else begin      hndl := NewHandle(dataEOF, myID, $C010, nil);      if toolError <> 0 then begin         HandleError(toolError, memErr);         Return1;         goto 99;         end; {if}      readRec.requestCount := dataEOF;      readRec.dataBuffer := hndl^;      ReadGS(readRec);      error := toolError;      CloseGS(closeRec);      if error <> 0 then begin         HandleError(error, readErr);         Return2;         goto 99;         end; {if}      SetFileWName(wInfo.currWindNum);      if not CreateWindow(wInfo) then begin         Return2;         goto 99;         end; {if}      FiniWindow(wInfo.currWindNum);      TESetText($0005, hndl^, readRec.transferCount, refIsPtr,                nil, nil);      if toolError <> 0 then begin         HandleError(toolError, TEErr);         Return2;         goto 99;         end; {if}      DisposeHandle(hndl);      end; {if file not empty}   end; {with openRec}{Perform final clean-up.}with userWind[wInfo.currWindNum] do begin   upFlag := true;   fileFlag := true;   wPathName := openRec.pathName;   wPathHandle := handle(theReply.pathRef);   end; {with}DisposeHandle(theReply.nameRef);99:end; {DoOpen}{---------------------------------------------------------------}{                                                               }{ DoSaveAs - Use Standard File Operations to save a window or   }{            the dictionary to disk.                            }{                                                               }{ Parameters:                                                   }{    saveDict - true if saving current dictionary               }{                                                               }{ Returns:  True if save operation cancelled; false otherwise.  }{                                                               }{---------------------------------------------------------------}function DoSaveAs {saveDict: boolean): boolean};label 99;var   wInfo: windInfoRec;                  {information about front window}   tmp: gsosInStringPtr;                {temporaries}   hndl: handle;begin {DoSaveAs}DoSaveAs := true;                       {assume can't save the file}{We can save the dictionary without its window being open.}if saveDict then   with wInfo do begin      currWindTyp := dictTyp;      currWindNum := dictWindNum;      end {with}else if not MyWindow(wInfo) then        {ensure the front window is ours}   goto 99;{Make SFPutFile2 call to bring up SFO Save dialog and get filename and}{pathname of file to create, open, and then write.  The default name  }{to display in the dialog is based on whether the file is a dictionary}{and if so, if a filename is currently associated with the dictionary.}if wInfo.currWindTyp = dictTyp then   if userWind[dictWindNum].fileFlag then      tmp := @saveDFName   else      tmp := @saveDNameelse   tmp := @saveTName;SFPutFile2(20, 20, refIsPtr, saveMsg, refIsPtr, tmp, theReply);if toolError <> 0 then begin   HandleError(toolError, SFOErr);   goto 99;   end; {if}if theReply.good = 0 then               {Does user want to open a file?}   goto 99;{Fill in GS/OS parameter block fields.}hndl := handle(theReply.pathRef);tmp := pointer(ord4(hndl^) + 2);        {skip buffer length word}getFileInfoRec.pathName := tmp;openRec.pathName := tmp;destroyRec.pathName := tmp;createRec.pathName := tmp;{Make GetFileInfo call to see if file currently exists.}{If so, delete the old file.                           }GetFileInfoGS(getFileInfoRec);if toolError <> 0 then begin   if toolError <> fileNotFoundErr then begin      HandleError(toolError, fileErr);      goto 99;      end {if}   end {if}else begin   DestroyGS(destroyRec);   if toolError <> 0 then begin      HandleError(toolError, delErr);      goto 99;      end {if}   end; {else}{Create new file.  Set its filetype based on front window's type.}with createRec do   if wInfo.currWindTyp = phonTyp then      fileType := phonFileType   else if wInfo.currWindTyp = dictTyp then      fileType := dictFileType   else      fileType := ASCIIFileType;CreateGS(createRec);if toolError <> 0 then begin   HandleError(toolError, createErr);   goto 99;   end; {if}{Open the file.}OpenGS(openRec);if toolError <> 0 then begin   HandleError(toolError, openErr);   goto 99;   end;{if}with openRec do begin   writeRec.refNum := refNum;   closeRec.refNum := refNum;   end; {with}{Check if file currently associated with this window.}{If so, release its path handle.                     }with userWind[wInfo.currWindNum] do   if fileFlag then      if wPathHandle <> nil then begin         DisposeHandle(wPathHandle);         wPathHandle := nil;         end; {if}{Write the file to disk and update file's name in window display.}if wInfo.currWindTyp = dictTyp then begin   if not WriteDictFile then      goto 99;   SetDictName(theReply);   end {if}else   with wInfo do begin      if not WriteTextFile(currWindNum) then         goto 99;      SetFileWName(currWindNum);      SetWTitle(userWind[currWindNum].wName, currWindow);      end; {with}{Set window information.}with userWind[wInfo.currWindNum] do begin   fileFlag := true;   wPathName := openRec.pathName;   wPathHandle := handle(theReply.pathRef);   end; {with}DoSaveAs := false;99:end; {DoSaveAs}{---------------------------------------------------------------}{                                                               }{ DoSave - Save a window or the dictionary to disk.             }{                                                               }{ Parameters:                                                   }{    saveDict - true if saving current dictionary               }{                                                               }{ Returns:  True if user cancelled save operation; false        }{           otherwise;                                          }{                                                               }{---------------------------------------------------------------}function DoSave {saveDict: boolean): boolean};label 99;var   wInfo: windInfoRec;                  {info about front window}   btmp: boolean;begin {DoSave}DoSave := true;                         {assume can't save the file}{We can save the dictionary without its window being open.}if saveDict then   with wInfo do begin      currWindTyp := dictTyp;      currWindNum := dictWindNum;      end {with}else if not MyWindow(wInfo) then        {ensure the front window is ours}   goto 99;{If the window has never been saved to disk, execute DoSaveAs.}if not userWind[wInfo.currWindNum].fileFlag then begin   DoSave := DoSaveAs(saveDict);   goto 99;   end; {if}{Open the file and set its length to zero.}openRec.pathName := userWind[wInfo.currWindNum].wPathName;OpenGS(openRec);if toolError <> 0 then begin   HandleError(toolError, openErr);   goto 99;   end; {if}with openRec do begin   setEOFRec.refNum := refNum;   writeRec.refNum := refNum;   closeRec.refNum := refNum;   end; {with}SetEOFGS(setEOFRec);if toolError <> 0 then begin   HandleError(toolError, zeroErr);   CloseGS(closeRec);   goto 99;   end; {if}{Call appropriate routine to write file to disk, based on file's type.}if wInfo.currWindTyp = dictTyp then begin   if not WriteDictFile then      goto 99;   end {if}else begin   if not WriteTextFile(wInfo.currWindNum) then      goto 99;   end; {else}DoSave := false;99:end; {DoSave}{---------------------------------------------------------------}{                                                               }{ DictSave - Save current dictionary to disk.                   }{                                                               }{---------------------------------------------------------------}procedure DictSave;begin {DictSave}{Get default filename to use in SFO dialog.}with userWind[dictWindNum] do   {If dictionary associated with a file, use file's name.}   if fileFlag then begin      saveDFName.size := fileDName.size;      saveDFName.name := fileDName.name;      end; {if}{Bring up SFO dialog to get pathname of file to receive dictionary,}{then initialize the file.                                         }if not DoSaveAs(true) then   dictChanged := false;end; {DictSave}{---------------------------------------------------------------}{                                                               }{ WantToSave - Ask user if he wants to save a text window       }{              before closing it.                               }{                                                               }{ Returns:  True if Cancel selected                             }{                                                               }{---------------------------------------------------------------}function WantToSave {wNum: integer): boolean};var   answer: integer;begin {WantToSave}{Copy filename to save alert template.}saveFN := concat(userWind[wNum].wName, '?');{Bring up alert.  Assume at first that Cancel will not be selected.}WantToSave := false;answer := NoteAlert(saveAlert, nil);if answer = 1 then begin   if DoSave(false) then                {give chance to cancel}      WantToSave := true;   end {if}else if answer = 2 then   WantToSave := true;end; {WantToSave}{---------------------------------------------------------------}{                                                               }{ WantToSaveDict - Ask user if he wants to save current         }{                  dictionary before disposing of it.           }{                                                               }{ Returns:  True if Cancel selected; false otherwise.           }{                                                               }{---------------------------------------------------------------}function WantToSaveDict {:boolean};var   answer: integer;begin {WantToSaveDict}{Bring up alert.  Assume at first that Cancel will not be selected.}WantToSaveDict := false;answer := NoteAlert(saveDictAlert, nil);if answer = 1 then begin   if DoSave(true) then      WantToSaveDict := true;   end {if}else if answer = 2 then   WantToSaveDict := true;end; {WantToSaveDict}{---------------------------------------------------------------}{                                                               }{ InitFileCmds - Initialize the FileCmds unit.                  }{                                                               }{---------------------------------------------------------------}procedure InitFileCmds;begin {InitFileCmds}{Initialize Standard File Operations data structures.}with theReply do begin   nameVerb := RefIsSpecial;   pathVerb := RefIsSpecial;   end; {with}openMsg := 'Select file to open:';with openTypes do begin   numEntries := 4;                     {number of entries in filetype list}   with fileAndAuxTypes[1] do begin      flags := $8000;                   {match filetype, any auxtype, selectable}      fileType := $F2;                  {dictionary file}      auxType := 0;                     {don't care about auxtype}      end; {with}   with fileAndAuxTypes[2] do begin      flags := $8000;                   {match filetype, any auxtype, selectable}      fileType := $04;                  {ASCII text file}      auxType := 0;                     {don't care about auxtype}      end; {with}   with fileAndAuxTypes[3] do begin      flags := $8000;                   {match filetype, any auxtype, selectable}      fileType := $B0;                  {ORCA/APW source file}      auxType := 0;                     {don't care about auxtype}      end; {with}   with fileAndAuxTypes[4] do begin      flags := $8000;                   {match filetype, any auxtype, selectable}      fileType := $F1;                  {phonetics text file}      auxType := 0;                     {don't care about auxtype}      end; {with}   end; {with}saveMsg := 'Enter name of file to save:'; {msg to display in SFO save dialog}with saveTName do begin                 {default name for text file}   size := 7;   name := 'newFile';   end; {with}with saveDName do begin                 {default name for dict file}   size := 10;   name := 'SpeechDict';   end; {with}with saveDFName do begin                {current dictionary filename}   size := 15;   name := '               ';   end; {with}{Initialize save file dialogs.}with saveAlert do begin                 {Save dictionary alert}   with atBoundsRect do begin      v1 := $31;      h1 := $88;      v2 := $65;      h2 := $1ED;      end; {with}   atAlertID := 2;   atStage1 := $81;   atStage2 := $81;   atStage3 := $81;   atStage4 := $81;   atItemList[1] := @item00Save;   atItemList[2] := @item01Save;   atItemList[3] := @item02Save;   atItemList[4] := @item03Save;   atItemList[5] := @item04Save;   atItemList[6] := nil;   end; {with}with item00Save do begin                {save message}   itemID := $64;   with itemRect do begin      v1 := 7;      h1 := 120;      v2 := 17;      h2 := 329;      end; {with}   itemType := $800F;   itemDescr := @item00PointerSave;   itemValue := 27;   itemFlag := 1;   itemColor := nil;   end; {with}with item01Save do begin                {save alert's filename template}   itemID := $65;   with itemRect do begin      v1 := 19;      h1 := 130;      v2 := 29;      h2 := 230;      end; {with}   itemType := $800F;   itemDescr := @saveFN;   itemValue := 18;   itemFlag := 1;   itemColor := nil;   end; {with}with item02Save do begin                {save alert's OK button template}   itemID := 1;   with itemRect do begin      v1 := 32;      h1 := 32;      v2 := 45;      h2 := 94;      end; {with}   itemType := $A;   itemDescr := @yesTitle;   itemValue := 0;   itemFlag := 0;   itemColor := nil;   end; {with}with item03Save do begin                {save alert's No button template}   itemID := 3;   with itemRect do begin      v1 := 32;      h1 := 134;      v2 := 45;      h2 := 208;      end; {with}   itemType := $A;   itemDescr := @noTitle;   itemValue := 0;   itemFlag := 0;   itemColor := nil;   end; {with}with item04Save do begin                {save alert's Cancel button template}   itemID := 2;   with itemRect do begin      v1 := 32;      h1 := 239;      v2 := 45;      h2 := 325;      end; {with}   itemType := $A;   itemDescr := @cancelTitle;   itemValue := 0;   itemFlag := 0;   itemColor := nil;   end; {with}item00pointerSave := 'Save changes before closing';saveFN := '                  ';with saveDictAlert do begin             {WantToSaveDict alert box}   with atBoundsRect do begin      v1 := $33;      h1 := $28;      v2 := $83;      h2 := $212;       end; {with}   atAlertID := 4;   atStage1 := $81;   atStage2 := $81;   atStage3 := $81;   atStage4 := $81;   atItemList[1] := @item00dict;   atItemList[2] := @item01dict;   atItemList[3] := @item02dict;   atItemList[4] := @item03dict;   atItemList[5] := nil;   end; {with}with item00dict do begin                {dict save alert's prompt template}   itemID := $64;   with itemRect do begin      v1 := 13;      h1 := 131;      v2 := 23;      h2 := 463;      end; {with}   itemType := $800F;   itemDescr := @item00pointerdict;   itemValue := 46;   itemFlag := 0;   itemColor := nil;   end; {with}with item01dict do begin                {dict save alert's Yes button}   itemID := 1;   with itemRect do begin      v1 := 42;      h1 := 54;      v2 := 55;      h2 := 133;      end; {with}   itemType := $A;   itemDescr := @yesTitle;   itemValue := 0;   itemFlag := 1;   itemColor := nil;   end; {with}with item02dict do begin                {dict save alert's No button}   itemID := 3;   with itemRect do begin      v1 := 42;      h1 := 194;      v2 := 55;      h2 := 276;      end; {with}   itemType := $A;   itemDescr := @noTitle;   itemValue := 0;   itemFlag := 0;   itemColor := nil;   end; {with}with item03dict do begin                {dict save alert's Cancel button}   itemID := 2;   with itemRect do begin      v1 := 42;      h1 := 349;      v2 := 55;      h2 := 435;      end; {with}   itemType := $A;   itemDescr := @cancelTitle;   itemValue := 0;   itemFlag := 0;   itemColor := nil;   end; {with}item00pointerdict := 'Would you like to save the current dictionary?';end; {InitFileCmds}end. {FileCmds unit}