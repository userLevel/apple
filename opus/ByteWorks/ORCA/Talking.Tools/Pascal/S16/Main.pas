{$keep 'main'}{---------------------------------------------------------------}{                                                               }{ SpeakIt - A desktop program to show how Talking Tools works.  }{                                                               }{ Written by Barbara Allred, with a little help from her        }{ friends.                                                      }{                                                               }{ Copyright 1991 by Byte Works, Inc.                            }{ Copyright 1987-1991 by First Byte, Inc.                       }{                                                               }{---------------------------------------------------------------}{								}{ Version 1.0.2							}{								}{ December 1995							}{ Mike Westerfield						}{								}{   1.	Recompiled the headers so they work with the latest	}{	release of the compiler.				}{   2.	Fixed several bugs that caused the program to crash	}{	when you tried to manipulate new dictionary entries	}{	that did not have a phonetic translation.		}{   3.	Made changes so the program compiles with the modern	}{	interfaces.						}{								}{---------------------------------------------------------------}program SpeakIt;uses   Common, ToolLocator, MemoryMgr, MscToolSet, QuickDrawII, EventMgr, WindowMgr,   ControlMgr, MenuMgr, LineEdit, DialogMgr, SFToolSet, ListMgr, PrintMgr,   IntegerMath, TextEdit, SpeechTools, GSOS, DeskMgr;{$LibPrefix '0/'}uses   Globals, Error, MscCmds, DictCmds, FileCmds, SpeechCmds;var   startStopRef: longint;               {hndl from StartUpTools call}   taskRec: eventRecord;                {extended task record}{---------------------------------------------------------------}{                                                               }{ DoQuit - Handle Quit command.                                 }{                                                               }{---------------------------------------------------------------}procedure DoQuit;label 100;var   bTmp: boolean;begin {DoQuit}{Check need to save dictionary.}if dictChanged then   if WantToSaveDict then               {if cancel chosen, abort Quit command}      goto 100;{Close all open windows.}while numWindows > 0 do   if DoClose then                      {give chance to cancel}      goto 100;done := true;                           {set the done flag}100:end; {DoQuit}{---------------------------------------------------------------}{                                                               }{ HandleMenu - Dispatch appropriate routine for menu items      }{              numbered 256 and above.                          }{                                                               }{---------------------------------------------------------------}procedure HandleMenu;type   menuIDs = 256..268;                  {menu items}var   theItem: integer;                    {menu item ID}   menuNum: integer;                    {item's menu number}   btmp: boolean;begin {HandleMenu}theItem := hiLow(taskRec.taskData).lo;  {menu item, menu number are}menuNum := hiLow(taskRec.taskData).hi;  {  passed in taskData field}{Dispatch appropriate routine, based on wmTaskData value, the menu item ID.}case theItem of   aboutID:    DoAbout;   newID:      DoNew;   openID:     DoOpen(false);   saveID:     btmp := DoSave(false);   saveAsID:   btmp := DoSaveAs(false);   pSetUpID:   DoPSetUp;   printID:    DoPrint;   quitID:     DoQuit;   speakID:    DoSpeak;   phonID:     DoShowPhonetics;   setID:      DoSetParameters;   dictID:     DoDict;   activeID:   DoActivate;   end; {case}{Unhighlight the menu the user pulled down.}HiliteMenu(false, menuNum);end; {HandleMenu}{---------------------------------------------------------------}{                                                               }{ HandleSpecial - Handle special menu commands,                 }{                 menu IDs 250 - 255.                           }{                                                               }{---------------------------------------------------------------}procedure HandleSpecial;var   theItem: integer;                    {menu item ID}   menuNum: integer;                    {item's menu number}   bTmp: boolean;begin {HandleSpecial}theItem := hiLow(taskRec.taskData).lo;  {menu item, menu number are}menuNum := hiLow(taskRec.taskData).hi;  {  passed in taskData field}{The only special menu item we need handle is Close.}if theItem = closeID then   bTmp := DoClose;HiliteMenu(false, menuNum);end; {HandleSpecial}{---------------------------------------------------------------}{                                                               }{ HandleUpdate - Handle update event for active window.         }{                                                               }{---------------------------------------------------------------}procedure HandleUpdate;begin {HandleUpdate}BeginUpdate(grafPortPtr (taskRec.taskData));DrawControls(grafPortPtr (taskRec.taskData));EndUpdate(grafPortPtr(taskRec.taskData));end; {HandleUpdate}{---------------------------------------------------------------}{                                                               }{ Init - Initialize global variables, start the tools we need,  }{        then create our menu bar.                              }{                                                               }{ Returns:  True if able to start program; false otherwise.     }{                                                               }{---------------------------------------------------------------}function Init: boolean;label 99;var   i: integer;                          {index}begin {Init}Init := false;                          {assume all is not well}{Start the tools we need.}myID := userID;                         {get user ID passed to us}startStopRef := StartUpTools(myID, refIsRsrc, longint(startStopID));if toolError <> 0 then   goto 99;{Initialize all of the program's units.}InitError;if not InitGlobals then   goto 99;if not InitSpeechCmds then   goto 99;if not InitMscCmds then   goto 99;InitFileCmds;if not InitDictCmds then   goto 99;{Create the menu bar.}SetSysBar(NewMenuBar2(refIsRsrc, longint(menuBarID), nil));SetMenuBar(nil);FixAppleMenu(1);                        {add desk accessories to Apple menu}i := FixMenuBar;                        {compute std sizes, menu bar/menus}DrawMenuBar;{StartUpTools brings up the watch cursor so change it to the arrow.}InitCursor;Init := true;99:end; {Init}{---------------------------------------------------------------}{                                                               }{ EventLoop - Get next event, then dispatch the appropriate     }{             routine to handle it.                             }{                                                               }{---------------------------------------------------------------}procedure EventLoop;type   ctlIDs = 8..25;var   theEvent: integer;                   {event code returned by TaskMaster}   theCtl: ctlIDs;                      {control ID, if control event}   bTmp: boolean;begin {EventLoop}done := false;                          {we ain't done yet}taskRec.taskMask := $001FBFFF;          {ask TaskMaster to handle as much as possible}while not done do begin   theEvent := TaskMaster($076E, taskRec);   if toolError <> 0 then      FatalErr(toolError);   {Dispatch appropriate routine, based on event.}   if theEvent = inUpdate then      HandleUpdate   else if theEvent = wInSpecial then      HandleSpecial   else if theEvent = wInGoAway then      bTmp := DoClose   else if theEvent = wInMenuBar then      HandleMenu   else if theEvent = wInControl then begin      theCtl := ord(taskRec.taskData4);      if theCtl > 15 then         case theCtl of            16:  DictAddWord;            17:  DictDeleteWord;            18:  DictConvertWord;            19:  DictSpeakWord;            20:  ;            21:  DictSave;            22:  DoOpen(true);            23:  DictClear;            24:  DoPrint;            25:  bTmp := DoClose;            end; {case}      end; {else if wInControl}   end; {while}end; {EventLoop}{---------------------------------------------------------------}{                                                               }{ ShutDown - Unload the tools we started.                       }{                                                               }{---------------------------------------------------------------}procedure ShutDown;begin {ShutDown}FemaleShutDown;                         {shut down speech tools}MaleShutDown;ParseShutDown;SpeechShutDown;ShutDownTools(refIsHndl, startStopRef); {shut down all other}if toolError <> 0 then                  {  tools we started }    FatalErr(toolError);end; {ShutDown}{---------------------------------------------------------------}{                                                               }{ Main program - Initialize the program, call the event loop,   }{                then shut down the program.                    }{                                                               }{---------------------------------------------------------------}beginif Init then                            {start tools, bring up menu bar}   EventLoop;                           {execute main event loop}ShutDown;                               {unload tools, clean up}end. {SpeakIt}