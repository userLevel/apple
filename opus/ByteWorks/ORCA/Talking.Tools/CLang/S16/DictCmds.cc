/***************************************************************** DictCmds - Commands to control TalkingTools' on-line dictionary.** Written by Barbara Allred and Mike Westerfield** Copyright 1991, Byte Works, Inc.* Copyright 1987-1991, First Byte, Inc.****************************************************************/#pragma keep "DictCmds"#pragma noroot#pragma optimize 9#include "globals.h"#include "error.h"#include "msccmds.h"typedef struct {                        /* array used for list display of curr dict */   int memNum;   pString32 english;   } visMembers;int  actListSize = 0;                   /* # members can be held in curr list */int  top = 0;                           /* member # at top of list display */int  bottom = 0;                        /* member # at bottom of list display */int  englishSize;                       /* text size, English edit box */char englishText[33];                   /* English word in edit box */int  phoneticSize;                      /* text size, phonetic edit box */char phoneticText[33];                  /* phonetic word in edit box */int  dActiveFlag = -1;                  /* non-zero if dict is active */char activeMsg[] = "\pDictionary on";   /* menu item when dict NOT active */char inactiveMsg[] = "\pDictionary off"; /* menu item when dict is active */char mountPrompt[] =                    /* prompt to mount boot disk */   "\pPlease place boot disk on-line";gsosInString19 defaultDName = {         /* default dictionary name */   19, "*/System/SpeechDict"   };gsosInString15 noFileDName = {          /* name when dict not from file */   15, "< no file >    "   };visMembers visMems[5] = {               /* dict's list display */   -1, "\p                                ",   -1, "\p                                ",   -1, "\p                                ",   -1, "\p                                ",   -1, "\p                                "   };StaticTextTemplate fnTempl = {          /* dict filename template */   8, 8L, {5, 307, 15, 397}, 0x81000000L, 0, 0x1000, 0L,   (Ref) &noFileDName.name, 15   };extern int WantToSaveDict(void);/* Located in FileCmds module, which INCLUDES this module. *//***************************************************************** MakeInvisible - Removes elements from currently visible*                 portion of the list.** Parameters:*       firstMem - 1st element to be removed*       lastMem  - last element to be removed****************************************************************/void MakeInvisible (int firstMem, int lastMem){listMemberPtr listPtr;int i, j;/* Set visible member array elements' visMem number to -1. */listPtr = (void *) (((unsigned long) listTempl.listRef)          + (firstMem * sizeof(listMember)));for (i = firstMem; i <= lastMem; ++i) {   j = listPtr->visNum;   if (j != -1) {      visMems[j].memNum = -1;      listPtr->visNum = -1;      }   ++listPtr;   }}/***************************************************************** SetEndVars - Resets dictionary's list variables, in case the*              end of the dictionary is unexpectedly reached.** Returns - true if dictionary is empty****************************************************************/boolean SetEndVars (void){listTempl.listSize = nextEntry;         /* list size has changed */listTempl.listStart = listTempl.listSize - 4;if (listTempl.listSize == 0) {   listTempl.listStart = 0;   return TRUE;   }if (listTempl.listStart < 1)   listTempl.listStart = 1;bottom = listTempl.listSize - 1;        /* we number from 0 */top = bottom - 4;if (top < 0)   top = 0;DictInit(0);                            /* reset dictionary to top */nextEntry = 0;return FALSE;}/***************************************************************** MakeVisible - Adds elements to currently visible portion of*               the list.** Parameters:*       firstMem - first element to be added*       lastMem  - last element to be added** Returns - true if list has changed****************************************************************/boolean MakeVisible (int firstMem, int lastMem){int oldTop, oldBottom;                  /* former top, bottom display elements */listMemberPtr listPtr;                  /* pointer into list member array */pString32 word1, word2;                 /* dictionary entry */pString32Ptr tmp;                       /* temporaries */int i;/* Check need to reset dictionary to ensure ability to reach firstMem entry. */if (firstMem < nextEntry) {   DictInit(0);   nextEntry = 0;   }/* Loop to reach first dictionary entry, dumping unneeded entries. */while (nextEntry < firstMem) {   tmp = DictDump(word1, word2);   if (word1[0] == 0) {                 /* if reach end of dict, */      if (SetEndVars())                 /*   execute End routine */         MakeVisible(top, bottom);      return TRUE;      }   nextEntry++;   }/* Loop to dump dictionary entries firstMem through lastMem, initializing *//* our list data structures as we go.                                     */listPtr = (void *) (((unsigned long) listTempl.listRef)          + (firstMem * sizeof(listMember)));i = 0;while (firstMem <= lastMem) {   while (visMems[i].memNum != -1) {    /* TAKEN FOR GRANTED THAT CALLER */      ++i;                              /* HAS INITIALIZED VISMEMS ARRAY */      if (i == 5)                       /* sanity check */         return TRUE;      }   tmp = DictDump(word1, word2);        /* get next dict entry */   /* If end of dictionary reached, reset dictionary variables. */   if (word1[0] == 0) {      oldTop = top;      oldBottom = bottom;      if (! SetEndVars())         return TRUE;      /* Determine which entries for the changed */      /* display we still need to get.           */      if ((oldBottom >= top) && (oldBottom <= bottom))         MakeVisible(oldBottom+1, bottom);      else if ((oldTop >= top) && (oldTop <= bottom))         MakeVisible(top, oldTop-1);      else         MakeVisible(top, bottom);      return TRUE;      }   visMems[i].memNum = firstMem;        /* init display array */   memcpy(visMems[i].english, word1, word1[0]+1);   listPtr->visNum = i;                 /* init member array element */   listPtr->flag = 0;   listPtr->phonPtr = (void *) tmp;   ++listPtr;                           /* move to next member record */   ++firstMem;   ++i;                                 /* move to next display element */   ++nextEntry;                         /* move to next dict element */   }return FALSE;}/***************************************************************** AdjustList - After inserting or deleting a dictionary entry, scroll*              list display to page containing affected entry.** Parameters:*       englPtr - pointer to English word of inserted/deleted entry****************************************************************/void AdjustList (pString32Ptr englPtr){boolean found;                          /* true when entry found or passed */listMemberPtr listPtr;                  /* pointer into list member array */pString32 word1, word2;                 /* dictionary entry */int count, i;                           /* misc counters */char s1[33], s2[33];                    /* C equivalents of pStrings */char *tmp;/* Scroll the display so that the new word will appear within the list. *//* Start by removing all of the words currently visible, then search    *//* the dictionary for our new word, filling the display array as we go. */MakeInvisible(top, bottom);found = FALSE;listTempl.listStart = -4;listPtr = (listMemberPtr) (listTempl.listRef);/* Outer loop: dump dictionary entries until we find the one we were passed. */do {                                    /* move to next display page */   listTempl.listStart = listTempl.listStart + 5;   top = nextEntry;   bottom = top + 4;   /* Inner loop:  fill visMems array with next group of 5 elements. */   count = 0;   while (count < 5) {      tmp = DictDump(word1, word2);     /* get next dict entry */      if (word1[0] == 0) {              /* if end-of-dict do */         listTempl.listSize = nextEntry; /*  adjust listSize */         bottom = listTempl.listSize - 1; /*  adjust display */         top = bottom - 4;         if (top < 0)            top = 0;         listTempl.listStart = top + 1;         DictInit(0);                   /*  reset dict. to top */         nextEntry = 0;         count = 5;                     /*  bail out of inner loop */         found = TRUE;                  /*  bail out of out loop */         }      else {                                        /* load English entry into display */         memcpy(visMems[count].english, word1, word1[0]+1);         visMems[count].memNum = nextEntry;         if (!found) {                  /* check entry is one we seek */            strcpy(s1, p2cstr(englPtr));            strcpy(s2, p2cstr(word1));            if (strcmp(s1, s2) < 0)               found = TRUE;            }         listPtr->flag = 0;             /* set non-display values */         listPtr->phonPtr = tmp;        /*   for this list member */         ++count;         ++nextEntry;         ++listPtr;         } /* not end of dict */      } /* while count < 5 */   }while (!found);/* Set visNums for elements in display. */i = top;   count = 0;while ((i <= bottom) && (count < 5)) {   if (visMems[count].memNum != -1) {      listPtr = (void *) ( ((unsigned long) listTempl.listRef)                + (visMems[count].memNum * sizeof(listMember)) );      listPtr->visNum = count;      }   ++i;   ++count;   }/* We're now ready to recreate the control and exit. */userWind[dictWindNum].wCtl.dCtls->listCtlHndl =   NewControl2(userWind[dictWindNum].windPtr, refIsPtr, (Ref) &listTempl);if (toolerror() != 0) {   HandleError(toolerror(), ctlErr);   DoClose();   }else   dictChanged = TRUE;}/***************************************************************** GetEnglishBox - Retrieves contents of English word edit box*                 in dictionary window, translating to upper case.** Global Output:*       englishSize - size of English text*       englishText - English text****************************************************************/void GetEnglishBox (void){LERecHndl  tmp;                         /* handle to box' line-edit record */CtlRecHndl theHandle;                   /* "generic" control handle */handle hndl;                            /* "generic" handle */int i;                                  /* loop index */char *cPtr;                             /* pointer to box' text *//* Get pointer to English word from the edit record.  Edit record handle is *//* stored in the control's control record.                                  */theHandle = userWind[dictWindNum].wCtl.dCtls->englCtlHndl;tmp = (LERecHndl) (*theHandle)->ctlData;/* Call Line Edit toolset for the English word's size and text. */englishSize = LEGetTextLen(tmp);hndl = LEGetTextHand(tmp);cPtr = (void *) *hndl;for (i = 1; i <= englishSize; ++i) {   englishText[i] = toupper(*cPtr);   ++cPtr;   }englishText[0] = englishSize;}/***************************************************************** GetPhonBox - Retrieves contents of phonetics word edit box in*              dictionary window.** Global Output:*       phoneticSize - size of phonetic text*       phoneticWord - phonetic text****************************************************************/void GetPhonBox (void){LERecHndl tmp;                          /* handle to box' line-edit record */CtlRecHndl theHandle;                   /* "generic" control handle */handle hndl;                            /* "generic" handle */char *cPtr;                             /* pointer to box' text */int i;                                  /* loop index *//* Get pointer to phonetic word from the edit record.  Edit record handle is *//* stored in the control's control record.                                   */theHandle = userWind[dictWindNum].wCtl.dCtls->phonCtlHndl;tmp = (LERecHndl) (*theHandle)->ctlData;/* Call Line Edit toolset for the English word's size and text. */phoneticSize = LEGetTextLen(tmp);hndl = LEGetTextHand(tmp);cPtr = (void *) *hndl;for (i = 1; i <= phoneticSize; ++i) {   phoneticText[i] = *cPtr;   ++cPtr;   }phoneticText[0] = phoneticSize;}/***************************************************************** ListDrawRtn - Draws dictionary list member into list control.** Parameters:*       theRect - pointer to rect. enclosing member*       theMem  - pointer to member record to be drawn*       theList - list control handle****************************************************************/#pragma databank 1#pragma toolparms 1pascal void ListDrawRtn (RectPtr theRect, listMemberPtr theMem,                        CtlRecHndl theList){int oldTop, oldBottom;                  /* members at top/bottom of list display */int tmp;                                /* temporaries */boolean btmp;char *wordPtr;int i;/* Check whether requested element to be drawn is currently visible. */if (theMem->visNum == -1) {             /* -1 signals not visible */   /* If the element is not visible, will need to revise the list.      */   /* First calculate the list display's new top and bottom members.    */   /* The new top is derived from this member's position in the window. */   /* Position is distance from top of member's rect to top of list     */   /* control's rect divided by height of member's rectangle.           *//* SysBeep(); /* debug */   oldTop = top;   oldBottom = bottom;   tmp = (theRect->v1 - (*theList)->ctlRect.v1)               / (theRect->v2 - theRect->v1);   top = theMem->memNum - tmp;   bottom = top + 4;   /* Make the proper items visible. */   MakeInvisible(oldTop, oldBottom);   btmp = MakeVisible(top, bottom);   /* The MakeVisible routine determines whether the list size has changed. */   /* If so, we'll need to recreate the list control. */   if (btmp) {      HideControl(userWind[dictWindNum].wCtl.dCtls->listCtlHndl);      DisposeControl(userWind[dictWindNum].wCtl.dCtls->listCtlHndl);      userWind[dictWindNum].wCtl.dCtls->listCtlHndl =         NewControl2(userWind[dictWindNum].windPtr, refIsPtr, (Ref) &listTempl);      if (toolerror())         HandleError(toolerror(), ctlErr);      return;      }   }/* The member is visible, access it from the visMems array. */EraseRect(theRect);PenNormal();ShowPen();MoveTo(theRect->h1+5, theRect->v2-1);DrawString((void *) visMems[theMem->visNum].english);/* If the member was selected, copy its English word to the English  *//* edit-line box, and its phonetics word to the phonetics edit-line  *//* box.  Invert the member's view rectangle to show it was selected. */if (theMem->flag) {   HideControl(userWind[dictWindNum].wCtl.dCtls->englCtlHndl);   englishSize = visMems[theMem->visNum].english[0];   wordPtr = &visMems[theMem->visNum].english[1];   LESetText(wordPtr, englishSize,      (LERecHndl) (*userWind[dictWindNum].wCtl.dCtls->englCtlHndl)->ctlData);   if (toolerror())      HandleError(toolerror(), ctlErr);   ShowControl(userWind[dictWindNum].wCtl.dCtls->englCtlHndl);   HideControl(userWind[dictWindNum].wCtl.dCtls->phonCtlHndl);   phoneticSize = theMem->phonPtr[0];   wordPtr = &theMem->phonPtr[1];   LESetText(wordPtr, phoneticSize,      (LERecHndl) (*userWind[dictWindNum].wCtl.dCtls->phonCtlHndl)->ctlData);   if (toolerror())      HandleError(toolerror(), ctlErr);   ShowControl(userWind[dictWindNum].wCtl.dCtls->phonCtlHndl);   InvertRect(theRect);                 /* invert member's rectangle */   } /* if member selected */}#pragma databank 0#pragma toolparms 0/***************************************************************** DoActivate - Toggle dictionary state between on and off.****************************************************************/void DoActivate (void){int flag;                               /* activate dictionary? */char *msg;                              /* message address */dActiveFlag = dActiveFlag ^ 0xFFFF;     /* toggle dict active flag with EOR op */if (dActiveFlag) {   flag = 1;                            /* activate dictionary */   msg = (char *) &inactiveMsg;         /* menu item = 'Dictionary off' */   }else {   flag = 0;                            /* deactivate dictionary */   msg = (char *) &activeMsg;           /* menu item = 'Dictionary on' */   }SetMItemName(msg, activeID);DictActivate(flag);}/***************************************************************** DoDict - Bring up dictionary editor.  How the Dictionary...*          command functions is based on the dictionary window's*          position on the desktop.  If the window is front-most,*          the command closes the window; if the window is up, but*          not the front one, the command brings it to front; if*          the window is not up, the command creates it.****************************************************************/void DoDict (void){long tmp;                               /* for tracking control ID */int i;                                  /* loop variable */CtlRecHndl *theCtls;                    /* pointer to dict wind's controls */windInfoRec wInfo;                      /* info about the front window */RefConRec wRefCon;                      /* window's type and number *//* First determine whether the dictionary window is up or not. */if (userWind[dictWindNum].upFlg) {      /* if it is... */   if (MyWindow(&wInfo))      if (wInfo.currWindNum == dictWindNum) /* ...if front wind = dict */         DoClose();                     /*      just close the window */      else {                            /*    else front wind = dict */         SelectWindow(userWind[dictWindNum].windPtr);         wInfo.currWindow = userWind[dictWindNum].windPtr;         wInfo.currWindNum = dictWindNum;         wInfo.currWindTyp = dictTyp;         }   } /* if dict window up *//* Window creation routine. */else {   wRefCon.a.wNum = dictWindNum;   wRefCon.a.wTyp = dictTyp;   userWind[dictWindNum].windPtr = NewWindow2(NULL, wRefCon.l, NULL, NULL,                                 refIsRsrc, (unsigned long) dictWindID, 0x800E);   if (toolerror()) {      HandleError(toolerror(), windErr);      return;      }   wInfo.currWindow = userWind[dictWindNum].windPtr;   /* Add controls to dictionary window.    */   /* Filename and list are from templates. */   userWind[dictWindNum].wCtl.dCtls->fnCtlHndl =      NewControl2(wInfo.currWindow, refIsPtr, (Ref) &fnTempl);   if (toolerror())      HandleError(toolerror(), ctlErr);   userWind[dictWindNum].wCtl.dCtls->listCtlHndl =      NewControl2(wInfo.currWindow, refIsPtr, (Ref) &listTempl);   if (toolerror())      HandleError(toolerror(), ctlErr);   /* The other controls are in the resource fork. */   tmp = dictCtlID;                     /* starting ID for controls */   theCtls = (void *) (((unsigned long) (userWind[dictWindNum].wCtl.dCtls))             + 8);   for (i = 0; i <= maxDCtls; ++i) {      *theCtls = NewControl2(wInfo.currWindow, refIsRsrc, (Ref) tmp);      if (toolerror())         HandleError(toolerror(), ctlErr);      ++tmp;      ++theCtls;      }   /* Finish setting window variables. */   wInfo.currWindNum = dictWindNum;   wInfo.currWindTyp = dictTyp;   userWind[dictWindNum].upFlg = TRUE;   ++numWindows;   } /* window creation */}/***************************************************************** GrowList - Attempt to expand dictionary's list member array by*            128 members.** Returns - true if list was grown** Global output:*       actListSize                  - updated to reflect new list size*       listTempl.ctlTemplate.refCon - new handle for member array*       listTempl.listRef            - new pointer to member array****************************************************************/boolean GrowList (void){int size;                               /* number elements in expanded list */long memSize;                           /* amt. memory needed for new list */listMemberPtr listPtr;                  /* pointer into list member array */handle hndl;                            /* temporaries */int i;/* Calculate total amount of memory needed for array = *//* number of members  *  sizeof(memberRecord). */size = listTempl.listSize + 128;        /* ensure not exceeding maxListSize */if (size > maxListSize) {   HandleError(0x1C01, listErr);   return FALSE;   }memSize = size * sizeof(listMember);HUnlock((Handle) listTempl.ctlTemplate.refCon); /* unlock handle for SetHandleSize */if (toolerror()) {   HandleError(toolerror(), memryErr);   return FALSE;   }                                        /* grow member array */SetHandleSize(memSize, (Handle) listTempl.ctlTemplate.refCon);if (toolerror()) {   HandleError(toolerror(), memryErr);   return FALSE;   }HLock((Handle) listTempl.ctlTemplate.refCon); /* lock down the array */hndl = (void *) listTempl.ctlTemplate.refCon;listTempl.listRef = (long) (*hndl);     /* reset pointer to array */actListSize = size;                     /* update size of array */                                        /* get pointer to new part */listPtr = (void *) (((unsigned long) listTempl.listRef)          + (listTempl.listSize * sizeof(listMember)));/* Initialize new part of member array. */for (i = listTempl.listSize; i < size; ++i) {   listPtr->visNum = -1;   listPtr->memNum = i;   listPtr->flag = 0;   listPtr->phonPtr = NULL;   ++listPtr;   }return TRUE;}/***************************************************************** DictAddWord - Handle adding entry to dictionary.****************************************************************/void DictAddWord (void){/* Get contents of English word edit box.  *//* Get contents of phonetic word edit box. */GetEnglishBox();GetPhonBox();/* make sure we have a complete entry to add */if ((englishText[0] != (char) 0) && (phoneticText[0] != (char) 0)) {   /* Ensure that the new word will fit in the current list. */   if (listTempl.listSize + 1 >= actListSize)      if (!GrowList())         return;   /* Dispose of the list control, since we'll be redrawing it. */   HideControl(userWind[dictWindNum].wCtl.dCtls->listCtlHndl);   DisposeControl(userWind[dictWindNum].wCtl.dCtls->listCtlHndl);   /* Add word to the dictionary; reset dictionary to top; */   /* adjust the list control.                             */   DictInsert(englishText, phoneticText);   DictInit(0);   nextEntry = 0;   ++listTempl.listSize;   AdjustList(englishText);   }}/***************************************************************** EmptyDict - Create "empty" dictionary.** Returns - true if able to create empty list****************************************************************/boolean EmptyDict (void){listMemberPtr listPtr;                  /* pointer into list member array */handle hndl;                            /* temporaries */int i;/* First remove all traces of the last dictionary, if there was one. */DictInit(1);                            /* clear the dict in memory */nextEntry = 0;dictChanged = FALSE;if (listTempl.ctlTemplate.refCon) {     /* deallocate members array */   DisposeHandle((void *) listTempl.ctlTemplate.refCon);   listTempl.ctlTemplate.refCon = 0;   }listTempl.listStart = 0;                /* no members in list now */listTempl.listSize = 0;listTempl.listRef = 0;if (userWind[dictWindNum].fileFlag) {   /* deallocate path handle */   if (userWind[dictWindNum].wPathHandle != NULL) {      DisposeHandle(userWind[dictWindNum].wPathHandle);      userWind[dictWindNum].wPathHandle = NULL;      }   userWind[dictWindNum].fileFlag = FALSE;   }for (i = 0; i <= 4; ++i)                /* make all visMems available */   visMems[i].memNum = -1;top = 0;                                /* reset display variables */bottom = 0;/* Create new member array of minimum size. */hndl = NewHandle(1024L, myID, 0xC010, NULL);if (toolerror()) {   HandleError(toolerror(), memryErr);   return FALSE;   }listTempl.ctlTemplate.refCon = (long) hndl;listTempl.listRef = (long) *hndl;listPtr = (void *) listTempl.listRef;actListSize = 128;for (i = 0; i < 128; i++, listPtr++) {  /* init. members array */   listPtr->visNum = -1;   listPtr->memNum = i;   listPtr->flag = 0;   listPtr->phonPtr = NULL;   }/* If dict window is up, recreate list control. */if (userWind[dictWindNum].upFlg) {   HideControl(userWind[dictWindNum].wCtl.dCtls->listCtlHndl);   DisposeControl(userWind[dictWindNum].wCtl.dCtls->listCtlHndl);   userWind[dictWindNum].wCtl.dCtls->listCtlHndl =      NewControl2(userWind[dictWindNum].windPtr, refIsPtr, (Ref) &listTempl);   if (toolerror()) {      HandleError(toolerror(), ctlErr);      DoClose();      return FALSE;      }   }return TRUE;}/***************************************************************** SetDefaultDName - Set dictionary's filename to reflect*                   dictionary loaded from default dictionary*                   (*:System:SpeechDict).****************************************************************/void SetDefaultDName (void){/* Set values in filename's control template and dictionary filename string. */strcpy(fileDName.name, "SpeechDict");fileDName.size = strlen(fileDName.name);fnTempl.textRef = (long) &fileDName.name;fnTempl.textSize = fileDName.size;/* If dictionary window is up, recreate filename control. */if (userWind[dictWindNum].upFlg) {   HideControl(userWind[dictWindNum].wCtl.dCtls->fnCtlHndl);   DisposeControl(userWind[dictWindNum].wCtl.dCtls->fnCtlHndl);   userWind[dictWindNum].wCtl.dCtls->fnCtlHndl =      NewControl2(userWind[dictWindNum].windPtr, refIsPtr, (Ref) &fnTempl);   if (toolerror())      HandleError(toolerror(), ctlErr);   }}/***************************************************************** SetDictName - Build filename when open dictionary file.****************************************************************/void SetDictName (SFReplyRec2 theReply){gsosInString19 *tmp;                    /* temporaries */handle theHandle;/* Convert handle to GS/OS output string for filename, returned by SFO in *//* reply record, to pointer to text. */theHandle = (void *) theReply.nameRef;tmp = (void *) (((unsigned long) (*theHandle)) + 2);fileDName.size = tmp->size;if (fileDName.size > 15)   fileDName.size = 15;/* Set values in filename's control template. */memcpy(fileDName.name, tmp->name, fileDName.size);fnTempl.textRef = (long) &fileDName.name;fnTempl.textSize = fileDName.size;/* If dictionary window is up, recreate filename control. */if (userWind[dictWindNum].upFlg) {   HideControl(userWind[dictWindNum].wCtl.dCtls->fnCtlHndl);   DisposeControl(userWind[dictWindNum].wCtl.dCtls->fnCtlHndl);   userWind[dictWindNum].wCtl.dCtls->fnCtlHndl =      NewControl2(userWind[dictWindNum].windPtr, refIsPtr, (Ref) &fnTempl);   if (toolerror())      HandleError(toolerror(), ctlErr);   }}/***************************************************************** SetNoFileDName - Set dictionary's filename to < no file >.****************************************************************/void SetNoFileDName (void){/* Set dictionary's filename to < no file >. */fnTempl.textRef = (long) &noFileDName.name;fnTempl.textSize = noFileDName.size;/* If dict window is up, recreate filename control. */if (userWind[dictWindNum].upFlg) {   HideControl(userWind[dictWindNum].wCtl.dCtls->fnCtlHndl);   DisposeControl(userWind[dictWindNum].wCtl.dCtls->fnCtlHndl);   userWind[dictWindNum].wCtl.dCtls->fnCtlHndl =      NewControl2(userWind[dictWindNum].windPtr, refIsPtr, (Ref) &fnTempl);   if (toolerror())      HandleError(toolerror(), ctlErr);   }}/***************************************************************** DictClear - Clear current dictionary from memory.****************************************************************/void DictClear (void){/* If the current dictionary has changed, ask user if want to save it *//* before removing it from memory.                                    */if (dictChanged)   if (WantToSaveDict())                /* give chance to cancel */      return;if (EmptyDict())   SetNoFileDName();}/***************************************************************** DictConvertWord - Convert English word to its phonetic representation.****************************************************************/void DictConvertWord (void){pString phString;                       /* phonetic string returned from Parse */int i;                                  /* loop index *//* Get contents of English word edit-line box. */GetEnglishBox();if (englishText[0] != (char) 0) {   /* Convert the string to phonetics. */   i = Parse(englishText, phString, 1);   /* Set phonetics edit box to returned phonetic string. */   phoneticSize = (int) phString[0];   memcpy(phoneticText, &phString[1], (int) phString[0]);   /* Recreate phonetics edit box control. */   HideControl(userWind[dictWindNum].wCtl.dCtls->phonCtlHndl);   LESetText(phoneticText, phoneticSize,      (LERecHndl) (*userWind[dictWindNum].wCtl.dCtls->phonCtlHndl)->ctlData);   if (toolerror())      HandleError(toolerror(), ctlErr);   else      ShowControl(userWind[dictWindNum].wCtl.dCtls->phonCtlHndl);   }}/***************************************************************** DictDeleteWord - Delete entry from dictionary.****************************************************************/void DictDeleteWord (void){/* Dispose of the list control, since we'll be redrawing it. */HideControl(userWind[dictWindNum].wCtl.dCtls->listCtlHndl);DisposeControl(userWind[dictWindNum].wCtl.dCtls->listCtlHndl);/* Get contents of English word edit box */GetEnglishBox();if (englishText[0] != (char) 0) {   /* Delete word from the dictionary; reset      */   /* dictionary to top; adjust the list control. */   DictDelete(englishText);   DictInit(0);   nextEntry = 0;   AdjustList(englishText);   }}/***************************************************************** DictSpeakWord - Speak phonetic dictionary entry.****************************************************************/void DictSpeakWord (void){/* Get contents of phonetic edit-line box. */GetPhonBox();/* SPEAK the string. Call appropriate function based on current voice setting */if (phoneticText[0] != (char) 0)   if (maleParm.itemValue == 1)      MaleSpeak(volume[1]-'0', speed[1]-'0', pitch[1]-'0', phoneticText);   else      FemaleSpeak(volume[1]-'0', speed[1]-'0', pitch[1]-'0', phoneticText);}/***************************************************************** LoadDict - Load new dictionary from disk.** Parameters:*       buffPtr  - pointer to buffer into which file has been read*       fileSize - size of buffer** Returns - true if able to load new dictionary****************************************************************/boolean LoadDict (pString32Ptr buffPtr, long fileSize){handle hndl;                            /* handle to memory for new member array */pString32Ptr word2Ptr;                  /* pointer to phonetic dict entry */listMemberPtr listPtr;                  /* pointer into member array */long memSize;                           /* amount memory needed for new array */int length1, length2;                   /* length of dict entries */long tmp;                               /* temporaries */int i;/* Check need to deallocate old dictionary. */if (listTempl.ctlTemplate.refCon != 0) {   DisposeHandle((void *) listTempl.ctlTemplate.refCon);   listTempl.listRef = 0;   listTempl.ctlTemplate.refCon = 0;   }listTempl.listSize = 0;                 /* initialize list to empty */listTempl.listStart = 0;DictInit(1);                            /* clear curr dict from memory *//* Process the file:  count # dict. entries, create dict. from file. */tmp = 0;while ((tmp < fileSize) && (listTempl.listSize < maxListSize)) {   length1 = buffPtr[0];   word2Ptr = buffPtr + length1 + 1;   DictInsert(buffPtr, word2Ptr);   length2 = word2Ptr[0];   buffPtr = word2Ptr + length2 + 1;   ++listTempl.listSize;   tmp += length1 + length2 + 2;   }/* Build list for dictionary window:  allocate memory for members array, *//*                                    then initialize array.             */tmp = listTempl.listSize + 128;         /* leave rm for inserts */if (tmp > maxListSize)   tmp = maxListSize;actListSize = tmp;memSize = tmp * sizeof(listMember);if (memSize > MaxBlock()) {             /* ensure enough memory */   HandleError(0x0201, OOMErr);         /*   for member array */   return FALSE;   }                                        /* allocate the memory */hndl = NewHandle((long) memSize, myID, 0xC010, NULL);if (toolerror()) {   HandleError(toolerror(), memryErr);   return FALSE;   }listTempl.ctlTemplate.refCon = (long) hndl;listTempl.listStart = 1;listTempl.listRef = (long) *hndl;listPtr = (void *) listTempl.listRef;for (i = 0; i < actListSize; i++, listPtr++) { /* init. members array */   listPtr->phonPtr = NULL;   listPtr->flag = 0;   listPtr->visNum = -1;   listPtr->memNum = i;   }top = 0;                                /* init list display */bottom = 4;if (bottom > listTempl.listSize)   bottom = listTempl.listSize - 1;DictInit(0);                            /* set dict to top */nextEntry = 0;for (i = 0; i < 5; ++i)                 /* make all visMembers available */   visMems[i].memNum = -1;MakeVisible(top, bottom);userWind[dictWindNum].fileFlag = TRUE;return TRUE;}/***************************************************************** Return_1 - Helper routine for OpenDict, disposing of SFO handles.** Parameters:*    theReply - reply record returned by SFGetFile2 call****************************************************************/void Return_1 (SFReplyRec2 theReply){DisposeHandle((handle) theReply.nameRef);DisposeHandle((handle) theReply.pathRef);}/***************************************************************** Return_2 - Helper routine for OpenDict, disposing of SFO handles*           and read buffer.** Parameters:*    theReply - reply record returned by SFGetFile2 call*    hndl     - read buffer's handle****************************************************************/void Return_2 (SFReplyRec2 theReply, handle hndl){DisposeHandle((handle) theReply.nameRef);DisposeHandle((handle) theReply.pathRef);DisposeHandle(hndl);}/***************************************************************** OpenDict - Load a new dictionary file.** Parameters:*    theReply - reply record returned by SFGetFile2 call****************************************************************/void OpenDict (SFReplyRec2 theReply){int error;                              /* error code returned by system */handle  hndl;                           /* temporaries */boolean bTmp;/* Before opening a new dictionary, check if *//* the current dictionary has changed. */if (dictChanged)   if (WantToSaveDict) {      Return_1(theReply);      return;      }/* If the current dictionary is associated with a file, *//* release the memory it uses. */if (userWind[dictWindNum].fileFlag)   if (userWind[dictWindNum].wPathHandle != NULL) {      DisposeHandle(userWind[dictWindNum].wPathHandle);      userWind[dictWindNum].wPathHandle = NULL;      userWind[dictWindNum].wPathName = NULL;      }/* We allow a dictionary file to be opened even if the dictionary editor  *//* isn't currently up.  However, we need to ensure it's the front window. */if (userWind[dictWindNum].upFlg)   SelectWindow(userWind[dictWindNum].windPtr);/* Open the file, read it into a buffer, and close the file. *//* Convert handle to GS/OS output string to pointer to GS/OS input string. */hndl = (handle) theReply.pathRef;openRec.pathname = (void *) (((unsigned long) (*hndl)) + 2);OpenGS(&openRec);if (toolerror()) {   HandleError(toolerror(), openErr);   Return_1(theReply);   return;   }readRec.refNum = openRec.refNum;closeRec.refNum = openRec.refNum;/* If the file is empty, close the file and skip loading it. *//* Initialize the dictionary to empty. */if (openRec.eof == 0) {   CloseGS(&closeRec);   if (! EmptyDict()) {      Return_1(theReply);      return;      }   SetDictName(theReply);   } /* if file is empty */else {   hndl = NewHandle((long) openRec.eof, myID, 0xC010, NULL);   if (toolerror()) {      HandleError(toolerror(), memryErr);      Return_1(theReply);      return;      }   readRec.requestCount = openRec.eof;   readRec.dataBuffer = *hndl;   ReadGS(&readRec);   error = toolerror();   CloseGS(&closeRec);   if (error) {      HandleError(error, readErr);      Return_2(theReply, hndl);      return;      }   if (! LoadDict(readRec.dataBuffer, readRec.transferCount)) {      Return_2(theReply, hndl);      return;      }   SetDictName(theReply);   DisposeHandle(hndl);   } /* if file not empty *//* If the dictionary editor is up, we need to recreate the *//* list, English edit-line, and phonetics edit-line controls. */if (userWind[dictWindNum].upFlg) {   HideControl(userWind[dictWindNum].wCtl.dCtls->listCtlHndl);   DisposeControl(userWind[dictWindNum].wCtl.dCtls->listCtlHndl);   userWind[dictWindNum].wCtl.dCtls->listCtlHndl =      NewControl2(userWind[dictWindNum].windPtr, refIsPtr, (Ref) &listTempl);   if (toolerror()) {      HandleError(toolerror(), ctlErr);      bTmp = DoClose();      return;      }   HideControl(userWind[dictWindNum].wCtl.dCtls->englCtlHndl);   englishSize = 0;   englishText[0] = (char) 0;   LESetText(NULL, englishSize,      (LERecHndl) (*userWind[dictWindNum].wCtl.dCtls->englCtlHndl)->ctlData);   if (toolerror()) {      HandleError(toolerror(), ctlErr);      bTmp = DoClose();      return;      }   ShowControl(userWind[dictWindNum].wCtl.dCtls->englCtlHndl);   HideControl(userWind[dictWindNum].wCtl.dCtls->phonCtlHndl);   phoneticSize = 0;   phoneticText[0] = (char) 0;   LESetText(NULL, phoneticSize,      (LERecHndl) (*userWind[dictWindNum].wCtl.dCtls->englCtlHndl)->ctlData);   if (toolerror()) {      HandleError(toolerror(), ctlErr);      bTmp = DoClose();      return;      }   ShowControl(userWind[dictWindNum].wCtl.dCtls->phonCtlHndl);   } /* if dict window is up *//* Perform final clean-up. */userWind[dictWindNum].fileFlag = TRUE;userWind[dictWindNum].wPathName = (void *) (openRec.pathname);userWind[dictWindNum].wPathHandle = (handle) theReply.pathRef;DisposeHandle((Handle) theReply.nameRef);dictChanged = false;}/***************************************************************** InitDictCmds - Initialize the DictCmds module.** Returns - true if able to initialize module****************************************************************/boolean InitDictCmds (void){int answer;                             /* response to TLMountBootVolume dlg */handle hndl;                            /* read buffer's handle, default dict */int error;                              /* error code returned by GS/OS */boolean bTmp;                           /* temporaries */int i;/* Initialize variables we can't initialize during definition. */userWind[dictWindNum].wCtl.dCtls = &dictCtls;listTempl.listDraw = (ProcPtr) &ListDrawRtn;/* Initialize the dictionary. First see if there's a dictionary file to load. */SetNoFileDName();                       /* assume no dictionary file */                                        /* attempt to open *:System:SpeechDict */openRec.pathname = (void *) &defaultDName;OpenGS(&openRec);error = toolerror();if ((error == diskSwitchedErr) || (error == volNotFoundErr)) {   /* Use TLMountVolume call to prompt for boot disk. */   answer = TLMountVolume(20, 20,       /* put dialog box at (20, 20) */                          mountPrompt,  /* pointer to 1st message line */                          NULL,         /* no 2nd message line in dialog */                          okTitle,      /* pointer to OK button's text */                          cancelTitle); /* pointer to Cancel button's text */   if (answer == 1) {                   /* try again to open file */      OpenGS(&openRec);      error = toolerror();      if ((error == diskSwitchedErr) || (error == volNotFoundErr) ||         (error == fileNotFoundErr))         if (EmptyDict())            return TRUE;         else            return FALSE;      else if (error) {         HandleError(error, openErr);         return FALSE;         }      } /* attempt to reopen file */   else {      if (EmptyDict())         return TRUE;      else         return FALSE;      } /* user won't mount boot disk */   } /* volNotFound, diskSwitched error detected */else if (error == fileNotFoundErr) {   if (EmptyDict())      return TRUE;   else      return FALSE;   }else if (error) {   HandleError(error, openErr);   return FALSE;   }else if (openRec.eof == 0) {   SetDefaultDName();   if (EmptyDict())      return TRUE;   else      return FALSE;   }/* If *:System:SpeechDict exists, read the file, close the file, *//* then load the dictionary. */closeRec.refNum = openRec.refNum;hndl = NewHandle((long) openRec.eof, myID, 0xC010, NULL);if (toolerror()) {   HandleError(toolerror(), memryErr);   CloseGS(&closeRec);   return FALSE;   }readRec.refNum = openRec.refNum;readRec.requestCount = openRec.eof;readRec.dataBuffer = *hndl;ReadGS(&readRec);error = toolerror();CloseGS(&closeRec);if (error) {   HandleError(error, readErr);   DisposeHandle(hndl);   return FALSE;   }bTmp = LoadDict(readRec.dataBuffer, readRec.transferCount);if (!bTmp) {   DisposeHandle(hndl);   return FALSE;   }SetDefaultDName();                      /* set dict window's name */userWind[dictWindNum].fileFlag = TRUE;userWind[dictWindNum].wPathName = openRec.pathname;userWind[dictWindNum].wPathHandle = NULL;DisposeHandle(hndl);return TRUE;}