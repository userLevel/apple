/***************************************************************** SpeechCmds - Commands to speak text and phonetics.** Written by Barbara Allred and Mike Westerfield** Copyright 1991, Byte Works, Inc.* Copyright 1987-1991, First Byte, Inc.****************************************************************/#pragma keep "SpeechCmds"#pragma noroot#pragma optimize 9#include "globals.h"#include "error.h"#include "msccmds.h"#include "filecmds.h"#include "dictcmds.h"ToolTable toolTbl = {                   /* Table of Speech Tools */   4,                                   /*  start 4 tools */   50, 0,                               /*  Male Speech tool set */   51, 0,                               /*  Female Speech tool set */   52, 0,                               /*  Parser tool set */   53, 0                                /*  GS/OS interface tool set */  };long   phBuffSize = 0L;                 /* size of phonetics buffer */handle phBuffer = 0L;                   /* handle to phonetics buffer *//***************************************************************** InitSpeechCmds - Initialize SpeechCmds module.** Returns - true if able to start speech tools****************************************************************/boolean InitSpeechCmds (void){handle hndl;                            /* handle to phonetics buffer */LoadTools((Pointer) &toolTbl);          /* start speech tools */if (toolerror()) {    HandleError(toolerror(), toolErr);   return FALSE;   }FemaleStartUp();                        /* start female speech tool */MaleStartUp();                          /* start male speech tool */ParseStartUp(myID);                     /* start parser */SpeechStartUp();                        /* start os interface tool *//* Allocate buffer to hold phonetics text. */phBuffer = NewHandle(1024L, myID, 0x8010, NULL);if (toolerror()) {   HandleError(toolerror(), memryErr);   return FALSE;   }phBuffSize = 1024;}/***************************************************************** GetPhonetics - Call Text Edit's TEGetText routine to dump text*                into the phonetics buffer.** Parameters:*      size - size of text*      wNum - window's number** Returns - true if text can be returned** Global output:*       phBuffer   - handle to text*       phBuffSize - size of buffer****************************************************************/boolean GetPhonetics (long *size, int wNum){*size = 0;/* First call Text Edit's TEGetTextInfo to find the size of window's text. */TEGetTextInfo((Pointer) &textInfo, 2, (Handle) userWind[wNum].wCtl.teHndl);if (toolerror()) {                                        HandleError(toolerror(), TEErr);   return FALSE;   }*size = textInfo.charCount + 1;         /* need 1 more byte for 1st length byte *//* Attempt to get memory block for text from Memory Manager. */HUnlock(phBuffer);/* If current handle isn't valid, allocate a new memory block. */if (toolerror()) {   phBuffer = NewHandle((long) *size, myID, 0x8010, NULL);   if (toolerror()) {      HandleError(toolerror(), memryErr);      return FALSE;      }   }/* Otherwise, attempt to grow the current handle. */else {   SetHandleSize(*size, phBuffer);   if (toolerror()) {      HandleError(toolerror(), memryErr);      return FALSE;      }   }HLock(phBuffer);phBuffSize = *size;/* Call Text Edit's TEGetText to dump text into buffer. */*size = TEGetText(0x0005, (Ref) (((unsigned long) *phBuffer) + 1),           *size, refIsPtr, (Ref) NULL, (Handle) userWind[wNum].wCtl.teHndl);if (toolerror()) {                                                            HandleError(toolerror(), TEErr);   return FALSE;   }return TRUE;}/***************************************************************** SpeakPhonetics - Speak selected phonetics.** Parameters:*      wNum - window's number****************************************************************/void SpeakPhonetics (int wNum){long size;                              /* amount of text in phon buffer */char *tPtr, *cPtr;                      /* pointers into phonetics buffer */char saveChar;                          /* char overwritten in phon buffer */boolean stop;                           /* true if all text has been spoken */long selStart;                          /* chr position, start of selection */long selEnd;                            /* chr position, end of selection */long selLength;                         /* length of selection */if (!GetPhonetics(&size, wNum))         /* dump text into our buffer */   goto End;                            /* just return if unable to get text *//* Call Text Edit's GetSelection to get *//* starting/ending offsets for current selection. */TEGetSelection((Pointer) &selStart, (Pointer) &selEnd,   (Handle) userWind[wNum].wCtl.teHndl);if (toolerror()) {   HandleError(toolerror(), TEErr);   goto End;   }/* If there is no current selection, we assume user wants to SPEAK the entire *//* window.  In this case, we set start of selection to 0, end of selection to *//* end of text. */if (selStart == selEnd) {   selStart = 0;   selEnd = size - 1;   }/* Get the pointer to the text from the buffer handle, *//* adjusting pointer to the start of the selection. */++selStart;                             /* 1st byte is for length */cPtr = (void *) (((unsigned long) (*phBuffer)) + selStart - 1);stop = FALSE;/* Now we're ready to enter our SPEAK loop.  As long as the text to be spoken *//* exceeds 255 characters (SPEAK accepts a Pascal-style string), we need to   *//* "doctor" the string to speak.                                              */do {   selLength = selEnd - selStart + 1;   /* get length of text to speak */   if (selLength <= 0)                  /* if string length == 0, we're done */      stop = TRUE;   else {      if (selLength > 255)              /* length can't exceed 255 chars */         selLength = 255;      /* Ensure string doesn't end in middle of 2-character phoneme. */      tPtr = (void *) (((unsigned long) cPtr) + selLength);      if ((*tPtr >= 'A') && (*tPtr <= 'Z')) {         --tPtr;         if ((*tPtr < 'A') || (*tPtr > 'Z'))            --selLength;         }      /* Save character we'll be overwriting in the buffer with length byte. */      saveChar = *cPtr;      *cPtr = (char) selLength;       /* SPEAK the string.  Call appropriate function */      /* based on current voice setting. */      if (maleParm.itemValue == 1)         MaleSpeak(volume[1]-'0', speed[1]-'0', pitch[1]-'0', cPtr);      else         FemaleSpeak(volume[1]-'0', speed[1]-'0', pitch[1]-'0', cPtr);      *cPtr = saveChar;                 /* restore char we overwrote */       selStart += selLength;            /* update start of next string */                                        /*   to SPEAK                  */      cPtr += selLength;                /* update ptr into text */      }   }while (!stop);End:HUnlock(phBuffer);}/***************************************************************** SpeakText - Speak selected text.** Parameters:*      wNum - window's number****************************************************************/void SpeakText (int wNum){long size;                              /* amt. text in English text buffer */char *cPtr;                             /* pointer into buffer */boolean stop;                           /* true if all text has been spoken */pString sayString;                      /* string to SAY */long selStart;                          /* chr position, start of selection */long selEnd;                            /* chr position, end of selection */long selLength;                         /* length of selection */if (!GetText(&size, wNum))              /* dump text into our buffer */   goto End;                            /* just return if unable to get text *//* Call Text Edit's TEGetSelection to get starting/ending *//* offsets for current selection.                         */TEGetSelection((Pointer) &selStart, (Pointer)   &selEnd, (Handle) userWind[wNum].wCtl.teHndl);if (toolerror()) {   HandleError(toolerror(), TEErr);   goto End;   }/* If there is no current selection, we assume user wants to SAY the entire   *//* window.  In this case, we set start of selection to 0, end of selection to *//* end of text.                                                               */if (selStart == selEnd) {   selStart = 0;   selEnd = size;   }/* Get the pointer to the text from the buffer handle, *//* adjusting pointer to the start of the selection.    */--selEnd;                               /* end is always 1 more than it should be */cPtr = (void *) (((unsigned long) *buffer) + selStart);/* Now we're ready to enter our SAY loop.  As long as the text to be spoken *//* exceeds 255 characters (SAY accepts a Pascal-style string), we need to   *//* "doctor" the string to speak.                                            */stop = FALSE;do {   selLength = selEnd - selStart + 1;   /* get length of text to speak */   if (selLength <= 0)                  /* if length of string == 0, */      stop = TRUE;                      /*   we're done              */   else {      if (selLength > 255)              /* length can't exceed 255 chars */         selLength = 255;      sayString[0] = (char) selLength;  /* stuff length byte into     */                                        /*   start of string to speak */      /* Move text from buffer to string to SAY. */      memcpy(&sayString[1], cPtr, selLength);      Say(sayString);                   /* SAY the string */      selStart += selLength;            /* update start of next string */                                        /*   to SAY                    */      cPtr += selLength + 1;            /* update pointer into text */      }   }while (!stop);End:HUnlock(buffer);}/***************************************************************** Toggle - For radio buttons, set 1 family member "on" and*          the other "off".** Parameters:*       oldItem - item currently selected*       newItem - item being selected*       setParmsPtr - pointer to SetParameters dialog's grafPort****************************************************************/void Toggle (int oldItem, int newItem, GrafPortPtr setParmsPtr){SetDItemValue(1, setParmsPtr, newItem);if (toolerror()) {   HandleError(toolerror(), dlgErr);   return;   }SetDItemValue(0, setParmsPtr, oldItem);if (toolerror())   HandleError(toolerror(), dlgErr);}/***************************************************************** DoSetParameters - Set global speech parameters.****************************************************************/#define okItem       1                 /* dialog's item IDs */#define cancelItem   2 #define maleItem     3 #define femaleItem   4 #define trebleItem   6 #define bassItem     7 #define pitchItem    8 #define speedItem    9 #define volumeItem   10 void DoSetParameters (void){GrafPortPtr setParmsPtr;                /* SetParameters dialog's grafPort pointer */int savMale;                            /* original maleVoice value */int savFemale;                          /* original femaleVoice value */int savTreble;                          /* original treble value */int savBass;                            /* original bass value */minPString savPitch;                    /* original pitch value */minPString savSpeed;                    /* original speed value */minPString savVolume;                   /* original volume value */int item2;                              /* if radio button, other item to toggle */int itemHit;                            /* item selected in dialog */Gender theVoice;                        /* new global voice value */Tone theTone;                           /* new global tone value */boolean stop;                           /* true if ready to exit set parms dialog */minPString tmp;                         /* tmp text for dialog's edit-line boxes */int i;/* Create the Set Parameters dialog box. */setParmsPtr = GetNewModalDialog(&setParmsDlg);if (toolerror()) {   HandleError(toolerror(), windErr);   return;   }/* Save the original parameter values, in case user decides to cancel. */savMale = maleParm.itemValue;savFemale = femaleParm.itemValue;savTreble = trebleParm.itemValue;savBass = bassParm.itemValue;memcpy(savPitch, pitch, pitch[0]+1);memcpy(savSpeed, speed, speed[0]+1);memcpy(savVolume, volume, volume[0]+1);/* Call Dialog Manager to get item selected, then handle appropriately. */stop = FALSE;do {   itemHit = ModalDialog(NULL);   if (toolerror())      FatalErr(toolerror());   /* Based on item selected, handle appropriately. */   if (itemHit == okItem) {      /* If item == OK button, set global speech parameters. */      if (maleParm.itemValue == 1)         theVoice = Male;      else         theVoice = Female;      if (bassParm.itemValue == 1)         theTone = Bass;      else         theTone = Treble;      SetSayGlobals(theVoice, theTone, pitch[1]-'0', speed[1]-'0',                    volume[1]-'0');      stop = TRUE;      }   else if (itemHit == cancelItem) {      /* If Cancel button selected, we'll need to restore original values. */      maleParm.itemValue = savMale;      femaleParm.itemValue = savFemale;      bassParm.itemValue = savBass;      trebleParm.itemValue = savTreble;      memcpy(pitch, savPitch, savPitch[0]+1);      memcpy(speed, savSpeed, savSpeed[0]+1);      memcpy(volume, savVolume, savVolume[0]+1);      stop = TRUE;      }   else if (itemHit == maleItem) {      /* If item selected is a radio button, we'll need to set */      /* the selected button and then clear its family member. */      maleParm.itemValue = 1;      femaleParm.itemValue = 0;      item2 = femaleItem;      Toggle(item2, itemHit, setParmsPtr);      }   else if (itemHit == femaleItem) {      femaleParm.itemValue = 1;      maleParm.itemValue = 0;      item2 = maleItem;      Toggle(item2, itemHit, setParmsPtr);      }   else if (itemHit == trebleItem) {      trebleParm.itemValue = 1;      bassParm.itemValue = 0;      item2 = bassItem;      Toggle(item2, itemHit, setParmsPtr);      }   else if (itemHit == bassItem) {      bassParm.itemValue = 1;      trebleParm.itemValue = 0;      item2 = trebleItem;      Toggle(item2, itemHit, setParmsPtr);      }   else {      /* The last 3 items are edit-line boxes.  Error-check entered value. */      GetIText(setParmsPtr, itemHit, (Pointer) &tmp);      if (toolerror()) {         HandleError(toolerror(), dlgErr);         stop = TRUE;         }      else {         /* To handle errors in edit-line boxes, bring up an error alert, */         /* select the offensive text, then have user reenter the text.   */         if ((tmp[1] < '0') || (tmp[1] > '9')) {            i = CautionAlert(&pErrorAlert, NULL);            SelectIText(setParmsPtr, itemHit, 0, 1);            }         else if (itemHit == pitchItem)            memcpy(pitch, tmp, tmp[0]+1);         else if (itemHit == speedItem)            memcpy(speed, tmp, tmp[0]+1);         else if (itemHit == volumeItem)            memcpy(volume, tmp, tmp[0]+1);         }      }   }while (!stop);CloseDialog(setParmsPtr);}/***************************************************************** SetPhonWName - Create phonetic window's name.** Parameters:*      wNum - window's number****************************************************************/void SetPhonWName (int wNum){char tmp[14];/* Build window name from the string 'Phonetics' and the window's number. */memcpy(&tmp[1], " Phonetics   ", 13);tmp[12] = (char) (wNum+'0');tmp[0] = 13;memcpy(userWind[wNum].wName, tmp, 14);}/***************************************************************** DoShowPhonetics - Convert English text to phonetics.****************************************************************/void DoShowPhonetics (void){windInfoRec wInfo;                      /* information about the front window */pString phString;                       /* strings to send to PARSE function */pString sayString;long selStart;                          /* chr position, start of selection */long selEnd;                            /* chr position, end of selection */long selLength;                         /* length of selection */long size;                              /* amt. of text in text window */long tmp;                               /* amt. of phonetics text in buffer */char *tPtr;                             /* pointer into text buffer */char *pPtr;                             /* pointer into phonetics buffer */boolean stop;                           /* true when reach end of text buffer */int phStart;                            /* pos. in English text to begin PARSE*/long tmp2;                              /* temporaries */int i;/* Check abort conditions. */if (!MyWindow(&wInfo))                  /* ensure front window is ours */   return;if (wInfo.currWindTyp == phonTyp)       /* if the front window = phonetics */   return;                              /*   just return                   */if (wInfo.currWindTyp == dictTyp) {     /* if front window = dictionary    */   DictConvertWord();                   /*   call DictConvertWord and exit */   return;   }if (userWindows == 10)                  /* ensure we can open 1 more window */   return;                              /*   to hold phonetic translation   */if (!GetText(&size, wInfo.currWindNum)) /* dump English text into buffer  */   return;                              /*   return if unable to get text */HLock(phBuffer);                        /* ensure integrity of phon buffer */if (toolerror()) {                      /* if can't lock buffer, alloc new one */   phBuffer = NewHandle(1024L, myID, 0x8010, NULL);   if (toolerror()) {      HandleError(toolerror(), memryErr);      goto Exit;      }   phBuffSize = 1024;   }/* Call Text Edit's TEGetSelection to get starting/ending *//* offsets for current selection. */TEGetSelection((Pointer) &selStart, (Pointer) &selEnd,   (Handle) userWind[wInfo.currWindNum].wCtl.teHndl);if (toolerror()) {   HandleError(toolerror(), TEErr);   goto Exit;   }/* If there is no current selection, we assume user wants to convert the *//* entire text window to phonetics.  In this case, we set start of selection *//* to 0, end of selection to end of text. */if (selStart == selEnd) {   selStart = 0;   selEnd = size;   }/* Get the pointer to the text from the buffer handle, *//* adjusting pointer to the start of the selection. */--selEnd;                               /* end is always 1 more than it should be */tPtr = (void *) (((unsigned long) *buffer) + selStart);pPtr = (void *) ((unsigned long) *phBuffer);tmp = 0;                                /* tmp tracks size of phonetics *//* Now we're ready to enter our PARSE loop.  As long as the text to be *//* parsed exceeds 255 characters (PARSE accepts 2 Pascal-style strings), *//* we need to "doctor" the string to parse. */stop = FALSE;do {   selLength = selEnd - selStart + 1;   /* get length of text to parse */   if (selLength <= 0)                  /* if length of string = 0, */      stop = TRUE;                      /*   we're done */   else {      /* Ensure length of string doesn't exceed 255 characters. */      if (selLength > 255)         selLength = 255;      /* Move string to parse from buffer to sayString.  1st byte = length. */      sayString[0] = (char) selLength;      for (i = 1; i <= selLength; i++, tPtr++)         sayString[i] = *tPtr;      /* Parse the string. */      phStart = 0;                      /* start parsing at start of string */      while ((sayString[0]) != phStart) {         phString[0] = (char) 255;      /* set length of phonetics string */         ++phStart;         phStart = Parse(sayString, phString, phStart);         /* Move phonetics string to buffer.  First check if buffer is */         /* large enough; if not, attempt to allocate a bigger buffer. */         tmp2 = tmp;                    /* save curr size of phonetics */         tmp += phString[0];            /* update size of phon created */         if (tmp > phBuffSize) {        /* check buffer large enough */            HUnlock(phBuffer);          /* unlock block so MM can grow */            phBuffSize += 1024;         /* grow by 1K increments */            SetHandleSize(phBuffSize, phBuffer);            if (toolerror()) {               HandleError(toolerror(), memryErr);               goto Exit;               }            HLock(phBuffer);            pPtr = (void *) (((unsigned long) *phBuffer) + tmp2);            }         /* Move phonetic string to buffer. */         for (i = 1; i <= phString[0]; i++, pPtr++)            *pPtr = phString[i];         } /* while */      /* Update start of next string to parse. */      selStart += selLength;      } /* selLength > 0 */   }while (!stop);/* Now that all the text has been converted, we need to show it in *//* a phonetics window.  We'll need to create a new window, first. */if (!InitWindow(&wInfo))                /* init window data structures */   goto Exit;SetPhonWName(wInfo.currWindNum);        /* get name for new phonetics window */userWind[wInfo.currWindNum].wTyp = phonTyp;wInfo.currWindTyp = phonTyp;if (!CreateWindow(&wInfo))   goto Exit;/* Finally, we need to dump the phonetics buffer into the phonetics window. */TESetText (0x0005, (Ref) *phBuffer, tmp, refIsPtr, (Ref) NULL,           (Handle) userWind[wInfo.currWindNum].wCtl.teHndl);if (toolerror()) {                                    HandleError(toolerror(), TEErr);   CloseWindow(wInfo.currWindow);   goto Exit;   }/* Clean up:  disable Open and New commands, if necessary; set window's *//*            upFlg to true; set window's dirty bit.                    */FiniWindow(wInfo.currWindNum);userWind[wInfo.currWindNum].fileFlag = FALSE;(*userWind[wInfo.currWindNum].wCtl.teHndl)->ctlFlag =   (*userWind[wInfo.currWindNum].wCtl.teHndl)->ctlFlag | isDirty;Exit:HUnlock(phBuffer);HUnlock(buffer);}/***************************************************************** DoSpeak - Depending upon type of front-most window, speak text*           or phonetics.****************************************************************/void DoSpeak(void){windInfoRec wInfo;                      /* information about the front window*//* Don't do anything unless the front window is ours. */if (MyWindow(&wInfo))   if (wInfo.currWindTyp == textTyp)      SpeakText(wInfo.currWindNum);   else if (wInfo.currWindTyp == phonTyp)      SpeakPhonetics(wInfo.currWindNum);   else      DictSpeakWord();}