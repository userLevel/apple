/***************************************************************** FileCmds - Commands to create text windows and interface with*            the file I/O system.** Written by Barbara Allred and Mike Westerfield** Copyright 1991, Byte Works, Inc.* Copyright 1987-1991, First Byte, Inc.****************************************************************/#pragma keep "FileCmds"#pragma noroot#pragma optimize 9#define atItemListLength 8#include "Globals.h"#include "Error.h"#include "DictCmds.h"#include "MscCmds.h"#define dictFileType    0xF2            /* File types */#define phonFileType    0xF1#define ASCIIFileType   0x04                                        /* Std File Ops data structures */                                        /********************************/SFReplyRec2 theReply = {                /* returned by SFO */   0, 0, 0L, 3, NULL, 3, NULL   };char openMsg[] = {                      /* msg for SFO open dialog */   "\pSelect file to open:"   };SFTypeList2 openTypes = {   4,   0x8000, 0x00F2, 0L,                  /* dictionary file */   0x8000, 0x0004, 0L,                  /* ASCII text file */   0x8000, 0x00B0, 0L,                  /* ORCA/APW source file */   0x8000, 0x00F1, 0L                   /* phonetics text file */   };char saveMsg[] = {                      /* msg for SFO save dialog */   "\pEnter name of file to save:"   };                                        /* filenames for SFO save dialog */gsosInString15 saveTName = {            /* default name for text file */   7, "newFile"   };gsosInString15 saveDName = {            /* default name for dict file */   10, "SpeechDict"   };gsosInString15 saveDFName = {           /* curr. dict filename */   15, "               "   };                                        /* WantToSave dialog */                                        /*********************/char item00pointerSave[] =              /* actual message */   "\pSave changes before closing";ItemTemplate item00Save = {             /* save message */   100,   {7, 120, 17, 329},   0x800F, (void *) &item00pointerSave,   27, 1, NULL   };char saveFN[] = "\p                  "; /* actual filename */ItemTemplate item01Save = {             /* filename for save */   101,   {19, 130, 29, 230},   0x800F, (void *) &saveFN,    18, 1, NULL   };ItemTemplate item02Save = {             /* Yes button */   1,   {32, 32, 45, 94},   10, (void *) &yesTitle,   0, 0, NULL   };ItemTemplate item03Save = {             /* No button */   3,   {32, 134, 45, 208},   10, (void *) &noTitle,   0, 0, NULL   };ItemTemplate item04Save = {             /* Cancel button */   2,   {32, 239, 45, 325},   10, (void *) &cancelTitle,   0, 0, NULL   };AlertTemplate saveAlert = {             /* WantToSave alert box */   {49, 136, 101, 493},   2, 0x81, 0x81, 0x81, 0x81,   &item00Save,   &item01Save,   &item02Save,   &item03Save,   &item04Save,   NULL   };                                        /* WantToSaveDict dialog */                                        /*************************/char item00pointerdict[] =              /* actual prompt */   "\pWould you like to save the current dictionary?";ItemTemplate item00dict = {             /* prompt */   100,   {13, 131, 23, 463},   0x800F, (void *) &item00pointerdict,   46, 0, NULL   };ItemTemplate item01dict = {             /* Yes button */   1,   {42, 54, 55, 133},   10, (void *) &yesTitle,   0, 1, NULL   };ItemTemplate item02dict = {             /* No button */   3,   {42, 194, 55, 276},   10, (void *) &noTitle,   0, 0, NULL   };ItemTemplate item03dict = {             /* Cancel button */   2,   {42, 349, 55, 435},   10, (void *) &cancelTitle,   0, 0, NULL   };AlertTemplate saveDictAlert = {         /* Save dictionary alert */   {51, 40, 131, 530},   4, 0x81, 0x82, 0x83, 0x84,   &item00dict,   &item01dict,   &item02dict,   &item03dict,   NULL   };/*****************************************************************  CreateWindow - Create new window on the desktop.** Parameters:*       wInfo - number and type to assign to new window** Returns - true if window can be created****************************************************************/boolean CreateWindow (windInfoRec *wInfo){RefConRec wRefCon;                      /* window's number and type *//* Set the window's number and type, then create the window. */wRefCon.a.wNum = wInfo->currWindNum;wRefCon.a.wTyp = wInfo->currWindTyp;userWind[wInfo->currWindNum].wNum = wInfo->currWindNum;userWind[wInfo->currWindNum].wTyp = wInfo->currWindTyp;userWind[wInfo->currWindNum].windPtr =   NewWindow2((Pointer) &userWind[wInfo->currWindNum].wName, wRefCon.l, NULL,      NULL, refIsRsrc, (Ref) windowID, 0x800E);if (toolerror()) {                                   HandleError(toolerror(), windErr);   return FALSE;   }wInfo->currWindow = userWind[wInfo->currWindNum].windPtr;/* Create window's text edit control. */userWind[wInfo->currWindNum].wCtl.teHndl =   NewControl2(wInfo->currWindow, refIsRsrc, (Ref) textEditID);if (toolerror()) {   DoClose();   HandleError(toolerror(), windErr);   return FALSE;   }return TRUE;}/***************************************************************** FiniWindow - Disable New and Open commands if this is the 10th*              window opened.** Parameters:*       wNum - new window's number****************************************************************/void FiniWindow (int wNum){userWind[wNum].upFlg = TRUE;            /* set flag that window is up */++numWindows;                           /* one more open window */++userWindows;                          /* one more open user window */if (userWindows == 9) {   DisableMItem(newID);                 /* can't allow creation of new window */   DisableMItem(openID);                /*   or opening of text file */   }}/***************************************************************** GetText - Call Text Edit's TEGetText routine to dump text into*           our buffer.** Parameters:*       size - long: size of text in buffer*       wNum - window's number** Returns - true if text can be returned** Global output:*       buffer     - handle to text*       bufferSize - size of text****************************************************************/boolean GetText (long *size, int wNum){*size = 0;/* Call Text Edit's TEGetTextInfo to determine if the current buffer *//* is large enough to hold the text to write.                        */TEGetTextInfo((Pointer) &textInfo, 2, (Handle) userWind[wNum].wCtl.teHndl);if (toolerror()) {   HandleError(toolerror(), TEErr);   return FALSE;   }*size = textInfo.charCount;/* Attempt to get memory block for text from Memory Manager. */HUnlock(buffer);/* If current handle isn't valid, allocate a new memory block. */if (toolerror()) {   buffer = NewHandle((long) *size, myID, 0x8010, NULL);   if (toolerror()) {      HandleError(toolerror(), memryErr);      return FALSE;      }   }/* Otherwise, attempt to grow the current handle. */else {   SetHandleSize(*size, buffer);   if (toolerror()) {      HandleError(toolerror(), memryErr);      return FALSE;      }   }HLock(buffer);bufferSize = *size;/* Call Text Edit's GetText to dump text into buffer. */*size = TEGetText(0x000D, (Ref) buffer, *size, refIsPtr, (Ref) NULL,    (Handle) userWind[wNum].wCtl.teHndl);if (toolerror()) {                HandleError(toolerror(), TEErr);   return FALSE;   }return TRUE;}/***************************************************************** InitWindow - Perform window initialization, common to both*              DoOpen and DoNew.** Parameters:*      wInfo - sets currWindNum to 1st free slot in userWind array** Returns - true if there aren't 10 user windows up yet****************************************************************/boolean InitWindow (windInfoRec *wInfo){int i;                                  /* index into userWind array */i = 0;                                  /* track window # in array */while (userWind[i].upFlg) {             /* loop to find empty slot in array */   ++i;   if (i > 9)      return FALSE;   }userWind[i].wNum = i;                   /* record index into user window array */wInfo->currWindNum = i;return TRUE;}/***************************************************************** SetFileWName - Build filename when open a file.** Parameters:*      wNum - window's number****************************************************************/void SetFileWName (int wNum){int size;ResultBuf255Ptr namePtr;/* Extract the filename from the GS/OS output string returned by SFO. *//* We're restricting these names to 15 characters.                    */namePtr = *((ResultBuf255Ptr *) theReply.nameRef);size = namePtr->bufString.length;if (size > 15)   size = 15;userWind[wNum].wName[0] = size+2;userWind[wNum].wName[1] = ' ';memcpy(&userWind[wNum].wName[2], namePtr->bufString.text, size);userWind[wNum].wName[size+2] = ' ';}/***************************************************************** SetTextWName - Create text window's name.** Parameters:*      wNum - window's number****************************************************************/void SetTextWName (int wNum){/* Build window name from the string 'Text' and the window's number. */userWind[wNum].wName[0] = 8;memcpy(&userWind[wNum].wName[1], " Text   ", 8);userWind[wNum].wName[7] = wNum + '0';}/***************************************************************** FillBuffer:  fill the write buffer with dictionary entries.** Parameters:*       bPtr - pointer to buffer to fill*       size - # characters to write*       word1 - English word*       word2 - phonetic word** Returns - true if end of dictionary reached****************************************************************/boolean FillBuffer (char *bPtr, long *size, char word1[], char word2[]){boolean result;                         /* function return value */boolean theEnd;                         /* true if end of dict or end of buffer reached */int len1, len2;                         /* string sizes of next dictionary entry */long tSize;                             /* temporary size of text in buffer */result = FALSE;theEnd = FALSE;*size = 0;while (!theEnd) {   len1 = word1[0];   len2 = word2[0];   if (len1 == 0) {                     /* null English word if end of dictionary */      result = TRUE;      theEnd = TRUE;      }   else {                               /* if not at end, write entries to buffer */      tSize = *size + len1 + len2 + 2;      if (tSize < bufferSize) {         memcpy(bPtr, word1, len1+1);         memcpy(bPtr+len1+1, word2, len2+1);         DictDump(word1, word2);         *size = tSize;         bPtr += len1 + len2 + 2;         }      else         theEnd = TRUE;      }   }return result;}/***************************************************************** WriteDictFile - Write dictionary to disk.** Returns - true if successful in writing file to disk****************************************************************/boolean WriteDictFile (void){boolean result;                         /* true if able to perform write */ptr buffPtr;                            /* pointer to buffer to write to disk */pString32 word1, word2;                 /* dictionary entry */pString32Ptr tmp;                       /* return value from DictDump function */boolean stop;                           /* true if end of dict reached *//* Prepare to begin writing dictionary to disk:  reset dictionary to top, *//* then check the buffer we'll be writing into.                           */result = TRUE;                          /* not at end of dict yet */stop = FALSE;DictInit(0);                            /* reset dictionary to top */nextEntry = 0;HLock(buffer);if ((toolerror()) || (bufferSize < 1024)) {   buffer = NewHandle(1024L, myID, 0xC010, NULL);   if (toolerror()) {      HandleError(toolerror(), memryErr);      result = FALSE;      goto Exit;      }   bufferSize = 1024;   }/* Initialize variables prior to entering main loop. */writeRec.dataBuffer = (void *) *buffer;/* Main loop:  while not at end of dictionary, fill the buffer with dict *//*             entries, then write the buffer to disk.                   */while (!stop) {   tmp = DictDump(word1, word2);        /* get 1st dict entry */   writeRec.requestCount = 0;           /* fill write buffer */   buffPtr = (void *) *buffer;   stop = FillBuffer((void *) buffPtr, (void *) &writeRec.requestCount,      word1, word2);   WriteGS(&writeRec);                  /* write buffer to disk */   if (toolerror()) {      HandleError(toolerror(), writeErr);      result = FALSE;      goto Exit;      }   }/* Final clean-up:  Close the file, reset dictionary to top. */dictChanged = FALSE;Exit:CloseGS(&closeRec);DictInit(0);nextEntry = 0;HUnlock(buffer);return result;}/***************************************************************** WriteTextFile - Write text window to disk.** Parameters:*      wNum - window's number** Returns - true if able to write file to disk****************************************************************/boolean WriteTextFile (int wNum){boolean result;                         /* return value */CtlRecPtr tePtr;                        /* text window's text edit ctl hndl */result = TRUE;                          /* assume all is well to start *//* Check the dirty bit in the window's text edit control record, *//* to see if we really need to save the file. */tePtr = *(userWind[wNum].wCtl.teHndl);if ((tePtr->ctlFlag & isDirty) == 0)   goto Exit;/* Get the window's text. */if (!GetText((long *) &writeRec.requestCount, wNum)) {   result = FALSE;   goto Exit;   }/* Write the window to disk. */writeRec.dataBuffer = *buffer;WriteGS(&writeRec);if (toolerror()) {   HandleError(toolerror(), writeErr);   result = FALSE;   goto Exit;   }tePtr->ctlFlag = tePtr->ctlFlag & 0x00BF;  /* clear window's dirty bit */Exit:CloseGS(&closeRec);HUnlock(buffer);return result;}/***************************************************************** DoNew - Create new text window.****************************************************************/void DoNew (void){windInfoRec wInfo;                      /* information about the front window */if (InitWindow(&wInfo)) {               /* init window data structures */   SetTextWName(wInfo.currWindNum);     /* create window's title */   wInfo.currWindTyp = textTyp;         /* set window's type */   userWind[wInfo.currWindNum].wTyp = textTyp;   if (CreateWindow(&wInfo)) {          /* create new window on desktop */                                        /* window not assoc. with file */      userWind[wInfo.currWindNum].fileFlag = FALSE;      FiniWindow(wInfo.currWindNum);    /* disable Open, New commands, */      }                                 /*   if necessary              */   }}/***************************************************************** Return1 - Helper routine 1 for DoOpen, disposing of SFO handles.****************************************************************/void Return1(void){DisposeHandle((handle) theReply.nameRef);DisposeHandle((handle) theReply.pathRef);}/***************************************************************** Return2 - Helper routine 2 for DoOpen, disposing of SFO*           handles and read buffer.** Parameters:*       hndl - handle to dispose of****************************************************************/void Return2(handle hndl){DisposeHandle((handle) theReply.nameRef);DisposeHandle((handle) theReply.pathRef);DisposeHandle(hndl);}/***************************************************************** DoOpen - Open an ASCII file and display in new window on the*          desktop.** Parameters:*       dictOnly - true if can only open a dictionary file** Returns - true if able to open a file****************************************************************/void DoOpen (boolean dictOnly){int error;                              /* error # returned by tools */windInfoRec wInfo;                      /* information about front window */handle hndl;                            /* "generic" handle *//* Set types of files allowed to be opened, based on whether user is *//* restricted to opening a dictionary or can open ASCII file, tool.  */if (dictOnly)   openTypes.numEntries = 1;else   openTypes.numEntries = 4;/* Make SFGetFile2 call to bring up SFO Open dialog and get filename and *//* pathname of file to open. */SFGetFile2(20, 20, refIsPtr, (Ref) openMsg, NULL, &openTypes, &theReply);if (toolerror()) {   HandleError(toolerror(), SFOErr);   return;   }if (theReply.good == 0)                /* Does user want to open a file? */   return;/* If user has opened a dictionary file, call OpenDict to open it. */if (theReply.fileType == dictFileType) {   OpenDict(theReply);   return;   }if (InitWindow(&wInfo))   if (theReply.fileType == phonFileType) {      wInfo.currWindTyp = phonTyp;      userWind[wInfo.currWindNum].wTyp = phonTyp;      }   else {      wInfo.currWindTyp = textTyp;      userWind[wInfo.currWindNum].wTyp = textTyp;      }else {   Return1();   return;   }/* Open the file, read it into a buffer, and close the file. *//* Convert handle to GS/OS output string to pointer to GS/OS input string. */hndl = (handle) theReply.pathRef;openRec.pathname = (void *) (((unsigned long) (*hndl)) + 2);OpenGS(&openRec);if (toolerror()) {   HandleError(toolerror(), openErr);   Return1();   return;   }readRec.refNum = openRec.refNum;closeRec.refNum = openRec.refNum;/* If the file is empty, close the file and skip loading it. */if (openRec.eof == 0) {   CloseGS(&closeRec);   SetFileWName(wInfo.currWindNum);   if (!CreateWindow(&wInfo)) {      Return1();      return;      }   FiniWindow(wInfo.currWindNum);   }/* If the file is not empty, we need to read it into a buffer,        *//* create its window, and fill its text edit control from the buffer. */else {   hndl = NewHandle((long) openRec.eof, myID, 0xC010, NULL);   if (toolerror()) {      HandleError(toolerror(), memryErr);      Return1();      return;      }   readRec.requestCount = openRec.eof;   readRec.dataBuffer = *hndl;   ReadGS(&readRec);   error = toolerror();   CloseGS(&closeRec);   if (error) {      HandleError(error, readErr);      Return2(hndl);      return;      }   SetFileWName(wInfo.currWindNum);   if (!CreateWindow(&wInfo)) {      Return2(hndl);      return;      }   FiniWindow(wInfo.currWindNum);   TESetText(5, (Ref) *hndl, readRec.transferCount, refIsPtr, (Ref) NULL, NULL);   if (toolerror()) {      HandleError(toolerror(), TEErr);      Return2(hndl);      return;      }   DisposeHandle(hndl);   } /* file not empty *//* Perform final clean-up. */userWind[wInfo.currWindNum].upFlg = TRUE;userWind[wInfo.currWindNum].fileFlag = TRUE;userWind[wInfo.currWindNum].wPathName = openRec.pathname;userWind[wInfo.currWindNum].wPathHandle = (handle) theReply.pathRef;DisposeHandle((Handle) theReply.nameRef);}/***************************************************************** DoSaveAs - Handle Save as command.** Parameters:*       saveDict - true if saving current dictionary** Returns true if an error occurred; else false****************************************************************/boolean DoSaveAs (boolean saveDict){boolean result;                         /* result to return */gsosInString19 *tmp;                    /* temp name pointer */handle hndl;                            /* work buffer handle */windInfoRec wInfo;                      /* information about the front window */result = TRUE;                          /* assume can't save the file *//* We can save the dictionary without its window being open. */if (saveDict) {   wInfo.currWindTyp = dictTyp;   wInfo.currWindNum = dictWindNum;   }else if (!MyWindow(&wInfo))             /* ensure the front window is ours */   goto Exit;/* Make SFPutFile2 call to bring up SFO Save dialog and get filename and *//* pathname of file to create, open, and then write.  The default name   *//* to display in the dialog is based on whether the file is a dictionary *//* and if so, if a filename is currently associated with the dictionary. */if (wInfo.currWindTyp == dictTyp)   if (userWind[dictWindNum].fileFlag)      tmp = (void *) &saveDFName;   else      tmp = (void *) &saveDName;else   tmp = (void *) &saveTName;SFPutFile2(20, 20, refIsPtr, (Ref) saveMsg, refIsPtr, (Ref) tmp, &theReply);if (toolerror()) {   HandleError(toolerror(), SFOErr);   goto Exit;   }if (theReply.good == 0)                 /* Does user want to open a file? */   goto Exit;/* Fill in GS/OS parameter block fields. */hndl = (handle) theReply.pathRef;tmp = (void *) (((unsigned long) *hndl) + 2); /* skip buffer length word */getFileInfoRec.pathname = (void *) tmp;openRec.pathname = (void *) tmp;destroyRec.pathname = (void *) tmp;createRec.pathname = (void *) tmp;/* Make GetFileInfo call to see if file currently exists. *//* If so, delete the old file. */GetFileInfoGS(&getFileInfoRec);if (toolerror()) {   if (toolerror() != fileNotFoundErr) {      HandleError(toolerror(), fileErr);      goto Exit;      }   }else {   DestroyGS(&destroyRec);   if (toolerror()) {      HandleError(toolerror(), delErr);      goto Exit;      }   }/* Create new file.  Set its filetype based on front window's type. */if (wInfo.currWindTyp == phonTyp)   createRec.fileType = phonFileType;else if (wInfo.currWindTyp == dictTyp)   createRec.fileType = dictFileType;else   createRec.fileType = ASCIIFileType;CreateGS(&createRec);if (toolerror()) {   HandleError(toolerror(), createErr);   goto Exit;   }/* Open the file. */OpenGS(&openRec);if (toolerror()) {   HandleError(toolerror(), openErr);   goto Exit;   }writeRec.refNum = openRec.refNum;closeRec.refNum = openRec.refNum;/* Check if file currently associated with this window. *//* If so, release its path handle. */if (userWind[wInfo.currWindNum].fileFlag)   if (userWind[wInfo.currWindNum].wPathHandle != NULL) {      DisposeHandle(userWind[wInfo.currWindNum].wPathHandle);      userWind[wInfo.currWindNum].wPathHandle = NULL;      }/* Write the file to disk and update file's name in window display. */if (wInfo.currWindTyp == dictTyp) {   if (!WriteDictFile())      goto Exit;   SetDictName(theReply);   }else {   if (!WriteTextFile(wInfo.currWindNum))      goto Exit;   SetFileWName(wInfo.currWindNum);   SetWTitle(userWind[wInfo.currWindNum].wName, wInfo.currWindow);   }/* Set window information. */userWind[wInfo.currWindNum].fileFlag = TRUE;userWind[wInfo.currWindNum].wPathName = openRec.pathname;userWind[wInfo.currWindNum].wPathHandle = (void *) theReply.pathRef;result = FALSE;Exit:return result;}/***************************************************************** DoSave - Save a window or the dictionary to disk.** Parameters:*       saveDict - true if saving current dictionary****************************************************************/boolean DoSave (boolean saveDict){boolean result;                         /* result to return */windInfoRec wInfo;                      /* info about the front window */result = TRUE;                          /* assume can't save the file *//* We can save the dictionary without its window being open. */if (saveDict) {   wInfo.currWindTyp = dictTyp;   wInfo.currWindNum = dictWindNum;   }else if (!MyWindow(&wInfo))             /* ensure the front window is ours */   goto Exit;/* If the window has never been saved to disk, execute DoSaveAs. */if (!userWind[wInfo.currWindNum].fileFlag) {   result = DoSaveAs(saveDict);   goto Exit;   }/* Open the file and set its length to zero. */openRec.pathname = userWind[wInfo.currWindNum].wPathName;OpenGS(&openRec);if (toolerror()) {   HandleError(toolerror(), openErr);   goto Exit;   }setEOFRec.refNum = openRec.refNum;writeRec.refNum = openRec.refNum;closeRec.refNum = openRec.refNum;SetEOFGS(&setEOFRec);if (toolerror() != 0) {   HandleError(toolerror(), zeroErr);   CloseGS(&closeRec);   goto Exit;   }/* Call appropriate routine to write file to disk, based on file's type. */if (wInfo.currWindTyp == dictTyp) {   if (!WriteDictFile())      goto Exit;   }else {   if (!WriteTextFile(wInfo.currWindNum))      goto Exit;   }result = FALSE;Exit:return result;}/***************************************************************** DictSave - Save current dictionary to disk.****************************************************************/void DictSave (void){/* Get default filename to use in SFO dialog. *//* If dictionary associated with a file, use file's name. */if (userWind[dictWindNum].fileFlag) {   saveDFName.size = fileDName.size;   memcpy(saveDFName.name, fileDName.name, saveDFName.size);   }/* Bring up SFO dialog to get pathname of file to receive dictionary, *//* then initialize the file. */if (!DoSaveAs(TRUE))   dictChanged = FALSE;}/***************************************************************** WantToSave - Ask user if he wants to save a text window before*              closing it.** Parameters:*      wNum - window's number** Returns - true if Cancel selected****************************************************************/boolean WantToSave (int wNum){int answer;                             /* response to WantToSave dialog *//* Copy filename to save alert template. */saveFN[0] = userWind[wNum].wName[0] + 1;memcpy(&saveFN[1], &userWind[wNum].wName[1], saveFN[0]);saveFN[saveFN[0]+1] = '?';/* Bring up alert. */answer = NoteAlert(&saveAlert, NULL);if (answer == 1) {   if (DoSave(FALSE))                   /* give chance to cancel */      return TRUE;   }else if (answer == 2)   return TRUE;return FALSE;}/***************************************************************** WantToSaveDict - Ask user if they'd like to save current*       dictionary before disposing of it.** Returns - true if Cancel selected****************************************************************/boolean WantToSaveDict (void){int answer;                             /* response to WantToSaveDict dialog *//* Bring up alert. */answer = NoteAlert(&saveDictAlert, NULL);if (answer == 1) {   if (DoSave(TRUE))      return TRUE;   }else if (answer == 2)   return TRUE;return FALSE;}