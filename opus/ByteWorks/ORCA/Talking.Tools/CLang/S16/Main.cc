/***************************************************************** SpeakIt - A demo to show how the speech tools work.** Written by Barbara Allred, with a little help* from her friends.** Copyright 1991 by Byte Works, Inc.* Copyright 1987-1991 by First Byte, Inc.******************************************************************* Version 1.0.2** December 1995* Mike Westerfield**   1.	Updated the program to work with the latest C interfaces.*   2.	Fixed several bugs that caused the program to crash*	when you tried to manipulate new dictionary entries*	that did not have a phonetic translation.*   3.	Fixed the scrolling code for the dictionary list so it*	works.*   4.	Fixed the tab order for editline items in the speech*	parameters dialog.*   5.	Adjusted the editline items in the speech parameters*	dialog to give a little more editing room, so the values*	show up right away.****************************************************************/#pragma keep "main"#pragma optimize 9#include "globals.h"#include "error.h"#include "msccmds.h"#include "dictcmds.h"#include "filecmds.h"#include "speechcmds.h"long startStopRef;                      /* handle from StartUpTools call */EventRecord taskRec = {                 /* extended task record */   0, 0L, 0L, {0, 0}, 0, 0L, 0x001FBFFF, 0L, 0, 0L, 0L, 0L, 0L   };/***************************************************************** DoQuit - Handle Quit command.****************************************************************/void DoQuit (void){/* Check need to save dictionary. */if (dictChanged)   if (WantToSaveDict())                /* if cancel chosen, abort Quit command */      return;/* Close all open windows. */while (numWindows > 0)   if (DoClose())                       /* give chance to cancel */       return;done = TRUE;                            /* set the done flag */}/***************************************************************** HandleMenu - Handle menu selections, menu IDs 256 ->.****************************************************************/void HandleMenu (void){int theItem;int menuNum;theItem = taskRec.wmTaskData;           /* menu item, menu number are   */menuNum = taskRec.wmTaskData >> 16;     /*   passed in wmTaskData field *//* Dispatch appropriate routine, based on wmTaskData value, the menu item ID. */switch (theItem) {   case aboutID:    DoAbout();                    break;   case newID:      DoNew();                    break;   case openID:     DoOpen(FALSE);                    break;   case saveID:     DoSave(FALSE);                    break;   case saveAsID:   DoSaveAs(FALSE);                    break;   case pSetUpID:   DoPSetUp();                    break;   case printID:    DoPrint();                    break;   case quitID:     DoQuit();                    break;   case speakID:    DoSpeak();                    break;   case phonID:     DoShowPhonetics();                    break;   case setID:      DoSetParameters();                    break;   case dictID:     DoDict();                    break;   case activeID:   DoActivate();   }/* Unhighlight the menu the user pulled down. */HiliteMenu(FALSE, menuNum);}/***************************************************************** HandleSpecial - Handle special menu commands,*                 menu IDs 250 - 255.****************************************************************/void HandleSpecial (void){int theItem;int menuNum;theItem = taskRec.wmTaskData;           /* menu item, menu number are   */menuNum = taskRec.wmTaskData >> 16;     /*   passed in wmTaskData field *//* The only special menu item we need handle is Close. */if (theItem == closeID)   DoClose();HiliteMenu(FALSE, menuNum);}/***************************************************************** HandleUpdate - Handle update event for active window.****************************************************************/void HandleUpdate (void){BeginUpdate((GrafPortPtr) taskRec.wmTaskData);DrawControls((GrafPortPtr) taskRec.wmTaskData);EndUpdate((GrafPortPtr) taskRec.wmTaskData);}/***************************************************************** Init - Start the tools we need, then create our menu bar.** Returns - true if able to start program****************************************************************/boolean Init (void){/* First start tools we need. */myID = userid();                        /* get user ID passed to us */startStopRef = StartUpTools(myID, refIsRsrc, (long) startStopID);if (toolerror())   return FALSE;/* Initialize all of the program's modules. */if (! InitSpeechCmds())   return FALSE;if (! InitMscCmds())   return FALSE;if (! InitDictCmds())   return FALSE;/* Create the menu bar. */SetSysBar (NewMenuBar2(refIsRsrc, (long) menuBarID, NULL));SetMenuBar(NULL);FixAppleMenu(1);                        /* add desk accessories to Apple menu */FixMenuBar();                           /* compute std sizes, menu bar/menus */DrawMenuBar();/* Allocate buffer to hold windows' text. */buffer = NewHandle(1024L, myID, 0x8010, NULL);if (toolerror()) {   HandleError (toolerror(), memryErr);   return FALSE;   }bufferSize = 1024;/* StartUpTools brings up the watch cursor so change it to the arrow. */InitCursor();return TRUE;}/***************************************************************** EventLoop - Get next event, then dispatch the appropriate*             routine to handle it.****************************************************************/void EventLoop (void){int theEvent;int theCtl;done = FALSE;                           /* we ain't done yet */while (!done) {   theEvent = TaskMaster(0x076E, &taskRec);   if (toolerror())      FatalErr(toolerror());   /* Dispatch appropriate routine, based on event. */   if (theEvent == inUpdate)      HandleUpdate();   else if (theEvent == wInSpecial)      HandleSpecial();   else if (theEvent == wInGoAway)      DoClose();   else if (theEvent == wInMenuBar)      HandleMenu();   else if (theEvent == wInControl) {      theCtl = taskRec.wmTaskData4;      if (theCtl > 15)         switch (theCtl) {            case 16:  DictAddWord();                      break;            case 17:  DictDeleteWord();                      break;            case 18:  DictConvertWord();                      break;            case 19:  DictSpeakWord();                      break;            case 21:  DictSave();                      break;            case 22:  DoOpen(TRUE);                      break;            case 23:  DictClear();                      break;            case 24:  DoPrint();                      break;            case 25:  DoClose();            }      } /* if theEvent == wInControl */   } /* while ! done */}/***************************************************************** ShutDown - Unload the tools we started.****************************************************************/void ShutDown (void){FemaleShutDown();                       /* shut down speech tools */MaleShutDown();ParseShutDown();SpeechShutDown();ShutDownTools(refIsHndl, (long) startStopRef);    /* shut down all other */if (toolerror())                                  /*   tools we started  */   FatalErr (toolerror());}/***************************************************************** Main program****************************************************************/void main (void){if (Init())                             /* start tools, bring up menu bar */   EventLoop();                         /* execute main event loop */ShutDown();                             /* unload tools, clean up */}