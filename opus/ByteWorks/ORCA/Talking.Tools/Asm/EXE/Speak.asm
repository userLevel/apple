         keep  speak         mcopy speak.macros******************************************************************  Speak - A "plain vanilla" demonstration the Talking Tools*        Speech Toolkit.**  by Barbara Allred**  Copyright 1991 by Byte Works, Inc.*  Copyright 1987 - 1991 by First Byte, Inc.******************************************************************* Speak 1.0.2** December 1995* Mike Westerfield**   1.	Converted the program to use the modern macros and*	libraries.******************************************************************Speak    start         using Globals         phk                            ensure code, data in same bank         plb         sta   myID                     get userID passed by Loader	jsl	SystemEnvironmentInit	initialize the program	jsl	SysIOStartup         jsr   Init         bcs   Rtl         jsr   Main                     if no error, execute the programRtl      jsr   ShutDown	jsl	SysIOShutDown         lda   #0           rtl         end**************************************************  Globals - Speak's global data area.**************************************************Globals  data;; Constants;maleVoice      gequ    0                speech parameters that are enumerationsfemaleVoice    gequ    1bassTone       gequ    0trebleTone     gequ    1fileNotFoundErr gequ   $0046            GS/OS file-not-found error codehandle         gequ    0                "generic" handleptr            gequ    4                "generic" pointer;; Global variables;; ORCA/M strings:  2 length bytes before chars.;tmp            ds  4                    4-byte temporarycount          ds  2                    2-byte temporary               dc  i1'255'              will be using ORCA/M's getstring macrosayString      dc  i1'255'              English text to speak or parse               ds  255               dc  i1'255'              will be using ORCA/M's getstring macrophString       dc  i1'255'              phonetic string               ds  255               dc  i1'1'                will be using ORCA/M's gets functionanswer         dc  i1'1'                user's response to queries               ds  1               dc  i1'32'word1          dc  i1'32'               strings to use with dictionary               ds  32               dc  i1'32'word2          dc  i1'32'               ds  32;; Other general variables;myID           ds  2                    program's user IDerrNum         ds  2                    error number to report to userdone           dc  i2'0'                true if user wants to exit program;; Speech Toolkit variables;voice          dc  i2'maleVoice'        default voice = malebasePitch      dc  i2'bassTone'         default tone = bassspeed          dc  i2'5'                default speed = 5pitch          dc  i2'5'                default pitch = 5volume         dc  i2'5'                default volume = 5;;  Start/stop tools data structures;toolTable      anop                     tool table to pass to LoadTools functionttNumTools     dc  i2'4'                # tools to be loadedtsArray        anop                     toolset #, min. version required               dc  i2'50,0'               male voice               dc  i2'51,0'               female voice               dc  i2'52,0'               parser               dc  i2'53,0'               GS/OS interface;; Error Messages;msg0           dc  i1'13',c'Error = $'hexValue       ds  4toolErr        dw  'Unable to load Speech Tools             'openErr        dw  'Unable to open file                     'memErr         dw  'Unable to allocate memory for buffer    'readErr        dw  'Unable to read file                     'infoErr        dw  'Unable to obtain information about file 'createErr      dw  'Unable to create file                   'zeroErr        dw  'Unable to set file size to zero         'writeErr       dw  'Unable to write file                    ';;  Data structures for GS/OS file handling calls.;pathname       dc  i1'255'              ORCA string to read dict filename               dc  i1'255'               dc  255c' 'options        dc  i2'6'                6 bytes total in options area               ds  4;                                       GS/OS open recordopenRec        dc  i2'15'                 pcountopenRef        ds  2                      refNumopenPath       dc  a4'pathname'           pathname               dc  i2'$0003'              request read/write access               dc  i2'0'                  resource number:  open data forkopenAccess     ds  2                      accessopenFileType   ds  2                      filetypeopenAuxType    ds  4                      auxType               ds  2                      storage type               ds  8                      create date/time               ds  8                      mod date/time               dc  i4'options'            pointer to GS/OS result bufferopenSize       ds  4                      eof:  # bytes that can be read               ds  4                      blocks used               ds  4                      resource eof               ds  4                      resource blocks;;                                       GS/OS read recordreadRec        dc  i2'5'                  pcountreadRef        ds  2                      reference #readBuffer     ds  4                      pointer to buffer to read intoreadRequest    ds  4                      # bytes to readtransferCount  ds  4                      # bytes actually readcache          dc  i2'0'                  don't cache;;                                       GS/OS close recordcloseRec       dc  i2'1'                  pCountcloseRef       ds  2                      reference #;;                                       GS/OS write recordwriteRec       dc  i2'5'                  pCountwriteRef       ds  2                      file reference #writeData      ds  4                      pointer to data to writewriteRequest   ds  4                      # bytes to writewriteTransfer  ds  4                      # bytes actually written               dc  i2'0'                  don't cache file;;                                       GS/OS getFileInfo recordGFIRec         dc  i2'12'                 pCountGFIPath        dc  a4'pathname'           pointer to GS/OS input stringGFIInfo        ds  26                     not relevant for our purposes               dc  a4'options'            pointer to GS/OS output buffer               ds  24                     not interested in this stuff;;                                       GS/OS create recordcreateRec      dc  i2'7'                  pCountcreatePath     dc  a4'pathname'           pointer to GS/OS input string               dc  i2'$00C3'              destroy, rename, write, read accesscreateTyp      dc  i2'$00F2'              filetype = dictionary               dc  i4'0'                  auxtype               dc  i2'$0001'              standard file               dc  i4'0'                  initial size of data fork is 0               dc  i4'0'                  initial size of resource fork is 0;;                                       GS/OS EOF recordsetEOFRec      dc  i2'3'                  pCountsetEOFRef      ds  2                      file reference #               dc  i2'0'                  base of 0               dc  i4'0'                  displacement of 0 to create empty file               end******************************************************************  ConvertToPhonetics - Convert English strings to phonetic*        strings until user ready to stop.******************************************************************ConvertToPhonetics start         using GlobalsphStart  gequ  0                        char. in sayString to begin PARSEsize     gequ  2                        size of English string to PARSECTP0     putcr                          write carriage return         puts  #'Enter string to parse.  Press RETURN to exit.',cr=t         gets  sayString-1,cr=t         get string to PARSE         lda   sayString                if length = 0, exit         and   #$00FF         sta   size         bne   CTP1         rtsCTP1     stz   phStart                  initialize where to begin parsingCTP2     inc   phStart                  loop to PARSE current string         pha                              integer result         ph4   #sayString                 string to PARSE         ph4   #phString                  string to receive phonetics         lda   phStart                    where in English string to begin         pha         _Parse         pl2   phStart                    returns last char. converted         ph4   #phString                  write the phonetic string         _WriteLine         putcr                          write carriage return         lda   phStart                    translated all the chars.?         cmp   size         bne   CTP2                       No - continue inner loop         brl   CTP0                       Yes - continue outer loop         end******************************************************************  DeleteWord - Delete word from exceptions dictionary.******************************************************************DeleteWord start         using Globals         putcr         puts  #'Word to delete from dictionary?',cr=t         gets  word1-1,cr=t             get string to DELETE         ph4   #word1                   DELETE the word from the dictionary         _DictDelete         rts         end******************************************************************  DisplayDict - Display exceptions dictionary.******************************************************************DisplayDict start         using Globalsaddr     gequ  4DD0      putcr                          write carriage return         puts  #'Before displaying dictionary, we can initialize it.',cr=t         puts  #'Enter 0 to reset dictionary to beginning.',cr=t         puts  #'Enter 1 to delete current dictionary.',cr=t         puts  #'Enter 2 to NOT initialize dictionary.',cr=t         gets  answer-1,cr=t            get initialization flag         lda   answer+1         and   #$00FF         cmp   #'0'                     check if valid response         blt   Err1         cmp   #'3'         bge   Err1         sec                            if valid, convert to integer         sbc   #$30         cmp   #2                       skip initializing if user says to         beq   DD1         pha         _DictInit         bra   DD1Err1     puts  #'Please enter either 0, 1, or 2.',cr=t         brl   DD0;; Loop to display dictionary, from current word to end.;DD1      pha                            room for long result         pha         ph4   #word1                   English word         ph4   #word2                   its phonetic translation         _DictDump         pl4   addr         lda   word1                    check if at end of dictionary -         and   #$00FF                     length (word1) = 0         bne   DD2         rtsDD2      putcr                          write carriage return         puts  #'Next entry:  '         ph4   #word1         _WriteString         puts  #'   '         ph4   #word2         _WriteString         puts  #'      Continue? (Y or N)',cr=t         gets  answer-1,cr=t         lda   answer+1         and   #$00FF         cmp   #'N'         beq   Rts         cmp   #'n'         beq   Rts         brl   DD1Rts      rts         end******************************************************************  Init - Start the tools, initialize global data.**  Outputs:*        carry flag - Set if error detected; clear otherwise.******************************************************************Init     start         using Globals;; Display welcoming message.;         puts  #'Speak - A demonstration of the Talking Tools.',cr=t         putcr         puts  #'Please wait while we load the tools...',cr=t         putcr         putcr                          write carriage return;; Start the speech tools.;         ph4   #toolTable               load the RAM-based tools we need         _LoadTools         bcc   I1                       check for error from LoadTools call         sta   errNum         ph4   #toolErr         jsr   ReportErr         sec                            set error flag         rtsI1       lda   myID         pha         _ParseStartUp         _MaleStartUp         _FemaleStartUp         _SpeechStartUpRts      clc                            return OK flag         rts         end******************************************************************  InsertWord - Add a new word to the exceptions dictionary.******************************************************************InsertWord start         using GlobalsIW0      putcr                          write carriage return         puts  #'Press RETURN for the dictionary entries to exit.',cr=t         puts  #'Enter English word to add to dictionary:  '         gets  word1-1,cr=t             get English word         lda   word1                    if length = 0, exit         and   #$00FF         bne   IW1Rts      rtsIW1      puts  #'Enter phonetic representation of word to add:  '         gets  word2-1,cr=t             get phonetic word         lda   word2                    if length = 0, exit         and   #$00FF         beq   Rts         ph4   #word1         ph4   #word2         _DictInsert         brl   IW0         end****************************************************************** LoadDict - Load dictionary from disk file.******************************************************************LoadDict start         using Globals;; Get name of file to open.;         short M                        init. ORCA string to receive pathname         lda   #255         sta   pathname         sta   pathname+1         long  M         puts  #'Enter pathname of dictionary to open:  '         gets  pathname,cr=t            get name of file to open         lda   pathname+1               check empty string         and   #$00FF         bne   LD1         rtsLD1      sta   pathname                 convert ORCA string to GS/OS input string;; Open the file, allocate a buffer into which it will be read, then close file.;         _OpenGS  openRec               open the file         bcc   LD2                      handle error         sta   errNum         ph4   #openErr         jsr   ReportErr         rtsLD2      lda   openRef                  get ready to read and then close the file         sta   readRef         sta   closeRef         ph2   #1                       clear current dict from memory         _DictInit;; If the file is empty, close the file and skip loading it.;         lda   openSize         ora   openSize+2         bne   LD3         _CloseGS closeRec         rts;; If the file is not empty, allocate a read buffer, read and then close the; file.;LD3      ph4   #0                       allocate memory block to read files         ph4   openSize                 read in the whole thing         ph2   myID         ph2   #$C010                   locked, can't move, don't purge, don't!                                         cross bank bound., don't page align         ph4   #0                       no absolute address specified         _NewHandle         bcc   LD3A                     handle error:         plx                              throw away zero handle         plx         sta   errNum         ph4   #memErr         jsr   ReportErr                  report error         _CloseGS  closeRec               close file         rts                              returnLD3A     pl4   handle                   get ready to dereference the handle         lda   [handle]                 dereference memory handle         sta   readBuffer         sta   ptr         ldy   #2         lda   [handle],Y         sta   readBuffer+2         sta   ptr+2         lda   openSize                 get # bytes to read         sta   readRequest         lda   openSize+2         sta   readRequest+2         _ReadGS  readRec               make the Read call         php                            save error flag from read         pha                            save error #         _CloseGS closeRec         pla         plp         bcc   LD4                      handle error         sta   errNum         ph4   #readErr         jsr   ReportErr         bra   LD5;; Create new dictionary from entries in buffer.;LD4      clc                            tmp := address of last byte in buffer         lda   ptr         adc   transferCount         sta   tmp         lda   ptr+2         adc   transferCount+2         sta   tmp+2LD4A     lda   ptr+2                    while ptr < tmp do begin         cmp   tmp+2         blt   LD4C         beq   LD4B         bra   LD5LD4B     lda   ptr         cmp   tmp         blt   LD4C         bra   LD5LD4C     lda   ptr+2                      push pointer to English word         pha         lda   ptr         pha         lda   [ptr]                      calc. pointer to phonetic word:         and   #$00FF                     length (English word) + 1 + textPtr         inc   A         clc         adc   ptr         bcc   LD4D         inc   ptr+2LD4D     sta   ptr         ldx   ptr+2         phx                              push pointer to phonetic word         pha         _DictInsert                      insert new entry into dictionary         lda   [ptr]                      calc. pointer to next entry         and   #$00FF         inc   A         clc         adc   ptr         bcc   LD4E         inc   ptr+2LD4E     sta   ptr         bra   LD4A                     end {while};; Clean up and return.;LD5      lda   handle+2         pha         lda   handle         pha         _DisposeHandle         ph2   #0                       reset dict to top         _DictInit         rts         end******************************************************************  Main - Speak's main function.  Presents main menu and acts*        on user's choice.******************************************************************Main     start         using Globals;; Display main menu.;Top      puts  #'Enter desired function:  S to speak English string ',cr=t         puts  #'                         P to speak phonetic string',cr=t         puts  #'                         C to convert to phonetics ',cr=t         puts  #'                         G to set global speech parameters',cr=t         puts  #'                         A to activate dictionary  ',cr=t         puts  #'                         T to deactivate dictionary',cr=t         puts  #'                         D to display dictionary   ',cr=t         puts  #'                         I to insert word into dictionary ',cr=t         puts  #'                         R to remove word from dictionary ',cr=t         puts  #'                         L to load dictionary from disk',cr=t         puts  #'                         W to write dictionary to disk',cr=t         puts  #'                         Q to quit program         ',cr=t         putcr         gets  answer-1,cr=t            get user's choice         lda   answer+1                 dispatch appropriate routine:         and   #$00FF                   case (answer):         cmp   #'S'                       'S','s':  SpeakText;         bne   M2M1       jsr   SpeakText         brl   TopM2       cmp   #'s'         beq   M1         cmp   'P'                        'P','p': SpeakPhonetics         bne   M4M3       jsr   SpeakPhonetics         brl   TopM4       cmp   #'p'         beq   M3         cmp   #'C'                       'C','c': ConvertToPhonetics         bne   M6M5       jsr   ConvertToPhonetics         brl   TopM6       cmp   #'c'         beq   M5         cmp   #'G'                       'G','g': SetSpeechGlobals         bne   M8M7       jsr   SetSpeechGlobals         brl   TopM8       cmp   #'g'         beq   M7         cmp   #'A'                       'A','a': Activate dict         bne   M10M9       ph2   #1         _DictActivate         brl   TopM10      cmp   #'a'         beq   M9         cmp   #'T'                       'T','t': Deactivate dict         bne   M12M11      ph2   #0         _DictActivate         brl   TopM12      cmp   #'t'         beq   M11         cmp   #'D'                       'D','d': DisplayDict         bne   M14M13      jsr   DisplayDict         brl   TopM14      cmp   #'d'         beq   M13         cmp   #'I'                       'I','i': InsertWord         bne   M16M15      jsr   InsertWord         brl   TopM16      cmp   #'i'         beq   M15         cmp   #'R'                       'R','r': DeleteWord         bne   M18M17      jsr   DeleteWord         brl   TopM18      cmp   #'r'         beq   M17         cmp   #'L'                       'L','l': LoadDict         bne   M20M19      jsr   LoadDict         brl   TopM20      cmp   #'l'         beq   M19         cmp   #'W'                       'W','w': WriteDict         bne   M22M21      jsr   WriteDict         brl   TopM22      cmp   #'w'         beq   M21         cmp   #'Q'                       'Q','q': exit Main         beq   Rts         cmp   #'q'         bne   M23Rts      rtsM23      putcr                          write carriage return         puts  #'Please enter one of S, P, C, G, A, T, D, I, R, or Q',cr=t         putcr                          write carriage return         brl   Top         end******************************************************************  ReportErr - Report tool errors detected by program.******************************************************************ReportErr start         using GlobalsrtsAddr  gequ  8         pl2   rtsAddr                  save return address         _WriteLine         pha                            room for long result         pha         ph2   errNum         _HexIt         pl4   hexValue         ph4   #msg0         _WriteLine         ph2   rtsAddr                  restore return address         rts         end******************************************************************  SetSpeechGlobals - Set global speech parameters.******************************************************************SetSpeechGlobals start         using Globals         putcr                          write carriage return         puts  #'Follow the prompts to change the speech parameters.',cr=t;; Let user change current voice setting.;SSG1     puts  #'Voice = '              display current voice setting         lda   voice         bne   SSG2         puts  #'male  '         bra   SSG3SSG2     puts  #'female  'SSG3     puts  #'Enter 0 for male voice, 1 for female voice.',cr=t         gets  answer-1,cr=t            get user's response         lda   answer+1         and   #$00FF         cmp   #'0'                     check if it's valid         blt   DoErr1         cmp   #'2'         bge   DoErr1         sec                            if valid, convert to integer         sbc   #$30         sta   voice         bra   SSG4DoErr1   jsr   Err1         brl   SSG1Err1     putcr                          write carriage return         puts  #'Value must be either 0 or 1.',cr=t         rts;; Let user change current tone setting.;SSG4     puts  #'Tone = '               display current tone setting         lda   basePitch         bne   SSG5         puts  #'bass    '         bra   SSG6SSG5     puts  #'treble  'SSG6     puts  #'Enter 0 for bass tone, 1 for treble tone.',cr=t         gets  answer-1,cr=t            get user's response         lda   answer+1         and   #$00FF         cmp   #'0'                     check if it's valid         blt   DoErr2         cmp   #'2'         bge   DoErr2         sec                            if valid, convert to integer         sbc   #$30         sta   basePitch         bra   SSG7DoErr2   jsr   Err1         brl   SSG4;; Let user change current speed setting.;SSG7     puts  #'Speed = '              display current speed setting         put2  speed,cr=t         gets  answer-1,cr=t            get user's response         lda   answer+1         and   #$00FF         cmp   #'0'                     check if it's valid         blt   DoErr3         cmp   #':'         bge   DoErr3         sec                            if valid, convert to integer         sbc   #$30         sta   speed         bra   SSG8DoErr3   jsr   Err2         bra   SSG7Err2     putcr                          write carriage return         puts  #'Value must be between 0 and 9.',cr=t         rts;; Let user change current volume setting.;SSG8     puts  #'Volume = '             display current volume setting         put2  volume,cr=t         gets  answer-1,cr=t            get user's response         lda   answer+1         and   #$00FF         cmp   #'0'                     check if it's valid         blt   DoErr4         cmp   #':'         bge   DoErr4         sec                            if valid, convert to integer         sbc   #$30         sta   volume         bra   SSG9DoErr4   jsr   Err2         bra   SSG8;; Let user change current pitch setting.;SSG9     puts  #'Pitch = '              display current pitch setting         put2  pitch,cr=t         gets  answer-1,cr=t            get user's response         lda   answer+1         and   #$00FF         cmp   #'0'                     check if it's valid         blt   DoErr5         cmp   #':'         bge   DoErr5         sec                            if valid, convert to integer         sbc   #$30         sta   pitch         lda   voice         pha         lda   basePitch         pha         lda   pitch         pha         lda   speed         pha         lda   volume         pha         _SetSayGlobals         rtsDoErr5   jsr   Err2         bra   SSG9         end******************************************************************  ShutDown - Shut down tools, do any necessary clean-up before*        exiting program.******************************************************************ShutDown start         using Globals         _MaleShutDown         _FemaleShutDown         _ParseShutDown         _SpeechShutDown         rts         end******************************************************************  SpeakPhonetics - Speak phonetic strings until user is ready*        to stop.******************************************************************SpeakPhonetics start         using GlobalsSP0      putcr                          write carriage return         puts  #'Enter phonetic string to speak.  RETURN to exit.',cr=t         gets  phString-1,cr=t          get string to SPEAK         lda   phString                 if length = 0, exit         and   #$00FF         bne   SP1         rtsSP1      lda   volume                   else SPEAK the string just entered         pha         lda   speed         pha         lda   pitch         pha         ph4   #phString         lda   voice                    call MALE_SPEAK or FEMALE_SPEAK,         bne   SP2                        whichever is appropriate         _MaleSpeak         brl   SP0SP2      _FemaleSpeak         brl   SP0         end******************************************************************  SpeakText - Speak English strings until user is ready to stop.******************************************************************SpeakText start         using GlobalsST0      putcr                          write carriage return         puts  #'Enter string to speak.  Press RETURN to exit.',cr=t         gets  sayString-1,cr=t         get string to SAY         lda   sayString                if length = 0, exit         and   #$00FF         bne   ST1         rtsST1      ph4   #sayString               else SAY the string just entered         _Say         bra   ST0         end******************************************************************  WriteDict - Write dictionary to a disk file.******************************************************************WriteDict start         using Globals;; Get name of file to open.;         short M                        init. ORCA string to receive pathname         lda   #255         sta   pathname         sta   pathname+1         long  M         puts  #'Enter pathname of dictionary to write:  '         gets  pathname,cr=t            get name of file to open         lda   pathname+1               check empty string         and   #$00FF         bne   WD1         rtsWD1      sta   pathname                 convert ORCA string to GS/OS input string;; Check if the file exists.  If not, create the file.;         _GetFileInfoGS GFIRec          make GetFileInfo call to see if exists         bcc   WD3         cmp   #fileNotFoundErr         if error not file-not-found         beq   WD2         sta   errNum                     report error         ph4   #infoErr         jsr   ReportErr         rts                              and exitWD2      _CreateGS createRec            else create the file         bcc   WD3         sta   errNum         ph4   #createErr         jsr   ReportErr         rts;; Open the file, set its size to zero, allocate a write buffer.;WD3      _OpenGS  openRec               open the file         bcc   WD3A                     handle error         sta   errNum         ph4   #openErr         jsr   ReportErr         rtsWD3A     lda   openRef                  init. GS/OS file reference #s         sta   setEOFRef         sta   writeRef         sta   closeRef         _SetEOFGS setEOFRec            set file's size to 0         bcc   WD3B                     handle error         sta   errNum         ph4   #zeroErr         jsr   ReportErr         rts;; Allocate the write buffer.;WD3B     ph4   #0                       allocate memory block to read files         ph4   #1024                    1K buffer         ph2   myID         ph2   #$C010                   locked, can't move, don't purge, don't;                                         cross bank bound., don't page align         ph4   #0                       no absolute address specified         _NewHandle         bcc   WD3C                     handle error:         plx                              throw away zero handle         plx         sta   errNum         ph4   #memErr         jsr   ReportErr                  report error         _CloseGS  closeRec               close file         rts                              returnWD3C     pl4   handle                   get ready to dereference the handle         lda   [handle]                 dereference memory handle         sta   writeData         ldy   #2         lda   [handle],Y         sta   writeData+2         ph2   #0                       reset dictionary to top         _DictInit;; Main loop:  while not at end of dictionary, fill the buffer with dictionary;             entries, then write the buffer to disk.;WD4      pha                            room for long result         pha         ph4   #word1         ph4   #word2         _DictDump                      get 1st dictionary entry         pla         plaWD4A     stz   writeRequest             init. FillBuffer variables         stz   writeRequest+2         lda   [handle]         sta   ptr         ldy   #2         lda   [handle],Y         sta   ptr+2         ldy   #0         jsr   FillBuffer         php                            save flag returned from FillBuffer rtn         _WriteGS  writeRec             write buffer to disk         bcc   WD4B         sta   errNum         ph4   #writeErr         jsr   ReportErr         plp         bra   WD5WD4B     plp                            retrieve flag returned from FillBuffer         bcc   WD4A;; Final clean-up:  Close the file, deallocate buffer.;WD5      _CloseGS  closeRec             close the file         lda   handle+2         pha         lda   handle         pha         _DisposeHandle         ph2   #0                       reset dict. to top         _DictInit         rts;; FillBuffer:  fill the write buffer with dictionary entries.;FillBuffer anop         lda   word1                    check if we've gotten all entries         and   #$00FF         bne   FB1         sec                            yes - set flag that we're done         rtsFB1      lda   writeRequest             no - check if new entries will fit in         sta   tmp                        buffer         lda   writeRequest+2         sta   tmp+2         lda   word1                    add size of English word         and   #$00FF         clc         adc   tmp         bcc   FB1A         inc   tmp+2FB1A     sta   tmp         lda   word2                    add size of phonetic word         and   #$00FF         clc         adc   tmp         bcc   FB1B         inc   tmp+2FB1B     sta   tmp         lda   #2                       add length bytes to total         clc         adc   tmp         bcc   FB1C         inc   tmp+2FB1C     sta   tmp         cmp   #1024                    ensure that new total size is         blt   FB2                        less than or equal to buffer size         clc                            set flag that we're not done, then exit         rts;; We're not at the end of the dictionary, and the current entry will fit in; our buffer, so we move the entries to the buffer, then get the next entry.;FB2      lda   tmp                      update current amt. chars. in buffer         sta   writeRequest         lda   tmp+2         sta   writeRequest+2         lda   word1                    move English word to buffer         and   #$00FF         sta   count         ldx   #0         short MFB2A     lda   word1,X         sta   [ptr],Y         inx         iny         dec   count         bpl   FB2A         long  M         lda   word2                    move phonetic word to buffer         and   #$00FF         sta   count         ldx   #0         short MFB2B     lda   word2,X         sta   [ptr],Y         inx         iny         dec   count         bpl   FB2B         long  M         phy                            save index into buffer         pha                            room for long result         pha         ph4   #word1         ph4   #word2         _DictDump                      get next dictionary entry         pla         pla         ply         brl   FillBuffer         end