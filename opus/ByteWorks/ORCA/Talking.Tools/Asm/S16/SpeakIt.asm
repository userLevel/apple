         keep  speakit         mload speakit.macros************************************************** SpeakIt - A demo to show how the speech tools work.** Written by Barbara Allred and Design Master** Copyright 1990 by Byte Works, Inc.*************************************************** Speakit 1.0.2** December 1995* Mike Westerfield**   1.	Fixed a bug that caused the program to*	crash when a word with no phonetics*	was added to the dictionary.**************************************************SpeakIt  start         using SIData         phk                            ensure code and data in same bank         plb         jsr   Init                     start tools, bring up menu bar         bcs   SI1         jsr   EventLoop                execute main event loopSI1      jsr   ShutDown                 unload tools         _QuitGS quitRec                make GS/OS Quit call, instead of RTL         end**************************************************  SIData - Common data area for SpeakIt*************************************************SIData   data;;  Resource IDs.;startStopID    equ   1menuBarID      equ   $64appleMenuID    equ   1fileMenuID     equ   2editMenuID     equ   3speechMenuID   equ   4windowID       equ   6textEditID     equ   7dictWindID     equ   $200dictCtlID      equ   $201;; Filetypes;dictFileType   equ   $F2phonFileType   equ   $F1textFileType   equ   $04;;  Menu item IDs.;undoID         equ   250cutID          equ   251copyID         equ   252pasteID        equ   253clearID        equ   254closeID        equ   255aboutID        equ   256newID          equ   257openID         equ   258saveID         equ   259saveAsID       equ   260pSetUpID       equ   261printID        equ   262quitID         equ   263speakID        equ   264phonID         equ   265setID          equ   266dictID         equ   267activeID       equ   268;;  Event codes returned by TaskMaster;mouseDownEvt   GEQU   $0001             ; button down eventinButtDwn      GEQU   $0001             ; button down eventmouseUpEvt     GEQU   $0002             ; button up eventkeyDownEvt     GEQU   $0003             ; keystroke eventinKey          GEQU   $0003             ; keystroke eventautoKeyEvt     GEQU   $0005             ; auto key event:  key held down by userinUpdate       GEQU   $0006             ; update eventactivateEvt    GEQU   $0008             ; activate eventswitchEvt      GEQU   $0009             ; switch eventdeskAccEvt     GEQU   $000A             ; desk accessory eventdriverEvt      GEQU   $000B             ; driver eventapp1Evt        GEQU   $000C             ; application 1 eventapp2Evt        GEQU   $000D             ; application 2 eventapp3Evt        GEQU   $000E             ; application 3 eventapp4Evt        GEQU   $000F             ; application 4 eventwInDesk        GEQU   $0010             ; On DesktopwInMenuBar     GEQU   $0011             ; On system menu barwClickCalled   GEQU   $0012             ; system click calledwInContent     GEQU   $0013             ; In content regionwInDrag        GEQU   $0014             ; In drag regionwInGrow        GEQU   $0015             ; In grow region, active window onlywInGoAway      GEQU   $0016             ; In go-away region, active window onlywInZoom        GEQU   $0017             ; In zoom region, active window onlywInInfo        GEQU   $0018             ; In information barwInSpecial     GEQU   $0019             ; Item ID selected was 250 - 255wInDeskItem    GEQU   $001A             ; Item ID selected was 1 - 249wInFrame       GEQU   $001B             ; in Frame, but not on anything elsewInactMenu     GEQU   $001C             ; "selection" of inactive menu itemwClosedNDA     GEQU   $001D             ; desk accessory closedwCalledSysEdit GEQU   $001E             ; inactive menu item selectedwTrackZoom     GEQU   $001F             ; zoom box clicked, but not selectedwHitFrame      GEQU   $0020             ; button down on frame, made activewInControl     GEQU   $0021             ; button or keystroke in controlwInSysWindow   GEQU   $8000             ; hi bit set for system windows;;  Error numbers.;toolErr        equ   0                  Unable to load tools.  Aborting...memErr         equ   1                  Memory error.windErr        equ   2                  Can't create window.openErr        equ   3                  Error from GS/OS when opening file.readErr        equ   4                  Error from GS/OS when reading file.printErr       equ   5                  Print Mgr error.writeErr       equ   6                  Error from GS/OS when writing file.fileErr        equ   7                  Error when accessing file.createErr      equ   8                  Error from GS/OS when creating file.delErr         equ   9                  Error from GS/OS when deleting file.TEErr          equ   10                 Error from TEGetText call.SFOErr         equ   11                 Error from SFGetFile call.OOMErr         equ   12                 Out of memory; can't perform task.dlgErr         equ   13                 Error returned from Dialog Manager.zeroErr        equ   14                 Error from GS/OS when zeroing file.pathErr        equ   15                 Error when accessing pathname.ctlErr         equ   16                 Error when creating control.listErr        equ   17                 Attempt to grow list beyond max size.;;  Error messages.;msg0           dc    i1'44'               dc    c'Unable to load tools.  Aborting SpeakIt.    'msg1           dc    i1'44'               dc    c'Memory error reported:                      'msg2           dc    i1'44'               dc    c'Unable to create window:                    'msg3           dc    i1'44'               dc    c'Error returned by GS/OS when opening file:  'msg4           dc    i1'44'               dc    c'Error returned by GS/OS when reading file:  'msg5           dc    i1'44'               dc    c'Print Manager error reported:               'msg6           dc    i1'44'               dc    c'Error returned by GS/OS when writing file:  'msg7           dc    i1'44'               dc    c'Error returned by GS/OS when accessing file:'msg8           dc    i1'44'               dc    c'Error returned by GS/OS when creating file: 'msg9           dc    i1'44'               dc    c'Error returned by GS/OS when deleting file: 'msg10          dc    i1'44'               dc    c'Text Edit error reported:                   'msg11          dc    i1'44'               dc    c'Standard File error reported:               'msg12          dc    i1'44'               dc    c'Not enough memory to perform requested task.'msg13          dc    i1'44'               dc    c'Error returned by Dialog Manager            'msg14          dc    i1'44'               dc    c'Error returned by GS/OS when zeroing file:  'msg15          dc    i1'44'               dc    c'Error returned by GS/OS when accessing path:'msg16          dc    i1'44'               dc    c'Error when creating control:                'msg17          dc    i1'44'               dc    c'Attempt to grow list beyond maximum size.   ';; System error constants;diskSwitchedErr gequ $002EvolNotFoundErr  gequ $0045fileNotFoundErr gequ $0046;; Globals constants;maxListSize    gequ  $3FFF              largest list sizetextTyp        gequ  0                  window types:  text windowphonTyp        gequ  1                                 phonetics windowdictTyp        gequ  2                                 dictionary windowdictWindNum    gequ  10                 dictionary window is window #10dictIndex2     gequ  20                 dictionary' wind index into 2-byte arraysdictIndex4     gequ  40                 dictionary' wind index into 4-byte arraysdirtyOffset    equ   16                 offset to dirty flag in text edit recordisDirty        equ   $0040              mask to check dirty bitequal          gequ  0                  two strings are equalgreater        gequ  1                  1st string is greater than 2nd stringless           gequ  -1                 1st string is less than 2nd string;;  Global variables.;;                                       Direct page variables;ptr            gequ  0                    "generic" pointersptr2           gequ  4ptr3           gequ  8handle         gequ  12                   "generic" handlehandle2        gequ  16                   second "generic" handlecount          gequ  20                   "generic" countertmp            gequ  24                   "generic" temporaryitemHit        gequ  28                   "generic" item hit from a dialog box;; General variables;currWindow     ds    4                  front window's grafPort pointercurrWindNum    ds    2                  front window's #currIndex2     ds    2                  index into 2-byte window arrayscurrIndex4     ds    2                  index into 4-byte window arrayscurrWindTyp    ds    2                  front window's typewTitle         ds    4                  pointer to window's titlewRefCon        dc    i4'0'              index into window-tracking arraysmasterID       ds    2                  user ID passed by loadermyID           ds    2                  SpeakIt's user IDdone           dc    i2'0'              done flag - set if user selects QuitmenuHandle     ds    4                  "generic" menu handleprHandle       ds    4                  print record handlebuffer         ds    4                  buffer to hold text returned by TEGetTextbufferSize     dc    i4'0'              size of this bufferprRect         ds    8                  TEPaintText rect to draw intotRect          ds    8                  "generic" rect;; General Speech variables;dActiveFlag    dc    i2'-1'             true if dict is activeactiveMsg      dc    i1'13'             menu item when dict NOT active               dc    c'Dictionary on'inactiveMsg    dc    i1'14'             menu item when dict is active               dc    c'Dictionary off'selStart       ds    4                  offset into text of beginning of selectionselEnd         ds    4                  offset into text of ending of selectionselLength      ds    4                  length of current selectionsayLength      dc    i1'255'            length of string to SAYsayString      ds    255                string to SAYtmp4           ds    4                  temporary 4-byte field;; Phonetics variables;phBuffSize     dc    i4'0'              size of phonetics bufferphBuffer       ds    4                  handle to phonetics bufferphLength       dc    i1'255'            length byte of phonetics stringphString       ds    255                phonetics stringphStart        ds    2                  where to begin parsing in English string;; Speech parameter variables;setParmsPtr    ds    4                  pointer to set parameters grafPort;; Dictionary variables;actListSize    ds    2                  actual size of current listfreeArray      dc    5i2'-1'            those visMembers not assoc. w/ listtop            dc    i2'0'              member # at top of list displaybottom         dc    i2'-1'             member # at bottom of list displayoldTop         dc    i2'0'              prev member # at top of list displayoldBottom      dc    i2'0'              prev member # at bottom of list displaymountPrompt    dc    i1'30'               dc    c'Please place boot disk on-line'dictFileName   dc    i2'19'               dc    c'*/System/'defaultDName   dc    c'SpeechDict'dictName1Size  dc    i2'11'             name to display in dictionary windowdictName1      dc    c'< no file >'dictName2Size  dc    i2'15'             name to display in dictionary windowdictName2      dc    c'               'word1          dc    i1'255'            English word for dictionary               ds    255word2          dc    i1'255'            phonetic word for dictionary               ds    255dictChanged    dc    i2'0'              set if dict. has changed since last savednextEntry      dc    i2'0'              entry # of next dict. elementenglishSize    dc    i2'32'             English word in edit boxenglishText    ds    32phoneticSize   dc    i2'32'             phonetic word in edit boxphoneticText   ds    32visMembers     dc    i2'-1',i1'0',32c' '   array of English words:  5 x 35 bytes               dc    i2'-1',i1'0',32c' '               dc    i2'-1',i1'0',32c' '               dc    i2'-1',i1'0',32c' '               dc    i2'-1',i1'0',32c' ';;  Start/stop tools data structures;startStopRef   ds    4                  rsrc ID returned by StartUpTools calltoolTable      anop                     tool table to pass to LoadTools functionttNumTools     dc    i2'4'              # tools to be loadedtsArray        dc    i2'50,0'           maleSpeak (tsNum, req version)               dc    i2'51,0'           femaleSpeak               dc    i2'52,0'           parser               dc    i2'53,0'           speech;;  Extended task record;taskRec        anopwmWhat         ds    2wmMessage      ds    4wmWhen         ds    4wmWhere        ds    4wmModifiers    ds    2wmTaskData     ds    4wmTaskMask     dc    h'FFBF1F00'wmLastClickTick ds   4wmClickCount   ds    2wmTaskData2    ds    4wmTaskData3    ds    4wmTaskData4    ds    4wmLastClickPt  anop                     this is a pointwmLCP_Y        ds    2wmLCP_X        ds    2;;  Window tracking information -- We're allowing only 10 user windows to be;                                 opened on the desktop.;numWindows     dc    i2'0'              number of currently open windowsuserWindows    dc    i2'0'              number of currently open user windows;;  Array of flags indicating if window is up:  0 = not open; 1 = open;windUpFlag     dc    i2'0'              window 0               dc    i2'0'              window 1               dc    i2'0'              window 2               dc    i2'0'              window 3               dc    i2'0'              window 4               dc    i2'0'              window 5               dc    i2'0'              window 6               dc    i2'0'              window 7               dc    i2'0'              window 8               dc    i2'0'              window 9dictUpFlag     dc    i2'0'              window 10: dictionary window;;  Array of file flags for open windows:  0 = no file; 1 = assoc. with file;windFileFlag   dc    i2'0'              window 0               dc    i2'0'              window 1               dc    i2'0'              window 2               dc    i2'0'              window 3               dc    i2'0'              window 4               dc    i2'0'              window 5               dc    i2'0'              window 6               dc    i2'0'              window 7               dc    i2'0'              window 8               dc    i2'0'              window 9dictFileFlag   dc    i2'0'              window 10: dictionary window;;  Array of pointers to window grafPorts.;windowPtr      dc    i4'0'              window 0               dc    i4'0'              window 1               dc    i4'0'              window 2               dc    i4'0'              window 3               dc    i4'0'              window 4               dc    i4'0'              window 5               dc    i4'0'              window 6               dc    i4'0'              window 7               dc    i4'0'              window 8               dc    i4'0'              window 9dictWindowPtr  dc    i4'0'              window 10: dictionary window;;  Array of control handles.;teHandle       dc    i4'0'              window 0               dc    i4'0'              window 1               dc    i4'0'              window 2               dc    i4'0'              window 3               dc    i4'0'              window 4               dc    i4'0'              window 5               dc    i4'0'              window 6               dc    i4'0'              window 7               dc    i4'0'              window 8               dc    i4'0'              window 9dictCtlHndl    anop                     Dictionary control handlesfnCtlHndl      dc    i4'0'                filename, static textlistCtlHndl    dc    i4'0'                list controlfirstRsrcHndl  dc    i4'0'                title, static text               dc    i4'0'                phonetics prompt, static textphonCtlHndl    dc    i4'0'                phonetics word, edit box               dc    i4'0'                English prompt, static textenglCtlHndl    dc    i4'0'                English word, edit box               dc    i4'0'                word operations, stat text               dc    i4'0'                add button               dc    i4'0'                delete button               dc    i4'0'                translate button               dc    i4'0'                speak button               dc    i4'0'                file operations, stat text               dc    i4'0'                save button               dc    i4'0'                load button               dc    i4'0'                clear button               dc    i4'0'                print button               dc    i4'0'                exit button;;  Array of pointers to window names.;wNamePtr       dc    a4'wName0,wName1,wName2,wName3,wName4'               dc    a4'wName5,wName6,wName7,wName8,wName9';;  Array of window names.;wName0         dc    i1'17'               dc    17c' 'wName1         dc    i1'17'               dc    17c' 'wName2         dc    i1'17'               dc    17c' 'wName3         dc    i1'17'               dc    17c' 'wName4         dc    i1'17'               dc    17c' 'wName5         dc    i1'17'               dc    17c' 'wName6         dc    i1'17'               dc    17c' 'wName7         dc    i1'17'               dc    17c' 'wName8         dc    i1'17'               dc    17c' 'wName9         dc    i1'17'               dc    17c' ';;  Array of allocated pathname pointers, for opening files.;pathName       ds    4                  open file 0               ds    4                  open file 1               ds    4                  open file 2               ds    4                  open file 3               ds    4                  open file 4               ds    4                  open file 5               ds    4                  open file 6               ds    4                  open file 7               ds    4                  open file 8               ds    4                  open file 9dictPathName   ds    4                  open file 10: dictionary window;;  Array of allocated pathname handles, returned by SFO.;pathHandle     ds    4                  open file 0               ds    4                  open file 1               ds    4                  open file 2               ds    4                  open file 3               ds    4                  open file 4               ds    4                  open file 5               ds    4                  open file 6               ds    4                  open file 7               ds    4                  open file 8               ds    4                  open file 9dictPathHandle dc    i4'0'              open file 10: dictionary window;;  Standard File Operations data structures;replyRecord    anoprrGood         ds    2rrFileType     ds    2rrAuxType      ds    4rrNameVerb     dc    i2'3'              reference is undefined:  SFO will;                                         allocate and return a handlerrNameRef      ds    4                  refers to class 1 GS/OS output stringrrpathVerb     dc    i2'3'              reference is undefined:  SFO will do itrrPathRef      ds    4                  refers to class 1 GS/OS output stringopenMsg        dc    i1'20'               dc    c'Select file to open:'openTypes      anopnumEntries     dc    i2'4'              number of entries in filetype list;               dc    i2'$8000'               dc    i2'$F2'            dictionary file               dc    i4'0'               dc    i2'$8000'          match filetype, any auxtype, can select               dc    i2'$04'            ASCII text file               dc    i4'0'              don't care about auxtype               dc    i2'$8000'               dc    i2'$B0'            ORCA/APW source file               dc    i4'0'               dc    i2'$8000'               dc    i2'$F1'            phonetics text file               dc    i4'0'saveMsg        dc    i1'27'               dc    c'Enter name of file to save:'saveName       dc    i2'7'              default name to appear SFO save dlg               dc    c'newFile'saveName1      dc    i2'10'             default dict name to appear SFO save dlg               dc    c'SpeechDict'saveName2      dc    i2'15'             dict filename to appear SFO save dlg               dc    15c' ';;  Data structures for GS/OS file handling calls.;options        dc    i2'6'              6 bytes total in options area               ds    4;                                       GS/OS open recordopenRec        dc    i2'15'               pcountopenRef        ds    2                    refNumopenPath       ds    4                    pathname               dc    i2'$0003'            request read/write access               dc    i2'0'                resource number:  open data forkopenAccess     ds    2                    accessopenFileType   ds    2                    filetypeopenAuxType    ds    4                    auxType               ds    2                    storage type               ds    8                    create date/time               ds    8                    mod date/time               dc    i4'options'          pointer to GS/OS result bufferopenSize       ds    4                    eof:  # bytes that can be read               ds    4                    blocks used               ds    4                    resource eof               ds    4                    resource blocks;                                       GS/OS read recordreadRec        dc    i2'5'readRef        ds    2readBuffer     ds    4readRequest    ds    4transferCount  ds    4cache          dc    i2'0';                                       GS/OS close recordcloseRec       dc    i2'1'                pCountcloseRef       ds    2;                                       GS/OS destroy recorddestroyRec     dc    i2'1'                pCountdestroyPath    ds    4                    pointer to GS/OS input string;                                       GS/OS write recordwriteRec       dc    i2'5'                pCountwriteRef       ds    2                    file reference #writeData      ds    4                    pointer to data to writewriteRequest   ds    4                    # bytes to writewriteTransfer  ds    4                    # bytes actually written               dc    i2'0'                don't cache file;                                       GS/OS getFileInfo recordgetFileInfoRec dc    i2'12'               pCountGFIPath        ds    4                    pointer to GS/OS input stringGFIInfo        ds    26                   not relevant for our purposes               dc    a4'options'          pointer to GS/OS output buffer               ds    24                   not interested in this stuff;                                       GS/OS create recordcreateRec      dc    i2'7'                pCountcreatePath     ds    4                    pointer to GS/OS input string               dc    i2'$00C3'            destroy, rename, write, read accesscreateTyp      dc    i2'$0004'            filetype               dc    i4'0'                auxtype               dc    i2'$0001'            standard file               dc    i4'0'                initial size of data fork is 0               dc    i4'0'                initial size of resource fork is 0;                                       GS/OS EOF recordsetEOFRec      dc    i2'3'                pCountsetEOFRef      ds    2                    file reference #               dc    i2'0'                base of 0               dc    i4'0'                displacement of 0 to create empty file;                                       GS/OS quit recordquitRec        dc    i2'2'                pCount               dc    i4'0'                let GS/OS choose the next app. to run               dc    i2'0'                don't recall SpeakIt; load from disk;;  textInfo record, used to find out the number of lines in a document.;textInfo       anopcharCount      ds    4                  total # characters in documentlineCount      ds    4                  total # lines in document               ds    16                 other fields not interested in;; Dialogs, created with Design Master's help.;aboutDlg anop                           ; About menu item's dialog box         dc    i2'$02B,$0C4,$09C,$1B9'  ; Enclosing rectangle         dc    i2'-1'                   ; Visiblilty flag         dc    i4'0'                    ; RefCon, for application use         dc    i4'item00Abt1'           ; item pointer         dc    i4'item01Abt1'           ; item pointer         dc    i4'0'                    ; Null terminatoritem00Abt1 anop                         ; About dialog's static text item         dc    i2'$0064'                ; Item ID number         dc    i2'004,008,072,241'      ; Bounding rectangle         dc    i2'$000F'                ; Item Type         dc    i4'item00pointerAbt1'    ; Item descriptor         dc    i2'0093'                 ; Item value         dc    i2'$0000'                ; Item bit flag         dc    i4'0'                    ; Item color tableitem00pointerAbt1 anop                  ; Descriptor for About's static text         dc    i1'99'                   ; character count         dc    c'Speak It 1.0.2',h'0d'         dc    c'',h'0d'         dc    c'A simple demo to show how to',h'0d'         dc    c'use the speech tools.       ',h'0d'         dc    c'Written by Barbara Allred'item01Abt1 anop                         ; About dialog's OK button         dc    i2'$0001'                ; Item ID number         dc    i2'089,094,102,149'      ; Bounding rectangle         dc    i2'$000A'                ; Item Type         dc    i4'okTitle'              ; Item descriptor         dc    i2'0000'                 ; Item value         dc    i2'$0001'                ; Item bit flag         dc    i4'item01colorsAbt1'     ; Item color tableitem01colorsAbt1  dc  i2'$0010,$00D0,$0070,$00E8,$00B9'         ; ColorsokTitle  anop                           ; OK button's descriptor         dc    i1'002'                  ; character count         dc    c'OK'errAlert anop                               ; Error alert box         dc    i2'$02A,$04C,$082,$1F9'      ; Enclosing rectangle         dc    i2'1'                        ; Alert ID number         dc    h'81'                        ; Stage byte         dc    h'81'                        ; Stage byte         dc    h'81'                        ; Stage byte         dc    h'81'                        ; Stage byte         dc    i4'item00Err1'               ; item pointer:  Error message         dc    i4'item01Err1'               ; item pointer:  Error number         dc    i4'item02Err1'               ; item pointer:  OK button         dc    i4'0'                        ; null terminatoritem00Err1 anop                             ; Name as needed         dc    i2'$0064'                    ; Item ID number         dc    i2'030,010,045,409'          ; Bounding rectangle         dc    i2'$800F'                    ; Item TypeerrMsg   dc    i4'item00pointerErr1'        ; Item descriptor         dc    i2'0044'                     ; Item value         dc    i2'$0000'                    ; Item bit flag         dc    i4'0'                        ; Item color tableitem00pointerErr1 anop                      ; Descriptor         dc    i1'044'                      ; character count         dc    c'                      'item01Err1 anop                             ; Name as needed         dc    i2'$0064'                    ; Item ID number         dc    i2'050,150,065,200'          ; Bounding rectangle         dc    i2'$800F'                    ; Item Type         dc    i4'item01pointerErr1'        ; Item descriptor         dc    i2'0005'                     ; Item value         dc    i2'$0000'                    ; Item bit flag         dc    i4'0'                        ; Item color tableitem01pointerErr1 anop                      ; Descriptor         dc    i1'05'                       ; character count         dc    c'$'errNum   dc    c'0000'                      ; **item02Err1 anop                             ; Name as needed         dc    i2'$0001'                    ; Item ID number         dc    i2'070,200,085,230'          ; Bounding rectangle         dc    i2'$000A'                    ; Item Type         dc    i4'okTitle'                  ; Item descriptor         dc    i2'0000'                     ; Item value         dc    i2'$0001'                    ; Item bit flag         dc    i4'0'                        ; Item color tablesaveAlert      anop                     ; WantToSave alert box         dc    i2'$031,$088,$065,$1ED'  ; Enclosing rectangle         dc    i2'2'                    ; Alert ID number         dc    h'81'                    ; Stage byte         dc    h'81'                    ; Stage byte         dc    h'81'                    ; Stage byte         dc    h'81'                    ; Stage byte         dc    i4'item00Save'           ; item pointer:  Save message         dc    i4'item01Save'           ; item pointer:  filename         dc    i4'item02Save'           ; item pointer:  OK button         dc    i4'item03Save'           ; item pointer:  Cancel button         dc    i4'item04Save'           ; item pointer:  Cancel button         dc    i4'0'                    ; null terminatoritem00Save     anop                     ; save alert's message template         dc    i2'$0064'                ; Item ID number         dc    i2'7,120,17,329'         ; Bounding rectangle         dc    i2'$800F'                ; Item Type         dc    i4'item00pointerSave'    ; Item descriptor         dc    i2'27'                   ; Item value         dc    i2'$0001'                ; Item bit flag         dc    i4'0'                    ; Item color tableitem00pointerSave  anop                 ; Descriptor         dc    i1'27'                   ; character count         dc    c'Save changes before closing'item01Save     anop                     ; save alert's filename template         dc    i2'$0065'                ; Item ID number         dc    i2'19,130,29,230'        ; Bounding rectangle         dc    i2'$800F'                ; Item Type         dc    i4'saveFN'               ; Item descriptorsaveFNSize dc  i2'18'                   ; Item value         dc    i2'$0001'                ; Item bit flag         dc    i4'0'                    ; Item color tablesaveFN   anop                           ; Descriptor         dc    i1'18'                   ; character count         dc    18c' 'item02Save     anop                     ; save alert's OK button template         dc    i2'$0001'                ; Item ID number         dc    i2'32,32,45,94'          ; Bounding rectangle         dc    i2'$000A'                ; Item Type         dc    i4'item02PointerSave'    ; Item descriptor         dc    i2'0000'                 ; Item value         dc    i2'$0000'                ; Item bit flag:  round         dc    i4'0'                    ; Item color tableitem02PointerSave anop                  ; Descriptor         dc    i1'3'                    ; character count         dc    c'Yes'item03Save     anop                     ; save alert's No button template         dc    i2'$0003'                ; Item ID number         dc    i2'32,134,45,208'        ; Bounding rectangle         dc    i2'$000A'                ; Item Type         dc    i4'item03PointerSave'    ; Item descriptor         dc    i2'0000'                 ; Item value         dc    i2'$0000'                ; Item bit flag:  round         dc    i4'0'                    ; Item color tableitem03PointerSave anop                  ; Descriptor         dc    i1'2'                    ; character count         dc    c'No'item04Save anop                         ; Save alert's Cancel button template         dc    i2'$0002'                ; Item ID number         dc    i2'32,239,45,325'        ; Bounding rectangle         dc    i2'$000A'                ; Item Type         dc    i4'cancelTitle'          ; Item descriptor         dc    i2'0'                    ; Item value         dc    i2'$0000'                ; Item bit flag         dc    i4'0'                    ; Item color tablecancelTitle    anop                     ; Descriptor         dc    i1'006'                  ; character count         dc    c'Cancel'setParmsDlg    anop                     ; Rename to suit your needs         dc    i2'$028,$060,$09C,$1FB'  ; Enclosing rectangle         dc    i2'-1'                   ; Visiblilty flag         dc    i4'0'                    ; RefCon, for application use         dc    i4'item00parm'           ; item pointer:  male voice radio button         dc    i4'item01parm'           ; item pointer:  female voice radio btn         dc    i4'item02parm'           ; item pointer:  dialog's title         dc    i4'item03parm'           ; item pointer:  treble radio button         dc    i4'item04parm'           ; item pointer:  bass radio button         dc    i4'item05parm'           ; item pointer:  pitch edit-line box         dc    i4'item07parm'           ; item pointer:  volume edit-line box         dc    i4'item06parm'           ; item pointer:  speed edit-line box         dc    i4'item08parm'           ; item pointer:  pitch's static text         dc    i4'item09parm'           ; item pointer:  speed's static text         dc    i4'item10parm'           ; item pointer:  volume's static text         dc    i4'item11parm'           ; item pointer:  OK button         dc    i4'item12parm'           ; item pointer:  Cancel button         dc    i4'0'                    ; null terminatoritem00parm     anop                     ; Male voice radio button         dc    i2'$0003'                ; Item ID number         dc    i2'17,12,30,126'         ; Bounding rectangle         dc    i2'$000C'                ; Item Type         dc    i4'item00pointerparm'    ; Item descriptormaleVoice dc   i2'1'                    ; Item value:  initially selected         dc    i2'$0001'                ; Item bit flag         dc    i4'0'                    ; Item color tableitem00pointerparm anop                  ; Descriptor         dc    i1'10'                   ; character count         dc    c'Male voice'item01parm     anop                     ; Female voice radio button         dc    i2'$0004'                ; Item ID number         dc    i2'30,11,43,140'         ; Bounding rectangle         dc    i2'$000C'                ; Item Type         dc    i4'item01pointerparm'    ; Item descriptorfemaleVoice dc i2'0'                    ; Item value:  initially not selected         dc    i2'$0001'                ; Item bit flag         dc    i4'0'                    ; Item color tableitem01pointerparm anop                  ; Descriptor         dc    i1'12'                   ; character count         dc    c'Female voice'item02parm anop                         ; Set parameters title         dc    i2'$0005'                ; Item ID number         dc    i2'3,111,13,270'         ; Bounding rectangle         dc    i2'$800F'                ; Item Type         dc    i4'item02pointerparm'    ; Item descriptor         dc    i2'21'                   ; Item value         dc    i2'$0000'                ; Item bit flag         dc    i4'0'                    ; Item color tableitem02pointerparm anop                  ; Descriptor         dc    i1'21'                   ; character count         dc    c'Set speech parameters'item03parm     anop                     ; Treble radio button         dc    i2'$0006'                ; Item ID number         dc    i2'72,12,85,97'          ; Bounding rectangle         dc    i2'$000C'                ; Item Type         dc    i4'item03pointerparm'    ; Item descriptortreble   dc    i2'0'                    ; Item value         dc    i2'$0002'                ; Item bit flag         dc    i4'0'                    ; Item color tableitem03pointerparm anop                  ; Descriptor         dc    i1'6'                    ; character count         dc    c'Treble'item04parm     anop                     ; Bass radio button         dc    i2'$0007'                ; Item ID number         dc    i2'58,10,71,80'          ; Bounding rectangle         dc    i2'$000C'                ; Item Type         dc    i4'item04pointerparm'    ; Item descriptorbass     dc    i2'1'                    ; Item value:  initially selected         dc    i2'$0002'                ; Item bit flag         dc    i4'0'                    ; Item color tableitem04pointerparm anop                  ; Descriptor         dc    i1'4'                    ; character count         dc    c'Bass'item05parm     anop                     ; Pitch edit line box         dc    i2'$0008'                ; Item ID number         dc    i2'19,355,32,378'        ; Bounding rectangle         dc    i2'$0011'                ; Item Type         dc    i4'pitch'                ; Item descriptor         dc    i2'1'                    ; Item value         dc    i2'$0000'                ; Item bit flag         dc    i4'0'                    ; Item color tablepitch    anop                           ; Descriptor         dc    i1'1'                    ; character count         dc    c'5'item06parm     anop                     ; Speed edit line box         dc    i2'$0009'                ; Item ID number         dc    i2'35,355,48,378'        ; Bounding rectangle         dc    i2'$0011'                ; Item Type         dc    i4'speed'                ; Item descriptor         dc    i2'1'                    ; Item value         dc    i2'$0000'                ; Item bit flag         dc    i4'0'                    ; Item color tablespeed    anop                           ; Descriptor         dc    i1'1'                    ; character count         dc    c'5'item07parm     anop                     ; Volume edit line box         dc    i2'$000A'                ; Item ID number         dc    i2'51,355,64,378'        ; Bounding rectangle         dc    i2'$0011'                ; Item Type         dc    i4'volume'               ; Item descriptor         dc    i2'1'                    ; Item value         dc    i2'$0000'                ; Item bit flag         dc    i4'0'                    ; Item color tablevolume   anop                           ; Descriptor         dc    i1'1'                    ; character count         dc    c'5'item08parm     anop                     ; Title for Pitch edit line box         dc    i2'$000B'                ; Item ID number         dc    i2'20,296,30,334'        ; Bounding rectangle         dc    i2'$800F'                ; Item Type         dc    i4'item08pointerparm'    ; Item descriptor         dc    i2'5'                    ; Item value         dc    i2'$0000'                ; Item bit flag         dc    i4'0'                    ; Item color tableitem08pointerparm anop                  ; Descriptor         dc    i1'5'                    ; character count         dc    c'Pitch'item09parm     anop                      ; Title for Speed edit line box         dc    i2'$000C'                 ; Item ID number         dc    i2'36,296,46,336'         ; Bounding rectangle         dc    i2'$800F'                 ; Item Type         dc    i4'item09pointerparm'     ; Item descriptor         dc    i2'5'                     ; Item value         dc    i2'$0000'                 ; Item bit flag         dc    i4'0'                     ; Item color tableitem09pointerparm anop                  ; Descriptor         dc    i1'5'                    ; character count         dc    c'Speed'item10parm     anop                     ; Title for Volume edit line box         dc    i2'$000D'                ; Item ID number         dc    i2'52,297,62,347'        ; Bounding rectangle         dc    i2'$800F'                ; Item Type         dc    i4'item10pointerparm'    ; Item descriptor         dc    i2'6'                    ; Item value         dc    i2'$0000'                ; Item bit flag         dc    i4'0'                    ; Item color tableitem10pointerparm anop                  ; Descriptor         dc    i1'6'                    ; character count         dc    c'Volume'item11parm     anop                     ; OK button         dc    i2'$0001'                ; Item ID number         dc    i2'94,100,107,155'       ; Bounding rectangle         dc    i2'$000A'                ; Item Type         dc    i4'okTitle'              ; Item descriptor         dc    i2'0'                    ; Item value         dc    i2'$0001'                ; Item bit flag         dc    i4'0'                    ; Item color tableitem12parm     anop                     ; Cancel button         dc    i2'$0002'                ; Item ID number         dc    i2'94,216,107,302'       ; Bounding rectangle         dc    i2'$000A'                ; Item Type         dc    i4'cancelTitle'          ; Item descriptor         dc    i2'0'                    ; Item value         dc    i2'$0000'                ; Item bit flag         dc    i4'0'                    ; Item color tablePErrorAlert    anop                     ; Set parameters error alert         dc    i2'$031,$088,$072,$1D9'  ; Enclosing rectangle         dc    i2'3'                    ; Alert ID number         dc    h'81'                    ; Stage byte         dc    h'82'                    ; Stage byte         dc    h'83'                    ; Stage byte         dc    h'84'                    ; Stage byte         dc    i4'item00PErr'           ; item pointer         dc    i4'item01PErr'           ; item pointer         dc    i4'0'                    ; null terminatoritem00PErr     anop                     ; Error message         dc    i2'$0064'                ; Item ID number         dc    i2'32,61,42,276'         ; Bounding rectangle         dc    i2'$000F'                ; Item Type         dc    i4'item00pointerPErr'    ; Item descriptor         dc    i2'30'                   ; Item value         dc    i2'$0001'                ; Item bit flag         dc    i4'0'                    ; Item color tableitem00pointerPErr anop                  ; Descriptor         dc    i1'30'                   ; character count         dc    c'Value must be between 0 and 9.'item01PErr     anop                     ; OK button         dc    i2'$0001'                ; Item ID number         dc    i2'48,134,61,189'        ; Bounding rectangle         dc    i2'$000A'                ; Item Type         dc    i4'okTitle'              ; Item descriptor         dc    i2'0'                    ; Item value         dc    i2'$0001'                ; Item bit flag         dc    i4'0'                    ; Item color tablesaveDictAlert anop                      ; Save dictionary alert         dc    i2'$033,$028,$083,$212'  ; Enclosing rectangle         dc    i2'4'                    ; Alert ID number         dc    h'81'                    ; Stage byte         dc    h'82'                    ; Stage byte         dc    h'83'                    ; Stage byte         dc    h'84'                    ; Stage byte         dc    i4'item00dict'           ; item pointer: prompt         dc    i4'item01dict'           ; item pointer: Yes button         dc    i4'item02dict'           ; item pointer: No button         dc    i4'item03dict'           ; item pointer: Cancel button         dc    i4'0'                    ; null terminatoritem00dict anop                         ; prompt         dc    i2'$0064'                ; Item ID number         dc    i2'13,131,23,463'        ; Bounding rectangle         dc    i2'$800F'                ; Item Type: static text + disable         dc    i4'item00pointerdict'    ; Item descriptor         dc    i2'46'                   ; Item value         dc    i2'$0000'                ; Item bit flag         dc    i4'0'                    ; Item color tableitem00pointerdict anop                  ; Descriptor         dc    i1'46'                   ; character count         dc    c'Would you like to save the current dictionary?'item01dict anop                         ; Yes push button         dc    i2'$0001'                ; Item ID number         dc    i2'42,54,55,133'         ; Bounding rectangle         dc    i2'$000A'                ; Item Type         dc    i4'item01pointerdict'    ; Item descriptor         dc    i2'0'                    ; Item value         dc    i2'$0001'                ; Item bit flag         dc    i4'0'                    ; Item color tableitem01pointerdict anop                  ; Descriptor         dc    i1'3'                    ; character count         dc    c'Yes'item02dict anop                         ; No push button         dc    i2'$0003'                ; Item ID number         dc    i2'42,194,55,276'        ; Bounding rectangle         dc    i2'$000A'                ; Item Type         dc    i4'item02pointerdict'    ; Item descriptor         dc    i2'0'                    ; Item value         dc    i2'$0000'                ; Item bit flag         dc    i4'0'                    ; Item color tableitem02pointerdict anop                  ; Descriptor         dc    i1'2'                    ; character count         dc    c'No'item03dict anop                         ; Cancel button         dc    i2'$0002'                ; Item ID number         dc    i2'42,349,55,435'        ; Bounding rectangle         dc    i2'$000A'                ; Item Type         dc    i4'cancelTitle'          ; Item descriptor         dc    i2'0'                    ; Item value         dc    i2'$0000'                ; Item bit flag         dc    i4'0'                    ; Item color tablefnTempl  anop                           filename template         dc    i2'$8'                   ; parm count         dc    i4'8'                    ; ID number         dc    i2'$0005,$0133,$000F,$018D'  ; rectangle         dc    i4'$81000000'            ; Defproc            dc    i2'$0000'                ; flags         dc    i2'$1000'                ; More flags         dc    i4'0'                    ; RefConfnText   dc    a4'dictName1'            ; text referencefnTextSize dc  i2'11'                   ; lengthlistTempl anop                          list control template         dc    i2'14'                   ; parm count         dc    i4'9'                    ; ID number         dc    i2'$0016,$0024,$004A,$0218'  ; rectangle         dc    i4'$89000000'            ; Def proc          dc    i2'$0000'                ; flags         dc    i2'$1400'                ; More flagslistRefCon dc  i4'0'                    ; RefCon:  memory handle for member arraylistSize dc    i2'$0000'                ; List size         dc    i2'$0005'                ; List view         dc    i2'$0006'                ; List typelistStart dc   i2'$0000'                ; List start         dc    a4'ListDrawRtn'          ; member drawing routine         dc    i2'$a'                   ; member height         dc    i2'8'                    ; member record sizememArray dc    i4'0'                    ; pointer to member array         end************************************************** CompareRtn - Compare two strings.** Input:*        13,S - length of 1st string*        9,S  - pointer to 1st string*        7,S  - length of 2nd string*        5,S  - pointer to 2nd string** Output:*        A - 0 = equal; 1 = greater than; -1 = less than**************************************************CompareRtn start         using SIDatalen1     equ   15wPtr1    equ   11len2     equ   9wPtr2    equ   5rtn      equ   3         phd                            save old Direct Page register         tsc                            set up new Direct Page on stack         tcd         ldy   #0                       while ((len1 <> 0) and (len2 <> 0))         short MTop1     lda   len1         beq   CR1                        check equality condition         lda   len2                       if (len1 <> 0) and (len2 = 0)         beq   CR3                          return (greater)         lda   [wPtr1],Y                  if (*wPtr1 [Y] < *wPtr2 [Y])         cmp   [wPtr2],Y                    return (less)         blt   CR1A         bne   CR3                        else if (*wPtr1 [Y] > *wPtr2 [Y]);                                           return (greater)         iny                              else (*wPtr1 [Y] = *wPtr2 [Y])         dec   len1                         Y++;  len1--;  len2--         dec   len2         bra   Top1CR1      lda   len2                     len1 = 0; if (len2 = 0)         beq   CR2                        return (equal)CR1A     ldx   #less                    else         bra   Rts                        return (less)CR2      ldx   #equal                   return equal here         bra   RtsCR3      ldx   #greater                 return greater hereRts      long  M         lda   rtn                      move return addr to top of stack         sta   len1         pld                            restore original Direct Page register         tsc                            "pop" parameters from stack         clc         adc   #12         tcs         txa                            return result in A         rts         end************************************************** CreateWindow - Create new window on the desktop.**************************************************CreateWindow start         using SIData         ph4   #0                       outer call:  NewControl2         ph4   #0                         inner call:  NewWindow2         ph4   wTitle                       pointer to window's title         ph4   wRefCon                      index into window-tracking arrays         ph4   #0                           no content-draw routine         ph4   #0                           standard defProc routine         pea   2                            paramlist is resource ID         ph4   #windowID                    resource ID of window parameter list         pea   $800E                        resource type = rWindParam1         _NewWindow2         bcc   CW1                          handle error returned by call:         plx                                  pull nil off stack         plx         plx         plx                                  pull room for outer call         pea   windErr                        report error         jsr   HandleError         sec                                return (error)         rtsCW1      ldx   currIndex4                   record window pointer         lda   1,S         sta   windowPtr,X         sta   currWindow         lda   3,S         sta   windowPtr+2,X         sta   currWindow+2;                                       create text edit record for window:         pea   2                          will push rsrc ID of control template         ph4   #textEditID                textEdit control's resource ID         _NewControl2         bcc   Rts                        handle error returned from call:         plx                                throw away zero handle         plx         pea   windErr                         report error         jsr   HandleError         jsr   DoClose         sec                                return (error)         rtsRts      ldx   currIndex4                 record textEdit handle         pla         sta   teHandle,X         pla         sta   teHandle+2,X         clc                            return (no error)         rts         end************************************************** DictAddWord - Handle adding entry to dictionary.**************************************************DictAddWord start         using SIDatafoundFlag equ  50                       set if new word found in dict.;; Get pointer to English word.;         jsr   GetEnglishBox         lda   #^englishSize         sta   ptr+2         lda   #englishSize         inc   A         bne   HAW2A         inc   ptr+2HAW2A    sta   ptr         short M                        convert pointer to text into pointer         lda   englishSize                to Pascal-style string         sta   [ptr]         long  M	lda	englishSize	quit if there is no word	and	#$00FF	bne	lb1	rts;; Get pointer to phonetic word.;lb1      jsr   GetPhonBox         lda   #^phoneticSize         sta   ptr2+2         lda   #phoneticSize         inc   A         bne   HAW2B         inc   ptr2+2HAW2B    sta   ptr2         short M                        convert pointer to text into pointer         lda   phoneticSize               to Pascal-style string         sta   [ptr2]         long  M	lda	phoneticSize	quit if there is no word	and	#$00FF	bne	lb2	rts;; Ensure that the new word will fit in the current list.; If not, attempt to grow the list.;lb2      lda   listSize         inc   A         cmp   actListSize         blt   HAW1         beq   HAW1         jsr   GrowList         bcc   HAW1         rtsHAW1     ph4   listCtlHndl              we'll be redrawing the dict display         _HideControl         ph4   listCtlHndl         _DisposeControl;; Add word to the dictionary.;         lda   ptr+2                    pointer to English word         pha         lda   ptr         pha         lda   ptr2+2                   pointer to phonetic word         pha         lda   ptr2         pha         _DictInsert         pea   0         _DictInit         stz   nextEntry                insert operation resets dict to top         inc   listSize                 one more word in dictionary         lda   #0                       restore high byte of word size fields         short M         sta   [ptr]         sta   [ptr2]         long  M;; Now we'll want to scroll the display so that the new word will appear at; the top of the list.  We'll start by removing all of the words currently; visible, then search the dictionary for our new word, filling the; display array as we go.;         inc   ptr                      restore pointer to English text         bne   HAW3         inc   ptr+2HAW3     ldx   top                      remove current elements from display         ldy   bottom         jsr   MakeInvisible;; Outer loop:  dump dictionary entries until we find the one we just inserted.;         stz   foundFlag                foundFlag := false         lda   #-4                      listStart := -4         sta   listStart         lda   memArray                 ptr2 := addr (memArray [0])         sta   ptr2         lda   memArray+2         sta   ptr2+2         ldx   #^word1                  tmp4 := addr (word1 + 1)         lda   #word1         inc   A         bne   HAW3AA         inxHAW3AA   sta   tmp4         stx   tmp4+2;                                       doHAW3A    clc                              listStart += 5         lda   listStart         adc   #5         sta   listStart         stz   count                      count := 0         lda   nextEntry                  top   := nextEntry         sta   top         clc                              bottom := top + 4         adc   #4         sta   bottom         lda   #^visMembers               ptr3 := addr (visMembers [0])         sta   ptr3+2         lda   #visMembers         sta   ptr3;; Inner loop:  fill visMembers array with next group of 5 elements.;HAW3B    lda   count                      while (count < 5)         cmp   #5         blt   HAW3BB         brl   HAW3EHAW3BB   pea   0                            room for long result         pea   0         ph4   #word1                       dump english word         ph4   #word2                       dump phonetic translation         _DictDump         pla                                tmp := DictDump ( ... )         plx         sta   tmp         stx   tmp+2         lda   word1                        if (end-of-dict)         and   #$00FF                         /* null english word returned */         beq   HAW4A                          goto HAW4A         tax                                X := length (english word)         tay                                ptr3^.english := word1         iny         iny         short MHAW3AAA  lda   word1,X         sta   [ptr3],Y         dey         dex         bpl   HAW3AAA         long  M         lda   foundFlag                    if (foundFlag == true)         bne   HAW3D                          skip comparison         lda   englishSize                  compare new word to curr. dict entry         pha         lda   ptr+2         pha         lda   ptr         pha         lda   word1         and   #$00FF         pha         ph4   tmp4         jsr   CompareRtn         bne   HAW3D                        if (words are equal)         inc   foundFlag                      foundFlag := trueHAW3D    lda   nextEntry                    ptr3^.mem# := nextEntry         sta   [ptr3]         ldy   #4                           ptr2^.flag := 0         lda   #0         sta   [ptr2],Y         ldy   #5                           ptr2^.phoneticPtr := tmp         lda   tmp+2         sta   [ptr2],Y         iny         lda   tmp         sta   [ptr2],Y         inc   count                        count++         inc   nextEntry                    nextEntry++         clc                                ptr2++         lda   ptr2         adc   #8         sta   ptr2         lda   ptr2+2         adc   #0         sta   ptr2+2         clc                                ptr3++         lda   ptr3         adc   #35         sta   ptr3         lda   ptr3+2         adc   #0         sta   ptr3+2         brl   HAW3B                      end whileHAW3E    lda   foundFlag                end do         bne   HAW4B         brl   HAW3A;; Handle encountering end of dictionary.;HAW4A    lda   nextEntry                listSize := nextEntry         sta   listSize         dec   A                        bottom := listSize - 1         sta   bottom         sec                            top := bottom - 4         sbc   #4         bpl   HAW4AA                   if (top < 0)         lda   #0                         top := 0HAW4AA   sta   top         inc   A                        listStart := top + 1         sta   listStart         pea   0                        reset dict. to top         _DictInit         stz   nextEntry;; Set visMember #s for elements in display.;HAW4B    lda   top                      tmp   := top         sta   tmp         stz   count                    count := 0         ldx   #0                       X     := 0HAW4C    lda   count                    while (count < 5)         cmp   #5         bge   HAW5         lda   tmp         cmp   bottom         bgt   HAW5         lda   visMembers,X               A := visMembers [X].mem#         bmi   HAW5                       if (A < 0);                                           goto HAW5         sta   ptr2                       ptr2 := addr (memArray [A])         stz   ptr2+2         ldy   #3HAW4D    asl   ptr2         rol   ptr2+2         dey         bne   HAW4D         clc         lda   ptr2         adc   memArray         sta   ptr2         lda   ptr2+2         adc   memArray+2         sta   ptr2+2         lda   count                      ptr2^.vis# := count         sta   [ptr2]         inc   count                      count++         inc   tmp                        tmp++         clc                              X++         txa         adc   #35         tax         bra   HAW4C;; We're now ready to recreate the control and exit.;HAW5     pea   0                        room for long result         pea   0         lda   dictWindowPtr+2          window that own's control         pha         lda   dictWindowPtr         pha         pea   0                        will push pointer to template         ph4   #listTempl         _NewControl2         bcc   HAW5A                    handle error         plx                              throw away zero handle         plx         pea   ctlErr                      report error         jsr   HandleError         ph4   dictWindowPtr              close the dict window         _CloseWindowHAW5A    pla         sta   listCtlHndl         pla         sta   listCtlHndl+2         lda   #1                       indicate dict changed since last save         sta   dictChanged         rts         end************************************************** DictClear - Handle clearing current dictionary*             from memory.**************************************************DictClear start         using SIData         lda   dictChanged              before clearing dict., check if user         beq   DC1                        wants to save current dictionary         jsr   WantToSaveDict         bcc   DC1                      check if user selected Cancel         rtsDC1      jsr   EmptyDict                init dict to empty         jsr   SetNoFileDName           set its name to "No name"         rts         end************************************************** DictConvertWord - Handle converting English*                   word to its phonetic representation.**************************************************DictConvertWord start         using SIData;; Get pointer to English word.;         jsr   GetEnglishBox         short M                        copy text to SAY string         lda   englishSize         sta   sayLength         tay         deyHCW1A    lda   [ptr],Y         sta   sayString,Y         dey         bpl   HCW1A         lda   #255         sta   phLength         long  M;; Convert the string to phonetics.;         pea   0                        room for integer result         ph4   #sayLength               pointer to English string to convert         ph4   #phLength                pointer to string to receive phonetics         pea   1                        start at 1st char. of English string         _Parse         pla                            throw away result;; Set phonetics edit box to returned phonetic string.;         lda   phLength                 set size of text         and   #$00FF         cmp   #33         blt   HCW2         lda   #32HCW2     sta   phoneticSize         ldy   phoneticSize             copy string to phonetics data area         dey         short MHCW2A    lda   phString,Y         sta   phoneticText,Y         dey         bpl   HCW2A         long  M         ph4   phonCtlHndl              we'll be redrawing the phonetics box         _HideControl         lda   phonCtlHndl              get edit record handle from control         sta   handle                     record         lda   phonCtlHndl+2         sta   handle+2         lda   [handle]                   dereference control handle         sta   ptr         ldy   #2         lda   [handle],Y         sta   ptr+2         ldy   #30         lda   [ptr],Y         sta   tmp4+2         ldy   #28         lda   [ptr],Y         sta   tmp4         ph4   #phoneticText            pointer to text for box         lda   phoneticSize             text length         pha         ph4   tmp4                     phonetics Line Edit record handle         _LESetText         ph4   phonCtlHndl              redraw the control         _ShowControl         rts         end************************************************** DictDeleteWord - Handle deleting dictionary entry.**************************************************DictDeleteWord start         using SIDatafndFlag  equ   50                       true if have passed deleted word in dict         ph4   listCtlHndl              we'll be redrawing the dict display         _HideControl         ph4   listCtlHndl         _DisposeControl;; Get pointer to English word.;         jsr   GetEnglishBox            fill englishSize, englishWord variables         lda   #^englishSize            ptr := & (englishSize) + 1         sta   ptr+2         lda   #englishSize         inc   A         bne   HDW2A         inc   ptr+2HDW2A    sta   ptr         short M         lda   englishSize              convert text area to Pascal-style         sta   [ptr]                      string by creating length byte         long  M;; Delete word from dictionary.;         lda   ptr+2         pha         lda   ptr         pha         _DictDelete         lda   #0                       restore byte used as length byte         short M         sta   [ptr]         long  M         inc   ptr                      restore pointer to English text         bne   HDW2B         inc   ptr+2HDW2B    pea   0         _DictInit         stz   nextEntry                delete operation resets dict to top;; Now we'll want to scroll the display to show where we deleted the word.; We'll start by removing all of the words currently visible, then search the; dictionary for the first word greater than the deleted word, filling the; display array as we go.;         ldx   top         ldy   bottom         jsr   MakeInvisible;; Outer loop:  dump dictionary entries until we find the entry that follows the;              one we just deleted.;         stz   fndFlag                  fndFlag := false         lda   #-4                      listStart := -4         sta   listStart         lda   memArray                 ptr2 := addr (memArray [0])         sta   ptr2         lda   memArray+2         sta   ptr2+2         ldx   #^word1                  tmp4 := addr (word1 + 1)         lda   #word1         inc   A         bne   HDW3AA         inxHDW3AA   sta   tmp4         stx   tmp4+2;                                       doHDW3A    clc                              listStart += 5         lda   listStart         adc   #5         sta   listStart         stz   count                      count := 0         lda   nextEntry                  top   := nextEntry         sta   top         clc                              bottom := top + 4         adc   #4         sta   bottom         lda   #^visMembers               ptr3 := addr (visMembers [0])         sta   ptr3+2         lda   #visMembers         sta   ptr3;; Inner loop:  fill visMembers array with next group of 5 elements.;HDW3B    lda   count                      while (count < 5)         cmp   #5         blt   HDW3BB         brl   HDW3EHDW3BB   pea   0                            room for long result         pea   0         ph4   #word1                       dump english word         ph4   #word2                       dump phonetic translation         _DictDump         pla                                tmp := DictDump ( ... )         plx         sta   tmp         stx   tmp+2         lda   word1                        if (end-of-dict)         and   #$00FF                         /* null english word returned */         beq   HDW4A                          goto HDW4A         tax                                X := length (english word)         tay                                ptr3^.english := word1         iny         iny         short MHDW3AAA  lda   word1,X         sta   [ptr3],Y         dey         dex         bpl   HDW3AAA         long  M         lda   fndFlag                      if (fndFlag == true)         bne   HDW3D                          skip comparison         lda   englishSize                  compare new word to curr. dict entry         pha         lda   ptr+2         pha         lda   ptr         pha         lda   word1         and   #$00FF         pha         ph4   tmp4         jsr   CompareRtn         bpl   HDW3D                        if (current word > deleted word)         inc   fndFlag                        fndFlag := trueHDW3D    lda   nextEntry                    ptr3^.mem# := nextEntry         sta   [ptr3]         ldy   #4                           ptr2^.flag := 0         lda   #0         sta   [ptr2],Y         ldy   #5                           ptr2^.phoneticPtr := tmp         lda   tmp+2         sta   [ptr2],Y         iny         lda   tmp         sta   [ptr2],Y         inc   count                        count++         inc   nextEntry                    nextEntry++         clc                                ptr2++         lda   ptr2         adc   #8         sta   ptr2         lda   ptr2+2         adc   #0         sta   ptr2+2         clc                                ptr3++         lda   ptr3         adc   #35         sta   ptr3         lda   ptr3+2         adc   #0         sta   ptr3+2         brl   HDW3B                      end whileHDW3E    lda   fndFlag                  end do         bne   HDW4B         brl   HDW3A;; Handle encountering end of dictionary.;HDW4A    lda   nextEntry                listSize := nextEntry         sta   listSize         dec   A                        bottom := listSize - 1         sta   bottom         sec                            top := bottom - 4         sbc   #4         bpl   HDW4AA                   if (top < 0)         lda   #0                         top := 0HDW4AA   sta   top         inc   A                        listStart := top + 1         sta   listStart         pea   0                        reset dict. to top         _DictInit         stz   nextEntry;; Set visMember #s for elements in display.;HDW4B    stz   count                    count := 0         ldx   #0                       X     := 0HDW4C    lda   count                    while (count < 5)         cmp   #5         bge   HDW5         lda   visMembers,X               A := visMembers [X].mem#         bmi   HDW5                       if (A < 0);                                           goto HDW5         sta   ptr2                       ptr2 := addr (memArray [A])         stz   ptr2+2         ldy   #3HDW4D    asl   ptr2         rol   ptr2+2         dey         bne   HDW4D         clc         lda   ptr2         adc   memArray         sta   ptr2         lda   ptr2+2         adc   memArray+2         sta   ptr2+2         lda   count                      ptr2^.vis# := count         sta   [ptr2]         inc   count                      count++         clc                              X++         txa         adc   #35         tax         bra   HDW4C;; Now we're ready to recreate the control.;HDW5     pea   0                        room for long result         pea   0         lda   dictWindowPtr+2          window that own's control         pha         lda   dictWindowPtr         pha         pea   0                        will push pointer to template         ph4   #listTempl         _NewControl2         bcc   HDW5A                    handle error         plx                              throw away zero handle         plx         pea   ctlErr                      report error         jsr   HandleError         ph4   dictWindowPtr              close the dict window         _CloseWindow         rtsHDW5A    pla         sta   listCtlHndl         pla         sta   listCtlHndl+2         lda   #1                       indicate dict changed since last save         sta   dictChanged         rts         end************************************************** DictLoad - Handle loading new dictionary.**************************************************DictLoad start         using SIData         lda   #1                       only allowing dict file to be opened         jsr   DoOpen                   load in the new dictionary;; Recreate list control, since list has changed.;         ph4   listCtlHndl              dispose of current control         _HideControl         ph4   listCtlHndl         _DisposeControl         pea   0                        room for long result         pea   0         ph4   dictWindowPtr            window that own's control         pea   0                        will push pointer to template         ph4   #listTempl         _NewControl2         bcc   DL3                      handle error         plx                              throw away zero handle         plx         pea   ctlErr                      report error         jsr   HandleError         ph4   dictWindowPtr              close the dict window         _CloseWindow         stz   dictUpFlag         rtsDL3      pla         sta   listCtlHndl         pla         sta   listCtlHndl+2         stz   dictChanged         rts         end************************************************** DictSpeakWord - Speak phonetic dictionary entry.**************************************************DictSpeakWord start         using SIData;; Calculate pointer to phonetic representation.;         jsr   GetPhonBox         lda   #^phoneticSize         sta   ptr2+2         lda   #phoneticSize         inc   A         bne   HSW0         inc   ptr2+2HSW0     sta   ptr2         short M                        convert phonetic data area into         lda   phoneticSize               Pascal-style string         sta   [ptr2]         long  M         lda   volume+1                 SPEAK the string         and   #$00FF                     convert character into integer         sec         sbc   #$30         pha         lda   speed+1         and   #$00FF                     convert character into integer         sec         sbc   #$30         pha         lda   pitch+1         and   #$00FF                     convert character into integer         sec         sbc   #$30         pha         lda   ptr2+2                     address of string to SPEAK         pha         lda   ptr2         pha         lda   maleVoice         beq   HSW1         _MaleSpeak                       call male or female speech, as         bra   HSW2                         appropriateHSW1     _FemaleSpeakHSW2     lda   #0                       restore high byte of word size field         short M         sta   [ptr2]         long  M         rts         end************************************************** DictSave - Save current dictionary to disk.**************************************************DictSave start         using SIData;; Set globals for front window.;         lda   #dictWindNum         sta   currWindNum         lda   #dictTyp         sta   currWindTyp         lda   dictWindowPtr         sta   currWindow         lda   dictWindowPtr+2         sta   currWindow+2         lda   #dictIndex2         sta   currIndex2         lda   #dictIndex4         sta   currIndex4;; Get default filename to use in SFO dialog.;         lda   dictFileFlag             if dict. assoc. with file, use filename         beq   DSD2         ldx   dictName2Size         stx   saveName2         ldy   #0         short MDSD0     lda   dictName2,Y         sta   saveName2+2,Y         iny         dex         bne   DSD0DSD1     long  M;; Bring up SFO dialog to get pathname of file to receive dictionary, then; initialize the file.;DSD2     jsr   DSA0         bcs   Rts         stz   dictChangedRts      rts         end************************************************** DoAbout - Handle About command.**************************************************DoAbout  start         using SIData         pea   0                        room for dialog ptr         pea   0         ph4   #aboutDlg                pointer to the About dialog         _GetNewModalDialog             create the modal dialog         bcc   DA1                      handle error         plx         plx         pea   windErr         jsr   HandleError         rtsDA1      pea   0                        room for result         ph4   #0                       standard filter procedure         _ModalDialog                   let Dialog Manager handle events         bcc   DA2         plx                            pull item hit off stack         plx                            pull dialog pointer from stack         plx         brl   FatalErr                 only error is front window not modal dlgDA2      pla                            can throw away item hit value         _CloseDialog                   dialog pointer left on stack from;                                         GetNewModalDialog call         rts         end************************************************** DoActivate - Handle dictionary activate command.**************************************************DoActivate start         using SIData         lda   dActiveFlag              toggle dict active flag         eor   #$FFFF         sta   dActiveFlag         beq   Deact         pea   1                        activate dictionary; change message         ph4   #inactiveMsg               they can next deactivate dict         bra   DA1Deact    pea   0                        deactivate dictionary; change message         ph4   #activeMsg                 they can next activate dictDA1      pea   activeID         _SetMItemName         _DictActivate         rts         end************************************************** DoClose - Handle Close command.** Output:*        carry flag - set if Cancel in save dialog*                     chosen; clear otherwise**************************************************DoClose  start         using SIData         jsr   MyWindow                 ensure it's one of our windows, and if         bcs   DC0                       so, get indices into window arrays         clc         rtsDC0      lda   currWindTyp              if closing dictionary window, can't         cmp   #dictTyp                   necessarily open a new window         beq   DC1                        necessarily open a new window;;  Check if they want to save data before closing window.;         ldx   currIndex4         lda   teHandle,X               get ready to dereference text edit         sta   handle                     record's handle         lda   teHandle+2,X         sta   handle+2         lda   [handle]                 dereference the handle         sta   ptr         ldy   #2         lda   [handle],Y         sta   ptr+2         ldy   #dirtyOffset             check dirty bit in text edit record         lda   [ptr],Y         and   #isDirty         beq   DC1A         jsr   WantToSave               file has changed -- ask if they want to         bcc   DC1A                       save changes; check Cancel         rtsDC1A     dec   userWindows              one less user window up         ph2   #newID                   can now create new window         _EnableMItem         ph2   #openID                  can now open a file         _EnableMItemDC1      lda   currWindow+2             close the window -- they're done with it         pha         lda   currWindow         pha         _CloseWindow         dec   numWindows               one less window open;;  If window allocated by Open command, free memory used by it.;         ldx   currIndex2         stz   windUpFlag,X         lda   currWindTyp         cmp   #dictTyp         beq   Rts         lda   windFileFlag,X         bne   DC2Rts      clc         rtsDC2      stz   windFileFlag,X         ldx   currIndex4         lda   pathHandle+2,X         ora   pathHandle         beq   Rts         lda   pathHandle+2,X         pha         lda   pathHandle,X         pha         _DisposeHandle         bra   Rts         end************************************************** DoDict - Bring up dictionary editor.**************************************************DoDict   start         using SIData;; First determine whether the window is up or not.;         lda   dictUpFlag               if (not (dictUpFlag))         beq   DD2                        create dict window         jsr   MyWindow                 else if (front window not ours)         bcs   DD0                        exit         rtsDD0      lda   currWindTyp              else if (front window is dict)         cmp   #dictTyp                   close it         bne   DD1         jsr   DoClose         rts                              exitDD1      lda   dictWindowPtr+2          else         sta   currWindow+2               set curr window vars to dict window         pha         lda   dictWindowPtr         sta   currWindow         pha         _SelectWindow                    bring dict window to front         lda   #dictIndex2                2-byte offset into window arrays         sta   currIndex2         lda   #dictIndex4                4-byte offset into window arrays         sta   currIndex4         lda   #dictWindNum               window #         sta   currWindNum         lda   #dictTyp                   window type         sta   currWindTyp         rts                              exit;; Window creation routine.;DD2      pea   0                          long result         pea   0         pea   0                          no title         pea   0         pea   dictTyp                    refCon:  hi word = window type         pea   dictWindNum                         lo word = window number         pea   0                          no content-draw routine         pea   0         pea   0                          standard defProc routine         pea   0         pea   2                          paramlist is resource         pea   0                          resource ID for dict window         pea   dictWindID         pea   $800E                      resource type = rWindParam1         _NewWindow2         bcc   DD2A                       handle err returned by NewWindow2 call         plx                              pull nil off stack         plx         pea   windErr         jsr   HandleError         rtsDD2A     pla                            get window pointer         sta   dictWindowPtr         sta   currWindow         pla         sta   dictWindowPtr+2         sta   currWindow+2;; Add controls to dictionary window.  Filename and list are from templates.;         pea   0                        room for long result         pea   0         lda   dictWindowPtr+2          window that owns control         pha         lda   dictWindowPtr         pha         pea   0                        will push pointer to template         ph4   #fnTempl                 pointer to template         _NewControl2         bcc   DD2B                     report any error, but keep going         pea   ctlErr         jsr   HandleErrorDD2B     pla                            pull control handle from stack         ply         sta   fnCtlHndl         sty   fnCtlHndl+2         pea   0                        room for long result         pea   0         ph4   dictWindowPtr            window that owns control         pea   0                        will push pointer to template         ph4   #listTempl               pointer to template         _NewControl2         bcc   DD2C                     report any error, but keep going         pea   ctlErr         jsr   HandleErrorDD2C     pla                            pull control handle from stack         ply         sta   listCtlHndl         sty   listCtlHndl+2;; The other controls are in the resource fork.;         ldx   #0         lda   #dictCtlID         sta   countDD2D     cpx   #64                      check end of control list         beq   DD2F         phx                            save index         pea   0                        room for long result         pea   0         ph4   dictWindowPtr            window that owns control         pea   2                        will push resource ID         pea   0         lda   count                    resource ID         pha         _NewControl2         bcc   DD2E                     report any error, but keep going         pea   ctlErr         jsr   HandleErrorDD2E     pla                            pull control handle from stack         ply         plx                            pull index from stack         sta   firstRsrcHndl,X         tya         sta   firstRsrcHndl+2,X         inc   count                    resource ID++         inx         inx         inx         inx         bra   DD2D;; Finish setting dictionary window's variables.;DD2F     lda   #dictIndex2              2-byte offset into window arrays         sta   currIndex2         lda   #dictIndex4              4-byte offset into window arrays         sta   currIndex4         lda   #dictWindNum             window #         sta   currWindNum         lda   #dictTyp                 window type         sta   currWindTyp         lda   #1                       set flag that dict window is up         sta   dictUpFlag         inc   numWindows               one more window up         rts         end************************************************** DoNew - Create new text window.**************************************************DoNew    start         using SIData         jsr   InitWindow               initialize window data structures         bcs   Rts         jsr   SetTextWName             create window's title         lda   #textTyp                 set window's type         sta   wRefCon+2         sta   currWindTyp         jsr   CreateWindow             create new window on desktop         bcs   Rts         ldx   currIndex2               set flag that window not assoc. with file         stz   windFileFlag,X         jsr   FiniWindow               disable Open, New commands, if necessaryRts      rts         end************************************************** DoOpen - Handle Open command.** Input:*        A - # of filetypes allowed in SFO open dialog**************************************************DoOpen   start         using SIData;;  Make SFGetFile2 call to bring up SFO Open dialog and get filename and;  pathname of file to open.;         sta   numEntries         pea   20                       upper left corner X-coord of SFGetFile2's dialog         pea   20                       upper left corner Y-coord of SFGetFile2's dialog         pea   0                        prompt is pointer to P-string         ph4   #openMsg                 pointer to prompt         ph4   #0                       no filter procedure         ph4   #openTypes               fileTypes, auxTypes of files to open         ph4   #replyRecord         _SFGetFile2         bcc   DO1                      handle error         pea   SFOErr         jsr   HandleError         rtsDO1      lda   rrGood                   Does user want to open a file?         bne   DO2         rts;; If user opened a dictionary file, call OpenDict and exit.;DO2      lda   rrFileType         cmp   #dictFileType         bne   DO2A         jsr   OpenDict         rts;; Set window type, window number based on file selected.;DO2A     jsr   InitWindow               initialize window data structures         bcc   DO2B         brl   Err3DO2B     lda   rrFileType         cmp   #phonFileType         bne   DO2C         lda   #phonTyp         sta   currWindTyp         sta   wRefCon+2         bra   DO3DO2C     lda   #textTyp         sta   currWindTyp         sta   wRefCon+2;; Open the file, read it into a buffer, and then close the file.;DO3      ldx   currIndex4               get offset into pathHandle array         lda   rrPathRef         sta   pathHandle,X         sta   handle                   get ready to dereference the handle         lda   rrPathRef+2         sta   pathHandle+2,X         sta   handle+2         ldy   #2                       dereference the handle         lda   [handle],Y         sta   openPath+2         lda   [handle]                 need to skip total length byte of GS/OS         clc                              output string         adc   #2         sta   openPath         bcc   DO3A         inc   openPath+2DO3A     _OpenGS  openRec               open the file         bcc   DO3B                     handle error         pea   openErr         jsr   HandleError         brl   Err3DO3B     lda   openRef                  get ready to read and then close the file         sta   readRef         sta   closeRef;; If the file is empty, close the file and skip loading it.;         lda   openSize         ora   openSize+2         bne   DO5         _CloseGS closeRec         jsr   SetFileWName         jsr   CreateWindow         bcc   DO4         brl   Err3DO4      jsr   FiniWindow         brl   DO6;; If the file is not empty, allocate a read buffer, read and then close the; file.  Load the file into a window.;DO5      ph4   #0                       allocate memory block to read files         ph4   openSize                 read in the whole thing         ph2   myID         pea   $C010                    locked, can't move, don't purge, don't;                                         cross bank bound., don't page align         ph4   #0                       no absolute address specified         _NewHandle         bcc   DO5A                     handle error:         plx                              throw away zero handle         plx         pea   memErr         jsr   HandleError         _CloseGS  closeRec         brl   Err3DO5A     pla         sta   handle                   get ready to dereference the handle         pla         sta   handle+2         lda   [handle]                 dereference memory handle         sta   readBuffer         ldy   #2         lda   [handle],Y         sta   readBuffer+2         lda   openSize                 get # bytes to read         sta   readRequest         lda   openSize+2         sta   readRequest+2         _ReadGS  readRec               make the Read call         php                            save error flag from read         _CloseGS closeRec         plp         bcc   DO5B                     handle error         pea   readErr         jsr   HandleError         brl   Err2DO5B     jsr   SetFileWName         jsr   CreateWindow         bcc   DO5C         brl   Err2DO5C     jsr   FiniWindow         pea   $0005                    text descriptor:  text is raw data         ph4   readBuffer               pointer to data         ph4   transferCount            size of data         pea   0                        style ref is pointer         ph4   #0                       not really passing any style reference         ph4   #0                       use currently active TE control         _TESetText         bcc   DO5D                     handle error         pea   TEErr         jsr   HandleError         brl   Err1DO5D     lda   handle+2         pha         lda   handle         pha         _DisposeHandle;; Perform final clean-up.;DO6      ldx   currIndex2               set window upFlag         lda   #1         sta   windUpFlag,X         sta   windFileFlag,X           set window fileFlag         ldx   currIndex4               set window's pathName         lda   openPath         sta   pathName,X         lda   openPath+2         sta   pathName+2,X         lda   rrPathRef                set window's pathHandle         sta   pathHandle,X         lda   rrPathRef+2         sta   pathHandle+2,X         rts;; Error clean-up.;Err1     jsr   DoCloseErr2     lda   handle+2         pha         lda   handle         pha         _DisposeHandleErr3     ph4   rrPathRef         _DisposeHandle         ph4   rrNameRef         _DisposeHandle         ldx   currIndex4         stz   pathName,X         stz   pathName+2,X         stz   pathHandle,X         stz   pathHandle+2,X         rts         end************************************************** DoPrint - Handle Print command.**************************************************DoPrint  start         using SIDataprPort       equ   50                   Print Manager's grafPortcurrLine     equ   54                   current page # to printlastLine     equ   58                   last page # to printcopies       equ   62                   # copies of document to printfirstPage    equ   66                   first page to begin printingspool        equ   70                   0 = draft mode; 1 = spooled printingfinalPage    equ   74                   final page to printjobOffset    equ   $0050                offset from beginning of print record;                                         to prJob subrecordrPageOffset  equ   $0008                offset from beginning of print record;                                         to rPage field in prInfo subrecord         jsr   MyWindow                 printing one of our windows?         bcs   DP1         rtsDP1      pea   0                        room for integer result         ph4   prHandle         _PrJobDialog                   bring up print job dialog         bcc   DP2                      handle error         plx         pea   printErr         jsr   HandleError         rtsDP2      pla                            get dialog result         bne   DP3                      Do they want to print?         rtsDP3      lda   prHandle                 dereference print record handle         sta   handle         lda   prHandle+2         sta   handle+2         lda   [handle]         sta   ptr         ldy   #2         lda   [handle],Y         sta   ptr+2         ldy   #rPageOffset             set page rectangle size         lda   [ptr],Y                    h1         sta   prRect         iny                              v1         iny         lda   [ptr],Y         sta   prRect+2         iny                              h2         iny         lda   [ptr],Y         sta   prRect+4         iny                              v2         iny         lda   [ptr],Y         sta   prRect+6         ldy   #jobOffset               get first page # to print         lda   [ptr],Y         sta   firstPage                record this page for use later         dec   A         phy         pea   0                        multiply by 60 to get 1st line #         pea   0         pha         pea   60         _Multiply         pla         sta   currLine         pla         sta   currLine+2         ply                            set page # to 1 for Print Manager         lda   #1         sta   [ptr],Y         iny                            get last page # to print         iny         lda   [ptr],Y         sta   finalPage                record this page for use later         phy         pea   0                        multiply by 60 to get last line #         pea   0         pha         pea   60         _Multiply         pla         sta   lastLine         pla         sta   lastLine+2         ply         lda   finalPage                get final page # to pass to Print Mgr         sec         sbc   firstPage         bpl   DP3A                     ensure start page # less than end page #         rtsDP3A     inc   A         sta   [ptr],Y         iny                            get # copies to print         iny         lda   [ptr],Y         sta   copies         lda   currLine                 remember starting line # in case of         sta   firstPage                  multiple copies in draft mode         stz   spool                    assume draft printing         iny         lda   [ptr],Y         and   #$FF00                   mode is a byte value         beq   DP3B         inc   spool;; Ensure requested line # is in document.;DP3B     lda   currWindTyp         cmp   #dictTyp         bne   DP3C         lda   listSize                 for dict, # lines in document =         bra   DP3E                       # entries in dictDP3C     ph4   #textInfo                for text window, call TEGetTextInfo to         pea   2                          find out # lines in document         ldx   currIndex4         lda   teHandle+2,X         pha         lda   teHandle,X         pha         _TEGetTextInfo         bcc   DP3D                     handle error         pea   TEErr         jsr   HandleError         rtsDP3D     lda   lineCount                # lines in document > 1st line to print?DP3E     cmp   currLine         bge   DP4         rts;; If we're printing the dictionary, we'll need to position it at first entry; to print.;DP4      lda   currWindTyp         cmp   #dictTyp         bne   Top0         lda   nextEntry         cmp   currLine         beq   Top0         blt   DP4A         pea   0         _DictInit         stz   nextEntryDP4A     lda   nextEntry         cmp   currLine         beq   Top0         pea   0         pea   0         ph4   #word1         ph4   #word2         _DictDump         pla         pla         lda   word1         and   #$00FF         bne   DP4B         rtsDP4B     inc   nextEntry         bra   DP4A;;  Call Print Manager to open the document for printing.;Top0     pea   0                        room for long result         pea   0         ph4   prHandle                 print record handle         pea   0                        let Print Manager allocate & init.         pea   0                          new grafPort         _PrOpenDoc                     handle error         bcc   DP4C         plx         plx         pea   printErr         jsr   HandleError         brl   DP12                       reset port and exitDP4C     pla                            record Print Manager's grafPort         sta   prPort         pla         sta   prPort+2;;  Print loop.;;  Get ready to print the next page.;Top1     lda   prPort+2                 Print Manager's grafPort         pha         lda   prPort         pha         pea   0                        no scaling rect.         pea   0         _PrOpenPage         bcc   DP5                      handle error         pea   printErr         jsr   HandleError         brl   DP9                        close the document, clean up, exitDP5      _PenNormal                     set pen to standard state         pea   0                        move to top left corner of drawing         pea   0                          rectangle         _MoveTo;; If printing dictionary, we need to paint the next 60 entries.;         lda   currWindTyp         cmp   #dictTyp         jne   DP5D         stz   count                    loop counter         lda   #10                      horizontal offset into page         sta   tmp4DP5A     lda   count                    for (count = 0; count < 60; count++)         cmp   #60         blt   DP5B         brl   DP7DP5B     pea   0                          (X,A) := DictDump (word1, word2)         pea   0         ph4   #word1         ph4   #word2         _DictDump         pla         plx         lda   word1                      if (end-of-dict) then         and   #$00FF         bne   DP5C         lda   #$FFFF                       currLine := end-of-document flag         sta   currLine         pea   0                            reset dict to top         _DictInit         stz   nextEntry         brl   DP7                          goto DP7DP5C     pea   10                         else         lda   tmp4                         MoveTo (10, tmp4)         pha         _MoveTo         ph4   #word1                       write English word         _DrawString         pea   170                          MoveTo (170, tmp4)         lda   tmp4         pha         _MoveTo         ph4   #word2                       write phonetic word         _DrawString         inc   nextEntry                  nextEntry++         inc   count                      count++         inc   currLine                   currLine++         clc                              tmp4 += 10         lda   tmp4         adc   #10         sta   tmp4         brl   DP5A;; If window is text, call TEPaintText to draw text into Print Manager's; grafPort.;DP5D     pea   0                        room for long result         pea   0         lda   prPort+2                 Print Manager's printing port         pha         lda   prPort         pha         lda   currLine+2               page # to start printing         pha         lda   currLine         pha         ph4   #prRect                  pointer to rectangle defining one page         pea   0                        don't clip the last line on page         ldx   currIndex4               use current TE record         lda   teHandle+2,X         pha         lda   teHandle,X         pha         _TEPaintText         bcc   DP6                      handle error:         cmp   #$2209                     error = "Thru printing" ?         beq   DP6                        yes - continue         plx         plx         pea   printErr                       no - report error then close page         jsr   HandleError         lda   #-1         sta   currLine         bra   DP7DP6      pla                            returns -1 when all is printed         sta   currLine         plx                            throw away high word - can't print over;                                         32,767 pagesDP7      lda   prPort+2                 close this page         pha         lda   prPort         pha         _PrClosePage         bcc   DP8                      handle error         pea   printErr         jsr   HandleError         bra   DP9DP8      lda   currLine                 move on to next page to print         cmp   #$FFFF                   check if we're finished printing         beq   DP9         cmp   lastLine         bgt   DP9         brl   Top1DP9      lda   prPort+2                 close this document for printing         pha         lda   prPort         pha         _PrCloseDoc         bcc   DP10                     handle error         pea   printErr         jsr   HandleError         bra   DP12;;  Need to print multiple copies?;DP10     lda   spool                    if spooled printing, it handles the         bne   DP11                       copies         dec   copies                   print copies of this document         beq   DP12         lda   firstPage         sta   currLine         brl   DP4;;  Handle spooled printing here.;DP11     ph4   prHandle                 call PrPicFile to do spooled printing         ph4   #0                       let Print Manager alloc. new grafPort         pea   0                        nil for prStatusRec         pea   0;        ph4   #prStatusRec         _PrPicFile         bcc   DP12                     handle error         pea   printErr         jsr   HandleErrorDP12     lda   currWindow+2             restore the original grafPort         pha         lda   currWindow         pha         _SetPort         rts         end************************************************** DoPSetUp - Handle Page setUp command.**************************************************DoPSetUp start         using SIData         pea   0                        room for integer result         ph4   prHandle         _PrStlDialog                   bring up print style dialog         bcc   OK                       handle error         plx         pea   printErr         jsr   HandleError         rtsOK       pla                            throw away result - Print Manager;                                         handles it all         rts         end************************************************** DoQuit - Handle Quit command.**************************************************DoQuit   start         using SIData;; Check need to save dictionary.;         lda   dictChanged              before clearing dict., check if user         beq   Top1                       wants to save current dictionary         jsr   WantToSaveDict         bcc   Top1                     check if user selected Cancel         rts;; Loop to close all open windows.;Top1     lda   numWindows         beq   Out         jsr   DoClose                  give chance to cancel         bcc   Top1         rtsOut      inc   done                     set the done flag         rts         end************************************************** DoSave - Handle Save command.**************************************************DoSave   start         using SIData         jsr   MyWindow         bcs   DS1         rtsDS1      entry         ldx   currIndex2               check if a new file - goto Save as         lda   windFileFlag,X         jeq   DSA0;; Open the file and set its length to zero.;         ldx   currIndex4               get file's pathname for delete, create,         lda   pathName,X                 and open operations         sta   openPath         lda   pathName+2,X         sta   openPath+2         _OpenGS openRec                open the old file         bcc   DS2         pea   openErr         jsr   HandleError         rtsDS2      lda   openRef                  get file's ref. # for other operations         sta   setEOFRef         sta   writeRef         sta   closeRef         _SetEOFGS setEOFRec            set file's size to 0         bcc   DS3         pea   zeroErr         jsr   HandleError         rts;; Call appropriate routine to write file to disk, based on file's type.;DS3      lda   currWindTyp         cmp   #dictTyp         bne   DS3A         jsr   WriteDictFile         rtsDS3A     jsr   WriteTextFile         rts         end************************************************** DoSaveAs - Handle Save as command.**************************************************DoSaveAs start         using SIData         jsr   MyWindow         bcs   DSA0         rts;;  Make SFPutFile2 call to bring up SFO Save dialog and get filename and;  pathname of file to create, open, and then write.;DSA0     entry         pea   20                       upper left corner X-coord of SFGetFile2's dialog         pea   20                       upper left corner Y-coord of SFGetFile2's dialog         pea   0                        prompt is pointer to P-string         ph4   #saveMsg                 pointer to prompt         pea   0                        default name is pointer         lda   currWindTyp              if saving dict., use appropriate default         cmp   #dictTyp                   name         bne   DSA0C         lda   dictFileFlag         beq   DSA0B         ph4   #saveName2         bra   DSA0DDSA0B    ph4   #saveName1         bra   DSA0DDSA0C    ph4   #saveName                pointer to GS/OS input stringDSA0D    ph4   #replyRecord         _SFPutFile2         bcc   DSA1                     handle error         pea   SFOErrError    jsr   HandleError         sec         rtsDSA1     lda   rrGood                   Does user want to open a file?         bne   DSA2         sec         rts;;  Fill in GS/OS parameter block fields.;DSA2     lda   rrPathRef                dereference path handle         sta   handle         lda   rrPathRef+2         sta   handle+2         ldy   #2                       call GetFileInfo to see if file exists         lda   [handle],Y         sta   GFIPath+2         lda   [handle]                 skip buffer length in GS/OS output string         clc         adc   #2         sta   GFIPath         sta   destroyPath         sta   createPath         sta   openPath         ldx   currIndex4         sta   pathName,X         lda   GFIPath+2         adc   #0         sta   GFIPath+2         sta   destroyPath+2         sta   createPath+2         sta   openPath+2         sta   pathName+2,X         _GetFileInfoGS  getFileInfoRec         bcc   DSA3                     No error - file should be deleted         cmp   #$0046                   File not found error?         beq   DSA4                     Yes - skip deletion         pea   fileErr                     No - report error and exit         bra   ErrorDSA3     _DestroyGS  destroyRec         File exists -- overwrite it         bcc   DSA4         pea   delErr                    err msg = "Error when deleting file."         bra   ErrorDSA4     lda   currWindTyp              set new file's type         beq   DSA4A         cmp   #phonTyp         beq   DSA4B         lda   #$F2                     dict filetype         bra   DSA4CDSA4A    lda   #$04                     ASCII text file         bra   DSA4CDSA4B    lda   #$F1                     phonetics fileDSA4C    sta   createTyp         _CreateGS  createRec           File not found error -- create new one         bcc   DSA5         pea   createErr                    err msg = "Error when creating file."         brl   ErrorDSA5     _OpenGS  openRec               open the file         bcc   DSA6         pea   openErr                     err msg = "Error when opening file."         brl   ErrorDSA6     lda   openRef         sta   writeRef         sta   closeRef         ldx   currIndex2               check if old file & need to release its         lda   windFileFlag,X             memory handle & save new path handle         beq   DSA7         ldx   currIndex4         lda   pathHandle+2,X         ora   pathHandle,X         beq   DSA7         lda   pathHandle+2,X         pha         lda   pathHandle,X         pha         _DisposeHandle         stz   pathHandle+2,X         stz   pathHandle,XDSA7     ldx   currIndex4               save new path handle for file         lda   rrPathRef         sta   pathHandle,X         lda   rrPathRef+2         sta   pathHandle+2,X         lda   currWindTyp         cmp   #dictTyp         bne   DSA8         jsr   WriteDictFile         bcc   DSA7ARts1     rtsDSA7A    jsr   SetDictName         bra   DSA9DSA8     jsr   WriteTextFile         bcs   Rts1         jsr   SetFileWName             get opened file's name to put in window         ph4   wTitle                   change window's title         lda   currWindow+2         pha         lda   currWindow         pha         _SetWTitleDSA9     ldx   currIndex2               record that window comes from file         lda   #1         sta   windFileFlag,X         rts         end************************************************** DoSetParameters - Set global speech parameters.**************************************************DoSetParameters start         using SIDatasavMale   equ   52                      original maleVoice value, in case of CancelsavFemale equ   54                      original femaleVoice valuesavBass   equ   56                      original bass valuesavTreble equ   58                      original treble valuesavPitch  equ   60                      original pitch valuesavSpeed  equ   62                      original speed valuesavVolume equ   64                      original volume valueitem2     equ   66                      if radio button, other item to togglevalue2    equ   68                      if radio button, other item's value;; Create the Set Parameters dialog box.;         pea   0                        long result         pea   0         ph4   #setParmsDlg             pointer to dialog template         _GetNewModalDialog         bcc   DSP1                     handle error         plx         plx         pea   windErr         jsr   HandleError         rtsDSP1     lda   1,S                      record dialog's grafPort pointer         sta   setParmsPtr         lda   3,S         sta   setParmsPtr+2;; Save the original parameter values, in case user decides to cancel.;         lda   maleVoice         sta   savMale         lda   femaleVoice         sta   savFemale         lda   bass         sta   savBass         lda   treble         sta   savTreble         lda   pitch         sta   savPitch         lda   speed         sta   savSpeed         lda   volume         sta   savVolume;; Call Dialog Manager to get item selected, then handle appropriately.;DSP2     pea   0                        integer result         ph4   #0                       use standard filter procedure         _ModalDialog         bcc   DSP3         plx         brl   FatalErr                 only possible error is not modal dialogDSP3     pla                            get item hit         sta   itemHit;; Based on item selected, handle appropriately.;         cmp   #1                       OK button selected?         bne   DSP8         lda   maleVoice                Yes - set global speech parameters         beq   DSP4                       set voice gender         lda   #0         bra   DSP5DSP4     lda   #1DSP5     pha         lda   bass                       set tone type         beq   DSP6         lda   #0         pha         bra   DSP7DSP6     lda   #1         phaDSP7     lda   pitch+1                    set pitch         and   #$00FF                     convert 1-byte character to integer         sec         sbc   #$30         pha         lda   speed+1                    set speed         and   #$00FF                     convert 1-byte character to integer         sec         sbc   #$30         pha         lda   volume+1                   set volume         and   #$00FF                     convert 1-byte character to integer         sec         sbc   #$30         pha         _SetSayGlobalsRts      _CloseDialog                   dialog's grafPort pointer still on stack         rts;; If Cancel button selected, we'll need to restore original values.;DSP8     cmp   #2         bne   DSP9         lda   savMale         sta   maleVoice         lda   savFemale         sta   femaleVoice         lda   savBass         sta   bass         lda   savTreble         sta   treble         lda   savPitch         sta   pitch         lda   savSpeed         sta   speed         lda   savVolume         sta   volume         bra   Rts;; If item selected is a radio button, we'll need to set the selected button; and then clear its family member.;DSP9     ldx   #1         cmp   #3                       Male voice radio button?         bne   DSP10         stx   maleVoice                Yes - set male, clear female voices         stz   femaleVoice         phx         lda   #4         sta   item2         bra   ToggleDSP10    cmp   #4                       Female voice radio button?         bne   DSP11         stx   femaleVoice              Yes - set female, clear male voices         stz   maleVoice         phx         lda   #3         sta   item2Toggle   ph4   setParmsPtr              toggle selected button         lda   itemHit         pha         _SetDItemValue         bcc   T1                       handle error         pea   dlgErr         jsr   HandleError         bra   RtsT1       pea   0         ph4   setParmsPtr         lda   item2         pha         _SetDItemValue         bcc   T2                       handle error         pea   dlgErr         jsr   HandleError         brl   RtsT2       brl   DSP2DSP11    cmp   #6                       Treble tone radio button?         bne   DSP12         stx   treble                   Yes - set treble, clear bass tones         stz   bass         phx         lda   #7         sta   item2         bra   ToggleDSP12    cmp   #7                       Bass tone radio button?         bne   DSP13         stx   bass                     Yes - set bass, clear treble tones         stz   treble         phx         lda   #6         sta   item2         bra   Toggle;; The last 3 items are edit-line boxes.;DSP13    ph4   setParmsPtr              get current text from edit-line box         lda   itemHit         pha         ph4   #tmp4         _GetIText         bcc   DSP14                    handle error         pea   dlgErr         jsr   HandleError         brl   RtsDSP14    lda   tmp4+1                   check value is between '0' and '9'         and   #$00FF         cmp   #'0'         blt   Err         cmp   #':'         bge   Err         ldx   tmp4                     text is OK - change it         lda   itemHit         cmp   #8                       if pitch item, save new pitch value         bne   DSP15         stx   pitch         brl   DSP2DSP15    cmp   #9                       if speed item, save new speed value         bne   DSP16         stx   speed         brl   DSP2DSP16    stx   volume                   must be volume item         brl   DSP2;; To handle errors in edit-line boxes, bring up an error alert, select the; offensive text, then have user reenter the text.;Err      pea   0                        room for result         ph4   #pErrorAlert             address of alert template         ph4   #0                       use default filter procedure         _CautionAlert         pla                            get item hit         ph4   setParmsPtr         lda   itemHit         pha         pea   0         pea   1         _SelectIText         brl   DSP2         end************************************************** DoShowPhonetics - Convert English text to phonetics.**************************************************DoShowPhonetics start         using SIData;; Check all abort conditions.;         jsr   MyWindow                 front window ours?         bcs   DSP0Rts0     rtsDSP0     lda   currWindTyp              if the front window = phonetics, just         cmp   #phonTyp                   return         beq   Rts0         cmp   #dictTyp                 if front window = dictionary, just         bne   DSP0A                      return         jsr   DictConvertWord         rtsDSP0A    lda   userWindows              ensure we can open 1 more window         cmp   #10                        to hold phonetic translation         beq   Rts0         jsr   GetText                  dump English text into our buffer         bcs   Rts0                     just return if unable to get text         ph4   phBuffer                 ensure integrity of phonetics buffer         _HLock         bcs   DSP0B                    if can't lock buffer, try to allocate;                                         a new one         cmp4  phBuffSize,#1024         else if block size < 1K, attempt         bge   DSPOK                      to grow it         ph4   #1024         ph4   phBuffer         _SetHandleSize         bcc   DSP0D         bcs   DSP0BBDSP0B    pea   0         pea   0         ph4   #1024         ph2   myID         pea   $8010         pea   0         pea   0         _NewHandle         bcc   DSP0C         plx                            pull empty handle from stack         plxDSP0BB   pea   memErr         jsr   HandleError         rtsDSP0C    pl4   phBufferDSP0D    lda   #1024         sta   phBuffSize;; Call Text Edit's GetSelection to get starting/ending offsets for current; selection.;DSPOK    ph4   #selStart         ph4   #selEnd         ldx   currIndex4         lda   teHandle+2,X         pha         lda   teHandle,X         pha         _TEGetSelection         bcc   DSP1                     handle error         pea   TEErr         jsr   HandleError         rts;; If there is no current selection, we assume user wants to convert the entire; text window to phonetics.  In this case, we set start of selection to 0, end; of selection to end of text.;DSP1     cmp4  selStart,selEnd         bne   DSP2         stz   selStart         stz   selStart+2         lda   charCount         sta   selEnd         lda   charCount+2         sta   selEnd+2;; Get the pointer to the text from the buffer handle, adjusting pointer to the; start of the selection.;DSP2     dec4  selEnd                   end is always 1 more than it should be         lda   buffer                   put handle into DP location         sta   handle         lda   buffer+2         sta   handle+2         lda   [handle]                 dereference handle         sta   ptr         ldy   #2         lda   [handle],Y         sta   ptr+2         clc                            add starting offset to pointer         lda   ptr         adc   selStart         sta   ptr         lda   ptr+2         adc   selStart+2         sta   ptr+2DSP3     stz   tmp4                     we'll use tmp4 to track size of         stz   tmp4+2                     phonetics;; Get the pointer to the phonetics buffer from its handle.;         lda   phBuffer                 put handle into DP location         sta   handle2         lda   phBuffer+2         sta   handle2+2         lda   [handle2]                dereference handle         sta   ptr2         ldy   #2         lda   [handle2],Y         sta   ptr2+2         inc   ptr2                     1st byte is for length byte of 1st         bne   DSP4                       phonetic string, in DoSpeakPhonetics         inc   ptr2+2;; Now we're ready to enter our PARSE loop.  As long as the text to be parsed; exceeds 255 characters (PARSE accepts 2 Pascal-style strings), we need to; "doctor" the string to parse.;DSP4     sub4  selEnd,selStart,selLength        get length of text to be         inc4  selLength                          parsed         cmp4  selLength,#0             if length of string = 0, we're done         jeq   DSP14         bpl   DSP5         brl   DSP14DSP5     cmp4  selLength,#256           ensure length doesn't exceed 255 chars.         blt   DSP6         lda   #255         sta   selLength         stz   selLength+2DSP6     short M         lda   selLength                stuff length byte into beginning         sta   sayLength                  of string to speak         ldy   selLength                move string to PARSE from buffer to         dey                              SAY stringTop1     lda   [ptr],Y         sta   sayString,Y         dey         bpl   Top1         long  M;; PARSE the string.;         lda   #0                       we'll start parsing at beginning         sta   phStartDSP7     lda   #255                     length of phonetics string = 255         sta   phLength         inc   phStart         pea   0                        integer result         ph4   #sayLength               pointer to English string to PARSE         ph4   #phLength                pointer to string to hold phonetics         ph2   phStart                  place in English string to begin         _Parse         pla                            get # characters converted         sta   phStart;; Move phonetics string to buffer.  First check if buffer is large enough;; if not, attempt to allocate a bigger buffer.;         lda   tmp4                     save current size of text         sta   tmp         lda   tmp4+2         sta   tmp+2         lda   phLength                 update size of all phonetics created         and   #$00FF         clc         adc   tmp4         bcc   DSP8         inc   tmp4+2DSP8     sta   tmp4         cmp4  phBuffSize,tmp4          check that buffer is large enough         bge   DSP11         ldy   #4                       unlock the block so MM can move it         lda   [handle2],Y         and   #$7FFF         sta   [handle2],Y         add4  phBuffSize,#1024         grow by 1K increments         ph4   phBuffSize         ph4   phBuffer         _SetHandleSize         bcc   DSP9                     handle error         pea   memErr         jsr   HandleError         rtsDSP9     lda   phBuffer                 place the buffer's handle into DP area         sta   handle2         lda   phBuffer+2         sta   handle2+2         ldy   #4                       lock the block         lda   [handle2],Y         ora   #$8000         sta   [handle2],Y         lda   [handle2]                dereference the handle         sta   ptr2         ldy   #2         lda   [handle2],Y         sta   ptr2+2         lda   ptr2+2                   adjust pointer for text already in buffer         clc         adc   tmp+2         sta   ptr2+2         lda   ptr2         clc         adc   tmp         bcc   DSP10         inc   ptr2+2DSP10    sta   ptr2DSP11    lda   phLength                 move phonetic string to buffer         and   #$00FF         pha         tax         dex         ldy   #0         short MTop2     lda   phString,Y         sta   [ptr2],Y         iny         dex         bpl   Top2         long  M         pla                            update pointer into phonetics buffer         clc         adc   ptr2         bcc   DSP12         inc   ptr2+2DSP12    sta   ptr2         lda   sayLength                check if we converted all of the chars.         and   #$00FF                   clear byte after length byte         cmp   phStart         jne   DSP7         add4  selStart,selLength       update start of next string to PARSE         clc                            update pointer into text         lda   ptr         adc   selLength         sta   ptr         lda   ptr+2         adc   selLength+2         sta   ptr+2         brl   DSP4;; Now that all the text has been converted, we need to show it in a phonetics; window.  We'll need to create a new window, first.;DSP14    jsr   InitWindow               init data structures         bcc   DSP15DSP14A   rtsDSP15    jsr   SetPhonWName             get name for new phonetics window         lda   #phonTyp         sta   wRefCon+2                set window's type         sta   currWindTyp         jsr   CreateWindow         bcs   DSP14A;; Finally, we need to dump the phonetics buffer into the phonetics window.;DSP17    pea   $0005                    text descriptor:  text is raw data         ldy   #2                       pointer to text         lda   [handle2],Y              handle of text         tax         lda   [handle2]         inc   A         bne   DSP17A         inxDSP17A   phx         pha         ph4   tmp4                     size of data         pea   0                        style ref is pointer         ph4   #0                       not really passing any style reference         ldx   currIndex4         lda   teHandle+2,X         pha         lda   teHandle,X         pha         _TESetText         bcc   Rts                      handle error         pea   TEErr         jsr   HandleError         ph4   currWindow                 close window and exit         _CloseWindow         rtsRts      ldx   currIndex2               set flag that wind not assoc with         stz   windFileFlag,X             file         jsr   FiniWindow               final setting of data structures         ldy   #4                       unlock blocks         lda   [handle],Y         and   #$BFFF         sta   [handle],Y         lda   [handle2],Y         and   #$BFFF         sta   [handle2],Y         ldx   currIndex4         lda   teHandle,X               access Phonetics window's text edit         sta   handle                     control record         lda   teHandle+2,X         sta   handle+2         lda   [handle]                 dereference handle         sta   ptr         ldy   #2         lda   [handle],Y         sta   ptr+2         ldy   #dirtyOffset             set the dirty bit         lda   [ptr],Y         ora   #isDirty         sta   [ptr],Y         rts         end************************************************** DoSpeak - Depending upon type of front-most*           window, speak text or phonetics.**************************************************DoSpeak  start         using SIData         jsr   MyWindow                 front window ours?         bcs   DS0Rts      rtsDS0      lda   currWindTyp              call appropriate rtn for front window         cmp   #textTyp         bne   DS1         jsr   SpeakText         bra   RtsDS1      cmp   #phonTyp         bne   DS2         jsr   SpeakPhonetics         bra   RtsDS2      cmp   #dictTyp         bne   Rts         jsr   DictSpeakWord         rts         end************************************************** EmptyDict - Create "empty" dictionary.** Output:*        carry flag - set if error occurs;*                     clear otherwise**************************************************EmptyDict start         using SIData         pea   1                        clear the dict. in memory         _DictInit         lda   listRefCon               release curr. member array         ora   listRefCon+2         beq   ED1         ph4   listRefCon         _DisposeHandle         stz   listRefCon         stz   listRefCon+2         stz   memArray         stz   memArray+2ED1      lda   dictFileFlag             if file assoc. with dictionary,         beq   ED1A                       release its pathhandle         lda   dictPathHandle         ora   dictPathHandle+2         beq   ED1A         ph4   dictPathHandle         _DisposeHandle         stz   dictPathHandle         stz   dictPathHandle+2ED1A     stz   top                      reset dict variables to reflect lack         stz   bottom                     of on-line dictionary         stz   dictChanged         stz   nextEntry         stz   dictFileFlag         stz   listSize         stz   listStart;; Set display variables to none visible.;         ldx   #0         ldy   #0ED2      lda   #$FFFF         sta   visMembers,Y         sta   freeArray,X         tya         clc         adc   #35         tay         inx         inx         cpx   #10         blt   ED2;; Create new member array of minimum size.;         pea   0                        alloc. memory:  room for long result         pea   0         pea   0         pea   1024                     amount needed, in bytes         ph2   myID                     our user ID         pea   $C010                    locked, can't move, don't purge, don't;                                         cross bank bound., don't page align         ph4   #0                       no absolute address specified         _NewHandle                     alloc. memory for members array         bcc   ED3                      handle error         plx                              throw away zero handle         plx         pea   memErr         jsr   HandleError         sec         rtsED3      pla                            get handle returned by NewHandle call         sta   handle         sta   listRefCon         pla         sta   handle+2         sta   listRefCon+2         lda   [handle]                 dereference memory handle         sta   memArray         sta   ptr         ldy   #2         lda   [handle],Y         sta   memArray+2         sta   ptr+2         lda   #128         sta   actListSize;; Loop to init. list.;         stz   countED4      lda   count                    for (count := 0; count < actListSize;         cmp   actListSize                   count++)         bge   ED5         ldy   #2                         memArray [count].mem# := count;         sta   [ptr],Y         lda   #$FFFF                     memArray [count].visMem# := -1;         sta   [ptr]         ldy   #4                         memArray [count].flag := 0;         lda   #0                           (visible, not enabled)         sta   [ptr],Y         inc   count                      update loop variables:  count++;         lda   ptr                                                ptr += 8;         clc         adc   #8         sta   ptr         lda   ptr+2         adc   #0         sta   ptr+2         bra   ED4;; If dictionary window is up, recreate list control, now that list is empty.;ED5      lda   dictUpFlag         bne   ED5A         clc         rtsED5A     ph4   listCtlHndl              dispose of current control         _HideControl         ph4   listCtlHndl         _DisposeControl         pea   0                        room for long result         pea   0         ph4   dictWindowPtr            window that own's control         pea   0                        will push pointer to template         ph4   #listTempl         _NewControl2         bcc   ED6                      handle error         plx                              throw away zero handle         plx         pea   ctlErr                      report error         jsr   HandleError         ph4   dictWindowPtr              close the dict window         _CloseWindow         sec                              return (error)         rtsED6      pla         sta   listCtlHndl         pla         sta   listCtlHndl+2         clc         rts         end************************************************** EventLoop - Get next event, then dispatch the*             appropriate routine to handle it.**************************************************EventLoop start         using SIDataLoop     lda   done                     check if we're finished         beq   L0         rtsL0       pea   0                        call TaskMaster         pea   $076E                    event mask = just about everything         ph4   #taskRec         _TaskMaster         bcc   L1         brl   FatalErr                 only error is screwing up wmTaskMask;                                         bitsL1       pla         beq   L0         cmp   #inUpdate                handle window update events         bne   L2         jsr   HandleUpdate         bra   L0L2       cmp   #wInSpecial         bne   L3         jsr   HandleSpecial         bra   L0L3       cmp   #wInGoAway         bne   L4         jsr   DoClose         bra   L0L4       cmp   #wInMenuBar         bne   L5         jsr   HandleMenu         bra   LoopL5       cmp   #wInControl              if window control clicked,         bne   L0                         dispatch appropriate routine         lda   wmTaskData4                get control ID         cmp   #16         blt   L0         sec                              we're only interested in dict's         sbc   #16                          controls         asl   A         tax         jsr   (CtlTable,X)         bra   L0CtlTable dc    a2'DictAddWord'                  add button         dc    a2'DictDeleteWord'               delete button         dc    a2'DictConvertWord'              translate button         dc    a2'DictSpeakWord'                speak button         dc    a2'NullRtn'                      file operations static box         dc    a2'DictSave'                     save button         dc    a2'DictLoad'                     load button         dc    a2'DictClear'                    clear button         dc    a2'DoPrint'                      print button         dc    a2'DoClose'                      exit button         end************************************************** FatalErr - Handle a fatal error.**************************************************FatalErr start         using SIData         pea   0         pea   0         _SysFailMgr         end************************************************** FiniWindow - Disable New and Open commands if*              this is the 10th window opened.**************************************************FiniWindow start         using SIData         ldx   currIndex2               set flag that window is up         lda   #1         sta   windUpFlag,X         inc   numWindows               one more open window         inc   userWindows              one more open user window         lda   userWindows         cmp   #10         blt   Rts         ph2   #newID                   can't allow creation of new window         _DisableMItem         ph2   #openID                  or opening of a file         _DisableMItemRts      rts         end************************************************** GetEnglishBox - Retrieves contents of English*                 word edit box in dictionary*                 window, translating to upper case.** Global Output:*        englishSize - size of English text*        englishWord - English text*        handle      - handle to text*        ptr         - pointer to text*        tmp4        - English word's leRecHndl**************************************************GetEnglishBox start         using SIData;; Get pointer to English word from the edit record.  Edit record handle is; stored in the control's control record.;         lda   englCtlHndl              handle := English word's control hndl         sta   handle         lda   englCtlHndl+2         sta   handle+2         lda   [handle]                 ptr := handle^         sta   ptr         ldy   #2         lda   [handle],Y         sta   ptr+2         ldy   #30                      tmp4 := ptr^.leRecHndl         lda   [ptr],Y         sta   tmp4+2         ldy   #28         lda   [ptr],Y         sta   tmp4;; Call Line Edit toolset for the English word's size and text.;         pea   0                        room for integer result         ph4   tmp4         _LEGetTextLen                  get English text length         pla         sta   englishSize              englishSize := LEGetTextLen (tmp4)         pea   0                        room for long result         pea   0         ph4   tmp4         _LEGetTextHand                 handle := LEGetTextHand (tmp4)         pla         sta   handle         pla         sta   handle+2         lda   [handle]                 ptr := handle^         sta   ptr         ldy   #2         lda   [handle],Y         sta   ptr+2         ldy   englishSize              copy text to our data area:         dey                            for (Y := englishSize-1; Y >= 0; Y--)         short MGEB1     lda   [ptr],Y                    A := (ptr+Y)^.char         cmp   #'a'                       if (A >= 'a') and (A <= 'z')         blt   GEB2         cmp   #'{'         bge   GEB2         sec                                A := upshift (A)         sbc   #$20                       endifGEB2     sta   englishText,Y         dey         bpl   GEB1                     endfor         long  M         rts         end************************************************** GetPhonBox - Retrieves contents of phonetics*              word edit box in dictionary window.** Global Output:*        phoneticSize - size of phonetic text*        phoneticWord - phonetic text*        handle2      - handle to text*        ptr2         - pointer to text*        tmp4         - phonetic word's leRecHndl**************************************************GetPhonBox start         using SIData;; Get pointer to phonetic word from the edit record.  Edit record handle is; stored in the control's control record.;         lda   phonCtlHndl              handle2 := phonCtlHndl         sta   handle2         lda   phonCtlHndl+2         sta   handle2+2         lda   [handle2]                ptr2 := handle2^         sta   ptr2         ldy   #2         lda   [handle2],Y         sta   ptr2+2         ldy   #30                      tmp4 := ptr2^.leRecHndl         lda   [ptr2],Y         sta   tmp4+2         ldy   #28         lda   [ptr2],Y         sta   tmp4         pea   0                        room for integer result         ph4   tmp4         _LEGetTextLen                  get phonetic text length         pla         sta   phoneticSize         pea   0                        room for long result         pea   0         ph4   tmp4         _LEGetTextHand                 get handle to phonetic text         pla         sta   handle2         pla         sta   handle2+2         lda   [handle2]                 dereference text handle         sta   ptr2         ldy   #2         lda   [handle2],Y         sta   ptr2+2         ldy   phoneticSize             copy text to our data area         dey         short MGPB1     lda   [ptr2],Y         sta   phoneticText,Y         dey         bpl   GPB1         long  M         rts         end************************************************** GetPhonetics - Call Text Edit's TEGetText routine*                to dump text into the phonetics*                buffer.** Output:*        carry flag - clear if text can be*                     returned, and set otherwise*        phBuffer   - handle to text*        phBuffSize - size of text**************************************************GetPhonetics start         using SIData;; First call Text Edit's TEGetTextInfo to determine if the current buffer; is large enough to hold the text to write.;         ph4   #textInfo                pointer to textInfo record         pea   2                        all we really want are 1st 2 fields         ldx   currIndex4         lda   teHandle+2,X         pha         lda   teHandle,X         pha         _TEGetTextInfo         bcc   GP1                      handle error         pea   TEErr         jsr   HandleError         sec         rts;; Set the current buffer's size to that needed; if the buffer has been; deallocated, attempt to allocate a new buffer.;GP1      inc4  charCount                need 1 more for 1st length byte         ph4   phBuffer         _HUnlock         bcs   GP2         ph4   charCount         ph4   phBuffer         _SetHandleSize         bcc   GP3         pea   OOMErr         jsr   HandleError         sec         rtsGP2      pea   0                        allocate memory block for TEGetText call         pea   0         ph4   charCount                allocate needed size         ph2   myID         pea   $8010                    don't purge, don't cross bank bndry         pea   0                        no absolute address specified         pea   0         _NewHandle         bcc   GP2A                     handle error         plx         plx         pea   memErr         jsr   HandleError         sec         rtsGP2A     pla                            get buffer's handle         sta   phBuffer         pla         sta   phBuffer+2GP3      ph4   phBuffer         _HLock         lda   charCount                get new buffer size         sta   phBuffSize         lda   charCount+2         sta   phBuffSize+2;; Call Text Edit's GetText to dump text into buffer.;GP5      pea   0                        room for long result         pea   0         pea   $0005                    will pass pointer to buffer         lda   phBuffer                 dereference handle to get pointer         sta   handle2         lda   phBuffer+2         sta   handle2+2         lda   [handle2]         sta   ptr2         ldy   #2         lda   [handle2],Y         sta   ptr2+2         inc   ptr2         bne   GP5A         inc   ptr2+2GP5A     lda   ptr2+2                   push pointer to buffer         pha         lda   ptr2         pha         ph4   charCount                size of buffer         pea   0                        don't care about style info         pea   0         pea   0         ldx   currIndex4         lda   teHandle+2,X         pha         lda   teHandle,X         pha         _TEGetText         bcc   GP6                      if error, process error         plx         plx         pea   TEErr         jsr   HandleError         sec         rtsGP6      pla                            get size of text to write to disk,         sta   writeRequest               returned by TEGetText call         pla         sta   writeRequest+2         clc         rts         end************************************************** GetText - Call Text Edit's TEGetText routine*           to dump text into our buffer.** Output:*        carry flag - clear if text can be*                     returned, and set otherwise*        buffer     - handle to text*        bufferSize - size of text**************************************************GetText  start         using SIData;; First call Text Edit's TEGetTextInfo to determine if the current buffer; is large enough to hold the text to write.;         ph4   #textInfo                pointer to textInfo record         pea   2                        all we really want are 1st 2 fields         ldx   currIndex4         lda   teHandle+2,X         pha         lda   teHandle,X         pha         _TEGetTextInfo         bcc   GT1                      handle error         pea   TEErr         jsr   HandleError         sec         rts;; Set the current buffer's size to that needed; if the buffer has been; deallocated, attempt to allocate a new buffer.;GT1      ph4   buffer         _HUnlock         bcs   GT2         ph4   charCount         ph4   buffer         _SetHandleSize         bcc   GT3         pea   OOMErr         jsr   HandleError         sec         rtsGT2      pea   0                        allocate memory block for TEGetText call         pea   0         ph4   charCount                allocate needed size         ph2   myID         pea   $8010                    don't purge, don't cross bank bndry         pea   0                        no absolute address specified         pea   0         _NewHandle         bcc   GT2A                     handle error         plx         plx         pea   memErr         jsr   HandleError         sec         rtsGT2A     pla                            get buffer's handle         sta   buffer         pla         sta   buffer+2GT3      ph4   buffer         _HLock         lda   charCount                get new buffer size         sta   bufferSize         lda   charCount+2         sta   bufferSize+2;; Call Text Edit's GetText to dump text into buffer.;GT5      pea   0                        room for long result         pea   0         pea   $000D                    will pass buffer's handle         ph4   buffer         ph4   charCount         pea   0                        don't care about style info         pea   0         pea   0         ldx   currIndex4         lda   teHandle+2,X         pha         lda   teHandle,X         pha         _TEGetText         bcc   GT6                      if error, process error         plx         plx         pea   TEErr         jsr   HandleError         sec         rtsGT6      pla                            get size of text to write to disk,         sta   writeRequest               returned by TEGetText call         pla         sta   writeRequest+2         clc         rts         end************************************************** GrowList - Attempt to expand dictionary's list*            member array by 128 members.** Output:*  carry - clear if list was grown; clear otherwise** Global output:*  actListSize - updated to reflect new list size*  listRefCon  - new handle for member array*  memArray    - new pointer to member array*************************************************GrowList start         using SIData;; Calculate total amount of memory needed for array =; current list size  *  sizeof (memberRecord).;         lda   listSize                 try to grow by 1K         clc         adc   #128         cmp   #maxListSize             ensure not exceeding list maximum         blt   GL0         beq   GL0         lda   #$1C01         pea   listErr         jsr   HandleError         sec         rtsGL0      sta   tmp4         stz   tmp4+2         ldx   #3                       counterGL1      asl   tmp4                     sizeof (member record) = 8, so use         rol   tmp4+2                     3 shifts to perform multiply         dex         bne   GL1         ph4   listRefCon               unlock handle for SetHandleSize call         _HUnlock         bcc   GL2         pea   memErr         jsr   HandleError         sec         rtsGL2      ph4   tmp4         ph4   listRefCon         _SetHandleSize         bcc   GL3         pea   memErr         jsr   HandleError         sec         rts;; Initialize new part of array.;GL3      lda   listRefCon         sta   handle         lda   listRefCon+2         sta   handle+2         ldy   #4                       lock handle         lda   [handle],Y         ora   #$C000         sta   [handle],Y         lda   listSize                 record new list size         clc         adc   #128         sta   actListSize         lda   [handle]                 dereference memory handle         sta   memArray         sta   ptr         ldy   #2         lda   [handle],Y         sta   memArray+2         sta   ptr+2;; Initialize memArray.;         lda   listSize                 get starting address for new part         sta   tmp4         stz   tmp4+2         ldx   #3                       counterGL4      asl   tmp4                     sizeof (member record) = 8, so use         rol   tmp4+2                     3 shifts to perform multiply         dex         bne   GL4         clc         lda   ptr         adc   tmp4         sta   ptr         lda   ptr+2         adc   tmp4+2         sta   ptr+2         ldx   listSizeGL4A     cpx   actListSize              for X := listSize to actListSize-1 do         bge   GL5                      begin         txa         ldy   #2                         memArray [X].mem# := X;         sta   [ptr],Y         lda   #$FFFF                     memArray [count].visMem# := -1;         sta   [ptr]         ldy   #4                         memArray [count].flag := 0;         lda   #0                           (visible, not enabled)         sta   [ptr],Y         ldy   #6                         memArray [count].phonlistPtr := nil;         sta   [ptr],Y         inx                              update loop variables:  X++;         lda   ptr                                                ptr += 8;         clc         adc   #8         bcc   GL4B         inc   ptr+2GL4B     sta   ptr         bra   GL4A                     end; {for}GL5      clc         rts         end************************************************** HandleError - Report errors detected in SpeakIt.** Input:*        3,S - error message #*        A   - error number returned by tool** Output:*        A   - error number passed**************************************************HandleError start         using SIData         sta   error                    save error # returned by tool         lda   3,S                      get address of error message         asl   A         asl   A         tax         lda   errMsgPtr,X              change alert template's pointer to         sta   errMsg                     error message         lda   errMsgPtr+2,X         sta   errMsg+2         ph2   error                    convert integer error # to hex string         ph4   #errNum                  address of space for hex string         pea   4                        length of string is 4 spaces         _Int2Hex         bcc   OK         brl   FatalErr;;  Bring up alert.;OK       pea   0                        room for result         ph4   #errAlert                address of alert template         ph4   #0                       use default filter procedure         _CautionAlert                  bring up alert         pla                            only 1 item to be hit, so ignore it         lda   1,S                      clean up stack and exit         sta   3,S                      put rts at top of stack         pla                            pull extra byte from stack         lda   error                    return err # passed to us         rtserror     ds   2errMsgPtr dc   a4'msg0,msg1,msg2,msg3,msg4,msg5,msg6,msg7,msg8,msg9,msg10,msg11'          dc   a4'msg12,msg13,msg14,msg15,msg16,msg17'         end************************************************** HandleMenu - Handle menu selections, menu IDs*              256 ->.**************************************************HandleMenu start         using SIData         lda   wmTaskData               get menu item ID         sec         sbc   #aboutID                 get offset from 1st menu ID, the about item         asl   A                        multiply by 2 since table items are 2 bytes         tax         jsr   (table,X)                get address from table to stuff into jsr         pea   0                        need to unhighlight menu         ph2   wmTaskData+2         _HiliteMenu         rtstable    dc    a2'DoAbout'         dc    a2'DoNew'         dc    a2'DoOpen'         dc    a2'DoSave'         dc    a2'DoSaveAs'         dc    a2'DoPSetUp'         dc    a2'DoPrint'         dc    a2'DoQuit'         dc    a2'DoSpeak'         dc    a2'DoShowPhonetics'         dc    a2'DoSetParameters'         dc    a2'DoDict'         dc    a2'DoActivate'         end************************************************** HandleSpecial - Handle special menu commands,*                 menu IDs 250 - 255.**************************************************HandleSpecial start         using SIData         lda   wmTaskData         cmp   #closeID                 Selected Close?         bne   Out                      all other special items handled by TaskMaster         jsr   DoCloseOut      pea   0                        need to unhighlight menu         ph2   wmTaskData+2         _HiliteMenu         rts         end************************************************** HandleUpdate - Handle update event for active*                window.**************************************************HandleUpdate start         using SIData         ph4   wmTaskData         _BeginUpdate         ph4   wmTaskData         _DrawControls         ph4   wmTaskData         _EndUpdate         rts         end************************************************** Init - Start the tools we need, then create*        our menu bar.**************************************************Init     start         using SIData         sta   masterID                 get user ID passed by loader         ora   #$0200                   alter for our purposes, so we can do         sta   myID                       a simple DisposeAll at the end;; Start tools we need.;         pha                            room for long return value         pha         ph2   masterID                 our user ID         ph2   #2                       start/stop ref is rsrc ID         ph4   #startStopID             rsrc ID of start/stop record         _StartUpTools                  use GS/OS 5.0 one-call tool start up         bcc   I0                       handle error         plx         plx         rtsI0       pl4   startStopRef;; Start the speech tools.;         jsr   InitSpeech         bcc   I1         rts;;  Create the menu bar.;I1       pea   0                        room for long result         pea   0         pea   2                        ref is rsrc ID         pea   0                        rsrc ID         pea   menuBarID         pea   0                        window ptr = nil; not a window menu bar         pea   0         _NewMenuBar2                   create menu bar         _SetSysBar                     set our menu bar to curr sys menu bar         pea   0                        nil for curr sys menu bar to become         pea   0                          curr menu bar         _SetMenuBar         pea   1                        add desk accessories to Apple menu         _FixAppleMenu         pea   0                        compute standard sizes for menu bar and         _FixMenuBar                      menus         pla                            throw away returned height         _DrawMenuBar;;  Create print record.;         pea   0                        allocate memory block for print record         pea   0         ph4   #140                     record is 140 bytes long         ph2   myID         pea   $C010                    locked, don't purge, don't move         pea   0                        no absolute address specified         pea   0         _NewHandle         bcc   I2                       handle error         plx                              pull null from stack         plx         pea   memErr                       report error         jsr   HandleError         sec                              return (error)         rtsI2       lda   1,S                      save the print record handle         sta   prHandle         lda   3,S         sta   prHandle+2         _PrDefault                     let Print Manager initialize print record         bcc   I3                       handle error         pea   printErr         jsr   HandleError         sec         rts;; Allocate buffers to hold windows' text.;I3       pea   0                        allocate memory block for TEGetText call         pea   0         ph4   #1024                    allocate 2 blocks         ph2   myID         pea   $8010                    don't purge, don't cross bank bndry         pea   0                        no absolute address specified         pea   0         _NewHandle         bcc   I4                       handle error         plx                              pull null from stack         plx         pea   memErr         jsr   HandleError         sec         rtsI4       pla                            save buffer handle         sta   buffer         pla         sta   buffer+2         lda   #1024                    save buffer's size         sta   bufferSize         stz   bufferSize+2         pea   0                        allocate memory block for TEGetText call         pea   0         ph4   #1024                    allocate 2 blocks         ph2   myID         pea   $8010                    don't purge, don't cross bank bndry         pea   0                        no absolute address specified         pea   0         _NewHandle         bcc   I5                       handle error         plx                              pull null from stack         plx         pea   memErr         jsr   HandleError         sec         rtsI5       pla                            save buffer handle         sta   phBuffer         pla         sta   phBuffer+2         lda   #1024                    save buffer's size         sta   phBuffSize         stz   phBuffSize+2         _InitCursor                    StartUpTools brings up the watch cursor         clc                              so change it to the arrow         rts         end************************************************** InitSpeech - Start speech tools and*              initialize dictionary.** Ouput:*        carry - set if error occurs; otherwise clear**************************************************InitSpeech start         using SIData;; Start speech tools.;         ph4   #toolTable               start the tools we need         _LoadTools         bcc   IST1                     check for error from LoadTools call         pea   toolErr                       report the error         jsr   HandleError         sec                              return error flag         rtsIST1     lda   myID                     start parser         pha         _ParseStartUp         _MaleStartUp                   start male voice         _FemaleStartUp                 start female voice         _SpeechStartUp                 start GS/OS interface         bcc   IST2                       check inability to start this tool         pea   toolErr                       report the error         jsr   HandleError         sec                              return error flag         rts;; Initialize the dictionary.;; First see if there's a dictionary file to load.;IST2     lda   #^dictFileName           attempt to open */System/SpeechDict         sta   openPath+2         lda   #dictFileName         sta   openPath;                                       SET ACCESS, FILETYPE, AUXTYPEIST3     _OpenGS  openRec               open the file         bcc   IST4                     if no error, continue init. dict.         cmp   #diskSwitchedErr         if open error = disk switched, ask user         beq   IST3B                      to load boot disk         cmp   #volNotFoundErr          else if open error = volume not found,         beq   IST3B                      ask user to load boot disk         cmp   #fileNotFoundErr         else if open error = file not found,         bne   IST3A         jsr   SetNoFileDName             set dict's filename to none         jsr   EmptyDict                  set dict to empty         bcs   Err1         rtsIST3A    pea   openErr                     else report the file open error         jsr   HandleErrorErr1     sec         rts;; Use TLMountVolume call to prompt for boot disk.;IST3B    pea   0                        room for integer result         pea   20                       put dialog box at (20,20)         pea   20         ph4   #mountPrompt             pointer to 1st message line         pea   0                        no 2nd message line in dialog box         pea   0         ph4   #okTitle                 pointer to OK button's text         ph4   #cancelTitle             pointer to Cancel button's text         _TLMountVolume         pla                            get user's response         cmp   #1         beq   IST3         clc         rtsIST4     lda   openPath                 record file's pathname, will need it         sta   dictPathName               when saving the file to disk         lda   openPath+2         sta   dictPathName+2         lda   openRef                  get ready to read then close the file         sta   readRef         sta   closeRef         lda   openSize                 ensure file size not 0         ora   openSize+2         bne   IST5         _CloseGS (closeRec)            if it is, close the file then init dict         jsr   EmptyDict                  to empty         bcs   IST4A         brl   IST6IST4A    sec         rts;; If the file is not empty, allocate a read buffer, read and then close the; file.  Based on the file's type, load it into the program.;IST5     ph4   #0                       allocate memory block to read files         ph4   openSize                 read in the whole thing         ph2   myID         pea   $C010                    locked, can't move, don't purge, don't;                                         cross bank bound., don't page align         ph4   #0                       no absolute address specified         _NewHandle         bcc   IST5A                    handle error:         plx                              throw away zero handle         plx         pea   memErr         jsr   HandleError         _CloseGS  closeRec         sec         rtsIST5A    pla         sta   handle                   get ready to dereference the handle         pla         sta   handle+2         lda   [handle]                 dereference memory handle         sta   readBuffer         ldy   #2         lda   [handle],Y         sta   readBuffer+2         lda   openSize                 get # bytes to read         sta   readRequest         lda   openSize+2         sta   readRequest+2         _ReadGS  readRec               make the Read call         php                            save error flag from read         _CloseGS closeRec         plp         bcc   IST5B                    handle error         pea   readErr         jsr   HandleErrorErr2     sec         rtsIST5B    ph4   readBuffer         ph4   transferCount         jsr   LoadDict                 load dictionary file         php         lda   handle+2                 dispose of read buffer         pha         lda   handle         pha         _DisposeHandle         plp         bcs   Err2;; Perform final clean-up.;IST6     lda   #10                      set dict's name         sta   count         lda   #^defaultDName         sta   ptr3+2         lda   #defaultDName         sta   ptr3         jsr   SetDefaultDName         ldx   currIndex2         lda   #1         sta   windFileFlag,X         ldx   currIndex4         lda   openPath         sta   pathName,X         lda   openPath+2         sta   pathName+2,X         clc         rts         end************************************************** InitWindow - Perform window initialization,*              common to both DoOpen and DoNew.** Ouput:*        carry - set if there are already 10*                user windows up; otherwise clear**************************************************InitWindow start         using SIData         ldx   #0                       track window # in array         stx   countTop1     lda   windUpFlag,X             loop to find empty slot in array         beq   IW1         inc   count         inx         inx         cpx   #20                      slots 0 - 9 all gone?         blt   Top1         sec         rtsIW1      lda   count                    count is index into window arrays         sta   wRefCon                  use window's RefCon to track position         sta   currWindNum                in arrays         asl   A                        calculate 2-byte offset into arrays         sta   currIndex2         asl   A                        calculate 4-byte offset into arrays         sta   currIndex4         tax                            set wTitle pointer         lda   wNamePtr,X               set wTitle pointer         sta   wTitle         lda   wNamePtr+2,X         sta   wTitle+2         clc         rts         end************************************************** ListDrawRtn - Draws dictionary list member into*               list control.** Inputs:*        1,S - 3-byte return address*        4,S - list control handle*        8,S - pointer to member record to be drawn*       12,S - pointer to rect. enclosing member**************************************************ListDrawRtn start         using SIDatartl      equ   11                       inputs, as direct page variableslistHndl equ   14memPtr   equ   18rectPtr  equ   22tmp1     equ   7                        temps on stacktmp2     equ   3         tsc                            make room for direct page temps         sec         sbc   #8         tcs         phd                            save direct page register         tsc                            set direct page register to stack reg.         tcd         phb                            use K for B         phk         plb;; Check whether requested element to be drawn is currently visible.;         lda   [memPtr]                 A := memArray [memPtr^.visMem#]         cmp   #$FFFF                   if (A = -1) then         jne   LDR1;; If element not visible, will need to revise the list.  First calculate the; list display's new top and bottom members.;         lda   top                        tmp4 := top         sta   tmp4         lda   bottom                     tmp4+2 := bottom         sta   tmp4+2         lda   [listHndl]               newTop is derived from this element's         sta   tmp1                     position in the window:         ldy   #2                         dereference the control handle         lda   [listHndl],Y         sta   tmp1+2         ldy   #8                         get control's rect.Y1         lda   [tmp1],Y         sta   tmp2         lda   [rectPtr]                  get member's rect.Y1         sec                              calculate member's distance to top of         sbc   tmp2                         display         pea   0                          position := distance / member height         pea   0         pha         pea   10         _UDivide         pla         sta   tmp2                       tmp2 := member's position         plx                              throw away remainder         ldy   #2                         top := memPtr^.mem# - position         lda   [memPtr],Y         sec         sbc   tmp2         sta   top         clc                              bottom := top + 4         adc   #4         sta   bottom;; Calculate type of scrolling user has done in order to determine which; members need to be made invisible, and which are now visible.;         lda   tmp4+2                 if (oldBottom >= top) and         cmp   top                       (oldBottom <= bottom) then         blt   LDR0B         cmp   bottom         bgt   LDR0A         ldx   tmp4                     MakeInvisible (oldTop -> top-1)         ldy   top         dey         jsr   MakeInvisible         ldx   tmp4+2                   MakeVisible (oldBottom+1 -> bottom)         inx         ldy   bottom         jsr   MakeVisible         bra   LDR0CLDR0A    lda   tmp4                     if (oldTop >= top) and         cmp   top                         (oldTop <= bottom) then         blt   LDR0B         cmp   bottom         bgt   LDR0B         ldx   bottom                     MakeInvisible (bottom+1 -> oldBottom)         inx         ldy   tmp4+2         jsr   MakeInvisible         ldx   top                        MakeVisible (top -> oldTop-1)         ldy   tmp4         dey         jsr   MakeVisible         bra   LDR0CLDR0B    ldx   tmp4                     else         ldy   tmp4+2                     need to refill entire visible list:         jsr   MakeInvisible              MakeInvisible (oldTop, oldBottom)         ldx   top         ldy   bottom         jsr   MakeVisible                MakeVisible (top, bottom)LDR0C    bcc   LDR0D         ph4   listCtlHndl              we'll be redrawing the dict display         _HideControl         ph4   listCtlHndl         _DisposeControl         pea   0                        room for long result         pea   0         lda   dictWindowPtr+2          window that own's control         pha         lda   dictWindowPtr         pha         pea   0                        will push pointer to template         ph4   #listTempl         _NewControl2         bcc   LDR0CA                   handle error         plx                              throw away zero handle         plx         pea   ctlErr                      report error         jsr   HandleError         ph4   dictWindowPtr              close the dict window         _CloseWindow         rtsLDR0CA   pla         sta   listCtlHndl         pla         sta   listCtlHndl+2         brl   LDR5LDR0D    lda   [memPtr]                 get visMem# to draw;; If element is visible, access it from the visMembers array.;LDR1     pea   0                        else         pea   0         pha         pea   35                         calculate address of string to draw:         _Multiply         lda   #^visMembers+2               &(visMembers [A * 35].English)         sta   tmp4+2         lda   #visMembers+2         sta   tmp4         clc         pla         adc   tmp4         sta   tmp4         pla         adc   tmp4+2         sta   tmp4+2;; Draw the member.;LDR3     lda   rectPtr+2                erase the member's rectangle         pha         lda   rectPtr         pha         _EraseRect         _PenNormal                     use a standard pen         _ShowPen;                                       move pen to drawing location:         ldy   #2                         X := rectPtr^.X1 + 5         lda   [rectPtr],Y         clc         adc   #5         pha         ldy   #4                         Y := rectPtr^.Y2         lda   [rectPtr],Y         pha         _MoveTo                          MoveTo (X, Y)         ph4   tmp4                     DrawString (tmp4)         _DrawString;; If the member was selected, copy its English word to the English edit-line; box, and its phonetics word to the phonetics edit-line box.  Invert the; member's view rectangle to show it was selected.;         lda   #0         ldy   #4                       check member's flag         short M         lda   [memPtr],Y         long  M         and   #$0080                     flag is 1 byte         jeq   LDR5         ph4   englCtlHndl         _HideControl         lda   tmp4                     get address of English word         sta   tmp1         lda   tmp4+2         sta   tmp1+2         inc4  tmp4                     skip length byte in English word         ph4   tmp4                     pass addr of text to LESetText call         lda   [tmp1]                   access length byte         and   #$00FF         sta   englishSize              record size of text         pha                            pass length parm to LESetText call         tay                            copy text to English data structure         short MLDR4B    lda   [tmp1],Y         sta   EnglishText-1,Y         dey         bne   LDR4B         long  M         lda   englCtlHndl              dereference English edit-line box'         sta   tmp1                       control handle to access ctlData field         lda   englCtlHndl+2         sta   tmp1+2         lda   [tmp1]         sta   tmp2         ldy   #2         lda   [tmp1],Y         sta   tmp2+2         ldy   #30                      pass leRecHndl to LESetText call         lda   [tmp2],Y         pha         ldy   #28         lda   [tmp2],Y         pha         _LESetText         ph4   englCtlHndl         _ShowControl         ph4   phonCtlHndl         _HideControl         ldy   #6                       get address of phonetic word:  addr         lda   [memPtr],Y                 is backwards!         sta   tmp4         sta   tmp1         ldy   #5         stz   tmp4+2         stz   tmp1+2         short M         lda   [memPtr],Y         sta   tmp4+2         sta   tmp1+2         long  M         inc4  tmp4                     skip length byte in phonetic word         ph4   tmp4                     pass addr of text to LESetText call         lda   [tmp1]                   access length byte         and   #$00FF         sta   phoneticSize             record size of text         pha                            pass length parm to LESetText call         tay                            copy text to phonetic data structure         short MLDR4C    lda   [tmp1],Y         sta   phoneticText-1,Y         dey         bne   LDR4C         long  M         lda   phonCtlHndl              dereference English edit-line box'         sta   tmp1                       control handle to access ctlData field         lda   phonCtlHndl+2         sta   tmp1+2         lda   [tmp1]         sta   tmp2         ldy   #2         lda   [tmp1],Y         sta   tmp2+2         ldy   #30                      pass leRecHndl to LESetText call         lda   [tmp2],Y         pha         ldy   #28         lda   [tmp2],Y         pha         _LESetText         ph4   phonCtlHndl         _ShowControl         lda   rectPtr+2                invert the member's rectangle         pha         lda   rectPtr         pha         _InvertRect;; Clean up and exit.;LDR5     lda   rtl                      move return address to top of stack         sta   rectPtr+1         lda   rtl+1         sta   rectPtr+2         plb                            reset B         pld                            restore original direct page register         tsc                            pop input parms + temps from stack         clc         adc   #20         tcs         rtl         end************************************************** LoadDict - Load new dictionary from disk.** Input:*        7,S - pointer to file's contents*        3,S - file's size (long)** Output:*        carry flag - set if error occurs, clear*                     otherwise**************************************************LoadDict start         using SIDatatextPtr  equ   17fileSize equ   13Rts      equ   11hndl     equ   7listPtr  equ   3         tsc                            set up new direct page on stack         sec                              room for temps         sbc   #8         tcs         phd                            save old Direct Page register         tsc         tcd         lda   listRefCon               check need to dealloc old dict         ora   listRefCon+2         beq   LD0         ph4   listRefCon         _DisposeHandle         stz   listRefCon         stz   listRefCon+2         stz   memArray         stz   memArray+2LD0      stz   listSize                 assume dict is empty to start with         stz   listStart         stz   top         stz   bottom         pea   1         _DictInit         stz   nextEntry;; Process the file:  count # dict. entries, create dict. from file.;         clc                            tmp4 := address of last byte in buffer         lda   textPtr         adc   fileSize         sta   tmp4         lda   textPtr+2         adc   fileSize+2         sta   tmp4+2LD3      lda   textPtr+2                while textPtr < tmp4 do begin         cmp   tmp4+2         blt   LD5         beq   LD4         bra   LD8LD4      lda   textPtr         cmp   tmp4         blt   LD5         bra   LD8LD5      lda   textPtr+2                  push pointer to English word         pha         lda   textPtr         pha         lda   [textPtr]                  calc. pointer to phonetic word:         and   #$00FF                     length (English word) + 1 + textPtr         inc   A         clc         adc   textPtr         bcc   LD6         inc   textPtr+2LD6      sta   textPtr         ldx   textPtr+2         phx                              push pointer to phonetic word         pha         _DictInsert                      insert new entry into dictionary         lda   [textPtr]                  calc. pointer to next entry         and   #$00FF         inc   A         clc         adc   textPtr         bcc   LD7         inc   textPtr+2LD7      sta   textPtr         inc   listSize                   # dict entries++         lda   listSize         cmp   #maxListSize               ensure doesn't exceed max size         blt   LD3                      end {while};; Build list for dictionary window:  allocate memory for members array, then; initialize array.;LD8      lda   listSize                 allocate memory for members array:         sta   tmp4                       amount needed = sizeof (member record)         stz   tmp4+2                                     * listSize + 1024         ldx   #3                       counterLD9      asl   tmp4                     sizeof (member record) = 8, so use         rol   tmp4+2                     3 shifts to perform multiply         dex         bne   LD9         clc                            check if can grow list by 128 members         lda   listSize         adc   #128         cmp   #maxListSize         blt   LD9A         lda   #maxListSize         sta   actListSize         bra   LD9BLD9A     sta   actListSize         add4  tmp4,#1024LD9B     pea   0                        alloc. memory:  room for long result         pea   0         ph4   tmp4                     amount needed, in bytes         ph2   myID                     our user ID         pea   $C010                    locked, can't move, don't purge, don't;                                         cross bank bound., don't page align         ph4   #0                       no absolute address specified         _NewHandle                     alloc. memory for members array         bcc   LD10                     handle error         plx                              throw away zero handle         plx         pea   memErr                       report error         jsr   HandleError         sec                              return (error)         rtsLD10     pla                            get handle returned by NewHandle call         sta   hndl         sta   listRefCon         pla         sta   hndl+2         sta   listRefCon+2         lda   [hndl]                   dereference memory handle         sta   memArray         sta   listPtr         ldy   #2         lda   [hndl],Y         sta   memArray+2         sta   listPtr+2         inc   listStart                indicate list not empty;; Initialize memArray.;         ldx   #0LD11     cpx   actListSize              for X := 0 to actListSize-1 do begin         bge   LD12         txa         ldy   #2                         memArray [X].mem# := X;         sta   [listPtr],Y         lda   #$FFFF                     memArray [count].visMem# := -1;         sta   [listPtr]         ldy   #4                         memArray [count].flag := 0;         lda   #0                           (visible, not enabled)         sta   [listPtr],Y         ldy   #6                         memArray [count].phonlistPtr := nil;         sta   [listPtr],Y         inx                              update loop variables:  X++;         lda   listPtr                                            listPtr += 8;         clc         adc   #8         bcc   LD11A         inc   listPtr+2LD11A    sta   listPtr         bra   LD11;; Initialize list display.;LD12     stz   top                      set top, bottom members to display         lda   #4         cmp   listSize         blt   LD12A         lda   listSize         dec   ALD12A    sta   bottom         pea   0         _DictInit         stz   nextEntry         ldx   #0                       for X := 0 to 4 do begin         ldy   #0LD12B    lda   #$FFFF         sta   freeArray,X                freeArray [X]      := -1         sta   visMembers,Y               visMems [X].memNum := -1         tya         clc         adc   #35         tay         inx         inx         cpx   #10         blt   LD12B                    end {for}         ldx   top                      MakeVisible (top, bottom)         ldy   bottom         jsr   MakeVisible         lda   #1                       dictFileFlag := true         sta   dictFileFlag;; If the dictionary window is up, recreate list control.;         lda   dictUpFlag         beq   LD14         ph4   listCtlHndl              we'll be redrawing the dict display         _HideControl         ph4   listCtlHndl         _DisposeControl         pea   0                        room for long result         pea   0         lda   dictWindowPtr+2          window that own's control         pha         lda   dictWindowPtr         pha         pea   0                        will push pointer to template         ph4   #listTempl         _NewControl2         bcc   LD13                     handle error         plx                              throw away zero handle         plx         pea   ctlErr                      report error         jsr   HandleError         bra   LD14LD13     pla         sta   listCtlHndl         pla         sta   listCtlHndl+2;; Clean up the stack and return.;LD14     lda   Rts                      move return address to TOS         sta   textPtr+2         pld                            restore original Direct Page register         tsc                            pop parms + temps from stack         clc         adc   #16         tcs         clc         rts         end************************************************** MakeInvisible - Removes elements from currently*                 visible poriton of the list.** Input:*        X - 1st element to be removed*        Y - last element to be removed**************************************************MakeInvisible start         using SIData;; First initialize the free array to none free.;         phy                            save input parms         phx         ldx   #0         ldy   #5Top1     stz   freeArray,X         inx         inx         dey         bne   Top1;; Now we enter our main loop, setting member array elements' visMem# to -1,; and adding its visMem# to the free array.;         lda   1,S                      ptr2 := addr (memArray [X]) := X * 8         sta   ptr2                     /* 8 == sizeof (member record) */         stz   ptr2+2         ldx   #3Top2     asl   ptr2         rol   ptr2+2         dex         bne   Top2         clc                              + addr (memArray)         lda   ptr2         adc   memArray         sta   ptr2         lda   ptr2+2         adc   memArray+2         sta   ptr2+2;                                       doTop3     lda   [ptr2]                     A := memArray [mem#].visMem#         bmi   Top3A                      if (A <> -1)         tay                                Y := A         asl   A                            X := A * 2  (index into freeArray)         tax         lda   #$FFFF         sta   freeArray,X                  freeArray [X] := true         sta   [ptr2]                       memArray [mem#].visMem# := -1         pea   0                            visMems [visMem#].mem# := -1         pea   0         phy         pea   35         _Multiply         plx         pla         lda   #$FFFF         sta   visMembers,XTop3A    clc                              ptr2++         lda   ptr2         adc   #8         sta   ptr2         lda   ptr2+2         adc   #0         sta   ptr2+2         lda   1,S                        starting mem#++         inc   A         sta   1,S         cmp   3,S                      until (starting mem# > ending mem#)         ble   Top3         pla         pla         rts         end************************************************** MakeVisible - Adds elements to currently visible*               portion of the list.** Input:*        X - 1st element to be added*        Y - last element to be added**************************************************MakeVisible start         using SIData;; Local variables;endFlag  equ   17                       true if end-of-dict reachedVMPtr    equ   13                       pointer into visMembers arrayMAPtr    equ   9                        pointer into member arrayfree     equ   7                        index into free visMembers arraymemNum   equ   5                        current member being added to listlastMem  equ   3                        last member to add to the list         tsc                            get 14 bytes of stack space for temps         sec         sbc   #16         tcs         phd                            save original direct page         tsc                            set our direct page to stack         tcd         stz   endFlag                  endFlag := false;; First initialize the dictionary to that its next entry equals 1st member to; add to list.;MV00     stx   memNum                   save input parms         sty   lastMem         tya                            ensure not drawing past end of display         cmp   listSize         blt   MV0         beq   MV0         lda   listSize         sta   lastMemMV0      lda   nextEntry                check if we can reach 1st member from         cmp   memNum                     current dictionary setting         beq   MV2         blt   MV1         pea   0                        otherwise, we need to reset the dict.         _DictInit         stz   nextEntry;; Loop to reach first dictionary entry, dumping unneeded entries.;MV1      lda   nextEntry         cmp   memNum         beq   MV2         pea   0                        room for long result         pea   0         ph4   #word1                   address to receive English word         ph4   #word2                   address to receive phonetic word         _DictDump         pla                            don't care about pointer to phonetics         pla;; Check end of dictionary.;         lda   word1                    check if null English string returned         and   #$00FF                     Pascal-style string         jeq   MV3;; Not at end of dictionary, so just continue.;         inc   nextEntry         bra   MV1;; Initialize DP pointers to visMembers, memArray.;MV2      lda   memNum                   MAPtr := addr (memArray [memNum])         sta   MAPtr         stz   MAPtr+2         ldx   #3MV2A     asl   MAPtr         rol   MAPtr+2         dex         bne   MV2A         clc         lda   MAPtr         adc   memArray         sta   MAPtr         lda   MAPtr+2         adc   memArray+2         sta   MAPtr+2         stz   free                     VMPtr := addr (visMembers [free])         jsr   GetVM                    tmp4 := addr (VMPtr^.English)         bcc   MV2B                     sanity check         brl   MV4;; Loop to dump dictionary entries memNum through lastMem.; Dump dictionary entry into visMembers, member arrays.;MV2B     lda   memNum                   while (memNum <= lastMem)         cmp   lastMem         blt   MV2C         beq   MV2C         brl   MV4MV2C     pea   0                          room for long result         pea   0         ph4   #word1                     address to receive English word         ph4   #word2                     address to receive phonetic word         _DictDump                        tmp4 := DictDump ( ... )         pla         plx         sta   tmp4                       tmp4 := addr (phonetic word)         stx   tmp4+2;; Check end of dictionary.;         lda   word1                      check if null English string returned         and   #$00FF                       Pascal-style string         jeq   MV3;; Not at end of dictionary, so record info. into our list data structures.;         tax                              X := length (word1)         tay                              Y := index (visMems [free].english)         iny         iny         short MMV2D     lda   word1,X                    VMPtr^.english := word1         sta   [VMPtr],Y         dey         dex         bpl   MV2D         long  M         lda   memNum                     VMPtr^.mem# := memNum         sta   [VMPtr]         ldy   #4                         MAPtr^.flag := 0         lda   #0         sta   [MAPtr],Y         iny                              WE'RE STORING POINTER BACKWARDS!         lda   tmp4+2                     MAPtr^.phonPtr := tmp4         sta   [MAPtr],Y         iny         lda   tmp4         sta   [MAPtr],Y         lda   free                       MAPtr^.vis# := free         sta   [MAPtr]         asl   A                          freeArray [free] := false         tax         stz   freeArray,X;; Initialize our data structures for next entry.;         inc   memNum                     memNum++         inc   nextEntry                  nextEntry++         clc                              MAPtr++         lda   MAPtr         adc   #8         sta   MAPtr         lda   MAPtr+2         adc   #0         sta   MAPtr+2         inc   free                       free++         jsr   GetVM                      get VMPtr         bcs   MV4                        sanity check         brl   MV2B                     end while;; Handle encountering end of dictionary.;MV3      inc   endFlag                  endFlag := true         lda   top                      oldTop  := top         sta   oldTop         lda   bottom                   oldBottom := bottom         sta   oldBottom         lda   nextEntry                listSize := nextEntry         sta   listSize         dec   A                        bottom := listSize - 1         sta   bottom         sec                            top := bottom - 4         sbc   #4         bpl   MV3A                     if (top < 0)         lda   #0                         top := 0MV3A     sta   top         inc   A                        listStart := top + 1         sta   listStart         pea   0                        reset dictionary to top         _DictInit         stz   nextEntry                nextEntry := 0;; Determine which entries for the changed display we still need to get.;         lda   oldBottom                if (oldBottom >= top) and         cmp   top         blt   MV3C         cmp   bottom                      (oldBottom <= bottom) then         bgt   MV3B         ldx   oldBottom                  MakeVisible (oldBottom+1, bottom)         inx         ldy   bottom         brl   MV00MV3B     lda   oldTop                   if (oldTop >= top) and         cmp   top         blt   MV3C         cmp   bottom                      (oldTop <= bottom) then         bgt   MV3C         ldx   top                        MakeVisible (top, oldTop-1)         ldy   oldTop         dey         brl   MV00MV3C     ldx   top                      else         ldy   bottom                     MakeVisible (top, bottom)         brl   MV00;; Clean up and return.;MV4      ldx   endFlag                  save end-of-dict flag         pld                            restore original Direct Page register         tsc                            "pop" temps from stack         clc         adc   #16         tcs         clc                            if (not (end-of-dict)) then         txa                              return (not changed)         beq   MV4A                     else         sec                              return (changed)MV4A     rts                            end if;; Get index of next free visMembers element, address of element.; Return carry flag to indicate whether or not a free slot was found.;GetVM    lda   free                     X := index into freeArray         asl   A         taxGVM1     lda   freeArray,X         bne   GVM2         inx         inx         cpx   #10                      sanity check         blt   GVM1A         sec         rtsGVM1A    inc   free         bra   GVM1;; Calculate visMembers address from index contained in free variable.;GVM2     pea   0                        calculate address into visMembers array:         pea   0                          free * 35         lda   free         pha         pea   35         _Multiply         pla         clc         adc   #visMembers         sta   VMPtr         pla         adc   #^visMembers         sta   VMPtr+2         clc         rts         end************************************************** MyWindow - Checks if front window is one of ours.** Output:*        carry flag - set if its one of ours**************************************************MyWindow start         using SIData         lda   numWindows               Any windows up?         bne   MW1         clc         rts;;  Now check if the window is one of ours.;MW1      pea   0                        room for integer result - outer call         pea   0                        room for long result - inner call         pea   0         _FrontWindow                   get grafPort ptr of active window         lda   1,S                      save ptr in case it's ours         sta   currWindow         lda   3,S         sta   currWindow+2         _GetSysWFlag                   Is system window or application window?         pla         beq   MW2         clc         rts;;  It's one of ours, so calculate offsets in arrays.;MW2      pea   0         pea   0         lda   currWindow+2         pha         lda   currWindow         pha         _GetWRefCon         pla         sta   currWindNum              get window's #         plx                            get window's type         stx   currWindTyp         asl   A                        get 2-byte offset into integer arrays         sta   currIndex2         asl   A                        get 4-byte offset into long arrays         sta   currIndex4         sec         rts         end************************************************** NullRtn - Do nothing.**************************************************NullRtn  start         rts         end************************************************** OpenDict - Load new dictionary file.**************************************************OpenDict start         using SIData;; Before opening a new dictionary, check if the current dictionary has changed.; If so, give user a chance to save it.;         lda   dictChanged         beq   OD1         jsr   WantToSaveDict         bcc   OD1         brl   Err3;; If the current dictionary is associated with a file, release the memory; it uses.;OD1      lda   dictFileFlag         beq   OD2         lda   dictPathHandle         ora   dictPathHandle+2         beq   OD1A         ph4   dictPathHandle         _DisposeHandle         stz   dictPathHandle         stz   dictPathHandle+2OD1A     stz   dictPathName         stz   dictPathName+2;; We allow a dictionary file to be opened even if the dictionary editor isn't; currently up.  However, we need to ensure it's the front window.;OD2      lda   dictUpFlag         beq   OD3         ph4   dictWindowPtr         _SelectWindow         lda   #dictWindNum             set global info for front window         sta   currWindNum         lda   #dictTyp         sta   currWindTyp         lda   dictWindowPtr         sta   currWindow         lda   dictWindowPtr+2         sta   currWindow+2         lda   #dictIndex2         sta   currIndex2         lda   #dictIndex4         sta   currIndex4;; Open the file, read it into a buffer, and then close the file.; Convert handle to GS/OS output string to pointer to GS/OS input string.;OD3      lda   rrPathRef         sta   dictPathHandle         sta   handle                   get ready to dereference the handle         lda   rrPathRef+2         sta   dictPathHandle+2         sta   handle+2         ldy   #2                       dereference the handle         lda   [handle],Y         sta   openPath+2         lda   [handle]                 need to skip total length byte of GS/OS         clc                              output string         adc   #2         sta   openPath         bcc   OD3A         inc   openPath+2OD3A     _OpenGS  openRec               open the file         bcc   OD3B                     handle error         pea   openErr         jsr   HandleError         brl   Err3OD3B     lda   openRef                  get ready to read and then close the file         sta   readRef         sta   closeRef;; If the file is empty, close the file and skip loading it.; Initialize the dictionary to empty.;         lda   openSize         ora   openSize+2         bne   OD5         _CloseGS closeRec         jsr   EmptyDict         bcc   OD4         brl   Err3OD4      jsr   SetDictName         brl   OD6;; If the file is not empty, allocate a read buffer, read and then close the; file.  Load it into the program.;OD5      ph4   #0                       allocate memory block to read files         ph4   openSize                 read in the whole thing         ph2   myID         pea   $C010                    locked, can't move, don't purge, don't;                                         cross bank bound., don't page align         ph4   #0                       no absolute address specified         _NewHandle         bcc   OD5A                     handle error:         plx                              throw away zero handle         plx         pea   memErr         jsr   HandleError         _CloseGS  closeRec         brl   Err3OD5A     pla         sta   handle                   get ready to dereference the handle         pla         sta   handle+2         lda   [handle]                 dereference memory handle         sta   readBuffer         ldy   #2         lda   [handle],Y         sta   readBuffer+2         lda   openSize                 get # bytes to read         sta   readRequest         lda   openSize+2         sta   readRequest+2         _ReadGS  readRec               make the Read call         php                            save error flag from read         _CloseGS closeRec         plp         bcc   OD5B                     handle error         pea   readErr         jsr   HandleError         brl   Err2OD5B     ph4   readBuffer         ph4   transferCount         jsr   LoadDict         bcc   OD5C         brl   Err2OD5C     jsr   SetDictName         lda   handle+2         pha         lda   handle         pha         _DisposeHandle;; Perform final clean-up.;OD6      lda   #1                       set window's fileFlag         sta   dictFileFlag         lda   openPath                 set window's pathName         sta   dictPathName         lda   openPath+2         sta   dictPathName+2         lda   rrPathRef                set window's pathHandle         sta   dictPathHandle         lda   rrPathRef+2         sta   dictPathHandle+2         ph4   rrNameRef                dispose of SFO's nameRef handle         _DisposeHandle         rts;; Error clean-up.;Err2     lda   handle+2         pha         lda   handle         pha         _DisposeHandleErr3     ph4   rrPathRef         _DisposeHandle         ph4   rrNameRef         _DisposeHandle         stz   dictPathName         stz   dictPathName+2         stz   dictPathHandle         stz   dictPathHandle+2         rts         end************************************************** SetDictName - Build filename when open dictionary*               file.**************************************************SetDictName start         using SIData         lda   rrNameRef                get filename returned by SFO         sta   handle2                  get ready to dereference the handle         lda   rrNameRef+2         sta   handle2+2         ldy   #2                       get filename to display in windo's         lda   [handle2],Y                title bar -- dereference the handle         sta   ptr3+2                     and move beyond initial length words         lda   [handle2]                  of GS/OS output string         clc         adc   #2         sta   ptr3         bcc   SDN1         inc   ptr3+2SDN1     lda   [ptr3]                   get length of filename         cmp   #16                      we're restricting filenames to 15 chars         blt   SDN2         lda   #15SDN2     sta   count                    save the size for now         lda   ptr3                     final adjustment to filename pointer --         clc                              move beyond its length word         adc   #2         sta   ptr3         bcc   SDN3         inc   ptr3+2SetDefaultDName entry                   entry used for default filenameSDN3     ldy   #0                       move filename pointed to by ptr3 to         ldx   count                      dictName         stx   fnTextSize               set variables for filename stat text         stx   dictName2Size         short MTop1     lda   [ptr3],Y         sta   dictName2,Y         iny         dex         bne   Top1         long  M;; Recreate static text box holding dictionary's filename.;         lda   #^dictName2              record address of filename in         sta   fnText+2                   template         lda   #dictName2         sta   fnText         lda   dictUpFlag               don't recreate control if window         bne   SDN4                       not up         clc         rtsSDN4     ph4   fnCtlHndl                dispose of current control         _HideControl         ph4   fnCtlHndl                dispose of current control         _DisposeControl         pea   0                        room for long result         pea   0         ph4   dictWindowPtr         pea   0                        will pass pointer to template         ph4   #fnTempl         _NewControl2         bcc   Rts                      handle error:         plx                              throw away zero handle         plx         pea   ctlErr                      report error         jsr   HandleError         jsr   DoClose                    close window         sec                              return (error)         rtsRts      pla                            record new control handle         sta   fnCtlHndl         pla         sta   fnCtlHndl+2         clc         rts         end************************************************** SetFileWName - Build filename when open a file.**************************************************SetFileWName start         using SIData         lda   rrNameRef                get filename returned by SFO         sta   handle2                  get ready to dereference the handle         lda   rrNameRef+2         sta   handle2+2         ldy   #2                       get filename to display in windo's         lda   [handle2],Y                title bar -- dereference the handle         sta   ptr3+2                     and move beyond initial length words         lda   [handle2]                  of GS/OS output string         clc         adc   #2         sta   ptr3         bcc   GON1         inc   ptr3+2GON1     lda   [ptr3]                   get length of filename         cmp   #15                      we're restricting these names to 15 chars         ble   GON1A                    save the size for now         lda   #15GON1A    pha         lda   ptr3                      final adjustment to filename pointer --         clc                              move beyond its length word         adc   #2         sta   ptr3         bcc   GON2         inc   ptr3+2GON2     lda   wTitle+2                 move filename passed by SFO to wTitle+2         sta   ptr2+2         lda   wTitle         sta   ptr2         pla                            X := counter         tax         inc   A                        place length byte at beg. of title         inc   A         sta   [ptr2]         ldy   #1                       place blank before title         lda   #' '         sta   [ptr2],Y         clc                            adjust title pointer for length byte         lda   ptr2                       and initial blank         adc   #2         sta   ptr2         lda   ptr2+2         adc   #0         sta   ptr2+2         ldy   #0         short MTop1     lda   [ptr3],Y         sta   [ptr2],Y         iny         dex         bne   Top1         lda   #' '                     place trailing blank in title         sta   [ptr2],Y         long  M         ph4   rrNameRef                we don't need this handle anymore         _DisposeHandle         rts         end************************************************** SetNoFileDName - Use name of < no file > for dictionary.**************************************************SetNoFileDName start         using SIData;; Set dict's filename to none.;         lda   dictName1Size         sta   fnTextSize         lda   #^dictName1              record address of filename in         sta   fnText+2                   template         lda   #dictName1         sta   fnText         lda   dictUpFlag               if window is up, recreate control         bne   SNF1         rts;; Recreate list control, now that list is empty.;SNF1     ph4   fnCtlHndl                dispose of current control         _HideControl         ph4   fnCtlHndl         _DisposeControl         pea   0                        room for long result         pea   0         ph4   dictWindowPtr         pea   0                        will pass pointer to template         ph4   #fnTempl         _NewControl2         bcc   SNF2                     handle error         plx                              throw away zero handle         plx         pea   ctlErr                      report error         jsr   HandleError         rtsSNF2     pla                            record new control handle         sta   fnCtlHndl         pla         sta   fnCtlHndl+2         rts         end************************************************** SetPhonWName - Create phonetic window's name.**************************************************SetPhonWName start         using SIData;;  Convert window number to ASCII character.;         lda   currWindNum         clc                            calc. size of window's title         adc   #$30         short M         sta   num         long  M;;  Now move temporary name to window names array.;         lda   wTitle         sta   ptr2         lda   wTitle+2         sta   ptr2+2         ldy   #0         lda   size         and   #$00FF         tax         short MTop2     lda   size,Y         sta   [ptr2],Y         iny         dex         bpl   Top2         long  M         rtssize     dc    i1'13'         dc    c' Phonetics 'num      dc    c'  '         end************************************************** SetTextWName - Create text window's name.**************************************************SetTextWName start         using SIData;;  Convert window number to ASCII character.;         lda   currWindNum         clc                            calc. size of window's title         adc   #$30         short M         sta   num         long  M;;  Now move temporary name to window names array.;         lda   wTitle         sta   ptr2         lda   wTitle+2         sta   ptr2+2         ldy   #0         lda   size         and   #$00FF         tax         short MTop2     lda   size,Y         sta   [ptr2],Y         iny         dex         bpl   Top2         long  M         rtssize     dc    i1'8'         dc    c' Text 'num      dc    c'  '         end************************************************** ShutDown - Unload the tools we started.**************************************************ShutDown start         using SIData         ph2   myID                     dispose of all memory we allocated         _DisposeAll         _FemaleShutDown                shut down speech tools         _MaleShutDown         _ParseShutDown         _SpeechShutDown         pea   1                        shut down all other tools we started         ph4   startStopRef         _ShutDownTools         bcc   Rts         brl   FatalErrRts      rts         end************************************************** SpeakPhonetics - Speak selected phonetics.**************************************************SpeakPhonetics start         using SIData         jsr   GetPhonetics             dump text into our buffer         bcc   SP0                      just return if unable to get text         rts;; Call Text Edit's GetSelection to get starting/ending offsets for current; selection.;SP0      ph4   #selStart         ph4   #selEnd         ldx   currIndex4         lda   teHandle+2,X         pha         lda   teHandle,X         pha         _TEGetSelection         bcc   SP1                      handle error         pea   TEErr         jsr   HandleError         rts;; If there is no current selection, we assume user wants to SPEAK the entire; window.  In this case, we set start of selection to 0, end of selection to; end of text.;SP1      cmp4  selStart,selEnd         bne   SP2         stz   selStart         stz   selStart+2         lda   charCount         sta   selEnd         lda   charCount+2         sta   selEnd+2         dec4  selEnd;; Get the pointer to the text from the buffer handle, adjusting pointer to the; start of the selection.;SP2      inc4  selStart                 1st byte is for length         lda   phBuffer                 put handle into DP location         sta   handle2         lda   phBuffer+2         sta   handle2+2         lda   [handle2]                dereference handle         sta   ptr2         ldy   #2         lda   [handle2],Y         sta   ptr2+2         clc                            add starting offset to pointer         lda   ptr2         dec   A                        back up 1 - 1st byte is length byte         adc   selStart         sta   ptr2         lda   ptr2+2         adc   selStart+2         sta   ptr2+2;; Now we're ready to enter our SPEAK loop.  As long as the text to be spoken; exceeds 255 characters (SPEAK accepts a Pascal-style string), we need to; "doctor" the string to speak.;SP3      sub4  selEnd,selStart,selLength        get length of text to speak         inc4  selLength         cmp4  selLength,#0             if length of string = 0, we're done         jeq   Rts         bpl   SP4         brl   RtsSP4      cmp4  selLength,#256           ensure length doesn't exceed 255 chars.         blt   SP5         lda   #255         sta   selLength         stz   selLength+2         ldy   selLength                ensure string doesn't end in middle of         lda   [ptr],Y                    2-char. vowel         cmp   #'A'         blt   SP5         cmp   #'['         bge   SP5         dey         lda   [ptr],Y         cmp   #'A'         blt   BackUp         cmp   #'['         bge   BackUp         iny         bra   SP5BackUp   dec4  selLengthSP5      lda   [ptr2]                   save char. we'll be overwriting with         pha                              length byte         short M         lda   selLength         sta   [ptr2]         long  M         lda   volume+1                 SPEAK the string         and   #$00FF                     convert character into integer         sec         sbc   #$30         pha         lda   speed+1         and   #$00FF                     convert character into integer         sec         sbc   #$30         pha         lda   pitch+1         and   #$00FF                     convert character into integer         sec         sbc   #$30         pha         lda   ptr2+2                     address of string to SPEAK         pha         lda   ptr2         pha         lda   maleVoice         beq   SP6         _MaleSpeak                       call male or female speech, as         bra   SP7                          appropriateSP6      _FemaleSpeakSP7      pla                            restore char we overwrote in buffer         sta   [ptr2]         add4  selStart,selLength       update start of next string to SPEAK         lda   ptr2                     update pointer into text         clc         adc   selLength         bcc   SP9         inc   ptr2+2SP9      sta   ptr2         brl   SP3Rts      ldy   #4                       unlock block         lda   [handle2],Y         and   #$BFFF         sta   [handle2],Y         rts         end************************************************** SpeakText - Speak selected text.**************************************************SpeakText start         using SIData         jsr   GetText                  dump text into our buffer         bcc   ST0                      just return if unable to get text         rts;; Call Text Edit's GetSelection to get starting/ending offsets for current; selection.;ST0      ph4   #selStart         ph4   #selEnd         ldx   currIndex4         lda   teHandle+2,X         pha         lda   teHandle,X         pha         _TEGetSelection         bcc   ST2                      handle error         pea   TEErr         jsr   HandleError         rts;; If there is no current selection, we assume user wants to SAY the entire; window.  In this case, we set start of selection to 0, end of selection to; end of text.;ST2      cmp4  selStart,selEnd         bne   ST3         stz   selStart         stz   selStart+2         lda   charCount         sta   selEnd         lda   charCount+2         sta   selEnd+2;; Get the pointer to the text from the buffer handle, adjusting pointer to the; start of the selection.;ST3      dec4  selEnd                   end is always 1 more than it should be         lda   buffer                   put handle into DP location         sta   handle         lda   buffer+2         sta   handle+2         lda   [handle]                 dereference handle         sta   ptr         ldy   #2         lda   [handle],Y         sta   ptr+2         clc                            add starting offset to pointer         lda   ptr         adc   selStart         sta   ptr         lda   ptr+2         adc   selStart+2         sta   ptr+2;; Now we're ready to enter our SAY loop.  As long as the text to be spoken; exceeds 255 characters (SAY accepts a Pascal-style string), we need to "doctor"; the string to speak.;ST4      sub4  selEnd,selStart,selLength        get length of text to speak         inc4  selLength         cmp4  selLength,#0             if length of string = 0, we're done         jeq   Rts         bpl   ST5         brl   RtsST5      cmp4  selLength,#256           ensure length doesn't exceed 255 chars.         blt   ST6         lda   #255         sta   selLength         stz   selLength+2ST6      short M         lda   selLength                stuff length byte into beginning         sta   sayLength                  of string to speak         ldy   selLength                move text from buffer to SAY string         deyTop1     lda   [ptr],Y         sta   sayString,Y         dey         bpl   Top1         long  M         ph4   #sayLength               SAY the string         _Say         add4  selStart,selLength       update start of next string to SAY         clc                            update pointer into text         lda   ptr         adc   selLength         sta   ptr         lda   ptr+2         adc   selLength+2         sta   ptr+2         brl   ST4Rts      ldy   #4                       unlock block         lda   [handle],Y         and   #$BFFF         sta   [handle],Y         rts         end************************************************** WantToSave - Ask user if they'd like to save*              a file before closing its window.** Outputs:*        carry - set if Cancel selected**************************************************WantToSave start         using SIData;; Copy filename to save alert template.;         ldx   currIndex4               ptr := wNamePtr [X]         lda   wNamePtr,X         sta   ptr         lda   wNamePtr+2,X         sta   ptr+2         lda   [ptr]                    A := sizeof (wNamePtr [X]^)         and   #$00FF         tax                            X := A;        inc   A                        A++         sta   saveFNSize               saveFNSize := A         ldy   #0                       Y := 0         short MWTS0     lda   [ptr],Y                  saveFN := ptr^         sta   saveFN,Y         iny         dex         bne   WTS0         lda   #'?'                     filename in alert concludes a query         sta   saveFN,Y         lda   saveFNSize               because of '?' string size in display         sta   saveFN                     is 1 larger than that stored         long  M;;  Bring up alert.;         pea   0                        room for result         ph4   #saveAlert               address of alert template         ph4   #0                       use default filter procedure         _NoteAlert         pla                            get item hit         cmp   #1                       do they want to save file?         bne   WTS1         jsr   DoSave         rtsRts      clc         rtsWTS1     cmp   #2                       cancel operation         bne   Rts         sec         rts         end************************************************** WantToSaveDict - Ask user if they'd like to save*                  current dictionary before disposing*                  of it.** Outputs:*        carry - set if Cancel selected**************************************************WantToSaveDict start         using SIData;;  Bring up alert.;         pea   0                        room for result         ph4   #saveDictAlert           address of alert template         ph4   #0                       use default filter procedure         _NoteAlert         pla                            get item hit         cmp   #1                       do they want to save file?         bne   WTSD1         lda   #dictWindNum             set global info for dict window         sta   currWindNum         lda   #dictTyp         sta   currWindTyp         lda   dictWindowPtr         sta   currWindow         lda   dictWindowPtr+2         sta   currWindow+2         lda   #dictIndex2         sta   currIndex2         lda   #dictIndex4         sta   currIndex4         jsr   DS1                      yes - execute save dict. rtnRts      clc                            no - just return         rtsWTSD1    cmp   #2                       cancel operation         bne   Rts         sec         rts         end************************************************** WriteDictFile - Write dictionary to disk.** Output:*        carry flag - set if error; otherwise clear**************************************************WriteDictFile start         using SIData;; Prepare to begin writing dictionary to disk:  reset dictionary to top, then; lock the buffer we'll be writing into.;         pea   0                        reset dictionary to top         _DictInit         stz   nextEntry         ph4   buffer                   lock block; if block has been purged,         _HLock                           attempt to allocate a new one         bcs   WDF0         cmp4  bufferSize,#1024         else if block size < 1K, attempt to         bge   WDF0                       grow it         ph4   #1024         ph4   buffer         _SetHandleSize         bcc   WDF000         bcs   WDFErrWDF0     pea   0         pea   0         ph4   #1024         ph2   myID         pea   $C010         pea   0         pea   0         _NewHandle         bcc   WDF00         plx         plxWDFErr   pea   memErr         jsr   HandleError         sec         rtsWDF00    pl4   bufferWDF000   lda   #1024         sta   bufferSize         stz   bufferSize+2         lda   buffer                   dereference buffer's handle to get         sta   handle                     pointer to data to write         lda   buffer+2         sta   handle+2         lda   [handle]                 store pointer to data for write ops         sta   writeData         ldy   #2         lda   [handle],Y         sta   writeData+2;; Main loop:  while not at end of dictionary, fill the buffer with dictionary;             entries, then write the buffer to disk.;WDF1     pea   0                        room for long result         pea   0         ph4   #word1         ph4   #word2         _DictDump                      get 1st dictionary entry         pla         plaWDF1A    stz   writeRequest             init. FillBuffer variables         stz   writeRequest+2         lda   [handle]         sta   ptr         ldy   #2         lda   [handle],Y         sta   ptr+2         ldy   #0         jsr   FillBuffer         php                            save flag returned from FillBuffer rtn         _WriteGS  writeRec             write buffer to disk         bcc   WDF1B         pea   writeErr                     err msg = "Error when writing file"         jsr   HandleError         plp         bra   WDF2WDF1B    plp                            retrieve flag returned from FillBuffer         bcc   WDF1A;; Final clean-up:  Close the file, set dictionary variables.;WDF2     _CloseGS  closeRec             close the file         ldy   #4                       unlock the buffer         lda   [handle],Y         and   #$7FFF         sta   [handle],Y         pea   0                        reset dict. to top         _DictInit         stz   dictChanged         rts;; FillBuffer:  fill the write buffer with dictionary entries.;FillBuffer anop         lda   word1                    check if we've gotten all entries         and   #$00FF         bne   FB1         sec                            yes - set flag that we're done         rtsFB1      lda   writeRequest             no - check if new entries will fit in         sta   tmp4                       buffer         lda   writeRequest+2         sta   tmp4+2         lda   word1                    add size of English word         and   #$00FF         clc         adc   tmp4         bcc   FB1A         inc   tmp4+2FB1A     sta   tmp4         lda   word2                    add size of phonetic word         and   #$00FF         clc         adc   tmp4         bcc   FB1B         inc   tmp4+2FB1B     sta   tmp4         lda   #2                       add length bytes to total         clc         adc   tmp4         bcc   FB1C         inc   tmp4+2FB1C     sta   tmp4         lda   tmp4+2                   ensure that new total size is         cmp   bufferSize+2               less than or equal to bufferSize         blt   FB2         bne   FB1D         lda   tmp4         cmp   bufferSize         blt   FB2         beq   FB2FB1D     clc                            set flag that we're OK, then exit         rts;; We're not at the end of the dictionary, and the current entry will fit in; our buffer, so we move the entries to the buffer, then get the next entry.;FB2      lda   tmp4                     update current amt. chars. in buffer         sta   writeRequest         lda   tmp4+2         sta   writeRequest+2         lda   word1                    move English word to buffer         and   #$00FF         sta   count         ldx   #0         short MFB2A     lda   word1,X         sta   [ptr],Y         inx         iny         dec   count         bpl   FB2A         long  M         lda   word2                    move phonetic word to buffer         and   #$00FF         sta   count         ldx   #0         short MFB2B     lda   word2,X         sta   [ptr],Y         inx         iny         dec   count         bpl   FB2B         long  M         phy                            save index into buffer         pea   0                        room for long result         pea   0         ph4   #word1         ph4   #word2         _DictDump                      get next dictionary entry         pla         pla         ply         brl   FillBuffer         end************************************************** WriteTextFile - Write text window to disk.**************************************************WriteTextFile start         using SIDatadirtyFlag equ  30                       flag read from text edit record         ldx   currIndex4         lda   teHandle,X               need to get and change dirty flag         sta   handle                     from text edit record         lda   teHandle+2,X         sta   handle+2         lda   [handle]                 dereference handle         sta   ptr         ldy   #2         lda   [handle],Y         sta   ptr+2;;  Determine if file has changed and needs to be saved.;         ldy   #dirtyOffset             access flag containing dirty bit in         lda   [ptr],Y                   TE record         sta   dirtyFlag         and   #isDirty         bne   WTF1         rts                            if not changed, no need to saveWTF1     jsr   GetText         bcc   WTF2         rtsWTF2     lda   buffer                   dereference buffer's handle to get         sta   handle                     pointer to data to write         lda   buffer+2         sta   handle+2         lda   [handle]         sta   writeData         ldy   #2         lda   [handle],Y         sta   writeData+2         _WriteGS  writeRec             write window to disk         bcc   WTF3         pea   writeErr                     err msg = "Error when writing file."         jsr   HandleError         _CloseGS closeRec         sec         rtsWTF3     ldy   #dirtyOffset             clear the dirty bit after saving file         lda   dirtyFlag         and   #$FFBF         sta   [ptr],Y         ldy   #4                       unlock the buffer         lda   [handle],Y         and   #$7FFF         sta   [handle],Y         _CloseGS  closeRec         clc         rts         end