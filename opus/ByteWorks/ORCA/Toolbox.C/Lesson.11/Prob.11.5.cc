/***************************************************************** Text Editor** This is a simple, TextEdit based text editor.****************************************************************/#pragma lint -1#include <stdlib.h>#include <string.h>#include <stdio.h>#include <orca.h>#include <Event.h>#include <Menu.h>#include <QuickDraw.h>#include <Window.h>#include <Desk.h>#include <Resources.h>#include <Memory.h>#include <Locator.h>#include <MiscTool.h>#include <Print.h>#include <Font.h>#include <Control.h>#include <TextEdit.h>#include <GSOS.h>#include <StdFile.h>#define appleMenu       1               /* Menu ID #s (also resource ID #s) */#define fileMenu        2#define editMenu        3#define fontMenu        4#define styleMenu       5#define sizeMenu        6#define appleAbout      257#define fileNew         260#define fileOpen        261#define fileClose       255#define fileSave        262#define fileSaveAs      263#define filePageSetup   264#define filePrint       265#define fileQuit        256#define editUndo        250#define editCut         251#define editCopy        252#define editPaste       253#define editClear       254#define fontFirst       1000#define stylePlain      280#define styleBold       281#define styleItalic     282#define styleUnderline  283#define styleOutline    284#define styleShadow     285#define styleLeft       300#define styleRight      301#define styleFill       302#define styleCenter     303#define size9           290#define size10          291#define size12          292#define size14          293#define size18          294#define size24          295#define teControl       1001            /* text edit control ID */#define maxName 80                      /* max length of a window title */typedef struct documentStruct {         /* information about our document */   struct documentStruct *next;         /* next document */   GrafPortPtr wPtr;                    /* window pointer */   char wName[maxName+1];               /* window name */   BOOLEAN onDisk;                      /* does the file exist on disk? */   Handle fileName;                     /* file name handle or NULL */   Handle pathName;                     /* full path name handle or NULL */   PrRecHndl prHandle;                  /* print record */   } documentStruct;typedef documentStruct *documentPtr;    /* document pointer */BOOLEAN done;                           /* are we done, yet? */documentPtr documents;                  /* our documents */int untitledNum;                        /* number for the next untitled window */EventRecord myEvent;                    /* event record */unsigned lastFont;                      /* menu ID for checked font family *//***************************************************************** GetString** Get a string from the resource fork** Parameters:*    resourceID - resource ID of the rCString resource** Returns: pointer to the string; NULL for an error** Notes: The string is in a locked resource handle.  The caller*    should call FreeString when the string is no longer needed.*    Failure to do so is not catastrophic; the memory will be*    deallocated when the program is shut down.****************************************************************/char *GetString (int resourceID){Handle hndl;                            /* resource handle */hndl = LoadResource(rCString, resourceID);if (toolerror() == 0) {   HLock(hndl);   return (char *) (*hndl);   }return NULL;}/***************************************************************** Free a resource string** Parameters:*    resourceID - resource ID of the rCString to free****************************************************************/void FreeString (int resourceID){ReleaseResource(-3, rCString, resourceID);}/***************************************************************** FlagError** Flag an error** Parameters:*    error - error message number*    tError - toolbox error code; 0 if none****************************************************************/void FlagError (int error, int tError){#define errorAlert 2000                 /* alert resource ID */#define errorBase 2000                  /* base resource ID for fortunes */char *substArray;                       /* substitution "array" */char *errorString;                      /* pointer to the error string */                                        /* form the error string */errorString = GetString(errorBase + error);substArray = NULL;if (errorString != NULL) {   substArray = malloc(strlen(substArray)+9);   if (substArray != NULL)      strcpy(substArray, errorString);   FreeString(errorBase + error);   }if (substArray != NULL) {   if (tError != 0)                     /* add the tool error number */      sprintf(&substArray[strlen(substArray)], " ($%04X)", tError);                                        /* show the alert */   AlertWindow(awCString+awResource, (Pointer) &substArray, errorAlert);   free(substArray);   }#undef errorAlert#undef errorBase}/***************************************************************** TextEditChange** Check to see if the text or style information has changed** Parameters:*    id - control ID for the record to check*    wPtr - window containing the record** Returns: TRUE if the record changed, FALSE if not or error****************************************************************/BOOLEAN TextEditChange (unsigned id, GrafPortPtr wPtr){BOOLEAN changed;                        /* are there any changes? */CtlRecHndl ctlHandle;                   /* control handle */unsigned char *ptr;                     /* work pointer */ctlHandle = GetCtlHandleFromID(wPtr, id);changed = FALSE;if (toolerror() == 0) {   HLock((Handle) ctlHandle);   ptr = (unsigned char *) (((unsigned long) (*ctlHandle)) + 16);   changed = ((*ptr) & 0x40) != 0;   HUnlock((Handle) ctlHandle);   }return changed;}/***************************************************************** ClearTextEdit** Clear the changed flag for the text edit record** Parameters:*    id - control ID for the record to check*    wPtr - window containing the record****************************************************************/void ClearTextEdit (unsigned id, GrafPortPtr wPtr){CtlRecHndl ctlHandle;                   /* control handle */unsigned char *ptr;                     /* work pointer */ctlHandle = GetCtlHandleFromID(wPtr, id);if (toolerror() == 0) {   HLock((Handle) ctlHandle);   ptr = (unsigned char *) (((unsigned long) (*ctlHandle)) + 16);   *ptr = (*ptr) & 0xBF;   HUnlock((Handle) ctlHandle);   }}/***************************************************************** LoadDocument** Load a document file from disk** Parameters:*    dPtr - pointer to the document to load** Returns: TRUE if successful, else FALSE****************************************************************/BOOLEAN LoadDocument (documentPtr dPtr){RefNumRecGS clRec;                      /* CloseGS record */OpenRecGS opRec;                        /* OpenGS record */IORecGS rdRec;                          /* ReadGS record */BOOLEAN success;                        /* was the operation successful? */GrafPortPtr port;                       /* caller's GrafPort */Rect r;                                 /* our port rect */Handle tHand;                           /* file's handle */LongWord length;                        /* length of the text */LongWord *lPtr, *tPtr;                  /* pointers to the parts of the file */success = TRUE;                         /* assume we will succeed */opRec.pCount = 12;                      /* open the file */HLock(dPtr->pathName);opRec.pathname = (GSString255Ptr) (((long) (*(dPtr->pathName))) + 2);opRec.requestAccess = 1;opRec.resourceNumber = 0;opRec.optionList = NULL;OpenGS(&opRec);if (toolerror() != 0) {   FlagError(4, toolerror());   success = FALSE;   }else {   tHand =                              /* allocate memory for the file */      NewHandle(opRec.eof, userid(), 0x8000, NULL);   if (toolerror() != 0) {      FlagError(2, toolerror());      success = FALSE;      }   else {      rdRec.pCount = 4;                 /* read the file */      rdRec.refNum = opRec.refNum;      rdRec.dataBuffer = *tHand;      rdRec.requestCount = opRec.eof;      ReadGS(&rdRec);      if (toolerror() != 0) {         FlagError(4, toolerror());         success = FALSE;         }      else {         port = GetPort();              /* get our port */         SetPort(dPtr->wPtr);         lPtr = (LongWord *) (*tHand);         length = *lPtr;         tPtr = (LongWord *) (((LongWord) lPtr) + 4);         lPtr = (LongWord *) (((LongWord) tPtr) + length + 4);         TESetText(5, (Ref) tPtr, length, 0, (Ref) lPtr, NULL);         SetPort(port);                 /* restore caller's port */         }      DisposeHandle(tHand);      }   clRec.pCount = 1;                    /* close the file */   clRec.refNum = opRec.refNum;   CloseGS(&clRec);   }HUnlock(dPtr->pathName);                /* unlock the name handle */ClearTextEdit(teControl, dPtr->wPtr);   /* no changes */return success;                         /* return the success flag */}/***************************************************************** StyleLength** Finds the length of a style record** Parameters:*    hand - style handle** Returns: Length in bytes****************************************************************/LongWord StyleLength (Handle hand){LongWord len;                           /* length of the buffer */LongWord *lPtr;                         /* used to fetch values from the record */HLock(hand);                            /* dereference the handle */lPtr = (LongWord *) (((LongWord) (*hand)) + 2);len = 14;                               /* account for lengths, version field */len += *lPtr;                           /* account for ruler list */lPtr = (LongWord *) (((LongWord) lPtr) + 4 + *lPtr);len += *lPtr;                           /* account for style list */lPtr = (LongWord *) (((LongWord) lPtr) + 4 + *lPtr);len += (*lPtr)*8;                       /* account for style item structures */HUnlock(hand);return len;}/***************************************************************** SaveDocument** Save a document file to disk** Parameters:*    dPtr - pointer to the document to save****************************************************************/void SaveDocument (documentPtr dPtr){RefNumRecGS clRec;                      /* CloseGS record */CreateRecGS crRec;                      /* CreateGS record */NameRecGS dsRec;                        /* DestroyGS record */OpenRecGS opRec;                        /* OpenGS record */IORecGS wrRec;                          /* WriteGS record */LongWord length;                        /* length of the text buffer */GrafPortPtr port;                       /* caller's GrafPort */Handle tHand;                           /* text handle */Handle sHand;                           /* style handle */if (dPtr == NULL)                       /* make sure there is a document */   return;port = GetPort();                       /* use our GrafPort */SetPort(dPtr->wPtr);                                        /* get the text */length = TEGetText(0x19, (Ref) &tHand, 0, 3, (Ref) &sHand, NULL);if (toolerror() != 0) {   FlagError(5, toolerror());   SetPort(port);   return;   }HLock(dPtr->pathName);                  /* lock the path name */dsRec.pCount = 1;                       /* destroy any old file */dsRec.pathname = (GSString255Ptr) (((long) (*(dPtr->pathName))) + 2);DestroyGS(&dsRec);crRec.pCount = 5;                       /* create a new file */crRec.pathname = (GSString255Ptr) (((long) (*(dPtr->pathName))) + 2);crRec.access = 0xC3;crRec.fileType = 0x06;crRec.auxType = 0;crRec.storageType = 1;CreateGS(&crRec);if (toolerror() != 0)   FlagError(5, toolerror());else {   opRec.pCount = 3;                    /* open the file */   opRec.pathname = (GSString255Ptr) (((long) (*(dPtr->pathName))) + 2);   opRec.requestAccess = 2;   OpenGS(&opRec);   if (toolerror() != 0)      FlagError(5, toolerror());   else {      wrRec.pCount = 4;                 /* write the text buffer length */      wrRec.refNum = opRec.refNum;      wrRec.dataBuffer = (Pointer) (&length);      wrRec.requestCount = 4;      WriteGS(&wrRec);      if (toolerror() != 0) {         FlagError(5, toolerror());         goto cleanUp;         }      HLock(tHand);                     /* write the text buffer */      wrRec.dataBuffer = *tHand;      wrRec.requestCount = length;      WriteGS(&wrRec);      if (toolerror() != 0) {         FlagError(5, toolerror());         goto cleanUp;         }      length = StyleLength(sHand);      /* get the style buffer length */      wrRec.requestCount = 4;           /* write the style buffer length */      wrRec.dataBuffer = (Pointer) &length;      WriteGS(&wrRec);      if (toolerror() != 0) {         FlagError(5, toolerror());         goto cleanUp;         }      HLock(sHand);                     /* write the style buffer */      wrRec.dataBuffer = *sHand;      wrRec.requestCount = length;      WriteGS(&wrRec);      if (toolerror() != 0) {         FlagError(5, toolerror());         goto cleanUp;         }      dPtr->onDisk = TRUE;              /* exists on disk */      ClearTextEdit(teControl, dPtr->wPtr); /* no changes */cleanUp:      clRec.pCount = 1;                 /* close the file */      clRec.refNum = opRec.refNum;      CloseGS(&clRec);      }   }DisposeHandle(tHand);                   /* get rid of the text and style buffers */DisposeHandle(sHand);HUnlock(dPtr->pathName);                /* unlock the name handle */SetPort(port);                          /* restore the caller's GrafPort */}/***************************************************************** CloseDocument** Close a document and its associated window** Parameters:*    dPtr - pointer to the document to close; may be NULL** Returns: TRUE for a normal close, FALSE if the user canceled****************************************************************/void DoSave (documentPtr dPtr);         /* forward declaration */BOOLEAN CloseDocument (documentPtr dPtr){#define alertID 2                       /* alert string resource ID */char name[maxName], *namePtr[] = {name}; /* document name */documentPtr lPtr;                       /* pointer to the previous document */unsigned button;                        /* button pushed */if (dPtr != NULL) {                     /* check for changes */   while (TextEditChange(teControl, dPtr->wPtr)) {      strcpy(name, &dPtr->wName[2]);      name[strlen(name)-2] = (char) 0;      button = AlertWindow(awCString+awResource, (Pointer) namePtr, alertID);      switch (button) {         case 0: DoSave(dPtr);                          break;         case 1: ClearTextEdit(teControl, dPtr->wPtr);  break;         case 2: return FALSE;                          break;         }      }   CloseWindow(dPtr->wPtr);             /* close the window */   if (documents == dPtr)               /* remove dPtr from the list when... */      documents = dPtr->next;           /* ...dPtr is the first document */   else {                               /* ...dPtr is not the first document */      lPtr = documents;      while (lPtr->next != dPtr)         lPtr = lPtr->next;      lPtr->next = dPtr->next;      }   if (dPtr->fileName != NULL)          /* dispose of the name buffers */      DisposeHandle(dPtr->fileName);   if (dPtr->pathName != NULL)      DisposeHandle(dPtr->pathName);   if (dPtr->prHandle != NULL)          /* dispose of the print record */      DisposeHandle((Handle) dPtr->prHandle);   free(dPtr);                          /* dispose of the document record */   }return TRUE;#undef alertID}/***************************************************************** FindDocument** Find the document for wPtr** Parameters:*    wPtr  pointer to the window for which to find a document** Returns: Document pointer; NULL if there isn't one****************************************************************/documentPtr FindDocument (GrafPortPtr wPtr){BOOLEAN done;                           /* used to test for loop termination */documentPtr dPtr;                       /* used to trace the document list */dPtr = documents;done = dPtr == NULL;while (!done)   if (dPtr->wPtr == wPtr)      done = TRUE;   else {      dPtr = dPtr->next;      done = dPtr == NULL;      }return dPtr;}/***************************************************************** DrawContents** Draw the contents of the active port****************************************************************/#pragma databank 1void DrawContents (void){DrawControls(GetPort());}#pragma databank 0/***************************************************************** GetPageSize** Get the page size for one printer page** Parameters:*    pHand - print record handle*    r - (output) rectangle to fill in****************************************************************/void GetPageSize (Handle pHand, Rect *r){PrRecPtr pPtr;                          /* pointer to print record */HLock(pHand);pPtr = (PrRecPtr) (*pHand);*r = pPtr->prInfo.rPage;HUnlock(pHand);}/***************************************************************** PrintDocument** Do the actual printing of the document** Parameters:*    dPtr - document to print****************************************************************/void PrintDocument (documentPtr dPtr){GrafPortPtr prPort;                     /* printer's GrafPort */LongWord line;                          /* line number */PrStatusRec status;                     /* printer status */Rect pageRect;                          /* printer's page rectangle *//* get ready to print */prPort = PrOpenDoc(dPtr->prHandle, NULL);if (toolerror() != 0) {   FlagError(6, toolerror());   return;   }/* main print loop */GetPageSize((Handle) dPtr->prHandle, &pageRect);if (toolerror() != 0)   FlagError(6, toolerror());else {   line = 0;   while (line != -1) {      PrOpenPage(prPort, NULL);      if (toolerror() != 0) {         FlagError(6, toolerror());         line = -1;         }      else {         line = TEPaintText(prPort, line, &pageRect, 0,            (Handle) GetCtlHandleFromID(dPtr->wPtr, teControl));         PrClosePage(prPort);         }      }   }PrCloseDoc(prPort);/* spooling loop */if (PrError() == 0)   PrPicFile(dPtr->prHandle, NULL, &status);}/***************************************************************** GetUntitledName** Create a name for an untitled window** Returns: Pointer to the new window name****************************************************************/char *GetUntitledName (void){#define untitled 101                    /* Resource number for "Untitled " */static char name[maxName];              /* window name */char *sPtr;                             /* pointer to the resource string */documentPtr dPtr;                       /* used to trace the document list */int number;                             /* new value for untitledNum */dPtr = documents;                       /* if there are no untitled          */number = 1;                             /*  documents then reset untitledNum */while (dPtr != NULL)   if (!dPtr->onDisk) {      number = untitledNum;      dPtr = NULL;      }   else      dPtr = dPtr->next;untitledNum = number;strcpy(name, "  ");                     /* pad on the left with spaces */sPtr = GetString(untitled);             /* set the base name */if (sPtr == NULL)   strcat(name, "Untitled ");else {   strncat(name, sPtr, maxName-10);   FreeString(untitled);   }                                        /* add the untitled number */sprintf(&name[strlen(name)], "%d", untitledNum);strcat(name, "  ");                     /* pad on the right with spaces */++untitledNum;                          /* update untitledNum */return name;                            /* return the name */}/***************************************************************** NewDocument** Open a new window, returning the pointer** Parameters:*    wName - name for the new window** Returns: Document pointer; NULL for an error****************************************************************/documentPtr NewDocument (char *wName){#define wrNum 1001                      /* window resource number */documentPtr dPtr;                       /* new document pointer */dPtr = malloc(sizeof(documentStruct)); /* allocate the record */if (dPtr != NULL) {   dPtr->onDisk = FALSE;                /* not on disk */   dPtr->wName[0] = strlen(wName);      /* set up the name */   strncpy(&dPtr->wName[1], wName, maxName);   dPtr->fileName = NULL;               /* no file name handle */   dPtr->pathName = NULL;               /* no path name handle */   dPtr->wPtr =                         /* open the window */      NewWindow2(dPtr->wName, 0, DrawContents, NULL, 0x02, wrNum, rWindParam1);   if (dPtr->wPtr == NULL) {      FlagError(1, toolerror());        /* handle a window error */      free(dPtr);      dPtr = NULL;      }   else {      dPtr->next = documents;           /* put the document in the list */      documents = dPtr;                                        /* allocate a print record */      dPtr->prHandle = (PrRecHndl) NewHandle(140, userid(), 0, NULL);      if (dPtr->prHandle != NULL) {         PrDefault(dPtr->prHandle);         if (toolerror() != 0) {            DisposeHandle((Handle) dPtr->prHandle);            dPtr->prHandle = NULL;            }         }      }   }else   FlagError(2, 0);                     /* handle an out of memory error */return dPtr;#undef wrNum}/***************************************************************** DoAbout** Draw our about box****************************************************************/void DoAbout (void){#define alertID 1                       /* alert string resource ID */AlertWindow(awCString+awResource, NULL, alertID);#undef alertID}/***************************************************************** DoNew** Open a new document window****************************************************************/void DoNew (void){NewDocument(GetUntitledName());}/***************************************************************** DoOpen** Open a file****************************************************************/void DoOpen (void){#define posX 80                         /* X position of the dialog */#define posY 50                         /* Y position of the dialog */#define titleID 102                     /* prompt string resource ID */documentPtr dPtr;                       /* pointer to the new document */SFTypeList2 fileTypes;                  /* list of valid file types */Handle gsosNameHandle;                  /* handle of the file name */ResultBuf255Ptr gsosNamePtr;            /* pointer to the GS/OS file name */int i;                                  /* loop/index variable */int len;                                /* GS/OS name length */char name[maxName];                     /* new document name */SFReplyRec2 reply;                      /* reply record */fileTypes.numEntries = 1;               /* set up the allowed file types */fileTypes.fileTypeEntries[0].flags = 0x0000;fileTypes.fileTypeEntries[0].fileType = 0x06;fileTypes.fileTypeEntries[0].auxType = 0x0000;reply.nameRefDesc = 3;                  /* get the file to open */reply.pathRefDesc = 3;SFGetFile2(posX, posY, refIsResource, titleID, NULL, &fileTypes, &reply);if (toolerror() != 0)   FlagError(3, toolerror());           /* handle an error */else if (reply.good) {                  /* form the file name */   gsosNameHandle = (Handle) reply.nameRef;   HLock(gsosNameHandle);   gsosNamePtr = (ResultBuf255Ptr) (*gsosNameHandle);   strcpy(name, "  ");   len = gsosNamePtr->bufString.length;   if (len > maxName-5)      len = maxName-5;   for (i = 0; i < len; ++i)      name[2+i] = gsosNamePtr->bufString.text[i];   name[2+i] = (char) 0;   strcat(name, "  ");   HUnlock(gsosNameHandle);   dPtr = NewDocument(name);            /* get a document record */   if (dPtr == NULL) {                  /* in case of error, dispose of the names */      DisposeHandle((Handle) reply.nameRef);      DisposeHandle((Handle) reply.pathRef);      }   else {                               /* otherwise save the names */      dPtr->fileName = (Handle) reply.nameRef;      dPtr->pathName = (Handle) reply.pathRef;      if (LoadDocument(dPtr))           /* read the file */         dPtr->onDisk = TRUE;           /* file is on disk */      else                              /* handle a read error */         CloseDocument(dPtr);      }   }#undef posX#undef posY#undef titleID}/***************************************************************** DoSaveAs** Save a document to a new name** Parameters:*    dPtr - document to save****************************************************************/void DoSaveAs (documentPtr dPtr){#define posX 80                         /* X position of the dialog */#define posY 50                         /* Y position of the dialog */#define titleID 103                     /* prompt string resource ID */int dummyName;                          /* used for a null file name prompt */Handle gsosNameHandle;                  /* handle of the file name */ResultBuf255Ptr gsosNamePtr;            /* pointer to the GS/OS file name */int i;                                  /* loop/index variable */int len;                                /* GS/OS name length */SFReplyRec2 reply;                      /* reply record */if (dPtr != NULL) {   reply.nameRefDesc = 3;               /* get the new file name */   reply.pathRefDesc = 3;   if (dPtr->fileName == NULL) {      dummyName = 0;      SFPutFile2(posX, posY, refIsResource, (Ref) titleID, refIsPointer,         (Ref) &dummyName, &reply);      }   else      SFPutFile2(posX, posY, refIsResource, titleID, refIsPointer,         (Ref) (((long) (*dPtr->fileName)) + 2), &reply);   if (toolerror() != 0)      FlagError(3, toolerror());        /* handle an error */   else if (reply.good) {                                        /* form the new window name */      gsosNameHandle = (Handle) reply.nameRef;      HLock(gsosNameHandle);      gsosNamePtr = (ResultBuf255Ptr) (*gsosNameHandle);      strcpy(dPtr->wName, "   ");      len = gsosNamePtr->bufString.length;      if (len > maxName-6)         len = maxName-6;      for (i = 0; i < len; ++i)         dPtr->wName[2+i] = gsosNamePtr->bufString.text[i];      dPtr->wName[2+i] = (char) 0;      strcat(dPtr->wName, "  ");      dPtr->wName[0] = (char) (strlen(dPtr->wName)-1);      HUnlock(gsosNameHandle);      SetWTitle(dPtr->wName, dPtr->wPtr);                                        /* save the names */      dPtr->fileName = (Handle) reply.nameRef;      dPtr->pathName = (Handle) reply.pathRef;      dPtr->onDisk = TRUE;              /* file is on disk */      SaveDocument(dPtr);               /* save the file */      }   }#undef posX#undef posY#undef titleID}/***************************************************************** DoSave** Save a document to the existing disk file** Parameters:*    dPtr - document to save****************************************************************/void DoSave (documentPtr dPtr){if (dPtr != NULL)   if (dPtr->onDisk)      SaveDocument(dPtr);   else      DoSaveAs(dPtr);}/***************************************************************** DoPageSetup** Set up the printer options****************************************************************/void DoPageSetup (void){documentPtr dPtr;                       /* document to save */dPtr = FindDocument(FrontWindow());     /* get the document */if (dPtr == NULL)   return;if (dPtr->prHandle == NULL) {           /* make sure there is a print record */   dPtr->prHandle = (PrRecHndl) NewHandle(140, userid(), 0, NULL);   if (dPtr->prHandle == NULL) {      FlagError(6, toolerror());      return;      }   PrDefault(dPtr->prHandle);   if (toolerror() != 0) {      FlagError(6, toolerror());      DisposeHandle((Handle) dPtr->prHandle);      dPtr->prHandle = NULL;      }   }if (dPtr->prHandle != NULL)             /* update the print record */   PrStlDialog(dPtr->prHandle);}/***************************************************************** DoPrint** Print the document****************************************************************/void DoPrint (void){documentPtr dPtr;                       /* document to save */dPtr = FindDocument(FrontWindow());     /* get the document */if (dPtr == NULL)   return;if (dPtr->prHandle == NULL) {           /* make sure there is a print record */   dPtr->prHandle = (PrRecHndl) NewHandle(140, userid(), 0, NULL);   if (dPtr->prHandle == NULL) {      FlagError(6, toolerror());      return;      }   PrDefault(dPtr->prHandle);   if (toolerror() != 0) {      FlagError(6, toolerror());      DisposeHandle((Handle) dPtr->prHandle);      dPtr->prHandle = NULL;      }   }if (dPtr->prHandle != NULL)             /* print the document */   if (PrJobDialog(dPtr->prHandle))      PrintDocument(dPtr);}/***************************************************************** DoQuit** Handle quit processing****************************************************************/void DoQuit (void){done = TRUE;while ((documents != NULL) && done)   if (documents != NULL)      done = CloseDocument(documents);}/***************************************************************** GetCurrentID** Get the current font ID** Parameters:*    fID - (returned) current font ID****************************************************************/void GetCurrentID (FontID *fID){documentPtr dPtr;                       /* front document */GrafPortPtr port;                       /* caller's GrafPort */Handle sHandle;                         /* style handle */TEStyle style;                          /* style record */unsigned flags;                         /* style flags */fID->fidRec.famNum = 0;                 /* set up a default in case of error */fID->fidRec.fontStyle = 0;fID->fidRec.fontSize = 0;dPtr = FindDocument(FrontWindow());     /* get the font in use */if (dPtr == NULL)   return;port = GetPort();SetPort(dPtr->wPtr);sHandle = NewHandle(1, userid(), 0, NULL);if (toolerror() == 0) {   flags = TEGetSelectionStyle(&style, sHandle, NULL);   if (toolerror() == 0) {      if ((flags & 0x0020) != 0)         fID->fidRec.famNum = style.styleFontID.fidRec.famNum;      if ((flags & 0x0010) != 0)         fID->fidRec.fontSize = style.styleFontID.fidRec.fontSize;      if ((flags & 0x0001) != 0)         fID->fidRec.fontStyle = style.styleFontID.fidRec.fontStyle;      }   DisposeHandle(sHandle);   }SetPort(port);}/***************************************************************** SetCurrentID** Set the appropriate font ID to fID** Parameters:*    fID - new font ID*    flags - flags telling which bits are valid****************************************************************/void SetCurrentID (FontID fID, unsigned flags){documentPtr dPtr;                       /* front document */GrafPortPtr port;                       /* caller's GrafPort */TEStyle style;                          /* style record */dPtr = FindDocument(FrontWindow());if (dPtr != NULL) {   port = GetPort();   SetPort(dPtr->wPtr);   style.styleFontID = fID;   TEStyleChange(flags, &style, NULL);   SetPort(port);   }}/***************************************************************** DoFontFamily** Pick a new font family** Parameters:*    id - font family menu item ID****************************************************************/void DoFontFamily (unsigned id){FontID fID;                             /* current/new font ID */fID.fidRec.famNum = ItemID2FamNum(id);if (toolerror() == 0)   SetCurrentID(fID, 0x0040);}/***************************************************************** DoFontSize** Pick a new font size** Parameters:*    size - new font size****************************************************************/void DoFontSize (unsigned size){FontID fID;                             /* current/new font ID */fID.fidRec.fontSize = size;SetCurrentID(fID, 0x0020);}/***************************************************************** DoPlainText** Change the style to plain text****************************************************************/void DoPlainText (void){FontID fID;                             /* current/new font ID */fID.fidRec.fontStyle = 0;SetCurrentID(fID, 0x0002);}/***************************************************************** DoStyle** Set the text style** Parameters:*    style - new text style****************************************************************/void DoStyle (unsigned style){documentPtr dPtr;                       /* active document */GrafPortPtr port;                       /* caller's GrafPort */Handle rulerHandle;                     /* ruler handle */TERuler *rulerPtr;                      /* pointer to the ruler record */dPtr = FindDocument(FrontWindow());if (dPtr == NULL)   return;port = GetPort();SetPort(dPtr->wPtr);TEGetRuler(3, (Ref) &rulerHandle, NULL);if (toolerror() == 0) {   HLock(rulerHandle);   rulerPtr = (TERuler *) (*rulerHandle);   rulerPtr->just = style;   TESetRuler(1, (Ref) rulerHandle, NULL);   DisposeHandle(rulerHandle);   }SetPort(port);}/***************************************************************** DoFontStyle** Flip a style bit** Parameters:*    style - style bit to flip****************************************************************/void DoFontStyle (unsigned style){FontID fID;                             /* current/new font ID */GetCurrentID(&fID);fID.fidRec.fontStyle = fID.fidRec.fontStyle ^ style;SetCurrentID(fID, 0x0001);}/***************************************************************** HandleMenu** Initialize the menu bar.****************************************************************/void HandleMenu (void){int menuNum, menuItemNum;               /* menu number & menu item number */menuNum = myEvent.wmTaskData >> 16;menuItemNum = myEvent.wmTaskData;if (menuItemNum >= fontFirst)           /* go handle the menu */   DoFontFamily(menuItemNum);else   switch (menuItemNum) {      case appleAbout:     DoAbout();                                   break;      case fileNew:        DoNew();                                     break;      case fileOpen:       DoOpen();                                    break;      case fileClose:      CloseDocument(FindDocument(FrontWindow()));  break;      case fileSave:       DoSave(FindDocument(FrontWindow()));         break;      case fileSaveAs:     DoSaveAs(FindDocument(FrontWindow()));       break;      case filePageSetup:  DoPageSetup();                               break;      case filePrint:      DoPrint();                                   break;      case fileQuit:       DoQuit();                                    break;      case editUndo:                                                    break;      case editCut:                                                     break;      case editCopy:                                                    break;      case editPaste:                                                   break;      case editClear:                                                   break;      case stylePlain:     DoPlainText;                                 break;      case styleBold:      DoFontStyle(1);                              break;      case styleItalic:    DoFontStyle(2);                              break;      case styleUnderline: DoFontStyle(4);                              break;      case styleOutline:   DoFontStyle(8);                              break;      case styleShadow:    DoFontStyle(16);                             break;      case styleLeft:      DoStyle(0);                                  break;      case styleRight:     DoStyle(-1);                                 break;      case styleFill:      DoStyle(2);                                  break;      case styleCenter:    DoStyle(1);                                  break;      case size9:          DoFontSize(9);                               break;      case size10:         DoFontSize(10);                              break;      case size12:         DoFontSize(12);                              break;      case size14:         DoFontSize(14);                              break;      case size18:         DoFontSize(18);                              break;      case size24:         DoFontSize(24);                              break;      }HiliteMenu(FALSE, menuNum);             /* unhighlight the menu */}/***************************************************************** InitMenus** Initialize the menu bar.****************************************************************/void InitMenus (void){#define menuID 1                        /* menu bar resource ID */int height;                             /* height of the largest menu */MenuBarRecHndl menuBarHand;             /* for 'handling' the menu bar */                                        /* create the menu bar */menuBarHand = NewMenuBar2(refIsResource, menuID, NULL);SetSysBar(menuBarHand);SetMenuBar(NULL);FixAppleMenu(appleMenu);                /* add desk accessories */FixFontMenu(fontMenu, fontFirst, 0);    /* add fonts */height = FixMenuBar();                  /* draw the completed menu bar */DrawMenuBar();#undef menuID}/***************************************************************** OutLine** Outline or un-outline a size menu item** Parameters:*    id - menu ID (style set to 0xFF, family correct)*    size - size to check*    menuID - menu ID to outline****************************************************************/void Outline (FontID id, unsigned  size, unsigned menuID){id.fidRec.fontSize = size;if (CountFonts(id, 0x0A) == 0)   SetMItemStyle(0, menuID);else   SetMItemStyle(8, menuID);}/***************************************************************** CheckMenus** Check the menus to see if they should be dimmed****************************************************************/void CheckMenus (void){documentPtr dPtr;                       /* active document */FontID fID;                             /* active font ID */GrafPortPtr port;                       /* caller's GrafPort */Handle rulerHandle;                     /* ruler handle */int style;                              /* text justification style */TERuler *rulerPtr;                      /* pointer to the ruler record */unsigned newFont;                       /* new menu item ID for font family menu */if (documents == NULL) {                /* print menus */   DisableMItem(filePageSetup);   DisableMItem(filePrint);   }else {   EnableMItem(filePageSetup);   EnableMItem(filePrint);   GetCurrentID(&fID);                  /* get the "active" font ID */   if (lastFont != 0)                   /* check the current font family */      CheckMItem(FALSE, lastFont);   newFont = FamNum2ItemID(fID.fidRec.famNum);   if (toolerror() == 0) {      lastFont = newFont;      CheckMItem(TRUE, lastFont);      }   else      lastFont = 0;                                        /* check the proper style items */   CheckMItem(fID.fidRec.fontStyle == 0, stylePlain);   CheckMItem((fID.fidRec.fontStyle & 1) != 0, styleBold);   CheckMItem((fID.fidRec.fontStyle & 2) != 0, styleItalic);   CheckMItem((fID.fidRec.fontStyle & 4) != 0, styleUnderline);   CheckMItem((fID.fidRec.fontStyle & 8) != 0, styleOutline);   CheckMItem((fID.fidRec.fontStyle & 16) != 0, styleShadow);   CheckMItem(fID.fidRec.fontSize == 9, size9); /* check the proper size items */   CheckMItem(fID.fidRec.fontSize == 10, size10);   CheckMItem(fID.fidRec.fontSize == 12, size12);   CheckMItem(fID.fidRec.fontSize == 14, size14);   CheckMItem(fID.fidRec.fontSize == 18, size18);   CheckMItem(fID.fidRec.fontSize == 24, size24);   fID.fidRec.fontStyle = 0xFF;         /* outline the appropriate sizes */   Outline(fID, 9, size9);   Outline(fID, 10, size10);   Outline(fID, 12, size12);   Outline(fID, 14, size14);   Outline(fID, 18, size18);   Outline(fID, 24, size24);   dPtr = FindDocument(FrontWindow());  /* check the proper justification style */   if (dPtr == NULL) {      DisableMItem(styleLeft);      DisableMItem(styleRight);      DisableMItem(styleFill);      DisableMItem(styleCenter);      }   else {      EnableMItem(styleLeft);      EnableMItem(styleRight);      EnableMItem(styleFill);      EnableMItem(styleCenter);      port = GetPort();      SetPort(dPtr->wPtr);      TEGetRuler(3, (Ref) &rulerHandle, NULL);      if (toolerror == 0) {         HLock(rulerHandle);         rulerPtr = (TERuler *) (*rulerHandle);         style = rulerPtr->just;         TESetRuler(1, (Ref) rulerHandle, NULL);         DisposeHandle(rulerHandle);         CheckMItem(style == 0, styleLeft);         CheckMItem(style == -1, styleRight);         CheckMItem(style == 1, styleCenter);         CheckMItem(style == 2, styleFill);         }      SetPort(port);      }   }}/***************************************************************** InitGlobals** Initialize the global variables****************************************************************/void InitGlobals (void){documents = NULL;                       /* no documents */lastFont = 0;                           /* menu ID for checked font family */}/***************************************************************** Main program****************************************************************/int main (void){int event;                              /* event type returned by TaskMaster */Ref startStopParm;                      /* tool start/shutdown parameter */startStopParm =                         /* start up the tools */   StartUpTools(userid(), 2, 1);if (toolerror() != 0)   SysFailMgr(toolerror(), "\pCould not start tools: ");InitMenus();                            /* set up the menu bar */InitCursor();                           /* start the arrow cursor */InitGlobals();                          /* initialize our global variables */done = FALSE;                           /* main event loop */CheckMenus();                           /* set up the initial menus */myEvent.wmTaskMask = 0x001F7FFF;        /* let TaskMaster do it all */while (!done) {   event = TaskMaster(everyEvent, &myEvent);   switch (event) {      case wInSpecial:      case wInMenuBar:          HandleMenu();                                break;      case wInGoAway:           CloseDocument(FindDocument(                                   (GrafPortPtr) myEvent.wmTaskData));                                break;      }   if (event != nullEvt)      CheckMenus();   }ShutDownTools(1, startStopParm);        /* shut down the tools */}