/***************************************************************** Font Sampler** View and print an font.****************************************************************/#pragma lint -1#include <stdlib.h>#include <string.h>#include <stdio.h>#include <orca.h>#include <Event.h>#include <Menu.h>#include <QuickDraw.h>#include <Window.h>#include <Desk.h>#include <Resources.h>#include <Memory.h>#include <Locator.h>#include <MiscTool.h>#include <Print.h>#include <Font.h>#define appleMenu       1               /* Menu ID #s (also resource ID #s) */#define fileMenu        2#define editMenu        3#define fontMenu        4#define appleAbout      257#define fileNew         260#define fileClose       255#define filePageSetup   264#define filePrint       265#define fileQuit        256#define editUndo        250#define editCut         251#define editCopy        252#define editPaste       253#define editClear       254#define fontChooseFont  270#define maxName 80                      /* max length of a window title */typedef struct documentStruct {         /* information about our document */   struct documentStruct *next;         /* next document */   GrafPortPtr wPtr;                    /* window pointer */   char wName[maxName+1];               /* window name */   PrRecHndl prHandle;                  /* print record */   FontID fID;                          /* window's font */   } documentStruct;typedef documentStruct *documentPtr;    /* document pointer */BOOLEAN done;                           /* are we done, yet? */documentPtr documents;                  /* our documents */FontID currentFont;                     /* current font */int untitledNum;                        /* number for the next untitled window */EventRecord myEvent;                    /* event record *//***************************************************************** GetString** Get a string from the resource fork** Parameters:*    resourceID - resource ID of the rCString resource** Returns: pointer to the string; NULL for an error** Notes: The string is in a locked resource handle.  The caller*    should call FreeString when the string is no longer needed.*    Failure to do so is not catastrophic; the memory will be*    deallocated when the program is shut down.****************************************************************/char *GetString (int resourceID){Handle hndl;                            /* resource handle */hndl = LoadResource(rCString, resourceID);if (toolerror() == 0) {   HLock(hndl);   return (char *) (*hndl);   }return NULL;}/***************************************************************** Free a resource string** Parameters:*    resourceID - resource ID of the rCString to free****************************************************************/void FreeString (int resourceID){ReleaseResource(-3, rCString, resourceID);}/***************************************************************** FlagError** Flag an error** Parameters:*    error - error message number*    tError - toolbox error code; 0 if none****************************************************************/void FlagError (int error, int tError){#define errorAlert 2000                 /* alert resource ID */#define errorBase 2000                  /* base resource ID for fortunes */char *substArray;                       /* substitution "array" */char *errorString;                      /* pointer to the error string */                                        /* form the error string */errorString = GetString(errorBase + error);substArray = NULL;if (errorString != NULL) {   substArray = malloc(strlen(substArray)+9);   if (substArray != NULL)      strcpy(substArray, errorString);   FreeString(errorBase + error);   }if (substArray != NULL) {   if (tError != 0)                     /* add the tool error number */      sprintf(&substArray[strlen(substArray)], " ($%04X)", tError);                                        /* show the alert */   AlertWindow(awCString+awResource, (Pointer) &substArray, errorAlert);   free(substArray);   }#undef errorAlert#undef errorBase}/***************************************************************** CloseDocument** Close a document and its associated window** Parameters:*    dPtr - pointer to the document to close; may be NULL****************************************************************/void CloseDocument (documentPtr dPtr){documentPtr lPtr;                       /* pointer to the previous document */if (dPtr != NULL) {   CloseWindow(dPtr->wPtr);             /* close the window */   if (documents == dPtr)               /* remove dPtr from the list when... */      documents = dPtr->next;           /* ...dPtr is the first document */   else {                               /* ...dPtr is not the first document */      lPtr = documents;      while (lPtr->next != dPtr)         lPtr = lPtr->next;      lPtr->next = dPtr->next;      }   if (dPtr->prHandle != NULL)          /* dispose of the print record */      DisposeHandle((Handle) dPtr->prHandle);   free(dPtr);                          /* dispose of the document record */   }}/***************************************************************** FindDocument** Find the document for wPtr** Parameters:*    wPtr  pointer to the window for which to find a document** Returns: Document pointer; NULL if there isn't one****************************************************************/documentPtr FindDocument (GrafPortPtr wPtr){BOOLEAN done;                           /* used to test for loop termination */documentPtr dPtr;                       /* used to trace the document list */dPtr = documents;done = dPtr == NULL;while (!done)   if (dPtr->wPtr == wPtr)      done = TRUE;   else {      dPtr = dPtr->next;      done = dPtr == NULL;      }return dPtr;}/***************************************************************** DrawFonts** Parameters:*    dPtr - document to draw****************************************************************/void DrawFonts (documentPtr dPtr){#define headerH 10                      /* location of header string */#define headerV 15#define tableH 10                       /* location of table's topline */#define tableV 20Byte style;                             /* font style */char str[80];                           /* font header string */FontID standard;                        /* standard font font ID */FontInfoRecord info;                    /* info about the font */unsigned base;                          /* baseline for the top line of the table */unsigned dv, dh;                        /* size of one character */unsigned row, col;                      /* loop variables */if (dPtr == NULL)                       /* make sure the document exists */   return;SetForeColor(0);                        /* print black text on a white background */SetBackColor(3);SetTextMode(modeCopy);standard.fidLong = 0;                   /* write the header info */InstallFont(standard, 0);sprintf(str, "famNum = %d  fontSize = %d  fontStyle =",   (int) dPtr->fID.fidRec.famNum, (int) dPtr->fID.fidRec.fontSize);style = dPtr->fID.fidRec.fontStyle;if (style == 0)   strcat(str, " plain text");else {   if (style & 1)      strcat(str, " bold");   if (style & 2)      strcat(str, " italic");   if (style & 4)      strcat(str, " underline");   if (style & 8)      strcat(str, " outline");   if (style & 16)      strcat(str, " shadow");   }MoveTo(headerH, headerV);DrawCString(str);InstallFont(dPtr->fID, 0);              /* install the window's font */GetFontInfo(&info);                     /* get info needed to format the font table */base = tableV + info.ascent;dv = info.descent + info.ascent + info.leading;dh = info.widMax*2;for (row = 0; row < 16; ++row)          /* print the font table */   for (col = 0; col < 16; ++col) {      MoveTo(tableH + dh*col, base + dv*row);      DrawChar((char) (col*16 + row));      }#undef headerH#undef headerV#undef tableH#undef tableV}/***************************************************************** DrawContents** Draw the contents of the active port****************************************************************/#pragma databank 1void DrawContents (void){DrawFonts(FindDocument(GetPort()));}#pragma databank 0/***************************************************************** GetPageCount** Get the size of the document in pages** Parameters:*    dPtr - document to get the size of*    h, v - (returned) pointers to size in pages****************************************************************/void GetPageCount (documentPtr dPtr, unsigned *h, unsigned *v){*h = 1;*v = 1;}/***************************************************************** PrintDocument** Do the actual printing of the document** Parameters:*    dPtr - document to print****************************************************************/void PrintDocument (documentPtr dPtr){unsigned h, v;                          /* size of document in pages */unsigned x, y;                          /* page loop counters */PrStatusRec status;                     /* printer status */GrafPortPtr prPort;                     /* printer's GrafPort *//* get ready to print */prPort = PrOpenDoc(dPtr->prHandle, NULL);if (toolerror() != 0) {   FlagError(6, toolerror());   return;   }GetPageCount(dPtr, &h, &v);/* main print loop */for (x = 1; x <= h; ++x)   for (y = 1; y <= v; ++y) {      PrOpenPage(prPort, NULL);      if (toolerror() != 0)         FlagError(6, toolerror());      else {         /* print here */         DrawFonts(dPtr);         /* done printing */         PrClosePage(prPort);         }      }PrCloseDoc(prPort);/* spooling loop */if (PrError() == 0)   PrPicFile(dPtr->prHandle, NULL, &status);}/***************************************************************** GetUntitledName** Create a name for an untitled window** Returns: Pointer to the new window name****************************************************************/char *GetUntitledName (void){#define untitled 101                    /* Resource number for "Untitled " */static char name[maxName];              /* window name */char *sPtr;                             /* pointer to the resource string */documentPtr dPtr;                       /* used to trace the document list */if (documents == NULL)                  /* if there are no untitled          */   untitledNum = 1;                     /*  documents then reset untitledNum */strcpy(name, "  ");                     /* pad on the left with spaces */sPtr = GetString(untitled);             /* set the base name */if (sPtr == NULL)   strcat(name, "Untitled ");else {   strncat(name, sPtr, maxName-10);   FreeString(untitled);   }                                        /* add the untitled number */sprintf(&name[strlen(name)], "%d", untitledNum);strcat(name, "  ");                     /* pad on the right with spaces */++untitledNum;                          /* update untitledNum */return name;                            /* return the name */}/***************************************************************** NewDocument** Open a new window, returning the pointer** Parameters:*    wName - name for the new window** Returns: Document pointer; NULL for an error****************************************************************/documentPtr NewDocument (char *wName){#define wrNum 1001                      /* window resource number */documentPtr dPtr;                       /* new document pointer */dPtr = malloc(sizeof(documentStruct)); /* allocate the record */if (dPtr != NULL) {   dPtr->wName[0] = strlen(wName);      /* set up the name */   strncpy(&dPtr->wName[1], wName, maxName);   dPtr->fID = currentFont;             /* use the current default font */   dPtr->wPtr =                         /* open the window */      NewWindow2(dPtr->wName, 0, DrawContents, NULL, 0x02, wrNum, rWindParam1);   if (dPtr->wPtr == NULL) {      FlagError(1, toolerror());        /* handle a window error */      free(dPtr);      dPtr = NULL;      }   else {      dPtr->next = documents;           /* put the document in the list */      documents = dPtr;                                        /* allocate a print record */      dPtr->prHandle = (PrRecHndl) NewHandle(140, userid(), 0, NULL);      if (dPtr->prHandle != NULL) {         PrDefault(dPtr->prHandle);         if (toolerror() != 0) {            DisposeHandle((Handle) dPtr->prHandle);            dPtr->prHandle = NULL;            }         }      }   }else   FlagError(2, 0);                     /* handle an out of memory error */return dPtr;#undef wrNum}/***************************************************************** DoAbout** Draw our about box****************************************************************/void DoAbout (void){#define alertID 1                       /* alert string resource ID */AlertWindow(awCString+awResource, NULL, alertID);#undef alertID}/***************************************************************** DoNew** Open a new document window****************************************************************/void DoNew (void){NewDocument(GetUntitledName());}/***************************************************************** DoPageSetup** Set up the printer options****************************************************************/void DoPageSetup (void){documentPtr dPtr;                       /* document to save */dPtr = FindDocument(FrontWindow());     /* get the document */if (dPtr == NULL)   return;if (dPtr->prHandle == NULL) {           /* make sure there is a print record */   dPtr->prHandle = (PrRecHndl) NewHandle(140, userid(), 0, NULL);   if (dPtr->prHandle == NULL) {      FlagError(6, toolerror());      return;      }   PrDefault(dPtr->prHandle);   if (toolerror() != 0) {      FlagError(6, toolerror());      DisposeHandle((Handle) dPtr->prHandle);      dPtr->prHandle = NULL;      }   }if (dPtr->prHandle != NULL)             /* update the print record */   PrStlDialog(dPtr->prHandle);}/***************************************************************** DoPrint** Print the document****************************************************************/void DoPrint (void){documentPtr dPtr;                       /* document to save */dPtr = FindDocument(FrontWindow());     /* get the document */if (dPtr == NULL)   return;if (dPtr->prHandle == NULL) {           /* make sure there is a print record */   dPtr->prHandle = (PrRecHndl) NewHandle(140, userid(), 0, NULL);   if (dPtr->prHandle == NULL) {      FlagError(6, toolerror());      return;      }   PrDefault(dPtr->prHandle);   if (toolerror() != 0) {      FlagError(6, toolerror());      DisposeHandle((Handle) dPtr->prHandle);      dPtr->prHandle = NULL;      }   }if (dPtr->prHandle != NULL)             /* print the document */   if (PrJobDialog(dPtr->prHandle))      PrintDocument(dPtr);}/***************************************************************** DoChooseFont** Pick a new font****************************************************************/void DoChooseFont (void){documentPtr dPtr;                       /* pointer to the front document */GrafPortPtr port;                       /* caller's GrafPort */Rect r;                                 /* window's GrafPort rect */                                        /* pick the new font */currentFont.fidLong = ChooseFont(currentFont, 0);dPtr = FindDocument(FrontWindow());     /* change the front window's font */if (dPtr == NULL)   return;dPtr->fID = currentFont;port = GetPort();SetPort(dPtr->wPtr);GetPortRect(&r);EraseRect(&r);InvalRect(&r);SetPort(port);}/***************************************************************** HandleMenu** Initialize the menu bar.****************************************************************/void HandleMenu (void){int menuNum, menuItemNum;               /* menu number & menu item number */menuNum = myEvent.wmTaskData >> 16;menuItemNum = myEvent.wmTaskData;switch (menuItemNum) {                  /* go handle the menu */   case appleAbout:     DoAbout();                                      break;   case fileNew:        DoNew();                                        break;   case fileClose:      CloseDocument(FindDocument(FrontWindow()));     break;   case filePageSetup:  DoPageSetup();                                  break;   case filePrint:      DoPrint();                                      break;   case fileQuit:       done = TRUE;                                    break;   case editUndo:                                                       break;   case editCut:                                                        break;   case editCopy:                                                       break;   case editPaste:                                                      break;   case editClear:                                                      break;   case fontChooseFont: DoChooseFont();                                 break;   }HiliteMenu(FALSE, menuNum);             /* unhighlight the menu */}/***************************************************************** InitMenus** Initialize the menu bar.****************************************************************/void InitMenus (void){#define menuID 1                        /* menu bar resource ID */int height;                             /* height of the largest menu */MenuBarRecHndl menuBarHand;             /* for 'handling' the menu bar */                                        /* create the menu bar */menuBarHand = NewMenuBar2(refIsResource, menuID, NULL);SetSysBar(menuBarHand);SetMenuBar(NULL);FixAppleMenu(1);                        /* add desk accessories */height = FixMenuBar();                  /* draw the completed menu bar */DrawMenuBar();#undef menuID}/***************************************************************** CheckMenus** Check the menus to see if they should be dimmed****************************************************************/void CheckMenus (void){if (documents == NULL) {   DisableMItem(filePageSetup);   DisableMItem(filePrint);   }else {   EnableMItem(filePageSetup);   EnableMItem(filePrint);   }}/***************************************************************** InitGlobals** Initialize the global variables****************************************************************/void InitGlobals (void){documents = NULL;                       /* no documents */currentFont.fidRec.famNum = 0;          /* default to the system font */currentFont.fidRec.fontStyle = 0;currentFont.fidRec.fontSize = 0;}/***************************************************************** Main program****************************************************************/int main (void){int event;                              /* event type returned by TaskMaster */Ref startStopParm;                      /* tool start/shutdown parameter */startStopParm =                         /* start up the tools */   StartUpTools(userid(), 2, 1);if (toolerror() != 0)   SysFailMgr(toolerror(), "\pCould not start tools: ");InitMenus();                            /* set up the menu bar */InitCursor();                           /* start the arrow cursor */InitGlobals();                          /* initialize our global variables */done = FALSE;                           /* main event loop */myEvent.wmTaskMask = 0x001F7FFF;        /* let TaskMaster do it all */while (!done) {   CheckMenus();   event = TaskMaster(everyEvent, &myEvent);   switch (event) {      case wInSpecial:      case wInMenuBar:          HandleMenu();                                break;      case wInGoAway:           CloseDocument(FindDocument(                                   (GrafPortPtr) myEvent.wmTaskData));                                break;      }   }ShutDownTools(1, startStopParm);        /* shut down the tools */}