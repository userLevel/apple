/***************************************************************** Window Sampler** This program creates windows based on a variety of user-* selected values.****************************************************************/#pragma lint -1#include <stdlib.h>#include <string.h>#include <stdio.h>#include <orca.h>#include <Event.h>#include <Menu.h>#include <QuickDraw.h>#include <Window.h>#include <Desk.h>#include <Resources.h>#include <Memory.h>#define appleMenu       1               /* Menu ID #s (also resource ID #s) */#define fileMenu        2#define editMenu        3#define wFrameBitsMenu  4#define titleMenu       5#define appleAbout      257#define fileNew         260#define fileOpen        261#define fileClose       255#define fileQuit        256#define editUndo        250#define editCut         251#define editCopy        252#define editPaste       253#define editClear       254#define frameTitle      270#define frameClose      271#define frameAlert      272#define frameControls   273#define frameFlex       274#define frameZoom       275#define frameMove       276#define frameCtlTie     277#define titleSolid      280#define titleLined      281#define titleDithered   282#define maxName 80                      /* max length of a window title */typedef struct documentStruct {         /* information about our document */   struct documentStruct *next;         /* next document */   GrafPortPtr wPtr;                    /* window pointer */   char wName[maxName+1];               /* window name */   BOOLEAN onDisk;                      /* does the file exist on disk? */   WindColor wColor;                    /* window color table */   } documentStruct;typedef documentStruct *documentPtr;    /* document pointer */typedef enum {solid, lined, dithered} titleKind; /* Title bar kind */BOOLEAN done;                           /* are we done, yet? */documentPtr documents;                  /* our documents */int untitledNum;                        /* number for the next untitled window */EventRecord myEvent;                    /* event record */BOOLEAN fbTitle;                        /* wFrameBits options */BOOLEAN fbClose;BOOLEAN fbAlert;BOOLEAN fbControls;BOOLEAN fbFlex;BOOLEAN fbZoom;BOOLEAN fbMove;BOOLEAN fbCtlTie;titleKind titleBarKind;                 /* Title option *//***************************************************************** GetString** Get a string from the resource fork** Parameters:*    resourceID - resource ID of the rCString resource** Returns: pointer to the string; NULL for an error** Notes: The string is in a locked resource handle.  The caller*    should call FreeString when the string is no longer needed.*    Failure to do so is not catastrophic; the memory will be*    deallocated when the program is shut down.****************************************************************/char *GetString (int resourceID){Handle hndl;                            /* resource handle */hndl = LoadResource(rCString, resourceID);if (toolerror() == 0) {   HLock(hndl);   return (char *) (*hndl);   }return NULL;}/***************************************************************** Free a resource string** Parameters:*    resourceID - resource ID of the rCString to free****************************************************************/void FreeString (int resourceID){ReleaseResource(-3, rCString, resourceID);}/***************************************************************** FlagError** Flag an error** Parameters:*    error - error message number*    tError - toolbox error code; 0 if none****************************************************************/void FlagError (int error, int tError){#define errorAlert 2000                 /* alert resource ID */#define errorBase 2000                  /* base resource ID for fortunes */char *substArray;                       /* substitution "array" */char *errorString;                      /* pointer to the error string */                                        /* form the error string */errorString = GetString(errorBase + error);substArray = NULL;if (errorString != NULL) {   substArray = malloc(strlen(substArray)+9);   if (substArray != NULL)      strcpy(substArray, errorString);   FreeString(errorBase + error);   }if (substArray != NULL) {   if (tError != 0)                     /* add the tool error number */      sprintf(&substArray[strlen(substArray)], " ($%04X)", tError);                                        /* show the alert */   AlertWindow(awCString+awResource, (Pointer) &substArray, errorAlert);   free(substArray);   }#undef errorAlert#undef errorBase}/***************************************************************** DrawContents** Draw the contents of the active port****************************************************************/#pragma databank 1void DrawContents (void){PenNormal();                            /* use a "normal" pen */}#pragma databank 0/***************************************************************** CloseDocument** Close a document and its associated window** Parameters:*    dPtr - pointer to the document to close; may be NULL****************************************************************/void CloseDocument (documentPtr dPtr){documentPtr lPtr;                       /* pointer to the previous document */if (dPtr != NULL) {   CloseWindow(dPtr->wPtr);             /* close the window */   if (documents == dPtr)               /* remove dPtr from the list when... */      documents = dPtr->next;           /* ...dPtr is the first document */   else {                               /* ...dPtr is not the first document */      lPtr = documents;      while (lPtr->next != dPtr)         lPtr = lPtr->next;      lPtr->next = dPtr->next;      }   free(dPtr);                          /* dispose of the document record */   }}/***************************************************************** FindDocument** Find the document for wPtr** Parameters:*    wPtr  pointer to the window for which to find a document** Returns: Document pointer; NULL if there isn't one****************************************************************/documentPtr FindDocument (GrafPortPtr wPtr){BOOLEAN done;                           /* used to test for loop termination */documentPtr dPtr;                       /* used to trace the document list */dPtr = documents;done = dPtr == NULL;while (!done)   if (dPtr->wPtr == wPtr)      done = TRUE;   else {      dPtr = dPtr->next;      done = dPtr == NULL;      }return dPtr;}/***************************************************************** GetUntitledName** Create a name for an untitled window** Returns: Pointer to the new window name****************************************************************/char *GetUntitledName (void){#define untitled 101                    /* Resource number for "Untitled " */static char name[maxName];              /* window name */char *sPtr;                             /* pointer to the resource string */documentPtr dPtr;                       /* used to trace the document list */int number;                             /* new value for untitledNum */dPtr = documents;                       /* if there are no untitled          */number = 1;                             /*  documents then reset untitledNum */while (dPtr != NULL)   if (!dPtr->onDisk) {      number = untitledNum;      dPtr = NULL;      }   else      dPtr = dPtr->next;untitledNum = number;strcpy(name, "  ");                     /* pad on the left with spaces */sPtr = GetString(untitled);             /* set the base name */if (sPtr == NULL)   strcat(name, "Untitled ");else {   strncat(name, sPtr, maxName-10);   FreeString(untitled);   }                                        /* add the untitled number */sprintf(&name[strlen(name)], "%d", untitledNum);strcat(name, "  ");                     /* pad on the right with spaces */++untitledNum;                          /* update untitledNum */return name;                            /* return the name */}/***************************************************************** NewWind** Create a new window** Parameters:*    dPtr - document for which to create the window** Returns: Pointer to the window; NULL for error****************************************************************/GrafPortPtr NewWind (documentPtr dPtr){ParamList wParms;                       /* parameters for NewWindow */dPtr->wColor.frameColor = 0x0000;       /* initialize the window color record */dPtr->wColor.titleColor = 0x0F00;switch (titleBarKind) {   case solid:      dPtr->wColor.titleColor = 0x0F0F;      dPtr->wColor.tBarColor = 0x0000;      break;   case lined:      dPtr->wColor.tBarColor = 0x020F;      break;   case dithered:      dPtr->wColor.tBarColor = 0x010F;      break;   }dPtr->wColor.growColor = 0xF0F0;dPtr->wColor.infoColor = 0x00F0;wParms.paramLength = sizeof(wParms);    /* initialize the window record */wParms.wFrameBits = 0x0025;if (fbTitle) wParms.wFrameBits |= fTitle;if (fbClose) wParms.wFrameBits |= fClose;if (fbAlert) wParms.wFrameBits |= fAlert;if (fbControls) wParms.wFrameBits = wParms.wFrameBits | fGrow | fBScroll | fRScroll;if (fbFlex) wParms.wFrameBits |= fFlex;if (fbZoom) wParms.wFrameBits |= fZoom;if (fbMove) wParms.wFrameBits |= fMove;if (fbCtlTie) wParms.wFrameBits |= fCtlTie;wParms.wTitle = dPtr->wName;wParms.wRefCon = 0;wParms.wZoom.h1 = 0; wParms.wZoom.h2 = 0;wParms.wZoom.v1 = 0; wParms.wZoom.v2 = 0;wParms.wColor = &dPtr->wColor;wParms.wYOrigin = 0;wParms.wXOrigin = 0;wParms.wDataH = 200;wParms.wDataW = 640;wParms.wMaxH = 0;wParms.wMaxW = 0;wParms.wScrollVer = 8; wParms.wScrollHor = 8;wParms.wPageVer = 0; wParms.wPageHor = 0;wParms.wInfoRefCon = 0;wParms.wInfoHeight = 0;wParms.wFrameDefProc = NULL;wParms.wInfoDefProc = NULL;wParms.wContDefProc = DrawContents;wParms.wPosition.v1 = 30;wParms.wPosition.h1 = 10;wParms.wPosition.v2 = 183;wParms.wPosition.h2 = 602;wParms.wPlane = (WindowPtr) topMost;wParms.wStorage = NULL;return NewWindow(&wParms);              /* open the window */}/***************************************************************** NewDocument** Open a new window, returning the pointer** Parameters:*    wName - name for the new window** Returns: Document pointer; NULL for an error****************************************************************/documentPtr NewDocument (char *wName){documentPtr dPtr;                       /* new document pointer */dPtr = malloc(sizeof(documentStruct)); /* allocate the record */if (dPtr != NULL) {   dPtr->onDisk = FALSE;                /* not on disk */   dPtr->wName[0] = strlen(wName);      /* set up the name */   strncpy(&dPtr->wName[1], wName, maxName);   dPtr->wPtr = NewWind(dPtr);          /* open the window */   if (dPtr->wPtr == NULL) {      FlagError(1, toolerror());        /* handle a window error */      free(dPtr);      dPtr = NULL;      }   else {      dPtr->next = documents;           /* put the document in the list */      documents = dPtr;      }   }else   FlagError(2, 0);                     /* handle an out of memory error */return dPtr;}/***************************************************************** DoAbout** Draw our about box****************************************************************/void DoAbout (void){#define alertID 1                       /* alert string resource ID */AlertWindow(awCString+awResource, NULL, alertID);#undef alertID}/***************************************************************** DoNew** Open a new document window****************************************************************/void DoNew (void){NewDocument(GetUntitledName());}/***************************************************************** FrameOption** Change a wFrameBits option** Parameters:*    id - menu ID for the option to change*    setting - (output) option flag variable****************************************************************/void FrameOption (int id, BOOLEAN *setting){*setting = !(*setting);CheckMItem(*setting, id);}/***************************************************************** TitleOption** Change the title bar kind option** Parameters:*    option - new title bar option****************************************************************/void TitleOption (titleKind option){CheckMItem(FALSE, titleSolid + titleBarKind);titleBarKind = option;CheckMItem(TRUE, titleSolid + titleBarKind);}/***************************************************************** HandleMenu** Initialize the menu bar.****************************************************************/void HandleMenu (void){int menuNum, menuItemNum;               /* menu number & menu item number */menuNum = myEvent.wmTaskData >> 16;menuItemNum = myEvent.wmTaskData;switch (menuItemNum) {                  /* go handle the menu */   case appleAbout:     DoAbout();                                      break;   case fileNew:        DoNew();                                        break;   case fileOpen:       DoNew();                                        break;   case fileClose:      CloseDocument(FindDocument(FrontWindow()));     break;   case fileQuit:       done = TRUE;                                    break;   case editUndo:                                                       break;   case editCut:                                                        break;   case editCopy:                                                       break;   case editPaste:                                                      break;   case editClear:                                                      break;   case frameTitle:     FrameOption(frameTitle, &fbTitle);              break;   case frameClose:     FrameOption(frameClose, &fbClose);              break;   case frameAlert:     FrameOption(frameAlert, &fbAlert);              break;   case frameControls:  FrameOption(frameControls, &fbControls);        break;   case frameFlex:      FrameOption(frameFlex, &fbFlex);                break;   case frameZoom:      FrameOption(frameZoom, &fbZoom);                break;   case frameMove:      FrameOption(frameMove, &fbMove);                break;   case frameCtlTie:    FrameOption(frameCtlTie, &fbCtlTie);            break;   case titleSolid:     TitleOption(solid);                             break;   case titleLined:     TitleOption(lined);                             break;   case titleDithered:  TitleOption(dithered);                          break;   }HiliteMenu(FALSE, menuNum);             /* unhighlight the menu */}/***************************************************************** InitMenus** Initialize the menu bar.****************************************************************/void InitMenus (void){#define menuID 1                        /* menu bar resource ID */int height;                             /* height of the largest menu */MenuBarRecHndl menuBarHand;             /* for 'handling' the menu bar */                                        /* create the menu bar */menuBarHand = NewMenuBar2(refIsResource, menuID, NULL);SetSysBar(menuBarHand);SetMenuBar(NULL);FixAppleMenu(1);                        /* add desk accessories */height = FixMenuBar();                  /* draw the completed menu bar */DrawMenuBar();#undef menuID}/***************************************************************** InitGlobals** Initialize the global variables****************************************************************/void InitGlobals (void){documents = NULL;                       /* no documents */fbTitle = TRUE;                         /* wFrameBits options */fbClose = TRUE;fbAlert = FALSE;fbControls = TRUE;fbFlex = TRUE;fbZoom = TRUE;fbMove = TRUE;fbCtlTie = TRUE;titleBarKind = lined;                   /* Title option */}/***************************************************************** Main program****************************************************************/int main (void){int event;                              /* event type returned by TaskMaster */startdesk(640);                         /* start the tools */InitMenus();                            /* set up the menu bar */InitCursor();                           /* start the arrow cursor */InitGlobals();                          /* initialize our global variables */done = FALSE;                           /* main event loop */myEvent.wmTaskMask = 0x001F7FFF;        /* let TaskMaster do it all */while (!done) {   event = TaskMaster(everyEvent, &myEvent);   switch (event) {      case wInSpecial:      case wInMenuBar:          HandleMenu();                                break;      case wInGoAway:           CloseDocument(FindDocument(                                   (GrafPortPtr) myEvent.wmTaskData));                                break;      }   }enddesk();}