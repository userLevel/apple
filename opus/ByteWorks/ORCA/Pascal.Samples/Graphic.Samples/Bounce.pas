{$keep 'Bounce'}program Bounce;{*****************************************************************  A simple graphics demo.**  Note: In addition do showing how to use QuickDraw without*  using the entire desktop, this program shows an easy way*  (by using the shell's stop command) to see if the user wants*  to stop the program early.  Note that this is safe even*  if the program is executed from the program launcher.*  The call woun't work, but it will not cause problems, either.*  To stop the program, hold down the open apple key and press*  the period key.**  By Phil Montoya**  Copyright 1987-1990*  Byte Works, Inc.****************************************************************}uses   Common, QuickDrawII, ORCAShell;const   screenMode  =   320;        { 320x200 graphics Super HiRes display mode }   copyMode    =   0;          { pen copy mode }   maxX        =   320;        { Maximum X coordinate (+1) }   maxY        =   200;        { Maximum Y coordinate (+1) }   size        =   6;          { number of points }var   curColor, curSize : integer;                { number of solutions found }   r : rect;   x, y, xv, yv : array[1..size] of integer;   { move and velocity arrays }   stopVar: stopDCB;                           { open-Apple-period pressed? }{*****************************************************************  UpDate - Updates x and y be velocity factors and changes*           direction if necessary**  Inputs:*       px - X location*       pxv - X velocity*       py - Y location*       pyv - Y velocity****************************************************************}procedure UpDate (var px, pxv, py, pyv : integer);beginpx := px + pxv;                        { move x by velocity factor }if (px < 0) or (px > maxX) then        { if x is beyond boarder }   begin   px := px - pxv;                     { move back }   pxv := -pxv;                        { change directions }   end;py := py + pyv;                        { move y by velocity factor }if (py < 0) or (py > maxY) then        { if y is beyond boarder }   begin   py := py - pyv;                     { move back }   pyv := -pyv;                        { change directions }   end;end;{*****************************************************************  NextPenColor - Changes the pen color****************************************************************}procedure NextPenColor;begincurColor := curColor + 1;          { get next color }if curColor > white then           { if out of colors then start over }   curColor := black;SetSolidPenPat(curColor);          { set the pen to this color }end;{*****************************************************************  Initialize - initialization for program****************************************************************}procedure Initialize;var i, j : integer;beginSetPenSize(4,2);                   { use a fatter pen }SetPenMode(copyMode);              { use the copy pen mode }SetRect(r, 0, 0, maxX, maxY);      { set r to the full screen }curColor := white;                 { start off with white }curSize := 2;                      { start off with two points }x[1] := 180;                       { initialize starting points }y[1] := 100;x[2] := 140;y[2] := 100;x[3] := 160;y[3] := 100;x[4] := 160;y[4] := 110;x[5] := 160;y[5] := 90;x[6] := 160;y[6] := 100;j := 6;                            { set velocity factors }for i := 1 to size do   begin   if odd(i) then       j := -j;   yv[i] := j;   xv[i] := -j;   j := j - 2;   end;end;{*****************************************************************  DrawShapes - This is the engine of the demo.****************************************************************}procedure DrawShapes;label 1;var i, j, k: integer;beginfor k := white downto black do         { cycle thru 16 screens }   begin   SetSolidPenPat(k);                  { set the background color }   PaintRect(r);   { The number of shapes per screen depends on the size of the   shape.  The more points a shape has the less times it will be   drawn and visa-versa.  This keeps the time and density per   screen approximately the same. }   for i := 1 to (((size-curSize) * 38) + 75) do       begin                           { draw this series of shapes }       NextPenColor;                   { change pen colors }       MoveTo(x[curSize],y[curSize]);  { initial from position }       for j := 1 to curSize do        { draw this shape }           begin           LineTo(x[j],y[j]);           Update(x[j],xv[j],y[j],yv[j]);           Stop(stopVar);           if stopVar.stopFlag then goto 1;           end;       end;   curSize := curSize + 1;             { next shape size }   if curSize > size then curSize := 2;   end;1:end;{*****************************************************************  Program Begins Here****************************************************************}beginStartGraph(screenMode);         { set up graphics screen }Initialize;                     { initialize our stuff }DrawShapes;                     { draw our shapes }EndGraph;                       { shut down the graphics screen }end.