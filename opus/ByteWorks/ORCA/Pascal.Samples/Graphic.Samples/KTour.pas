{$keep 'KTour'}program KnightsTour (output);{*****************************************************************  This is the classic knights tour problem.  Here a simple*  hueristic is applied in order to find a quick solution.*  Hold down the open-Apple key and then press the period key*  to abort the program before normal termination.**  By Phil Montoya**  Copyright 1987-1990*  Byte Works, Inc.****************************************************************}uses   Common, QuickDrawII, ORCAShell;const       screenMode = 320;        { 320x200 graphics Super HiRes display mode }       copyMode = 0;            { pen copy mode }       maxX = 320;              { Maximum X coordinate (+1) }       maxY = 200;              { Maximum Y coordinate (+1) }       size =   8;              { size of board }       sizeSqr =  64;           { number of squares on board }type       index = 1..size;         { legal values of board size }var       solutions, count: integer;      { number of solutions found    }       numMoves : longint;             { number of move/100           }       success : boolean;              { was the tour successful  }       r : rect;                       { rectangle                }       a : array [1..8] of integer;    { board }       b : array [1..8] of integer;       s : set of index;       board : array [index,index] of integer;       stopVar: stopDCB;               { for early termination }{*****************************************************************  DrawBlock - Draws either a colored block or a number in the block**  Inputs:*      x,y - block coordinates (0..7)*      tp - type of block to draw (0 color block 1 number block)*      num - number to print if a number block****************************************************************}procedure DrawBlock (x, y, tp, num : integer);const   blWidth     =   33;         { block width }   blLeftDisp  =   28;         { block left displacement from edge }   blHeight    =   20;         { block height }   blTopDisp   =   36;         { block top displacment from edge }beginif tp = 0 then                 { if we draw a block }   begin   if not (odd (x+y)) then     { set color for checkerboard effect }      SetSolidPenPat (white)   else      SetSolidPenPat (black);   SetRect (r, x * blWidth + blLeftDisp, y * blHeight + blTopDisp,            x * blWidth + blWidth + blLeftDisp,            y * blHeight + blHeight + blTopDisp);   PaintRect (r);   endelse if tp = 1 then   begin   if not (odd (x+y)) then       begin       SetForeColor (black);       SetBackColor (white);       end   else       begin       SetForeColor (white);       SetBackColor (black);       end;   if num < 10 then       begin       MoveTo (x * blWidth + blLeftDisp + 12, y * blHeight + blTopDisp + 15);       write (num:1);       end   else       begin       MoveTo (x * blWidth + blLeftDisp + 8, y * blHeight + blTopDisp + 15);       write (num:2);       end;   end;end;procedure Initialize;{*****************************************************************  Initialize****************************************************************}var   i, j : integer;beginsolutions := 0;count     := 100;numMoves  := 0;{ Draw the title }SetSolidPenPat (white);SetForeColor   (white);                { set the fore color }SetBackColor   (black);                { set the back color }SetPenMode     (copyMode);             { set pen mode to copy mode }MoveTo (118,10);write ('Knights Tour');MoveTo (27,25);write ('Solutions:');MoveTo (175,25);write ('Moves X 100:');MoveTo (27,35);                        { draw board's border }LineTo (292,35);LineTo (292,196);LineTo (27,196);LineTo (27,35);{ Draw the board and initialize board array }for i := 1 to size do   for j := 1 to size do       begin       DrawBlock (i-1,j-1,0,0);       board[i,j] := 0;       end;s := [1,2,3,4,5,6,7,8];         { define set of legal moves }a[1] := -2;  b[1] := -1;        { define legal moves }a[2] := -2;  b[2] :=  1;a[3] := -1;  b[3] :=  2;a[4] := -1;  b[4] := -2;a[5] :=  1;  b[5] := -2;a[6] :=  2;  b[6] := -1;a[7] :=  1;  b[7] :=  2;a[8] :=  2;  b[8] :=  1;end;procedure Pause;{*****************************************************************  Pause****************************************************************}var i, j : integer;begin{SetBackColor (black);for i := 0 to 300 do   begin   if (i mod 100) = 0 then       begin       for j := 0 to 1500 do;       SetForeColor (black);       MoveTo (110,25);       write (solutions:2);       for j := 0 to 1500 do;       SetForeColor (white);       MoveTo (110,25);       write (solutions:2);       end;   end;for i := 0 to 500 do   for j := 0 to 100 do;}end;procedure TryMove (i : integer; x, y : index);{*****************************************************************  TryMove****************************************************************}var k, u, v, j, w, z, t : integer;   moves, score : array [1..size] of integer;   done : boolean;beginif not stopVar.stopFlag then begin   stop (stopVar);   count := count + 1;   if count > 100 then      begin      count := 0;      SetForeColor (white);      SetBackColor (black);      MoveTo (265,25);      write (numMoves:1);      numMoves := numMoves + 1;      end;   for k := 1 to size do      begin      moves[k] := k;      score[k] := 0;      u := x + a[moves[k]];      v := y + b[moves[k]];      for j := 1 to size do          begin          w := u + a[j];          z := v + b[j];          if (w in s) and (z in s) then              if board[w,z] = 0 then                  score[k] := score[k] + 1;          end;      end;   repeat      done := true;      for j := 1 to size-1 do          if score[j] > score[j+1] then              begin              t := score[j];              score[j] := score[j+1];              score[j+1] := t;              t := moves[j];              moves[j] := moves[j+1];              moves[j+1] := t;              done := false;              end   until done;   for k := 1 to 8 do      begin      u := x + a[moves[k]];      v := y + b[moves[k]];      if (u in s) and (v in s) then          if board[u,v] = 0 then              begin              board[u,v] := i;              DrawBlock (u-1,v-1,1,i);              if i < sizeSqr then                  TryMove (i+1,u,v)              else                  begin                  solutions := solutions + 1;                  SetForeColor (white);                  SetBackColor (black);                  MoveTo (110,25);                  write (solutions:2);                  Pause;                  end;              board[u,v] := 0;              DrawBlock (u-1,v-1,0,0);              end;      end;   end;end;{*****************************************************************  Program Begins Here****************************************************************}beginStartGraph (screenMode);           { initialize the graphics screen }Initialize;                        { initialize program stuff }board[1,1] := 1;                   { set first move }DrawBlock (0,0,1,1);stopVar.stopFlag := false;TryMove (2,1,1);                   { make a move }EndGraph;                          { shut down the graphics screen }end.