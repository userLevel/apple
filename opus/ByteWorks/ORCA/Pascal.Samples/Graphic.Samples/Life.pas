{$keep 'Life'}program Life (output);{*****************************************************************  Plays Conway's 'game' of life, showing generations of the*  R-pentominoe.**  Use open-apple period to stop early.**  By Phil Montoya**  Copyright 1987-1990*  Byte Works, Inc.****************************************************************}uses   Common, QuickDrawII, ORCAShell;const       screenMode  = 320;       { 320x200 graphics Super HiRes display mode }       copyMode = 0;            { copy pen mode }       maxX = 320;              { Maximum X coordinate (+1) }       maxY = 200;              { Maximum Y coordinate (+1) }       height      = 100;       width       = 80;       minBound    = -1;type       edges = record          left, right,          top, bottom : integer;          end;var       population, births, deaths : integer;       curColor : integer;       edge : edges;       r : rect;       generation: integer;       board : packed array [minBound..height,minBound..width] of boolean;       nearby : array [minBound..height,minBound..width] of integer;       stopVar: stopDCB;        {for early exits}procedure ResetEdges;{*****************************************************************  ResetEdges - Initialize the edges of the pattern****************************************************************}beginwith edge do   begin   top := height-1;   right := minbound+1;   left := width-1;   bottom := minbound + 1;   end;end;procedure NextColor;{*****************************************************************  NextColor****************************************************************}beginif curColor = 15 then  curColor := 1else curColor := curColor + 1;end;procedure Initialize;{*****************************************************************  Initialize****************************************************************}var i,j : integer;beginSetPenMode (copyMode);curColor := 1;for i := minBound to height do  for j := minBound to width do    begin    board [i,j] := false;    nearby [i,j] := 0;    end;ResetEdges;end;procedure DrawPoint (X, Y, color : integer);{*****************************************************************  DrawPoint****************************************************************}begin  SetRect (r, X*4, Y*2, X*4+4, Y*2+2); { Define rectangle (l,t,r,b) }  SetSolidPenPat (color);              { define the pen color }  PaintRect (r);                       { paint the rectangle }end;function Max (A,B : integer) : integer;{*****************************************************************  Max****************************************************************}beginif A >= B then Max := Aelse Max := Bend;function Min (A,B : integer) : integer;{*****************************************************************  Min****************************************************************}beginif A <= B then Min := Aelse Min := Bend;procedure Limits (X,Y : integer);{*****************************************************************  Limits****************************************************************}beginwith edge do  begin  left := Min (left,X);  right := Max (right,X);  top := Min (top,Y);  bottom := Max (bottom,Y);  end;end;procedure ClearNearby;{*****************************************************************  ClearNearby****************************************************************}var i,j : integer;beginfor i := edge.top-1 to edge.bottom+1 do  for j := edge.left-1 to edge.right+1 do    nearby [i,j] := 0;end;procedure CountNeighbors;{*****************************************************************  CountNeighbors****************************************************************}var down, across : integer;    deltaDown, deltaAcross : integer;beginClearNearby;for down := edge.top-1 to edge.bottom+1 do  for across := edge.left-1 to edge.right+1 do    if board [down,across] = true then       for deltaDown := -1 to 1 do          for deltaAcross := -1 to 1 do             nearby [down+deltaDown,across+deltaAcross] :=             nearby [down+deltaDown,across+deltaAcross] + 1;end;procedure Update;{*****************************************************************  Update****************************************************************}var down, across : integer;   localEdge : edges;beginbirths := 0;deaths := 0;localEdge := edge;ResetEdges;for down := Max (minBound+1, localEdge.top-1) to            Min (height-1, localEdge.bottom+1) do  for across := Max (minBound+1, localEdge.left-1) to                 Min (width-1, localEdge.right+1) do    if board [down,across] = false then      begin      if nearby [down,across] = 3 then        begin        board [down,across] := true;        DrawPoint (across,down,curColor);        NextColor;        Limits (across,down);        births := births+1;        end;      end      else        begin        if (nearby [down,across] = 3) or (nearby [down,across] = 4) then            Limits(across,down)        else            begin            board [down,across] := false;            DrawPoint (across,down,0);            deaths := deaths + 1;            end;        end;population := population + births - deaths;end;procedure GetPositions;{*****************************************************************  GetPositions****************************************************************}beginpopulation := 5;Limits (40,49);board [49,40] := true;DrawPoint (40,49,15);NextColor;Limits (41,49);board [49,41] := true;DrawPoint (41,49,15);NextColor;Limits (39,50);board [50,39] := true;DrawPoint (39,50,15);NextColor;Limits (40,50);board [50,40] := true;DrawPoint (40,50,15);NextColor;Limits (40,51);board [51,40] := true;DrawPoint (40,51,15);end;{*****************************************************************  Program Begins Here****************************************************************}beginStartGraph (screenMode);Initialize;GetPositions;MoveTo (95,170);writeln ('Life: R-pentominoe');SetForeColor (6);generation := 0;repeat   CountNeighbors;   Update;   Stop (stopVar);   generation := generation+1;   MoveTo (110,180);   writeln ('Generation ',generation:1);until (population = 0) or ((births = 0) and (deaths = 0))   or stopVar.stopFlag;EndGraph;end.