{$keep 'Graph'}{$optimize 7}{---------------------------------------------------------------}{                                                               }{  Graph a function and its integral                            }{                                                               }{  Illustrates passing a function as a parameter to implement   }{  general routines for plotting functions in two dimensions.   }{                                                               }{  By Mike Westerfield                                          }{                                                               }{  Copyright 1987-1990                                          }{  Byte Works, Inc.                                             }{                                                               }{---------------------------------------------------------------}program Graph (input, output);uses   Common, QuickDrawII;const  minXc    =   0;                    { min X coordinate }  maxXc    =   600;                  { max X coordinate }  minYc    =   20;                   { min Y coordinate }  maxYc    =   199;                  { max Y coordinate }  minX     =   0;                    { min X value }  maxX     =   20.0;                 { max X value }  minY     =   -1.0;                 { min Y value }  maxY     =   2.0;                  { max Y value }  deltaX   =   0.2;                  { distance between plotted points }var  x, y: real;                            { x,y point in real space }  sum:  double;                          { sum of integral so far }  h, v: integer;                         { x,y point in graph space }   {**************************************************************   *   *  Fn: Returns function to plot.   *   **************************************************************}   function Fn (x: real): real;   begin { fn }   if x = 0.0 then       fn := 1.0   else       fn := sin(x)/x;   end; { fn }   {**************************************************************   *   *  Integral:  Integrates f from x1 to x2 using n integrals and   *             the trapezoidal rule for integration.   *   *   **************************************************************}   function Integral  ( x1, x2: real;  n: integer;                        function F (x: real):  real):                        real;   var       width:  real;                       { width of a single interval }       sum:    double;                     { integral so far }       i:      integer;                    { loop variable }   begin { Integral }   sum := 0.0;   width := (x2 - x1) / n;   for i := 0 to n-1 do       sum := sum + F (x1 + width / 2.0 + i * width) * width;   Integral := sum;   end; { Integral }   {**************************************************************   *   *  CoordToPoint:  Convert from a coordinate in real space to a   *                 point on the screen.   *   **************************************************************}   procedure CoordToPoint  ( minXc, maxXc, minYc, maxYc: integer;                             minX, maxX, minY, maxY: real;                             var xc, yc: integer;                             xp, yp: real);   begin { CoordToPoint }   xc := round ((xp - minX) * (maxXc - minXc) / (maxX - minX)) + minXc;   yc := maxYc - round ((yp - minY) * (maxYc - minYc) / (maxY - minY));   end; { CoordToPoint }   {**************************************************************   *   *  Axis:  Draw an X-Y axis.   *   *   **************************************************************}   procedure Axis  ( minXc, maxXc, minYc, maxYc: integer;                                                   { size of drawing area }                    minX, maxX, minY, maxY: real;  { range of values      }                    Xtics, Ytics: integer);        { # tic marks          }   var       h, v: integer;                          { work point               }       x, y: real;                             { work point in real space }       i:    integer;                          { loop variable            }   begin { Axis }   { Draw the axis }   SetSolidPenPat (15);   MoveTo (minXc, minYc);   LineTo (minXc, maxYc);   LineTo (maxXc, maxYc);   { Draw tic marks & labels on X axis }   for i := 0 to Xtics do begin       x := minX + i * (maxX - minX) / Xtics;       CoordToPoint (minXc, maxXc, minYc, maxYc, minX, maxX, minY, maxY,                     h, v, x, minY);       MoveTo (h, maxYc);       LineTo (h, maxYc - 6);       MoveTo(h - 10, maxYc + 10);       write (cnvrs (x, 4, 1));       end;   { Draw tic marks & labels on Y axis }   for i := 0 to Ytics do begin       y := minY + i * (maxY - minY) / Ytics;       CoordToPoint (minXc, maxXc, minYc, maxYc, minX, maxX, minY, maxY,                     h, v, minX, y);       MoveTo (minXc, v);       LineTo (minXc + 10, v);       MoveTo (minXc - 40, v + 4);       write (cnvrs (y, 4, 1));       end;   end; { Axis }{****************************************************************                      Main Program***************************************************************}begin{ Set up the screen }StartGraph (640);SetPenMode (0);SetPenSize (2, 1);{ Draw the axis }Axis (minXc + 100, maxXc, minYc, maxYc - 30, minX, maxX, minY, maxY, 10, 6);{ Draw the function }SetSolidPenPat (1);                      { Note: use another color on  }SetForeColor (1);                        {  monochrome screens         }MoveTo (250, 140);writeln ('Function: sin(x)/x');x := minX;CoordToPoint (minXc + 100, maxXc, minYc, maxYc - 30, minX, maxX, minY, maxY,              h, v, minX, Fn (minX));MoveTo (h, v);while x <= maxX do begin   y := Fn (x);   CoordToPoint (minXc + 100, maxXc, minYc, maxYc - 30, minX, maxX, minY, maxY,                 h, v, x, y);   LineTo (h, v);   x := x + deltaX;   end;{ Draw the integral }SetSolidPenPat (2);SetForeColor (2);MoveTo (250, 150);writeln ('Integral: computed via 400 point trapezoid rule');x := minX;CoordToPoint (minXc + 100, maxXc, minYc, maxYc - 30, minX, maxX, minY, maxY,              h, v, minX, 0.0);MoveTo (h, v);sum := 0.0;while x <= maxX do begin   sum := sum + Integral (x, x + deltaX, 4, fn);   x   := x + deltaX;   CoordToPoint (minXc + 100, maxXc, minYc, maxYc - 30, minX, maxX, minY, maxY,                 h, v, x, sum);   LineTo (h, v);   end;readln;                                { wait for a keypress }EndGraph;                              { shut down quickdraw }end.