{$keep 'Ackermann'}{$stacksize $4000, rangecheck+}{---------------------------------------------------------------}{                                                               }{  Ackermann                                                    }{                                                               }{  This program implements a famous mathematical function that  }{  is often used to examine recursion.  It is deceptively       }{  simple, but can take enormous amounts of time and stack      }{  space for relatively small arguments.  For that reason, the  }{  StackSize directive has been used to allocate 32K of stack   }{  space.  Rangechecking has also been enabled to ensure the    }{  integrity of the stack.                                      }{                                                               }{  By Mike Westerfield                                          }{                                                               }{  Copyright 1987-1990                                          }{  Byte Works, Inc.                                             }{                                                               }{---------------------------------------------------------------}program ackermann(output);const  maxm = 3;                             {max value of 1st argument}  maxn = 5;                             {max value of 2nd argument}var  a: integer;  m,n: integer;  depth,maxdepth: integer;  function Ackermann (m,n: integer): integer;  begin {Ackermann}  depth := depth+1;  if depth > maxdepth then maxdepth := depth;  if m = 0 then    Ackermann := n+1  else if n = 0 then    Ackermann := Ackermann(m-1,1)  else    Ackermann := Ackermann(m-1,Ackermann(m,n-1));  depth := depth-1;  end; {Ackermann}begin {main}for m := 0 to maxm do  for n := 0 to maxn do begin    depth := 0;    maxdepth := 0;    a := Ackermann(m,n);    writeln('Ackermann(',m:1,',',n:1,') = ',a:4,            'Max recursion depth was ':40,maxdepth:1);    end;end. {main}