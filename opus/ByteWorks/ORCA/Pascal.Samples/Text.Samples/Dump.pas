{$keep 'Dump'}{$optimize 7}{--------------------------------------------------------------}{                                                              }{  Dump                                                        }{                                                              }{  This program illustrates a variety of techniques by         }{  creating a program that can dump a file in hex.             }{  Techniques illustrated include:                             }{                                                              }{       1. Using the ORCA shell to handle wildcards.           }{       2. Reading the command line to get a file name.        }{       3. Reading a file byte by byte.                        }{       4. Error exits to the shell via the halt procedure.    }{                                                              }{  To run the program, first compile and link it.  Then        }{  create a short text file whose contents you would like to   }{  see dumped in hex.  Finally, execute the program with the   }{  command line:                                               }{                                                              }{      dump  infile                                            }{                                                              }{  where infile is the name of the file to dump.               }{                                                              }{  By Mike Westerfield                                         }{                                                              }{  Copyright 1987-1990                                         }{  Byte Works, Inc.                                            }{                                                              }{--------------------------------------------------------------}program Dump(output);uses Common,ORCAShell;type  lineType = string[255];var                                        {misc.}                                        {-----}  line: lineType;                       {holds the command line}  fName: lineType;                      {holds the file name}  toke: lineType;                       {dummy token, for unused parms}                                        {wildcard expansion}                                        {------------------}  IWDCB: initWildCardDCB;  NWDCB: nextWildCardDCB;  function GetToken(var token,line: lineType): boolean;  {read (and remove) the next token (word) from the command line}  {returns false if no token was found}  begin {GetToken}                                        {strinp leading blanks}  while (length(line) > 0) and (line[1] = ' ') do    delete(line,1,1);  if (length(line) > 0) and (line[1] <> ' ') then begin    GetToken := true;                   {form a token from the non-blank chars}    token := '';    while (length(line) > 0) and (line[1] <> ' ') do begin      token := concat(token,line[1]);      delete(line,1,1);      end;    end  else    GetToken := false;                  {no token found}  end; {GetToken}  procedure HexOut(n: longint; l: integer);  {writes n as an l byte hex number}  var    i: integer;                         {loop variable}    procedure NibbleOut(n: integer);    {write a nibble to the screen}    begin {NibbleOut}    if n >= 10 then      write(chr(ord('A')+n-10))    else      write(chr(ord('0')+n));    end; {NibbleOut}  begin {HexOut}  l := l*2;                             {convert from bytes to # digits}  for i := l-1 downto 0 do    NibbleOut(ord((n >> (i*4)) & $0000000F));  end; {HexOut}  procedure WriteFile;  {write the file f as a hex dump}  label 1,2;                            {for early loop exits}  var    pos: longint;                       {position in file}    i,cnt: integer;                     {loop and counter variables}    b: byte;                            {byte variable for file read}    f: file of byte;                    {input file}  begin {WriteFile}  reset(f,fName);                       {open the file}  if not eof(f) then begin    pos := 0;                           {set position in file to 0}    repeat                              {process the file...}      HexOut(pos,3);                    {write the position in the file}      write(':');      cnt := 0;                         {write the contents in hex}      for i := 0 to 15 do begin        if i & 3 = 0 then          write(' ');        read(f,b);        HexOut(b,1);        if eof(f) then goto 1;        cnt := i+1;        end;1:    for i := cnt+1 to 15 do begin     {if the loop ended early, padd  }        write('  ');                    { with spaces                   }        if i & 3 = 0 then          write(' ');        end;      seek(f,pos);                      {reposition to the start of this line}      get(f);      write('  ''');                    {write the file as ASCII characters}      for i := 0 to 15 do begin        read(f,b);        if (chr(b) >= ' ') and (chr(b) <= '~') then          write(chr(b))        else          write(' ');        if eof(f) then goto 2;        end;2:    writeln('''');      pos := pos+16;                    {update the position in the file}    until eof(f);    end; {if}  end; {WriteFile}beginCommandLine(line);                      {read the command line}if GetToken(toke,line) then begin       {strip the command name from the line}  if GetToken(fName,line) then begin    {read the file name}    if GetToken(toke,line) then begin   {check for unused parameters}      writeln(erroroutput,'Unused parameters found on command line.');      halt(-1);      end;    with IWDCB do begin                 {initialize for wildcard expansion}      wFile := @fName;      flags := 0;      end;    Init_WildCard(IWDCB);    NWDCB.nextFile := @fName;           {find the first matching file name}    Next_WildCard(NWDCB);    if length(fName) = 0 then begin      writeln(erroroutput,'The input file could not be found.');      halt(-1);      end;    WriteFile;                          {write the file as a hex dump}    end  else begin    writeln(erroroutput,'No file name found.');    halt(-1);    end;  endelse begin  writeln(erroroutput,'Command name not found.');  halt(-1);  end;end.