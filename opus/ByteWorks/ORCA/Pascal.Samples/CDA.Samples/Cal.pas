{$keep 'Calendar'}{$ClassicDesk 'Calendar' Start ShutDown}{--------------------------------------------------------------}{                                                              }{  Calendar                                                    }{                                                              }{  This classic desk accessory shows the calendar for the      }{  current date.  The arrow keys can be used to see calendars  }{  for previous or future months.                              }{                                                              }{  Commands (each is a single keystroke)                       }{                                                              }{       up-arrow        Look at the same month in the previous }{                       year.                                  }{       down-arrow      Look at the same month in the next     }{                       year.                                  }{       left-arrow      Look at the previous month.            }{       right-arrow     Look at the next month.                }{       ? or /          Display help screen.                   }{       ESC             Return to CDA main menu.               }{                                                              }{  Mike Westerfield                                            }{                                                              }{  Copyright 1987-1990                                         }{  Byte Works, Inc.                                            }{                                                              }{--------------------------------------------------------------}program Calendar (output);uses   Common, MscToolSet;var  bRam: array [0..255] of byte;        { battery RAM contents }{****************************************************************  Start:  Body of calendar program***************************************************************}procedure Start;const  esc           = $1B;                  { key codes for legal commands }  up_arrow      = $0B;  down_arrow    = $0A;  left_arrow    = $08;  right_arrow   = $15;  question      = $3F;  slash         = $2F;var  ch: integer;                         { ord of last character read }  month, year: integer;                { current month and year }   {*************************************************************   *   *  GetKey:  Returns the ordinal value of the next key typed   *           by the user.   *   *************************************************************}   function GetKey: integer;   var       keyboard, strobe: ^byte;           { keyboard and strobe pointers }   begin { GetKey }   keyboard := pointer ($00C000);   strobe := pointer ($00C010);   while keyboard^ < 128 do   { nothing } ;   GetKey := keyboard^ & $7F;   strobe^ := 0;   end; { GetKey }   {**************************************************************   *   *  GotoXY:  Positions the cursor   *   ***************************************************************}   procedure GotoXY (x, y: integer);   begin { GotoXY }   write (chr ($1E), chr ($20 + x), chr ($20 + y));   end; { GotoXY }   {***************************************************************   *   *  Factor:  Computes the 'factor' for the first day of the   *           month.  The factor is the number of days since   *           31 Dec 0000.   *   **************************************************************}   function Factor (year, month: longint): longint;   begin { Factor }   if month < 2 then       Factor := 365 * year + 1 + 31 * month + (year - 1) div 4 -                 ((year - 1) div 100 + 1) * 3 div 4   else       Factor := 365 * year + 1 + 31 * month- ((month + 1) * 4 + 23)                 div 10 + year div 4 - (year div 100 + 1) * 3 div 4;   end; { Factor }   {**************************************************************   *   *  GetThisMonth:  Reads the clock to obtain today's month   *   **************************************************************}   procedure GetThisMonth;   var       timeStr: packed array [0..19] of char;  { ASCII time string }       {***************************************************************       *       *  GetNum:  Reads a value from timeStr starting at       *           character loc       *       ***************************************************************}       function GetNum (loc: integer): integer;       begin { GetNum }       GetNum := ord (timeStr[loc]) & $F * 10 + ord (timeStr[loc + 1]) & $F;       end; { GetNum }   begin { GetThisMonth }   ReadBRam (@bRAM);                      { find out what date format is used }   ReadASCIITime (@timeStr);              { read the time string }   case bRam[$34] of       0: begin           year := GetNum (6);           month := GetNum (0);           end;       1: begin           year := GetNum (6);           month := GetNum (3);           end;       2: begin           year := GetNum (0);           month := GetNum (3);           end;       end; { case }   year := year + 1900;                    { adjust to this century }   month := month - 1;                     { month counts from 0, not 1 }   end; { GetThisMonth }   {***************************************************************   *   *  PrintCalendar:  Prints the calendar for the current   *                  and year.   *   ***************************************************************}   procedure PrintCalendar;   const       tab =   26;                     { disp of calendar from left edge }       vtab =  5;                      { disp of calendar from top }   var       startDay:   0..6;               { day of week for 1st day in month }       numDays:    1..31;              { # days in the month }       nextMonth:  0..12;              { work variables }       nextYear:   integer;       i:          1..32;              { loop variable }       vt:         0..23;              { line # for next line of days }       pos:        0..7;               { day position for next date }   begin { PrintCalendar }   { Compute day of week for 1st day in month }   startDay := ord ((Factor (year, month) - 1) mod 7);   nextMonth := month+1;                   { compute # days in month }   if nextMonth = 12 then begin       nextMonth := 0;       nextYear := year+1;       end   else       nextYear := year;   numDays := ord (Factor (nextYear, nextMonth) - Factor (year, month));   page;                                   { clear the screen }   GotoXY (tab+7, vtab);                   { position cursor }   case month of                           { write the month }       0: write (' January ');       1: write ('February ');       2: write ('  March ');       3: write ('  April ');       4: write ('   May ');       5: write ('  June ');       6: write ('  July ');       7: write (' August ');       8: write ('September ');       9: write (' October ');       10: write ('November ');       11: write ('December ');       end; { case month of }   write (year:1);                         { write the year }   GotoXY (tab, vtab+2);                   { write the day header line }   write ('Sun Mon Tue Wed Thu Fri Sat');   vt := vtab + 4;                         { set current date line }   pos := 0;                               { set day position }   GotoXY (tab - 1, vt);                   { position cursor for 1st line }   for i := 1 to startDay do begin         { skip over blank days }    pos := pos + 1;    write (' ':4);    end; { for }   { Write the dates }   for i := 1 to numDays do begin       write (i:4);       pos := pos+1;       if pos = 7 then begin           pos := 0;           vt := vt+2;           GotoXY (tab-1, vt);           end; { if }       end; { for }   GotoXY (25, 23);                        { write instructions }   write ('Hit ? for help,  or ESC to quit');   end; { PrintCalendar }   {***************************************************************   *   *  PrintHelp:  Print the help screen.   *   ***************************************************************}   procedure PrintHelp;   var       ch: integer;                    { dummy variable for reading keyboard }   begin { PrintHelp }   page;                               { clear screen }   writeln ('This program recognizes the following single-keystroke commands:');   writeln;   writeln;   writeln ('     key             action');   writeln ('     ---             ------');   writeln ('     up-arrow        Show the current month in the previous year.');   writeln ('     down-arrow      Show the current month in the next year.');   writeln ('     left-arrow      Show the previous month.');   writeln ('     right-arrow     Show the next month.');   writeln ('     ESC             exit the program.');   GotoXY (0, 23);   write ('Hit any key to return to the program.');   ch := GetKey;   end; { PrintHelp }{----------------------------------- Main program ---------------------------}begin { Start }write (chr (6));                       { turn the cursor off }GetThisMonth;                          { find out what month it is }PrintCalendar;                         { print the calendar for this month }repeat   ch := GetKey;                        { get a command }   case ch of       left_arrow: begin           month := month-1;           if month < 0 then begin               month := 11;               year := year-1;               end;           PrintCalendar;           end;       right_arrow: begin           month := month+1;           if month > 11 then begin               month := 0;               year := year+1;               end;           PrintCalendar;           end;       up_arrow: begin           year := year-1;           PrintCalendar;           end;       down_arrow: begin           year := year+1;           PrintCalendar;           end;       question, slash: begin           PrintHelp;           PrintCalendar;           end;       esc: ;       otherwise:           SysBeep;       end; { case ch of }until ch = esc;end; { Start }{**************************************************************{{  ShutDown: Does nothing{{************************************************************}procedure ShutDown;begin { ShutDown }end; { ShutDown }beginend.