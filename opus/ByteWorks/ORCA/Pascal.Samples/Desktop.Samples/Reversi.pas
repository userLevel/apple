{$keep 'Reversi'}{$optimize 1}{---------------------------------------------------------------}{                                                               }{  Reversi                                                      }{                                                               }{  A desktop program for the Apple IIgs.                        }{                                                               }{  Reversi is a board game played between two players.  This    }{  program will play against an aponent (probably you, but you  }{  could play it against another program), or it will play      }{  itself (usefull when you are learning).                      }{                                                               }{  The game is so popular and well known that we will assume    }{  you know how to play.  If not, several commercial versions   }{  of the game ara available, and all come with rules and       }{  basic strategy hints.  Many fine books are also available    }{  from your local book store.  When looking, you should note   }{  that the game is also sold under the name Othello.           }{                                                               }{  The program itself is provided as a real-world example of    }{  using the desktop.  Unlike the other samples on this disk,   }{  this program was designed as a working game, not as a        }{  sample.  For that reason, some problems that can be avoided  }{  by careful choice of a sample are handled here - like        }{  scrolling without the help of TaskMaster (to avoid scrolling }{  a small part of the moves window).                           }{                                                               }{  To learn how the program works, start with the main event    }{  loop at the end of the program, and examine how it handles   }{  each event.  The move selection procedure, FindMove, is the  }{  only place where this tactic is not likely to work.  That    }{  procedure uses a technique called an alpha-beta search to    }{  find the best move.  To understand that search, you should   }{  refer to text books on artificial intelegence, or to any     }{  one of several fine articles, mostly dealing with chess,     }{  that appeared in Byte in the early 1980's.                   }{                                                               }{  By Mike Westerfield                                          }{                                                               }{  Copyright 1987-1990                                          }{  Byte Works, Inc.                                             }{                                                               }{---------------------------------------------------------------}program Reversi(output);uses Common, QuickDrawII, EventMgr, WindowMgr, ControlMgr, DeskMgr,     DialogMgr, MenuMgr;const  return = 13;                          {RETURN key code}  squareWidth   = 52;                   {width of one square}  squareHeight  = 20;                   {height of one square}  blank         = 0;                    {square colors}  blackPiece    = 1;  whitePiece    = 2;  boarder       = 3;  apple_AboutReversi            = 257;  {menu names/numbers}  file_NewGame                  = 258;  file_Quit                     = 259;  edit_UndoLastMove             = 270;  edit_Cut                      = 271;  edit_Copy                     = 272;  edit_Paste                    = 273;  edit_Clear                    = 274;  level_1Ply                    = 262;  level_2Ply                    = 263;  level_3Ply                    = 264;  level_4Ply                    = 265;  level_5Ply                    = 266;  level_6Ply                    = 267;  level_7Ply                    = 268;  level_8Ply                    = 269;  options_SelfPlay              = 280;  options_ComputerPlaysWhite    = 281;  options_Pass                  = 282;  options_ShowScoreWindow       = 283;  options_ShowMovesWindow       = 284;type  alertKind = (norml,stop,note,caution); {kinds of alerts}  boardType = array[0..99] of byte;     {game board}  convert = record                      {for splitting 4 bytes to 2 bytes}    case boolean of      true : (long: longint);      false: (lsw,msw: integer);    end;  moveListType = record                 {move list}    num: integer;                       {# legal moves (max index + 1)}    moves: array[0..59] of byte;        {list of moves}    end;{-- Global variables ----------------------------------------------------------}var  color: integer;                       {color the computer plays}  done: boolean;                        {are we done yet?}  ply: 1..8;                            {playing level (ply)}  disp: array[0..7] of integer;         {move displacements}  selfPlay: boolean;                    {computer-human or computer-computer}  board: boardType;                     {main game board}  currentColor: integer;                {color to move next}  bSc: array[0..299] of integer;        {square scores for 3 portions of game}  movesLeft: boolean;                   {are there legal moves left?}  movesMade: integer;                   {# moves (by ply) made}  topMove: integer;                     {first visible move in moves list}  updateMoves: boolean;                {used to see if entire list needs update}  moves: array[1..60] of integer;       {list of moves made}  msg: pString;                         {for builing alert strings}  event: integer;                       {event #; returned by TaskMaster}  lastEvent: eventRecord;               {last event returned in event loop}  boardWindow: grafPortPtr;             {pointer to the game board window}  scoreWindow: grafPortPtr;             {pointer to the score window}  showScoreWindow: boolean;             {is scoreWindow visible?}  movesWindow: grafPortPtr;             {pointer to the moves window}  showMovesWindow: boolean;             {is movesWindow visible?}  growHandle: ctlRecHndl;               {moves window's grow box}  vScrollHandle: ctlRecHndl;            {moves window's vertical scroll bar}  movesNotFront: boolean;               {is the moves window the front window?}  moveHeight: integer;                  {current height of move window}  charHeight: integer;                  {size of a character}  selfPlayStr,computerPlayStr,          {strings for SetItem calls}  computerPlaysBlack,computerPlaysWhite: cString;{-- Utility routines ----------------------------------------------------------}procedure DoAlert(kind: alertKind;      {kind of the alert}                  msg: pString);        {message}{handle an alert box}var  message,button: itemTemplate;         {button & message items}  alertRec: alertTemplate;              {alert box}  junk: integer;                        {for receiving NoteAlert value}  i: integer;                           {loop variable}begin {DoAlert}SetForeColor(0);                        {set text colors}SetBackColor(15);with alertRec do begin                  {initialize alert box}  with atBoundsRect do begin    v1 := 50;  h1 := 180;    v2 := 107; h2 := 460;    end;  atAlertID := 2;  atStage1 := $80;  atStage2 := $80;  atStage3 := $80;  atStage4 := $80;  atItemList[1] := @button;  atItemList[2] := @message;  atItemList[3] := nil;  end;with button do begin                    {initialize button item}  itemID := 1;  with itemRect do begin    v1 := 36; h1 := 15;    v2 := 0; h2 := 0;    end;  itemType := 10;  itemDescr := @'OK';  itemValue := 0;  itemFlag := 0;  itemColor := nil;  end;with message do begin                   {initialize message item}  itemID := 100;  with itemRect do begin    v1 := 5; h1 := 100;    v2 := 90; h2 := 280;    end;  itemType := $800F;  itemDescr := @msg;  itemValue := 0;  itemFlag := 0;  itemColor := nil;  end;case kind of  norml:        junk := Alert(alertRec,nil);  stop:         junk := StopAlert(alertRec,nil);  note:         junk := NoteAlert(alertRec,nil);  caution:      junk := CautionAlert(alertRec,nil);  end; {case}end; {DoAlert}function Even(i: integer): integer;{returns an even number by incrementing odd paramaters - for move list }{ calculations.                                                        }begin {Even}if odd(i) then  Even := i+1else  Even := i;end; {Even}{-- Routines actually involved in playing the game ----------------------------}procedure DrawSquare(square: integer;   {square #}                     col: integer);     {color of square}{draw a square on the game board}const  penBlack      =  0;                   {pen colors}  penWhite      =  3;  penGreen      =  2;var  r: rect;                              {square's rectangle}  procedure Plot(h,v: integer);  {plot a point}  begin {Plot}  MoveTo(h,v);  LineTo(h,v);  end; {Plot}begin {DrawSquare}StartDrawing(boardWindow);              {draw to our window}with r do begin                         {set up the square's rectangle}  r.h2 := (square mod 10)*squareWidth-1;  r.v2 := (square div 10)*squareHeight-1;  r.h1 := r.h2-squareWidth+1;  r.v1 := r.v2-squareHeight+1;  end;SetSolidPenPat(penGreen);               {draw the background of the square}PaintRect(r);SetSolidPenPat(penBlack);               {draw the edge of the square}MoveTo(r.h1,r.v2);LineTo(r.h2,r.v2);LineTo(r.h2,r.v1);if square in [22,26,62,66] then         {draw "corner" dots, if required}  Plot(r.h2-1,r.v2-1)else if square in [23,27,63,67] then  Plot(r.h1,r.v2-1)else if square in [32,36,72,76] then  Plot(r.h2-1,r.v1)else if square in [33,37,73,77] then  Plot(r.h1,r.v1);if col <> blank then begin              {draw the peice, if any}  if col = whitePiece then    SetSolidPenPat(penWhite);  PaintOval(r);  end;end; {DrawSquare}procedure DrawBoard;{Draw (or redraw) the entire game board}var  i: integer;                           {loop variable}  col: integer;                         {column #}begin {DrawBoard}for i := 11 to 88 do begin  col := i mod 10;  if (col <> 0) and (col <> 9) then    DrawSquare(i,board[i]);  end;end; {DrawBoard}procedure GetMoves(board: boardType;    {board to find moves on}                   color: integer;      {color to find moves for}                   var moveList: moveListType); {move list}{create a list of legal moves}label 1;var  index: integer;                       {square being checked}  tindex: integer;                      {work index}  enemyColor: integer;                  {temp variable for enemy color}  dir: integer;                         {direction being checked}  lMoveList: moveListType;              {local move list - for efficiency}begin {GetMoves}enemyColor := color ! 3;                {set enemy color}lMoveList.num := 0;                     {no moves so far}for index := 11 to 89 do begin          {loop over all squares}  if board[index] = blank then          {check only empty squares}    for dir := 0 to 7 do begin          {loop in all 8 directions}      tindex := index+disp[dir];        {see if there is a capture in   }      if board[tindex] = enemyColor     { this direction                }        then begin        while board[tindex] = enemyColor do {skip enemy pieces}          tindex := tindex+disp[dir];        if board[tindex] = color then   {if last piece is ours, move is legal}          begin          lMoveList.moves[lMoveList.num] := index;          lMoveList.num := lMoveList.num+1;          goto 1;          end; {if}        end; {if}      end; {for}1:  end; {for}moveList := lMoveList;                  {return move list}end; {GetMoves}procedure CheckForDone;{checks to see if the game is over}var  moveList: moveListType;               {for checking # of moves}  wcnt,bcnt: integer;                   {# pieces for each side}  i: integer;                           {loop variable}begin {CheckForDone}GetMoves(board,whitePiece,moveList);if moveList.num = 0 then begin  GetMoves(board,blackPiece,moveList);  if moveList.num = 0 then begin    wcnt := 0;    bcnt := 0;    for i := 11 to 89 do begin      if board[i] = whitePiece then wcnt := wcnt+1;      if board[i] = blackPiece then bcnt := bcnt+1;      end;    if wcnt = bcnt then      msg := concat('The game is over.  It',chr(return),'is a draw.')    else begin      if wcnt > bcnt then        msg := 'White'      else        msg := 'Black';      msg := concat(msg,' wins by a score',chr(return),'of ',        cnvis(bcnt),' to ',cnvis(wcnt),'.');      end;    DoAlert(note,msg);    movesLeft := false;    end;  end;end; {CheckForDone}function Score(board: boardType):       {board to score}               integer;                 {score of board}{compute the score for the board passed}type  edgeType = array[0..9] of integer;    {edge of a board}var  s,rs: integer;                        {temp variables for scoring}  i: integer;                           {loop variable}  pi: integer;                          {game portion index}  numPieces: integer;                   {# pieces on board}  edge: edgeType;                       {for scoring edges}  function ScoreEdge(edge: edgeType): integer;  {Score an edge by the following rules:    1. An edge must have at least one empty square to be scored.    2. If there is a single space between friendly peices, score -100.    3. If there are two spaces between friendly bieces, score 30.    4. If there are three spaces between friendly pieces, score -50.    5. If there is a solid line of enemy pieces between friendly       pieces, score -150;  }  var    atLeastOneBlank: boolean;           {for checking rule #1}    i,j: integer;                       {loop variable}    s,rs: integer;                      {for computing scores}    enemyColor: integer;                {temp variable for enemy color}  begin {ScoreEdge}  s := 0;                               {init score}  atLeastOneBlank := false;             {check rule 1}  for i := 1 to 8 do    atLeastOneBlank := atLeastOneBlank or (edge[i] = blank);  if atLeastOneBlank then    for i := 1 to 7 do                  {check all positions on edge}      if edge[i] in [blackPiece,whitePiece] then begin        enemyColor := edge[i] ! 3;        j := i+1;        if edge[j] = enemyColor then    {check rule 5}          begin          while edge[j] = enemyColor do            j := j+1;          if edge[j] = edge[i] then            if enemyColor = whitePiece then              s := s-150            else              s := s+150;          end        else if edge[j] = blank then    {check rules 2..4}          begin          while edge[j] = blank do            j := j+1;          if edge[j] = edge[i] then begin            case j-i of              2: rs := -100;            {score rule 2}              3: rs := 30;              {score rule 3}              4: rs := -50;             {score rule 4}              otherwise: ;              end; {case}            if edge[i] = whitePiece then              s := s-rs            else              s := s+rs;            end; {if}          end; {else if}        end; {if}  ScoreEdge := s;  end; {ScoreEdge}begin {Score}s := 0;                                 {initialize score to 0}numPieces := 0;                         {# pieces is 0}for i := 11 to 89 do                    {loop over all squares}  if board[i] = whitePiece then begin   {add 4 for black, dec 4 for white}    s := s-4;    numPieces := numPieces+1;    end  else if board[i] = blackPiece then begin    s := s+4;    numPieces := numPieces+1;    end;if numPieces < 24 then                  {set index into board scores    }  pi := 0                               { by what part of the game this }else if numPieces < 44 then             { is                            }  pi := 100else  pi := 200;for i := 11 to 89 do begin              {loop over all squares}                                        {add in square values}  if board[i] in [blackPiece,whitePiece] then begin    if i in [12,21,22] then             {squares adjacent to corners    }                                        { get special treatment         }      if board[11] in [blackPiece,whitePiece] then        rs := 10      else        rs := bSc[pi+i]    else if i in [17,27,28] then      if board[18] in [blackPiece,whitePiece] then        rs := 10      else        rs := bSc[pi+i]    else if i in [71,72,82] then      if board[81] in [blackPiece,whitePiece] then        rs := 10      else        rs := bSc[pi+i]    else if i in [77,78,87] then      if board[88] in [blackPiece,whitePiece] then        rs := 10      else        rs := bSc[pi+i]    else      rs := bSc[pi+i];    if board[i] = whitePiece then      s := s-rs    else      s := s+rs;    end; {if}  end; {for}for i := 0 to 9 do                      {score top edge}  edge[i] := board[10+i];s := s+ScoreEdge(edge);for i := 0 to 9 do                      {score bottom edge}  edge[i] := board[i+80];s := s+ScoreEdge(edge);for i := 0 to 9 do                      {score left edge}  edge[i] := board[1+i*10];s := s+ScoreEdge(edge);for i := 0 to 9 do                      {score right edge}  edge[i] := board[8+i*10];s := s+ScoreEdge(edge);Score := s;                             {set the return value}end; {Score}procedure MakeAMove(index: integer;     {board index of move to make}                    col: integer);      {color of player making move}{make a move on the main playing board}const  pause         = 100;                  {index for pause}var  i: integer;                           {loop variable}  dir: integer;                         {loop variable for directions}  tindex: integer;                      {temp index; for captures}  enemyColor: integer;                  {temp variable for enemy color}begin {MakeAMove}movesMade := movesMade+1;               {record the move}moves[movesMade] := index;DrawSquare(index,col);                  {flash the piece played}for i := 1 to pause do ;DrawSquare(index,blank);for i := 1 to pause do ;DrawSquare(index,col);board[index] := col;                    {make the move on the board}enemyColor := col ! 3;                  {set enemy color}for dir := 0 to 7 do begin              {loop in all 8 directions}  tindex := index+disp[dir];            {see if there is a capture in   }  if board[tindex] = enemyColor then    { this direction                }    begin    while board[tindex] = enemyColor do {skip enemy pieces}      tindex := tindex+disp[dir];    if board[tindex] = col then begin   {if last piece is ours, capture}      tindex := index+disp[dir];      while board[tindex] <> col do begin        DrawSquare(tindex,col);        board[tindex] := col;        tindex := tindex+disp[dir];        end; {while}      end; {if}    end; {if}  end; {for}end; {MakeAMove}procedure FindMove(col: integer);       {color to move for}{make a computer generated move}var  moveList: moveListType;               {list of legal moves}  bmove: integer;                       {best move from this level}  bscore: integer;                      {best score from this level}  s: integer;                           {work copy of score}  i: integer;                           {loop variable}  function ScoreMove(board: boardType;  {board to make move on}                    index: integer;     {move to make}                    s: integer;         {best score at previous level}                    col: integer;       {color to optimize for}                    level: integer):    {ply level of this evaluation}                    integer;            {return score for move}  {find the score for a particular move}  var    bscore: integer;                    {best score from this level}    bmove: integer;                     {best move from this level}    moveList: moveListType;             {list of legal moves}    enemyColor: integer;                {color of the enemy peices}    dir: integer;                       {direction loop variable}    tindex: integer;                    {temp board index; for captures}    i: integer;                         {loop variable}    function EndScore(board: boardType): {board to score}                      integer;          {score of board}    {compute an end game score (no more moves) for the board passed}    var      s: integer;                       {work copy of score}      i: integer;                       {loop variable}    begin {EndScore}    s := 0;                             {initialize score to 0}    for i := 11 to 89 do                {count difference in pieces}      if board[i] = whitePiece then        s := s-1      else if board[i] = blackPiece then        s := s+1;    if s < 0 then                       {set the return value}      EndScore := -maxint+65+s    else if s > 0 then      EndScore := maxint-65+s    else      EndScore := 0;    end; {EndScore}  begin {ScoreMove}  {--- Part 1 -------------------------- make the move passed}  enemyColor := col ! 3;                {set enemy color}  if index <> 0 then begin              {if there was a move, make it}    board[index] := col;                {make the move on the board}    for dir := 0 to 7 do begin          {loop in all 8 directions}      tindex := index+disp[dir];        {see if there is a capture in   }      if board[tindex] = enemyColor then {this direction                }        begin        while board[tindex] = enemyColor do {skip enemy pieces}          tindex := tindex+disp[dir];        if board[tindex] = col then     {if last piece is ours, capture}          begin          tindex := index+disp[dir];          while board[tindex] <> col do begin            board[tindex] := col;            tindex := tindex+disp[dir];            end; {while}          end; {if}        end; {if}      end; {for}    end; {if}  {--- Part 2 -------------------------- score the board}  if level = ply then                   {if at max depth, score is static score}    ScoreMove := Score(board)  else begin                            {else pick from available moves}    GetMoves(board,enemyColor,moveList); {get a list of legal moves}    if enemyColor = whitePiece then     {initial score is worst possible, so }      bscore := maxint                  { that any alternative is selected   }    else      bscore := -maxint;    if moveList.num = 0 then begin      {if no moves, check for end of game}      GetMoves(board,col,moveList);      if moveList.num = 0 then        bscore := EndScore(board)      else        bscore := ScoreMove(board,0,bscore,enemyColor,level+1);      end    else begin      for i := 0 to moveList.num-1 do   {scan and score available moves}        begin        s := ScoreMove(board,moveList.moves[i],bscore,enemyColor,level+1);        if enemyColor = whitePiece then {if this is the best so far, remember  }          begin                         { the move                             }          if s < bscore then begin            bscore := s;            bmove := moveList.moves[i];            end;          end        else begin          if s > bscore then begin            bscore := s;            bmove := moveList.moves[i];            end;          end;        end;      end;    ScoreMove := bscore;    end;  end; {ScoreMove}begin {FindMove}WaitCursor;                             {change to the watch cursor}GetMoves(board,col,moveList);           {get a list of legal moves}if moveList.num = 1 then                {if there is only one move, make it}  MakeAMove(moveList.moves[0],col)else if moveList.num > 1 then begin     {if there is more than one, select}  if col = whitePiece then              {initial score is worst possible, so }    bscore := maxint                    { that any alternative is selected   }  else    bscore := -maxint;  for i := 0 to moveList.num-1 do begin {scan and score available moves}    s := ScoreMove(board,moveList.moves[i],bscore,col,1);    if col = whitePiece then begin      {if this is the best so far, remember  }      if s < bscore then begin          { the move                             }        bscore := s;        bmove := moveList.moves[i];        end;      end    else {if col = blackPiece then} begin      if s > bscore then begin        bscore := s;        bmove := moveList.moves[i];        end;      end;    end;  MakeAMove(bmove,col);                 {make the best move found }  endelse {no legal moves} begin  msg := concat('I cannot move, so I',chr(return),'must pass.',chr(return));  InitCursor;  DoAlert(note,msg);  WaitCursor;  end;InitCursor;                             {back to the arrow cursor}CheckForDone;end; {FindMove}procedure DrawMoves; forward;{Write the contents of the moves window}procedure DrawScore; forward;{Write the contents of the scores window}procedure NewGame;{set up the board for a new game}var  i: integer;                           {loop variable}  col,row: integer;                     {row, column numbers}  r: rect;                              {rectangle for clearing moves window}  port: grafPortPtr;                    {graph port pointer}begin {NewGame}for i := 0 to 99 do begin               {initialize the game board}  col := i mod 10;  row := i div 10;  if (row = 0) or (col = 0) or (row = 9) or (col = 9) then    board[i] := boarder  else    board[i] := blank;  end;board[44] := whitePiece; board[55] := whitePiece;board[45] := blackPiece; board[54] := blackPiece;currentColor := blackPiece;             {black moves first}movesLeft := true;                      {the game is not over yet...}movesMade := 0;                         {empty the moves list}topMove := 1;                           {first visible move in moves list}updateMoves := true;                    {draw entire list}if showMovesWindow then begin           {if move list is visible, clear it}  port := GetPort;                      {save the graph port}  StartDrawing(movesWindow);            {draw to the moves window}  GetPortRect(r);                       {get the rectangle}  EraseRect(r);                         {erase the window's contents}  DrawControls(movesWindow);            {draw the controls}  SetPort(port);                        {restore the old graph port}  DrawMoves;                            {draw the pieces}  end;if showScoreWindow then  DrawScore;                            {redraw the scores window}end; {NewGame}{-- Initialization ------------------------------------------------------------}procedure InitMenus;{create and draw the initial menu bar}var  height: integer;                      {height of the largest menu}  menuHand: menuHandle;                 {for 'handling' windows}  s: textPtr;                           {for builing menus}begin {InitMenus}new(s);                                 {create the options menu}s^ := concat('>>  Options  \N5',chr(return));s^ := concat(s^,'--Self Play\N280',chr(return));s^ := concat(s^,'--Computer Plays Black\N281',chr(return));s^ := concat(s^,'---\N514D',chr(return));s^ := concat(s^,'--Pass\N282',chr(return));s^ := concat(s^,'--Show Score Window\N283',chr(return));s^ := concat(s^,'--Show Moves Window\N284',chr(return));s^ := concat(s^,'.',chr(return));menuHand := NewMenu(s);InsertMenu(menuHand,0);new(s);                                 {create the level menu}s^ := concat('>>  Level  \N4',chr(return));s^ := concat(s^,'--1 Ply\N262',chr(return));s^ := concat(s^,'--2 Ply\N263',chr(return));s^ := concat(s^,'--3 Ply\N264',chr(return));s^ := concat(s^,'--4 Ply\N265',chr(return));s^ := concat(s^,'--5 Ply\N266',chr(return));s^ := concat(s^,'--6 Ply\N267',chr(return));s^ := concat(s^,'--7 Ply\N268',chr(return));s^ := concat(s^,'--8 Ply\N269',chr(return));s^ := concat(s^,'.',chr(return));menuHand := NewMenu(s);InsertMenu(menuHand,0);new(s);                                 {create the edit menu}s^ := concat('>>  Edit  \N3',chr(return));s^ := concat(s^,'--Undo Last Move\N270D*Zz',chr(return));s^ := concat(s^,'---\N512D',chr(return));s^ := concat(s^,'--Cut\N271D*Xx',chr(return));s^ := concat(s^,'--Copy\N272D*Cc',chr(return));s^ := concat(s^,'--Paste\N273D*Vv',chr(return));s^ := concat(s^,'--Clear\N274D',chr(return));s^ := concat(s^,'.',chr(return));menuHand := NewMenu(s);InsertMenu(menuHand,0);new(s);                                 {create the file menu}s^ := concat('>>    File  \N2',chr(return));s^ := concat(s^,'--New Game\N258*Nn',chr(return));s^ := concat(s^,'---\N513D',chr(return));s^ := concat(s^,'--Quit\N259*Qq',chr(return));s^ := concat(s^,'.',chr(return));menuHand := NewMenu(s);InsertMenu(menuHand,0);new(s);                                 {create the apple menu}s^ := concat('>>@\XN1',chr(return));s^ := concat(s^,'--About Reversi\N257',chr(return));s^ := concat(s^,'---\N513D',chr(return));s^ := concat(s^,'.',chr(return));menuHand := NewMenu(s);InsertMenu(menuHand,0);FixAppleMenu(1);                        {add desk accessories}height := FixMenuBar;                   {draw the completed menu bar}DrawMenuBar;CheckMItem(true,level_1Ply);            {check ply 1}end; {InitMenus}procedure InitVariables;{initialize global variables}var  i: integer;                           {loop variable}  r: rect;                              {rectangle for finding height of chars}begin {InitVariables}color := whitePiece;                    {computer plays white by default}ply := 1;                               {set initial ply level to 1}selfPlay := false;                      {computer vs human}showScoreWindow := false;               {score window is not visible}showMovesWindow := false;               {moves window is not visible}CharBounds('A',r);                      {find the height of a character}charHeight := r.h2-r.h1;NewGame;                                {set up the board for a new game}disp[0] := 9;                           {initialize directions array}disp[1] := 10;disp[2] := 11;disp[3] := -1;disp[4] := 1;disp[5] := -9;disp[6] := -10;disp[7] := -11;for i := 0 to 299 do                    {set up the square scores}  bSc[i] := 0;bSc[011] := 500; bSc[012] := -20; bSc[013] := 100; bSc[014] :=  50;bSc[015] :=  50; bSc[016] := 100; bSc[017] := -20; bSc[018] := 500;bSc[021] := -20; bSc[022] :=-250; bSc[023] :=  -2; bSc[024] :=  -2;bSc[025] :=  -2; bSc[026] :=  -2; bSc[027] :=-250; bSc[028] := -20;bSc[031] := 100; bSc[032] :=  -2; bSc[033] :=  30; bSc[034] :=  10;bSc[035] :=  10; bSc[036] :=  30; bSc[037] :=  -2; bSc[038] := 100;bSc[041] :=  50; bSc[042] :=  -2; bSc[043] :=  10; bSc[044] :=   2;bSc[045] :=   2; bSc[046] :=  10; bSc[047] :=  -2; bSc[048] :=  50;bSc[051] :=  50; bSc[052] :=  -2; bSc[053] :=  10; bSc[054] :=   2;bSc[055] :=   2; bSc[056] :=  10; bSc[057] :=  -2; bSc[058] :=  50;bSc[061] := 100; bSc[062] :=  -2; bSc[063] :=  30; bSc[064] :=  10;bSc[065] :=  10; bSc[066] :=  30; bSc[067] :=  -2; bSc[068] := 100;bSc[071] := -20; bSc[072] :=-250; bSc[073] :=  -2; bSc[074] :=  -2;bSc[075] :=  -2; bSc[076] :=  -2; bSc[077] :=-250; bSc[078] := -20;bSc[081] := 500; bSc[082] := -20; bSc[083] := 100; bSc[084] :=  50;bSc[085] :=  50; bSc[086] := 100; bSc[087] := -20; bSc[088] := 500;bSc[111] := 500; bSc[112] := -20; bSc[113] := 200; bSc[114] :=  50;bSc[115] :=  50; bSc[116] := 200; bSc[117] := -20; bSc[118] := 500;bSc[121] := -20; bSc[122] :=-250; bSc[123] :=  15; bSc[124] :=  10;bSc[125] :=  10; bSc[126] :=  15; bSc[127] :=-250; bSc[128] := -20;bSc[131] := 200; bSc[132] :=  15; bSc[133] :=  35; bSc[134] :=  20;bSc[135] :=  20; bSc[136] :=  35; bSc[137] :=  15; bSc[138] := 200;bSc[141] :=  50; bSc[142] :=  10; bSc[143] :=  20; bSc[144] :=  15;bSc[145] :=  15; bSc[146] :=  20; bSc[147] :=  10; bSc[148] :=  50;bSc[151] :=  50; bSc[152] :=  10; bSc[153] :=  20; bSc[154] :=  15;bSc[155] :=  15; bSc[156] :=  20; bSc[157] :=  10; bSc[158] :=  50;bSc[161] := 200; bSc[162] :=  15; bSc[163] :=  35; bSc[164] :=  20;bSc[165] :=  20; bSc[166] :=  35; bSc[167] :=  15; bSc[168] := 200;bSc[171] := -20; bSc[172] :=-250; bSc[173] :=  15; bSc[174] :=  10;bSc[175] :=  10; bSc[176] :=  15; bSc[177] :=-250; bSc[178] := -20;bSc[181] := 500; bSc[182] := -20; bSc[183] := 200; bSc[184] :=  50;bSc[185] :=  50; bSc[186] := 200; bSc[187] := -20; bSc[188] := 500;bSc[211] := 400; bSc[212] := -20; bSc[213] := 100; bSc[214] :=  75;bSc[215] :=  75; bSc[216] := 100; bSc[217] := -20; bSc[218] := 400;bSc[221] := -20; bSc[222] :=-300; bSc[223] :=  60; bSc[224] :=  10;bSc[225] :=  10; bSc[226] :=  60; bSc[227] :=-300; bSc[228] := -20;bSc[231] := 100; bSc[232] :=  60; bSc[233] :=  50; bSc[234] :=   5;bSc[235] :=   5; bSc[236] :=  50; bSc[237] :=  60; bSc[238] := 100;bSc[241] :=  75; bSc[242] :=  10; bSc[243] :=   5; bSc[244] :=  30;bSc[245] :=  30; bSc[246] :=   5; bSc[247] :=  10; bSc[248] :=  75;bSc[251] :=  75; bSc[252] :=  10; bSc[253] :=   5; bSc[254] :=  30;bSc[255] :=  30; bSc[256] :=   5; bSc[257] :=  10; bSc[258] :=  75;bSc[261] := 100; bSc[262] :=  60; bSc[263] :=  50; bSc[264] :=   5;bSc[265] :=   5; bSc[266] :=  50; bSc[267] :=  60; bSc[268] := 100;bSc[271] := -20; bSc[272] :=-300; bSc[273] :=  60; bSc[274] :=  10;bSc[275] :=  10; bSc[276] :=  60; bSc[277] :=-300; bSc[278] := -20;bSc[281] := 400; bSc[282] := -20; bSc[283] := 100; bSc[284] :=  75;bSc[285] :=  75; bSc[286] := 100; bSc[287] := -20; bSc[288] := 400;                                        {set up strings for SetMItem}selfPlayStr := '--Self Play';computerPlayStr := '--Play Computer';computerPlaysBlack := '--Computer Plays Black';computerPlaysWhite := '--Computer Plays White';end; {InitVariables}procedure InitWindow;{draw the board's window}const  scoreWidth = 96;                      {width of score, moves windows}var  windowName: pStringPtr;               {pointer to window name}  bWindow: paramListPtr;                {record for board's window}  r: rect;                              {for seting sizes of controls}  procedure OpenWindow;  {do the assignments to set up common window parms}  begin {OpenWindow}  new(bWindow);                         {initialize the window record}  with bWindow^ do begin    paramLength := 78;    wFrameBits := $80E4;    wTitle := pointer(windowName);    wRefCon := 0;    wZoom.h1 := 0; wZoom.h2 := 0;    wZoom.v1 := 0; wZoom.v2 := 0;    wColor := nil;    wYOrigin := 0; wXOrigin := 0;    wDataH := squareHeight*8;    wDataW := squareWidth*8;    wMaxH := squareHeight*8;    wMaxW := squareWidth*8;    wScrollVer := 0; wScrollHor := 0;    wPageVer := 0; wPageHor := 0;    wInfoRefCon := 0; wInfoHeight := 0;    wFrameDefProc := nil;    wInfoDefProc := nil;    wContDefProc := nil;    wPosition.v1 := 32;    wPosition.h1 := 32;    wPosition.v2 := 32+wDataH;    wPosition.h2 := 32+wDataW;    wPlane := pointer(topMost);    wStorage := nil;    end;  end; {OpenWindow}begin {InitWindow}new(windowName);                        {initialize the board window}windowName^ := 'Reversi';OpenWindow;boardWindow := NewWindow(bWindow^);new(windowName);                        {initialize the scores window}windowName^ := 'Scores';OpenWindow;with bWindow^ do begin  wFrameBits := $C0C4;  wDataH := 29; wDataW := scoreWidth;  wMaxH := 29;  wMaxW := scoreWidth;  wPosition.v1 := 32; wPosition.h1 := 640-32-scoreWidth;  wPosition.v2 := 61; wPosition.h2 := 640-32;  end;scoreWindow := NewWindow(bWindow^);new(windowName);                        {initialize the moves window}windowName^ := 'Moves';OpenWindow;with bWindow^ do begin  wFrameBits := $C0C4;  wDataH := 112; wDataW := scoreWidth;  wMaxH := squareHeight*8; wMaxW := scoreWidth;  wPosition.v1 := 80; wPosition.h1 := 640-32-scoreWidth;  wPosition.v2 := 192; wPosition.h2 := 640-32;  end;movesWindow := NewWindow(bWindow^);r.h1 := scoreWidth-23;                  {create a grow box}r.h2 := scorewidth+1;r.v1 := 100; r.v2 := 113;growHandle := NewControl(movesWindow,r,nil,0,0,0,0,pointer($08000000),0,nil);r.v1 := 0; r.v2 := 101;                 {create scroll bar}vScrollHandle :=  NewControl(movesWindow,r,nil,3,0,112,25,pointer($06000000),0,nil);moveHeight := 112;                      {set height of window}SelectWindow(boardWindow);              {make game board the front window}end; {InitWindow}{-- Action Routines -----------------------------------------------------------}procedure DrawMoves;{Write the contents of the moves window}var  port,p2: grafPortPtr;                    {graph port pointer}  i,n: integer;                         {index variables}  r: rect;                              {rectangle for drawing colors}  ctl: ctlRecHndl;                      {for finding scroll bar}  procedure WriteMove(move: integer);  {write a move to the screen}  begin {WriteMove}  write(chr(move mod 10 -1+ord('A')),9-(move div 10):1,' ');  end; {WriteMove}begin {DrawMoves}if showMovesWindow then begin  port := GetPort;                      {save the graph port}  StartDrawing(movesWindow);            {draw to the score window}  SetForeColor(0);                      {black pen on white background}  SetBackColor(15);  if updateMoves then begin    SetSolidPenPat(0);                  {draw black column header}    r.v1 := 5; r.h1 := 26;    r.v2 := 13; r.h2 := 40;    PaintOval(r);    r.v1 := 5; r.h1 := 47;              {draw white column header}    r.v2 := 13; r.h2 := 61;    PaintOval(r);    SetSolidPenPat(15);    r.v1 := 6; r.h1 := 48;    r.v2 := 12; r.h2 := 60;    PaintOval(r);    end;  if movesMade > 0 then begin    MoveTo(2,25);                       {draw the moves}    i := topMove;    n := (i+1) div 2;    while i <= movesMade do begin      if updateMoves or (i > movesMade-2) then begin        if n < 10 then write(' ');        write(n:2,': ');        WriteMove(moves[i]);        if i+1 <= movesMade then          WriteMove(moves[i+1])        else          write(' ':6);        end;      writeln;      n := n+1;      i := i+2;      end;    writeln(' ':16);                    {blank the last line (for scrolls)}                                        {update the thumb size}    SetCtlParams(Even(movesMade) div 2 * charHeight,      moveHeight-25,vScrollHandle);    SetPort(port);                      {restore the old graph port}    end;  updateMoves := false;                 {complete update is no longer needed}  end;end; {DrawMoves}procedure DrawScore;{Write the contents of the scores window}var  i: integer;                           {loop variable}  wcnt,bcnt: integer;                   {for counting pieces}  port: grafPortPtr;                    {graph port pointer}begin {DrawScore}if showScoreWindow then begin  port := GetPort;                      {save the graph port}  StartDrawing(scoreWindow);            {draw to the score window}  SetForeColor(0);                      {black pen on white background}  SetBackColor(15);  MoveTo(2,10);                         {Start at upper left corner}  wcnt := 0;                            {count the peices on the board}  bcnt := 0;  for i := 11 to 89 do    if board[i] = whitePiece then      wcnt := wcnt+1    else if board[i] = blackPiece then      bcnt := bcnt+1;  writeln('White:',wcnt:1,'  ');        {write the values}  writeln('Black:',bcnt:1,'  ');  writeln('Score:',Score(board):1,' ':10);  SetPort(port);                        {restore the old graph port}  end;end; {DrawScore}procedure MenuShowMovesWindow;{Hide or show the moves window}var  port: grafPortPtr;                    {graph port pointer}begin {MenuShowMovesWindow}showMovesWindow := not showMovesWindow; {reverse window's status}CheckMItem(showMovesWindow,options_ShowMovesWindow);ShowHide(showMovesWindow,movesWindow);if showMovesWindow then begin           {if visible, draw it...}  updateMoves := true;                  {draw the moves list}  DrawMoves;  port := GetPort;                      {save the graph port}  StartDrawing(movesWindow);            {redraw the controls}  SetPort(port);  end;SelectWindow(boardWindow);end; {MenuShowMovesWindow}procedure MenuShowScoreWindow;{Hide or show the scores window}begin {MenuShowScoreWindow}showScoreWindow := not showScoreWindow;CheckMItem(showScoreWindow,options_ShowScoreWindow);ShowHide(showScoreWindow,scoreWindow);SelectWindow(boardWindow);DrawScore;end; {MenuShowScoreWindow}procedure HandleMenu(menuNum: integer   {menu # of menu to handle}                    );{handle a menu event}  procedure MenuAbout;  {show about alert box}  begin {MenuAbout}  msg := concat('Reversi 1.0',chr(return),            'Copyright 1987-1990',chr(return),'Byte Works, Inc.',chr(return),            chr(return),'By Mike Westerfield');  DoAlert(note,msg);  end; {MenuAbout}  procedure MenuColor;  {Change the color the computer plays}  begin {MenuColor}  if color = whitePiece then begin    SetMItem(@computerPlaysWhite,options_ComputerPlaysWhite);    color := blackPiece;    end  else begin    SetMItem(@computerPlaysBlack,options_ComputerPlaysWhite);    color := whitePiece;    end;  end; {MenuColor}  procedure MenuPass;  {Player wants to pass}  var    moveList: moveListType;             {for seeing if there are legal moves}  begin {MenuPass}  GetMoves(board,currentColor,moveList);{get a list of legal moves}  if moveList.num = 0 then              {OK to pass if there are no moves}    currentColor := currentColor ! 3  else begin                            {error to pass if there are moves}    msg := concat('You have legal moves,',chr(return),            'so you cannot pass.',chr(return));    DoAlert(stop,msg);    end;  end; {MenuPass}  procedure MenuSelfPlay;  {Change the play mode}  begin {MenuSelfPlay}  selfPlay := not selfPlay;  if selfPlay then    SetMItem(@computerPlayStr,options_SelfPlay)  else    SetMItem(@selfPlayStr,options_SelfPlay);  end; {MenuSelfPlay}  procedure MenuSetPly(newPly: integer);{menu # of ply level selected}  {change the current playing level}  begin {MenuSetPly}  CheckMItem(false,ply+level_1Ply-1);   {uncheck old ply}  CheckMItem(true,newPly);              {check new ply}  ply := newPly-level_1Ply+1;           {set the ply level}  end; {MenuSetPly}begin {HandleMenu}case menuNum of                         {go handle the menu}  apple_AboutReversi: MenuAbout;  file_NewGame: begin NewGame; DrawBoard; end;  file_Quit: done := true;  edit_UndoLastMove: ;  edit_Cut,edit_Copy,edit_Paste,edit_Clear: ;  level_1Ply,level_2Ply,level_3Ply,  level_4Ply,level_5Ply,level_6Ply,  level_7Ply,level_8Ply: MenuSetPly(menuNum);  options_SelfPlay: MenuSelfPlay;  options_ComputerPlaysWhite: MenuColor;  options_Pass: MenuPass;  options_ShowScoreWindow: MenuShowScoreWindow;  options_ShowMovesWindow: MenuShowMovesWindow;  end; {case}HiliteMenu(false,convert(lastEvent.taskData).msw);end; {HandleMenu}procedure HideAWindow;{hide the front window}begin {HideAWindow}if FrontWindow = scoreWindow then  MenuShowScoreWindowelse {if FrontWindow = movesWindow then}  {always true}  MenuShowMovesWindow;end; {HideAWindow}procedure DoContent;{Handle a mouse down event in the content region}var  part: integer;                        {part # returned by FindControl}  ctl: ctlRecHndl;                      {control handle}  function LegalMove(index,color: integer): boolean;  {see if a move is legal}  label 1;  var    moveList: moveListType;             {for list of legal moves}    i: integer;                         {loop variable}  begin {LegalMove}  LegalMove := false;  GetMoves(board,color,moveList);  for i := 0 to moveList.num-1 do    if index = moveList.moves[i] then begin      LegalMove := true;      goto 1;      end;1:  end; {LegalMove}  procedure GrowMoves;  {grow the moves window (which is the only one that can grow)}  var    rt: rect;                           {for creating scroll bar}    movesInWindow: integer;             {# moves the moves window can display}    r,s: record                         {for converting integers}      case boolean of        true:  (long: longint);        false: (lsw,msw: integer);      end;  begin {GrowMoves}  s.long := GetMaxGrow(movesWindow);    {get max size}  r.long := GrowWindow(s.msw,64,        {track the growing of the window}    lastEvent.eventWhere.h,lastEvent.eventWhere.v,movesWindow);  if r.long <> 0 then begin             {if the size changed then...}    SizeWindow(s.msw,r.lsw,movesWindow);{change the window's size}    MoveControl(73,r.lsw-12,growHandle); {move the grow box}    DisposeControl(vScrollHandle);      {resize the scroll bar}    rt.h1 := 73; rt.h2 := 98;    rt.v1 := 0; rt.v2 := r.lsw-11;    vScrollHandle :=      NewControl(movesWindow,rt,nil,3,0,112,25,pointer($06000000),0,nil);                                        {update the thumb size}    SetCtlParams(Even(movesMade) div 2 * charHeight,r.lsw-25,vScrollHandle);                                        {position the thumb of the scroll bar}    SetCtlValue(topMove div 2 * charHeight,vScrollHandle);    if r.lsw > moveHeight then begin    {if the window grew then...}      movesInWindow :=                  {get rid of blank space at end}        (r.lsw - 25) div charHeight * 2 + 2;      if (Even(topMove)+movesInWindow+1) div 2 > (Even(movesMade)+1) div 2 then        begin        topMove := Even(movesMade)-movesInWindow;        if not odd(topMove) then topMove := topMove+1;        if topMove < 1 then topMove := 1;        end;      updateMoves := true;              {redraw moves list}      moveHeight := r.lsw;      DrawMoves;      end;    moveHeight := r.lsw;                {update the window size}    end;  end; {GrowMoves}  procedure Scroll;  {handle vertical scrolls in the moves window (the only scroll possible)}  var    part: integer;                      {part # from TrackControl}    movesInWindow: integer;             {# moves the moves window can display}  begin {Scroll}  part := TrackControl(lastEvent.eventWhere.h,lastEvent.eventWhere.v,    pointer(-1),vScrollHandle);  movesInWindow := (moveHeight - 25) div charHeight * 2 + 2;  if part in [5,6,7,8] then begin       {if the part is not the slide switch...}    case part of      5:                                {handle up arrow}        if topMove > 1 then          topMove := topMove-2;      6:                                {handle down arrow}        if Even(topMove)+movesInWindow < Even(movesMade)+1 then          topMove := topMove+2;      7:                                {handle up page}        if topMove > 1 then begin          topMove := topMove-movesInWindow;          if topMove < 1 then topMove := 1;          end;      8:                                {handle down page}        if Even(topMove)+movesInWindow < Even(movesMade)+1 then begin          topMove := topMove+movesInWindow;          if (Even(topMove)+movesInWindow+1) div 2            > (Even(movesMade)+1) div 2 then begin            topMove := Even(movesMade)-movesInWindow;            if not odd(topMove) then topMove := topMove+1;            end;          end;      end; {case}      updateMoves := true;              {redraw the window}      DrawMoves;                                        {position the thumb of the scroll bar}      SetCtlValue(topMove div 2 * charHeight,vScrollHandle);    end  else if part = 129 then begin         {reposition based on new thumb loc.}    topMove := GetCtlValue(vScrollHandle) * 2 div charHeight +1;    if not odd(topMove) then topMove := topMove+1;    updateMoves := true;    DrawMoves;    end;  end; {Scroll}  procedure TryMove;  {if there is a legal move at the indicated coordinates, make it}  var    p: point;                           {location of mouse}    row,col: integer;                   {position on board}    index: integer;                     {index into board array}  begin {TryMove}  if movesLeft then begin               {make sure the game is not over}    StartDrawing(boardWindow);          {easy way to set port}    p.h := lastEvent.eventWhere.h;      {find out where the mouse is}    p.v := lastEvent.eventWhere.v;    GlobalToLocal(p);    col := p.h div squareWidth+1;       {convert to board index}    row := p.v div squareHeight+1;    index := row*10+col;    if LegalMove(index,currentColor)    {if the move is legal, make it}      then begin      MakeAMove(index,currentColor);      currentColor := currentColor ! 3; {switch color to move}      end    else begin                          {flag a bad move}      msg := concat('Illegal move -',chr(return),'try again.');      DoAlert(stop,msg);      end;    CheckForDone;    DrawScore;                          {update the score}    DrawMoves;                          {update the move list}    end;  end; {TryMove}begin {DoContent}if FrontWindow = pointer(lastEvent.taskData) then begin  if pointer(lastEvent.taskData) = boardWindow then    TryMove                             {try making a move}  else if pointer(lastEvent.taskData) = movesWindow then begin    part := FindControl(ctl,lastEvent.eventWhere.h,      lastEvent.eventWhere.v,movesWindow);    if part = 10 then      GrowMoves                         {handle grow box}    else if part <> 0 then      Scroll;                           {handle scroll bar}    end;  end;end; {DoContent}procedure Update;{handle an update event}begin {Update}if lastEvent.eventMessage = ord4(boardWindow) then begin  BeginUpdate(boardWindow);             {update the board window}  DrawBoard;                            {redraw the board}  EndUpdate(boardWindow);               {complete the update}  endelse if lastEvent.eventMessage = ord4(scoreWindow) then begin  BeginUpdate(scoreWindow);             {update the score window}  DrawScore;                            {redraw the score window}  EndUpdate(scoreWindow);               {complete the update}  endelse if lastEvent.eventMessage = ord4(movesWindow) then begin  BeginUpdate(movesWindow);             {update the moves window}  updateMoves := true;                  {redraw the moves window}  DrawMoves;  EndUpdate(movesWindow);               {complete the update}  DrawControls(movesWindow);            {redraw the controls}  end;end; {Update}{-- Main program --------------------------------------------------------------}begin {Reversi}StartDesk(640);                         {initialize the dekstop environment}QDAuxStartup;SetPenMode(0);                          {set pen mode to copy}InitMenus;                              {set up the menu bar}InitWindow;                             {draw the board's window}InitVariables;                          {initialize global variables}lastEvent.taskMask := $13FF;            {let task master do most stuff}ShowCursor;                             {show the cursor}done := false;                          {main event loop}repeat  event := TaskMaster($074E,lastEvent);  case event of                         {handle the events we need to}    wInMenuBar: HandleMenu(convert(lastEvent.taskData).lsw);    updateEvt : Update;    wInContent: DoContent;    wInGoAway : HideAWindow;    otherwise: ;    end; {case}                                        {if the moves window has been brought  }                                        { to front, draw its controls          }  if FrontWindow = movesWindow then begin    if movesNotFront then begin      movesNotFront := false;      HiliteControl(0,vScrollHandle);      HiliteControl(0,growHandle);      DrawControls(movesWindow);      end;    end  else if not movesNotFront then begin    movesNotFront := true;    HiliteControl(255,vScrollHandle);    HiliteControl(255,growHandle);    end;  if movesLeft then begin               {let the computer move}    if selfPlay then begin      FindMove(currentColor);      currentColor := currentColor ! 3;      DrawScore;      DrawMoves;      end    else if color = currentColor then begin      FindMove(color);      currentColor := currentColor ! 3;      DrawScore;      DrawMoves;      end;    end; {if}until done;QDAuxShutdown;                          {shut down the desktop environment}EndDesk;end. {Reversi}