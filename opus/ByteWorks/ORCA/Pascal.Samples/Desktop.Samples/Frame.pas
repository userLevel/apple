{$keep 'Frame'}{---------------------------------------------------------------}{                                                               }{  Frame                                                        }{                                                               }{  This desktop program is about as simple as they get.  It     }{  brings up the Apple menu, a file menu with Quit and Close,   }{  and an edit menu with Undo, Cut, Copy, Paste and Clear.      }{  This is the minimum configuration for supporting desk        }{  accessories.  (All of these menus have pre-assigned numbers, }{  assigned by Apple.)                                          }{                                                               }{  The purpose of this rather simple program is to show how     }{  simple a desktop program can really be, and to give you a    }{  framework to use in developing your own programs.            }{                                                               }{  Mike Westerfield                                             }{                                                               }{  Copyright 1987-1990                                          }{  Byte Works, Inc.                                             }{                                                               }{---------------------------------------------------------------}program Frame(output);uses Common, QuickDrawII, EventMgr, WindowMgr, ControlMgr, DeskMgr,     DialogMgr, MenuMgr;const   return        = 13;                  {return key code}    Apple_About   = 257;                 {Menu ID #s}   File_Quit     = 256;type   alertKind = (norml,stop,note,caution); {kinds of alerts}   convert = record                     {for splitting 4 bytes to 2 bytes}      case boolean of         true : (long: longint);         false: (lsw,msw: integer);      end;var   done: boolean;                       {tells if the program should stop}   event: integer;                      {event #; returned by TaskMaster}   lastEvent: eventRecord;              {last event returned in event loop}   procedure DoAlert (kind: alertKind; msg: pString);   { Handle an alert box.                                        }   {                                                             }   { parameters:                                                 }   {     kind - kind of alert                                    }   {     msg - alert message                                     }    var      message,button: itemTemplate;     {button & message items}      alertRec: alertTemplate;          {alert box}      junk: integer;                    {for receiving NoteAlert value}    begin {DoAlert}   SetForeColor(0);                     {set text colors}   SetBackColor(15);   with alertRec do begin               {initialize alert box}      with atBoundsRect do begin         v1 := 50; h1 := 180;         v2 := 107; h2 := 460;         end;      atAlertID := 2;      atStage1 := $80;      atStage2 := $80;      atStage3 := $80;      atStage4 := $80;      atItemList[1] := @button;      atItemList[2] := @message;      atItemList[3] := nil;      end;   with button do begin                 {initialize button item}      itemID := 1;      with itemRect do begin         v1 := 36; h1 := 15;         v2 := 0; h2 := 0;         end;      itemType := buttonItem;      itemDescr := pointer(@'OK');      itemValue := 0;      itemFlag := 0;      itemColor := nil;      end;   with message do begin                {initialize message item}      itemID := 100;      with itemRect do begin         v1 := 5; h1 := 100;         v2 := 90; h2 := 280;         end;      itemType := itemDisable+statText;      itemDescr := pointer(@msg);      itemValue := 0;      itemFlag := 0;      itemColor := nil;      end;   case kind of                         {handle the alert}      norml:      junk := Alert(alertRec,nil);      stop:       junk := StopAlert(alertRec,nil);      note:       junk := NoteAlert(alertRec,nil);      caution:    junk := CautionAlert(alertRec,nil);      end; {case}   end; {DoAlert}    procedure InitMenus;   { Initialize the menu bar. }    var      height: integer;                  {height of the largest menu}      menuHand: menuHandle;             {for 'handling' windows}      s: textPtr;                       {for builing menus}    begin {InitMenus}   new(s);                              {create the edit menu}   s^ := concat('>> Edit \N3',chr(return));   s^ := concat(s^,'--Undo\N250V*Zz',chr(return));   s^ := concat(s^,'--Cut\N251*Xx',chr(return));   s^ := concat(s^,'--Copy\N252*Cc',chr(return));   s^ := concat(s^,'--Paste\N253*Vv',chr(return));   s^ := concat(s^,'--Clear\N254',chr(return));   s^ := concat(s^,'.',chr(return));   menuHand := NewMenu(s);   InsertMenu(menuHand,0);   new(s);                              {create the file menu}   s^ := concat('>> File \N2',chr(return));   s^ := concat(s^,'--Close\N255V',chr(return));   s^ := concat(s^,'--Quit\N256*Qq',chr(return));   s^ := concat(s^,'.',chr(return));   menuHand := NewMenu(s);   InsertMenu(menuHand,0);   new(s);                              {create the apple menu}   s^ := concat('>>@\XN1',chr(return));   s^ := concat(s^,'--About Frame...\N257V',chr(return));   s^ := concat(s^,'.',chr(return));   menuHand := NewMenu(s);   InsertMenu(menuHand,0);   FixAppleMenu(1);                     {add desk accessories}   height := FixMenuBar;                {draw the completed menu bar}   DrawMenuBar;   end; {InitMenus}    procedure HandleMenu(menuNum: integer);   { Handle a menu selection. }       procedure MenuAbout;      { Show About alert box. }        var         msg: pString;                  {alert message}        begin {MenuAbout}      msg := concat('Frame 1.0',chr(return),              'Copyright 1987-1990',chr(return),'Byte Works, Inc.',chr(return),              chr(return),'By Mike Westerfield');      DoAlert(note,msg);      end; {MenuAbout}    begin {HandleMenu}   case menuNum of                      {go handle the menu}      apple_About: MenuAbout;      file_Quit:   done := true;      otherwise:   ;      end; {case}   HiliteMenu(false,convert(lastEvent.taskData).msw);   end; {HandleMenu}begin {Frame}StartDesk(640);InitMenus;                              {set up the menu bar}lastEvent.taskMask := $1FFF;            {let task master do most stuff}ShowCursor;                             {show the cursor}done := false;                          {main event loop}repeat   event := TaskMaster($076E, lastEvent);   case event of                        {handle the events we need to}      wInSpecial,      wInMenuBar: HandleMenu(convert(lastEvent.taskData).lsw);      otherwise: ;      end; {case}until done;EndDesk;end. {Frame}