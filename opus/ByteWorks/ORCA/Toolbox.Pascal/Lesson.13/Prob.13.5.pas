{---------------------------------------------------------------}{                                                               }{  Control Explorer                                             }{                                                               }{  Explores how controls work.                                  }{                                                               }{---------------------------------------------------------------}program ControlExplorer;uses Common, QuickDrawII, EventMgr, WindowMgr, ControlMgr, DeskMgr,     DialogMgr, MenuMgr, ResourceMgr, MemoryMgr, SFToolSet, ToolLocator,     MscToolSet;const   return        = 13;                  {return key code}    appleMenu     = 1;                   {Menu ID #s (also resource ID #s)}   fileMenu      = 2;   editMenu      = 3;   editUndo      = 250;   editCut       = 251;   editCopy      = 252;   editPaste     = 253;   editClear     = 254;   fileClose     = 255;   fileQuit      = 256;   appleAbout    = 257;   ctlBeepOnce   = 2;                   {control IDs}   ctlBeepTwice  = 3;   ctlTitle      = 4;   ctlBoxRed     = 5;   ctlBoxGreen   = 6;   ctlBoxBlue    = 7;   ctlSound      = 8;   ctlTRed       = 9;   ctlTGreen     = 10;   ctlTBlue      = 11;   ctlSRed       = 12;   ctlSGreen     = 13;   ctlSBlue      = 14;      mixColor      = 1;                   {color mixer box color}type   long = record                        {for splitting 4 bytes to 2 bytes}      case boolean of         true : (long: longint);         false: (lsw,msw: integer);      end;var   wPtr: grafPortPtr;                   {our window}   done: boolean;                       {tells if the program should stop}   event: integer;                      {event #; returned by GetNextEvent}   myEvent: eventRecord;                {last event returned in event loop}   startStopParm: longint;              {tool start/shutdown parameter}   boxColor: integer;                   {box color}   boxRect: rect;                       {box color rectangle}   mixRect: rect;                       {color mixer rectangle}   soundOn: boolean;                    {is the sound turned on?}   procedure InitGlobals;   { Initialize the global variables                            }   begin {InitGlobals}   with boxRect do begin                {set up the box rectangle}      h1 := 10; h2 := 21;      v1 := 18; v2 := 31;      end; {with}   boxColor := 7;                       {red box}   with mixRect do begin                {set up the color mixer rectangle}      h1 := 10; h2 := 46;      v1 := 39; v2 := 74;      end; {with}   SetColorEntry(0, mixColor, 0);       {start off with a black color}   soundOn := true;                     {the sound is on}   end; {InitGlobals}   procedure InitMenus;   { Initialize the menu bar.                                   }   const      menuID = 1;                       {menu bar resource ID}    var      height: integer;                  {height of the largest menu}      menuBarHand: menuBarHandle;       {for 'handling' the menu bar}    begin {InitMenus}                                        {create the menu bar}   menuBarHand := NewMenuBar2(refIsResource, menuID, nil);   SetSysBar(menuBarHand);   SetMenuBar(nil);   FixAppleMenu(1);                     {add desk accessories}   height := FixMenuBar;                {draw the completed menu bar}   DrawMenuBar;   end; {InitMenus}   {$databank+}   procedure DrawContents;   { Draw the contents of the active port                       }   var      r: rect;                          {work rectangle}   begin {DrawContents}   PenNormal;   DrawControls(GetPort);               {draw the controls}   SetSolidPenPat(boxColor);            {draw the radio color box}   PaintRect(boxRect);   SetSolidPenPat(0);   FrameRect(boxRect);   SetSolidPenPat(mixColor);            {draw the color mixer rectangle}   PaintRect(mixRect);   SetSolidPenPat(0);   FrameRect(mixRect);   end; {DrawContents}   procedure ScrollAction (part: integer; ctlHandle: ctlRecHndl);   { Scroll bar action procedure                                }   {                                                            }   { Parameters:                                                }   {    part - scroll bar part code                             }   {    ctlHandle - scroll bar handle                           }   const      pageSize = 1;                     {size of a page}      maxPos = 15;                      {max position for the scroll bar}   var      cdisp: integer;                   {color based bit shift displacement}      color: integer;                   {color table entry}      ctlID: longint;                   {control ID}      value, oldValue: integer;         {control value}   begin {ScrollAction}   value := GetCtlValue(ctlHandle);   oldValue := value;   case part of      upArrow:     value := value-1;      downArrow:   value := value+1;      pageUp:      value := value-pageSize;      pageDown:    value := value+pageSize;      thumb:       begin value := oldValue; oldValue := value-1; end;      otherwise:   ;      end; {case}   if value < 0 then      value := 0   else if value > maxPos then      value := maxPos;   if value <> oldValue then begin      SetCtlValue(value, ctlHandle);      color := GetColorEntry(0, mixColor);      ctlID := GetCtlID(ctlHandle);      if ctlID = ctlSRed then         cdisp := $0100      else if ctlID = ctlSGreen then         cdisp := $0010      else         cdisp := $0001;      color := (color & ((cdisp*$000F) ! $FFFF)) | (cdisp * value);      SetColorEntry(0, mixColor, color);      end; {if}   end; {ScrollAction}   {$databank+}   procedure InitWindow;   { Set up the program window                                  }   const      rWindParam1 = $800E;              {resource ID}      wrNum = 1001;                     {window resource number}   var      i: integer;                       {loop/index variable}   begin {InitWindow}                                        {open the window}   wPtr := NewWindow2(@' ', 0, @DrawContents, nil, $02, wrNum, rWindParam1);                                        {set up the scroll action procedure}   SetCtlAction(@ScrollAction, GetCtlHandleFromID(wPtr, ctlSRed));   SetCtlAction(@ScrollAction, GetCtlHandleFromID(wPtr, ctlSBlue));   SetCtlAction(@ScrollAction, GetCtlHandleFromID(wPtr, ctlSGreen));   end; {InitWindow}   procedure HandleMenu;   { Handle a menu selection.                                   }    var      menuNum, menuItemNum: integer;    {menu number & menu item number}      procedure DoAbout;      { Draw our about box                                      }      const         alertID = 1;                   {alert string resource ID}      var         button: integer;               {button pushed}      begin {DoAbout}      button := AlertWindow($0005, nil, alertID);      end; {DoAbout}   begin {HandleMenu}                                        {separate the menu and item numbers}   menuNum := long(myEvent.taskData).msw;   menuItemNum := long(myEvent.taskData).lsw;   case menuItemNum of                  {go handle the menu}      appleAbout:  DoAbout;      fileClose:   ;      fileQuit:    done := true;      editUndo:    ;      editCut:     ;      editCopy:    ;      editPaste:   ;      editClear:   ;      otherwise:   ;      end; {case}   HiliteMenu(false, menuNum);          {unhighlight the menu}   end; {HandleMenu}   procedure HandleControl;   { Take action after a control has been selected                 }      procedure ForceUpdate (r: rect);      { Force an update of our window                           }      {                                                         }      { Parameters:                                             }      {    r - rectangle to update                              }      var         port: grafPortPtr;             {caller's grafPort}      begin {ForceUpdate}      port := GetPort;      SetPort(wPtr);      InvalRect(r);      SetPort(port);      end; {ForceUpdate}   begin {HandleControl}   if (myEvent.taskData4 & $FFFF8000) = 0 then      case ord(myEvent.taskData4) of         ctlBeepOnce:    if soundOn then                            SysBeep;         ctlBeepTwice:   if soundOn then begin                            SysBeep;                            SysBeep;                            end;         ctlBoxRed:      begin boxColor := 7; ForceUpdate(boxRect); end;         ctlBoxGreen:    begin boxColor := 10; ForceUpdate(boxRect); end;         ctlBoxBlue:     begin boxColor := 4; ForceUpdate(boxRect); end;         ctlSound:       soundOn := not soundOn;         otherwise:      ;         end; {case}   end; {HandleControl}begin {ControlExplorer}startStopParm :=                        {start up the tools}   StartUpTools(userID, 2, 1);if ToolError <> 0 then   SysFailMgr(ToolError, @'Could not start tools: ');InitMenus;                              {set up the menu bar}InitGlobals;                            {initialize our global variables}InitWindow;                             {set up the program window}InitCursor;                             {show the cursor}done := false;                          {main event loop}myEvent.taskMask := $001F7FFF;          {let task master do it all}repeat   event := TaskMaster(everyEvent, myEvent);   case event of                        {handle the events we need to}      wInSpecial,      wInMenuBar: HandleMenu;      wInControl: HandleControl;      otherwise: ;      end; {case}until done;ShutDownTools(1, startStopParm);        {shut down the tools}end. {ControlExplorer}