{---------------------------------------------------------------}{                                                               }{  Window Sampler                                               }{                                                               }{  This program creates windows based on a variety of user-     }{  selected values.                                             }{                                                               }{---------------------------------------------------------------}program Sampler;uses Common, QuickDrawII, EventMgr, WindowMgr, ControlMgr, DeskMgr,     DialogMgr, MenuMgr, ResourceMgr, MemoryMgr;const   return        = 13;                  {return key code}    appleMenu     = 1;                   {Menu ID #s (also resource ID #s)}   fileMenu      = 2;   editMenu      = 3;   wFrameBitsMenu = 4;   titleMenu     = 5;   editUndo      = 250;   editCut       = 251;   editCopy      = 252;   editPaste     = 253;   editClear     = 254;   fileNew       = 260;   fileOpen      = 261;   fileClose     = 255;   fileQuit      = 256;   appleAbout    = 257;   frameTitle    = 270;   frameClose    = 271;   frameAlert    = 272;   frameControls = 273;   frameFlex     = 274;   frameZoom     = 275;   frameMove     = 276;   frameCtlTie   = 277;   titleSolid    = 280;   titleLined    = 281;   titleDithered = 282;type   long = record                        {for splitting 4 bytes to 2 bytes}      case boolean of         true : (long: longint);         false: (lsw,msw: integer);      end;   documentPtr = ^documentRecord;       {document pointer}   documentRecord = record              {information about our document}      next: documentPtr;                {next document}      wPtr: grafPortPtr;                {window pointer}      wName: pString;                   {window name}      onDisk: boolean;                  {does the file exist on disk?}      wColor: wColorTbl;                {window color table}      end;   titleKind = (solid, lined, dithered); {Title bar kind}var   documents: documentPtr;              {our documents}   done: boolean;                       {tells if the program should stop}   event: integer;                      {event #; returned by GetNextEvent}   myEvent: eventRecord;                {last event returned in event loop}   untitledNum: integer;                {number for the next untitled window}   fbTitle: boolean;                    {wFrameBits options}   fbClose: boolean;   fbAlert: boolean;   fbControls: boolean;   fbFlex: boolean;   fbZoom: boolean;   fbMove: boolean;   fbCtlTie: boolean;   titleBarKind: titleKind;             {Title option}      procedure InitGlobals;   { Initialize the global variables                            }   begin {InitGlobals}   documents := nil;                    {no documents}   fbTitle := true;                     {wFrameBits options}   fbClose := true;   fbAlert := false;   fbControls := true;   fbFlex := true;   fbZoom := true;   fbMove := true;   fbCtlTie := true;   titleBarKind := lined;               {Title option}   end; {InitGlobals}   procedure InitMenus;   { Initialize the menu bar.                                   }   const      menuID = 1;                       {menu bar resource ID}    var      height: integer;                  {height of the largest menu}      menuBarHand: menuBarHandle;       {for 'handling' the menu bar}    begin {InitMenus}                                        {create the menu bar}   menuBarHand := NewMenuBar2(refIsResource, menuID, nil);   SetSysBar(menuBarHand);   SetMenuBar(nil);   FixAppleMenu(1);                     {add desk accessories}   height := FixMenuBar;                {draw the completed menu bar}   DrawMenuBar;   end; {InitMenus}   function GetPString (resourceID: integer): pStringPtr;   { Get a string from the resource fork                        }   {                                                            }   { Parameters:                                                }   {    resourceID - resource ID of the rPString resource       }   {                                                            }   { Returns: pointer to the string; nil for an error           }   {                                                            }   { Notes: The string is in a locked resource handle.  The     }   {    caller should call FreePString when the string is no    }   {    longer needed.  Failure to do so is not catastrophic;   }   {    the memory will be deallocated when the program is shut }   {    down.                                                   }   const      rPString = $8006;                 {resource type for p-strings}   var      hndl: handle;                     {resource handle}   begin {GetPString}   hndl := LoadResource(rPString, resourceID);   if ToolError <> 0 then      GetPString := nil   else begin      HLock(hndl);      GetPString := pStringPtr(hndl^);      end; {else}   end; {GetPString}   procedure FreePString (resourceID: integer);   { Free a resource string                                     }   {                                                            }   { Parameters:                                                }   {    resourceID - resource ID of the rPString to free        }   const      rPString = $8006;                 {resource type for p-strings}   begin {FreePString}                  ReleaseResource(-3, rPString, resourceID);   end; {FreePString}   procedure FlagError (error, tError: integer);   { Flag an error                                              }   {                                                            }   { Parameters:                                                }   {    error - error message number                            }   {    tError - toolbox error code; 0 if none                  }   const      errorAlert = 2000;                {alert resource ID}      errorBase = 2000;                 {base resource ID for error messages}   var      str: pString;                     {wprk string}      substArray: pStringPtr;           {substitution "array"}      button: integer;                  {button pushed}      function HexDigit (value: integer): char;      { Returns a hexadecimal digit for the value               }      {                                                         }      { Parameters:                                             }      {    value - value to form a digit from; only the least   }      {       significant 4 bits are used                       }      {                                                         }      { Returns: Hexadecimal character                          }      begin {HexDigit}      value := value & $000F;      if value > 9 then         HexDigit := chr(value-10 + ord('A'))      else         HexDigit := chr(value + ord('0'));      end; {HexDigit}   begin {FlagError}                                        {form the error string}   substArray := GetPString(errorBase + error);   str := substArray^;   FreePString(errorBase + error);   substArray := @str;   if tError <> 0 then begin            {add the tool error number}      str := concat(         str,         ' ($',         HexDigit(tError >> 12),         HexDigit(tError >> 8),         HexDigit(tError >> 4),         HexDigit(tError),         ')'         );      end; {if}                                        {show the alert}   button := AlertWindow($0005, @substArray, ord4(errorAlert));   end; {FlagError}   {$databank+}   procedure DrawContents;   { Draw the contents of the active port                       }   begin {DrawContents}   PenNormal;                           {use a "normal" pen}   end; {DrawContents}   {$databank+}   procedure CloseDocument (dPtr: documentPtr);   { Close a document and its associated window                    }   {                                                               }   { Parameters:                                                   }   {    dPtr - pointer to the document to close; may be nil        }   var      lPtr: documentPtr;                {pointer to the previous document}   begin {CloseDocument}   if dPtr <> nil then begin      CloseWindow(dPtr^.wPtr);          {close the window}      if documents = dPtr then          {remove dPtr from the list when...}         documents := dPtr^.next        {...dPtr is the first document}      else begin                        {...dPtr is not the first document}         lPtr := documents;         while lPtr^.next <> dPtr do            lPtr := lPtr^.next;         lPtr^.next := dPtr^.next;         end; {else}      dispose(dPtr);                    {dispose of the document record}      end; {if}   end; {CloseDocument}   function FindDocument (wPtr: grafPortPtr): documentPtr;   { Find the document for wPtr                                    }   {                                                               }   { Parameters:                                                   }   {    wPtr - pointer to the window for which to find a document  }   {                                                               }   { Returns: Document pointer; nil if there isn't one             }   var      done: boolean;                    {used to test for loop termination}      dPtr: documentPtr;                {used to trace the document list}   begin {FindDocument}   dPtr := documents;   done := dPtr = nil;   while not done do      if dPtr^.wPtr = wPtr then         done := true      else begin         dPtr := dPtr^.next;         done := dPtr = nil;         end; {else}   FindDocument := dPtr;   end; {FindDocument}   procedure GetUntitledName (var name: pString);   { Create a name for an untitled window                          }   {                                                               }   { Parameters:                                                   }   {    name - (returned) name for the window                      }   const      untitled = 101;                   {Resource number for "Untitled "}   var      dPtr: documentPtr;                {used to trace the document list}      number: integer;                  {new value for untitledNum}      sPtr: pStringPtr;                 {pointer to the resource string}   begin {GetUntitledName}   dPtr := documents;                   {if there are no untitled         }   number := 1;                         { documents then reset untitledNum}   while dPtr <> nil do      if not dPtr^.onDisk then begin         number := untitledNum;         dPtr := nil;         end {if}      else         dPtr := dPtr^.next;   untitledNum := number;   sPtr := GetPString(untitled);        {set the base name}   if sPtr = nil then      name := 'Untitled '   else begin      name := sPtr^;      FreePString(untitled);      end; {else}   name := concat(name, cnvis(untitledNum)); {add the untitled number}   name := concat('  ', name, '  ');    {pad with spaces}   untitledNum := untitledNum+1;        {update untitledNum}   end; {GetUntitledName}   function NewDocument (wName: pString): documentPtr;   { Open a new document                                           }   {                                                               }   { Parameters:                                                   }   {    wName - name for the new window                            }   {                                                               }   { Returns: Document pointer; nil for an error                   }   var      dPtr: documentPtr;                {new document pointer}      function NewWind: grafPortPtr;      { Create a new window                                     }      {                                                         }      { Returns: Pointer to the window; nil for error           }      var         wParms: paramList;             {parameters for NewWindow}      begin {NewWind}      with dPtr^.wColor do begin        {initialize the window color record}         frameColor := $0000;         titleColor := $0F00;         case titleBarKind of            solid:    begin                      titleColor := $0F0F;                      tBarColor := $0000;                      end;            lined:    tBarColor := $020F;            dithered: tBarColor := $010F;            end; {case}         growColor  := $F0F0;         infoColor  := $00F0;         end; {with}      with wParms do begin              {initialize the window record}         paramLength := sizeof(wParms);         wFrameBits := $0025;         if fbTitle then wFrameBits := wFrameBits | fTitle;         if fbClose then wFrameBits := wFrameBits | fClose;         if fbAlert then wFrameBits := wFrameBits | fAlert;         if fbControls then wFrameBits := wFrameBits | fGrow | fBScroll | fRScroll;         if fbFlex then wFrameBits := wFrameBits | fFlex;         if fbZoom then wFrameBits := wFrameBits | fZoom;         if fbMove then wFrameBits := wFrameBits | fMove;         if fbCtlTie then wFrameBits := wFrameBits | fCtlTie;         wTitle := @dPtr^.wName;                             wRefCon := 0;         wZoom.h1 := 0; wZoom.h2 := 0;         wZoom.v1 := 0; wZoom.v2 := 0;         wColor := @dPtr^.wColor;         wYOrigin := 0; wXOrigin := 0;         wDataH := 200;         wDataW := 640;         wMaxH := 0;         wMaxW := 0;         wScrollVer := 8; wScrollHor := 8;         wPageVer := 0; wPageHor := 0;         wInfoRefCon := 0; wInfoHeight := 0;         wFrameDefProc := nil;         wInfoDefProc := nil;         wContDefProc := @DrawContents;         wPosition.v1 := 30;         wPosition.h1 := 10;         wPosition.v2 := 183;         wPosition.h2 := 602;         wPlane := pointer(topMost);         wStorage := nil;         end; {with}      NewWind := NewWindow(wParms);     {open the window}      end; {NewWind}   begin {NewDocument}   new(dPtr);                           {allocate the record}   if dPtr <> nil then begin      dPtr^.onDisk := false;            {not on disk}      dPtr^.wName := wName;             {set up the name}      dPtr^.wPtr := NewWind;            {open the window}      if dPtr^.wPtr = nil then begin         FlagError(1, ToolError);       {handle a window error}         dispose(dPtr);         dPtr := nil;         end {if}      else begin         dPtr^.next := documents;       {put the document in the list}         documents := dPtr;         end; {else}      end {if}   else      FlagError(2, 0);                  {handle an out of memory error}   NewDocument := dPtr;   end; {NewDocument}   procedure HandleMenu;   { Handle a menu selection.                                   }   var      menuNum, menuItemNum: integer;    {menu number & menu item number}      procedure DoAbout;      { Draw our about box                                         }      const         alertID = 1;                   {alert string resource ID}      var         button: integer;               {button pushed}      begin {DoAbout}      button := AlertWindow($0005, nil, alertID);      end; {DoAbout}      procedure DoNew;      { Open a new document window                              }      var         dPtr: documentPtr;             {pointer to the new document}         name: pString;                 {new document name}      begin {DoNew}      GetUntitledName(name);      dPtr := NewDocument(name);      end; {DoNew}      procedure FrameOption (id: integer; var setting: boolean);      { Change a wFrameBits option                              }      {                                                         }      { Parameters:                                             }      {    id - menu ID for the option to change                }      {    setting - option flag variable                       }      begin {FrameOption}      setting := not setting;      CheckMItem(setting, id);      end; {FrameOption}      procedure TitleOption (option: titleKind);      { Change the title bar kind option                        }      {                                                         }      { Parameters:                                             }      {    option - new title bar option                        }      begin {TitleOption}      CheckMItem(false, titleSolid + ord(titleBarKind));      titleBarKind := option;      CheckMItem(true, titleSolid + ord(titleBarKind));      end; {TitleOption}   begin {HandleMenu}                                        {separate the menu and item numbers}   menuNum := long(myEvent.taskData).msw;   menuItemNum := long(myEvent.taskData).lsw;   case menuItemNum of                  {go handle the menu}      appleAbout:  DoAbout;      fileNew:     DoNew;      fileOpen:    DoNew;      fileClose:   CloseDocument(FindDocument(FrontWindow));      fileQuit:    done := true;      editUndo:    ;      editCut:     ;      editCopy:    ;      editPaste:   ;      editClear:   ;      frameTitle:  FrameOption(frameTitle, fbTitle);      frameClose:  FrameOption(frameClose, fbClose);      frameAlert:  FrameOption(frameAlert, fbAlert);      frameControls: FrameOption(frameControls, fbControls);      frameFlex:   FrameOption(frameFlex, fbFlex);      frameZoom:   FrameOption(frameZoom, fbZoom);      frameMove:   FrameOption(frameMove, fbMove);      frameCtlTie: FrameOption(frameCtlTie, fbCtlTie);      titleSolid:  TitleOption(solid);      titleLined:  TitleOption(lined);      titleDithered: TitleOption(dithered);      otherwise:   ;      end; {case}   HiliteMenu(false, menuNum);          {unhighlight the menu}   end; {HandleMenu}begin {Sampler}StartDesk(640);InitMenus;                              {set up the menu bar}InitCursor;                             {show the cursor}InitGlobals;                            {initialize our global variables}done := false;                          {main event loop}myEvent.taskMask := $001F7FFF;          {let task master do it all}repeat   event := TaskMaster(everyEvent, myEvent);   case event of                        {handle the events we need to}      wInSpecial,      wInMenuBar: HandleMenu;      wInGoAway:  CloseDocument(FindDocument(grafPortPtr(myEvent.taskData)));      otherwise: ;      end; {case}until done;EndDesk;end. {Sampler}