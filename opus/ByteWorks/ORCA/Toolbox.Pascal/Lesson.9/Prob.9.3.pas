{---------------------------------------------------------------}{                                                               }{  Slide Show                                                   }{                                                               }{  This program lets you load, view and save screen dump        }{  picture files.                                               }{                                                               }{---------------------------------------------------------------}program SlideShow;uses Common, QuickDrawII, EventMgr, WindowMgr, ControlMgr, DeskMgr,     DialogMgr, MenuMgr, ResourceMgr, MemoryMgr, SFToolSet, ToolLocator,     MscToolSet, PrintMgr, GSOS;const   return        = 13;                  {return key code}    appleMenu     = 1;                   {Menu ID #s (also resource ID #s)}   fileMenu      = 2;   editMenu      = 3;   editUndo      = 250;   editCut       = 251;   editCopy      = 252;   editPaste     = 253;   editClear     = 254;   fileOpen      = 261;   fileClose     = 255;   fileSave      = 262;   fileSaveAs    = 263;   filePageSetup = 264;   filePrint     = 265;   fileQuit      = 256;   appleAbout    = 257;type   long = record                        {for splitting 4 bytes to 2 bytes}      case boolean of         true : (long: longint);         false: (lsw,msw: integer);      end;   documentPtr = ^documentRecord;       {document pointer}   documentRecord = record              {information about our document}      next: documentPtr;                {next document}      wPtr: grafPortPtr;                {window pointer}      wName: pString;                   {window name}      onDisk: boolean;                  {does the file exist on disk?}      fileName: handle;                 {file name handle or nil}      pathName: handle;                 {full path name handle or nil}      pictureHandle: handle;            {handle of the picture}      prHandle: handle;                 {print record}      end;var   defaultColors: colorTable;           {default color table}   documents: documentPtr;              {our documents}   done: boolean;                       {tells if the program should stop}   event: integer;                      {event #; returned by GetNextEvent}   myEvent: eventRecord;                {last event returned in event loop}   startStopParm: longint;              {tool start/shutdown parameter}   untitledNum: integer;                {number for the next untitled window}   procedure InitGlobals;   { Initialize the global variables                            }   begin {InitGlobals}   documents := nil;   GetColorTable(0, defaultColors);   end; {InitGlobals}   procedure InitMenus;   { Initialize the menu bar.                                   }   const      menuID = 1;                       {menu bar resource ID}    var      height: integer;                  {height of the largest menu}      menuBarHand: menuBarHandle;       {for 'handling' the menu bar}    begin {InitMenus}                                        {create the menu bar}   menuBarHand := NewMenuBar2(refIsResource, menuID, nil);   SetSysBar(menuBarHand);   SetMenuBar(nil);   FixAppleMenu(1);                     {add desk accessories}   height := FixMenuBar;                {draw the completed menu bar}   DrawMenuBar;   end; {InitMenus}   function GetPString (resourceID: integer): pStringPtr;   { Get a string from the resource fork                        }   {                                                            }   { Parameters:                                                }   {    resourceID - resource ID of the rPString resource       }   {                                                            }   { Returns: pointer to the string; nil for an error           }   {                                                            }   { Notes: The string is in a locked resource handle.  The     }   {    caller should call FreePString when the string is no    }   {    longer needed.  Failure to do so is not catastrophic;   }   {    the memory will be deallocated when the program is shut }   {    down.                                                   }   const      rPString = $8006;                 {resource type for p-strings}   var      hndl: handle;                     {resource handle}   begin {GetPString}   hndl := LoadResource(rPString, resourceID);   if ToolError <> 0 then      GetPString := nil   else begin      HLock(hndl);      GetPString := pStringPtr(hndl^);      end; {else}   end; {GetPString}   procedure FreePString (resourceID: integer);   { Free a resource string                                     }   {                                                            }   { Parameters:                                                }   {    resourceID - resource ID of the rPString to free        }   const      rPString = $8006;                 {resource type for p-strings}   begin {FreePString}                  ReleaseResource(-3, rPString, resourceID);   end; {FreePString}   procedure FlagError (error, tError: integer);   { Flag an error                                              }   {                                                            }   { Parameters:                                                }   {    error - error message number                            }   {    tError - toolbox error code; 0 if none                  }   const      errorAlert = 2000;                {alert resource ID}      errorBase = 2000;                 {base resource ID for error messages}   var      str: pString;                     {wprk string}      substArray: pStringPtr;           {substitution "array"}      button: integer;                  {button pushed}      function HexDigit (value: integer): char;      { Returns a hexadecimal digit for the value               }      {                                                         }      { Parameters:                                             }      {    value - value to form a digit from; only the least   }      {       significant 4 bits are used                       }      {                                                         }      { Returns: Hexadecimal character                          }      begin {HexDigit}      value := value & $000F;      if value > 9 then         HexDigit := chr(value-10 + ord('A'))      else         HexDigit := chr(value + ord('0'));      end; {HexDigit}   begin {FlagError}                                        {form the error string}   substArray := GetPString(errorBase + error);   str := substArray^;   FreePString(errorBase + error);   substArray := @str;   if tError <> 0 then begin            {add the tool error number}      str := concat(         str,         ' ($',         HexDigit(tError >> 12),         HexDigit(tError >> 8),         HexDigit(tError >> 4),         HexDigit(tError),         ')'         );      end; {if}                                        {show the alert}   button := AlertWindow($0005, @substArray, ord4(errorAlert));   end; {FlagError}   procedure CloseDocument (dPtr: documentPtr);   { Close a document and its associated window                    }   {                                                               }   { Parameters:                                                   }   {    dPtr - pointer to the document to close; may be nil        }   var      lPLfh4∆7ó »&¬TÌ"[ÜPã‘ÏDÈ≠ñilh•z°¥êáÏÆœß!*?Œœ@}D_ˆEE”F=TÄJ‚°5Ω
‹˚a+s$Ì]Q÷4b=KÇö{ŒÁƒÁÃ„NNª` ¬Ê%A	9W‘mõ9ç∆I}}‘∫ê,Fay be nil        }   var      lPtr: documentPtr;                {pointer to the previous document}   begin {CloseDocument}   if dPtr <> nil then begin      CloseWindow(dPtr^.wPtr);          {close the window}      if documents = dPtr then          {remove dPtr from the list when...}         documents := dPtr^.next        {...dPtr is the first document}      else begin                        {...dPtr is not the first document}         lPtr := documents;         while lPtr^.next <> dPtr do            lPtr := lPtr^.next;         lPtr^.next := dPtr^.next;         end; {else}      if dPtr^.fileName <> nil then     {dispose of the name buffers}         DisposeHandle(dPtr^.fileName);      if dPtr^.pathName <> nil then         DisposeHandle(dPtr^.pathName);      if dPtr^.prHandle <> nil then     {dispose of the print record}         DisposeHandle(dPtr^.prHandle);      dispose(dPtr);                    {dispose of the document record}      end; {if}   end; {CloseDocument}   function FindDocument (wPtr: grafPortPtr): documentPtr;   { Find the document for wPtr                                    }   {                                                               }   { Parameters:                                                   }   {    wPtr - pointer to the window for which to find a document  }   {                                                               }   { Returns: Document pointer; nil if there isn't one             }   var      done: boolean;                    {used to test for loop termination}      dPtr: documentPtr;                {used to trace the document list}   begin {FindDocument}   dPtr := documents;   done := dPtr = nil;   while not done do      if dPtr^.wPtr = wPtr then         done := true      else begin         dPtr := dPtr^.next;         done := dPtr = nil;         end; {else}   FindDocument := dPtr;   end; {FindDocument}   function LoadDocument (dPtr: documentPtr): boolean;   { Load a document file from disk                                }   {                                                               }   { Parameters:                                                   }   {    dPtr - pointer to the document to save                     }   {                                                               }   { Returns: true if successful, else false                       }      begin {LoadDocument}   LoadDocument := true;   end; {LoadDocument}   procedure GetUntitledName (var name: pString);   { Create a name for an untitled window                          }   {                                                               }   { Parameters:                                                   }   {    name - (returned) name for the window                      }   const      untitled = 101;                   {Resource number for "Untitled "}   var      dPtr: documentPtr;                {used to trace the document list}      number: integer;                  {new value for untitledNum}      sPtr: pStringPtr;                 {pointer to the resource string}   begin {GetUntitledName}   dPtr := documents;                   {if there are no untitled         }   number := 1;                         { documents then reset untitledNum}   while dPtr <> nil do      if not dPtr^.onDisk then begin         number := untitledNum;         dPtr := nil;         end {if}      else         dPtr := dPtr^.next;   untitledNum := number;   sPtr := GetPString(untitled);        {set the base name}   if sPtr = nil then      name := 'Untitled '   else begin      name := sPtr^;      FreePString(untitled);      end; {else}   name := concat(name, cnvis(untitledNum)); {add the untitled number}   name := concat('  ', name, '  ');    {pad with spaces}   untitledNum := untitledNum+1;        {update untitledNum}   end; {GetUntitledName}   function NewDocument (wName: pString): documentPtr;   { Open a new document                                           }   {                                                               }   { Parameters:                                                   }   {    wName - name for the new window                            }   {                                                               }   { Returns: Document pointer; nil for an error                   }   const      rWindParam1 = $800E;              {resource ID}      wrNum = 1001;                     {window resource number}   var      dPtr: documentPtr;                {new document pointer}   begin {NewDocument}   new(dPtr);                           {allocate the record}   if dPtr <> nil then begin      dPtr^.onDisk := false;            {not on disk}      dPtr^.wName := wName;             {set up the name}      dPtr^.fileName := nil;            {no file name handle}      dPtr^.pathName := nil;            {no path name handle}      dPtr^.wPtr :=                     {open the window}         NewWindow2(@dPtr^.wName, 0, @DrawContents, nil, $02, wrNum,            rWindParam1);      if dPtr^.wPtr = nil then begin         FlagError(1, ToolError);       {handle a window error}         dispose(dPtr);         dPtr := nil;         end {if}      else begin         dPtr^.next := documents;       {put the document in the list}         documents := dPtr;                                        {allocate a print record}         dPtr^.prHandle := NewHandle(140, userID, 0, nil);         if dPtr^.prHandle <> nil then begin            PrDefault(dPtr^.prHandle);            if ToolError <> 0 then begin               DisposeHandle(dPtr^.prHandle);               dPtr^.prHandle := nil;               end; {if}            end; {if}         end; {else}      end {if}   else      FlagError(2, 0);                  {handle an out of memory error}   NewDocument := dPtr;   end; {NewDocument}   procedure SaveDocument (dPtr: documentPtr);   { Save a document file to disk                                  }   {                                                               }   { Parameters:                                                   }   {    dPtr - pointer to the document to save                     }   begin {SaveDocument}   end; {SaveDocument}   procedure HandleMenu;   { Handle a menu selection.                                   }    var      menuNum, menuItemNum: integer;    {menu number & menu item number}      procedure DoAbout;      { Draw our about box                                         }      const         alertID = 1;                   {alert string resource ID}      var         button: integer;               {button pushed}      begin {DoAbout}      button := AlertWindow($0005, nil, alertID);      end; {DoAbout}      procedure DoNew;      { Open a new document window                              }      var         dPtr: documentPtr;             {pointer to the new document}         name: pString;                 {new document name}      begin {DoNew}      GetUntitledName(name);      dPtr := NewDocument(name);      end; {DoNew}      procedure DoOpen;      { Open a file                                             }      const         posX = 80;                     {X position of the dialog}         posY = 50;                     {Y position of the dialog}µRºEÓ√-ÍÚ‘G?p9h)ÒÇ8:–tÕ†B˚ﬂJ|≠n'ÊmæêÄ˝^© `M∂;À≠‘ˇÒõÈ.$P≈üÃtWõn•NªŸ—ndÎˆ]	ÑŸlˇèO{Å°G?Æù¥q≈§≤ÂÁ»´ÅÃP}÷˝ù9`9"Â1üˆÚzû~Qö«%Ø=[‹x¡1#Hz™r¥ö>-m
ê”ıËT"‘ßm≈Ë?3Ω„—Õ√?Ω)@bŒê><ùÉ∑)x7ﬁáıØ <ÕŒy3∞≠≥âΩ≠°”oö• ØÎíƒ·íi™âr»’0=±,´ìÀ [<™∆
zf÷€æeûøº ÛWFÇË>)ß¸z—K|ÕˆnùËt•ÿ‰UÄ≠{º& cÎÙ4÷£q€^Y´hhIØ–Ωx[⁄…qd%ÿiòº]â÷	ínzl   end; {else}      end {if}   else      FlagError(2, 0);                  {handle an out of memory error}   NewDocument := dPtr;   end; {NewDocument}   procedure SaveDocument (dPtr: documentPtr);   { Save a document file to disk                                  }   {                                                               }   { Parameters:                                                   }   {    dPtr - pointer to the document to save                     }   var      count: integer;                   {number of points in the file}      f: file of integer;               {output file variable}      gsosNamePtr: gsosOutStringPtr;    {pointer to the GS/OS path name}      i: integer;                       {loop/index variable}      name: pString;                    {new document name}      pp: pointRecordPtr;               {used to trace the point list}   begin {SaveDocument}   if dPtr <> nil then begin                                        {form the file name}      HLock(dPtr^.ptArray, ord4(errorAlert));   end; {FlagError}   procedure CloseDocument (dPtr: documentPtr);   { Close a document and its associated window                    }   {                                                               }   { Parameters:                                                   }   {    dPtr - pointer to the document to close=5B.OºÇkOõõÏ
¿ÈF≠\”®≠)Ò”“ˆmGG∆uÿ˛^¡áØ≠nÒô¨ô¨∏6!{ùÓ*∑òx∆r’éÈ 44x£√™Á˚Gˆ„{i«Í^ßdÌ≤DLˇÒV2‚⁄&çWô k''ßØ&«$ö˜„£ôÍËÜ(T§4™ëHˇ—S™¶sÒf’Q9◊Q6Î+e≈ÓHr—Oû≈±+Ék--------------}program SlideShow;uses Common, QuickDrawII, EventMgr, WindowMgr, ControlMgr, DeskMgr,     DialogMgr, MenuMgr, ResourceMgr, MemoryMgr, SFToolSet, ToolLocator,     MscToolSet, PrintMgr, GSOS;const   return        = 13;                  {return key code}    appleMenu     = 1;                   {Menu ID #s (also resource ID #s)}   fileMenu      = 2;   editMenu      = 3;   editUndo      = 250;   editCut       = 251;   editCopy      = 252;   editPaste     = 253;   editClear     = 254;   fileOpen      = 261;   fileClose     = 255;   fileSave      = 262;   fileSaveAs    = 263;   filePageSetup = 264;   filePrint     = 265;   fileQuit      = 256;   appleAbout    = 257;type   long = record                        {for splitting 4 bytes to 2 bytes}      case boolean of         true : (long: longint);         false: (lsw,msw: integer);      end;   documentPtr = ^documentRecord;       {document pointer}   documentRecord = record              {information about our document}      next: documentPtr;                {next document}      wPtr: grafPortPtr;                {window pointer}      wName: pString;                   {window name}      onDisk: boolean;                  {does the file exist on disk?}      fileName: handle;                 {file name handle or nil}      pathName: handle;                 {full path name handle or nil}      pictureHandle: handle;            {handle of the picture}      prHandle: handle;                 {print record}      end;var   defaultColors: colorTable;           {default color table}   documents: documentPtr;              {our documents}   done: boolean;                       {tells if the program should stop}   event: integer;                      {event #; returned by GetNextEvent}   myEvent: eventRecord;                {last event returned in event loop}   startStopParm: longint;              {tool start/shutdown parameter}   untitledNum: integer;                {number for the next untitled window}   procedure InitGlobals;   { Initialize the global variables                            }   begin {InitGlobals}   documents := nil;   GetColorTable(0, defaultColors);   end; {InitGlobals}   procedure InitMenus;   { Initialize the menu bar.                                   }   const      menuID = 1;                       {menu bar resource ID}    var      height: integer;                  {height of the largest menu}      menuBarHand: menuBarHandle;       {for 'handling' the menu bar}    begin {InitMenus}                                        {create the menu bar}   menuBarHand := NewMenuBar2(refIsResource, menuID, nil);   SetSysBar(menuBarHand);   SetMenuBar(nil);   FixAppleMenu(1);                     {add desk accessories}   height := FixMenuBar;                {draw the completed menu bar}   DrawMenuBar;   end; {InitMenus}   function GetPString (resourceID: integer): pStringPtr;   { Get a string from the resource fork                        }   {                                                            }   { Parameters:                                                }   {    resourceID - resource ID of the rPString resource       }   {                                                            }   { Returns: pointer to the string; nil for an error           }   {                                                            }   { Notes: The string is in a locked resource handle.  The     }   {    caller should call FreePString when the string is no    }   {    longer needed.  Failure to do so is not catastrophic;   }   {    the memory will be deallocated when the program is shut }   {    down.                                                   }   const      rPString = $8006;                 {resource type for p-strings}   var      hndl: handle;                     {resource handle}   begin {GetPString}   hndl := LoadResource(rPString, resourceID);   if ToolError <> 0 then      GetPString := nil   else begin      HLock(hndl);      GetPString := pStringPtr(hndl^);      end; {else}   end; {GetPString}   procedure FreePString (resourceID: integer);   { Free a resource string                                     }   {                                                            }   { Parameters:                                                }   {    resourceID - resource ID of the rPString to free        }   const      rPString = $8006;                 {resource type for p-strings}   begin {FreePString}                  ReleaseResource(-3, rPString, resourceID);   end; {FreePString}   procedure FlagError (error, tError: integer);   { Flag an error                                              }   {                                                            }   { Parameters:                                                }   {    error - error message number                            }   {    tError - toolbox error code; 0 if none                  }   const      errorAlert = 2000;                {alert resource ID}      errorBase = 2000;                 {base resource ID for error messages}   var      str: pString;                     {wprk string}      substArray: pStringPtr;           {substitution "array"}      button: integer;                  {button pushed}      function HexDigit (value: integer): char;      { Returns a hexadecimal digit for the value               }      {                                                         }      { Parameters:                                             }      {    value - value to form a digit from; only the least   }      {       significant 4 bits are used                       }      {                                                         }      { Returns: Hexadecimal character                          }      begin {HexDigit}      value := value & $000F;      if value > 9 then         HexDigit := chr(value-10 + ord('A'))      else         HexDigit := chr(value + ord('0'));      end; {HexDigit}   begin {FlagError}                                        {form the error string}   substArray := GetPString(errorBase + error);   str := substArray^;   FreePString(errorBase + error);   substArray := @str;   if tError <> 0 then begin            {add the tool error number}      str := concat(         str,         ' ($',         HexDigit(tError >> 12),         HexDigit(tError >> 8),         HexDigit(tError >> 4),         HexDigit(tError),         ')'         );      end; {if}                                        {show the alert}   button := AlertWindow($0005, @substArray, ord4(errorAlert));   end; {FlagError}   procedure CloseDocument (dPtr: documentPtr);   { Close a document and its associated window                    }   {                                                               }   { Parameters:                                                   }   {    dPtr - pointer to the document to close; may be nil        }   var      lPtr: documentPtr;                {pointer to the previous document}   begin {CloseDocument}   if dPtr <> nil then begin      CloseWindow(dPtr^.wPtr);          {close the window}      if documents = dPtr then          {remove dPtr from the list when...}         documents := dPtr^.next        {...dPtr is the first document}      else begin                        {...dPtr is not the first document}         lPtr := documents;         while lPtr^.next <> dPtr do            lPtr := lPtr^.next;         lPtr^.next := dPtr^.next;         end; {else}      if dPtr^.fileName <> nil then     {dispose of the name buffers}         DisposeHandle(dPtr^.fileName);      if dPtr^.pathName <> nil then         DisposeHandle(dPtr^.pathName);      if dPtr^.pictureHandle <> nil then {dispose of the picture buffer}         DisposeHandle(dPtr^.pictureHandle);      if dPtr^.prHandle <> nil then     {dispose of the print record}         DisposeHandle(dPtr^.prHandle);      dispose(dPtr);                    {dispose of the document record}      end; {if}   end; {CloseDocument}   function FindDocument (wPtr: grafPortPtr): documentPtr;   { Find the document for wPtr                                    }   {                                                               }   { Parameters:                                                   }   {    wPtr - pointer to the window for which to find a document  }   {                                                               }   { Returns: Document pointer; nil if there isn't one             }   var      done: boolean;                    {used to test for loop termination}      dPtr: documentPtr;                {used to trace the document list}   begin {FindDocument}   dPtr := documents;   done := dPtr = nil;   while not done do      if dPtr^.wPtr = wPtr then         done := true      else begin         dPtr := dPtr^.next;         done := dPtr = nil;         end; {else}   FindDocument := dPtr;   end; {FindDocument}   {$databank+}   procedure DrawContents;   { Draw the contents of the active port                       }   var      dPtr: documentPtr;                {document to draw}      info: locInfo;                    {record for PPToPort}   begin {DrawContents}   dPtr := FindDocument(GetPort);   if dPtr <> nil then begin      HLock(dPtr^.pictureHandle);      with info do begin         portSCB := $00;         ptrToPixelImage := dPtr^.pictureHandle^;         width := 160;         with boundsRect do begin            h1 := 0; h2 := 320;            v1 := 0; v2 := 200;            end; {with}         end; {with}      PPToPort(info, info.boundsRect, 0, 0, modeCopy);      HUnlock(dPtr^.pictureHandle);      end; {if}                                     end; {DrawContents}   {$databank+}   function LoadDocument (dPtr: documentPtr): boolean;   { Load a document file from disk                                }   {                                                               }   { Parameters:                                                   }   {    dPtr - pointer to the document to save                     }   {                                                               }   { Returns: true if successful, else false                       }      var      clRec: closeOSDCB;                {CloseGS record}      opRec: openOSDCB;                 {OpenGS record}      port: grafPortPtr;                {caller's grafPort}      r: rect;                          {our port rect}      rdRec: readWriteOSDCB;            {ReadGS record}      scbPtr: ^byte;                    {pointer to SCB}   begin {LoadDocument}   LoadDocument := true;                {assume we will succeed}   opRec.pcount := 12;                  {open the file}   HLock(dPtr^.pathName);   opRec.pathName := pointer(ord4(dPtr^.pathName^)+2);   opRec.requestAccess := 1;   opRec.resourceNumber := 0;   opRec.optionList := nil;   OpenGS(opRec);   if ToolError <> 0 then begin      FlagError(4, ToolError);      LoadDocument := false;      end {if}   else begin      dPtr^.pictureHandle :=            {allocate memory for the file}         NewHandle(opRec.dataEOF, userID, $8000, nil);      if ToolError <> 0 then begin         FlagError(2, ToolError);         LoadDocument := false;         end {if}      else begin         rdRec.pcount := 4;             {read the file}         rdRec.refnum := opRec.refnum;         rdRec.dataBuffer := dPtr^.pictureHandle^;         rdRec.requestCount := opRec.dataEOF;         ReadGS(rdRec);         if ToolError <> 0 then begin            FlagError(4, ToolError);            LoadDocument := false;            DisposeHandle(dPtr^.pictureHandle);            dPtr^.pictureHandle := nil;            end {if}         else begin            HUnlock(dPtr^.pictureHandle); {let the picture move in memory}            port := GetPort;            {force an update}            SetPort(dPtr^.wPtr);            GetPortRect(r);            InvalRect(r);            SetPort(port);            end; {else}         end; {else}      clRec.pcount := 1;                {close the file}      clRec.refnum := opRec.refnum;      CloseGS(clRec);      end; {else}   HUnlock(dPtr^.pathName);             {unlock the name handle}   HLock(dPtr^.pictureHandle);          {warn the user if this is a 640 mode picture}   scbPtr := pointer(ord4(dPtr^.pictureHandle^)+32000);   if scbPtr^ & $0080 <> 0 then      FlagError(7, 0);   HUnlock(dPtr^.pictureHandle);   end; {LoadDocument}   procedure GetUntitledName (var name: pString);   { Create a name for an untitled window                          }   {                                                               }   { Parameters:                                                   }   {    name - (returned) name for the window                      }   const      untitled = 101;                   {Resource number for "Untitled "}   var      dPtr: documentPtr;                {used to trace the document list}      number: integer;                  {new value for untitledNum}      sPtr: pStringPtr;                 {pointer to the resource string}   begin {GetUntitledName}   dPtr := documents;                   {if there are no untitled         }   number := 1;                         —’∆1%V*Ëπ57]I€ÃÒ6ârÕìe>mZ˛>æz‚ëÈ
Ù%a9Á~≠jìk ∞Ø¬mÕ#È”(UvGÊ'XZÎnÒ≥èﬁ4[cÛﬂ~èΩn{'ûÆä—R|E»&æXWp9hv}DWJßÖG#†≠UOxo≥Ë%«~nn„biN¯¥Åı”–ZU¸ÅRÍGúÂLdÂÀa¡∏}AÕê—ˇümIRoEâ–LL¨H¥Pm"¢U∞Ü®:5Ë≠ºh©30€¸ÀõïåHãeÍ≥}XˇÙ‰ÁõvÏèwœ{CÏ∂W¯ÿH!F[à˝øÌH ‚Lﬁ±é «õ˘,EÁ≠<ê“Ò"ñ⁄˛ÚÃö†ÌÇ˘i……˛—¢ ì[Ú§…’6s<ã}À-M	é+æœ>G√ƒEw“C¯e∆ûæà)%Msn’§ÅV›’PkIÒròº;·ÓıefYP7êªm(Xnı˜x	àóB´ª≤<ÒªOâznﬂ†œé∏ÍP≈ÒÔÖ£æsn œ˜tb7ùô©è◊˛Õ·ËL˘'AƒGÜ∆@oz◊      w       'Z           fA         £´   Í 	 	Û 	 	„*0k    `÷Ó†‘øƒ„/ƒ„/¨„/§*¥ ∂∂ |=>ß **¥ ∂∂ k¿ F:+¥ — ∂ å∂ Åô 	¥ —∞Ñ°ˇ◊∞	       {      |      ~      }         +   Ä   1   |   9   É       ;'Z           ;Kl         3Ïq      
   1gq         /í   *¥ ∂∂ |<ª AY∑ ¨M>ß *¥ ∂∂ k¿ F:,¥ —∂ eÑ°ˇÂ,∂ æ∞b        á      à      â      ã      ä   #   å   ,   â   4   é       9'Z          1Ïq         (`{         &gq      #   /í   *+∂ â±       í      ë       'Z           fA   *+∂ ¢,∑ ≈±	       ñ   
   ï       'Z           fA          Él   *+∑ }±        õ      ô  ï  A „-Pk    @÷Ó†‘øƒ„2„1„1       'Z           œl   *∑ r±        °      ü       'Z           