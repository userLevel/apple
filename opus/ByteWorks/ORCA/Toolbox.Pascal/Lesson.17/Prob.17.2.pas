{---------------------------------------------------------------}{                                                               }{  Instrument Sampler                                           }{                                                               }{  Load and try ASIF instruments.                               }{                                                               }{---------------------------------------------------------------}program InstrumentSampler;uses Common, QuickDrawII, EventMgr, WindowMgr, ControlMgr, DeskMgr,     DialogMgr, MenuMgr, ResourceMgr, MemoryMgr, SFToolSet, ToolLocator,     MscToolSet, SoundMgr, Synthesizer, GSOS, Interrupt;const   return        = 13;                  {return key code}   appleMenu     = 1;                   {Menu ID #s (also resource ID #s)}   fileMenu      = 2;   editMenu      = 3;   editUndo      = 250;   editCut       = 251;   editCopy      = 252;   editPaste     = 253;   editClear     = 254;   fileOpen      = 261;   fileQuit      = 256;   appleAbout    = 257;   keyWidth      = 18;                  {key size}   keyHeight     = 50;   numKeys       = 21;                  {number of keys on the keyboard}type      long = record                        {for splitting 4 bytes to 2 bytes}      case boolean of         true : (long: longint);         false: (lsw,msw: integer);      end;var   wPtr: grafPortPtr;                   {our window}   device: longint;                     {disk insert device}   done: boolean;                       {tells if the program should stop}   event: integer;                      {event #; returned by GetNextEvent}   myEvent: eventRecord;                {last event returned in event loop}   startStopParm: longint;              {tool start/shutdown parameter}   instrumentHandle: handle;            {instrument file handle}   instrumentPtr: ^instrument;          {instrument record}   procedure InitGlobals;   { Initialize the global variables                            }   begin {InitGlobals}   instrumentHandle := nil;             {no instrument loaded}   end; {InitGlobals}   procedure InitMenus;   { Initialize the menu bar.                                   }   const      menuID = 1;                       {menu bar resource ID}    var      height: integer;                  {height of the largest menu}      menuBarHand: menuBarHandle;       {for 'handling' the menu bar}    begin {InitMenus}                                        {create the menu bar}   menuBarHand := NewMenuBar2(refIsResource, menuID, nil);   SetSysBar(menuBarHand);   SetMenuBar(nil);   FixAppleMenu(1);                     {add desk accessories}   height := FixMenuBar;                {draw the completed menu bar}   DrawMenuBar;   end; {InitMenus}   function GetPString (resourceID: integer): pStringPtr;   { Get a string from the resource fork                        }   {                                                            }   { Parameters:                                                }   {    resourceID - resource ID of the rPString resource       }   {                                                            }   { Returns: pointer to the string; nil for an error           }   {                                                            }   { Notes: The string is in a locked resource handle.  The     }   {    caller should call FreePString when the string is no    }   {    longer needed.  Failure to do so is not catastrophic;   }   {    the memory will be deallocated when the program is shut }   {    down.                                                   }   const      rPString = $8006;                 {resource type for p-strings}   var      hndl: handle;                     {resource handle}   begin {GetPString}   hndl := LoadResource(rPString, resourceID);   if ToolError <> 0 then      GetPString := nil   else begin      HLock(hndl);      GetPString := pStringPtr(hndl^);      end; {else}   end; {GetPString}   procedure FreePString (resourceID: integer);   { Free a resource string                                     }   {                                                            }   { Parameters:                                                }   {    resourceID - resource ID of the rPString to free        }   const      rPString = $8006;                 {resource type for p-strings}   begin {FreePString}                  ReleaseResource(-3, rPString, resourceID);   end; {FreePString}   procedure FlagError (error, tError: integer);   { Flag an error                                              }   {                                                            }   { Parameters:                                                }   {    error - error message number                            }   {    tError - toolbox error code; 0 if none                  }   const      errorAlert = 2000;                {alert resource ID}      errorBase = 2000;                 {base resource ID for error messages}   var      str: pString;                     {wprk string}      substArray: pStringPtr;           {substitution "array"}      button: integer;                  {button pushed}      function HexDigit (value: integer): char;      { Returns a hexadecimal digit for the value               }      {                                                         }      { Parameters:                                             }      {    value - value to form a digit from; only the least   }      {       significant 4 bits are used                       }      {                                                         }      { Returns: Hexadecimal character                          }      begin {HexDigit}      value := value & $000F;      if value > 9 then         HexDigit := chr(value-10 + ord('A'))      else         HexDigit := chr(value + ord('0'));      end; {HexDigit}   begin {FlagError}                                        {form the error string}   substArray := GetPString(errorBase + error);   str := substArray^;   FreePString(errorBase + error);   substArray := @str;   if tError <> 0 then begin            {add the tool error number}      str := concat(         str,         ' ($',         HexDigit(tError >> 12),         HexDigit(tError >> 8),         HexDigit(tError >> 4),         HexDigit(tError),         ')'         );      end; {if}                                        {show the alert}   button := AlertWindow($0005, @substArray, ord4(errorAlert));   end; {FlagError}   {$databank+}   procedure DrawContents;   { Draw the contents of the active port                       }   var      i: integer;                       {loop variable}      r: rect;                          {rectangle inclosing sharp keys}   begin {DrawContents}   PenNormal;                           {draw black lines}   SetPenSize(2,1);   with r do begin                      {set up initial sharp key rect}      h1 := keyWidth - keyWidth div 4;      h2 := h1 + keyWidth div 2 + 1;      v1 := 0;      v2 := keyHeight div 2;      end;   for i := 1 to numKeys-1 do begin     {for each key...}      MoveTo(i*keyWidth, 0);            {draw the lines separating keys}      LineTo(i*keyWidth, keyHeight);      if ((i-1) mod 7) in [0,1,3,4,5] then {draw the sharp (black) keys}         if i <> numKeys-1 then            PaintRect(r);      r.h1 := r.h1+keyWidth;            {set sharp key rectangle for next key}      r.h2 := r.h2+keyWidth;      end; {for}   end; {DrawContents}   {$databank+}   procedure InitWindow;   { Set up the program window                                  }   const      rWindParam1 = $800E;              {resource ID}      wrNum = 1001;                     {window resource number}   var      i: integer;                       {loop/index variable}   begin {InitWindow}   wPtr := NewWindow2(@'  Instrument Sampler  ', 0, @DrawContents, nil, $02,      wrNum, rWindParam1);   end; {InitWindow}   procedure ReadASIFFile (name: handle);   { Load an ASIF instrument file                               }   {                                                            }   { Parameters:                                                }   {    name - handle of a GS/OS output name                    }      var      clRec: closeOSDCB;                {CloseGS record}      length: longint;                  {size of the file buffer}      opRec: openOSDCB;                 {OpenGS record}      rdRec: readWriteOSDCB;            {ReadGS record}      procedure SetUpInstrument;      { Set up the instrument                                   }      type         chunkType = packed array[1..4] of char; {chunk ID type}      var         cPtr: ptr;                     {chunk pointer}         error: boolean;                {did we find an error?}         numSamples: integer;           {number of samples to skip}         sType: chunkType;              {super chunk type}         sPtr: ptr;                     {points to first chunk}         superLength: longint;          {length of the file}         waveSize: integer;             {size of the waveform}         function GetByte (var p: ptr): integer;         { Read a byte from the file buffer                           }         {                                                            }         { Parameters:                                                }         {    p - pointer to the byte (updated)                       }         {                                                            }         { Returns: Byte from the file                                }         begin {GetByte}         GetByte := p^;         p := pointer(ord4(p)+1);         end; {GetByte}         function GetInt (var p: ptr): integer;         { Read an integer from the file                              }         {                                                            }         { Parameters:                                                }         {    p - pointer to the value (updated)                      }         {                                                            }         { Returns: value                                             }         begin {GetInt}         GetInt := GetByte(p) | (GetByte(p) << 8);         end; {GetInt}         function GetLong2 (var p: ptr): longint;         { Read a reverse order longint from the file                 }         {                                                            }         { Parameters:                                                }         {    p - pointer to the value (updated)                      }         {                                                            }         { Returns: value                                             }         var            value: longint;             {value}         begin {GetLong2}         value := GetByte(p);         value := (value << 8) | GetByte(p);         value := (value << 8) | GetByte(p);         value := (value << 8) | GetByte(p);         GetLong2 := value;         end; {GetLong2}         procedure GetType (var p: ptr; var id: chunkType);         { Read a type from the file buffer                           }         {                                                            }         { Parameters:                                                }         {    p - pointer to the byte (updated)                       }         {    id - (output) type read                                 }         begin {GetType}         id[1] := chr(GetByte(p));         id[2] := chr(GetByte(p));         id[3] := chr(GetByte(p));         id[4] := chr(GetByte(p));         end; {GetType}         function FindChunk (p: ptr; chunk: chunkType; len: longint): ptr;         { Locate a chunk in an ASIF file                       }         {                                                      }         { Parameters:                                          }         {    p - pointer to the start of the first chunk       }         {    chunk - character type for the chunk to find      }         {    len - number of bytes left in the file            }         {                                                      }         { Returns: Pointer to the chunk; nil if not found.     }         var            disp: longint;              {length of the data in the chunk}            id: chunkType;              {chunk type for the current chunk}         begin {FindChunk}         repeat            GetType(p, id);            disp := GetLong2(p);            FindChunk := p;            p := pointer(ord4(p)+disp);            len := len - disp;            if len <= 0 then               if id <> chunk then begin                  p := nil;                  FindChunk := nil;                  end; {if}         until (p = nil) or (chunk = id);         end; {FindChunk}               begin {SetUpInstrument}      error := false;                   {no error found, yet}      sPtr := instrumentHandle^;        {verify that this is an ASIF file}      GetType(sPtr, sType);      if sType <> 'FORM' then         error := true;      if not error then begin         superLength := GetLong2(sPtr);         GetType(sPtr, sType);         if sType <> 'ASIF' then            error := true;         end; {if}      if not error then begin           {find the instrument}         cPtr := FindChunk(sPtr, 'INST', superLength);         if cPtr = nil then            error := true         else            instrumentPtr := pointer(ord4(cPtr) + cPtr^ + 3);         with instrumentPtr^ do begin            envelope[1] := 127;            envelope[2] := $80;            envelope[3] := $3F;            envelope[4] := 100;            envelope[5] := $B3;            envelope[6] := $00;            envelope[7] := 90;            envelope[8] := $06;            envelope[9] := $00;            envelope[10] := 0;            envelope[11] := $26;            envelope[12] := $01;            releaseSegment := 3;            vibratoDepth := 80;            vibratoSpeed := 40;            end; {with}         end; {if}      if not error then begin           {find and load the waveform}         cPtr := FindChunk(sPtr, 'WAVE', superLength);         if cPtr = nil then            error := true         else begin            cPtr := pointer(ord4(cPtr) + cPtr^ + 1);            waveSize := GetInt(cPtr);            numSamples := GetInt(cPtr);            cPtr := pointer(ord4(cPtr) + numSamples*12);            DisableInterrupts;            WriteRamBlock(cPtr, 0, waveSize);               EnableInterrupts;            end; {else}         end; {if}      if error then begin               {handle any error found}         FlagError(11, 0);         DisposeHandle(instrumentHandle);         instrumentHandle := nil;         end; {if}      end; {SetUpInstrument}   begin {ReadASIFFile}   if instrumentHandle <> nil then      {get rid of any old instrument}      begin      DisposeHandle(instrumentHandle);      instrumentHandle := nil;      end; {if}   opRec.pcount := 12;                  {open the file}   HLock(name);   opRec.pathName := pointer(ord4(name^)+2);   opRec.requestAccess := 1;   opRec.resourceNumber := 0;   opRec.optionList := nil;   OpenGS(opRec);   if ToolError <> 0 then      FlagError(4, ToolError)   else begin      length := opRec.dataEOF;          {allocate memory for the file}      if length < 65536 then         length := 65536;      instrumentHandle := NewHandle(length, userID, $C000, nil);      if ToolError <> 0 then         FlagError(2, ToolError)      else begin         rdRec.pcount := 4;             {read the file}         rdRec.refnum := opRec.refnum;         rdRec.dataBuffer := instrumentHandle^;         rdRec.requestCount := opRec.dataEOF;         ReadGS(rdRec);         if ToolError <> 0 then begin            FlagError(4, ToolError);            DisposeHandle(instrumentHandle);            instrumentHandle := nil;            end {if}         else            SetUpInstrument;         end; {else}      clRec.pcount := 1;                {close the file}      clRec.refnum := opRec.refnum;      CloseGS(clRec);      end; {else}   HUnlock(name);                       {unlock the name handle}   end; {ReadASIFFile}   procedure PlayNote (p: point);   { Play a note                                                }   {                                                            }   { Parameters:                                                }   {    p - location of key to play                             }   const      volume = 120;                     {volume}   var      generator: integer;               {generator for this note}      generator2: integer;              {generator for swaping notes}      note: integer;                    {note number}      port: grafPortPtr;                {caller's grafport}      function FindKey (p: point): integer;      { return the key number of a click in the content region  }      {                                                         }      { Parameters:                                             }      {    p - click location                                   }      const         baseKey = 36;                  {Midi key # for any C note}         function KeyNum (h: integer): integer;         { Find the key number for a given horizontal disp on   }         { the keyboard                                         }         var            key: integer;               {working key number}         begin {KeyNum}                                        {get key + octave displacement}         key := baseKey + 12 * (h div keyWidth div 7);         case h div keyWidth mod 7 of   {add key disp}            0: ;                        {C - leftmost key}            1: key := key+2;            {D}            2: key := key+4;            {E}            3: key := key+5;            {F}            4: key := key+7;            {G}            5: key := key+9;            {A}            6: key := key+11;           {B}            end; {case}         KeyNum := key;         end; {KeyNum}      begin {FindKey}      if (p.v < keyHeight div 2)        {is it on a sharp key?}         and ((p.h + keyWidth div 4) mod keyWidth <= keyWidth div 2 + 1)         and (((p.h - keyWidth div 2) div keyWidth mod 7) in [0,1,3,4,5]) then                                        {yes - "sharp" it!}         FindKey := KeyNum(p.h - keyWidth div 2)+1      else         FindKey := KeyNum(p.h);        {no - use normal (white) key #}      end; {FindKey}   begin {PlayNote}   port := GetPort;                     {use local coordinate system}   SetPort(wPtr);   GlobalToLocal(p);                    {convert to local coordinates}   if instrumentHandle = nil then      FlagError(10, 0)   else begin      generator := AllocGen(100);       {get a generator}      if ToolError = 0 then begin         note := FindKey(p);            {figure out which key was pressed}                                        {start the note}         NoteOn(generator, note, volume, instrumentPtr^);         while StillDown(0) do begin    {wait until the mouse is released,  }            GetMouse(p);                { switching notes if the mouse moves}            if FindKey(p) <> note then begin               generator2 := AllocGen(100);               if ToolError = 0 then begin                  NoteOff(generator, note);                  generator := generator2;                  note := FindKey(p);                  NoteOn(generator, note, volume, instrumentPtr^);                  end; {if}               end; {if}            end; {while}         NoteOff(generator, note);      {start the note decay}         end; {if}      end; {else}   SetPort(port);                       {restor caller's port}   end; {PlayNote}   procedure HandleMenu;   { Handle a menu selection.                                   }    var      menuNum, menuItemNum: integer;    {menu number & menu item number}      procedure DoAbout;      { Draw our about box                                      }      const         alertID = 1;                   {alert string resource ID}      var         button: integer;               {button pushed}      begin {DoAbout}      button := AlertWindow($0005, nil, alertID);      end; {DoAbout}      procedure DoOpen;      { Open a file                                             }      const         posX = 80;                     {X position of the dialog}         posY = 50;                     {Y position of the dialog}         titleID = 102;                 {prompt string resource ID}      var         fileTypes: typeList5_0;        {list of valid file types}         reply: replyRecord5_0;         {reply record}      begin {DoOpen}      with fileTypes do begin           {set up the allowed file types}         numEntries := 1;         with fileAndAuxTypes[1] do begin            flags := $0000;            fileType := $D8;            auxType := $0002;            end; {with}         end; {with}      reply.nameVerb := 3;              {get the file to open}      reply.pathVerb := 3;      SFGetFile2(posX, posY, 2, titleID, nil, fileTypes, reply);      if ToolError <> 0 then         FlagError(3, ToolError)        {handle an error}      else if reply.good <> 0 then begin                                        {read the file}         ReadASIFFile(handle(reply.pathRef));                                        {dispose of the name buffers}         DisposeHandle(handle(reply.nameRef));         DisposeHandle(handle(reply.pathRef));         end; {else if}      end; {DoOpen}   begin {HandleMenu}                                        {separate the menu and item numbers}   menuNum := long(myEvent.taskData).msw;   menuItemNum := long(myEvent.taskData).lsw;   case menuItemNum of                  {go handle the menu}      appleAbout:  DoAbout;      fileOpen:    DoOpen;      fileQuit:    done := true;      editUndo:    ;      editCut:     ;      editCopy:    ;      editPaste:   ;      editClear:   ;      otherwise:   ;      end; {case}   HiliteMenu(false, menuNum);          {unhighlight the menu}   end; {HandleMenu}   procedure CheckMessages;   { Check the message center                                   }   var      bPtr: ^boolean;                   {pointer to print flag}      fHandle: handle;                  {GS/OS path name}      msgHandle: handle;                {message}      sPtr: pStringPtr;                 {pointer to file name}      function StringToGSOS (sPtr: pStringPtr): handle;      { Convert a p-string to a GS/OS handle                    }      {                                                         }      { Parameters:                                             }      {    sPtr - pointer to the p-string to convert            }      {                                                         }      { Returns: handle to GS/OS output string; nil for error   }      var         osHandle: handle;              {handle of the file name}         osPtr: gsosOutStringPtr;       {output string pointer}      begin {StringToGSOS}      osHandle := NewHandle(length(sPtr^)+5, userID, $8010, nil);      if ToolError <> 0 then         FlagError(2, ToolError)      else begin         osPtr := pointer(osHandle^);         osPtr^.maxSize := length(sPtr^)+4;         osPtr^.theString.size := length(sPtr^);         osPtr^.theString.theString := sPtr^;         HUnlock(osHandle);         end; {else}      StringToGSOS := osHandle;      end; {StringToGSOS}   begin {CheckMessages}   msgHandle := NewHandle(1, userID, $0000, nil);   if ToolError = 0 then begin      MessageCenter(getMessage, 1, msgHandle);      if ToolError = 0 then begin         MessageCenter(deleteMessage, 1, msgHandle);         HLock(msgHandle);         bPtr := pointer(ord4(msgHandle^)+6);         sPtr := pointer(ord4(bPtr)+2);         if bPtr^ then begin            FlagError(12, 0);            done := true;            end {if}         else begin            fHandle := StringToGSOS(sPtr);            sPtr := pointer(ord4(sPtr)+length(sPtr^)+1);            if length(sPtr^) <> 0 then               FlagError(13, 0);            if fHandle <> nil then begin               ReadASIFFile(fHandle);               DisposeHandle(fHandle);               end; {if}            end; {else}         end; {if}      DisposeHandle(msgHandle);      end {if}   else      FlagError(2, ToolError);   end; {CheckMessages}begin {InstrumentSampler}startStopParm :=                        {start up the tools}   StartUpTools(userID, 2, 1);if ToolError <> 0 then   SysFailMgr(ToolError, @'Could not start tools: ');InitMenus;                              {set up the menu bar}InitWindow;                             {set up the program window}InitCursor;                             {show the cursor}InitGlobals;                            {initialize our global variables}AllNotesOff;                            {make sure all notes are off}done := false;                          {main event loop}CheckMessages;                          {check the message center}myEvent.taskMask := $001F7FFF;          {let task master do it all}while not done do begin   device := HandleDiskInsert($C000, 0);   event := TaskMaster(everyEvent, myEvent);   case event of                        {handle the events we need to}      wInSpecial,      wInMenuBar: HandleMenu;      wInGoAway:  done := true;      wInContent: PlayNote(myEvent.eventWhere);      otherwise: ;      end; {case}   end; {while}AllNotesOff;                            {make sure all notes are off}ShutDownTools(1, startStopParm);        {shut down the tools}end. {InstrumentSampler}