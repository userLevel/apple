{---------------------------------------------------------------}{                                                               }{  Control Explorer                                             }{                                                               }{  Explores how controls work.                                  }{                                                               }{---------------------------------------------------------------}program ControlExplorer;uses Common, QuickDrawII, EventMgr, WindowMgr, ControlMgr, DeskMgr,     DialogMgr, MenuMgr, ResourceMgr, MemoryMgr, SFToolSet, ToolLocator,     MscToolSet, LineEdit, ListMgr;const   return        = 13;                  {return key code}    appleMenu     = 1;                   {Menu ID #s (also resource ID #s)}   fileMenu      = 2;   editMenu      = 3;   editUndo      = 250;   editCut       = 251;   editCopy      = 252;   editPaste     = 253;   editClear     = 254;   fileClose     = 255;   fileQuit      = 256;   appleAbout    = 257;   ctlBeepOnce   = 2;                   {control IDs}   ctlBeepTwice  = 3;   ctlTitle      = 4;   ctlBoxRed     = 5;   ctlBoxGreen   = 6;   ctlBoxBlue    = 7;   ctlSound      = 8;   ctlTRed       = 9;   ctlTGreen     = 10;   ctlTBlue      = 11;   ctlSRed       = 12;   ctlSGreen     = 13;   ctlSBlue      = 14;   ctlRect       = 15;   ctlSavage     = 16;   ctlLeft       = 17;   ctlRight      = 18;   ctlLine1      = 19;   ctlLine2      = 20;   ctlList       = 21;   ctlPop        = 22;   cbase         = 1000;      ctlCalc       = 100;   ctlThermometer = 101;   mixColor      = 1;                   {color mixer box color}type   long = record                        {for splitting 4 bytes to 2 bytes}      case boolean of         true : (long: longint);         false: (lsw,msw: integer);      end;   listElement = record                 {list record}      memPtr:  pStringPtr;      memFlag: byte;      end;var   wPtr: grafPortPtr;                   {our window}   done: boolean;                       {tells if the program should stop}   event: integer;                      {event #; returned by GetNextEvent}   myEvent: eventRecord;                {last event returned in event loop}   startStopParm: longint;              {tool start/shutdown parameter}   boxColor: integer;                   {box color}   boxRect: rect;                       {box color rectangle}   boxColor2: integer;                  {box color #2}   boxRect2: rect;                      {box color rectangle #2}   mixRect: rect;                       {color mixer rectangle}   soundOn: boolean;                    {is the sound turned on?}   stateList: array[0..9] of listElement; {state list}   stateNames: array[0..9] of string[13];   procedure InitGlobals;   { Initialize the global variables                            }   begin {InitGlobals}   with boxRect do begin                {set up the box rectangle}      h1 := 10; h2 := 21;      v1 := 18; v2 := 31;      end; {with}   boxColor := 7;                       {red box}   with boxRect2 do begin               {set up the 2nd box rectangle}      h1 := 200; h2 := 310;      v1 := 110; v2 := 135;      end; {with}   boxColor2 := 7;                      {red box}   with mixRect do begin                {set up the color mixer rectangle}      h1 := 10; h2 := 46;      v1 := 39; v2 := 74;      end; {with}   SetColorEntry(0, mixColor, 0);       {start off with a black color}   soundOn := true;                     {the sound is on}   end; {InitGlobals}   procedure InitMenus;   { Initialize the menu bar.                                   }   const      menuID = 1;                       {menu bar resource ID}    var      height: integer;                  {height of the largest menu}      menuBarHand: menuBarHandle;       {for 'handling' the menu bar}    begin {InitMenus}                                        {create the menu bar}   menuBarHand := NewMenuBar2(refIsResource, menuID, nil);   SetSysBar(menuBarHand);   SetMenuBar(nil);   FixAppleMenu(1);                     {add desk accessories}   height := FixMenuBar;                {draw the completed menu bar}   DrawMenuBar;   end; {InitMenus}   {$databank+}   procedure DrawContents;   { Draw the contents of the active port                       }   var      r: rect;                          {work rectangle}   begin {DrawContents}   PenNormal;   DrawControls(GetPort);               {draw the controls}   SetSolidPenPat(boxColor);            {draw the radio color box}   PaintRect(boxRect);   SetSolidPenPat(0);   FrameRect(boxRect);   SetSolidPenPat(boxColor2);           {draw the popup color box}   PaintRect(boxRect2);   SetSolidPenPat(0);   FrameRect(boxRect2);   SetSolidPenPat(mixColor);            {draw the color mixer rectangle}   PaintRect(mixRect);   SetSolidPenPat(0);   FrameRect(mixRect);   end; {DrawContents}   procedure DrawContents2;   { Draw the contents of the Savage alert                      }   begin {DrawContents2}   DrawControls(GetPort);   end; {DrawContents2}   procedure ScrollAction (part: integer; ctlHandle: ctlRecHndl);   { Scroll bar action procedure                                }   {                                                            }   { Parameters:                                                }   {    part - scroll bar part code                             }   {    ctlHandle - scroll bar handle                           }   const      pageSize = 1;                     {size of a page}      maxPos = 15;                      {max position for the scroll bar}   var      cdisp: integer;                   {color based bit shift displacement}      color: integer;                   {color table entry}      ctlID: longint;                   {control ID}      value, oldValue: integer;         {control value}   begin {ScrollAction}   value := GetCtlValue(ctlHandle);   oldValue := value;   case part of      upArrow:     value := value-1;      downArrow:   value := value+1;      pageUp:      value := value-pageSize;      pageDown:    value := value+pageSize;      thumb:       begin value := oldValue; oldValue := value-1; end;      otherwise:   ;      end; {case}   if value < 0 then      value := 0   else if value > maxPos then      value := maxPos;   if value <> oldValue then begin      SetCtlValue(value, ctlHandle);      color := GetColorEntry(0, mixColor);      ctlID := GetCtlID(ctlHandle);      if ctlID = ctlSRed then         cdisp := $0100      else if ctlID = ctlSGreen then         cdisp := $0010      else         cdisp := $0001;      color := (color & ((cdisp*$000F) ! $FFFF)) | (cdisp * value);      SetColorEntry(0, mixColor, color);      end; {if}   end; {ScrollAction}   {$databank+}   procedure InitWindow;   { Set up the program window                                  }   const      rWindParam1 = $800E;              {resource ID}      wrNum = 1001;                     {window resource number}   var      i: integer;                       {loop/index variable}   begin {InitWindow}                                        {open the window}   wPtr := NewWindow2(@' ', 0, @DrawContents, nil, $02, wrNum, rWindParam1);                                        {set up the scroll action procedure}   SetCtlAction(@ScrollAction, GetCtlHandleFromID(wPtr, ctlSRed));   SetCtlAction(@ScrollAction, GetCtlHandleFromID(wPtr, ctlSBlue));   SetCtlAction(@ScrollAction, GetCtlHandleFromID(wPtr, ctlSGreen));                                        {set up the state list}   stateNames[0] := 'California';   stateNames[1] := 'Colorado';   stateNames[2] := 'Connecticut';   stateNames[3] := 'New Hampshire';   stateNames[4] := 'New York';   stateNames[5] := 'New Mexico';   stateNames[6] := 'New Jersey';   stateNames[7] := 'Alaska';   stateNames[8] := 'Alabama';   stateNames[9] := 'Arkansas';   for i := 0 to 9 do begin      stateList[i].memPtr := @stateNames[i];      stateList[i].memFlag := 0;      end; {for}   NewList2(nil, 1, ord4(@stateList), 0, 10, GetCtlHandleFromID(wPtr, ctlList));   SortList2(nil, GetCtlHandleFromID(wPtr, ctlList));   DrawMember2(0, GetCtlHandleFromID(wPtr, ctlList));   end; {InitWindow}   function GetCtlData (ctl: ctlRecHndl): longint;   { Returns the contents of a controls ctlData field           }   {                                                            }   { Parameters:                                                }   {    ctl - control                                           }   {                                                            }   { Returns: ctlData field                                     }   var      swap: integer;                    {used to swap words}      val: long;                        {param/ctlData field}   begin {GetCtlData}   val.long := GetCtlParams(ctl);   swap := val.msw;   val.msw := val.lsw;   val.lsw := swap;   GetCtlData := val.long;   end; {GetCtlData}   procedure HandleMenu;   { Handle a menu selection.                                   }    var      menuNum, menuItemNum: integer;    {menu number & menu item number}      procedure DoAbout;      { Draw our about box                                      }      const         alertID = 1;                   {alert string resource ID}      var         button: integer;               {button pushed}      begin {DoAbout}      button := AlertWindow($0005, nil, alertID);      end; {DoAbout}      procedure DoClear;      { Handle a clear command                                  }      var         ctl: ctlRecHndl;               {target control handle}         id: longint;                   {control ID}         port: grafPortPtr;             {caller's grafPort}      begin {DoClear}      port := GetPort;      SetPort(wPtr);      ctl := FindTargetCtl;      id := GetCtlID(ctl);      if (id = ctlLine1) or (id = ctlLine2) then         LEDelete(leRecHndl(GetCtlData(ctl)));      SetPort(port);      end; {DoClear}      procedure DoCopy;      { Handle a copy command                                   }      var         ctl: ctlRecHndl;               {target control handle}         id: longint;                   {control ID}         port: grafPortPtr;             {caller's grafPort}      begin {DoCopy}      port := GetPort;      SetPort(wPtr);      ctl := FindTargetCtl;      id := GetCtlID(ctl);      if (id = ctlLine1) or (id = ctlLine2) then begin         LECopy(leRecHndl(GetCtlData(ctl)));         LEToScrap;         end; {if}      SetPort(port);      end; {DoCopy}      procedure DoCut;      { Handle a cut command                                    }      var         ctl: ctlRecHndl;               {target control handle}         id: longint;                   {control ID}         port: grafPortPtr;             {caller's grafPort}      begin {DoCut}      port := GetPort;      SetPort(wPtr);      ctl := FindTargetCtl;      id := GetCtlID(ctl);      if (id = ctlLine1) or (id = ctlLine2) then begin         LECut(leRecHndl(GetCtlData(ctl)));         LEToScrap;         end; {if}      SetPort(port);      end; {DoCut}      procedure DoPaste;      { Handle a paste command                                  }      var         ctl: ctlRecHndl;               {target control handle}         id: longint;                   {control ID}         port: grafPortPtr;             {caller's grafPort}      begin {DoPaste}      port := GetPort;      SetPort(wPtr);      ctl := FindTargetCtl;      id := GetCtlID(ctl);      if (id = ctlLine1) or (id = ctlLine2) then begin         LEFromScrap;         LEPaste(leRecHndl(GetCtlData(ctl)));         end; {if}      SetPort(port);      end; {DoPaste}   begin {HandleMenu}                                        {separate the menu and item numbers}   menuNum := long(myEvent.taskData).msw;   menuItemNum := long(myEvent.taskData).lsw;   case menuItemNum of                  {go handle the menu}      appleAbout:  DoAbout;      fileClose:   ;      fileQuit:    done := true;      editUndo:    ;      editCut:     DoCut;      editCopy:    DoCopy;      editPaste:   DoPaste;      editClear:   DoClear;      otherwise:   ;      end; {case}   HiliteMenu(false, menuNum);          {unhighlight the menu}   end; {HandleMenu}   procedure HandleControl;   { Take action after a control has been selected                 }      procedure ForceUpdate (r: rect);      { Force an update of our window                           }      {                                                         }      { Parameters:                                             }      {    r - rectangle to update                              }      var         port: grafPortPtr;             {caller's grafPort}      begin {ForceUpdate}      port := GetPort;      SetPort(wPtr);      InvalRect(r);      SetPort(port);      end; {ForceUpdate}      procedure Savage;      { Run the Savage benchmark                                }      const         rWindParam1 = $800E;           {resource ID}         wrNum = 1002;                  {window resource number}      var         ctlThermo: ctlRecHndl;         {thermometer control handle}         i: integer;                    {loop variable}         sum: real;                     {savage sum}         wPtr: grafPortPtr;             {alert grafPort}      begin {Savage}      wPtr := NewWindow2(@' ', 0, @DrawContents2, nil, $02, wrNum, rWindParam1);      if ToolError = 0 then begin         DrawControls(wPtr);         ctlThermo := GetCtlHandleFromID(wPtr, ctlThermometer);         sum := 1.0;         for i := 1 to 250 do begin            SetCtlValue(i, ctlThermo);            sum := tan(arctan(exp(ln(sqrt(sqr(sum))))))+1.0;            end; {for}         CloseWindow(wPtr);         end; {with}      end; {Savage}      procedure ColorLeft;      { Switch the color radio button left                      }      begin {ColorLeft}      if GetCtlValue(GetCtlHandleFromID(wPtr, ctlBoxRed)) <> 0 then begin         SetCtlValue(1, GetCtlHandleFromID(wPtr, ctlBoxBlue));         boxColor := 4;         end {if}      else if GetCtlValue(GetCtlHandleFromID(wPtr, ctlBoxGreen)) <> 0 then begin         SetCtlValue(1, GetCtlHandleFromID(wPtr, ctlBoxRed));         boxColor := 7;         end {else if}      else begin         SetCtlValue(1, GetCtlHandleFromID(wPtr, ctlBoxGreen));         boxColor := 10;         end; {else}      ForceUpdate(boxRect);      end; {ColorLeft}      procedure ColorRight;      { Switch the color radio button right                     }      begin {ColorRight}      if GetCtlValue(GetCtlHandleFromID(wPtr, ctlBoxGreen)) <> 0 then begin         SetCtlValue(1, GetCtlHandleFromID(wPtr, ctlBoxBlue));         boxColor := 4;         end {if}      else if GetCtlValue(GetCtlHandleFromID(wPtr, ctlBoxBlue)) <> 0 then begin         SetCtlValue(1, GetCtlHandleFromID(wPtr, ctlBoxRed));         boxColor := 7;         end {else if}      else begin         SetCtlValue(1, GetCtlHandleFromID(wPtr, ctlBoxGreen));         boxColor := 10;         end; {else}      ForceUpdate(boxRect);      end; {ColorLeft}      procedure PopUpColor;      { Set the pop-up box color based on the control value     }      begin {PopUpColor}      case GetCtlValue(GetCtlHandleFromID(wPtr, ctlPop))-cbase-ctlPop of         1: boxColor2 := 7;         2: boxColor2 := 10;         3: boxColor2 := 4;         end; {case}      ForceUpdate(boxRect2);      end; {PopUpColor}   begin {HandleControl}   if (myEvent.taskData4 & $FFFF8000) = 0 then      case ord(myEvent.taskData4) of         ctlBeepOnce:    if soundOn then                            SysBeep;         ctlBeepTwice:   if soundOn then begin                            SysBeep;                            SysBeep;                            end;         ctlBoxRed:      begin boxColor := 7; ForceUpdate(boxRect); end;         ctlBoxGreen:    begin boxColor := 10; ForceUpdate(boxRect); end;         ctlBoxBlue:     begin boxColor := 4; ForceUpdate(boxRect); end;         ctlSound:       soundOn := not soundOn;         ctlSavage:      Savage;         ctlLeft:        ColorLeft;         ctlRight:       ColorRight;         ctlPop:         PopUpColor;         otherwise:      ;         end; {case}   end; {HandleControl}begin {ControlExplorer}startStopParm :=                        {start up the tools}   StartUpTools(userID, 2, 1);if ToolError <> 0 then   SysFailMgr(ToolError, @'Could not start tools: ');InitMenus;                              {set up the menu bar}InitGlobals;                            {initialize our global variables}InitWindow;                             {set up the program window}InitCursor;                             {show the cursor}done := false;                          {main event loop}myEvent.taskMask := $001F7FFF;          {let task master do it all}repeat   event := TaskMaster(everyEvent, myEvent);   case event of                        {handle the events we need to}      wInSpecial,      wInMenuBar: HandleMenu;      wInControl: HandleControl;      otherwise: ;      end; {case}until done;ShutDownTools(1, startStopParm);        {shut down the tools}end. {ControlExplorer}