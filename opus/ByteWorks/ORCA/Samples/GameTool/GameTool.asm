	keep	'GameTool'	mcopy	'GameTool.mac'******************************************************************  Game Paddle Port Tool**  This user tool provides access to the game paddle port.**  Reference: Apple IIGS Toolbox Reference, Volume 2, Appendix A*******************************************************************  Copyright 1998*  Byte Works, Inc.*  All Rights Reserved**  May 1998*  Mike Westerfield***********************************************************************************************************************************  Function Pointer Table (FPT)**  This table is required by the Tool Locator.  It must be at*  the start of the file.******************************************************************FPT	datacount	equ	13	function number for the highest numbered!			 tool call	dc	i4'count'	number of routines + 1	dc	a4'BootInit-1'	required functions	dc	a4'StartUp-1'	dc	a4'ShutDown-1'	dc	a4'Version-1'	dc	a4'Reset-1'	dc	a4'Status-1'	dc	a4'Null-1'	reserved functions	dc	a4'Null-1'	dc	a4'GTGetSwitch-1'	user functions	dc	a4'GTClearAnnunciator-1'	dc	a4'GTSetAnnunciator-1'	dc	a4'GTGetPaddle-1'	end******************************************************************  Common - common data******************************************************************Common	data;;  Constants;false	equ	0	boolean constanttrue	equ	1	boolean constanttoolVersion equ $0100	tool version number;;  Global variables;active	dc	i'0'	have we been initialized?callNumber ds	2	call number	end******************************************************************  Null - Called for required tool functions that don't do*	anything**  BootInit - Required function; called at boot or load time*  Reset - Required function; called during a system reset**  Outputs:*	C - clear, indicating no error*	A - 0, indicating no error******************************************************************Null	startBootInit	entryReset	entry	clc		no error	lda	#0	error code	rtl	end******************************************************************  Startup - Required function; called when the application*	starts the tool**  Outputs:*	C - clear, indicating no error*	A - 0, indicating no error******************************************************************Startup	start	using	Common	lda	#true	active = true	sta	>active	clc		no error	lda	#0	error code	rtl	end******************************************************************  Shutdown - Required function; called when the application*	shuts down the tool**  Outputs:*	C - clear, indicating no error*	A - 0, indicating no error******************************************************************Shutdown	start	using	Common	lda	#false	active = false	sta	>active	clc		no error	lda	#0	error code	rtl	end******************************************************************  Status - Required function; tells if the tool is active**  Outputs:*	C - clear, indicating no error*	A - 0, indicating no error*	toolStatus - true if the tool is started, else false******************************************************************Status	start	using	CommontoolStatus equ	7	stack offset for toolStatus output	lda	>status	toolStatus = status	sta	toolStatus,S	clc		no error	lda	#0	error code	rtl	end******************************************************************  Version - Required function; returns the tool version**  Outputs:*	C - clear, indicating no error*	A - 0, indicating no error*	outVersion - tool version number******************************************************************Version	start	using	CommonoutVersion equ	7	stack offset for version output	lda	#toolVersion	version = toolVersion	sta	outVersion,S	clc		no error	lda	#0	error code	rtl	end******************************************************************  Error0 - return from a tool with no error**  Outputs:*	C - set*	A - toolnumber*256 + 1**  Notes: Pops two bytes of parameter from the stack******************************************************************Error0	start	lda	5,S	pop the input	sta	7,S	lda	3,S	sta	5,S	pla	sta	1,S	clc		no error	lda	#0	error code	rtl	end******************************************************************  Error1 - return form a tool with error 1**  Outputs:*	C - set*	A - toolnumber*256 + 1**  Notes: Pops two bytes of parameter from the stack******************************************************************Error1	start	using	Common	lda	5,S	pop the input	sta	7,S	lda	3,S	sta	5,S	pla	sta	1,S	sec		bad number	lda	>callNumber	error code	xba	and	#$FF00	ora	#$0001	rtl	end******************************************************************  GTClearAnnunciator - clear an annunciator**  Inputs:*	inValue - annunciator to clear**  Outputs:*	C - clear, indicating no error*	A - 0, indicating no error******************************************************************GTClearAnnunciator start	using	CommoninValue	equ	7	stack offset for inputannAddr	equ	$00C058	annunciator 0 off softswitch	txa		save the tool number (for errors)	sta	>callNumber	lda	inValue,S	get the annunciator address	cmp	#4	bge	Error1	asl	A	convert it to an offset	tax	short	M	clear the annunciator	sta	>annAddr,X	long	M	bra	Error0	return with no error	end******************************************************************  GTGetSwitch - read a switch**  Inputs:*	inValue - switch to read**  Outputs:*	C - clear if no error; else set*	A -*		0 - no error*		toolnum*256 + 1 - invalid annunciator, paddle or*		    switch number*	outValue -*		0 if the annunciator is not set*		1 if the annunciator is set**  Note: Switch 3 is new on the Apple IIGS. It was not available*	on older Apple ][ models. This accounts for the odd*	addressing, with switch 3 first, followed by the first*	three switches.******************************************************************GTGetSwitch start	using	CommoninValue	equ	7	stack offset for inputoutValue	equ	9	stack offset for outputswitchAddr equ	$00C060	address of the first switch	txa		save the tool number (for errors)	sta	>callNumber	lda	inValue,S	get the switch number	cmp	#4	bge	Error1	inc	A	convert it to an offset	and	#$0003	tax	short	M	read the switch	lda	>switchAddr,X	rol	A	long	M	lda	#0	rol	A	sta	outValue,S	save the result	bra	Error0	return with no error	end******************************************************************  GTGetPaddle - read a game paddle position**  Inputs:*	inValue - paddle to read**  Outputs:*	C - clear, indicating no error*	A - 0, indicating no error*	outValue - game paddle value (0..255)******************************************************************GTGetPaddle start	using	CommoninValue	equ	7	stack offset for inputoutValue	equ	9	stack offset for outputresetTimer equ	$00C070	softswith to reset paddle timerpaddle	equ	$00C064	address for paddle 0count	equ	11	paddle count; overlays outValue	txa		save the tool number (for errors)	sta	>callNumber	lda	inValue,S	get the paddle number	cmp	#4	bge	Error1	tax	phd		set up a local stack frame	tsc	tcd	php		disable interrupts	sei	stz	count	initialize the paddle value	short	M	start the timer	lda	>resetTimerlb1	nop		delay a bit	nop	nop	nop	inc	count	increment the paddle value	beq	lb2	lda	>paddle,X	check the paddle	bmi	lb1lb2	dec	count	timer expired; change count to 255	long	M		plp		restore the interrupt setting	pld		restore the caller's DP	brl	Error0	return with no error	end******************************************************************  GTSetAnnunciator - set an annunciator**  Inputs:*	inValue - annunciator to set**  Outputs:*	C - clear, indicating no error*	A - 0, indicating no error******************************************************************GTSetAnnunciator start	using	CommoninValue	equ	7	stack offset for inputannAddr	equ	$00C059	annunciator 0 on softswitch	txa		save the tool number (for errors)	sta	>callNumber	lda	inValue,S	get the annunciator address	cmp	#4	jge	Error1	asl	A	convert it to an offset	tax	short	M	set the annunciator	sta	>annAddr,X	long	M	brl	Error0	return with no error	end