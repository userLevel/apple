	keep	'TimeTool'	mcopy	'TimeTool.mac'******************************************************************  Time Tool**  This user tool provides time and date functions.*******************************************************************  Copyright 1998*  Byte Works, Inc.*  All Rights Reserved**  July 1998*  Mike Westerfield***********************************************************************************************************************************  Function Pointer Table (FPT)**  This table is required by the Tool Locator.  It must be at*  the start of the file.******************************************************************FPT	datacount	equ	12	function number for the highest numbered!			 tool call	dc	i4'count'	number of routines + 1	dc	a4'BootInit-1'	required functions	dc	a4'StartUp-1'	dc	a4'ShutDown-1'	dc	a4'Version-1'	dc	a4'Reset-1'	dc	a4'Status-1'	dc	a4'Null-1'	reserved functions	dc	a4'Null-1'	dc	a4'TimeString-1'	user functions	dc	a4'DateString-1'	dc	a4'Time-1'	end******************************************************************  Common - common data******************************************************************Common	data;;  Constants;false	equ	0	boolean constanttrue	equ	1	boolean constanttoolVersion equ $0100	tool version number;;  Global variables;active	dc	i'0'	have we been initialized?callNumber ds	2	call number	end******************************************************************  Null - Called for required tool functions that don't do*	anything**  BootInit - Required function; called at boot or load time*  Reset - Required function; called during a system reset**  Outputs:*	C - clear, indicating no error*	A - 0, indicating no error******************************************************************Null	startBootInit	entryReset	entry	clc		no error	lda	#0	error code	rtl	end******************************************************************  Startup - Required function; called when the application*	starts the tool**  Outputs:*	C - clear, indicating no error*	A - 0, indicating no error******************************************************************Startup	start	using	Common	lda	#true	active = true	sta	>active	clc		no error	lda	#0	error code	rtl	end******************************************************************  Shutdown - Required function; called when the application*	shuts down the tool**  Outputs:*	C - clear, indicating no error*	A - 0, indicating no error******************************************************************Shutdown	start	using	Common	lda	#false	active = false	sta	>active	clc		no error	lda	#0	error code	rtl	end******************************************************************  Status - Required function; tells if the tool is active**  Outputs:*	C - clear, indicating no error*	A - 0, indicating no error*	toolStatus - true if the tool is started, else false******************************************************************Status	start	using	CommontoolStatus equ	7	stack offset for toolStatus output	lda	>status	toolStatus = status	sta	toolStatus,S	clc		no error	lda	#0	error code	rtl	end******************************************************************  Version - Required function; returns the tool version**  Outputs:*	C - clear, indicating no error*	A - 0, indicating no error*	outVersion - tool version number******************************************************************Version	start	using	CommonoutVersion equ	7	stack offset for version output	lda	#toolVersion	version = toolVersion	sta	outVersion,S	clc		no error	lda	#0	error code	rtl	end******************************************************************  Error0 - return from a tool with no error**  Outputs:*	C - set******************************************************************Error0	start	clc		no error	lda	#0	error code	rtl	end******************************************************************  DateString - return the date as a string**  Inputs:*	addr - address to store the string pointer**  Outputs:*	C - clear, indicating no error*	A - 0, indicating no error******************************************************************DateString start	using	Commonaddr	equ	7	stack offset for string return address	phb		use our data bank	phk	plb         pha                            get the current time         pha         pha         pha         _ReadTimeHex	ldy	#0	initial offset into the string         lda   5,S                      set the month         and   #$FF00         xba	asl	A	tax	lda	months,X	taxlb1	lda	|0,X	and	#$00FF	beq	lb2	sta	str,Y	iny	inx	bra	lb1lb2      lda	#' '	separate the month from the date	sta	str,Y	iny	lda   5,S                      set the day         and   #$00FF         inc   A	jsr	ToChars	pha	and	#$00FF	cmp	#'0'	beq	lb3	sta	str,Y	inylb3	pla	xba	and	#$00FF	sta	str,Y	iny	lda	#' ,'	separate the day from the year	sta	str,Y	iny	iny         lda   3,S                      set the year         and   #$FF00         xba	pha	cmp	#100	bge	lb4	lda	#'91'	sta	str,Y	pla	bra	lb5lb4	lda	#'02'	sta	str,Y	pla	sec	sbc	#100lb5	iny	iny	jsr	ToChars	sta	str,Y	iny	iny	lda	#0	sta	str,Y	pla		pop the time	pla	pla	pla	plb		restore the caller's data bank	lda	#str	return the time string	sta	addr,S	lda	#^str	sta	addr+2,S	brl	Error0	return with no error;;  Local data;str	ds	21Months	dc	a'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'Jan	dc	c'January',i1'0'Feb	dc	c'February',i1'0'Mar	dc	c'March',i1'0'Apr	dc	c'April',i1'0'May	dc	c'May',i1'0'Jun	dc	c'June',i1'0'Jul	dc	c'July',i1'0'Aug	dc	c'August',i1'0'Sep	dc	c'September',i1'0'Oct	dc	c'October',i1'0'Nov	dc	c'November',i1'0'Dec	dc	c'December',i1'0'	end******************************************************************  Time - return the time in a time record**  Inputs:*	addr - pointer to the time record to fill in**  Outputs:*	C - clear, indicating no error*	A - 0, indicating no error******************************************************************Time	start	using	Commonaddr	equ	7	stack offset for string return address	tsc		use the stack frame as a direct page	phd	tcd         pha                            get the current time         pha         pha         pha         _ReadTimeHex         lda   3,S                      set the year         and   #$FF00         xba	clc	adc	#1900         ldy   #0	sta	[addr],Y         lda   5,S                      set the month         and   #$FF00         xba         inc   A         iny	iny	sta	[addr],Y         lda   5,S                      set the day         and   #$00FF         inc   A         iny	iny	sta	[addr],Y         lda   3,S                      set the hour         and   #$00FF         iny	iny	sta	[addr],Y         lda   1,S                      set the minute         xba         and   #$00FF         iny	iny	sta	[addr],Y         pla                            set the second         and   #$00FF         iny	iny	sta	[addr],Y	lda	#0	set the milliseconds         iny	iny	sta	[addr],Y         pla                            clean up the stack         pla         pla	pld		restore the caller's DP	lda	5,S	remove the parameter	sta	9,S	lda	3,S	sta	7,S	pla	sta	3,S	pla	brl	Error0	return with no error	end******************************************************************  TimeString - return the time as a string**  Inputs:*	addr - address to store the string pointer**  Outputs:*	C - clear, indicating no error*	A - 0, indicating no error******************************************************************TimeString start	using	Commonaddr	equ	7	stack offset for string return address         pha                            get the current time         pha         pha         pha         _ReadTimeHex         lda   3,S                      set the hour         and   #$00FF         jsr	ToChars	sta	>str         lda   1,S                      set the minute         xba         and   #$00FF         jsr	ToChars	sta	>str+3         pla                            set the second         and   #$00FF         jsr	ToChars	sta	>str+6	pla		pop the remaining time words	pla	pla	lda	#str	return the time string	sta	addr,S	lda	#^str	sta	addr+2,S	brl	Error0	return with no error;;  Local data;str	dc	c'00:00:00',i1'0'	end******************************************************************  ToChars - convert a number to two decimal digits**  Inputs:*	A - number to convert**  Outputs:*	A - characters in string order**  Notes: Y is not changed.******************************************************************ToChars	start	ldx	#-1	split the value into two decimal digitstc1	inx	sec	sbc	#10	bcs	tc1	clc	adc	#10	ora	#'00'	form the ones digit	xba	pha	txa		form the tens digit & or with the	ora	1,S	  ones digit in string order	plx		pop the ones digit	rts	end