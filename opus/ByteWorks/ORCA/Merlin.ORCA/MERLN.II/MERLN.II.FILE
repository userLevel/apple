         LIST  OFF         SYMBOL OFF         65816 OFF         65C02 OFF******************************************************************  MERLIN-TO-ORCA Source Code Translator  V1.0 D1**  Inputs:  Command-line filename, or standard input, containing*           Merlin source code**  Outputs: Translated ORCA source, either a file or line-by-line*           translation sent to standard output**  Written by:  Barbara Allred and Mike Westerfield**  By The Byte Works Inc.*  Copyright (c) 1987*  All rights reserved.*****************************************************************MAIN     START         USING COMMON         TSX                            Save pointer to MONITOR for emergency         STX   STACK                    exit         JSR   INIT         JSR   TRANSLATE         JSR   PRNT_LT         JSR   TERMINATE         RTS         END******************************************************************  MERLIN COMMON DATA -- Global variables for program******************************************************************COMMON   DATACMD_LINE GEQU  $2                       Address of command lineR0       GEQU  $4                       Zero-page "registers"R1       GEQU  $5R2       GEQU  $6R3       GEQU  $7R4       GEQU  $8R5       GEQU  $9R6       GEQU  $AR7       GEQU  $BR8       GEQU  $CR9       GEQU  $DR10      GEQU  $ER11      GEQU  $FR12      GEQU  $10R13      GEQU  $11R14      GEQU  $12R15      GEQU  $13TABLE    GEQU  $14                      Indirect address locations for searchKEY      GEQU  $16                      routinesOPR_PTR  GEQU  $18                      Pointer to current operand;;                                       Constants;BLANK    EQU   $20                      BlankRETURN   EQU   $0D                      Carriage returnASTRK    EQU   $2A                      AsteriskSEMI_COL EQU   $3B                      Semi-colonCOMMNT    EQU   1                       Line_typesINSTR     EQU   2DIRECTIVE EQU   3MACRO     EQU   4LTHANDLE DS    2                        Label table addressLENGTH   DS    4                        Total length of label tableLT_SIZE  DS    4                        Current length of label tableKEY_SIZE DS    2                        Size of key being searched forOPR_SIZE  DS   2                        Curr. size of data pointed to by opr_ptrSV_OP_PTR DS   2                        Save operand pointer when default changsSV_OP_SIZ DS   1                        Save operand size when default changesOP_COUNT  DS   1                        Number of operators found in OPERANDOP_NUM    DS   2                        Directive number; pointer into jmp tableSIZE      DS   1                        Size of entire operand fieldSTACK    DS    1                        Pointer to MONITORFILE_FLAG DS   1                        True if input is from a fileEOF_FLAG  DS   1                        End-of-file flagEOL       DS   1                        End-of-line flagMSB_FLG   DS   1                        True if string data has MSB setNEW_VAR   DS   1                        True if new variabl found in input labelABS_FLAG  DS   1                        True if opcode uses forced abs addressSTR_FLG   DS   1                        True if operand is a stringMAC_FLG   DS   1                        True if a macro is being definedNO_PRNT   DS   1                        True if input line should be commented;                                       out during output translationERR_NUM   DS   14                       Array of internal (non-fatal) errorsX1       DS    1                        Temporary 8-bit Y registerY1       DS    1                        Temporary 8-bit X registerCHAR     DS    1                        Read variables: single character bufferLINE     DS    255                      Input line bufferLINE_TYPE DS   1                        Source line typeLABEL    DS    14                       Assembler source line fieldsOPCODE   DS    14OPERAND  DS    65COMMENT  DS    1DELIM    DS    1                        Character used for string delimiterSTRING   DC    I1'7'                    String used to convert global Merlin         DC    C'SYS'                   label to ORCA labelINDEX    DC    C'0000'L_STRING DC    I1'8'                    String used to convert local Merlin         DC    C'L'                     label to ORCA labelL_INDEX  DC    C'0000'                  Index of location in label tableGBL_CNT  DC    C'000'                   Global label counterV_STRING DC    I1'8'                    String used to convert Merlin variables         DC    C'V'                     to ORCA labelsV_INDEX  DC    C'0000'                  Index of location in label tableVAR_CNT  DC    C'000'                   Variable counterOUTPUT      DS 256                      Output lineOPCODE_COL  DS 1                        Column in output line to begin opcodeOPRND_COL   DS 1                        Column in output line to begin operandCMMNT_COL   DS 1                        Column in output line to begin comment;;                                       Directives translation flags.;ORG_FLG  DS    1KEEP_FLG DS    1XC_FLG   DS    1NEXT     DC    I1'0'                    Index into SEQ_SYM arraySEQ_SYM  DC    8I1'0'                   Array used for cond. assembly directivesDO_CNT   DC    I1'0'                    Counters for the number of DOs, ELSEs,ELSE_CNT DC    I1'0'                    and FINsFIN_CNT  DC    I1'0';;                                       DCBs;OP_DCB   DC    I1'3'                    Open file DCBPATH_PTR DC    I2'NAME'BUFF     DS    2REF_NUM  DS    1NAME     DS    65                       File name bufferRD_DCB   DC    I1'4'                    Read file DCBRD_REF   DS    1RD_BUFF  DC    I2'CHAR'RD_COUNT DC    I2'1'TRANS    DS    2CR_DCB   DC    I1'7'                    Create file DCB         DC    A'MAC_NAME'         DC    H'C3'         DC    H'04'         DC    H'01 00'         DC    H'01'TIME     DS    4MAC_NAME  DW   'MY.MACROS'WR_DCB   DC    I1'4'WR_REF   DS    1WR_BUF   DC    A'OUTPUT+1'WR_CNT   DS    2WR_RTN   DS    2OPN_DCB  DC    I1'3'                    Open macro file DCB         DC    A'MAC_NAME'M_BUFF   DS    2M_REF    DS    1         END******************************************************************  EXIT - Emergency exit from program when fatal error is found**  Inputs:*        STACK - return address of MONITOR**  Outputs:*        - None -******************************************************************EXIT     START         USING COMMON         JSR   TERMINATE         LDX   STACK         TXS         RTS         END******************************************************************  GET_CHAR - Reads next byte from input file or standard input**  Inputs:*        FILE_FLAG - set if input is from a file**  Outputs:*        CHAR      - contains next character read*        EOF_FLAG  - set to true if EOF encountered******************************************************************GET_CHAR START         USING COMMONEOF      EQU   $4CTAB      EQU   $09         LDA   FILE_FLAG                Check if input from file or std_input         BNE   FILERDG0       JSR   GETC                     Read from standard input         AND   #$7F         BEQ   END                      Check EOF         CMP   #RETURN                  Check special control chars         BEQ   RTS         CMP   #TAB         BEQ   G1         CMP   #$20         BLT   G0                       Other control chars just skip         BGE   RTSG1       LDA   #BLANK                   Replace tab with blankRTS      STA   CHAR;        JSR   PUTC                     uncomment for echoing from keyboard         RTSFILERD   RELEASE  #CHAR,#1              "Release" memory to be read into         READ  RD_DCB                   Input is from file         BCS   CHECK                    Check for error         RESERVE  #CHAR,#1              "Reserve" memory for program         LDA   CHAR                     Check special control chars         AND   #$7F         CMP   #RETURN         BEQ   FRTS         CMP   #TAB         BEQ   G1         CMP   #$20                     Check other control chars - just skip         BLT   FILERDFRTS     STA   CHAR         RTSCHECK    CMP   #EOF                     See if this is end of file error         BNE   ERREND      INC   EOF_FLAG         RTSERR      JSR   SYSPERR         JMP   EXITGETC     JMP   ($38)PUTC     JMP   ($36)         END******************************************************************  INIT - Program initialization.**  NOTES:  Determines whether input source is from a file or*          standard input.  Opens input file, sets program flags.*          Allocates memory for label table.**  Inputs:*        $2-$3 - address of command line**  Outputs:*        CMD_LINE  - pointer to command line*        FILE_FLAG - set to true if input from file*        EOF_FLAG  - set to false*        ORG_FLG   - set to false*        KEEP_FLG  - set to false*        XC_FLG    - set to false*        MAC_FLG   - set to false*        NAME      - name of input file given on command line*        BUFF      - pointer to input file's I/O work area*        REF_NUM   - input file's reference number, assigned by*                    ProDOS*        RD_REF    - input file's reference number*        LENGTH    - size of label table allocated by memory manager*        LTHANDLE  - pointer to label table******************************************************************INIT     START         USING COMMON         LONGA OFF         LONGI OFFINCREMENT EQU  256PROTIME   EQU  $BF90         RELEASE  #INFO_DCB,#18         check if MY.MACROS exists         GET_INFO INFO_DCB         PHP         PHA         RESERVE  #INFO_DCB,#18         PLA         PLP         BCC      OPEN         CMP   #$46                     Check if error is "file not found"         JNE   ERR         GET_TIME                       Create the macro file MY.MACROS         MOVE     PROTIME,TIME,#4         CREATE   CR_DCB         JCS      ERROPEN     FINDBUFF M_BUFF,#1024         JCC      ERR         OPEN     OPN_DCB         JCS      ERR         LDA      M_REF         STA      WR_REF         STA      EF_REF         LDA      #0         STA      EF_MRK                 Set EOF to beginning of file         STA      EF_MRK+1         SET_EOF  EF_DCB         JCS      ERR         LM    FILE_FLAG,#0             Clear flags         STA   EOF_FLAG         STA   ORG_FLG         STA   KEEP_FLG         STA   XC_FLG         STA   MAC_FLG         STA   NO_PRNT;;   Extract file name, if present, from command line.;         LDY   #0I1       LDA   (CMD_LINE),Y             Skip white-space         CMP   #RETURN                  Check if no file name given         BEQ   I7AI2       CMP   #BLANK         BNE   I3         INY         JMP   I1;;   Get file name and open input file.;I3       LDX   #0I4       INX         STA   NAME,X         INY         LDA   (CMD_LINE),Y         CMP   #RETURN         BEQ   I5         CMP   #BLANK         BEQ   I5         JMP   I4I5       STX   NAME                     First byte of name is its length         FINDBUFF  BUFF,#1024           Find I/O buffer for open file         JCC   ERRI6       OPEN  OP_DCB                   Open the file given on command line         JCS   ERRI7       LDA   REF_NUM                  Store file # returned by operating         STA   RD_REF                   system to read DCB         INC   FILE_FLAG                Set file-as-input flag to true;;   Reserve memory for label table.;I7A      LDA   #0                       Initialize total length of table to 0         STA   LENGTH         STA   LENGTH+1         STA   LENGTH+2         STA   LENGTH+3I8       ADD4  LENGTH,#INCREMENT        Loop to find largest buffer possible         FINDBUFF  LTHANDLE,LENGTH         BCC   FOUND         JMP   I8FOUND    SUB4  LENGTH,#INCREMENT         FINDBUFF  LTHANDLE,LENGTH         JCC   ERRI9       RESERVE   LTHANDLE,LENGTH      Reserve buffer for program use         LDA   LTHANDLE                 Initialize 1st byte of label table to 0         STA   TABLE         LDA   LTHANDLE+1         STA   TABLE+1         LDA   #0         LDY   #0         STA   (TABLE),Y         RTSERR      JSR   SYSPERR         JMP   EXITINFO_DCB DC    I1'10'         DC    A'MAC_NAME'         DS    15EF_DCB   DC    I1'2'EF_REF   DS    1EF_MRK   DS    3         END