******************************************************************  HEX - Skips over Merlin operand which is a hexadecimal number,*        counting size of number as it goes.**  Inputs:*        X1       - current pointer into OPERAND field*        OPERAND  - entire operand field extracted from input line*        SIZE     - current size of OPERAND*        OPR_SIZE - size of hex number upon entry to HEX**  Outputs:*        OPR_SIZE - final size of hex number*        SIZE     - size of OPERAND after scanning hex number*        X1       - index into OPERAND 1 byte beyond hex number******************************************************************HEX      START         USING COMMON         LONGA OFF         LONGI OFF         LDX   X1TOP      LDA   OPERAND,X                Get next OPERAND character; check if hex         JSR   SHIFT         CMP   #'0'         BLT   RTS         CMP   #'9'         BLE   OKAY         CMP   #'A'         BLT   RTS         CMP   #'F'+1         BGE   RTSOKAY     INX         INC   OPR_SIZE         DBNE  SIZE,TOPRTS      CLC         STX   X1         RTS         END******************************************************************  HEX_DR - Translates Merlin directive HEX into ORCA directive*           DC  H  (define hex constant).**  Notes:  The opcode field of the translated line will contain*          DC (define constant) & the operand field will have*          H'hex string'  where hex string  is a string of hex*          digits with commas translated as blanks.*  Inputs:*        OPERAND  - entire operand field extracted from input line*        OPRND_COL - column in output to begin operand field**  Outputs:*        OUTPUT - formatted output line, represented as a*                 Pascal-type string.*        OPRND_COL - updated during expression evaluation as the*                    translated operand field is built******************************************************************HEX_DR   START         USING COMMON         LONGA OFF         LONGI OFFOPSIZ    EQU   2COUNT    EQU   R8         LM    R0,#OPSIZ                move 'DC' to opcode of output line         LA    R1,TRANS         JSR   MOV_DIR         LM    COUNT,OPERAND            record size of OPERAND         BNE   D1         RTSD1       LDY   OPRND_COL                initialize output column for operands         LDA   #"H"                     put H' at beginning of operand field         STA   OUTPUT,Y         INY         LDA   #"'"         STA   OUTPUT,Y         LDX   #1                       loop to compress operands into 1 stringTOP      LDA   OPERAND,X         CMP   #','         BNE   D2                       skip commas in OPERAND         LDA   #BLANKD2       INY         STA   OUTPUT,Y                 move hex data to output         INX         DBNE  COUNT,TOP         INY                            put ending  '         LDA   #"'"         STA   OUTPUT,Y         STY   OUTPUT         RTSTRANS    DC    C'DC'         END******************************************************************  INC_ASC - Increments ASCII number**  Inputs:*        R0 - size of string to increment*        R1 - address of string to increment**  Outputs:*        String pointed to by R0 is incremented******************************************************************INC_ASC  START         USING COMMON         LONGA OFF         LONGI OFF         LDY   R0         DEYTOP      LDA   (R1),Y         STA   TEMP         INC   TEMP         LDA   TEMP         CMP   #'9'+1         BLT   OUT         LDA   #'0'         STA   (R1),Y         DBPL  Y,TOPOUT      STA   (R1),Y         RTSTEMP     DS    1         END******************************************************************  INSTR_OPRND - Operand evaluator.**  Inputs:*        OPERAND   - entire operand field extracted from input line*        C flag    - set if pointer to operand changes*        SV_OP_PTR - pointer into OPERAND; saved if pointer changes*        SV_OP_SIZ - size of current operator; saved if pointer changes**  Outputs:*        OPR_PTR   - pointer into OPERAND of next operand or operator*        OPR_SIZE  - size of next operand or operator found in*                    OPERAND*        OUTPUT    - translate output line*        CMMNT_COL - column in OUTPUT where comment field is to*                    begin******************************************************************INSTR_OPRND  START         USING COMMON         LONGA OFF         LONGI OFF;;   Initialization.;         LM    SIZE,OPERAND         BNE   BEGIN                    Check zero length operand field         RTSBEGIN    LM    OP_COUNT,#0         STA   OPR_SIZE         LA    OPR_PTR,OPERAND+1         LDY   OPRND_COL         LDX   #1;;   Get start characters, if any.;         LDA   OPERAND,X         CMP   #'#'         BEQ   I0         CMP   #'('         BEQ   I2         DEY         JMP   I3I0       STA   OUTPUT,Y                 Write immediate addressing sign         DBNE  SIZE,I1         STY   OUTPUT         RTSI1       INC2  OPR_PTR                  Update operand/operator pointer         INX         LDA   OPERAND,X                Check for low & high byte forcing syms         CMP   #'<'         BEQ   I2         CMP   #'>'         BEQ   I2         CMP   #'/'         BNE   I3         LDA   #'>'I2       INC2  OPR_PTR         INX         INY         STA   OUTPUT,Y                 Write start characters to output line         DBNE  SIZE,I3         STY   OUTPUT         RTSI3       LDA   ABS_FLAG                 Check for forced absolute addressing         BEQ   I4         LDA   #'!'         INY         STA   OUTPUT,Y;;   Perform first scan of operand field, to count number of operators.;I4       STY   OUTPUT                   Save variables for 2nd scan         STX   X1         STX   SAVE_X         LM    SAVE_SIZE,SIZE         MOVE  OPR_PTR,SAVE_PTR,#2I5       JSR   EVAL_OPRND               Get next operand         LDA   SIZE                     Check end of OPERAND field         BEQ   I6         BCC   I5A         MOVE  SV_OP_PTR,OPR_PTR,#2         LM    OPR_SIZE,SV_OP_SIZI5A      ADD2  OPR_PTR,OPR_SIZE         Update operand/operator pointer         JSR   GET_OPERATOR             Get next operator         LDA   SIZE         BEQ   I6         BCC   I6A         MOVE  SV_OP_PTR,OPR_PTR,#2         LM    OPR_SIZE,SV_OP_SIZI6A      ADD2  OPR_PTR,OPR_SIZE         JMP   I5I6       MOVE  OP_COUNT,SV_OP_CNT,#2         DEC   OP_COUNT                 Check if need to write any '(' to output         BMI   I8         BEQ   I8         LDY   OUTPUT                   Write '+' at beginning of expression         LDA   #'+'         INY         STA   OUTPUT,Y         LDA   #'('                     Write 1 '(' for each operator, minus 1I7       INY         STA   OUTPUT,Y         DBNE  OP_COUNT,I7         STY   OUTPUT;;   Write first operand.;I8       LM    X1,SAVE_X                Reinitialize subroutine variables         LM    SIZE,SAVE_SIZE           for second scan of OPERAND         MOVE  SAVE_PTR,OPR_PTR,#2         LM    OP_COUNT,#0         JSR   EVAL_OPRND               Get first operand         JSR   PUT_BUFFER         LDA   SIZE         JEQ   END         BCC   I9         MOVE  SV_OP_PTR,OPR_PTR,#2         LM    OPR_SIZE,SV_OP_SIZ;;   Write   operator, operand, ')'   until end of operand field.;I9       ADD2  OPR_PTR,OPR_SIZE         JSR   GET_OPERATOR         JSR   PUT_BUFFER         LDA   SIZE         JEQ   END         BCC   I9A         MOVE  SV_OP_PTR,OPR_PTR,#2         LM    OPR_SIZE,SV_OP_SIZI9A      ADD2  OPR_PTR,OPR_SIZE         JSR   EVAL_OPRND         JSR   PUT_BUFFER         LDA   SIZE         JEQ   END         BCC   I9B         MOVE  SV_OP_PTR,OPR_PTR,#2         LM    OPR_SIZE,SV_OP_SIZI9B      LDA   SV_OP_CNT                check if op_count > 0         CMP   #1         BLE   I9         LDY   OUTPUT         LDA   #')'         INY         STA   OUTPUT,Y         STY   OUTPUT         JMP   I9;;   Update size of output line; check if need to update cmmnt_column in output.;END      LDY   OUTPUT         INY         INY         CPY   CMMNT_COL         BLT   RTS         STY   CMMNT_COLRTS      RTSSAVE_X    DS    1SAVE_SIZE DS    1SAVE_PTR  DS    2SV_OP_CNT DS    2         END******************************************************************  IS_OK - Checks if character stored in accumulator is a valid*          ORCA label character.**  Inputs:*        A - character to be checked**  Outputs:*        C flag - clear if character is valid for ORCA label;*                 set if character is non-ORCA label character******************************************************************IS_OK    START         LONGA OFF         LONGI OFF         CMP   #'_'         BEQ   OK         CMP   #'~'         BEQ   OK         CMP   #'A'         BLT   NOT_OK         CMP   #'Z'         BLE   OK         CMP   #'a'         BLT   NOT_OK         CMP   #'z'         BGT   NOT_OKOK       CLC         RTSNOT_OK   SEC         RTS         END         APPEND  MERLIN.L