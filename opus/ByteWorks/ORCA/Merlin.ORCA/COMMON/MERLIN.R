******************************************************************  REJECT - Handles Merlin directives which are rejected by*           translator.**  Outputs:*        NO_PRNT - set to show input line should just be*                  commented out and then echoed to output*        ERR_NUM - byte number ERR of array is set for CANNOT-*                  HANDLE-THIS-DIRECTIVE error******************************************************************REJECT   START         USING COMMON         LONGA OFF         LONGI OFFERR      EQU   12         INC   NO_PRNT         LDX   #ERR         INC   ERR_NUM,X         RTS         END******************************************************************  SAV - Translates the Merlin directive SAV to the ORCA directive*        KEEP.**  NOTES:   ORCA allows only one KEEP in a program, and it*           must be declared before the first START of the program.**  Inputs:*        KEEP_FLG - flag showing if the Merlin directives SAV or*                   DSK have been used*        OPERAND  - Pascal-type string containing entire operand*                   field extracted from input line**  Outputs:*        KEEP_FLG - set if previously unset*        ERR_NUM [ERR] - set if SAV or DSK has already been used******************************************************************SAV      START         USING COMMON         LONGA OFF         LONGI OFFOPSIZ    EQU   4ERR      EQU   13         LDA   KEEP_FLG                 Check if have already used SAV or DSK         BEQ   S1         LDX   #ERR         INC   ERR_NUM,X         INC   NO_PRNTRTS      RTSS1       INC   KEEP_FLG                 Set flag showing have now used SAV/DSK           LM    R0,#OPSIZ                Move 'KEEP' to output line         LA    R1,TRANS         JSR   MOV_DIR         LM    R0,OPERAND               Move operand (a pathname) to output         BEQ   RTS         LA    R1,OPERAND+1         JMP   MOV_OPRTRANS    DC    C'KEEP'         END******************************************************************  SHIFT - Converts character in accumulator to uppercase**  Inputs:*        A - character to be converted**  Outputs:*        A - shifted character******************************************************************SHIFT    START         LONGA OFF         LONGI OFF         CMP   #'a'                     Shift to uppercase if needed         BLT   RTS         CMP   #'z'+1         BGE   RTS         ADC   #'A'-'a'RTS      RTS         END******************************************************************  SKIP_BLANKS - Loops over blanks in the input line**  Inputs:*        LINE - Merlin input source line*        X1   - current index into line**  Outputs:*        X1      - index into line after skipping blanks*        EOL     - set to true if end-of-line found*        COMMENT - column in input where ; found marking*                  beginning of comment field******************************************************************SKIP_BLANKS  START         USING COMMON         LONGA OFF         LONGI OFF         LDX   X1TOP      LDA   LINE,X         CMP   #RETURN                  Check end-of-line         BEQ   REOL2         CMP   #';'                     Check beginning of comment column         BEQ   REOL         CMP   #BLANK                   Check if found next field         BNE   RTS         INX         BNE   TOPRTS      STX   X1         RTSREOL     INX         STX   COMMENTREOL2    INC   EOL         RTS         END******************************************************************  SKP - Translates Merlin directive SKP into operand blank lines.**  NOTES:  The operand must be a decimal value.**  Inputs:*        OPERAND - Pascal-type string containing entire operand*                  field extracted from input line.**  Outputs:*        NO_PRNT - set if operand is not a simple decimal value*        ERR_NUM - byte number ERR of array is set if the*                  operand is not a simple decimal value******************************************************************SKP      START         USING COMMON         LONGA OFF         LONGI OFFERR      EQU   0         LDA   OPERAND+1         CMP   #'$'         BEQ   ERROR         CMP   #'%'         BEQ   ERROR         CMP   #'0'         BLT   ERROR         CMP   #'9'         BLE   OKERROR    INC   NO_PRNT                  Set don't print output line         LDX   #ERR         INC   ERR_NUM,X         RTSOK       CNVS2 OPERAND-1,VALUE          Convert number string to 2-byte integer         LDA   #RETURN                  Save 1 carriage return for output line         STA   OUTPUT+1                 for print routine         LDA   #1         STA   OUTPUT         DEC   VALUETOP      PUTCR         DBNE  VALUE,TOP         RTSVALUE    DS    2         END******************************************************************  SRCH - Conducts linear search of table whose address is*         stored in TABLE; looks for KEY.**  Inputs:*        KEY      - address of value to search for*        TABLE    - address of table to search*        KEY_SIZE - length of key**  Outputs:*        OP_NUM - index of key in table*        C flag - set if key not found******************************************************************SRCH     START         USING COMMON         LONGA OFF         LONGI OFF         LM    OP_NUM,#0                Initialize index into table         STA   OP_NUM+1TOP1     LDY   KEY_SIZETOP2     DEY         BMI   FOUND                    Key has been found         LDA   (TABLE),Y         BEQ   NOT_FOUND                Table has sentinel of 0         CMP   (KEY),Y         BEQ   TOP2                     Character match -- check next char         INC2  OP_NUM         ADD2  TABLE,KEY_SIZE           No match -- get next array item         BNE   TOP1                     by incrementing table pointer by sizeNOT_FOUND SEC         RTSFOUND    CLC         RTS         END******************************************************************  STR_DRCT - Generic subroutine for handling Merlin string*             directives:  ASC, DCI, INV, FLS, REV, and STR.**  NOTES:  The directives invoke macros contained in the file*          MERLIN.MACROS.  If the most-significant bit of the*          string should be set, an 'H' is appended to the name*          of the directive (e.g.  ASCH ).**  Inputs:*        MSB_FLG - set if string delimiter was "*        OUTPUT[0] - current length of output line*        OPRND_COL - column in output line where operand begins*        OPERAND   - Pascal-type string containing entire operand*                    extracted from input line**  Outputs:*        MSB_FLG - reset to false if was true upon entry to subrtn*        OUTPUT  - translated output line******************************************************************STR_DRCT START         USING COMMON         LONGA OFF         LONGI OFF         JSR   MOV_OPCODE               Move opcode, which will be translated to;                                       a macro call, to output line         LDA   MSB_FLG                  Check if most-significant bit should be          BEQ   S0                       set         DEC   MSB_FLG         LDX   OUTPUT                   Get column in output line to place 'H'         INX         LDA   #'H'         STA   OUTPUT,X         INC   OUTPUT                   Update size of output lineS0       LM    OPR_SIZE,OPERAND         Move operand to output         LDA   OPRND_COL         STA   OUTPUT         LA    OPR_PTR,OPERAND+1         JMP   PUT_BUFFER         END******************************************************************  TR - Translates Merlin directive TR to ORCA directive EXPAND**  Inputs:*        OPERAND[0] - length of entire operand extracted from input******************************************************************TR       START         USING COMMON         LONGA OFF         LONGI OFFOPSIZ    EQU   6         LM    R0,#OPSIZ         LA    R1,TRANS                 Move 'EXPAND' to output line         JSR   MOV_DIR         LDA   OPERAND                  Check if operand is blank         BEQ   T1         LDA   OPERAND+2                Check if operand is OFF         JSR   SHIFT         CMP   #'N'         BEQ   T1         LM    R0,#2                    If OFF use ON in translated operand         LA    R1,ON         JMP   MOV_OPRT1       LM    R0,#3                    Move OFF to operand field if blank         LA    R1,OFF                   or was ON         JMP   MOV_OPRTRANS    DC    C'EXPAND'ON       DC    C'ON'OFF      DC    C'OFF'         END******************************************************************  TR_MACRO - Translates a Merlin directive using a special*             ORCA macro.**  Inputs:*        OPERAND   - Pascal-type string containing entire operand*                    extracted from input line*        OPRND_COL - column in output to start operand field******************************************************************TR_MACRO START         USING COMMON         LONGA OFF         LONGI OFF         JSR   MOV_OPCODE               Move the directive to output         LM    R0,OPERAND               Move operand to output         LA    R1,OPERAND+1         JMP   MOV_OPRTR_MACRO2 ENTRY         JSR   MOV_OPCODE               Move directive to output         JMP   INSTR_OPRND              Evaluate directive's operand         END******************************************************************  USE - Translates Merlin directive USE to ORCA directive MCOPY.**  Inputs:*        OPERAND - Pascal-type string containing entire operand*                  field extracted from input line**  Outputs:*        OUTPUT  - Pascal-type string containing translated*                  output line******************************************************************USE      START         USING COMMON         LONGA OFF         LONGI OFFOPSIZ    EQU   5         LM    R0,#OPSIZ                Move 'MCOPY' to output line         LA    R1,TRANS         JSR   MOV_DIR         LM    R0,OPERAND               Move operand (a pathname) to output         BEQ   RTS         LA    R1,OPERAND+1         JMP   MOV_OPRRTS      RTSTRANS    DC    C'MCOPY'         END******************************************************************  VAR - Translates Merlin directive VAR into a series of equates,*        translating each of the implied variables ]1 through ]8*        to ORCA labels.**  Inputs:*        OPERAND    - entire operand extracted from input line,*                     represented in Pascal-type string*        OPCODE_COL - column in output where opcode begins**  Outputs:*        OUTPUT - translated output line, containing equated values*        NO_PRNT - set if NO-OPERAND-GIVEN error detected*        ERR_NUM - byte number ERR of array is set if NO-OPERAND-*                  GIVE error is found******************************************************************VAR      START         USING COMMON         LONGA OFF         LONGI OFFVAR_SIZE EQU   2ERR      EQU   1         LDX   OPERAND         BNE   I0         INC   NO_PRNT                  Handle no operand given error         LDX   #ERR         INC   ERR_NUM,X         RTSI0       STX   COUNT         LDY   #0                       Move OPERAND to local areaI1       LDA   OPERAND+1,Y         STA   VALUES,Y         INY         DBNE  X,I1         LA    R6,VAR_TBL               Initialize pointers and counter         LA    R8,VALUES         LM    COUNT,OPERANDTOP      LDX   #255                     Clear output line         LDA   #BLANKV0       STA   OUTPUT,X         DBNE  X,V0V1       MOVE  R6,KEY,#2                Translate next Merlin variable in table         LM    KEY_SIZE,#VAR_SIZE         LM    NEW_VAR,#1               Set flag for redefining variable         JSR   TRANS_LABEL         LDY   #0                       Move translated label to output         LDA   (R0),Y         TAX         INC2  R0V2       LDA   (R0),Y         INY         STA   OUTPUT,Y         DBNE  X,V2         LDX   #0                       Move 'EQU' to output         LDY   OPCODE_COLV3       LDA   TRANS,X         STA   OUTPUT,Y         INY         INX         CPX   #3         BLT   V3         STY   OUTPUT         LDY   #0V4       LDA   (R8),Y                   Get size of next operand         CMP   #';'         BEQ   V5         INY         DBNE  COUNT,V4V5       STY   OPERAND                  Set size of current operand         LDY   #0         LDX   OPERANDV5A      LDA   (R8),Y                   Move current variable value to OPERAND         INY         STA   OPERAND,Y         DBNE  X,V5A         INY                            Update pointer into values         STY   TEMP         ADD2  R8,TEMP         JSR   INSTR_OPRND              Evaluate current operand         DEC   COUNT                    If not the last variable, print output         JEQ   OUT         JMI   OUT         LDA   MSB_FLG                  Check if string in operand set MSB flag         BEQ   V6         PUTS  #'         MSB   ON',CR=TV6       PUTS  OUTPUT-1,CR=T         LDA   MSB_FLG         BEQ   V7         PUTS  #'         MSB   OFF',CR=T         LM    MSB_FLG,#0V7       INC2  R6                      Get next variable to be translated         INC2  R6         LDY   #0         LDA   (R6),Y                  Check if too many operands given         BEQ   OUT         JMP   TOPOUT      RTSVALUES   DS    66COUNT    DS    1TEMP     DS    2VAR_TBL  DC    C']1'         DC    C']2'         DC    C']3'         DC    C']4'         DC    C']5'         DC    C']6'         DC    C']7'         DC    C']8'         DC    I1'0'TRANS    DC    C'EQU'         END******************************************************************  XC - Translates Merlin directive XC to ORCA directives 65C02*       and 65816.**  NOTES:  The first time XC is encountered, it is translated to*          65C02 ON.  The next time it is encountered, it is*          translated to 65816 ON.**  Inputs:*        XC_FLG - if already set, XC has been previously used in*                 source file**  Outputs:*        XC_FLG - if hasn't been set, is now set******************************************************************XC       START         USING COMMON         LONGA OFF         LONGI OFFOPSIZ    EQU   5         LM    R0,#OPSIZ                Load size of directives into R0         LDA   XC_FLG                   Check if used already         BNE   X1         INC   XC_FLG         LA    R1,FIRST                 Move '65C02' to output line         JMP   X2X1       LA    R1,SECOND                Move '65816' to output lineX2       JSR   MOV_DIR         LM    R0,#2                    Move 'ON' to output line         LA    R1,ON         JMP   MOV_OPRFIRST    DC    C'65C02'SECOND   DC    C'65816'ON       DC    C'ON'         END