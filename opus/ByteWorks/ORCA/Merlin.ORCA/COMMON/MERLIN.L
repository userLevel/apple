******************************************************************  LST - Translates Merlin directive LST to ORCA directive LIST.**  Inputs:*        OPERAND[0] - size of operand field; if zero, then ON*                     is moved to the output operand field******************************************************************LST      START         USING COMMON         LONGA OFF         LONGI OFFOPSIZ    EQU   4ON_SZ    EQU   2         LM    R0,#OPSIZ         LA    R1,TRANS                 Move 'LIST' to output line         JSR   MOV_DIR         LDA   OPERAND                  Check if blank operand-make it ON         BNE   RTS         LM    R0,#ON_SZ         LA    R1,ON         JMP   MOV_OPRRTS      JMP   INSTR_OPRNDTRANS    DC    C'LIST'ON       DC    C'ON'         END******************************************************************  LSTDO - Translates Merlin directive LSTDO to ORCA directive TRACE.**  Inputs:*        OPERAND[0] - size of operand field; if zero, then ON*                     is moved to the output operand field******************************************************************LSTDO    START         USING COMMON         LONGA OFF         LONGI OFFOPSIZ    EQU   5ON_SZ    EQU   2         LM    R0,#OPSIZ                Move 'TRACE' to output line         LA    R1,TRANS         JSR   MOV_DIR         LDA   OPERAND                  Check if blank operand-make it ON         BNE   RTS         LM    R0,#ON_SZ         LA    R1,ON         JMP   MOV_OPRRTS      JMP   INSTR_OPRNDTRANS    DC    C'TRACE'ON       DC    C'ON'         END******************************************************************  LUP - Translates Merlin directive LUP to ORCA SETA directive.**  NOTES:  LUP initializes the predefined symbolic parameter*          & LUP to the expression given in the input operand.*          This line is printed and then followed by a line*          giving a sequence symbol (.LUP) to branch to.*          If a label was present in the input, then the label,*          with an operand of 'ANOP,' is printed before the*          output line is loaded with the symbolic parameter.**  Inputs:*        OUTPUT[0] - current size of output line**  Outputs:*        OUTPUT - translated output line, represented as a*                 Pascal-type string******************************************************************LUP      START         USING COMMON         LONGA OFF         LONGI OFFOPSIZ1   EQU   4OPSIZ2   EQU   12         LDA   OUTPUT                   1st check if label given on input line         BEQ   CONT         LM    R0,#OPSIZ1               Move 'ANOP' to output if label present         LA    R1,TRANS1         JSR   MOV_DIR         PUTS  OUTPUT-1,CR=T            Write output lineCONT     LDY   #OPSIZ2                  Move '& LUP     SETA' to output line         LDX   #1         LDA   #'&'         STA   OUTPUT+1L0       LDA   TRANS2,X         INX         STA   OUTPUT,X         DBNE  Y,L0         DEX         STX   OUTPUT         JSR   INSTR_OPRND              Evaluate operand expression         PUTS  OUTPUT-1,CR=T            Write output line         LDX   #255                     Clear output line         LDA   #BLANKL1       STA   OUTPUT,X         DBNE  X,L1         LDY   #OPSIZ1                  Move '.LUP' to output line         LDX   #0L2       LDA   LAB,X         INX         STA   OUTPUT,X         DBNE  Y,L2         STX   OUTPUT         RTSTRANS1   DC    C'ANOP'TRANS2   DC    C' LUP     SETA'LAB      DC    C'.LUP'         END******************************************************************  LUP_END - Translates Merlin directive --^ (end loop) to ORCA*            directives SETA followed by branch with AIF.**  NOTES:  The symbolic parameter initialized by the LUP directive*          is decremented.  If it is positive (as tested with the*          ORCA AIF directive), then the program branches to the*          the sequence symbol defined in the LUP directive.**          If a label was present on the input line, it is written*          to the output line last, with an operand of 'ANOP.'**  Inputs:*        OUTPUT[0] - current size of output line******************************************************************LUP_END  START         USING COMMON         LONGA OFF         LONGI OFFOPSIZ    EQU   4         LDA   #'&'                     Cannot store '&' directly         STA   LINE1+1         STA   LINE1+16         STA   LINE2+16         PUTS  LINE1-1,CR=T         LDA   OUTPUT                   Check if label given on input line         BEQ   CONT         LM    R0,#OPSIZ                Move 'ANOP' to output if label present         LA    R1,TRANS         JSR   MOV_DIRCONT     PUTS  LINE2-1,CR=T         RTSLINE1    DW    ' LUP     SETA   LUP-1'LINE2    DW    '         AIF    LUP,^LUP'TRANS    DC    C'ANOP'         END******************************************************************  MAC - Translates Merlin directive which defines a new macro.**  Notes:  Writes the line    MACRO       to the macro file and*          builds the line*                             macro_name  & A,& B,& C,& D,& E,& F,& G,& H**          for the macro file MY.MACROS**  Inputs:*        MAC_FLG - set if already within macro.*        LABEL - label extracted from input line**  Outputs:*        MAC_FLG - incremented to show subsequent lines of source*                  are part of a macro definition. If already*                  within a macro, the current macro is ended &*                  a new one begun.*        LABEL - written in opcode field of new macro*        OUTPUT - output line is built; it will be written to*                 the output file later******************************************************************MAC      START         USING COMMON         LONGA OFF         LONGI OFFLAB_SIZE EQU   3TRSIZE   EQU   4         LDA   MAC_FLG                  Check if already within macro         BEQ   M0         JSR   CLR         JSR   EOM                      End current macro         JSR   WR_MACRO         JSR   CLR         JMP   M1M0       INC   MAC_FLG                  Set within_macro flagM1       JSR   CLR                      Write 'MACRO' to macro file         LM    R0,#L:MACRO         LA    R1,MACRO         JSR   MOV_DIR         JSR   WR_MACRO         JSR   MOVLAB                   Move & LAB to label of macro model line         LM    R0,LABEL                 Move macro's name to opcode field         LA    R1,LABEL+1               of macro model line         JSR   MOV_DIR         LDX   #0                       Move parameters to output line         LDY   OUTPUT         INY         INYTOP      LDA   #'&'         STA   OUTPUT,Y         LDA   PARMS,X         INY         STA   OUTPUT,Y         CPX   #7         BEQ   OUT         INY         LDA   #','         STA   OUTPUT,Y         INY         INX         BNE   TOPOUT      STY   OUTPUT         JSR   WR_MACRO                 Write macro model line         JSR   MOVLAB                   Move & LAB to beginning of next macro ln         LM    R0,#TRSIZE               Move ANOP opcode field of next macro ln         LA    R1,TRANS         JMP   MOV_DIRCLR      LDX   #255                     Clear output line         LDA   #BLANKC1       STA   OUTPUT,X         DBNE  X,C1         STX   OUTPUT         RTSMOVLAB   JSR   CLR                      Move & LAB to label field of macro         LDA   #'&'                     model line         STA   OUTPUT+1         LDX   #LAB_SIZE         LDY   #0M2       LDA   LAB,Y         INY         STA   OUTPUT+1,Y         DBNE  X,M2         RTSLAB      DC    C'LAB'MACRO    DC    C'MACRO'PARMS    DC    C'ABCDEFGH'TRANS    DC    C'ANOP'         END******************************************************************  MOV_DIR - Moves translated directive to output line**  Inputs:*        R0         - size of directive*        R1         - address of directive*        OPCODE_COL - column in output line to begin opcode**  Outputs:*        OUTPUT     - output line*        OUTPUT[0]  - size of output line*        OPRND_COL  - updated if opcode would run into it in the*                     output line******************************************************************MOV_DIR  START         USING COMMON         LONGA OFF         LONGI OFF         LDX   OPCODE_COL               Move directive to output         LDY   #0TOP      LDA   (R1),Y         STA   OUTPUT,X         INY         INX         DBNE  R0,TOP         STX   OUTPUT                   Update size of output line         DEC   OUTPUT                   Check if need to change operand column         INX         CPX   OPRND_COL         BLE   RTS         STX   OPRND_COLRTS      RTS         END******************************************************************  MOV_OPCODE - Moves opcode to output line.**  Inputs:*        OPCODE[0]  - size of opcode*        OPCODE     - string containing opcode*        OPCODE_COL - column in output line to begin opcode**  Outputs:*        OUTPUT    - output line*        OUTPUT[0] - size of output line*        OPRND_COL - column in output where operand begins;*                    updated if necessary******************************************************************MOV_OPCODE  START         USING COMMON         LONGA OFF         LONGI OFF         LDX   OPCODE_COL               Move directive to output         LDA   OPCODE                   Size of opcode         STA   COUNT         LDY   #1TOP      LDA   OPCODE,Y         STA   OUTPUT,X         INY         INX         DBNE  COUNT,TOP         STX   OUTPUT                   Update size of output line         DEC   OUTPUT                   Check if need to change operand column         INX         CPX   OPRND_COL         BLE   RTS         STX   OPRND_COLRTS      RTSCOUNT    DS    1         END******************************************************************  MOV_OPR - Moves new operand for ORCA directive into output line**  Inputs:*        R0        - size of operand*        R1        - address of operand*        OPRND_COL - column in output where operand field begins**  Outputs:*        OUTPUT    - output line*        OUTPUT[0] - size of output line******************************************************************MOV_OPR  START         USING COMMON         LONGA OFF         LONGI OFF         LDY   #0         LDX   OPRND_COLTOP      LDA   (R1),Y         STA   OUTPUT,X         INY         INX         DBNE  R0,TOP         DEX         STX   OUTPUT         RTS         END         APPEND  MERLIN.O