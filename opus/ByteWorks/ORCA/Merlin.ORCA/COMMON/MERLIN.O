******************************************************************  OPR_LABEL - Scans Merlin operand which is a label, counting*              its size.**  NOTES:  Checks if the label is not standard ORCA, and calls*          conversion routine if necessary.**  Inputs:*        OPERAND  - entire operand field extracted from input line*        X1       - current pointer into OPERAND field*        SIZE     - current size of OPERAND field*        STRING   - ASCII string consisting of 'SYS'+ 5-digit value,*                   substituted for non-ORCA label*        OPR_SIZE - size of label upon entry to OPR_LABEL**  Outputs:*        OPR_SIZE  - final size of label*        OPR_PTR   - pointer to label*        C flag    - set if pointer to operand changes*        SV_OP_PTR - pointer into OPERAND; saved if pointer changes*        SV_OP_SIZ - size of current operator; saved if pointer changes*        SIZE      - size of OPERAND, after label has been found*        X1        - index into OPERAND, 1 byte beyond label******************************************************************OPR_LABEL  START         USING COMMON         LONGA OFF         LONGI OFF         DBEQ  SIZE,OUT                 Check end of OPERAND string         LDX   X1         INXTOP      LDA   OPERAND,X                Quit when OPERAND char equals operator;                                       or end of OPERAND field is reached         CMP   #']'         BEQ   OUT         CMP   #')'         BEQ   OUT         CMP   #','         BEQ   OUT         CMP   #'+'         BEQ   OUT         CMP   #'-'         BEQ   OUT         CMP   #'*'         BEQ   OUT         CMP   #'/'         BEQ   OUT         CMP   #'!'         BEQ   OUT         CMP   #'.'         BEQ   OUT         CMP   #'&'         BEQ   OUT         INC   OPR_SIZE         INX         DBNE  SIZE,TOP;;   Check if label is weird.  If weird, convert to ORCA label and store into;   buffer;  else store LABEL into buffer.;OUT      STX   X1                       Save current OPERAND pointer         MOVE  OPR_PTR,KEY,#2         LM    KEY_SIZE,OPR_SIZE         JSR   CHK_LABEL         BCS   NOT_OKAY         RTSNOT_OKAY MOVE  OPR_PTR,KEY,#2           Set address & size for translation         LM    KEY_SIZE,OPR_SIZE         MOVE  OPR_PTR,SV_OP_PTR,#2     Save pointer to OPERAND         LM    SV_OP_SIZ,OPR_SIZE       Save size of current operand         JSR   TRANS_LABEL              Translate to ORCA label         LDY   #0         LDA   (R0),Y                   Set size & pointer to translated label         STA   OPR_SIZE         INC2  R0         MOVE  R0,OPR_PTR,#2         SEC         RTS         END******************************************************************  ORG - Translates Merlin directive ORG.**  NOTES:  The first ORG is handled as an ORCA ORG.  A "reorg,"*          that is, an ORG with no operand, is handled as an*          ORCA OBJEND directive.  Subsequent ORGs which have*          operands are translated to the ORCA directive OBJ.**  Inputs:*        ORG_FLG    - set if ORG was previously found in source file*        OPERAND[0] - size of entire operand field extracted from*                     input line******************************************************************ORG      START         USING COMMON         LONGA OFF         LONGI OFFOPSIZ1   EQU   3OPSIZ2   EQU   6         LDA   ORG_FLG                  Check if have already used ORG         BNE   O1         INC   ORG_FLG         JMP   DO_INSTR                 Handle 1st ORG as regular instructionO1       LDA   OPERAND                  Check if "reorg"         BEQ   O2         LM    R0,#OPSIZ1               Move 'OBJ' to output line         LA    R1,OBJ         JSR   MOV_DIR         JMP   INSTR_OPRNDO2       LM    R0,#OPSIZ2               Move 'OBJEND' to output line         LA    R1,OBJEND         JMP   MOV_DIROBJ      DC    C'OBJ'OBJEND   DC    C'OBJEND'         END******************************************************************  PAG - Translates Merlin directive PAG to ORCA directive EJECT******************************************************************PAG      START         USING COMMON         LONGA OFF         LONGI OFFOPSIZ    EQU   5         LM    R0,#OPSIZ         LA    R1,TRANS                 Move 'EJECT' to output line         JMP   MOV_DIRTRANS    DC    C'EJECT'         END******************************************************************  PMC - Translates Merlin directive PMC, put macro**  Notes:  The opcode field of the translated output line*          contains the macro's name.  The operand field has*          the macro's parameters, surrounded in double quotes*          & separated with commas.**  Inputs:*        OPERAND  - entire operand field extracted from input line*        OPCODE_COL - column in output line where opcode is to*                     begin*        OPRND_COL  - column in output where operand is to begin**  Outputs:*        OUTPUT     - translated output line******************************************************************PMC      START         USING COMMON         LONGA OFF         LONGI OFFCOUNT    EQU   R6SAVEX    EQU   R8         LM    COUNT,OPERAND         LDY   OPCODE_COL               get macro name & move to opcode column         LDX   #1                       in output fieldTOP      LDA   OPERAND,X         CMP   #' '         BEQ   END         CMP   #'.'         BEQ   END         CMP   #'/'         BEQ   END         CMP   #','         BEQ   END         CMP   #'-'         BEQ   END         CMP   #'('         BEQ   END         STA   OUTPUT,Y         INY         INX         DBNE  COUNT,TOP         DEY         STY   OUTPUTRTS1     RTSEND      INX                            skip name separator character         DBEQ  COUNT,RTS1               check end of operand         BMI   RTS1         LDY   OPRND_COL                initialize output column for operands         STY   OUTPUTE2       LDY   OUTPUT                   loop to translate the parameters         LDA   #'"'                     put beginning "         INY         STA   OUTPUT,Y         STY   OUTPUT         INY         STY   OPRND_COL         LDY   #0                       extract next parameterTOP2     LDA   OPERAND,X         CMP   #';'         BEQ   OUT         INY         STA   OPERAND,Y                move it to the front of OPERAND         INX         DBNE  COUNT,TOP2OUT      STX   SAVEX                    send through expression evaluator         STY   OPERAND         JSR   INSTR_OPRND         LDY   OUTPUT                   put ending quotes         INY         LDA   #'"'         STA   OUTPUT,Y         LDX   SAVEX                    increment loop variables         INX         DBEQ  COUNT,RTS                check end of input         BMI   RTS         INY         LDA   #','                     put comma between parameters         STA   OUTPUT,Y         STY   OUTPUT         JMP   E2RTS      STY   OUTPUT         RTS         END******************************************************************  PROC_LINE - Processes input line:  Parses, determines line_type,*              processes opcode & operands, formats output line.**  Inputs:*        MAC_FLG   - true if macro is being defined*        LINE_TYPE - Merlin input source line type, either**                     0 - comment line, blank or starting with **                     1 - comment line, blanks followed by ;*                     2 - line containing 65816 instruction*                     3 - line containing Merlin directive*                     4 - line containing macro call**  Outputs:*        OPCODE_COL - column in output line where opcode is to*                     begin*        OPRND_COL  - column in output where operand is to begin*        CMMNT_COL  - column in output where comment is to begin*        OUTPUT     - translated output line******************************************************************PROC_LINE START         USING COMMON         LONGA OFF         LONGI OFF         LM    OPCODE_COL,#10           Initialize output columns         LM    OPRND_COL,#16         LM    CMMNT_COL,#41         LM    MSB_FLG,#0               Set MSB flag to false         STA   STR_FLG                  Set string flag to false         STA   OUTPUT                   Set output line size to zero         LDY   #255                     Clear output line         LDA   #BLANKP0       STA   OUTPUT,Y         DBNE  Y,P0         JSR   GET_LINE_TYPE         LDA   LINE_TYPE                Check comment (* or blank) line         BNE   P2         LDX   #0P1       LDA   LINE+1,X         CMP   #RETURN         BEQ   P1A         STA   OUTPUT+1,X         INX         BNE   P1P1A      STX   OUTPUT                   Length of output line in 1st byte         RTSP2       CMP   #COMMNT                  Check comment (;) line         BMI   P3                       Check for label         BNE   P4         JMP   DO_COMMENTP3       JSR   DO_LABEL                 Process labelP4       LDA   LINE_TYPE                Process 65816 instruction         CMP   #INSTR         BNE   P5         JSR   DO_INSTR         JMP   ENDP5       CMP   #DIRECTIVE               Process Merlin directive         BNE   P6         JSR   DO_DIRECT         JMP   ENDP6       JSR   DO_MACRO                 Process Merlin macro callEND      LDA   COMMENT                  Check if comment needs to be written         BEQ   RTS         LDY   OUTPUT                   Check if comment_col needs changing         INY         INY         CPY   CMMNT_COL         BLT   P7         STY   CMMNT_COLP7       JMP   PUT_COMMENTRTS      RTS         END******************************************************************  PUT - Translates the Merlin directive PUT into ORCA directive*        COPY.**  Inputs:*        OPERAND - Pascal-type string containing entire operand*                  field extracted from input line******************************************************************PUT      START         USING COMMON         LONGA OFF         LONGI OFFOPSIZ    EQU   4         LM    R0,#OPSIZ         LA    R1,TRANS                 Move 'COPY' to output line         JSR   MOV_DIR         LM    R0,OPERAND               Move operand (a pathname) to output         BEQ   RTS         LA    R1,OPERAND+1         JMP   MOV_OPRRTS      RTSTRANS    DC    C'COPY'         END******************************************************************  PUT_BUFFER - Writes current operand or operator to output line**  Inputs:*        OPR_PTR   - pointer to current operand/operator*        OPR_SIZE  - size of current operand/operator*        OUTPUT[0] - current length of OUTPUT line**  Outputs:*        OUTPUT - translated output line, represented as Pascal-*                 type string******************************************************************PUT_BUFFER  START         USING COMMON         LONGA OFF         LONGI OFFCOUNT    EQU   R10         LDA   OPR_SIZE                 Check empty operand/operator field         BEQ   RTS         STA   COUNT         LDX   OUTPUT                   Loop to move operand/operator to output         LDY   #0TOP      LDA   (OPR_PTR),Y         INX         STA   OUTPUT,X         INY         DBNE  COUNT,TOP         STX   OUTPUT                   Update size of output fieldRTS      RTS         END******************************************************************  PUT_COMMENT - Transfers comment in source line to output line**  Inputs:*        LINE      - input source line*        CMMNT_COL - column in output line where comment begins*        COMMENT   - column in input line where comment begins**  Outputs:*        OUTPUT - translated output line******************************************************************PUT_COMMENT  START         USING COMMON         LONGA OFF         LONGI OFF         LDY   CMMNT_COL         LDX   COMMENTTOP      LDA   LINE,X         CMP   #RETURN         BEQ   RTS         STA   OUTPUT,Y         INX         INY         BNE   TOPRTS      DEY         STY   OUTPUT         RTS         END******************************************************************  PUTLINE - Writes translated line to output device**  Inputs:*        OUTPUT - 255-byte buffer containing translated input*                 line*        ERR_NUM - bytes in this array are set if the corresponding*                  error message is to be printed*        NO_PRNT - set if output line is to be commented out*                  during printing*        MSB_FLG - set if string data in operand used MSB delimiter**  Outputs:*        OUTPUT - 255-byte buffer containing translated input*                 line*        ERR_NUM - the array is cleared after all messages printed*        NO_PRNT - cleared if was set upon entry to PUTLINE******************************************************************PUTLINE  START         USING COMMON         LONGA OFF         LONGI OFFMEND1    EQU   2MEND2    EQU   24MAX      EQU   247COUNT    EQU   R8         LDA   NO_PRNT                  Check if line should be commented out         JNE   ERROR                    instead of being written         LDA   MAC_FLG                  Check if line should be written to macro         BEQ   P00                      file         JSR   WR_MACRO         LDA   OP_NUM                   Check end of macro         CMP   #MEND1         BEQ   RESET         CMP   #MEND2         BNE   RTSRESET    DEC   MAC_FLGRTS      RTSP00      LDA   MSB_FLG                  Check if string data is to have MSB set         BEQ   P0         PUTS  #'         MSB   ON',CR=TP0       PUTS  OUTPUT-1,CR=T            Write translated output line         LDA   MSB_FLG         JEQ   WARNING         PUTS  #'         MSB   OFF',CR=T   Set MSB off         JMP   WARNINGERROR    LDA   #MAX                     Check if commented line is too long         CMP   LINE         BGE   P1         STA   LINEP1       LM    NO_PRNT,#0               Reset NO_PRNT flag         DEC   LINE                     Don't write CR at end of line         PUTS  BEGIN         PUTS  LINE-1         PUTS  END,CR=TWARNING  LM    COUNT,#L:ERR_NUM         Write all messages flagged in program         LDX   #0TOP      LDA   ERR_NUM,X         BNE   WRITE_MSGP2       INX         DBNE  COUNT,TOP         RTSWRITE_MSG  STX X1                       Save current value of X         TXA                            Get message addr from table of addresses         ASL   A         TAX         LDA   ADDR,X         STA   R0         INX         LDA   ADDR,X         STA   R1         PUTS  BEGIN         PUTS  {R0}         PUTS  END,CR=T         LDX   X1W1       DEC   ERR_NUM,X                Reset error number to zero         BEQ   P2         BNE   W1BEGIN    DSTR  '**  'END      DSTR  '  **'ADDR     DC    A'M1'         DC    A'M2'         DC    A'M3'         DC    A'M4'         DC    A'M5'         DC    A'M6'         DC    A'M7'         DC    A'M8'         DC    A'M9'         DC    A'M10'         DC    A'M11'         DC    A'M12'         DC    A'M13'         DC    A'M14'M1       DSTR  'Can only translate simple decimal operands     'M2       DSTR  'No operand given                               'M3       DSTR  'Can only zero-fill                             'M4       DSTR  'No previous DO statement                       'M5       DSTR  'Invalid nesting of conditional statements      'M6       DSTR  'EOM directive found outside of macro definition'M7       DSTR  'Label too long                                 'M8       DSTR  'Line too long                                  'M9       DSTR  'Opcode too long                                'M10      DSTR  'Operand too long                               'M11      DSTR  'Invalid operator found in expression           'M12      DSTR  'Bitwise logical operators are not translated   'M13      DSTR  'This directive is not translated               'M14      DSTR  'Only 1 SAV or DSK directive may be used        '         END         APPEND MERLIN.R