******************************************************************  DO_DIRECT - Processes source line containing a Merlin directive**  Inputs:*        OP_NUM - index of opcode in directives table in the*                 FND_INSTR subroutine******************************************************************DO_DIRECT START         USING COMMON         LONGA OFF         LONGI OFF         LDA   OP_NUM                   Self-modifying code to load a jump         ASL   A                        address         TAX         LDA   JMP_TBL,X         STA   JSR+1         LDA   JMP_TBL+1,X         STA   JSR+2JSR      JSR   JSR         RTSJMP_TBL  DC    A'ANOP'                  Label-only line         DC    A'EQUATE'                =         DC    A'EOM'                   <<<         DC    A'PMC'                   >>>         DC    A'LUP_END'               --^         DC    A'STR_DRCT'              ASC         DC    A'AST'                   AST         DC    A'REJECT'                CHK         DC    A'CYC'                   CYC         DC    A'DA'                    DA         DC    A'REJECT'                DAT         DC    A'DB'                    DB         DC    A'STR_DRCT'              DCI         DC    A'DDB'                   DDB         DC    A'MOV_OPCODE'            DEND         DC    A'DB'                    DFB         DC    A'DO'                    DO         DC    A'DS'                    DS         DC    A'SAV'                   DSK         DC    A'TR_MACRO2'             DUM         DC    A'DA'                    DW         DC    A'ELSE'                  ELSE         DC    A'END'                   END         DC    A'ENT'                   ENT         DC    A'EOM'                   EOM         DC    A'EQUATE'                EQU         DC    A'REJECT'                ERR         DC    A'EXP'                   EXP         DC    A'REJECT'                EXT         DC    A'FIN'                   FIN         DC    A'STR_DRCT'              FLS         DC    A'HEX_DR'                HEX         DC    A'REJECT'                IF         DC    A'STR_DRCT'              INV         DC    A'TR_MACRO'              KBD         DC    A'LST'                   LST         DC    A'LSTDO'                 LSTDO         DC    A'LUP'                   LUP         DC    A'MAC'                   MAC         DC    A'TR_MACRO2'             MX         DC    A'REJECT'                OBJ         DC    A'ORG'                   ORG         DC    A'PAG'                   PAG         DC    A'REJECT'                PAU         DC    A'PMC'                   PMC         DC    A'PUT'                   PUT         DC    A'REJECT'                REL         DC    A'STR_DRCT'              REV         DC    A'SAV'                   SAV         DC    A'SKP'                   SKP         DC    A'STR_DRCT'              STR         DC    A'REJECT'                SW         DC    A'TR'                    TR         DC    A'REJECT'                TYP         DC    A'USE'                   USE         DC    A'REJECT'                USR         DC    A'VAR'                   VAR         DC    A'XC'                    XC         END******************************************************************  DO_INSTR - Processes input line containing 65816 instruction.**  Inputs:*        OPCODE     - string containing opcode extracted from input line*        OPCODE_COL - column in OUTPUT line where opcode is to begin*        OPRND_COL  - column in OUTPUT line where operand is to begin*        OPERAND[0] - size of entire operand extracted from input**  Outputs:*        OUTPUT - Translated output line, represented as Pascal string******************************************************************DO_INSTR START         USING COMMON         LONGA OFF         LONGI OFFCOUNT    EQU   R10         JSR   MOV_OPCODE               Move opcode to output         LDA   OPERAND                  Check if operand has anything in it         BEQ   CHECKA         JMP   INSTR_OPRND              Process instruction operandsCHECKA   LA    TABLE,ACCUM              Check opcode using accumulator         LM    KEY_SIZE,OPCODE          addressingCHK1     LDY   OPCODECHK2     DEY         BMI   FOUND                    Key has been found         LDA   (TABLE),Y         BEQ   NOT_FOUND                Table has sentinel of 0         CMP   OPCODE+1,Y         BEQ   CHK2                     Character match -- check next char         ADD2  TABLE,KEY_SIZE           No match -- get next array item         BNE   CHK1                     by incrementing table pointer by sizeFOUND    LM    OUTPUT,OPRND_COL         TAY         LDA   #'A'         STA   OUTPUT,YNOT_FOUND RTSACCUM    DC    C'ASL'         DC    C'DEC'         DC    C'INC'         DC    C'LSR'         DC    C'ROL'         DC    C'ROR'         DC    I3'0'         END******************************************************************  DO_LABEL - Processes input line containing a label in the*             label field.**  Inputs:*        LABEL      - string containing label extracted from input line**  Outputs:*        LINE_TYPE  - high bit is set to show that input line began*                     with a label*        OPCODE_COL - column in output line where opcode is to begin*        OUTPUT     - translated output line*        NEW_VAR    - set if label is a Merlin variable*        GBL_CNT    - 3-byte ASCII number which is incremented if*                     the label is a global label******************************************************************DO_LABEL START         USING COMMON         LONGA OFF         LONGI OFF         LDA   LINE_TYPE                Reset high bit         AND   #$7F         STA   LINE_TYPE         LDA   LABEL+1                  Check if Merlin variable         CMP   #']'         BNE   D0         INC   NEW_VAR         JMP   WEIRDD0       CMP   #':'                     Check if Merlin local label         BEQ   WEIRD         LM    R0,#3                    Increment global label count string         LA    R1,GBL_CNT         JSR   INC_ASC         LA    KEY,LABEL+1              Check for non-ORCA label         LM    KEY_SIZE,LABEL         JSR   CHK_LABEL         BCS   WEIRD         LDY   LABEL                    Label is OK; check if opcode column              INY                            needs to be changed         INY         CPY   OPCODE_COL         BLT   D2         STY   OPCODE_COLD2       LA    R0,LABEL                 Move label to output         JMP   MOV_LBLWEIRD    LA    KEY,LABEL+1              Convert label to ORCA label         LM    KEY_SIZE,LABEL         JSR   TRANS_LABELMOV_LBL  LDY   #0                       Store converted string to output         LDA   (R0),Y         STA   R2                       Get size of converted string         INC2  R0                       Update pointer to start of stringMV1      LDA   (R0),Y         INY         STA   OUTPUT,Y         DBNE  R2,MV1         STY   OUTPUT         RTS         END******************************************************************  DO_MACRO - Translates line whose opcode is a macro call.**  Notes:  The macro's parameters are translated by enclosing*          them in double quotes & separating them with commas.**  Inputs:*        OPERAND  - entire operand field extracted from input line*        OPRND_COL - column in output to begin operand field**  Outputs:*        OUTPUT - formatted output line, represented as a*                 Pascal-type string.*        OPRND_COL - updated during expression evaluation as the*                    translated operand field is built*        OPCODE - the opcode is moved as is to the opcode field*                 of the output line******************************************************************DO_MACRO START         USING COMMON         LONGA OFF         LONGI OFFSAVEX    EQU   R13COUNT    EQU   R14         LM    R0,OPCODE                move macro name to opcode of output line         LA    R1,OPCODE+1         JSR   MOV_DIR         LM    COUNT,OPERAND            record size of OPERAND         BNE   D1         RTSD1       LDY   OPRND_COL                initialize output column for operands         STY   OUTPUT         LDX   #1D2       LDY   OUTPUT                   loop to translate the parameters         LDA   #'"'                     put beginning "         STA   OUTPUT,Y         INY         STY   OUTPUT         STY   OPRND_COL         LDY   #0                       extract next parameterTOP2     LDA   OPERAND,X         CMP   #';'         BEQ   OUT         INY         STA   OPERAND,Y                move it to the front of OPERAND         INX         DBNE  COUNT,TOP2OUT      STX   SAVEX                    send through expression evaluator         STY   OPERAND         JSR   INSTR_OPRND         LDY   OUTPUT                   put ending quotes         INY         LDA   #'"'         STA   OUTPUT,Y         LDX   SAVEX                    increment loop variables         INX         DBEQ  COUNT,RTS                check end of input         BMI   RTS         INY         LDA   #','                     put comma between parameters         STA   OUTPUT,Y         STY   OUTPUT         INC   OUTPUT         JMP   D2RTS      STY   OUTPUT         RTS         END******************************************************************  DS - Translates the Merlin directive DS, using a special*       macro called MDS.**  Inputs:*        OPERAND - entire operand field extracted from input*                  line, and represented as Pascal-type string**  Outputs:*        OUTPUT  - translated output line, represented as*                  Pascal-type string*        NO_PRNT - set if NO-OPERAND-GIVEN error found*        ERR_NUM - the ERR1 byte of this array is set if the*                  NO-OPERAND-GIVEN error is found; the ERR2*                  byte of this array is set if the operand*                  requests filling to the next page with some*                  value other than zero******************************************************************DS       START         USING COMMON         LONGA OFF         LONGI OFFCOUNT    EQU   R6TEMP     EQU   R14OPSIZ    EQU   3ERR1     EQU   1ERR2     EQU   2         LDX   OPERAND         STX   COUNT                    Save size of OPERAND         BNE   D0         INC   NO_PRNT                  Set flag to not print this source line         LDX   #ERR1                    Set byte in error array for this error         INC   ERR_NUM,X         RTSD0       LM    R0,#OPSIZ                Move 'MDS' to opcode field of output         LA    R1,TRANS         JSR   MOV_DIR         LDA   OPERAND+1                Check if 1st operand is '\'         CMP   #'\'         BNE   D2         LDA   COUNT         CMP   #1         BEQ   D1         LDX   #ERR2                    Set byte in error array for this error         INC   ERR_NUM,XD1       LM    R0,#1                    Call macro with '\' as only operand         LA    R1,OPERAND+1         JMP   MOV_OPR;;   Since 1st operand is not '\'  perform expression evaluation upon the;   (possibly two) operands.;D2       LDX   #1                       1st check for two operandsD3       LDA   OPERAND,X         CMP   #','         BEQ   D4         INX         DBNE  COUNT,D3         JMP   INSTR_OPRND              Just 1 operand; perform expr evaluationD4       STX   TEMP                     Save index into OPERAND         DEX         STX   OPERAND                  Fake size of operand to be evaluated         JSR   INSTR_OPRND              Evaluate 1st operand         LDX   OUTPUT                   Write ',' to separate operands         LDA   #','         INX         STA   OUTPUT,X         INX         STX   OPRND_COL                Fake column to write next operand         INC   OUTPUT         DEC   COUNT                    Move the second operand to the beginning         LM    OPERAND,COUNT            of OPERAND         LDX   TEMP         INX         LDY   #1D5       LDA   OPERAND,X         STA   OPERAND,Y         INX         INY         DBNE  COUNT,D5         JMP   INSTR_OPRND              Evaluate the second operandTRANS    DC    C'MDS'         END         APPEND MERLIN.E