******************************************************************  ELSE - Translates Merlin directive ELSE to ORCA directive*         AGO  .SEQ_SYM, followed by a different .SEQ_SYM.**  Inputs:*        ELSE_CNT  - current number of un-FIN-ed ELSEs found*                    in input*        DO_CNT    - number of DOs found in input; should be*                    greater than or equal to number of ELSEs*        OPRND_COL - column in output to begin operand field*        NEXT      - index into SEQ_SYM array*        SEQ_SYM   - array of sequence symbols, used as branch*                    addresses for conditional assembly language**  Outputs:*        ELSE_CNT - incremented to show new ELSE found in input*        OUTPUT   - translated output line, represented as a*                   Pascal string*        NEXT     - index into SEQ_SYM array; incremented to*                   point to next symbol*        SEQ_SYM  - sequence symbol assigned as label gets marked*                   to show has been used as a label*        NO_PRNT  - set if an error in the conditional language*                   logic is found*        ERR_NUM  - if no previous DO was given in the input,*                   byte number ERR1 is set for this error; if*                   no unused sequence symbol can be found, then*                   byte number ERR2 is set for this error******************************************************************ELSE     START         USING COMMON         LONGA OFF         LONGI OFFOPSIZ    EQU   3ERR1     EQU   3ERR2     EQU   4         INC   ELSE_CNT                 Check invalid ELSE         LDA   ELSE_CNT         CMP   DO_CNT         BLE   OK         INC   NO_PRNT                  Set flag to not print this source line         LDX   #ERR1                    Set byte in error array for this error         INC   ERR_NUM,X         RTSOK       LM    R0,#OPSIZ                Move 'AGO' to opcode field of output         LA    R1,TRANS         JSR   MOV_DIR         LDA   #'.'                     Move .SEQ_SYM(next) to operand field         LDX   OPRND_COL         STA   OUTPUT,X         INX         LDA   NEXT         CLC         ADC   #'I'         STA   OUTPUT,X         STX   OUTPUT         PUTS  OUTPUT-1,CR=T            Write current output line         LDX   NEXT                     Find preceding sequence symbol that hasE1       DEX                            not been used to assign to current ELSE         LDA   SEQ_SYM,X         BEQ   E2         BPL   E1;;   If all preceding sequence symbols have been used, set flags and exit.;         INC   NO_PRNT                  Set flag to not print this source line         LDX   #ERR2                    Set byte in error array for this error         INC   ERR_NUM,X         RTSE2       LDY   #1                       Move ELSE's sequence symbol to output         LDA   #'.'         STA   OUTPUT,Y         TXA         CLC         ADC   #'I'         INY         STA   OUTPUT,Y         STY   OUTPUT         INC   SEQ_SYM,X                Mark ELSE's seq symbol as being used         INC   NEXT                     Update pointer into SEQ_SYM array         RTSTRANS    DC    C'AGO'         END******************************************************************  END - Interprets Merlin directive END as signal to wrap up.**  Outputs:*        EOF_FLAG - set to true******************************************************************END      START         USING COMMON         LONGA OFF         LONGI OFF         INC   EOF_FLAG         RTS         END******************************************************************  ENT - Translates Merlin directive ENT to ORCA ENTRY directive******************************************************************ENT      START         USING COMMON         LONGA OFF         LONGI OFFOPSIZ    EQU   5         LM    R0,#OPSIZ         LA    R1,TRANS                 Move 'ENTRY' to output line         JMP   MOV_DIRTRANS    DC    C'ENTRY'         END******************************************************************  EOM - Translates Merlin directives EOM and <<< into error*        messages as these should not be found outside of macros,*        which are handled elsewhere.**  Outputs:*        NO_PRNT - set to show this input line should be echoed*                  to output, and commented out*        ERR_NUM - byte ERR is set for EOM-beyond-macro error******************************************************************EOM      START         USING COMMON         LONGA OFF         LONGI OFFOPSIZ    EQU   4         LM    R0,#OPSIZ         LA    R1,TRANS         JMP   MOV_DIRTRANS    DC    C'MEND'         END******************************************************************  EQUATE - Translates Merlin directives  =  or  EQU******************************************************************EQUATE   START         USING COMMON         LONGA OFF         LONGI OFFOPSIZ    EQU   3         LM    R0,#OPSIZ         LA    R1,TRANS                 Move 'EQU' to output line         JSR   MOV_DIR         JMP   INSTR_OPRND              Translate operandTRANS    DC    C'EQU'         END******************************************************************  EVAL_OPRND - Determines Merlin operand type, and calls*               appropriate operand-handling routine.**  Inputs:*        X1      - current pointer into OPERAND field*        OPERAND - string containing entire operand field extracted*                  from input source line**  Outputs:*        C        - set if pointer to operand is different than OPERAND*        OPR_SIZE - current size of operand being examined in*                   OPERAND field*        X1       - pointer into OPERAND 1 byte beyond character*                   examined in EVAL_OPRND*        DELIM    - if operand is a string, the string's delimiter*        SIZE     - total size of OPERAND, minus the current character*        MSB_FLG  - set if string delimiter is "******************************************************************EVAL_OPRND  START         USING COMMON         LONGA OFF         LONGI OFF         LM    OPR_SIZE,#1              Set operand size to 1         LDX   X1         LDA   OPERAND,X                Get OPERAND character         CMP   #'-'                     Check for leading '-'         BNE   E1         STORE         LDX   X1         LDA   OPERAND,X         INC   OPR_SIZE         JMP   E2E1       CMP   #'+'                     Check for leading '+'         BNE   E2         STORE         LDX   X1         LDA   OPERAND,X         INC   OPR_SIZEE2       CMP   #'*'                     Check for current program counter         BNE   E3         STORE                          Macro which stores X into X1 and         CLC                            checks for end of OPERAND field         RTSE3       CMP   #"'"                     Check for ASCII character         BNE   E4         STA   DELIM         STORE         JMP   CHAR_STRE4       CMP   #'"'                     Check for ASCII char with MSB set         BNE   E5         STA   DELIM         INC   MSB_FLG         STORE         JMP   CHAR_STRE5       CMP   #'$'                     Check for hex number         BNE   E6         STORE         JMP   HEXE6       CMP   #'%'                     Check for binary number         BNE   E7         STORE         JMP   BINARYE7       CMP   #'0'                     Check for decimal number         BLT   E8         CMP   #':'         BGE   E8         STORE         JMP   DECIMALE8       JMP   OPR_LABEL                Default is labelEND      CLC         RTS         END******************************************************************  EXP - Translates Merlin directive EXP to ORCA directive GEN.**  Inputs:*        OPERAND - Pascal-type string containing entire operand*                  extracted from input line******************************************************************EXP      START         USING COMMON         LONGA OFF         LONGI OFFOPSIZ    EQU   3         LM    R0,#OPSIZ                Load GEN into opcode field of output         LA    R1,GEN         JSR   MOV_DIR         LDA   OPERAND+3                Check if operand is ONLY         JSR   SHIFT         CMP   #'L'         BEQ   ONLY         JMP   INSTR_OPRNDONLY     LM    R0,#2         LA    R1,ON                    Convert ONLY operand to ON         JMP   MOV_OPRGEN      DC    C'GEN'ON       DC    C'ON'         END         APPEND MERLIN.F