******************************************************************  GET_LABEL - Extracts label from input source line**  Inputs:*        LINE     - Merlin source line*        X1       - current line index**  Outputs:*        LABEL     - string containing label on source line*        EOL       - set to true if end-of-line encountered*        ERR_NUM   - byte number ERR is set if LABEL-TOO-LONG*                    error detected*        LINE_TYPE - high bit set to show presence of label*                    ORed with 3 if label-only line*        OP_NUM    - set to zero if label-only line*        X1        - index into source line beyond label******************************************************************GET_LABEL  START         USING COMMON         LONGA OFF         LONGI OFFMAX      EQU   13ERR      EQU   6COUNT    EQU   R12         LDA   LINE_TYPE             Set high bit to reflect presence of label         ORA   #$80         STA   LINE_TYPE         LM    COUNT,#MAX            Check that label is not too long         LDX   X1                     Loop to extract label         LDY   #0G0       LDA   LINE,X         CMP   #RETURN         BEQ   END         CMP   #BLANK         BEQ   G1         STA   LABEL+1,Y         INX         DBEQ  COUNT,ERROR              Check label length         INY         BNE   G0ERROR    STX   X1         LDX   #ERR                     Set error flag for label-too-long         INC   ERR_NUM,X         LDX   X1E1       LDA   LINE,X                   Skip the rest of the label         CMP   #RETURN         BEQ   END         CMP   #BLANK         BEQ   G1         INX         BNE   E1G1       STX   X1                       Move to next field, checking EOL         JSR   SKIP_BLANKS         LDA   EOL         BEQ   RTSEND      INC   EOL                    Label-only line is ANOP directive         LDA   LINE_TYPE         ORA   #3         STA   LINE_TYPE         LDA   #0         STA   OP_NUMRTS      STY   LABEL                  Size of label in 1st byte         RTS         END******************************************************************  GET_LINE - Reads characters from input line, storing to buffer**  Inputs:*        CHAR     - character read during GET_CHAR routine*        EOF_FLAG - set to true by GET_CHAR if file pointer*                   set to EOF while reading**  Outputs:*        LINE     - the next line from the input stream,*                   stored as a Pascal-type string*        ERR_NUM  - byte ERR of array is set if LINE-TOO-LONG*                   error is detected******************************************************************GET_LINE START         USING COMMON         LONGA OFF         LONGI OFFCOUNT    EQU   R12MAX      EQU   255ERR      EQU   7         LM    COUNT,#MAX               Initialize line length counter         LM    LINE,#0                  Initialize line lengthG1       JSR   GET_CHAR                 Get next character         LDA   EOF_FLAG                 Check for EOF         BNE   G2         DBNE  COUNT,OK                 Check line length         LDX   #ERR                     Set error flag for line too long         INC   ERR_NUM,XG2       LDA   #RETURN         STA   CHAROK       INC   LINE                     Build line         LDA   CHAR         LDX   LINE         STA   LINE,X         CMP   #RETURN         BNE   G1         RTS         END******************************************************************  GET_LINE_TYPE - Parses input line of source into label, opcode,*                  operand, and comment.  Determines line type.**  Inputs:  LINE  - input source line**  Outputs:*        LABEL      - string containing label from input line*        OPCODE     - string containing opcode from input line*        OPERAND    - string containing operands from input line*        COMMENT    - column where comment field in line begins*        LINE_TYPE  - either comment (* or blanks) = 0,*                            comment (;)           = 1,*                            instruction           = 2,*                            directive             = 3,*                            macro                 = 4*        EOL        - initialized to false******************************************************************GET_LINE_TYPE  START         USING COMMON         LONGA OFF         LONGI OFF;;   Initialization.;         LDA   #0                       Initialize all field sizes to 0         STA   LABEL         STA   OPCODE         STA   OPERAND         STA   COMMENT         STA   EOL                      Clear EOL flag         STA   LINE_TYPE                Set default line_type to comment1         LDY   #13                      Clear opcode for directive check         LDA   #BLANKP0       STA   OPCODE,Y         DBNE  Y,P0;;   Check for line containing only a carriage return.;         LDX   #1         STX   X1         LDA   LINE,X         CMP   #RETURN         BEQ   RTS;;   Check for comment line.;         CMP   #'*'         BEQ   RTS         CMP   #';'         BEQ   RTS;;   Extract label from input line.;         CMP   #BLANK         BEQ   P3         JSR   GET_LABEL         LDA   EOL                      Check end-of-line         BEQ   P4RTS      RTS;;   Extract opcode, operands, and comment column from input line.;P3       JSR   SKIP_BLANKS         LDA   EOL                      Check end-of-line         BEQ   P4         LDA   COMMENT                  Check for comment2 line         BEQ   RTS         INC   LINE_TYPE         RTSP4       JSR   GET_OPCODE         LDA   EOL                      Check end-of-line         BNE   RTS         JSR   SKIP_BLANKS         LDA   EOL         BNE   RTS         LDA   STR_FLG                  Check if operand is a string         BEQ   P5         JSR   GET_STRING         DEC   STR_FLG         JMP   SKIP_BLANKSP5       JSR   GET_OPERAND         JMP   SKIP_BLANKS         END******************************************************************  GET_OPCODE - Extracts opcode field from input line**  Inputs:*        LINE      - Merlin source line*        X1        - current line index**  Outputs:*        OPCODE    - string containing extracted opcode*        EOL       - set to true if end-of-line encountered*        ERR_NUM   - byte ERR of array is set if OPCODE-TOO-LONG*                    error found*        X1        - index into line 1 byte beyond opcode******************************************************************GET_OPCODE START         USING COMMON         LONGA OFF         LONGI OFFOPSIZE   EQU   14MAX      EQU   13ERR      EQU   8COUNT    EQU   R6         LM    COUNT,#MAX               Initialize opcode length count         LDX   X1         LDY   #0G1       LDA   LINE,X                   Extract opcode         JSR   SHIFT         CMP   #RETURN         BNE   G2         INC   EOL         BNE   RTSG2       CMP   #BLANK         BEQ   G3         STA   OPCODE+1,Y         INY         INX         DBNE  COUNT,G1                 Check opcode lengthERROR    STX   X1         LDX   #ERR                     Handle opcode too long error         INC   ERR_NUM,X         LDX   X1E1       LDA   LINE,X                   Skip rest of opcode after MAX char         CMP   #RETURN         BNE   E2         INC   EOL         JMP   RTSE2       CMP   #BLANK         BEQ   G3         INX         BNE   E1G3       STX   X1RTS      STY   OPCODE         JMP   FIND_INSTR               Determine if opcode is instruction,;                                       directive, or macro         END******************************************************************  GET_OPERAND - Extracts operands from input line**  Inputs:*        LINE - Merlin input source line*        X1   - current pointer into line**  Outputs:*        OPERAND - string containing operands extracted*        COMMENT - beginning column # of comment field in*                  input line*        ERR_NUM - byte ERR of array is set if*                  OPERAND-TOO-LONG error encountered*        X1      - index into line 1 byte beyond operand******************************************************************GET_OPERAND  START         USING COMMON         LONGA OFF         LONGI OFFMAX      EQU   64ERR      EQU   9COUNT    EQU   R8         LM    COUNT,#MAX               Initialize operand length counter         LDX   X1         LDY   #0G1       LDA   LINE,X                   Loop to extract operand         CMP   #RETURN         BEQ   RTS         CMP   #BLANK         BEQ   RTS         INY         STA   OPERAND,Y         INX         DBNE  COUNT,G1                 Check operand lengthERROR    STX   X1         LDX   #ERR                     Handle operand-too-long error         INC   ERR_NUM,X         LDX   X1E1       LDA   LINE,X                   Skip rest of operand         CMP   #RETURN         BEQ   RTS         CMP   #BLANK         BEQ   RTS         INX         BNE   E1RTS      STY   OPERAND         STX   X1         RTS         END******************************************************************  GET_OPERATOR - Finds next Merlin operator in OPERAND field;*                 converts logical operators as needed.**  NOTES:   Merlin operators are all 1 character in length:*                   +  -  /  *  !  .  &  ,  )  ]**  Inputs:*        X1      - current pointer into OPERAND field*        OPERAND - string containing entire operand field*                  extracted from input source line**  Outputs:*        SIZE      - size of OPERAND string minus current operator*        OPR_SIZE  - size of operator found*        OPR_PTR   - pointer to operator, if different from*                    pointer to OPERAND*        C flag    - set if pointer to operand changes*        SV_OP_PTR - pointer into OPERAND; saved if pointer changes*        SV_OP_SIZ - size of current operator; saved if pointer changes*        ERR_NUM   - byte number ERR is set if invalid operator found*        X1        - index into OPERAND 1 byte after current operator******************************************************************GET_OPERATOR  START         USING COMMON         LONGA OFF         LONGI OFFERR1     EQU   10                       Byte to set in ERR_NUM for invald oprtrERR2     EQU   11                       Byte to set in ERR_NUM for logical oprtr         LM    OPR_SIZE,#1              Default size of operator is 1 byte         DEC   SIZE                     Update current size of OPERAND string         LDX   X1                       Get operator character         LDA   OPERAND,X         INC   X1                       Update OPERAND pointer;;   Check special-case operators: ,  )   ]    The op_count field is not;   incremented for these operators as this would ruin the formatting that;   Merlin-to-ORCA performs for operand expressions.;         CMP   #','                     If comma, just return         BEQ   END         CMP   #')'         BEQ   G2         CMP   #']'         BNE   G3G2       LDA   SIZE                     Check end of OPERAND field         BEQ   END         INX         LDA   OPERAND,X         CMP   #','         BNE   END         INC   X1         INC   OPR_SIZE         DEC   SIZEEND      CLC         RTS;;   Check operators that are the same in both Merlin and ORCA.;G3       CMP   #'+'         BEQ   OK         CMP   #'-'         BEQ   OK         CMP   #'/'         BEQ   OK         CMP   #'*'         BNE   G4OK       INC   OP_COUNT         CLC         RTS;;   Check logical operators--they need to be flagged an untranslatable.;G4       CMP   #'!'         BEQ   ERROR         CMP   #'.'         BEQ   ERROR         CMP   #'&'         BEQ   ERRORBAD      LDX   #ERR1                    Handle invalid-operator error         INC   ERR_NUM,X         CLC         RTSERROR    INC   NO_PRNT                  Handle logical-operator error         LDX   #ERR2         INC   ERR_NUM,X         CLC         RTS         END******************************************************************  GET_STRING - Translates Merlin operand which is a string, optionally*               followed by hex data.**  Inputs:*        LINE - input Merlin source line*        X1   - index into LINE**  Outputs:*        MSB_FLG - set if string delimiter is "*        DELIM   - string delimiter*        OPERAND - entire delimited string extracted from input*                  line, and represented as Pascal-type string*        ERR_NUM - byte number ERR is set if operand is too long*        X1      - index into LINE 1 byte beyond delimited string******************************************************************GET_STRING START         USING COMMON         LONGA OFF         LONGI OFFMAX      EQU   64ERR      EQU   9QUOTE    EQU   $27DQUOTE   EQU   $22DELIM    EQU   R10COUNT    EQU   R12         LM    MSB_FLG,#0         LM    COUNT,#MAX         LDX   X1         LDY   #1         LDA   LINE,X         STA   DELIM         LDA   #QUOTE                   Check if should set MSB flag         STA   OPERAND,Y         CMP   LINE,X         BLE   G0         INC   MSB_FLGG0       INX                            Extract string from input line         LDA   LINE,X         CMP   #RETURN         JEQ   G6         CMP   DELIM         BEQ   G3         CMP   #QUOTE                   Check if need to double quote         BEQ   G1         CMP   #DQUOTE         BNE   G2G1       INY         STA   OPERAND,YG2       INY         STA   OPERAND,Y         DBNE  COUNT,G0         JMP   E0G3       INX                            Check end of operand         LDA   LINE,X         CMP   #BLANK         JEQ   G7         CMP   #RETURN         JEQ   G6         LDA   #QUOTE                   Mark end of string         INY         STA   OPERAND,Y         LDA   #','                     Mark beginning of hex digit         INY         STA   OPERAND,Y         LDA   #QUOTE         INY         STA   OPERAND,YG4       LDA   LINE,X                   Process hex digit         CMP   #','         BEQ   G5         CMP   #RETURN         JEQ   G6         CMP   #BLANK         BEQ   G7         INY         STA   OPERAND,YG5       INX         DBNE  COUNT,G4E0       STX   X1         LDX   #ERR                     Operand is too long         INC   ERR_NUM,X         LDX   X1E1       INX                            Skip the rest of the operand         LDA   LINE,X         CMP   #RETURN         BEQ   G6         CMP   #BLANK         BNE   E1         JMP   G7G6       INC   EOLG7       STX   X1         LDA   #QUOTE         INY         STA   OPERAND,Y         STY   OPERAND         RTS         END         APPEND MERLIN.H