******************************************************************  MERLIN-TO-ORCA Source Code Translator  V1.0 D1**  Inputs:  Command-line filename, or standard input, containing*           Merlin source code**  Outputs: Translated ORCA source, either a file or line-by-line*           translation sent to standard output**  Written by Barbara Allred and Mike Westerfield**  By The Byte Works Inc.*  Copyright (c) 1987*  All rights reserved.*****************************************************************MAIN     START         PHK                            Put source & data in same program bank         PLB         JSR   INIT         JSR   TRANSLATE         JSR   PRNT_LT         JSR   TERMINATE         LDA   #0         RTL         END******************************************************************  MERLIN COMMON DATA -- Global variables for program******************************************************************COMMON   DATACMD_LINE GEQU  $0                       storage for address of command lineLOCKP    GEQU  $4                       required for memory management macrosLT_PTR   GEQU  $8                       Pointer to label tableR0       GEQU  $C                       Zero-page "registers"R1       GEQU  $DR2       GEQU  $ER3       GEQU  $FR4       GEQU  $10R5       GEQU  $11R6       GEQU  $12R7       GEQU  $13R8       GEQU  $14R9       GEQU  $15R10      GEQU  $16R11      GEQU  $17R12      GEQU  $18R13      GEQU  $19R14      GEQU  $1AR15      GEQU  $1BTABLE    GEQU  $1C                      Indirect address locations for searchKEY      GEQU  $20                      routinesOPR_PTR  GEQU  $24                      Pointer to current operand;;                                       Constants;BLANK    EQU   $20                      spaceRETURN   EQU   $0D                      carriage returnCOMMNT    EQU   1                       Line_typesINSTR     EQU   2DIRECTIVE EQU   3MACRO     EQU   4LINE_TYPE DS   1                        Source line typeUSER_ID  DS    2                        program's User_ID assigned by shellLT_HANDL   DS  4                        Label table handleLT_TOT_SIZ DS  4                        Total memory allocated to label tableLT_CUR_SIZ DS  4                        Current size of label tableKEY_SIZE DS    4                        Size of key being searched forOPR_SIZE  DC   I2'0'                    Curr. size of data pointed to by opr_ptrSV_OP_PTR DS   2                        Save operand pointer when default changsSV_OP_SIZ DS   1                        Save operand size when default changesOP_COUNT  DS   2                        Number of operators found in OPERANDOP_NUM    DS   2                        Directive number; pointer into jmp tableSIZE      DS   1                        Current size of OPERAND being parsed;;                                       Global flags;FILE_FLAG DS   1                        Boolean flag--file or standard input?EOF_FLAG  DS   1                        End-of-file flagEOL       DS   1                        End-of-line flagMSB_FLG   DS   1                        True if string data has MSB setNEW_VAR   DS   1                        New variable found in label fieldABS_FLAG  DS   1                        True if opcode uses forced abs address.STR_FLG   DS   1                        True if operand is a stringMAC_FLG   DS   1                        True if a macro is being definedORG_FLG   DS   1                        Set if ORG used in Merlin source fileKEEP_FLG  DS   1                        Set if SAV or DSK directives used onceXC_FLG    DS   1                        Set if XC directive has been usedNO_PRNT   DS   1                        Set if source line should be commented;                                       out during translationERR_NUM  DS    15                       Array of internal errorsX1       DS    1                        Temporary 8-bit Y registerY1       DS    1                        Temporary 8-bit X registerCHAR     DS    1                        Read variablesLINE     DS    255                      Input line bufferLABEL    DS    14                       Assembler source line fieldsOPCODE   DS    14OPERAND  DS    65COMMENT  DS    1                        Column in input where comment beginsOUTPUT      DS 256                      Output lineOPCODE_COL  DS 1                        Column in output line to begin opcodeOPRND_COL   DS 1                        Column in output line to begin operandCMMNT_COL   DS 1                        Column in output line to begin commentDELIM    DS    1                        Delimiter used to mark stringSTRING   DC    I1'7'                    Translated Merlin global label         DC    C'SYS'INDEX    DC    C'0000'                  Index of label in label tableL_STRING DC    I1'8'                    Translated Merlin local label         DC    C'L'L_INDEX  DC    C'0000'                  Index of label in label tableGBL_CNT  DC    C'000'                   Global count attached to local labelV_STRING DC    I1'8'                    Translated Merlin variable         DC    C'V'V_INDEX  DC    C'0000'                  Index of variable in label tableVAR_CNT  DC    C'000'                   Use count attached to variableNEXT     DC    I1'0'                    Index into SEQ_SYM arraySEQ_SYM  DC    8I1'0'                   Array used for conditional assembly dirsDO_CNT   DC    I1'0'                    Counters for the number of DOs, ELSEs,ELSE_CNT DC    I1'0'                    and FINsFIN_CNT  DC    I1'0';;                                       DCBs;QT_DCB   ANOP                           quit DCB         DC    A4'QT_FLAGS'QT_FLAGS DC    I'0'ER_DCB   ANOP                           system error DCBER_NUM   DS    2OP_DCB   ANOP                           Open file DCBREF_NUM  DS    2PATH_PTR DC    I4'NAME'BUFF     DS    4NAME     DS    65                       File name bufferRD_DCB   ANOP                           Read file DCBRD_REF   DS    2RD_BUFF  DC    I4'CHAR'RD_COUNT DC    I4'1'         DS    4IF_DCB   ANOP                           file info DCBIF_PATH  DC    A4'MAC_NAME'IF_ACC   DS    2IF_TYP   DS    2IF_AUX   DS    4         DS    16CR_DCB   ANOP                           Create DCBCR_PATH  DC    I4'MAC_NAME'CR_ACC   DC    I'$C3'CR_TYP   DC    I'4'CR_AUX   DS    4CR_STOR  DC    I'1'CR_DATE  DC    I'0'CR_TIME  DC    I'0'OPM_DCB  ANOP                           Open macro file DCBOPM_REF  DS    2OPM_PATH DC    I4'MAC_NAME'OPM_BUF  DS    4EF_DCB   ANOP                           End-of-file DCBEF_REF   DS    2EF_MRK   DS    4WR_DCB   ANOP                           Write DCBWR_REF   DS    2WR_BUF   DC    A4'OUTPUT+1'WR_CNT   DS    4WR_RTN   DS    4MAC_NAME DW    'MY.MACROS'         END******************************************************************  CHK_END - Checks if enough room in label table for new entry.**  NOTES:    If there is not enough room in the label table for*            a new entry, CHK_END tries to grow the label table.*            If it can't grow the table, then it quits the program.**  Inputs:*        LT_CUR_SIZ - current size of occupied label table*        KEY_SIZE - size of key to be added to label table*        LT_TOT_SIZ - total size allocated for label table*        LT_HANDL - handle of label table**  Outputs:*        LT_CUR_SIZ - size of occupied label table after adding*                     new label*        LT_TOT_SIZ - total size of label table after growing******************************************************************CHK_END  START         USING COMMON         SHORT I,MGROW_SIZ EQU   1024         ADD4  LT_CUR_SIZ,KEY_SIZE      Update size of label table         INC4  LT_CUR_SIZ         CMP4  LT_TOT_SIZ,LT_CUR_SIZ    Check if need to grow label table         BLT   GROW         RTSGROW     UNLOCK  LT_HANDL               Grow the label table, if can         BCS   ERROR         ADD4  LT_TOT_SIZ,#GROW_SIZ     compute new handle size         GROW  LT_HANDL,LT_TOT_SIZ      grow the handle         BCS   ERROR         LOCK  LT_HANDL,LT_PTR          lock it back down         BCS   ERROR         RTSERROR    TERR  #0         END******************************************************************  GET_CHAR - Reads next byte from input file or standard input**  Inputs:*        FILE_FLAG - set if input is from a file**  Outputs:*        CHAR - contains next character read*        EOF_FLAG - set to true if EOF encountered******************************************************************GET_CHAR START         USING COMMON         LONGA OFF         LONGI OFFTAB      EQU   $09EOF      EQU   $4C         LDA   FILE_FLAG                Check if input from file or std_input         BNE   FILERDG0       JSL   ~CRIN                    Read from standard input         CMP   #0         BEQ   END         CMP   #RETURN                  Check for control characters         BEQ   RTS         CMP   #TAB         BEQ   G1         CMP   #$20         BLT   G0         BRA   RTSG1       LDA   #BLANKRTS      STA   CHAR;        JSL   ~COUT                    can uncomment for echoing when         RTS                            entering input from the keyboardFILERD   READ  RD_DCB                   Input is from file         BCS   CHECK         LDA   CHAR         AND   #$7F         STA   CHAR         CMP   #RETURN                  Check for control characters         BEQ   FRTS         CMP   #TAB         BEQ   G1         CMP   #$20         BLT   FILERDFRTS     RTSCHECK    CMP   #EOF                     See if this is end-of-file error         BNE   ERREND      INC   EOF_FLAG         RTSERR      TERR  #0         END******************************************************************  INIT - Program initialization.**  NOTES: Determines whether input source is from a file or*         standard input.  Allocates memory for label table.*         Opens input file, sets program flags.**  Inputs:*        A          - User ID assigned to program by shell*        X,Y        - address of command line**  Outputs:*        USER_ID    - User ID assigned to program by shell*        CMD_LINE   - 4-byte address of command line*        LT_HANDL   - handle of memory allocated for label table*        LT_TOT_SIZ - total amount of memory allocated for table*        LT_PTR     - pointer to label table*        LT_CUR_SIZ - current size of occupied label table--set to 0*        NAME       - name of input file given on command line*        REF_NUM    - 2-byte reference number of input file*        RD_REF     - 2-byte reference number of input file*        FILE_FLAG  - set to true if input from file*        EOF_FLAG   - set to false*        ORG_FLG    - set to false; no ORGs used yet*        KEEP_FLG   - set to false; no KEEPs used yet*        XC_FLG     - set to false; no XCs used yet******************************************************************INIT     START         USING COMMON         LONG  I,MINIT_SIZE  EQU  1024         STA   USER_ID                  Save UserID         STX   CMD_LINE+2               Save address of command_line         STY   CMD_LINE         GET_FILE_INFO  IF_DCB          Create macro file         BCC   OPEN         CMP   #$46                     Check if error is "file not found"         JNE   ERR         CREATE  CR_DCB         JCS     ERR1OPEN     OPEN    OPM_DCB                Open the macro file         JCS     ERR         LDA     OPM_REF                Move file_ref_num to write DCB & EOF DCB         STA     WR_REF         STA     EF_REF         STZ     EF_MRK                 Set EOF to beginning of file         STZ     EF_MRK+2         SET_EOF EF_DCB         JCS     ERR;;   Get memory for label table.;         NEW   LT_HANDL,#INIT_SIZE         JCS   ERR         LDA   #INIT_SIZE               Total size of LT is amt allocated         STA   LT_TOT_SIZ         LOCK  LT_HANDL,LT_PTR         JCS   ERR         STZ   LT_CUR_SIZ               Current size of label table is zero         STZ   LT_CUR_SIZ+2         SHORT I,M         LDA   #0         STA   [LT_PTR]                 1st LT entry is a null string         STZ   FILE_FLAG                Clear flags         STZ   EOF_FLAG         STZ   ORG_FLG         STZ   KEEP_FLG         STZ   XC_FLG         STZ   MAC_FLG         STZ   NO_PRNT;;   Strip command from command_line as it isn't needed.;         LDY   #8         LDA   #BLANKI1       CMP   [CMD_LINE],Y             Skip white-space         BNE   I2         INY         BRA   I1I2       LDA   [CMD_LINE],Y             Skip command         BEQ   RTS                      Check for null-terminated string--no;                                       file specified on command line         CMP   #BLANK         BEQ   I4         INY         BRA   I2I4       LDA   [CMD_LINE],Y             Skip white-space         BEQ   RTS                      Check for re-directed input         CMP   #BLANK         BNE   I5         INY         BRA   I4;;   Get file name and open input file.;I5       LDX   #0I6       INX         STA   NAME,X         INY         LDA   [CMD_LINE],Y         BEQ   I7         CMP   #BLANK         BNE   I6I7       STX   NAME                     First byte of name is its length         INC   FILE_FLAG         OPEN  OP_DCB         JCS   ERR         LONG  I,M         LDA   REF_NUM         STA   RD_REFRTS      SHORT I,M         RTSERR1     PHA         PHX         PUTS  #'Error in creating MY.MACROS',CR=T         PLX         PLA         BRL   STERRERR      TERR  #0         END******************************************************************  PRNT_LT - Print label table at end of program.**  Inputs:*        LT_PTR - pointer to beginning of label table*        STRING - ASCII string containing 'SYS' and the 5-digit*                 index number of translated Merlin label*        INDEX -  index portion of STRING**  Outputs:*        The translated label table is appended to the end of the*        program's output.******************************************************************PRNT_LT  START         USING COMMON         SHORT I,M         LDY   #0                       Check if label table is empty         LDA   [LT_PTR],Y         BNE   P0         RTS;;   Print label table headings.;P0       PUTCR         PUTCR         PUTCR         PUTS  #';     MERLIN LABEL                  '         PUTS  #'TRANSLATED LABEL',CR=T         PUTS  #';     ------------'         PUTS  #'                  ----------------',CR=T         PUTS  #';',CR=T;;   Print label table.;         MOVE  NUM,INDEX,#4             Initialize table index to 4 ASCII zeroes         MOVE  XXX,GBL_CNT,#3           Set global count to 3 x's         MOVE  XXX,VAR_CNT,#3           Set variable count to 3 x'sTOP      PUTS  #';     '         LDY   #0         LDA   [LT_PTR],Y         BNE   P1                       Check end of table         RTSP1       STA   T_SIZE         TAX         INY                            Check if Merlin variable         LDA   [LT_PTR],Y         CMP   #']'         BNE   P2A         DEX         DEX         DEX         BRA   P2AP2       INY                            Loop to move Merlin label to output         LDA   [LT_PTR],YP2A      STA   OUTPUT,Y         DBNE  X,P2         LDA   #BLANK                   Put blanks between fields in outputP3       INY         STA   OUTPUT,Y         CPY   #34         BLT   P3         LDY   #1                       Check if local label         LDA   [LT_PTR],Y         CMP   #':'         BNE   P4         MOVE  INDEX,L_INDEX,#4         LA    R0,L_STRING         JSR   MV_STRING         BRA   P6P4       CMP   #']'                     Check if variable         BNE   P5         MOVE  INDEX,V_INDEX,#4         LA    R0,V_STRING         JSR   MV_STRING         BRA   P6P5       LA    R0,STRING         JSR   MV_STRINGP6       LM    R0,#4                    Increment index         LA    R1,INDEX         JSR   INC_ASC         INC4  T_SIZE                   Get next table item         ADD4  LT_PTR,T_SIZE         BRL   TOPMV_STRING LDY  #0                       Move translated label to output         LDA   (R0)                     Move size of string to R2         STA   R2         INC2  R0                       Update pointer to beginning of string         LDX   #34MV1      LDA   (R0),Y         STA   OUTPUT,X         INY         INX         DBNE  R2,MV1         DEX         STX   OUTPUT         PUTS  OUTPUT-1,CR=T         RTST_SIZE   DS    4NUM      DC    C'0000'XXX      DC    C'xxx'         END******************************************************************  STERR - Flag a terminal error**  Inputs:*        X - error number*        A - system error (for X = 0)******************************************************************STERR    START         USING COMMON         LONG  I,M         STA   ER_NUM                   do a CR         PHX         PUTCR         PLX         CPX   #0                       if system error then         BNE   LB1         BRA   OUTLB1      CPX   #1                       else if X = 1 then         BNE   OUT         PUTS  #'Error in allocating memory',CR=T         LDA   #$FFFF         STA   ER_NUMOUT      JSR   TERMINATE         LDA   ER_NUM         PHA         ERROR ER_DCB         PLA         QUIT  QT_DCB         END******************************************************************  TERMINATE - Program wrap-up.  Closes any open files and*              deallocates any allocated memory.**  Inputs:*        USER_ID - User ID assigned by shell to program**  Outputs:   - None -******************************************************************TERMINATE START         USING COMMON         LONG  I,M         CLOSE CL_DCB         DISPOSEALL  USER_ID         RTSCL_DCB   ANOP         DC    I'0'         END******************************************************************  TRANSLATE - Controlling routine for translating Merlin source*              code to ORCA source**  Inputs:*        EOF_FLAG - set to true if end-of-file encountered while*                   reading input line******************************************************************TRANSLATE START         USING COMMON         LONGA OFF         LONGI OFF         PUTS  #'         MCOPY MERLIN.MACROS',CR=T    Use MERLIN.MACROS in new;                                                      source file;         PUTS  #'         MCOPY MY.MACROS',CR=T        Make user's macros;                                                      available in new file;         PUTS  #'TRANSLATION  START',CR=T              Needed by ORCA         PUTS  #'         LCLA  &'                     Use local ORCA symbolic         PUTS  #'LUP',CR=T                             variable for Merlin LUP;                                                      directiveT0       JSR   GET_LINE                 Get next line from input         LDA   EOF_FLAG                 Check for EOF         BNE   RTS         STOP  ST_DCB                   Check exit from translator by user         LDA   ST_DCB         BNE   RTS         JSR   PROC_LINE                Process the input line         JSR   PUTLINE                  Write translated line to output         BRA   T0RTS      PUTS  #'         END',CR=T     Needed by ORCA         RTSST_DCB   DS    2         END******************************************************************  TRANS_LABEL - Translates Merlin label to ORCA label.**  NOTES:  TRANS_LABEL first checks if the Merlin label is already*          in the label table.  If it is not, it adds the new*          label to the end of the table.  The search performed is*          linear.  Merlin labels are of 3 distinct types:*          global labels, local labels, and variables.**          Global labels are translated into 'SYS' + the 4-byte*          ASCII index of the label's position in the label table.**          Local labels begin with ':'  and are "attached"*          to global labels.  They are translated into 'L' + the*          4-byte ASCII index of the label's position in the*          table + a 3-byte ASCII global count.  (The global counter*          is incremented every time a new global label is defined.)**          Variables begin with ']' and are redefined every time*          they appear in the label field of a Merlin source line.*          Variables are translated into 'V' + the 4-byte ASCII index*          of its position in the label table + a 3-byte ASCII field*          which is initialized to '000' and then incremented whenever*          the variable is redefined.**          Global and local labels are stored into the table with a*          starting length byte, followed by the characters as they*          appear in the Merlin source file.  Variables are stored into*          the table with a starting length byte, followed by the*          characters as they appear in the Merlin source file, and*          ending with a 3-byte ASCII count attached to the variable.**  Inputs:*        KEY      - string containing label extracted from input line,*                   either in label field or operand field*        KEY_SIZE - size of label*        LT_PTR   - pointer to label table*        INDEX    - index of Merlin global label in table*        L_INDEX  - index of Merlin local label in table**  Outputs:*        R0 - address of translated label******************************************************************TRANS_LABEL  START         USING COMMON         LONG  I,M         LDA   LT_PTR                   Move pointer to label table into TABLE         STA   TABLE         LDA   LT_PTR+2         STA   TABLE+2         MOVE  NUM,INDEX,#4             Init table index to 4 ASCII zeroes         SHORT I,M         LDY   #0                       Check if key points to Merlin variable         LDA   (KEY)         CMP   #']'         BNE   TOP         LDA   MAC_FLG                  Check if within macro         BEQ   T0000         LDA   KEY_SIZE                 Macro var siz is 2 characters:  ]  1-8         BNE   CONT         RTSCONT     CMP   #2         BNE   T0000         INY                            Check if 2nd key char is digit         LDA   (KEY),Y         CMP   #'1'         BLT   T0000         CMP   #'9'         BGT   T0000         SEC         SBC   #'1'         TAX         LDA   PARMS,X         STA   SYMPARM+2         LA    R0,SYMPARM         RTST0000    JSR   TRANS_VAR         LA    R0,V_STRING              Return pointer to variable         RTS;;   First check if label is already in table.;TOP      LDA   [TABLE]                  Check next table item size         BEQ   NOT_FND                  Check null size         STA   T_SIZE         CMP   KEY_SIZE                 Find element with same size as key         BEQ   STR_SRCHT2       LM    R0,#4                    Increment index         LA    R1,INDEX         JSR   INC_ASCT3       INC   T_SIZE                   Get next table element         ADD4  TABLE,T_SIZE         BRA   TOPSTR_SRCH LDY   KEY_SIZE                 Compare key chars to table charsT4       LDA   [TABLE],Y         DEY         BMI   FOUND         CMP   (KEY),Y         BEQ   T4         BRA   T2NOT_FND  JSR   CHK_END                  Ensure enough room in label table         LDY   #0         LDA   KEY_SIZE                 Store size of new label         STA   [TABLE]T5       LDA   (KEY),Y                  Loop to store label         INY         STA   [TABLE],Y         CPY   KEY_SIZE         BLT   T5         LDA   #0                       Reset end of table         INY         STA   [TABLE],YFOUND    LDY   #0                       Check if local label         LDA   (KEY),Y         CMP   #':'         BNE   T6         MOVE  INDEX,L_INDEX,#4         Return pointer to local label         LA    R0,L_STRING         RTST6       LA    R0,STRING                Else return pointer to global label         RTSSYMPARM  DC    I1'2'         DC    C'&'         DS    1PARMS    DC    C'ABCDEFGH'COUNT    DS    1T_SIZE   DC    I4'0'NUM      DC    C'0000'         END******************************************************************  TRANS_VAR - Translates Merlin variable to ORCA label.**  NOTES:  TRANS_VAR first checks if the variable is in the label*          table.  If it is not, it adds the new variable to the*          end of the table.  The variables are translated*          into the string 'V' + a 4-digit index string + a*          3-digit qualifier attached to the variable.  The*          qualifier is also appended to the variable stored*          in the table.  See TRANS_LABEL above for a more*          thorough discussion of the label table.**  Inputs:*        KEY      - string containing variable extracted from input*                   line, either in LABEL field or OPERAND field*        KEY_SIZE - size of variable*        TABLE    - pointer to label table*        V_INDEX  - index of Merlin variable in table*        NEW_VAR  - set if variable is in LABEL field so that it*                   should be redefined (i.e. VAR_CNT should be*                   incremented if the variable already appears in*                   the label table.**  Outputs:*        V_STRING - the ASCII string 'V' + V_INDEX + VAR_CNT******************************************************************TRANS_VAR START         USING COMMON         SHORT I,M         MOVE  NUM,V_INDEX,#4           Init variable index to 4 ASCII zeroes         LDA   KEY_SIZE                 Save size of original key         STA   SAV_SIZE         CLC                            Increment new key size by 3 to reflect         ADC   #3                       3-byte ASCII variable number attached to         STA   KEY_SIZE                 variable-type labelsTOP      LDY   #1                       Search table loop         LDA   [TABLE]         BEQ   NOT_FND                  Check end of table         STA   T_SIZE         CMP   KEY_SIZE                 Check for label of same size         BNE   CONT         LDA   [TABLE],Y                Check for label which is a variable         CMP   #']'         BNE   CONT         LDY   SAV_SIZE                 Check if table item matches keyT0       LDA   [TABLE],Y         DEY         BMI   FOUND         CMP   (KEY),Y         BEQ   T0CONT     LM    R0,#4                    Increment index         LA    R1,V_INDEX         JSR   INC_ASC         INC   T_SIZE                   Get next table item         ADD4  TABLE,T_SIZE         BRA   TOPNOT_FND  JSR   CHK_END                  Store new variable into table         LDY   #0         LDA   KEY_SIZE                 Store size of new variable         STA   [TABLE]         LDX   SAV_SIZET1       LDA   (KEY),Y         INY         STA   [TABLE],Y         DBNE  X,T1         LM    COUNT,#3                 Store counter for variable into table         LDA   #'0'                     and V_STRING         LDX   #0T2       INY         STA   [TABLE],Y         STA   VAR_CNT,X         INX         DBNE  COUNT,T2         LDA   #0                       Reset end of table         INY         STA   [TABLE],Y         RTSFOUND    LDY   KEY_SIZE                 Move variable counter from table into         LDX   #2                       VAR_CNTF0       LDA   [TABLE],Y         STA   VAR_CNT,X         DEY         DBPL  X,F0         LDA   NEW_VAR                  Check if table's VAR_CNT is to be updatd         BEQ   F2         DEC   NEW_VAR                  Reset new-variable flag to zero         LM    R0,#3         LA    R1,VAR_CNT         JSR   INC_ASC         LDY   KEY_SIZE         LDX   #2F1       LDA   VAR_CNT,X         STA   [TABLE],Y         DEY         DBPL  X,F1F2       RTSNUM      DC    C'0000'COUNT    DS    1T_SIZE   DC    I4'0'SAV_SIZE DS    1         END******************************************************************  WR_MACRO - Writes output line to macro file MY.MACROS**  Notes:  System error returned from WRITE operation*          causes program to issue error message and abort.**  Inputs:*        OUTPUT - Pascal-type string containing translated*                 input line**  Outputs:*        WR_CNT - 4-byte value (low byte first) containing*                 number of bytes written.  The DCB for the*                 write operation is given in COMMON data area.*        OUTPUT - output line is written to the macro file******************************************************************WR_MACRO START         USING COMMON         SHORT I,M         INC   OUTPUT         LDX   OUTPUT         LDA   #RETURN         STA   OUTPUT,X         LONG  I,M         TXA         AND   #$FF         STA   WR_CNT         STZ   WR_CNT+2         WRITE WR_DCB         SHORT I,M         BCS   ERR         RTSERR      TERR  #0         END******************************************************************  ~COUT - Temporary To Use With Rom Text Routines******************************************************************~COUT    START         PHP                            save register state         LONG  I,M                      force long index and accumulator         PHA                            save registers         PHX         PHY         AND   #$00FF                   if a CR to a LF also call         CMP   #$0D                       recursively         BNE   CO1         LDA   #10         JSL   ~COUT         LDA   #$0DCO1      PHA                            call rom character write         _WRITECHAR         PLY                            restore registers         PLX         PLA         PLP                            restore register state         RTL         LONGA OFF         LONGI OFF         END******************************************************************  ~CRIN - Temporary To Use With Rom Text Routines**  Outputs:*        A - character read******************************************************************~CRIN    START         USING COMMON         PHP                            save register state         LONG  I,M                      force long registers         PHX                            save X, Y         PHY         PH2   #0                       call rom character read         PH2   #0         _READCHAR         PLA         AND   #$007F         PLY                            restore X, Y         PLX         PLP                            restore register state         RTL         END