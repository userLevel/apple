         KEEP  UNSIGNED         MCOPY TEST.MACROS******************************************************************  This benchmark performs 10 multiplications, saving the result*  of each.  The multiplications are repeated 1000 times.  The*  UNMUL2 macro calls the routine ~UNMUL2, the unsigned version of*  the library segment ~MUL2.**  Written by Barbara Allred and Mike Westerfield**  By The Byte Works Inc.*  Copyright (c) 1986*  All rights reserved.******************************************************************TEST     START         PHK                            Program & data in same bank         PLB         PUTS  #'Start the clock',CR=T         LDA   #10000         STA   COUNTTOP1     LDX   #10         LDY   #0TOP2     PHX                            save X and Y registers         PHY         LDA   M1,Y         STA   ADDR1         LDA   M2,Y         STA   ADDR2         UNMUL2  ADDR1,ADDR2,TEMP       multiply next pair         PLY                            restore X and Y registers         PLX         LDA   TEMP                     save result of multiply         STA   RES,Y         INY                            update table index         INY         DBNE  X,TOP2         DBNE  COUNT,TOP1               repeat inner loop 1000 times         PUTS  #'Stop the clock',CR=T         LDX   #18                      check resultsTOP3     LDA   RES,X         CMP   ANS,X         BNE   ERROR         DEX         DBPL  X,TOP3         LDA   #0         RTLERROR    PUTS  #'Error in multiply routine',CR=T         LDA   #$FFFF         RTLADDR1    DS    2ADDR2    DS    2TEMP     DS    2COUNT    DS    2RES      DS    20M1       DC    I2'0,11,22,33,44,55,66,77,88,99'M2       DC    I2'5,76,34,123,654,41,92,18,12,99'ANS      DC    I2'0,836,748,4059,28776,2255,6072,1386,1056,9801'         END******************************************************************  ~UNMUL2 - Two-Byte Unsigned Integer Multiply**  Inputs:*        A - multiplicand*        X - multipier**  Outputs:*        A - result*        V - set if an overflow occurred**  Notes:*        1) Assumes long A and X on entry.******************************************************************~UNMUL2  START         LONGA ON         LONGI ONNUM1     EQU   1NUM2     EQU   5         PHD                            set up local data area on the stack         PHA         PHX         PHX         TSC         TCD         LDY   #16                      do 16 bit multiply         LDA   #0                       set up the high byte of the resultML3      LSR   NUM1+2                   test the LSB         BCC   ML4                      br if it is off         CLC                            add in partial product         ADC   NUM2ML4      ROR   A                        multiply answer by 2         ROR   NUM1         DEY                            loop         BNE   ML3         TAX                            check for overflow         BNE   OVFL         LDA   NUM1         BMI   OVFLML5      PLY                            restore stack, DP         PLY         PLY         PLD         CLV         RTLOVFL     PLY                            restore stack, DP         PLY         PLY         PLD         SEP   #%01000000               SEV         RTL         END