******************************************************************  SYSTAND - Tangent**  By Mike Westerfield*  Copyright (C) April 1985, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - argument**  OUTPUTS:*        SYSS1 - result******************************************************************SYSTAND  START         USING SYSCOM         MOVE  SYSS1,TX2,#LUDP         JSR   SYSCOSD         LDX   #LUDP-1DT1      LDA   SYSS1,X         STA   TX3,X         LDA   TX2,X         STA   SYSS1,X         DBPL  X,DT1         JSR   SYSSIND         MOVE  TX3,SYSS2,#LUDP         JMP   SYSDIVD         END******************************************************************  SYSCOSD - Cosine*  SYSSIND - Sine**  By Mike Westerfield*  Copyright (C) April 1985, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - argument**  OUTPUTS:*        SYSS1 - result**  Notes:*        1)  Algorithm from Cody, pp 125-149.  Table 3345 from*            Hart.******************************************************************SYSCOSD  START         USING SYSCOM;;  Change argument: COS(X) = SIN(X+PI/2);         MOVE  HALFPI,SYSS2,#LUDP         JSR   SYSADDD;;  Remove multiples of 2*PI, mapping the unit circle from 0..2*PI to 0..4.;SYSSIND  ENTRY         LDA   SYSS1                    quit if zero         AND   #FZERO         BNE   RTS         LM    LSIGN,SYSS1              remove and save sign         ASL   SYSS1         LSR   SYSS1         LDX   #LUDP-1                  check for maxRR1      LDA   SYSS1,X         STA   TX1,X         LDA   MAX,X         STA   SYSS2,X         DBPL  X,RR1         JSR   SYSCMPD         BLE   RR3         FERR  #FERR5                   inexact         LM    SYSS1,#FZERORTS      RTSRR3      LDX   #LUDP-1                  multiply by 2/PIRR3A     LDA   TX1,X         STA   SYSS1,X         LDA   IHPI,X         STA   SYSS2,X         DBPL  X,RR3A         JSR   SYSMULDRR4      LDA   SYSE1                    use extended result to maintain         CMP   #$80                      precision while removing multiples         BNE   RR4A                      of PI/2         LDA   SYSE1+1         CMP   #$01RR4A     BLT   RR5         JSR   SYSROLD         LDA   SYSE1+1         BNE   RR4B         DEC   SYSE1RR4B     DEC   SYSE1+1         LDA   SYSE1         ORA   SYSE1+1         BNE   RR4RR5      LDX   #14                      normalizeRR6      LDA   SYSM1,X         BNE   RR7         DBPL  X,RR6         LM    SYSS1,#FZERO         RTSRR7      LDA   SYSM1         BMI   RR8         JSR   SYSROLD         LDA   SYSE1+1         BNE   RR7A         DEC   SYSE1RR7A     DEC   SYSE1+1         LDA   SYSE1         ORA   SYSE1+1         BNE   RR7         FERR  #FERR4                   underflow         RTSRR8      ASL   SYSS1                    take absolute value         LSR   SYSS1;;  Reduce range from 0..4 to 0..1.;         LDA   SYSE1                    quit if < .5         LDX   SYSE1+1         CMP   #$7F         BNE   RR9         CPX   #$FERR9      BLT   SG1         CMP   #$80                     branch if < 2         BLT   RR10         MOVE  N4,SYSS2,#LUDP           SYSS1 = 4-SYSS1         LDA   SYSS1         EOR   #$80         STA   SYSS1         JSR   SYSADDD         LDA   LSIGN                    SIGN = -SIGN         EOR   #$80         STA   LSIGNRR10     LDA   SYSE1+1                  quit if < 1         CMP   #$7F         BNE   RR11         LDA   SYSE1         CMP   #$FFRR11     BLT   SG1         MOVE  N2,SYSS2,#LUDP           SYSS1 = 2-SYSS1         LDA   SYSS1         EOR   #$80         STA   SYSS1         JSR   SYSADDD;;  Done if SYSS1 < EPS (small angle approx.);SG1      LDA   SYSE1         CMP   EPS         BNE   SG2         LDA   SYSE1+1         CMP   EPS+1SG2      BGE   PE1         MOVE  HALFPI,SYSS2,#LUDP       map to radians         JSR   SYSMULD         JMP   SS1;;  Polynomial expansion;PE1      LDX   #LUDP-1PE2      LDA   SYSS1,X         STA   SYSS2,X         STA   TX1,X         DBPL  X,PE2         JSR   SYSMULD         LA    WR0,P8         LM    WR2,#8         JSR   SYSPOLD         MOVE  TX1,SYSS2,#LUDP         JSR   SYSMULD;;  Set sign.;SS1      ASL   SYSS1         ASL   LSIGN         ROR   SYSS1         RTS;;  Constants.;LSIGN    DS    1HALFPI   DC    H'00 7FFF C90FDAA2 2168C0' PI/2IHPI     DC    H'00 7FFE A2F9836E 4E4415' 2/PIMAX      DC    H'00 801A C90FDAA0 0000'   210828714N2       DC    H'00 8000 80000000 0000'   2N4       DC    H'00 8001 80000000 000000' 4EPS      DC    H'7FE4'                  exponent of 1.4901161E-8P8       DC    D'.587061098171E-11'         DC    D'-.66843217206396E-9'         DC    D'.5692134872719023E-7'         DC    D'-.359884300720869272E-5'         DC    D'.1604411847068220716E-3'         DC    D'-.468175413530264260121E-2'         DC    D'.7969262624616543562977E-1'         DC    D'-.64596409750624619108547'         DC    D'1.5707963267948966188272'         END******************************************************************  SYSPWRD - X^Y**  By Mike Westerfield*  Copyright (C) April 1985, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - X in X^Y*        SYSS1 - Y in X^Y**  OUTPUTS:*        SYSS1 - result******************************************************************SYSPWRD  START         USING SYSCOM         MOVE  SYSS2,TX4,#LUDP         JSR   SYSLNXD         MOVE  TX4,SYSS2,#LUDP         JSR   SYSMULD         JMP   SYSEXPD         END******************************************************************  SYSLNXD - Natural Log**  By Mike Westerfield*  Copyright (C) April 1985, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - argument**  OUTPUTS:*        SYSS1 - result**  Notes:*        1) Developed from Hart, pp 105-111 and table 2665.******************************************************************SYSLNXD  START         USING SYSCOM;;  Error if negative or zero argument.;         LDA   SYSS1         BMI   ER1         AND   #FZERO         BEQ   SF1ER1      FERR  #FERR1                   invalid operation         RTS;;  Split into component parts.;SF1      MOVE  SYSE1,EXP                save exponent         LM    SYSE1+1,#$FE             .5 <= X < 1         LM    SYSE1,#$7F         MOVE  SQR2,SYSS2,#LUDP         1/SQRT(2) <= X < SQRT(2)         JSR   SYSMULD;;  TX1 = (X-1)/(X+1);         LDX   #LUDP-1DZ1      LDA   SYSS1,X         STA   TX1,X         LDA   ONE,X         STA   SYSS2,X         DBPL  X,DZ1         JSR   SYSADDD         LDX   #LUDP-1DZ2      LDA   SYSS1,X         STA   TX2,X         LDA   TX1,X         STA   SYSS1,X         LDA   ONE,X         STA   SYSS2,X         DBPL  X,DZ2         JSR   SYSSUBD         MOVE  TX2,SYSS2,#LUDP         JSR   SYSDIVD;;  log(X) = P(TX1^2)*TX1;         LDX   #LUDP-1ES1      LDA   SYSS1,X         STA   SYSS2,X         STA   TX1,X         DBPL  X,ES1         JSR   SYSMULD         LA    WR0,P6         LM    WR2,#6         JSR   SYSPOLD         MOVE  TX1,SYSS2,#LUDP         JSR   SYSMULD;;  Result = ln(2)*(X/ln(2) - .5 + float(EXP));         MOVE  ILN2,SYSS2,#LUDP         JSR   SYSMULD         MOVE  NI2,SYSS2,#LUDP         JSR   SYSADDD         MOVE  SYSS1,TX1,#LUDP         CLC         LDA   EXP+1         ADC   #$2         STA   SYSS1         LDA   EXP         ADC   #$80         STA   SYSS1+1         JSR   SYSCV2D         MOVE  TX1,SYSS2,#LUDP         JSR   SYSADDD         MOVE  LN2,SYSS2,#LUDP         JMP   SYSMULD;;  Constants;EXP      DS    2                        exponent storage areaNI2      DC    H'80 7FFE 80000000 0000'   -1/2LN2      DC    H'00 7FFE B17217F7 D1CF7A' 0.69314718ILN2     DC    H'00 7FFF B8AA3B29 5C17F1' 1.442695041SQR2     DC    H'00 7FFF B504F333 F9DE65' 1.4142136P6       DC    D'0.16948212488'         DC    D'0.1811136267967'         DC    D'0.22223823332791'         DC    D'0.2857140915904889'         DC    D'0.400000001206045365'         DC    D'0.6666666666633660894'         DC    D'2.0000000000000002610'         RTS         END******************************************************************  SYSEXPD - Exponent**  By Mike Westerfield*  Copyright (C) April 1985, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - argument**  OUTPUTS:*        SYSS1 - result**  Notes:*        1) Developed from Hart, pp 96-104 and table 1323.******************************************************************SYSEXPD  START         USING SYSCOM;;  Divide by ln(2) to convert the problem from finding exp(X) to;  finding 2^X.;         MOVE  ILN2,SYSS2,#LUDP         JSR   SYSMULD;;  Reduce the range to -1/2 < X < 1/2 by:;        1) removing the integer part.;        2) dividing by 2 if result > 1/2;         LDA   #0                       remove integer part         STA   EXP         STA   EXP+1         STA   DBY2         LDA   SYSS1         AND   #FZERO         JNE   PW1EX1      LDA   SYSE1         CMP   #$7F         BNE   EX2         LDA   SYSE1+1         CMP   #$FFEX2      BLT   EX3         CLC         JSR   SYSROLD2         LDA   SYSE1+1         BNE   EX2A         DEC   SYSE1EX2A     DEC   SYSE1+1         LDA   SYSE1         ORA   SYSE1+1         BEQ   UFL         ROL   EXP+1         ROL   EXP         BPL   EX1         FERR  #FERR3                   overflow         RTSUFL      FERR  #FERR4                   underflow         RTSEX3      LDX   #112                     normalize fractional partEX4      LDA   SYSM1         BMI   EX5         CLC         JSR   SYSROLD2         LDA   SYSE1+1         BNE   EX4A         DEC   SYSE1EX4A     DEC   SYSE1+1         LDA   SYSE1         ORA   SYSE1+1         BEQ   UFL         DBPL  X,EX4         LDA   SYSS1         ORA   #FZERO         STA   SYSS1EX5      LDA   SYSS1         BPL   EX6         SEC         LDA   #0         SBC   EXP+1         STA   EXP+1         LDA   #0         SBC   EXP         STA   EXPEX6      LDX   SYSE1                    if ABS(X) >= 1/2 then divide by 2         INX         BPL   PW1         LDX   SYSE1+1         INX         BNE   PW1         INC   DBY2         LDA   SYSE1+1         BNE   EX7         DEC   SYSE1EX7      DEC   SYSE1+1         LDA   SYSE1         ORA   SYSE1+1         BEQ   UFL;;  X = 2^X = 2*X*P(X^2)/(Q(X^2)-X*P(X^2))+1;PW1      LDX   #LUDP-1                  save XPW1A     LDA   SYSS1,X         STA   SYSS2,X         STA   TX1,X         DBPL  X,PW1A         JSR   SYSMULD                  compute X^2         MOVE  SYSS1,TX2,#LUDP          save X^2         LA    WR0,P2                   compute P(X^2)*X         LM    WR2,#2         JSR   SYSPOLD         MOVE  TX1,SYSS2,#LUDP         JSR   SYSMULD         LDX   #LUDP-1                  save P(X^2)PW2      LDA   SYSS1,X                   and recover X^2         STA   TX1,X         LDA   TX2,X         STA   SYSS1,X         DBPL  X,PW2         LA    WR0,Q2                   compute Q(X^2)         LM    WR2,#2         JSR   SYSPOLD         MOVE  TX1,SYSS2,#LUDP          compute denominator         JSR   SYSSUBD         LDX   #LUDP-1                  do the divisionPW3      LDA   SYSS1,X         STA   SYSS2,X         LDA   TX1,X         STA   SYSS1,X         DBPL  X,PW3         JSR   SYSDIVD         INC   SYSE1+1                  multiply by 2         BNE   PW4         INC   SYSE1         BEQ   OVFLPW4      MOVE  ONE,SYSS2,#LUDP         JSR   SYSADDD;;  If division by 2 was used during range reduction, square the result.;         LDA   DBY2         BEQ   FN1         MOVE  SYSS1,SYSS2,#LUDP         JSR   SYSMULD;;  Add integer part to the exponent.;FN1      CLC         LDA   SYSE1         BPL   FN2         LDA   SYSE1+1         ADC   EXP+1         STA   SYSE1+1         LDA   SYSE1         ADC   EXP         STA   SYSE1         BMI   FN3OVFL     FERR  #FERR3                   overflow         RTSFN2      LDA   SYSE1+1         ADC   EXP+1         STA   SYSE1+1         LDA   SYSE1         ADC   EXP         STA   SYSE1FN3      RTS;;  Constants;EXP      DS    2                        integer part of argumentDBY2     DS    1                        divide by 2 flagILN2     DC    H'00 7FFF B8AA3B29 5C17F1' 1.442695041P2       DC    D'0.02309432127295385660'         DC    D'20.20170000695312604'         DC    D'1513.864173046535620'Q2       DC    D'1'         DC    D'233.1782320514310358'         DC    D'4368.088670067416986'         END******************************************************************  SYSINTD - Integer**  By Mike Westerfield*  Copyright (C) April 1985, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - argument**  OUTPUTS:*        SYSS1 - result******************************************************************SYSINTD  START         USING SYSCOM;;  If <0 then start by subtracting one.;         LDA   SYSS1         BPL   AB1         MOVE  ONE,SYSS2,#LUDP         JSR   SYSSUBD;;  If ABS(X) < 1 then return 0;AB1      LDX   SYSE1         LDA   SYSE1+1         CPX   #$7F         BNE   AB2         CMP   #$FFAB2      BGE   LG1         LM    SYSS1,#FZERO         RTS;;  If ABS(X) > 2^56 return;LG1      CPX   #$80         BLT   ZB0         BNE   RTS         CMP   #$36         BGE   RTS;;  Zero all bits to the right of the decimal place.;ZB0      CLC                            compute start disp         ADC   #$2         PHA         MLSR  A,3         TAX         PLA                            create bit mask         AND   #$7         BEQ   ZB2         TAY         LDA   #0ZB1      SEC         ROR   A         DBNE  Y,ZB1         AND   SYSM1,X                  zero partial byte         STA   SYSM1,X         INX         LDA   #0                       zero remaining bytesZB2      STA   SYSM1,X         INX         CPX   #8         BNE   ZB2RTS      RTS         END         APPEND DP.2