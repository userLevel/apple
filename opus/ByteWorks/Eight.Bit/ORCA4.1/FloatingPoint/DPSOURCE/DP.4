******************************************************************  SYSDIVD - Double Precision Divide**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - sign and flags for numerator*        SYSE1 - exponent for numerator*        SYSM1 - mantissa for numerator*        SYSS2 - sign and flags for denominator*        SYSE2 - exponent for denominator*        SYSM2 - mantissa for denominator**  OUTPUTS:*        SYSS1 - sign and flags for result*        SYSE1 - exponent for result*        SYSM1 - mantissa for result******************************************************************SYSDIVD  START;;  Exception and special case handling.;         LDA   SYSS2                    set sign         EOR   SYSS1         ASL   SYSS1         ASL   A         ROR   SYSS1         LDA   #FINF                    check for inf/inf         BIT   SYSS1         BEQ   IN2         BIT   SYSS2         BEQ   RTS         FERR  #FERR1         RTSIN2      BIT   SYSS2                    check for x/inf, with result of 0         BEQ   IN3         MOVE  #0,SYSE1,#LUDP-1         LDA   SYSS1         ORA   #FZERO         STA   SYSS1         RTSIN3      LDA   #FZERO                   check for division by 0         BIT   SYSS2         BEQ   IN5         BIT   SYSS1                    check for 0/0         BEQ   IN4         FERR  #FERR1         RTSIN4      FERR  #FERR2RTS      RTSIN5      BIT   SYSS1                    check for 0/X         BNE   RTS;;  Initialization;IN6      SEC                            subtract exponents         LDA   SYSE1+1         SBC   SYSE2+1         TAY         LDA   SYSE1         SBC   SYSE2         EOR   #$80         TAX         EOR   SYSE1         BPL   IN7         LDA   SYSE1         EOR   SYSE2         BPL   IN7         LDA   SYSE1         BPL   UFLOVFL     FERR  #FERR3         RTSUFL      FERR  #FERR4         RTSIN7      STX   SYSE1         STY   SYSE1+1         LDX   #6                       move the input number to a work area         LDY   #0                        and zero the number areaIN8      LDA   SYSM1,X         STA   SYSM1+7,X         STY   SYSM1,X         DBPL  X,IN8         JSR   CP12         BLT   IN9         LSR   SYSM1+7         ROR   SYSM1+8         ROR   SYSM1+9         ROR   SYSM1+10         ROR   SYSM1+11         ROR   SYSM1+12         ROR   SYSM1+13         JMP   IN10IN9      LDA   SYSE1+1         BNE   IN9A         DEC   SYSE1         BEQ   UFLIN9A     DEC   SYSE1+1IN10     LSR   SYSM2         ROR   SYSM2+1         ROR   SYSM2+2         ROR   SYSM2+3         ROR   SYSM2+4         ROR   SYSM2+5         ROR   SYSM2+6;;  Do 56 bit divide until left justified.;         LDX   #-57                     set shift countDV1      JSR   CP12                     see if subtraction will work         BLT   DV2         SEC                            subtract         LDA   SYSM1+13         SBC   SYSM2+6         STA   SYSM1+13         LDA   SYSM1+12         SBC   SYSM2+5         STA   SYSM1+12         LDA   SYSM1+11         SBC   SYSM2+4         STA   SYSM1+11         LDA   SYSM1+10         SBC   SYSM2+3         STA   SYSM1+10         LDA   SYSM1+9         SBC   SYSM2+2         STA   SYSM1+9         LDA   SYSM1+8         SBC   SYSM2+1         STA   SYSM1+8         LDA   SYSM1+7         SBC   SYSM2         STA   SYSM1+7DV2      ROL   SYSM1+6                  shift in divide bit         ROL   SYSM1+5         ROL   SYSM1+4         ROL   SYSM1+3         ROL   SYSM1+2         ROL   SYSM1+1         ROL   SYSM1         ASL   SYSM1+13                 adjust numerator         ROL   SYSM1+12         ROL   SYSM1+11         ROL   SYSM1+10         ROL   SYSM1+9         ROL   SYSM1+8         ROL   SYSM1+7         INX                            increment shift count         LDA   SYSM1                    check for done         BPL   DV1         INX                            account for extra shifts and check         BMI   OVFL2                     for overflows and underflows         STX   SYSE2+1         CLC         LDA   SYSE1+1         SBC   SYSE2+1         STA   SYSE1+1         LDA   SYSE1         SBC   #0         STA   SYSE1         BCC   UFL2         ORA   SYSE1+1         BEQ   UFL2         RTSUFL2     JMP   UFLOVFL2    JMP   OVFL;;  CP12: Compare SYSM1+4 and SYSM2;CP12     LDA   SYSM1+7         CMP   SYSM2         BNE   CP1         LDA   SYSM1+8         CMP   SYSM2+1         BNE   CP1         LDA   SYSM1+9         CMP   SYSM2+2         BNE   CP1         LDA   SYSM1+10         CMP   SYSM2+3         BNE   CP1         LDA   SYSM1+11         CMP   SYSM2+4         BNE   CP1         LDA   SYSM1+12         CMP   SYSM2+5         BNE   CP1         LDA   SYSM1+13         CMP   SYSM2+6CP1      RTS         END******************************************************************  SYSMULD - Double Precision Multiply**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - sign and flags for multiplicand*        SYSE1 - exponent for multiplicand*        SYSM1 - mantissa for multiplicand*        SYSS2 - sign and flags for multiplier*        SYSE2 - exponent for multiplier*        SYSM2 - mantissa for multiplier**  OUTPUTS:*        SYSS1 - sign and flags for result*        SYSE1 - exponent for result*        SYSM1 - mantissa for result******************************************************************SYSMULD  START;;  Exception and special case handling.;         LDA   SYSS1                    set the sign         EOR   SYSS2         ASL   SYSS1         ASL   A         ROR   SYSS1         LDA   #FINF                    inf*inf = inf         BIT   SYSS1         BEQ   SC1         BIT   SYSS2         BNE   RTS         LDA   SYSS2                    inf*0 is an error, inf*X = inf         AND   #FZERO         BEQ   RTSERR1     FERR  #FERR1RTS      RTSSC1      LDA   #FZERO                   0*inf is an error         BIT   SYSS1         BEQ   SC2         LDA   SYSS2         AND   #FINF         BNE   ERR1         RTSSC2      BIT   SYSS2                    X*0 = 0         BEQ   SC3         ORA   SYSS1         STA   SYSS1         MOVE  #0,SYSE1,#LUDP-1         RTSSC3      LDA   #FINF                    x*inf = inf         BIT   SYSS2         BEQ   IN1         ORA   SYSS1         STA   SYSS1         RTS;;  Initialization;IN1      LDA   SYSE1                    add exponents         EOR   SYSE2                    split on exponent signs         BMI   IN2         JSR   AEXP                     both the same: add         LDA   SYSE1         EOR   SYSE2         BPL   IN3OVFL     FERR  #FERR3         RTSIN2      JSR   AEXP                     signs different: overflow is not!                                        possibleIN3      LSR   SYSM2                    shield from overflow         ROR   SYSM2+1         ROR   SYSM2+2         ROR   SYSM2+3         ROR   SYSM2+4         ROR   SYSM2+5         ROR   SYSM2+6IN4      LDX   #6                       move number to work area and zero M1         LDY   #0IN5      LDA   SYSM1,X         STA   SYSM1+7,X         STY   SYSM1,X         DBPL  X,IN5;;  Multiply the mantissas;         LDY   #56                      do 56 bit multiplyML1      LDA   SYSM1+13         BNE   ML3         CPY   #8         BLT   ML3         LDX   #12                      shift right 8 bitsML2      LDA   SYSM1,X         STA   SYSM1+1,X         DBPL  X,ML2         LM    SYSM1,#0         SEC         TYA         SBC   #8         TAY         BNE   ML1         BEQ   NM1ML3      LSR   SYSM1                    shift right one bit         ROR   SYSM1+1         ROR   SYSM1+2         ROR   SYSM1+3         ROR   SYSM1+4         ROR   SYSM1+5         ROR   SYSM1+6         ROR   SYSM1+7         ROR   SYSM1+8         ROR   SYSM1+9         ROR   SYSM1+10         ROR   SYSM1+11         ROR   SYSM1+12         ROR   SYSM1+13         BCC   ML4         CLC                            add partial product         LDA   SYSM1+6         ADC   SYSM2+6         STA   SYSM1+6         LDA   SYSM1+5         ADC   SYSM2+5         STA   SYSM1+5         LDA   SYSM1+4         ADC   SYSM2+4         STA   SYSM1+4         LDA   SYSM1+3         ADC   SYSM2+3         STA   SYSM1+3         LDA   SYSM1+2         ADC   SYSM2+2         STA   SYSM1+2         LDA   SYSM1+1         ADC   SYSM2+1         STA   SYSM1+1         LDA   SYSM1         ADC   SYSM2         STA   SYSM1ML4      DEY                            next bit         BNE   ML1;;  Normalize the result;NM1      LDA   SYSM1                    shift left 1 bit if the shield bit was         BMI   NM2                       not used         JMP   SYSROLDNM2      INC   SYSE1+1                  correct for shield bit         BNE   NM3         INC   SYSE1         JEQ   OVFLNM3      RTS;;  AEXP: add exponents;AEXP     CLC         LDA   SYSE1+1         ADC   SYSE2+1         STA   SYSE1+1         LDA   SYSE1         ADC   SYSE2         EOR   #$80         STA   SYSE1         INC   SYSE1+1         BNE   AE2         INC   SYSE1AE2      RTS         END         APPEND DP.5