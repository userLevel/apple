******************************************************************  STACK - Stack a Token**  INPUTS:*        STK - stack pointer*        SCODE - token to stack**  OUTPUTS:*        C - cleared for a stack overflow******************************************************************STACK    START         USING COMMON         DEBUG STACK         ADD2  STK,#LEN+2,R0            check for impending overflow         CMPW  R0,STKE         BGE   ERR         MOVE  SCODE,{STK},#LEN+2       stack the variable         MOVE  R0,STK                   update the pointer         SEC         RTSERR      JSR   SEROR         PUTS  #'Stack overflow.',CR=T         CLC         RTS         END******************************************************************  STOKE - Read a Token**  INPUTS:*        LINE - input line (string format)*        NPARIN - # unmatched (*        NFLAG - number expected flag*        CC - position of next char in line**  OUTPUTS:*        SCODE - one of the following codes (char format):*              G - SIGN*              N - negate*              Q - SQRT*              T - TAN*              S - SIN*              C - COS*              A - ARCTAN*              L - LN*              E - EXP*              I - INT*              V - variable*              X - constant*              B - ABS*              R - RANDOM*              ( - left parin*              ) - right parin*              ^ - power*              * - multiply*              / - divide*              + - add*              - - subtract*              = - equal*              ? - print*              RETURN - end of line*        SISP - in stack priority*        OSP - out of stack priority*        SVAL - vlaue of constant or mane of variable******************************************************************STOKE    START         USING COMMON         DEBUG STOKE;;  Check for end of line.;         JSR   SCHAR         BCS   ST1         LDA   NPARIN         JNE   MERR         LM    SCODE,#RETURN         SEC         RTS;;  Scan for token.;ST1      LM    TOKNUM,#0                init for search         LA    R0,TOKESST2      LDX   CC                       get length of token         DEX         LDY   #0         LDA   (R0),Y         JEQ   CV1         STA   LENGTH         INYST3      LDA   (R0),Y                   check for match         CMP   LINE+2,X         BNE   ST4         INY         INX         DBNE  LENGTH,ST3         BEQ   TK1ST4      LDY   #0                       next token         LDA   (R0),Y         SEC         ADC   R0         STA   R0         BCC   ST5         INC   R1ST5      INC   TOKNUM         JMP   ST2;;  Token found - process it.;TK1      STX   CC                       set token info         LDX   TOKNUM         LDA   ISP,X         STA   SISP         STA   OSP         LDA   TOKE,X         STA   SCODE         CMP   #'('                     check for special types         BNE   TK2         LDA   NFLAG         CMP   #1         JEQ   OERR         LM    NFLAG,#0         INC   NPARIN         LM    SISP,#2         LM    OSP,#11         SEC         RTSTK2      CMP   #'='         BEQ   TK3         CMP   #'?'         BNE   TK4TK3      LM    NFLAG,#0         INC   NOPS         LDA   NOPS         CMP   #1         JNE   TERR         SEC         RTSTK4      LDX   NFLAG         CPX   #2         JEQ   PERR         CMP   #'-'         BNE   TK6         LDA   NFLAG         BEQ   TK5         LM    NFLAG,#0         SEC         RTSTK5      LM    SCODE,#'N'         LM    (SISP,OSP),#8         SEC         RTSTK6      CMP   #')'         BNE   TK6A         DEC   NPARIN         JMI   RERR         SEC         RTSTK6A     CMP   #'R'         BNE   TK7         LDA   NFLAG         CMP   #1         JEQ   OERR         LM    NFLAG,#1         SEC         RTSTK7      LDX   TOKNUM                   functions must appear where numbers         LDA   FUNCTION,X                are expected         BEQ   TK8         LDA   NFLAG         BNE   OERR         LM    NFLAG,#2         SEC         RTSTK8      LDA   NFLAG                    must be expecting an operation         JEQ   NERR         LM    NFLAG,#0         SEC         RTS;;  Check for variable.;CV1      LDA   NFLAG                    flag error if a number is not expected         CMP   #2         BEQ   PERR         CMP   #1         BEQ   OERR         INC   NFLAG                    indicate that an operation comes next         LDY   CC                       branch if not an alphabetic character         LDA   LINE+1,Y         JSR   SALID         BCC   NT1         STA   SVAL                     save the variable name         LM    SCODE,#'V'               set the variable code         SEC         RTS;;  Number Found.;NT1      DEC   CC         JSR   STREV         BCC   RTS         LM    SCODE,#'X'         SECRTS      RTS;;  Error messages.;PERR     JSR   SEROR         PUTS  #'Left perenthesis expected.',CR=T         CLC         RTSOERR     JSR   SEROR         PUTS  #'Operation expected.',CR=T         CLC         RTSNERR     JSR   SEROR         PUTS  #'Number expected.',CR=T         CLC         RTSRERR     JSR   SEROR         PUTS  #'Too many right parenthesis.',CR=T         CLC         RTSTERR     JSR   SEROR         PUTS  #'Too many actions.',CR=T         CLC         RTSMERR     JSR   SEROR         PUTS  #'Missing right parenthesis.',CR=T         CLC         RTS;;  Data areas.;TOKES    DW    ?         DW    '='         DW    +         DW    -         DW    *         DW    /         DW    ^         DW    '('         DW    )         DW    SIGN         DW    SQRT         DW    TAN         DW    SIN         DW    COS         DW    ARCTAN         DW    LN         DW    EXP         DW    INT         DW    ABS         DW    RANDOM         DC    I1'0'TOKE     DC    C'?=+-*/^()GQTSCALEIBR'ISP      DC    I1'1,1,4,4,5,5,6,9,9'         DC    I1'7,7,7,7,7,7,7,7,7,7,7'FUNCTION DC    I1'0,0,0,0,0,0,0,0,0'         DC    I1'1,1,1,1,1,1,1,1,1,1,1'TOKNUM   DS    1LENGTH   DS    1         END******************************************************************  STRCE - Debug Trace Facility**  If the global constant DEBUG is true this subroutine will*  be placed in the code.  If the variable TRACE is true, it*  will print the characters appearing on the DEBUG macros*  used in the program.**  INPUTS:*        TRACE - trace on flag******************************************************************STRCE    START         USING COMMON         AIF   DEBUG=0,.A         PHP                            save variables         STA   LA         STY   LY         STX   LX         PLA         STA   LP         MOVE  R0,TR0         PLA                            get the address of the characters         STA   R0         PLA         STA   R1         INC2  R0         LDA   TRACE                    quit if trace is off         JEQ   LB2         LDX   #10                      write the characters         LDY   #0LB1      LDA   (R0),Y         JSR   SYSCOUT         INY         DBNE  X,LB1         LDA   #RETURN         JSR   SYSCOUTLB2      ADD2  R0,#9                    get the return address         LDA   R1         PHA         LDA   R0         PHA         MOVE  TR0,R0                   restore variables         LDY   LY         LDX   LX         LDA   LP         PHA         LDA   LA         PLP         RTS;;  Write a byte to the screen.;BYTE     PHA         MLSR  A,4         ORA   #'0'         CMP   #'9'+1         BLT   BT1         ADC   #6BT1      JSR   SYSCOUT         PLA         AND   #$F         ORA   #'0'         CMP   #'9'+1         BLT   BT2         ADC   #6BT2      JSR   SYSCOUT         RTSLA       DS    1LX       DS    1LY       DS    1LP       DS    1TR0      DS    2.A         END******************************************************************  STREV - String Evaluation**  Evaluates numeric constants in the input line.**  INPUTS:*        LINE - input line*        CC - points to the first char of the string**  OUTPUTS:*        SVAL - value of the string*        CC - points to the first char past the string*        C - clear if error******************************************************************STREV    START         USING COMMON         DEBUG STREV         JSR   SCHAR                    go do a hex number if the char is $         CMP   #'$'         JEQ   SHXEV         DEC   CC         LDX   #0                       get the number from the input line         STX   EXPTR1      JSR   SCHAR         BCC   TR2TR1D     JSR   SYSNMID         BCS   TR1A         LDY   EXP                      check for a decimal point         BNE   TR1E         CMP   #'.'         BNE   TR1F         INC   EXP         JMP   TR1ATR1E     DEY                            check for an exponent         BNE   TR2TR1F     JSR   SHIFT         CMP   #'E'         BNE   TR2TR1B     STA   STRING+2,X         LM    EXP,#2         INX         CPX   STRING         BGE   TR1G         JSR   SCHAR         CMP   #'-'         BEQ   TR1A         CMP   #'+'         BNE   TR1DTR1A     STA   STRING+2,X         INX         CPX   STRING         BLT   TR1TR1G     JSR   SEROR         PUTS  #'Number too long.',CR=T         CLC         RTSTR2      CPX   #0                       check for zero length         BNE   TR3         JSR   SEROR         PUTS  #'Illegal symbol.',CR=T         CLC         RTSTR3      STX   STRING+1                 convert string to value         CNVSD STRING,SVAL         DEC   CC         SEC         RTSSTRING   DSTR  ,30EXP      DS    1                        exponent flag         END******************************************************************  SUSTK - Unstack a Token**  INPUTS:*        STK - stack pointer*        STKS - lowest point in stack**  OUTPUTS:*        STK - updated*        SCODE - token from TOS*        C - clear if stack was empty******************************************************************SUSTK    START         USING COMMON         DEBUG SUSTK         SUB2  STK,#LEN+2               recover TOS token         CMPW  STK,STKS         BLT   ERR         MOVE  {STK},SCODE,#LEN+2         SEC         RTSERR      ADD2  STK,#LEN+2         JSR   SEROR         PUTS  #'Stack underflow.',CR=T         CLC         RTS         END