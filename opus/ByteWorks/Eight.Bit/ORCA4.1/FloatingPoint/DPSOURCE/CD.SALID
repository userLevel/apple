******************************************************************  SALID - Alphabetic Identification**  INPUTS:*        A - character to check**  OUTPUTS:*        C - set if alphabetic, else clear******************************************************************SALID    START         DEBUG SALID         CMP   #'A'         BCC   RTS         CMP   #'Z'+1         BCC   SEC         CLC         RTSSEC      SECRTS      RTS         END******************************************************************  SCALC - Top Level Control******************************************************************SCALC    START         USING COMMON         DEBUG SCALCCL1      PUTC  #'#'                     get an input line         LDY   LINE         LDA   #' 'CL1A     STA   LINE+1,Y         DBNE  Y,CL1A         GETS  LINE,CR=T         LDA   LINE+1         BEQ   CL1         TAX                            convert it to upper-caseCL2      LDA   LINE+1,X         JSR   SHIFT         STA   LINE+1,X         DBNE  X,CL2         LDX   #4                       check for QUITCL5      LDA   QUIT,X         CMP   LINE+1,X         BNE   CL6         DBPL  X,CL5         RTS                            quitCL6      JSR   SEVAL                    evaluate the expression         PUTCR         JMP   CL1QUIT     DW    QUIT         END******************************************************************  SCHAR - Get a Character from LINE**  Returns the next non-blank character from the input line.**  INPUTS:*        LINE - input line*        CC - pointer in line**  OUTPUTS:*        CC - updated*        A - character*        C - clear if EOLN******************************************************************SCHAR    START         USING COMMON         DEBUG SCHAR         LDY   CCCH1      CPY   LINE+1         BGE   CH2         LDA   LINE+2,Y         INY         CMP   #' '         BEQ   CH1         STY   CC         SEC         RTSCH2      INY         STY   CC         CLC         RTS         END******************************************************************  SEROR - Shows Error Location**  INPUTS:*        CC - current cursor position******************************************************************SEROR    START         USING COMMON         DEBUG SEROR         PRBL  CC         PUTS  #'^ '         RTS         END******************************************************************  SEVAL - Evaluate a Line**  INPUTS:*        LINE - string containing the input line******************************************************************SEVAL    START         USING COMMON         DEBUG SEVAL;;  Initialization.;         LM    CC,#0                    character counter         MOVE  SYSESTMIN,SYSESTE        reset evaluation stack         MOVE  STKS,STK                 reset work stack         LDA   #0                       init token variables:         STA   NPARIN                     number of unmatched parenthesis         STA   NFLAG                      number expected flag         STA   NOPS                       number of opernads for functions         LM    SCODE,#RETURN         LM    SISP,#0         JSR   STACK         BCC   FT3;;  Get the first token.  Insure that it is a ? or a variable followed by a =.;         JSR   STOKE                    get a token         BCC   FT3         LDA   SCODE                    OK if ?         CMP   #'?'         BEQ   FT1         CMP   #'V'                     make sure it's a variable         BNE   FT2         JSR   STACK         JSR   STOKE                    ... followed by =         BCC   FT3         LDA   SCODE         CMP   #'='         BNE   FT2FT1      JSR   STACK         BCS   GT1         BCC   FT3FT2      JSR   SEROR         PUTS  #'No action requested.',CR=TFT3      RTS;;  Get a token and go to the apropriate handler.;GT1      JSR   STOKE         BCC   FT3         LDA   SCODE         CMP   #RETURN         JEQ   EL1         CMP   #'X'         JEQ   OP1         CMP   #'V'         BEQ   VR1;;  Handle an operation.;PR1      CMP   #')'                     if ( then unstack until ).         BNE   PR3PR2      JSR   SUSTK         BCC   FT3         LDA   SCODE         CMP   #'('         BEQ   GT1         JSR   SOPER         JMP   PR2PR3      MOVE  SCODE,TSCODE,#2+LEN      math operationPR4      JSR   SUSTK         JCC   RTS         LDA   SISP         CMP   OSP         BLT   PR5         LDA   SCODE         JSR   SOPER         JMP   PR4PR5      JSR   STACK         BCC   RTS         MOVE  TSCODE,SCODE,#2+LEN         JSR   STACK         JMP   GT1;;  Stack a variable.;VR1      SEC         LDA   SVAL         SBC   #'A'         STA   R0         LM    R0+1,#0         MUL2  R0,#LEN         ADD2  R0,#VARS         MOVE  {R0},*,#LEN         JMP   GT1;;  Stack a constant.;OP1      MOVE  SVAL,*,#LEN         JMP   GT1;;  End of line.;EL1      JSR   SUSTK                    process remaining tokens         BCC   RTS         LDA   SCODE         CMP   #RETURN         BEQ   RTS         JSR   SOPER         JMP   EL1RTS      RTS         END******************************************************************  SHIFT - Convert to Upper-Case**  INPUTS:*        A - character to shift**  OUTPUTS:*        A - upper-case character******************************************************************SHIFT    START         DEBUG SHIFT         CMP   #'a'         BLT   RTS         CMP   #'z'+1         BGE   RTS         ADC   #'A'-'a'RTS      RTS         END******************************************************************  SHOUT - Hex Output**  INPUTS:*        SVAL - number to output******************************************************************SHOUT    START         USING COMMON         DEBUG SHOUT         PUTC  #'$'         LDA   SVAL         JSR   BYTE         LDA   SVAL+1         JSR   BYTE         LDA   SVAL+2         JSR   BYTE         LDA   SVAL+3         JSR   BYTE         LDA   SVAL+4         JSR   BYTE         LDA   SVAL+5         JSR   BYTE         LDA   SVAL+6         JSR   BYTE         LDA   SVAL+7BYTE     PHA         MLSR  A,4         JSR   NIBBLE         PLA         AND   #$FNIBBLE   ORA   #'0'         CMP   #'9'+1         BLT   NB1         ADC   #'A'-'9'-2NB1      JSR   SYSCOUT         RTS         END******************************************************************  SHXEV - Hex Number Evaluation**  Evaluates a hex number.  No $ is expected.**  INPUTS:*        LINE - input line*        CC - points to first char of string**  OUTPUTS:*        SVAL - value of string*        CC - points to first char past string*        C - clear if error******************************************************************SHXEV    START         USING COMMON         DEBUG SHXEV         LA    SVAL,0                   SVAL = 0HX1      JSR   SCHAR                    WHILE character is hex DO         BCC   SEC         JSR   SHXID         BCC   SEC         PHA                               TOS = A         LDX   #4                          SVAL = SVAL*16HX2      ASL   SVAL+7         ROL   SVAL+6         ROL   SVAL+5         ROL   SVAL+4         ROL   SVAL+3         ROL   SVAL+2         ROL   SVAL+1         ROL   SVAL         BCS   ERR         DBNE  X,HX2         PLA                               SVAL = SVAL+TOS         JSR   SHXVL         ORA   SVAL+7         STA   SVAL+7         JMP   HX1ERR      JSR   SEROR         PUTS  #'Number too long.',CR=T         CLC         RTSSEC      SEC         RTS         END******************************************************************  SHXID - Hex Character Identification**  INPUTS:*        A - character to check**  OUTPUTS:*        C - set if hex******************************************************************SHXID    START         DEBUG SHXID         JSR   SYSNMID         BCS   RTS         CMP   #'A'         BLT   RTS         CMP   #'F'+1         BCC   SEC         CLC         RTSSEC      SECRTS      RTS         END******************************************************************  SHXVL - Convert Hex Character to Value**  INPUTS:*        A - hex character**  OUTPUTS:*        A - hex value******************************************************************SHXVL    START         DEBUG SHXVL         CMP   #'A'         BLT   HX1         SBC   #'A'-'9'-1HX1      AND   #$F         RTS         END******************************************************************  SINIT - Program Initialization******************************************************************SINIT    START         USING COMMON         DEBUG SINIT         HOME         PRBL  #26         PUTS   #'Double Precision Calculator',CR=T         PRBL  #31         PUTS      #'Copyright April 1985',CR=T         PRBL  #28         PUTS    #'From the Byte Works, Inc.',CR=T         PUTCR         PUTCR         INITSTACK #1024                initialize stacks         FINDBUFF STKS,#1024         RESERVE STKS,#1024         ADD2  STKS,#1024,STKE         SEED                           seed the random number generator         RTS         END******************************************************************  SOPER - Perform an Operation on the Stack**  INPUTS:*        A - operation code:*              G - SIGN*              Q - SQRT*              T - TAN*              S - SIN*              C - COS*              A - ARCTAN*              L - LN*              E - EXP*              I - INT*              B - ABS*              R - RANDOM*              N - negate*              ^ - power*              * - multiply*              / - divide*              + - add*              - - subtract*              ? - print TOS*              = - save TOS**  OUTPUTS:*        TOS - results******************************************************************SOPER    START         USING COMMON         DEBUG SOPER         CMP   #'G'         BNE   PR1         SIGND *         RTSPR1      CMP   #'Q'         BNE   PR2         SQRTD *         RTSPR2      CMP   #'B'         BNE   PR3         ABSD  *         RTSPR3      CMP   #'R'         BNE   PR5         RAND  *         RTSPR5      CMP   #'N'         BNE   PR6         SUBD  #0,*,*         RTSPR6      CMP   #'*'         BNE   PR7         MULD  *,*         RTSPR7      CMP   #'/'         BNE   PR8         DIVD  *,*         RTSPR8      CMP   #'+'         BNE   PR9         ADDD  *,*         RTSPR9      CMP   #'-'         BNE   PR10         SUBD  *,*         RTSPR10     CMP   #'?'         BNE   PR11         MOVE  *,SVAL,#LEN         PUTD  SVAL         PRBL  #4         JSR   SHOUT         PUTCR         RTSPR11     CMP   #'T'         BNE   PR12         TAND  *         RTSPR12     CMP   #'S'         BNE   PR13         SIND  *         RTSPR13     CMP   #'C'         BNE   PR14         COSD  *         RTSPR14     CMP   #'A'         BNE   PR15         ATAND *         RTSPR15     CMP   #'L'         BNE   PR16         LND   *         RTSPR16     CMP   #'E'         BNE   PR17         EXPD  *         RTSPR17     CMP   #'I'         BNE   PR18         INTD  *         RTSPR18     CMP   #'^'         BNE   PR19         PWRD  *,*         RTSPR19     JSR   SUSTK         SEC         LDA   SVAL         SBC   #'A'         STA   R0         LM    R1,#0         MUL2  R0,#LEN         ADD2  R0,#VARS         MOVE  *,{R0},#LEN         RTS         END         APPEND CD.STACK