******************************************************************  SYSATND - ARCTAN(X)**  By Mike Westerfield*  Copyright (C) April 1985, All rights reserved*  By the Byte Works, Inc.**  Inputs:*        SYSS1 - argument**  Outputs:*        SYSS1 - result**  Notes:*        1) Developed from Cody, pp.194-216******************************************************************SYSATND  START         USING SYSCOMEPS      EQU   $7FE4                    exponent of 2^(-53/2);;  Save sign.;         ASL   SYSS1         ROR   LSIGN         LSR   SYSS1;;  If X > 1 then reduce via atan(x) = pi/2-atan(1/X);         LDX   #LUDP-1                  TX1 = XRR1      LDA   SYSS1,X                  SYSS2 = 1         STA   TX1,X         LDA   ONE,X         STA   SYSS2,X         DBPL  X,RR1         JSR   SYSCMPD                  if X > 1 then         BLE   RR3         LDX   #LUDP-1                     X = 1/XRR2      LDA   TX1,X         STA   SYSS2,X         LDA   ONE,X         STA   SYSS1,X         DBPL  X,RR2         JSR   SYSDIVD         LM    N,#2*LUDP                   N = 2         JMP   RR4                      elseRR3      MOVE  TX1,SYSS1,#LUDP             SYSS1 = result         LM    N,#0                        N = 0RR4      ANOP                           endif;;  If X > 2-sqrt(3) then reduce via;        atan = pi/6+atan(g);        g = (X*sqrt(3)-1)/(sqrt(3)+X);         LDX   #LUDP-1                  TX1 = XRS1      LDA   SYSS1,X                  SYSS2 = 2-SQRT(3)         STA   TX1,X         LDA   TMS3,X         STA   SYSS2,X         DBPL  X,RS1         JSR   SYSCMPD                  if X > 2-SQRT(3) then         BLE   RS3         LDX   #LUDP-1                     SYSS1 = SQRT(3)+XRS1A     LDA   SQR3,X         STA   SYSS1,X         LDA   TX1,X         STA   SYSS2,X         DBPL  X,RS1A         JSR   SYSADDD         LDX   #LUDP-1                     SYSS1 = (SQRT(3)-1)*XRS2      LDA   SYSS1,X                     TX2 = SQRT(3)+X         STA   TX2,X         LDA   S3M1,X         STA   SYSS1,X         LDA   TX1,X         STA   SYSS2,X         DBPL  X,RS2         JSR   SYSMULD         MOVE  HALF,SYSS2,#LUDP            SYSS1 = SYSS1-.5         JSR   SYSSUBD         MOVE  HALF,SYSS2,#LUDP            SYSS1 = SYSS1-.5         JSR   SYSSUBD         MOVE  TX1,SYSS2,#LUDP             SYSS1 = SYSS1+X         JSR   SYSADDD         MOVE  TX2,SYSS2,#LUDP             SYSS1 = SYSS1/TX2         JSR   SYSDIVD         MOVE  SYSS1,TX1,#LUDP             TX1 = result         CLC                               N = N+1         LDA   N         ADC   #LUDP         STA   NRS3      ANOP                           endif;;  If X > eps then compute atan(X).  Eps gives a small;  angle approximation.;         LDA   TX1+1                    if X > eps then         CMP   #>EPS         BNE   EP0         LDA   TX1+2         CMP   #<EPSEP0      JLT   EP4         LDX   #LUDP                       SYSS1 = X*XEP1      LDA   TX1,X         STA   SYSS1,X         STA   SYSS2,X         DBPL  X,EP1         JSR   SYSMULD         MOVE  SYSS1,TX2,#LUDP             save g         LA    WR0,Q4                      compute Q(g)         LM    WR2,#4         JSR   SYSPOLD         LDX   #LUDP-1                     TX3 = Q(g)EP2      LDA   SYSS1,X                     SYSS1 = g         STA   TX3,X         LDA   TX2,X         STA   SYSS1,X         DBPL  X,EP2         LA    WR0,P3                      compute P(g)         LM    WR2,#3         JSR   SYSPOLD         MOVE  TX2,SYSS2,#LUDP             SYSS1 = P(g)*g         JSR   SYSMULD         MOVE  TX3,SYSS2,#LUDP             SYSS1 = g*P(g)/Q(g)         JSR   SYSDIVD         MOVE  TX1,SYSS2,#LUDP             X = SYSS1*X+X         JSR   SYSMULD         MOVE  TX1,SYSS2,#LUDP         JSR   SYSADDD         JMP   EP4                      elseEP3      MOVE  TX1,SYSS1,#LUDP             SYSS1 = XEP4      ANOP;;  If N > 1 then X = -X;         LDA   N         CMP   #LUDP+1         BLT   AJ1         LDA   SYSS1         EOR   #$80         STA   SYSS1;;  X = AR(N)+X;AJ1      LDX   N         LDY   #0AJ2      LDA   AR,X         STA   SYSS2,Y         INX         INY         CPY   #LUDP         BNE   AJ2         JSR   SYSADDD;;  Reset sign.;         LDA   LSIGN         AND   #$80         EOR   SYSS1         STA   SYSS1         RTS;;  Local data.;N        DS    1LSIGN    DS    1TMS3     DC    H'00 7FFD 8930A2F4 F66AC0'      2-SQRT(3)S3M1     DC    H'00 7FFE BB67AE85 84CAA0'      SQRT(3)-1HALF     DC    H'00 7FFE 80000000 0000'        .5SQR3     DC    H'00 7FFF DDB3D742 C26550'      SQRT(3)AR       DC    I1'FZERO',9H'00'         DC    H'00 7FFE 860A91C1 6B9B2A'         DC    H'00 7FFF C90FDAA2 2168C0'         DC    H'00 7FFF 860A91C1 6B9B2A'P3       DC    D'-0.83758299368150059274E00'         DC    D'-0.84946240351320683534E01'         DC    D'-0.20505855195861651981E02'         DC    D'-0.13688768894191926929E02'Q4       DC    D'1'         DC    D'0.15024001160028576121E02'         DC    D'0.59578436142597344465E02'         DC    D'0.86157349597130242515E02'         DC    D'0.41066306682575781263E02'         END******************************************************************  SYSCV8D - Convert Eight Byte Integer to Double Precision**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - eight byte integer**  OUTPUTS:*        SYSS1 - double precision******************************************************************SYSCV8D  START         LDY   #0                       handle negative inputs         LDA   SYSS1+7         BPL   CV1         SEC         LDA   #0         SBC   SYSS1         STA   SYSS1         LDA   #0         SBC   SYSS1+1         STA   SYSS1+1         LDA   #0         SBC   SYSS1+2         STA   SYSS1+2         LDA   #0         SBC   SYSS1+3         STA   SYSS1+3         LDA   #0         SBC   SYSS1+4         STA   SYSS1+4         LDA   #0         SBC   SYSS1+5         STA   SYSS1+5         LDA   #0         SBC   SYSS1+6         STA   SYSS1+6         LDA   #0         SBC   SYSS1+7         STA   SYSS1+7         INYCV1      MOVE  #0,SYSM1+8,#6            zero out the end of the number         LM    SYSM1+7,SYSS1            move the number         LM    SYSM1+6,SYSS1+1         LM    SYSM1+5,SYSS1+2         LDA   SYSM1+4         LDX   SYSM1         STX   SYSM1+4         STA   SYSM1         LDA   SYSM1+3         LDX   SYSM1+1         STX   SYSM1+3         STA   SYSM1+1         LDX   #7CV2      LDA   SYSM1,X                  check for zero         BNE   CV3         DBPL  X,CV2         LM    SYSS1,#FZERORTS      RTSCV3      TYA                            set the sign         LSR   A         ROR   A         STA   SYSS1         LM    SYSE1,#$80               initialize the exponent         LM    SYSE1+1,#$3ECV4      LDA   SYSM1                    normalize         BMI   RTS         JSR   SYSROLD         LDA   SYSE1+1         BNE   CV5         DEC   SYSE1CV5      DEC   SYSE1+1         JMP   CV4         END******************************************************************  SYSCVDF - Convert Double Precision to Floating Point**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - unpacked double precision number**  OUTPUTS:*        SYSS1 - unpacked floating point number******************************************************************SYSCVDF  START         LDA   SYSS1+LUFP         BPL   CV1         INC   SYSM1+3         BNE   CV1         INC   SYSM1+2         BNE   CV1         INC   SYSM1+1         BNE   CV1         INC   SYSM1         BNE   CV1         LM    SYSM1,#$80         INC   SYSE1+1         BNE   CV1         INC   SYSE1CV1      LDA   SYSE1+1         ROL   A         LDA   SYSE1         ROL   A         BEQ   CV2         CMP   #$FF         BNE   ERRCV2      EOR   SYSE1         BPL   ERR         ASL   SYSE1+1         ASL   SYSE1         ROR   SYSE1+1         RTSERR      FERR  #3         RTS         END******************************************************************  SYSCVFD - Convert Floating Point to Double Precision**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - unpacked floating point number**  OUTPUTS:*        SYSS1 - unpacked double precision number******************************************************************SYSCVFD  START         LDA   #0         LDX   SYSE1+1         BMI   CV1         LDA   #$FFCV1      ASL   SYSE1+1         ROR   A         STA   SYSE1         ROR   SYSE1+1         MOVE  #0,SYSS1+LUFP,#LUDP-LUFP         RTS         END******************************************************************  SYSRAND - Pseudo Random Double Precision Numnber**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  OUTPUTS:*        SYSS1 - result**  NOTES:*        1) The result is in the range [0.0..1.0)******************************************************************SYSRAND  START         JSR   SYSRANX         LDX   #6         LDY   #0RN1      LDA   SYSRANX+3,X         STA   SYSM1,X         STY   SYSM2,X         DBPL  X,RN1         STY   SYSS1         STY   SYSS2         SEC         ROR   SYSM1         LM    (SYSE1+1,SYSE2+1),#$FF         LM    (SYSE1,SYSE2),#$7F         LM    SYSM2,#$80         JMP   SYSSUBD         END         APPEND DP.3