******************************************************************  SYSPWRF - X^Y**  By Mike Westerfield*  Copyright (C) April 1985, All rights reserved*  By the Byte Works, Inc.**  Inputs:*        SYSS1 - argument (X in X^Y)*        SYSS2 - power (Y in X^Y)**  Outputs:*        SYSS1 - result******************************************************************SYSPWRF  START         USING SYSCOM         MOVE  SYSS2,TX4,#LUFP         JSR   SYSLNXF         MOVE  TX4,SYSS2,#LUFP         JSR   SYSMULF         JMP   SYSEXPF         END******************************************************************  SYSLNXF - Natural Log**  By Mike Westerfield*  Copyright (C) April 1985, All rights reserved*  By the Byte Works, Inc.**  Inputs:*        SYSS1 - argument**  Outputs:*        SYSS1 - result**  Notes:*        1) Developed from Hart, pp 105-111 and table 2702.******************************************************************SYSLNXF  START         USING SYSCOM;;  Error if negative or zero argument.;         LDA   SYSS1         BMI   ER1         AND   #FZERO         BEQ   SF1ER1      FERR  #FERR1                   invalid operation         RTS;;  Split into component parts.;SF1      LM    EXP,SYSE1+1              save exponent         LM    SYSE1+1,#$7E             .5 <= X < 1         MOVE  SQR2,SYSS2,#LUFP         1/SQRT(2) <= X < SQRT(2)         JSR   SYSMULF;;  TX1 = (X-1)/(X+1);         LDX   #LUFP-1DZ1      LDA   SYSS1,X         STA   TX1,X         LDA   ONE,X         STA   SYSS2,X         DBPL  X,DZ1         JSR   SYSADDF         LDX   #LUFP-1DZ2      LDA   SYSS1,X         STA   TX2,X         LDA   TX1,X         STA   SYSS1,X         LDA   ONE,X         STA   SYSS2,X         DBPL  X,DZ2         JSR   SYSSUBF         MOVE  TX2,SYSS2,#LUFP         JSR   SYSDIVF;;  log(X) = P(TX1^2)*TX1;         LDX   #LUFP-1ES1      LDA   SYSS1,X         STA   SYSS2,X         STA   TX1,X         DBPL  X,ES1         JSR   SYSMULF         LA    WR0,P3         LM    WR2,#3         JSR   SYSPOLF         MOVE  TX1,SYSS2,#LUFP         JSR   SYSMULF;;  Result = ln(2)*(X/ln(2) - .5 + float(EXP));         MOVE  ILN2,SYSS2,#LUFP         JSR   SYSMULF         MOVE  NI2,SYSS2,#LUFP         JSR   SYSADDF         MOVE  SYSS1,TX1,#LUFP         LDX   #$FF         CLC         LDA   EXP         ADC   #$82         STA   SYSS1         BMI   FN2         INXFN2      STX   SYSS1+1         JSR   SYSCV2F         MOVE  TX1,SYSS2,#LUFP         JSR   SYSADDF         MOVE  LN2,SYSS2,#LUFP         JMP   SYSMULF;;  Constants;EXP      DS    1                        exponent storage areaONE      DC    H'00 007F 80000000'      1NI2      DC    H'80 007E 80000000'      -1/2LN2      DC    H'00 007E B17217F8'      0.69314718ILN2     DC    H'00 007F B8AA3B29'      1.4426950SQR2     DC    H'00 007F B504F334'      1.4142136P3       DC    F'.30100328'         DC    F'.39965795'         DC    F'.66666948'         DC    F'2'         END******************************************************************  SYSEXPF - Exponent**  By Mike Westerfield*  Copyright (C) April 1985, All rights reserved*  By the Byte Works, Inc.**  Inputs:*        SYSS1 - argument**  Outputs:*        SYSS1 - result**  Notes:*        1) Developed from Hart, pp 96-104 and table 1321.******************************************************************SYSEXPF  START         USING SYSCOM;;  Divide by ln(2) to convert the problem from finding exp(X) to;  finding 2^X.;         MOVE  ILN2,SYSS2,#LUFP         JSR   SYSMULF;;  Reduce the range to -1/2 < X < 1/2 by:;        1) removing the integer part.;        2) dividing by 2 if result > 1/2;         LDA   #0                       remove integer part         STA   EXP         STA   DBY2         LDA   SYSS1         AND   #FZERO         BNE   PW1EX1      LDA   SYSE1+1         CMP   #$7F         BLT   EX3         CLC         JSR   SYSROLF2         DEC   SYSE1+1         BEQ   UFL         ROL   EXP         BPL   EX1         FERR  #FERR3                   overflow         RTSUFL      FERR  #FERR4                   underflow         RTSEX3      LDX   #64                      normalize fractional partEX4      LDA   SYSM1         BMI   EX5         CLC         JSR   SYSROLF2         DEC   SYSE1+1         BEQ   UFL         DBPL  X,EX4         LDA   SYSS1         ORA   #FZERO         STA   SYSS1EX5      LDA   SYSS1         BPL   EX6         SEC         LDA   #0         SBC   EXP         STA   EXPEX6      LDX   SYSE1+1                  if ABS(X) >= 1/2 then divide by 2         INX         BPL   PW1         INC   DBY2         DEC   SYSE1+1         BEQ   UFL;;  X = 2^X = 2*X*P(X^2)/(Q(X^2)-X*P(X^2))+1;PW1      LDX   #LUFP-1                  save XPW1A     LDA   SYSS1,X         STA   SYSS2,X         STA   TX1,X         DBPL  X,PW1A         JSR   SYSMULF                  compute X^2         MOVE  SYSS1,TX2,#LUFP          save X^2         LA    WR0,P1                   compute P(X^2)*X         LM    WR2,#1         JSR   SYSPOLF         MOVE  TX1,SYSS2,#LUFP         JSR   SYSMULF         LDX   #LUFP-1                  save P(X^2)PW2      LDA   SYSS1,X                   and recover X^2         STA   TX1,X         LDA   TX2,X         STA   SYSS1,X         DBPL  X,PW2         LA    WR0,Q1                   compute Q(X^2)         LM    WR2,#1         JSR   SYSPOLF         MOVE  TX1,SYSS2,#LUFP          compute denominator         JSR   SYSSUBF         LDX   #LUFP-1                  do the divisionPW3      LDA   SYSS1,X         STA   SYSS2,X         LDA   TX1,X         STA   SYSS1,X         DBPL  X,PW3         JSR   SYSDIVF         INC   SYSE1+1                  multiply by 2         BEQ   OVFL         MOVE  ONE,SYSS2,#LUFP         LM    SYSE2+1,#$7F         JSR   SYSADDF;;  If division by 2 was used during range reduction, square the result.;         LDA   DBY2         BEQ   FN1         MOVE  SYSS1,SYSS2,#LUFP         JSR   SYSMULF;;  Add integer part to the exponent.;FN1      CLC         LDA   SYSE1+1         BPL   FN2         ADC   EXP         BMI   FN3OVFL     FERR  #FERR3                   overflow         RTSFN2      ADC   EXPFN3      STA   SYSE1+1         RTS;;  Constants;EXP      DS    1                        integer part of argumentDBY2     DS    1                        divide by 2 flagILN2     DC    H'00 007F B8AA3B29'      1.4426950P1       DC    F'0.057699582'         DC    F'7.2150480'Q1       DC    F'1'         DC    F'20.818228'         END******************************************************************  SYSINTF - Floating Point Integer**  By Mike Westerfield*  Copyright (C) April 1985, All rights reserved*  By the Byte Works, Inc.**  Inputs:*        SYSS1 - argument**  Outputs:*        SYSS1 - result******************************************************************SYSINTF  START         USING SYSCOM;;  If <0 then start by subtracting one.;         LDA   SYSS1         BPL   AB1         MOVE  ONE,SYSS2,#LUFP         LM    SYSE2+1,#$7F         JSR   SYSSUBF;;  If ABS(X) < 1 then return 0;AB1      LDA   SYSE1+1         CMP   #$7F         BGE   LG1         LM    SYSS1,#FZERO         RTS;;  If ABS(X) > 2^32 return;LG1      CMP   #$9E         BGE   RTS;;  Zero all bits to the right of the decimal place.;         ADC   #$82                     compute start disp         PHA         MLSR  A,3         TAX         PLA                            create bit mask         AND   #$7         BEQ   ZB2         TAY         LDA   #0ZB1      SEC         ROR   A         DBNE  Y,ZB1         AND   SYSM1,X                  zero partial byte         STA   SYSM1,X         INX         LDA   #0                       zero remaining bytesZB2      STA   SYSM1,X         INX         CPX   #5         BNE   ZB2RTS      RTS         END******************************************************************  SYSATNF - ARCTAN(X)**  By Mike Westerfield*  Copyright (C) April 1985, All rights reserved*  By the Byte Works, Inc.**  Inputs:*        SYSS1 - argument**  Outputs:*        SYSS1 - result**  Notes:*        1) Developed from Cody, pp.194-216******************************************************************SYSATNF  START         USING SYSCOMEPS      EQU   $72                      exponent of 2^(-12);;  Save sign.;         ASL   SYSS1         ROR   SIGN         LSR   SYSS1;;  If X > 1 then reduce via atan(x) = pi/2-atan(1/X);         LDX   #LUFP-1                  TX1 = XRR1      LDA   SYSS1,X                  SYSS2 = 1         STA   TX1,X         LDA   ONE,X         STA   SYSS2,X         DBPL  X,RR1         LM    SYSE2+1,#$7F         JSR   SYSCMPF                  if X > 1 then         BLE   RR3         LDX   #LUFP-1                     X = 1/XRR2      LDA   TX1,X         STA   SYSS2,X         LDA   ONE,X         STA   SYSS1,X         DBPL  X,RR2         LM    SYSE1+1,#$7F         JSR   SYSDIVF         LM    N,#2*LUFP                   N = 2         JMP   RR4                      elseRR3      MOVE  TX1,SYSS1,#LUFP             SYSS1 = result         LM    N,#0                        N = 0RR4      ANOP                           endif;;  If X > 2-sqrt(3) then reduce via;        atan = pi/6+atan(g);        g = (X*sqrt(3)-1)/(sqrt(3)+X);         LDX   #LUFP-1                  TX1 = XRS1      LDA   SYSS1,X                  SYSS2 = 2-SQRT(3)         STA   TX1,X         LDA   TMS3,X         STA   SYSS2,X         DBPL  X,RS1         JSR   SYSCMPF                  if X > 2-SQRT(3) then         BLE   RS3         LDX   #LUFP-1                     SYSS1 = SQRT(3)+XRS1A     LDA   SQR3,X         STA   SYSS1,X         LDA   TX1,X         STA   SYSS2,X         DBPL  X,RS1A         JSR   SYSADDF         LDX   #LUFP-1                     SYSS1 = (SQRT(3)-1)*XRS2      LDA   SYSS1,X                     TX2 = SQRT(3)+X         STA   TX2,X         LDA   S3M1,X         STA   SYSS1,X         LDA   TX1,X         STA   SYSS2,X         DBPL  X,RS2         JSR   SYSMULF         MOVE  HALF,SYSS2,#LUFP            SYSS1 = SYSS1-.5         JSR   SYSSUBF         MOVE  HALF,SYSS2,#LUFP            SYSS1 = SYSS1-.5         JSR   SYSSUBF         MOVE  TX1,SYSS2,#LUFP             SYSS1 = SYSS1+X         JSR   SYSADDF         MOVE  TX2,SYSS2,#LUFP             SYSS1 = SYSS1/TX2         JSR   SYSDIVF         MOVE  SYSS1,TX1,#LUFP             TX1 = result         CLC                               N = N+1         LDA   N         ADC   #LUFP         STA   NRS3      ANOP                           endif;;  If X > eps then compute atan(X).  Eps gives a small;  angle approximation.;         LDA   TX1+2                    if X > eps then         CMP   #EPS         JLT   EP4         LDX   #LUFP                       SYSS1 = X*XEP1      LDA   TX1,X         STA   SYSS1,X         STA   SYSS2,X         DBPL  X,EP1         JSR   SYSMULF         MOVE  SYSS1,TX2,#LUFP             save g         LA    WR0,Q1                      compute Q(g)         LM    WR2,#1         JSR   SYSPOLF         LDX   #LUFP-1                     TX3 = Q(g)EP2      LDA   SYSS1,X                     SYSS1 = g         STA   TX3,X         LDA   TX2,X         STA   SYSS1,X         DBPL  X,EP2         LA    WR0,P1                      compute P(g)         LM    WR2,#1         JSR   SYSPOLF         MOVE  TX2,SYSS2,#LUFP             SYSS1 = P(g)*g         JSR   SYSMULF         MOVE  TX3,SYSS2,#LUFP             SYSS1 = g*P(g)/Q(g)         JSR   SYSDIVF         MOVE  TX1,SYSS2,#LUFP             X = SYSS1*X+X         JSR   SYSMULF         MOVE  TX1,SYSS2,#LUFP         JSR   SYSADDF         JMP   EP4                      elseEP3      MOVE  TX1,SYSS1,#LUFP             SYSS1 = XEP4      ANOP;;  If N > 1 then X = -X;         LDA   N         CMP   #LUFP+1         BLT   AJ1         LDA   SYSS1         EOR   #$80         STA   SYSS1;;  X = AR(N)+X;AJ1      LDX   N         LDY   #0AJ2      LDA   AR,X         STA   SYSS2,Y         INX         INY         CPY   #LUFP         BNE   AJ2         JSR   SYSADDF;;  Reset sign.;         LDA   SIGN         AND   #$80         EOR   SYSS1         STA   SYSS1         RTS;;  Local data.;N        DS    1TMS3     DC    H'00 007D 8930A2F5'      2-SQRT(3)S3M1     DC    H'00 007E BB67AE86'      SQRT(3)-1HALF     DC    H'00 007E 80000000'      .5SQR3     DC    H'00 007F DDB3D743'      SQRT(3)AR       DC    I1'FZERO',6H'00'         DC    H'00 007E 860A91C1'         DC    H'00 007F C90FDAA2'         DC    H'00 007F 860A91C1'P1       DC    F'-.05090958253'         DC    F'-.4708325141'Q1       DC    F'1'         DC    F'1.412500740'         END******************************************************************  SYSTANF - TAN(X)**  By Mike Westerfield*  Copyright (C) April 1985, All rights reserved*  By the Byte Works, Inc.**  Inputs:*        SYSS1 - argument**  Outputs:*        SYSS1 - result******************************************************************SYSTANF  START         USING SYSCOM         MOVE  SYSS1,TX2,#LUFP         JSR   SYSCOSF         LDX   #LUFP-1DT1      LDA   SYSS1,X         STA   TX3,X         LDA   TX2,X         STA   SYSS1,X         DBPL  X,DT1         JSR   SYSSINF         MOVE  TX3,SYSS2,#LUFP         JMP   SYSDIVF         END******************************************************************  SYSCOSF - COS(X)*  SYSSINF - SIN(X)**  By Mike Westerfield*  Copyright (C) April 1985, All rights reserved*  By the Byte Works, Inc.**  Inputs:*        SYSS1 - argument**  Outputs:*        SYSS1 - result**  Notes:*        1)  Algorithm from Cody, pp 125-149.  Table 3341 from*            Hart.******************************************************************SYSCOSF  START         USING SYSCOM;;  Change argument: COS(X) = SIN(X+PI/2);         MOVE  HALFPI,SYSS2,#LUFP         JSR   SYSADDF;;  Remove multiples of 2*PI, mapping the unit circle from 0..2*PI to 0..4.;SYSSINF  ENTRY         LDA   SYSS1                    quit if zero         AND   #FZERO         BNE   RTS         LM    SIGN,SYSS1               remove and save sign         ASL   SYSS1         LSR   SYSS1         LDX   #LUFP-1                  check for maxRR1      LDA   SYSS1,X         STA   TX1,X         LDA   MAX,X         STA   SYSS2,X         DBPL  X,RR1         JSR   SYSCMPF         BLE   RR3         FERR  #FERR5                   inexact         LM    SYSS1,#FZERORTS      RTSRR3      LDX   #LUFP-1                  multiply by 2/PIRR3A     LDA   TX1,X         STA   SYSS1,X         LDA   IHPI,X         STA   SYSS2,X         DBPL  X,RR3A         JSR   SYSMULFRR4      LDA   SYSE1+1                  use extended result to maintain         CMP   #$81                      precision while removing multiples         BLT   RR5                       of PI/2         JSR   SYSROLF         DEC   SYSE1+1         BNE   RR4RR5      LDX   #7                       normalizeRR6      LDA   SYSM1,X         BNE   RR7         DBPL  X,RR6         LM    SYSS1,#FZERO         RTSRR7      LDA   SYSM1         BMI   RR8         JSR   SYSROLF         DBNE  SYSE1+1,RR7         FERR  #FERR4                   underflow         RTSRR8      ASL   SYSS1                    take absolute value         LSR   SYSS1;;  Reduce range from 0..4 to 0..1.;         LDA   SYSE1+1                  quit if < .5         CMP   #$7E         BLT   SG1         CMP   #$80                     branch if < 2         BLT   RR10         MOVE  N4,SYSS2,#LUFP           SYSS1 = 4-SYSS1         LDA   SYSS1         EOR   #$80         STA   SYSS1         JSR   SYSADDF         LDA   SIGN                     SIGN = -SIGN         EOR   #$80         STA   SIGNRR10     LDA   SYSE1+1                  quit if < 1         CMP   #$7F         BLT   SG1         MOVE  N2,SYSS2,#LUFP           SYSS1 = 2-SYSS1         LDA   SYSS1         EOR   #$80         STA   SYSS1         JSR   SYSADDF;;  Done if SYSS1 < EPS (small angle approx.);SG1      LDA   SYSE1+1         CMP   EPS         BGE   PE1         MOVE  HALFPI,SYSS2,#LUFP       map to radians         JSR   SYSMULF         JMP   SS1;;  Polynomial expansion;PE1      LDX   #LUFP-1PE2      LDA   SYSS1,X         STA   SYSS2,X         STA   TX1,X         DBPL  X,PE2         JSR   SYSMULF         LA    WR0,P4         LM    WR2,#4         JSR   SYSPOLF         MOVE  TX1,SYSS2,#LUFP         JSR   SYSMULF;;  Set sign.;SS1      ASL   SYSS1         ASL   SIGN         ROR   SYSS1         RTS;;  Constants.;HALFPI   DC    H'00 007F C90FDAA2'      PI/2IHPI     DC    H'00 007E A2F9836E'      2/PIMAX      DC    H'00 0089 A2E00000'      1303N2       DC    H'00 0080 80000000'      2N4       DC    H'00 0081 80000000'      4EPS      DC    H'72'                    exponent of 2.441406 E-4P4       DC    F'1.51485129E-4'         DC    F'-4.67376661E-3'         DC    F'7.96896789E-2'         DC    F'-0.645963711'         DC    F'1.57079632'         END         APPEND FP.2