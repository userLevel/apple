******************************************************************  SYSDIVF - Floating Point Divide**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - sign and flags for numerator*        SYSE1 - exponent for numerator*        SYSM1 - mantissa for numerator*        SYSS2 - sign and flags for denominator*        SYSE2 - exponent for denominator*        SYSM2 - mantissa for denominator**  OUTPUTS:*        SYSS1 - sign and flags for result*        SYSE1 - exponent for result*        SYSM1 - mantissa for result******************************************************************SYSDIVF  START;;  Exception and special case handling.;         LDA   SYSS2                    set sign         EOR   SYSS1         ASL   SYSS1         ASL   A         ROR   SYSS1         LDA   #FINF                    check for inf/inf         BIT   SYSS1         BEQ   IN2         BIT   SYSS2         BEQ   RTS         FERR  #FERR1         RTSIN2      BIT   SYSS2                    check for x/inf, with result of 0         BEQ   IN3         LDA   #0         STA   SYSE1+1         STA   SYSM1         STA   SYSM1+1         STA   SYSM1+2         LDA   SYSS1         ORA   #FZERO         STA   SYSS1         RTSIN3      LDA   #FZERO                   check for division by 0         BIT   SYSS2         BEQ   IN5         BIT   SYSS1                    check for 0/0         BEQ   IN4         FERR  #FERR1         RTSIN4      FERR  #FERR2RTS      RTSIN5      BIT   SYSS1                    check for 0/X         BNE   RTS;;  Initialization;IN6      SEC                            subtract exponents         LDA   SYSE1+1         SBC   SYSE2+1         EOR   #$80         PHA         EOR   SYSE1+1         BPL   IN7         LDA   SYSE1+1         EOR   SYSE2+1         BPL   IN7         PLA         LDA   SYSE1+1         BPL   UFLOVFL     FERR  #FERR3         RTSUFL      FERR  #FERR4         RTSIN7      PLA         STA   SYSE1+1         LDX   #3                       move the input number to a work area         LDY   #0                        and zero the number areaIN8      LDA   SYSM1,X         STA   SYSM1+4,X         STY   SYSM1,X         DBPL  X,IN8         JSR   CP12         BLT   IN9         LSR   SYSM1+4         ROR   SYSM1+5         ROR   SYSM1+6         ROR   SYSM1+7         JMP   IN10IN9      DEC   SYSE1+1         BEQ   UFLIN10     LSR   SYSM2         ROR   SYSM2+1         ROR   SYSM2+2         ROR   SYSM2+3;;  Do 32 bit divide until left justified.;         LDX   #-33                     set shift countDV1      JSR   CP12                     see if subtraction will work         BLT   DV2         SEC                            subtract         LDA   SYSM1+7         SBC   SYSM2+3         STA   SYSM1+7         LDA   SYSM1+6         SBC   SYSM2+2         STA   SYSM1+6         LDA   SYSM1+5         SBC   SYSM2+1         STA   SYSM1+5         LDA   SYSM1+4         SBC   SYSM2         STA   SYSM1+4DV2      ROL   SYSM1+3                  shift in divide bit         ROL   SYSM1+2         ROL   SYSM1+1         ROL   SYSM1         ASL   SYSM1+7                  adjust numerator         ROL   SYSM1+6         ROL   SYSM1+5         ROL   SYSM1+4         INX                            increment shift count         LDA   SYSM1                    check for done         BPL   DV1         INX                            account for extra shifts         BMI   OVFL         STX   SYSE2+1         CLC         LDA   SYSE1+1         SBC   SYSE2+1         STA   SYSE1+1         BEQ   UFL2         BCC   UFL2         RTSUFL2     JMP   UFL;;  CP12: Compare SYSM1+4 and SYSM2;CP12     LDA   SYSM1+4         CMP   SYSM2         BNE   CP1         LDA   SYSM1+5         CMP   SYSM2+1         BNE   CP1         LDA   SYSM1+6         CMP   SYSM2+2         BNE   CP1         LDA   SYSM1+7         CMP   SYSM2+3CP1      RTS         END******************************************************************  SYSMULF - Floating Point Multiply**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - sign and flags for multiplicand*        SYSE1 - exponent for multiplicand*        SYSM1 - mantissa for multiplicand*        SYSS2 - sign and flags for multiplier*        SYSE2 - exponent for multiplier*        SYSM2 - mantissa for multiplier**  OUTPUTS:*        SYSS1 - sign and flags for result*        SYSE1 - exponent for result*        SYSM1 - mantissa for result******************************************************************SYSMULF  START;;  Exception and special case handling.;         LDA   SYSS1                    set the sign         EOR   SYSS2         ASL   SYSS1         ASL   A         ROR   SYSS1         LDA   #FINF                    inf*inf = inf         BIT   SYSS1         BEQ   SC1         BIT   SYSS2         BNE   RTS         LDA   SYSS2                    inf*0 is an error, inf*X = inf         AND   #FZERO         BEQ   RTSERR1     FERR  #FERR1RTS      RTSSC1      LDA   #FZERO                   0*inf is an error         BIT   SYSS1         BEQ   SC2         LDA   SYSS2         AND   #FINF         BNE   ERR1         RTSSC2      BIT   SYSS2                    X*0 = 0         BEQ   SC3         ORA   SYSS1         STA   SYSS1         LDA   #0         STA   SYSE1+1         STA   SYSM1         STA   SYSM1+1         STA   SYSM1+2         RTSSC3      LDA   #FINF                    x*inf = inf         BIT   SYSS2         BEQ   IN1         ORA   SYSS1         STA   SYSS1         RTS;;  Initialization;IN1      LDA   SYSE1+1                  add exponents         EOR   SYSE2+1                  split on exponent signs         BMI   IN2         JSR   AEXP                     both the same: add         EOR   SYSE2+1         BPL   IN3OVFL     FERR  #FERR3         RTSIN2      JSR   AEXP                     signs different: overflow is not!                                        possibleIN3      LSR   SYSM2                    shield from overflow         ROR   SYSM2+1         ROR   SYSM2+2         ROR   SYSM2+3IN4      LDX   #3                       move number to work area and zero M1         LDY   #0IN5      LDA   SYSM1,X         STA   SYSM1+4,X         STY   SYSM1,X         DBPL  X,IN5;;  Multiply the mantissas;         LDY   #32                      do 32 bit multiplyML1      LDA   SYSM1+7         BNE   ML3         CPY   #8         BLT   ML3         LDX   #6                       shift right 8 bitsML2      LDA   SYSM1,X         STA   SYSM1+1,X         DBPL  X,ML2         LM    SYSM1,#0         SEC         TYA         SBC   #8         TAY         BNE   ML1         BEQ   NM1ML3      LSR   SYSM1                    shift right one bit         ROR   SYSM1+1         ROR   SYSM1+2         ROR   SYSM1+3         ROR   SYSM1+4         ROR   SYSM1+5         ROR   SYSM1+6         ROR   SYSM1+7         BCC   ML4         CLC                            add partial product         LDA   SYSM1+3         ADC   SYSM2+3         STA   SYSM1+3         LDA   SYSM1+2         ADC   SYSM2+2         STA   SYSM1+2         LDA   SYSM1+1         ADC   SYSM2+1         STA   SYSM1+1         LDA   SYSM1         ADC   SYSM2         STA   SYSM1ML4      DEY                            next bit         BNE   ML1;;  Normalize the result;NM1      LDA   SYSM1                    shift left 1 bit if the shield bit was         BMI   NM2                       not used         JSR   SYSROLF         DEC   SYSE1+1NM2      INC   SYSE1+1                  correct for shield bit         JEQ   OVFL         RTS;;  AEXP: add exponents;AEXP     CLC         LDA   SYSE1+1         ADC   SYSE2+1         EOR   #$80         CLC         ADC   #1         STA   SYSE1+1         RTS         END         APPEND FP.5