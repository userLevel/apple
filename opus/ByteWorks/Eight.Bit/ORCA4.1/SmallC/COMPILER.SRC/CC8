comment()/*****************************************************************  Writes the start of a comment line for the assembler*****************************************************************/   /* begin a comment line for the assembler */   {outbyte(';');}header()/*****************************************************************  Writes statements required at the start of all programs*****************************************************************/   /* Print all assembler info before any code is generated */   {   pl("\fSmall-C Compiler 2.0\r");   }trailer()/*****************************************************************  Writes statements required at the end of all programs*****************************************************************/   /* Print any assembler stuff needed after all code */   {ot("end\r");   if(append)       {ot("append ");       outstr(apname);       outbyte('\r');       }   }getmem(sym)/*****************************************************************  Load a global value onto the TOS**  Inputs:*      sym - pointer to symbol table entry of variable to load*****************************************************************/   char *sym;   {if (sym[ident] == pointer)       gen1(4/*ldoi*/,sym+name);   else switch(sym[type])       {case cchar: {gen1(3/*ldoc*/,sym+name); break;}       case cshort: {gen1(4/*ldoi*/,sym+name); break;}       case clong: gen1(57/*ldol*/,sym+name);       }   }getloc(sym)/*****************************************************************  Load the address of a local variable**  Inputs:*      sym - pointer to symbol table entry of variable to load*****************************************************************/   char *sym;   {gen1(5/*lao*/,(sym[offset] & 255) + ((sym[offset+1] & 255) << 8));   }putmem(sym)/*****************************************************************  Save TOS to a global variable**  Inputs:*      sym - pointer to symbol table entry of variable to save*****************************************************************/   char *sym;   {if (sym[ident] == pointer)       gen1(7/*croi*/,sym+name);   else switch(sym[type])       {case cchar: {gen1(6/*croc*/,sym+name); break;}       case cshort: {gen1(7/*croi*/,sym+name); break;}       case clong: gen1(58/*crol*/,sym+name);       }   }putstk(typeobj)/*****************************************************************  Store indirect**  The value to save is at TOS, and the address to save it to*  is at TOS-1.  When complete, TOS still has the value, but*  the address has been removed.**  Inputs:*      typeobj - cchar or cint*****************************************************************/   char typeobj;   {switch(typeobj)       {case cchar: {gen1(8/*cpoc*/); break;}       case cshort: {gen1(9/*cpoi*/); break;}       case clong: gen1(59/*cpol*/);       }   }indirect(typeobj)/*****************************************************************  Load indirect**  TOS has the address of a value to load.  After completion, the*  value is at TOS and the address has been removed.**  Inputs:*      typeobj - cchar or cint*****************************************************************/   char typeobj;   {switch(typeobj)       {case cchar: {gen1(10/*indc*/); break;}       case cshort: {gen1(11/*indi*/); break;}       case clong: gen1(60/*indl*/);       }   }defbyte()/*****************************************************************  Set up for a character literal definition*****************************************************************/   {ot("dc i1'");}defstorage()/*****************************************************************  Set up to define storage for a global variable*****************************************************************/   {ot("ds ");}index(typ)/*****************************************************************  Adjust an array index*****************************************************************/   int typ;   {switch (typ)       {case cshort: {gen1(12/*ldci*/,1); gen0(18/*asl*/); return;}       case clong: {gen1(12/*ldci*/,2); gen0(18/*asl*/);}       }   }purge()/*****************************************************************  Purge any code in the code generation buffer*****************************************************************/{int i;i = 0;while (peep[i])   {instructionout(peep[i],peep[i+1],peep[i+2]);   peep[i] = 0;   i = i+instsize;   }}gen0(op)/*****************************************************************  Generate an implied operand instruction**  Inputs:*      op - op code number*****************************************************************/long op;{gen2(op,0,0);}gen1(op,num)/*****************************************************************  Generate an instruction with a single operand**  Inputs:*      op - op code number*      num - number of first operand**  Notes:*      The number may be a pointer to a string, rather than an*      integer.*****************************************************************/long op,num;{gen2(op,num,0);}gen2(op,num1,num2)/*****************************************************************  Generate an instruction with a single operand**  Inputs:*      op - op code number*      num1 - number of first operand*      num2 - number of second operand**  Notes:*      The numbers may be pointers to strings, rather than*      integers.*****************************************************************/long op,num1,num2;{int i, didone;/* find a spot for the new instruction */i = 0;while (peep[i]) i = i+instsize;if ((i/instsize) >= peepsize)   {instructionout(peep[0],peep[1],peep[2]);   remove(0);   i = peeparray-2*instsize;   }/* place it in the window */peep[i] = op; peep[i+1] = num1; peep[i+2] = num2;/* scan the list, optimizing */didone = true;while (didone)   {i = didone = 0;   while (peep[i])       {if (optimize(i)) ++didone;       i = i+instsize;       }   }}remove(i)/*****************************************************************  Remove an instruction from the peephole array**  Inputs:*      i - position to remove from*****************************************************************/   int i;   {   while (i < (peeparray-instsize))       {peep[i] = peep[i+instsize];       ++i;       }   }optimize(i)/*****************************************************************  Do optimizations on this instruction**  Inputs:*      i - disp into peep to try optimizing*****************************************************************/   int i;   {int temp;   temp = peep[i];   /* apply associative laws of addition, multiplication */   if (peep[i+instsize] == 12/*ldci*/)       if ((temp == 19/*adi*/) || (temp == 21/*mpi*/))           if (peep[i+instsize*2] == temp)               {peep[i] = peep[i+instsize];               peep[i+1] = peep[i+1+instsize];               peep[i+instsize] = peep[i+2*instsize];               return true;               }   /* replace copy-pop operations with stores */   if (peep[i+instsize] == 13/*popi*/)       {if (temp == 9/*cpoi*/)           {peep[i] = 51/*stoi*/;           remove(i+instsize);           return true;           }       if (temp == 8/*cpoc*/)           {peep[i] = 52/*stoc*/;           remove(i+instsize);           return true;           }       if (temp == 59/*cpol*/)           {peep[i] = 62/*stol*/;           remove(i+instsize);           return true;           }       if (temp == 7/*croi*/)           {peep[i] = 53/*sroi*/;           remove(i+instsize);           return true;           }       if (temp == 6/*croc*/)           {peep[i] = 54/*sroc*/;           remove(i+instsize);           return true;           }       if (temp == 58/*crol*/)           {peep[i] = 61/*srol*/;           remove(i+instsize);           return true;           }       }   /* do constant operations */   if (temp == 12/*ldci*/)       {if (peep[i+instsize] == 12/*ldci*/)           {temp = peep[i+2*instsize];           if (temp == 19/*adi*/)               {peep[i+1] = peep[i+1]+peep[i+1+instsize];               remove(i+instsize);               remove(i+instsize);               return true;               }           if (temp == 20/*sbi*/)               {peep[i+1] = peep[i+1]-peep[i+1+instsize];               remove(i+instsize);               remove(i+instsize);               return true;               }           if (temp == 21/*mpi*/)               {peep[i+1] = peep[i+1]*peep[i+1+instsize];               remove(i+instsize);               remove(i+instsize);               return true;               }           if (temp == 22/*dvi*/)               {peep[i+1] = peep[i+1]/peep[i+1+instsize];               remove(i+instsize);               remove(i+instsize);               return true;               }           return false;           }       else if (peep[i+instsize] == 28/*ngi*/)           {remove(i+instsize);           peep[i+1] = -peep[i+1];           }       else if (peep[i+1] == 0)           {temp = peep[i+instsize];           if ((temp == 19/*adi*/) || (temp == 20/*sbi*/))               {remove(i); remove(i); return true;}           if (temp == 16/*fjp*/)               {remove(i);               peep[i] = 15/*ujp*/;               return true;               }           return false;           }       else if (peep[i+instsize] == 16/*fjp*/)           {remove(i); remove(i); return true;}       return false;       }   /* remove dead code after ret or ujp */   if ((temp == 14/*ret*/) || (temp == 15/*ujp*/))       {if ((peep[i+instsize] != 2/*label*/) &&            (peep[i+instsize] != 49/*labell*/) &&            (peep[i+instsize] != 0))           {remove(i+instsize); return true;}       return false;       }   /* no optimizations done */   return false;   }instructionout(op,num1,num2)/*****************************************************************  Write an instruction to the output file**  Inputs:*      op - op code number*      num1 - number of first operand*      num2 - number of second operand**  Notes:*      The numbers may be pointers to strings, rather than*      integers.*****************************************************************/long op,num1,num2;{switch (op)   {case 1: {ot("cup "); outdec(num1); outbyte(','); outstr(num2); break;}   case 2:  {printlabel(num1); ot("anop\r"); return;}   case 3:  {ot("ldoc "); outstr(num1); break;}   case 4:  {ot("ldoi "); outstr(num1); break;}   case 5:  {ot("lao "); outdec(num1); break;}   case 6:  {ot("croc "); outstr(num1); break;}   case 7:  {ot("croi "); outstr(num1); break;}   case 8:  {ot("cpoc\r"); return;}   case 9:  {ot("cpoi\r"); return;}   case 10: {ot("indc\r"); return;}   case 11: {ot("indi\r"); return;}   case 12: {ot("ldci "); outdec(num1); break;}   case 13: {ot("popi\r"); return;}   case 14: {ot("ret\r"); return;}   case 15: {ot("ujp "); printlabel(num1); break;}   case 16: {ot("fjp "); printlabel(num1); break;}   case 17: {ot("ent "); outdec(num1); break;}   case 18: {ot("shl\r"); return;}   case 19: {ot("adi\r"); return;}   case 20: {ot("sbi\r"); return;}   case 21: {ot("mpi\r"); return;}   case 22: {ot("dvi\r"); return;}   case 23: {ot("mod\r"); return;}   case 24: {ot("ior\r"); return;}   case 25: {ot("xor\r"); return;}   case 26: {ot("andi\r"); return;}   case 27: {ot("shr\r"); return;}   case 28: {ot("ngi\r"); return;}   case 29: {ot("not\r"); return;}   case 30: {ot("ocp\r"); return;}   case 31: {ot("lor\r"); return;}   case 32: {ot("land\r"); return;}   case 33: {ot("inci\r"); return;}   case 34: {ot("deci\r"); return;}   case 35: {ot("eql\r"); return;}   case 36: {ot("neq\r"); return;}   case 37: {ot("les\r"); return;}   case 38: {ot("grt\r"); return;}   case 39: {ot("leq\r"); return;}   case 40: {ot("geq\r"); return;}   case 41: {ot("ult\r"); return;}   case 42: {ot("ule\r"); return;}   case 43: {ot("ugt\r"); return;}   case 44: {ot("uge\r"); return;}   case 45: {ot("ldci "); printlabel(num1); outbyte('+'); outdec(num2); break;}   case 46: {ot("ldci "); outstr(num1); break;}   case 47: {ot("mst\r"); return;}   case 48: {ot("ujp "); outstr(num1); break;}   case 49: {outstr(num1); ot("anop\r"); return;}   case 50: {ot("tjp "); printlabel(num1); break;}   case 51: {ot("stoi\r"); return;}   case 52: {ot("stoc\r"); return;}   case 53: {ot("sroi "); outstr(num1); break;}   case 54: {ot("sroc "); outstr(num1); break;}   case 55: {ot("xjp\r"); return;}   case 56: {ot("adr "); printlabel(num1); break;}   case 57: {ot("ldol "); outstr(num1); break;}   case 58: {ot("crol "); outstr(num1); break;}   case 59: {ot("cpol\r"); return;}   case 60: {ot("indl\r"); return;}   case 61: {ot("srol "); outstr(num1); break;}   case 62: {ot("stol\r"); return;}   }outbyte('\r');}