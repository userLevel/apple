main()/******************************************************************  Compiler begins execution here*****************************************************************/      {int i;      i = 0; while (i < peeparray) peep[i++] = 0;      glbptr=startglb;                 /* clear global symbols */      locptr=startloc;                 /* clear local symbols */      wqptr=wq;                        /* clear while queue */      macptr=                          /* clear the macro pool */      caseptr=                         /* clear the case pool */      litptr=                          /* clear literal pool */      sp=                              /* stack ptr (relative) */      errcnt=                          /* no errors */      eof=                             /* no eof yet */      input=                           /* no source file */      input2=                          /* no include file */      output=                          /* no output file */      activeswitch=                    /* no open switch statements */      ncmp=                            /* no open compound statements */      lastst=                          /* no last statement yet */      numlines=                        /* no source lines yet */      append=                          /* no file to append */      skipping=                        /* not skipping code */      org=                             /* no default org */      quote[1]=      0;                               /* --- all set to zero --- */      quote[0] = '"';      nofunctions=                     /* no functions yet */      cmode=1;                         /* enable preprocessing */      size[cchar] = charsz;            /* set up the size array */      size[cshort] = shortsz;      size[clong] = longsz;      /*                                          */      /*      compiler body                       */      /*                                          */      ask();                           /* get user options */      header();                        /* intro code */      parse();                         /* process ALL input */      dumpglbs();                      /* and all static memory */      errorsummary();                  /* summarize errors */      trailer();                       /* follow up code */      if (input) fclose(input);        /* close the source file */      if (output)         {fclose(output);              /* close the output file */         setlnum(kpfile,2);            /* make it an assembler file */         }      setlinfo();                      /* return to ORCA/HOST */      }parse()/******************************************************************  Process all input text**  At this level, only static declarations,*  defines, includes and functions*  definitions are legal.*****************************************************************/      {      while (!eof)         /* do until no more input */         {         if(amatch("char",4)){declglb(cchar);ns();}         else if(amatch("int",3)){declglb(cint);ns();}         else if(amatch("short",5)){declglb(cshort);ns();}         else if(amatch("long",4)){declglb(clong);ns();}         else if(amatch("#asm",4))doasm();         else if(amatch("#include",8))doinclude();         else if(amatch("#define",7))addmac();         else if(amatch("#list",5))dolist();         else if(amatch("#source",7))dosource();         else if(amatch("#keep",5))dokeep();         else if(amatch("#org",4))doorg();         else newfunc();         blanks();         /* force eof if pending */         }      }dumplits()/*****************************************************************  Dump the literal (string) pool*****************************************************************/   {int j,k;   if (! litptr) return;               /* if nothing there, exit */   printlabel(litlab);                 /* print literal label */   k=0;                                /* init an index... */   while (k<litptr)                    /*       to the loop with */       {defbyte();                     /* pseudo-op to define byte */       j=10;                           /* max bytes per line */       while(j--)           {outdec((litq[k++]&127));           if ((0 ==  j) | (k>=litptr))               {outbyte(singlequote);               outbyte('\r');          /* need <cr> */               break;               }           outbyte(',');               /* separate bytes */           }       }   litptr = 0;                         /* reset for the next function */   }dumpglbs()/*****************************************************************  Dump static (global) variables*****************************************************************/   {   int j;   outstr("sysccom data\r");   cptr=startglb;   while(cptr<glbptr)       {if(cptr[ident]!=function)           /* do if anything but function */           {outstr(cptr);           /* output name as label... */           defstorage();   /* define storage */           j=((cptr[offset])+(cptr[offset+1]<<8));           /* calc # bytes */           if (cptr[ident] == pointer) j = j*ptrsz;           else j = j*size[cptr[type]];           outdec(j);      /* need that many */           outbyte('\r');           }       cptr=cptr+symsiz;       }   }errorsummary()/******************************************************************  Report errors*****************************************************************/   {   if (ncmp) error(1);   putchar('\r');   putdec(errcnt); /* total # errors */   pl(" errors in compilation.");   if (errcnt) merrf(32);   }ask()/******************************************************************  Get options*****************************************************************/   {   int k; long num[1]; char *parmptr;   kill();                             /* clear input line */   ctext=false;   nxtlab=0;   getlinfo();                         /* get ORCA inputs */   if((input=fopen(sfile,"r"))==NULL)       {eof = true;       error(2);       }   if (parms)       {parmptr = parms;       numsubs = 0;       while(*parmptr)           {numsubs = numsubs + (*parmptr == '\r');           ++parmptr;           }       }   }onoff()/*****************************************************************  Read an On or Off Operand**  Outputs:*      onoff - value of operand*****************************************************************/   {int val;   blanks();   if (amatch("on",2)) val = true;   else if (amatch("off",3)) val = false;   else {val = false; error(3);}   kill();   return val;   }readname(n)/*****************************************************************  Read a File Name**  Inputs:*      name - pointer to the file name**  Outputs:*      name - value read from line*      readname - length of the name read*****************************************************************/   char n[];   {int cnt;   blanks();   if (ch() != '"') return false;   gch();   cnt = 0;   while (iscsym(ch())||(ch() == '/')||(ch() == '.'))       {if (cnt < filemax) n[cnt++] = ch(); gch();}   n[cnt] = 0;   if (ch() != '"') return false;   kill();   return cnt;   }doinclude()/*****************************************************************  Handle an included file*****************************************************************/   {char file[filemax];   int k;   if (! readname(file)) {error(4); return;}   if(lnum != getlnum(file))       {append = true;       k = 0;       while(file[k]) apname[k] = file[k++];       apname[k] = 0;       }   else if((input2 = fopen(file,"r")) == NULL)       {input2 = 0;       error(5);       }   kill();   }dolist()/*****************************************************************  Handle a List Directive**  Outputs:*      listflag - indicates if source listing is wanted*****************************************************************/   {listflag = onoff();}dosource()/*****************************************************************  Handle a List Directive**  Outputs:*      listflag - indicates if source listing is wanted*****************************************************************/   {ctext = onoff();}dokeep()/*****************************************************************  Handle a Keep Directive*****************************************************************/   {char n[filemax];   if(nofunctions && (! kflag))       {if (readname(n)) setkeep(n);       else error(4);       }   else       {if(nofunctions) error(6);       else error(7);       }   }doorg()/*****************************************************************  Handle an Org Directive*****************************************************************/   {long num[1];   blanks();   number(num);   ot("org "); outdec(num[0]); outbyte('\r');   org = num[0];   kill();   }declglb(typ)/*****************************************************************  Declare a static variable**  Creates a symbol table entry so that latar references to the*  symbol are valid, and so the symbol will be allocated space*  in sysccom.**  Inputs:*      typ - type of the variable (cchar, cshort, clong)*****************************************************************/   int typ;   {int k, j; char sname[namesize];   while(1)      {while(1)         {if(endst())return;   /* do line */         k=1;            /* assume 1 element */         if(match("*"))      /* pointer? */            j=pointer;      /* yes */         else j=variable;   /* no */         if(! symname(sname)) /* name ok? */            {error(8); junk();}         if(findglb(sname))   /* already defined? */            multidef(sname);         if(match("["))      /* array? */            {k=needsub();   /* get size */            if(k) j=array;   /* !0=array */            else j=pointer;   /* 0=pointer */            }         addglb(sname,j,typ,k); /* add symbol */         break;         }      if(! match(",")) return; /* more? */      }   }