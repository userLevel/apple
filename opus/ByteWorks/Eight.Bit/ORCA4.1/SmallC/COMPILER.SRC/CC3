declloc(typ)/*****************************************************************  Declare local variable**  Creates a symbol table entry so that latar references to the*  symbol are valid.  Space is allocated on the stack frame.**  Inputs:*      typ - type of the variable (cchar, cshort, clong)*****************************************************************/   int typ;   {   int k, j; char sname[namesize];   while(1)      {while(1)         {if(endst()) return;         if(match("*"))            j = pointer;         else j = variable;         if (! symname(sname))            {error(8); junk();}         if(findloc(sname))            multidef(sname);         if (match("["))            {k = needsub();            if (k)               {j = array;               k = k*size[typ];               }            else               {j = pointer;               k = ptrsz;               }            }         else            {if (j == pointer) k = ptrsz;            else k = size[typ];            }         /* change machine stack */         sp = sp+k;         addloc(sname, j, typ, sp);         break;         }      if (! match(",")) return;      }   }needsub()/*****************************************************************  Get array size**  Outputs:*      needsub - number of elements in the array*****************************************************************/   {   long num[1];   if (match("]")) return 0;           /* null size */   if (! number(num))                  /* go after a number */      {error(9);      num[0] = 1;                      /* force a number */      }   if (num[0] < 0)      {error(10);      num[0] = (-num[0]);      }   needbrack("]");                     /* force a single dimension */   return num[0];                      /* and return size */   }skiptobracket()/*****************************************************************  Skips code until a { or } is found**  Outputs:*      skiptobracket - '{' or '}'*****************************************************************/   {while (1)       {blanks();       /* do character literals */       if (ch() == singlequote)           {gch();           while (strchar(singlequote) != eostr);           blanks();           }       /* do string literals */       if (ch() == '"')           {gch();           while (strchar('"') != eostr);           blanks();           }       if ((ch() == '}') | eof) return '}';       if (ch() == '{') return '{';       gch();       }   }skip()/*****************************************************************  Skips a function body*****************************************************************/   {int numbrack;   skipping = true;   if (skiptobracket() == '{')       {numbrack = 1;       gch();       while (numbrack)           {if (skiptobracket() == '{') ++numbrack;           else --numbrack;           gch();           }       }   else error(11);   skipping = false;   }search(n)/*****************************************************************  Search the parm list to see if this function is needed**  Inputs:*      parms - list of names to compile*      name - name of current function**  Outputs:*      search - true if name is in list, else false**  Notes:*      If name is found, the name in the parms list is truncated*      to namemax characters.*****************************************************************/   char n[];   {int disp,pos,match;   disp = 0;   while (1)       {pos = 0; match = false;       while (pos < namemax)           {if ((0 ==  n[pos]) && (parms[disp+pos] == '\r'))               {match = true; break;}           if (n[pos] != parms[disp+pos]) break;           ++pos;           }       if (pos == namemax) match = true;       if (match)           {if ((pos == namemax) && (parms[disp+pos] != '\r'))               {disp = disp+namemax;               while (parms[disp] != '\r')                   {pos = 0;                   while (parms[disp+pos])                       parms[disp+(pos++)] = parms[disp+pos];                   }               }           break;           }       while (parms[disp++] != '\r');       if (! parms[disp]) break;       }   return match;   }newfunc()/*****************************************************************  Define a new function*****************************************************************/   {int targstk;   char n[namesize], *ptr;   if (!  symname(n))       {error(12);       kill(); /* invalidate line */       return;       }   if (parms[0]) /* skip functions not needed by partial compile */       if (!  search(n))           {skip(); return;}       else --numsubs;   if(nofunctions)             /* if first function, do initialization */       {if(kflag)           {if((output=fopen(kpfile,"w"))==NULL)               {eof=true;               error(13);               }           }       ot("list off\r");       ot("symbol off\r");       if (org)           {ot("org "); outdec(org); outbyte('\r');}       ot("mcopy c.macros\r");       outstr("syscmain start\r");       ot("init\r");       ot("end\r");       nofunctions = false;       }   litlab = getlabel();        /* get label for string literals */   if (!  listflag) pl(n);   if (ptr = findglb(n))      /* already in symbol table? */       {if (ptr[ident] != function) multidef(n);           /* already a variable by that name */       else if (ptr[offset] == function) multidef(n);           /* already a function by that name */       else ptr[offset] = function;           /* otherwise we have what was earlier assumed to be a function */       }   /* if not in table, define as a function now */   else addglb(n, function, cint, function);   /* we had better see open parin for args... */   if (!  match("(")) error(14);   outstr(n); ot("start\r");   ot("using sysccom\r");   argstk = 0;               /* init arg count */   while (!  match(")"))         /* then count args */       /* any legal name bumps arg count */       {if (symname(n)) argstk = argstk+longsz;       else {error(8); junk();}       blanks();       /* if not closing paren, should be comma */       if (!  streq(line+lptr, ")"))           {if (!  match(","))           error(15);           }       if (endst()) break;       }   locptr = startloc;          /* clear local symbol table */   sp = markstk;               /* preset stack ptr */   targstk = argstk;           /* save argstk for later */   while (argstk)       /* now let user declare what types of things */       /* those arguments were */       {if (amatch("char",4)) {getarg(cchar); ns();}       else if (amatch("int",3)) {getarg(cint); ns();}       else if (amatch("short",5)) {getarg(cshort); ns();}       else if (amatch("long",4)) {getarg(clong); ns();}       else {error(41); break;}       }   if (match("{"))       {++ncmp;       while(1)           {if ((ch() == 0) && eof) return;           else if (amatch("char",4)) {declloc(cchar); ns();}           else if (amatch("int",3)) {declloc(cint); ns();}           else if (amatch("short",5)) {declloc(cshort); ns();}           else if (amatch("long",4)) {declloc(clong); ns();}           else break;           }       gen1(17/*ent*/,(sp-markstk-targstk));       while (!  match("}"))           if (eof) return;           else statement();       --ncmp;       gen0(14/*ret*/);       }   else error(16);   sp = 0;                     /* reset stack ptr again */   locptr = startloc;          /* deallocate all locals */   purge();                    /* dump code in optimization buffer */   dumplits();                 /* dump string literal pool */   ot("end\r");                /* finish the function */   if(*parms)                  /* if doing partial compiles, check for done */       {if (numsubs == 0)           {if (input2) {fclose(input2); input2 = 0;}           eof = true;           }       }   }getarg(t)/*****************************************************************  Declare arguments**  This function adds an argument to the local symbol table.**  Inputs:*      t - cchar ot cint*****************************************************************/   int t;   {   char n[namesize], c; int j;   while (1)      {if (argstk == 0) return; /* no more args */      if (match("*")) j = pointer;      else j = variable;      if (!  symname(n)) {error(8); junk();}      if (findloc(n)) multidef(n);      if (match("["))         /* pointer? */      /* it is a pointer, so skip all */      /* stuff between "[]" */         {while(inbyte() != ']')            if (endst()) break;         j = pointer;         /* add entry as pointer */         }      argstk = argstk-longsz;      sp = sp+longsz;      addloc(n,j,t,sp);      if (endst()) return;      if (!  match(",")) error(15);      }   }