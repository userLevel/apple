expression()/*****************************************************************  Handle an expression*****************************************************************/   {long lval[2];   if (hier1(lval)) rvalue(lval);   }hier1(lval)/*****************************************************************  Check for =*****************************************************************/   long lval[];   {int k; long lval2[2];   k = hier2(lval);   if (match("="))      {if (k == 0) {error(42); return 0;}      if (hier1(lval2)) rvalue(lval2);      store(lval);      return 0;      }   else return k;   }hier2(lval)/*****************************************************************  Check for ||*****************************************************************/   long lval[];   {int k; long lval2[2];   k = hier3(lval);   blanks();   if (!  streq(line+lptr,"||")) return k;   if (k) rvalue(lval);   while (1)      {if (match("||"))         {if (hier3(lval2)) rvalue(lval2);         gen0(31/*lor*/);         }      else return 0;      }   }hier3(lval)/*****************************************************************  Check for &&*****************************************************************/   long lval[];   {int k; long lval2[2];   k = hier4(lval);   blanks();   if (!  streq(line+lptr,"&&")) return k;   if (k) rvalue(lval);   while (1)      {if (match("&&"))         {if (hier4(lval2)) rvalue(lval2);         gen0(32/*land*/);         }      else return 0;      }   }hier4(lval)/*****************************************************************  Check for |*****************************************************************/   long lval[];   {int k; long lval2[2];   k = hier5(lval);   blanks();   if (ch() != '|') return k;   if (streq(line+lptr,"||")) return k;   if (k) rvalue(lval);   while (1)      {if (match("|"))         {if (hier5(lval2)) rvalue(lval2);         gen0(24/*ior*/);         }      else return 0;      }   }hier5(lval)/*****************************************************************  Check for ^*****************************************************************/   long lval[];   {int k; long lval2[2];   k = hier6(lval);   blanks();   if (ch() != '^') return k;   if (k) rvalue(lval);   while(1)      {if (match("^"))         {         if (hier6(lval2)) rvalue(lval2);         gen0(25/*xor*/);         }      else return 0;      }   }hier6(lval)/*****************************************************************  Check for &*****************************************************************/   long lval[];   {int k; long lval2[2];   k = hier7(lval);   blanks();   if (ch() != '&') return k;   if (streq(line+lptr,"&&")) return k;   if (k) rvalue(lval);   while (1)      {if (match("&"))         {if (hier7(lval2)) rvalue(lval2);         gen0(26/*andi*/);         }      else return 0;      }   }hier7(lval)/*****************************************************************  Check for == !=*****************************************************************/   long lval[];   {int k; long lval2[2];   k = hier8(lval);   blanks();   if ((!  streq(line+lptr,"==")) &&      (!  streq(line+lptr,"!="))) return k;   if (k) rvalue(lval);   while (1)      {if (match("=="))         {if (hier8(lval2)) rvalue(lval2);         gen0(35/*eql*/);         }      else if (match("!="))         {if (hier8(lval2)) rvalue(lval2);         gen0(36/*neq*/);         }      else return 0;      }   }hier8(lval)/*****************************************************************  Check for <= >= < >*****************************************************************/   long lval[];   {int k; long lval2[2];   k = hier9(lval);   blanks();   if ((!  streq(line+lptr,"<")) &&      (!  streq(line+lptr,">")) &&      (!  streq(line+lptr,"<=")) &&      (!  streq(line+lptr,">="))) return k;   if (streq(line+lptr,">>")) return k;   if (streq(line+lptr,"<<")) return k;   if (k) rvalue(lval);   while(1)      {if (match("<="))         {if (hier9(lval2)) rvalue(lval2);         if (cptr = lval[0])            if (cptr[ident] == pointer)               {gen0(42/*ule*/);               continue;               }         if (cptr = lval2[0])            if (cptr[ident] == pointer)               {gen0(42/*ule*/);               continue;               }         gen0(39/*leq*/);         }      else if (match(">="))         {if (hier9(lval2)) rvalue(lval2);         if (cptr = lval[0])            if (cptr[ident] == pointer)               {gen0(44/*uge*/);               continue;               }         if (cptr = lval2[0])            if (cptr[ident] == pointer)               {gen0(44/*uge*/);               continue;               }         gen0(40/*geq*/);         }      else if (streq(line+lptr,"<") &&         (!  streq(line+lptr,"<<")))         {inbyte();         if (hier9(lval2)) rvalue(lval2);         if (cptr = lval[0])            if (cptr[ident] == pointer)               {gen0(41/*ult*/);               continue;               }         if (cptr = lval2[0])            if (cptr[ident] == pointer)               {gen0(41/*ult*/);               continue;               }         gen0(37/*les*/);         }      else if ((streq(line+lptr,">")) &&         (!  streq(line+lptr,">>")))         {inbyte();         if (hier9(lval2)) rvalue(lval2);         if (cptr = lval[0])            if (cptr[ident] == pointer)               {gen0(43/*ugt*/);               continue;               }         if (cptr = lval2[0])            if (cptr[ident] == pointer)               {gen0(43/*ugt*/);               continue;               }         gen0(38/*grt*/);         }      else return 0;      }   }hier9(lval)/*****************************************************************  Check for << >>*****************************************************************/   long lval[];   {int k; long lval2[2];   k = hier10(lval);   blanks();   if ((!  streq(line+lptr,">>")) &&      (!  streq(line+lptr,"<<"))) return k;   if (k) rvalue(lval);   while (1)      {if (match(">>"))         {if (hier10(lval2)) rvalue(lval2);         gen0(27/*shr*/);         }      else if (match("<<"))         {if (hier10(lval2)) rvalue(lval2);         gen0(18/*shl*/);         }      else return 0;      }   }hier10(lval)/*****************************************************************  Check for + -*****************************************************************/   long lval[];   {int k; long lval2[2];   k = hier11(lval);   blanks();   if ((ch() != '+') && (ch() != '-')) return k;   if (k) rvalue(lval);   while (1)      {if (match("+"))         {if (hier11(lval2)) rvalue(lval2);         if (cptr = lval[0])            if (cptr[ident] == pointer) index(cptr[type]);         gen0(19/*adi*/);         }      else if (match("-"))         {         if (hier11(lval2)) rvalue(lval2);         if (cptr = lval[0])            if (cptr[ident] == pointer) index(cptr[type]);         gen0(20/*sbi*/);         }      else return 0;      }   }hier11(lval)/*****************************************************************  Check for * / %*****************************************************************/   long lval[];   {int k; long lval2[2];   k = hier12(lval);   blanks();   if ((ch() != '*') && (ch() != '/') && (ch() != '%')) return k;   if (k) rvalue(lval);   while (1)      {if (match("*"))         {if (hier12(lval2)) rvalue(lval2);         gen0(21/*mpi*/);         }      else if (match("/"))         {if (hier12(lval2)) rvalue(lval2);         gen0(22/*dvi*/);         }      else if (match("%"))         {if (hier12(lval2)) rvalue(lval2);         gen0(23/*mod*/);         }      else return 0;      }   }hier12(lval)/*****************************************************************  Check for:*      leading ++*      leading --*      unary -*      pointer indicator (*)*      address operator (&)*      trailing ++*      trailing --*****************************************************************/   long lval[];   {int k;   char *ptr;   if (match("++"))      {if (!  (k = hier12(lval)))         {error(42);         return 0;         }      if (lval[1]) getloc(lval[0]);      rvalue(lval);      gen0(33/*inci*/);      ptr = lval[0];      if ((ptr[ident] == pointer) &&         (ptr[type] == cint)) gen0(33/*inci*/);      store(lval);      return 0;      }   else if (match("--"))      {if (!  (k = hier12(lval)))         {error(42);         return 0;         }      if (lval[1]) getloc(lval[0]);      rvalue(lval);      gen0(34/*deci*/);      ptr = lval[0];      if ((ptr[ident] == pointer) &&         (ptr[type] == cint)) gen0(34/*deci*/);      store(lval);      return 0;      }   else if (match("~"))      {k = hier12(lval);      if (k) rvalue(lval);      gen0(30/*ocp*/);      return 0;      }   else if (match("!"))      {k = hier12(lval);      if (k) rvalue(lval);      gen0(29/*not*/);      return 0;      }   else if (match("-"))      {k = hier12(lval);      if (k) rvalue(lval);      gen0(28/*ngi*/);      return 0;      }   else if (match("*"))      {k = hier12(lval);      if (k) rvalue(lval);      lval[1] = cint;      if (ptr = lval[0]) lval[1] = ptr[type];      lval[0] = 0;      return 1;      }   else if (match("&"))      {k = hier12(lval);      if (k == 0)         {error(43);         return 0;         }      else if (lval[1]) return 0;      else         {gen1(46/*ldcis*/,(ptr = lval[0]));         lval[1] = ptr[type];         return 0;         }      }   else      {k = hier13(lval);      if (match("++"))         {if (k == 0)            {error(42);            return 0;            }         if (lval[1]) getloc(lval[0]);         rvalue(lval);         gen0(33/*inci*/);         ptr = lval[0];         if ((ptr[ident] == pointer) && (ptr[type] == cint)) gen0(33/*inci*/);         store(lval);         gen0(34/*deci*/);         if ((ptr[ident] == pointer) && (ptr[type] == cint)) gen0(34/*deci*/);         return 0;         }      else if (match("--"))         {if (k == 0)            {error(42);            return 0;            }         if (lval[1]) getloc(lval[0]);         rvalue(lval);         gen0(34/*deci*/);         ptr = lval[0];         if ((ptr[ident] == pointer) && (ptr[type] == cint)) gen0(34/*deci*/);         store(lval);         gen0(33/*inci*/);         if ((ptr[ident] == pointer) && (ptr[type] == cint)) gen0(33/*inci*/);         return 0;         }      else return k;      }   }hier13(lval)/*****************************************************************  Distinguish between simple variables, arrays, and functions*****************************************************************/   long *lval;   {int k; char *ptr;   k = primary(lval);   ptr = lval[0];   blanks();   if ((ch() == '[') | (ch() == '('))   while(1)      {if (match("["))         {if (!  ptr)            {error(37);            junk();            needbrack("]");            return 0;            }         else if (ptr[ident] == pointer) rvalue(lval);         else if (ptr[ident] != array)            {error(37);            k = 0;            }         expression();         needbrack("]");         index(ptr[type]);         gen0(19/*adi*/);         lval[0] = 0;         lval[1] = ptr[type];         k = 1;         }      else if (match("("))         {callfunction(ptr);         k = lval[0] = 0;         }      else return k;      }   if (!  ptr) return k;   if (ptr[ident] == function)      {gen1(46/*ldcis*/,ptr);      return 0;      }   return k;   }primary(lval)/*****************************************************************  Handle simple variables and constants*****************************************************************/   long *lval;   {char *ptr,sname[namesize];   long num[1];   int k;   if (match("("))      {k = hier1(lval);      needbrack(")");      return k;      }   if (symname(sname))      {if (ptr = findloc(sname))         {getloc(ptr);         lval[0] = ptr;         lval[1] = ptr[type];         if (ptr[ident] == pointer) lval[1] = cint;         if (ptr[ident] == array) return 0;         else return 1;         }      if (ptr = findglb(sname))         if (ptr[ident] != function)            {lval[0] = ptr;            lval[1] = 0;            if (ptr[ident] != array) return 1;            gen1(46/*ldcis*/,ptr);            lval[1] = ptr[type];            return 0;            }       blanks();       if (ch() == '(')           ptr = addglb(sname,function,cint,0);       else           {ptr = addloc(sname,variable,cint,0);           error(38);           comment(); outstr("variable name: ");           outstr(sname); outbyte('\r');           }       lval[0] = ptr;       lval[1] = 0;       return 0;       }   if (constant(num))      return(lval[0] = lval[1] = 0);   else      {error(39);      gen1(12/*ldci*/,0);      junk();      return 0;      }   }store(lval)/*****************************************************************  Save a value from the TOS*****************************************************************/   long *lval;   {if (lval[1] == 0) putmem(lval[0]);   else putstk(lval[1]);   }rvalue(lval)/*****************************************************************  Load a value onto the TOS*****************************************************************/   long *lval;   {if ((lval[0] != 0) && (lval[1] == 0))      getmem(lval[0]);   else      indirect(lval[1]);   }test(label,cond)/*****************************************************************  Evaluate boolean expression and jump based on result**  Inputs:*      label - label to jump to if false*      cond - branch on false or branch on true*****************************************************************/   int label,cond;   {needbrack("(");   expression();   needbrack(")");   if (cond) gen1(50/*tjp*/,label);   else gen1(16/*fjp*/,label);   }constant(val)/*****************************************************************  Handle a constant*****************************************************************/   long val[];   {if (number(val)) gen1(12/*ldci*/,val[0]);   else if(pstr(val)) gen1(12/*ldci*/,val[0]);   else if (qstr(val)) gen2(45/*ldcil*/,litlab,val[0]);   else return 0;   return 1;   }number(val)/*****************************************************************  Read a number from the input stream**  Outputs:*      val[0] - value read*      number - 1 if number found, else 0*****************************************************************/   long val[];   {long k; int minus;   char c;   k = minus = 1;   while (k)      {k = 0;      if (match("+")) k = 1;      if (match("-")) {minus = (-minus); k = 1;}      }   if (! isdigit(ch())) return 0;   while (isdigit(ch()))      {c = inbyte();      k = k*10+(c-'0');      }   k = k*minus;   val[0] = k;   return 1;   }strchar(stopch)/*****************************************************************  Get a Character for a String or Character Literal**  Inputs:*      stopch - string terminator**  Outputs:*      strchar - character read; eostr if at end of string**  Notes:*      Interprets backslashes from the following table:**          \n  newline     10*          \t  tab         9*          \b  backspace   8*          \f  form feed   12*          \v  vert. tab   11*          \r  return      13*          \"  '"'         34*          \'  ''''        39*          \\  '\'         92*****************************************************************/   char stopch;   {char c;   if (ch() == 92)       {gch(); c = gch();       if (c == 'b') return 8;       if (c == 't') return 9;       if (c == 'n') return 10;       if (c == 'v') return 11;       if (c == 'f') return 12;       if (c == 'r') return 13;       return c;       }   if ((ch() == stopch) || (!ch())) {gch(); return eostr;}   return gch();   }pstr(val)/*****************************************************************  Handle a character constant**  Note: a character constant can consist of one or two characters.*****************************************************************/   long val[];   {int k;   char c;   k = 0;   if (!  match("'")) return 0;   while((c = strchar(singlequote)) != eostr)      k = (k<<8)+(c&127);   val[0] = k;   return 1;   }qstr(val)/*****************************************************************  Handle a string*****************************************************************/   long val[];   {char c;   if (!  match(quote)) return 0;   val[0] = litptr;   while ((c = strchar('"')) != eostr)      {if(ch() == 0) break;      if (litptr >= litmax)         {error(40);         while (!  (strchar('"') != eostr))            if (ch() == 0) break;         return 1;         }      litq[litptr++] = c;      }   litq[litptr++] = 0;   return 1;   }