keepch(c)/*****************************************************************  Keep a character in the temporary line buffer**  Inputs:*      c - character to keep*      mptr - location in mline to save the character**  Outsputs:*      mline - line containing the character*      mptr - incremented*****************************************************************/   char c;   {mline[mptr] = c;   if (mptr < mpmax) mptr++;   return c;   }preprocess()/*****************************************************************  Expand macros in a source line**  Inputs:*      line - line to expand macros in*      cmode - 0 if macros are not to be expanded, else 1**  Outputs:*      line - line with expanded macros*****************************************************************/   {int k;   char c, sname[namesize];   if (!  cmode) return;   mptr = lptr = 0;   while (ch())      {if (ch() == ' ')         {keepch(' ');         while (ch() == ' ') gch();         }      else if (ch() == '"')         {keepch(ch());         gch();         while (ch() != '"')            {if (ch() == 0)               {error (32);               break;               }            if (ch() == '\\') keepch(gch());            keepch(gch());            }         gch();         keepch('"');         }      else if (ch() == singlequote)         {keepch(singlequote);         gch();         while (ch() != singlequote)            {if (ch() == 0)               {error(33);               break;               }            if (ch() == '\\') keepch(gch());            keepch(gch());            }         gch();         keepch(singlequote);         }      else if ((ch() == '/') && (nch() == '*'))         {inchar(); inchar();         while (!  ((ch() == '*') && (nch() == '/')))            {if (ch() == 0) inline();               else inchar();            if (eof) break;            }         inchar(); inchar();         }      else if (isdigit(ch()))         while (isdigit(ch())) keepch(gch());      else if (iscsym(ch()))         {k = 0;         while (iscsym(ch()))            {if (k < namemax) sname[k++] = ch();            gch();            }         sname[k] = 0;         if (k = findmac(sname))            while (c = macq[k++])               keepch(c);         else            {k = 0;            while (c = sname[k++])               keepch(c);            }         }      else keepch(gch());      }   keepch(0);   if (mptr >= mpmax) error(34);   lptr = mptr = 0;   while (line[lptr++] = mline[mptr++]);   lptr = 0;   }addmac()/*****************************************************************  Add a macro definition to the macro pool*****************************************************************/   {char sname[namesize];   int k;   if (!  symname(sname))      {error(8);      kill();      return;      }   k = 0;   while (putmac(sname[k++]));   while (ch() == ' ') gch();   while (putmac(gch()));   if (macptr >= macmax) error(35);   }putmac(c)/*****************************************************************  Place a character in the macro table**  Inputs:*      c - character to place in the table*      macptr - index to the next free spot in the table*****************************************************************/   char c;   {macq[macptr] = c;   if (macptr < macmax) macptr++;   return c;   }outbyte(c)/*****************************************************************  Write a byte to the current output file**  Inputs:*      c - byte to write*      output - reference number for the file*****************************************************************/   char c;   {if(c == 0) return 0;   if (output)      {if ((fputc(c, output) & 255) == EOFCH)         {fclose(output);         error(36);         }      }   return c;   }outstr(ptr)/*****************************************************************  Write a string to the current output file**  Inputs:*      ptr - pointer to the string*****************************************************************/   char ptr[];   {int k;   k = 0;   while (outbyte(ptr[k++]));   }esccheck()/*****************************************************************  See if the last key pressed was an ESC - and quit if it was*****************************************************************/   {char *ptr;   ptr = -16384;   if ((*ptr & 127) == 27)       {if (input2) {fclose(input2); input2 = 0;}       eof = true;       }   }error(ernum)/*****************************************************************  write an error message**  inputs:*      ernum - error number*      lptr - position to write the error message*      line - line containing the error*****************************************************************/   int ernum;   {int k;   putchar('*'); putchar('*'); putchar('*');   pl(line);   k = -3;   while (k++ < lptr) putchar(' ');   putchar('^');   switch(ernum)      {case  1: {pl("missing closing bracket"); break;}       case  2: {pl("open failure on source file"); break;}       case  3: {pl("'on' or 'off' expected"); break;}       case  4: {pl("bad file name"); break;}       case  5: {pl("open failure on include file"); break;}       case  6: {pl("multiple keeps not allowed"); break;}       case  7: {pl("keep must come before first function"); break;}       case  8: {pl("illegal symbol name"); break;}       case  9: {pl("must be constant"); break;}       case 10: {pl("negative size illegal"); break;}       case 11: {pl("no function body found"); break;}       case 12: {pl("illegal function or declaration"); break;}       case 13: {pl("keep file could not be opened"); break;}       case 14: {pl("'(' expected"); break;}       case 15: {pl("',' expected"); break;}       case 16: {pl("missing block"); break;}       case 17: {pl("';' expected"); break;}       case 18: {pl("'while' expected"); break;}       case 19: {pl("':' expected"); break;}       case 20: {pl("this label already used"); break;}       case 21: {pl("default label already used"); break;}       case 22: {pl("too many case labels"); break;}       case 23: {pl("not valid outide switch"); break;}       case 24: {pl("name conflict"); break;}       case 25: {pl("label name expected"); break;}       case 26: {pl("already defined"); break;}       case 27: {pl("missing bracket"); break;}       case 28: {pl("global symbol table overflow"); break;}       case 29: {pl("local symbol table overflow"); break;}       case 30: {pl("too many active whiles"); break;}       case 31: {pl("no active whiles"); break;}       case 32: {pl("expected quote"); break;}       case 33: {pl("''' expected"); break;}       case 34: {pl("line too long"); break;}       case 35: {pl("macro table overflow"); break;}       case 36: {pl("output file error"); break;}       case 37: {pl("can't subscript"); break;}       case 38: {pl("undeclared variable"); break;}       case 39: {pl("invalid expression"); break;}       case 40: {pl("string space exhausted"); break;}       case 41: {pl("wrong number of args"); break;}       case 42: {pl("must be lvalue"); break;}       default: putdec(ernum);       }   ++errcnt;   esccheck();   while((fgetc(0) != '\r') && (!  eof)) esccheck();   }ot(ptr)/*****************************************************************  Write an op code**  Inputs:*      ptr - pointer to op code string*****************************************************************/   char ptr[];   {outbyte(' ');   outstr(ptr);   }match(lit)/*****************************************************************  Match a string**  Tries to match a string to the current input line.  If a*  match is found, the string is removed from the input stream.**  Inputs:*      lit - pointer to string to match*      line - line to check*      lptr - position to check**  Outputs:*      match - 1 if match found, else 0*****************************************************************/   char *lit;   {int k;   blanks();   if (k = streq(line+lptr,lit))      {lptr = lptr+k;      return 1;      }   return 0;   }amatch(lit,len)/*****************************************************************  Match a string**  Tries to match a string to the current input line.  If a*  match is found, the string is removed from the input stream.*  Unlike match, amatch tries to match a string of a specific*  length.**  Inputs:*      lit - pointer to string to match*      line - line to check*      lptr - position to check*      len - length of string to match**  Outputs:*      match - 1 if match found, else 0*****************************************************************/   char *lit;   int len;   {int k;   blanks();   if (k = astreq(line+lptr,lit,len))      {lptr = lptr+k;      while (iscsym(ch())) inbyte();      return 1;      }   return 0;   }blanks()/*****************************************************************  Remove blanks**  Removes white space (blanks and end of lines) from the input*  stream.  Note that tabs are not allowed in ORCA source files,*  so they are not checked for.*****************************************************************/   {while(1)      {while(ch() == 0)         {inline();         preprocess();         if (eof) break;         }      if (ch() == ' ') gch();      else return;      }   }formdec(number)/*****************************************************************  Form an integer string**  Inputs:*      number - integer value**  Outputs:*      string - string containing the ascii version of the number*****************************************************************/   long number;   {long k, zs, sk;   char c;   zs = 0;   sk = 0;   if (number < 0)      {number = -number;      string[sk++] = '-';      }   if (number == 0) string[sk++] = '0';   else      {      k = 1;      while (k <= number/10) k = k*10;      while (k)          {c = number/k + '0';          if (( c != '0') | (k == 1) | zs)             {zs = 1; string[sk++] = c;}          number = number%k;          k = k/10;          }      }   string[sk] = 0;   }outdec(number)/*****************************************************************  Print an integer**  Inputs:*      number - value to print*****************************************************************/   long number;   {int k;   formdec(number);   k = 0;   while (string[k]) outbyte(string[k++]);   }putdec(number)/*****************************************************************  Print an integer to the standard output**  Inputs:*      number - value to print*****************************************************************/   long number;   {int k;   formdec(number);   k = 0;   while (string[k]) putchar(string[k++]);   }