statement()/*****************************************************************  Statement parser**  Outputs:*      statement - id telling what kind of statement was found*****************************************************************/   {if ((ch() == 0) && eof) return;   else if (match("{")) compound();   else if (amatch("if",2))       {doif(); lastst = stif;}   else if (amatch("while",5))       {dowhile(); lastst = stwhile;}   else if (amatch("do",2))       {dodo(); lastst = stdo;}   else if (amatch("for",3))       {dofor(); lastst = stfor;}   else if (amatch("return",6))       {doreturn(); ns(); lastst = streturn;}   else if (amatch("break",5))       {dobreak(); ns(); lastst = stbreak;}   else if (amatch("continue",8))       {docont(); ns(); lastst = stcont;}   else if (match(";"));   else if (amatch("#asm",4))       {doasm(); lastst = stasm;}   else if (match("#list"))       dolist();   else if (amatch("goto",4))       {dogoto(); lastst = stgoto; ns();}   else if (amatch("switch",6))       {doswitch(); lastst = stswitch;}   else if (amatch("default:",8))       {dodefault(); lastst = stdefault;}   else if (amatch("case",4))       {docase(); lastst = stcase;}   else if (labelname())       {dolabel(); lastst = stlabel;}   /* else assume its an expression */   else {expression(); ns(); lastst = stexp; gen0(13/*pop*/);}   return lastst;   }ns()/*****************************************************************  Semicolon enforcer**  Called whenever syntax requires a semicolon*****************************************************************/   {if (!  match(";")) error(17);}compound()/*****************************************************************  Handle a compound statement*****************************************************************/   {   ++ncmp;                  /* new level open */   while (!  match("}"))      if (eof) return;      else statement();   --ncmp;                  /* close current level */   }doif()/*****************************************************************  Handle an if statement*****************************************************************/   {   int flev, flab1, flab2;   flev = locptr;                      /* record current local level */   flab1 = getlabel();                 /* get label for false branch */   test(flab1,false);                  /* get expression, and branch false */   statement();                        /* if true, do a statement */   locptr = flev;                      /* and declare any locals */   if (!  amatch("else",4))             /* if..else ? */      /* simple if - print false label */      {gen1(2/*label*/,flab1);      return;                          /* and exit */      }   /* an if..else statement */   gen1(15/*ujp*/,flab2 = getlabel()); /* jump around false code */   gen1(2/*label*/,flab1);             /* print false label */   statement();                        /* and do else clause */   locptr = flev;                      /* and deallocate locals */   gen1(2/*label*/,flab2);             /* print true label */   }dowhile()/*****************************************************************  Handle a while statement*****************************************************************/   {   int wq[wqsiz];                      /* allocate local queue */   wq[wqloop] = getlabel();            /* and looping label */   wq[wqlab] = getlabel();             /* and exit label */   addwhile(wq);                       /* add entry to queue */                                       /* (for break statement) */   gen1(2/*label*/,wq[wqloop]);        /* loop label */   test(wq[wqlab],false);              /* see if true */   statement();                        /* if so, do a statement */   gen1(15/*ujp*/,wq[wqloop]);         /* loop to label */   gen1(2/*label*/,wq[wqlab]);         /* exit label */   delwhile();                         /* delete queue entry */   }dodo()/*****************************************************************  Handle a do statement*****************************************************************/   {int top;   int wq[wqsiz];                      /* allocate local queue */   wq[wqloop] = getlabel();            /* and looping label */   wq[wqlab] = getlabel();             /* and exit label */   top = getlabel();                   /* and a top label */   addwhile(wq);                       /* add entry to queue */                                       /* (for break statement) */   gen1(2/*label*/,top);               /* set top label */   statement();                        /* do a statement */   if (!  amatch("while",5)) error(18);   gen1(2/*label*/,wq[wqloop]);        /* loop label */   test(top,true);                     /* if true, loop */   gen1(2/*label*/,wq[wqlab]);         /* exit label */   delwhile();                         /* delete queue entry */   }dofor()/*****************************************************************  Handle a for statement*****************************************************************/   {int lab1,lab2;   int wq[wqsiz];                      /* allocate local queue */   wq[wqloop] = getlabel();            /* create labels */   wq[wqlab] = getlabel();   lab1 = getlabel();   lab2 = getlabel();   addwhile(wq);                       /* add entry to queue */                                       /* (for break statement) */   needbrack("(");                     /* get opening parin */   if (!  match(";"))                   /* do the first expression */       {expression();       gen0(13/*popi*/);       ns();       }   gen1(2/*label*/,wq[wqloop]);        /* loop label */   if (!  match(";"))               /* do the second expression */       {expression();       gen1(16/*fjp*/,wq[wqlab]);       ns();       }   else gen1(15/*ujp*/,wq[wqlab]);   gen1(15/*ujp*/,lab2);               /* do the last expression */   gen1(2/*label*/,lab1);   if (!  match(")"))       {expression();       gen0(13/*popi*/);       needbrack(")");       }   gen1(15/*ujp*/,wq[wqloop]);   gen1(2/*label*/,lab2);              /* set statement label */   statement();                        /* do a statement */   gen1(15/*ujp*/,lab1);   gen1(2/*label*/,wq[wqlab]);         /* exit label */   delwhile();                         /* delete queue entry */   }doreturn()/*****************************************************************  Handle a return statement*****************************************************************/   {   if (!  endst()) expression();   gen0(14/*ret*/);   }dobreak()/*****************************************************************  Handle a break statement*****************************************************************/   {   int *ptr;   /* see if any whiles are open */   if ((ptr = readwhile()) == 0) return; /* no */   gen1(15/*ujp*/,ptr[wqlab]);     /* jump to exit label */   }docont()/*****************************************************************  Handle a continue statement*****************************************************************/   {   int *ptr;   /* see if any whiles are open */   if ((ptr = readwhile()) == 0) return; /* no */   gen1(15/*ujp*/,ptr[wqloop]);    /* jump to loop label */   }doswitch()/*****************************************************************  Handle a switch statement*****************************************************************/   {int tcaseptr,tdefaultlab,tfounddefault,tactiveswitch;   int tcaseq[switchsize];   int wq[wqsiz];   int i,caselab,thislab,lastlab;   wq[wqloop] = 0;                     /* no looping label */   wq[wqlab] = getlabel();             /* allocate exit label */   addwhile(wq);                       /* add entry to queue */   if (tactiveswitch = activeswitch)   /* save old switch info */       {tcaseptr = caseptr;       tdefaultlab = defaultlab;       tfounddefault = founddefault;       for (i = 0; i < caseptr; ++i) tcaseq[i] = caseq[i];       }   else activeswitch = true;   caseptr = 0;                        /* set up for case labels */   founddefault = false;   defaultlab = getlabel();   needbrack("(");                     /* evaluate switch condition */   expression();   needbrack(")");   gen1(15/*ujp*/,caselab=getlabel()); /* goto indexed jump */   statement();                        /* do switch body */   gen1(15/*ujp*/,wq[wqlab]);          /* jump around indexed jump */   gen1(2/*label*/,caselab);           /* start of indexed jump */   if (caseptr)                    /* only do xjp if there were case labs */       {gen1(12/*ldci*/,caseq[0]);     /* compute jump index */       gen0(20/*sbi*/);       gen1(12/*ldci*/,1);       gen0(18/*shl*/);       gen1(12/*ldci*/,(caseq[caseptr-2]-caseq[0]+1)*2);       gen2(45/*ldcil*/,defaultlab,0);       gen0(55/*xjp*/);                /* do the indexed jump */       lastlab = -1;                   /* generate the jump table */       for (i = 0; i < caseptr; i = i+2)           {thislab = caseq[i]-caseq[0];           while (thislab-lastlab-1)               {gen1(56/*adr*/,defaultlab);               ++lastlab;               }           ++lastlab;           gen1(56/*adr*/,caseq[i+1]);           }       }   else gen0(13/*popi*/);   gen1(2/*label*/,wq[wqlab]);         /* for branching past xjp */   if (! founddefault) gen1(2/*label*/,defaultlab);   if (activeswitch = tactiveswitch)   /* restore switch variables */       {caseptr = tcaseptr;       defaultlab = tdefaultlab;       founddefault = tfounddefault;       for (i = 0; i < caseptr; ++i) caseq[i] = tcaseq[i];       }   delwhile();                         /* delete queue entry */   }docase()/*****************************************************************  Handle a case label*****************************************************************/   {long num[1]; int i,j;   if (! number(num))       if (! pstr(num))           {error (9);           num[0] = 1;           }   if (! match(":")) error(19);   if (activeswitch)       {if (caseptr < switchsize)           {i = 0;           while ((i < caseptr) && (caseq[i] < num[0])) i = i+2;           if ((caseq[i] == num[0]) && (i < caseptr))               {error(20);               return;               }           j = caseptr;           while (j >= i)               {caseq[j+2] = caseq[j];               caseq[j+3] = caseq[j+1];               j = j-2;               }           caseptr = caseptr+2;           caseq[i] = num[0];           gen1(2/*label*/,caseq[i+1] = getlabel());           }       else error(22);       }   else error(23);   }dodefault()/*****************************************************************  Handle default label*****************************************************************/   {   if (activeswitch)       {if (founddefault) error(21);       else           {founddefault = true;           gen1(2/*label*/,defaultlab);           }       }   else error(23);   }dogoto()/*****************************************************************  Handle goto statement*****************************************************************/   {char sname[namesize];   if (symname(sname))       {gen1(48/*ujpl*/,sname);       if (findloc(sname) || findglb(sname))           error(24);       }   else error(25);   purge();   }dolabel()/*****************************************************************  Handle a goto label*****************************************************************/   {char sname[namesize];   symname(sname);   gen1(49/*labell*/,sname);   match(":");   purge();   statement();   }doasm()/*****************************************************************  Handle in-line assembly code*****************************************************************/   {   cmode = 0;                          /* mark mode as asm */   while(1)       {inline();                      /* get and print lines */       if (match("#endasm") | eof) break;       outstr(line);       outbyte('\r');       }   kill();   cmode = 1;                          /* out of asm mode */   }