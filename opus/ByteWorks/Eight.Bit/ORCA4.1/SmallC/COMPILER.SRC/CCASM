         LIST  ON         SYMBOL ON         MCOPY CC.MACROS******************************************************************  GETLINFO - Get Language Interface Information**  Outputs:*        SFILE - points to source file name*        KPFILE - points to keep file name*        PARMS - points to list of names for partial compile*        KFLAG - keep flag*        LISTFLAG - list output flag**  Notes:*        To make the best use of shared data areas, GETLINFO,*        SETLINFO and MERRF are contained in a single code*        segment.******************************************************************GETLINFO START         USING SYSCCOM         COPY  CCEQUATES         NOP                            switch to assembly         GET_LINFO GL_DCB               get language info         MOVE  GSFILE,WR0               save source file name         LDY   #0         LDA   (WR0),Y         TAY         LDA   #0         STA   LSFILE,YGT1      LDA   (WR0),Y         STA   LSFILE-1,Y         DBNE  Y,GT1         MOVE  GDFILE,WR0               save keep file name         LDY   #0         LDA   (WR0),Y         TAY         LDA   #0         STA   LDFILE,YGT2      LDA   (WR0),Y         STA   LDFILE-1,Y         DBNE  Y,GT2         MOVE  GPARMS,WR0               save partial compile list         MOVE  {WR0},LPARMS,#L:LPARMS         LA    SFILE,LSFILE             set addresses of the strings         LA    KPFILE,LDFILE         LA    PARMS,LPARMS         LM    KFLAG,GKFLAG             set KFLAG         LM    KFLAG+1,#0         STA   LISTFLAG                 set LISTFLAG         STA   LISTFLAG+1         LDA   GOUTF         BEQ   GT4         INC   LISTFLAGGT4      RET         EJECT******************************************************************  MERRF - Set Max Error Level Found**  Inputs:*        TOS - error level******************************************************************MERRF    ENTRY         NOP                            switch to assembly         LDY   #0                       set err level         LDA   (STP),Y         CMP   GMERRF         BLT   MR1         STA   GMERRFMR1      RET         EJECT******************************************************************  SETLINFO - Set Language Interface Information**  Notes:*        The effect of this is to return control to ORCA/HOST******************************************************************SETLINFO ENTRY         NOP                            switch to assembler         LDY   #L:LDFILE-2              change LDFILE to ProDOS formatSL1      LDA   LDFILE,Y         STA   LDFILE+1,Y         DBNE  Y,SL1         LDA   LDFILE         STA   LDFILE+1         LDY   #0SL2      INY         LDA   LDFILE+1,Y         BNE   SL2         STY   LDFILE         LDA   GKFLAG                   if keep is off, clear ops         BNE   SL3         STA   GLOPSSL3      LA    GSFILE,LDFILE            set file name pointers         LA    GDFILE,LDFILE         LA    GPARMS,LPARMS         SET_LINFO GL_DCB               return to ORCA/HOST         EJECT******************************************************************  SETKEEP - Set the Keep File Name**  Inputs:*        TOS - pointer to the keep file name**  Outputs:*        GKFLAG - 1*        GDFLAG - points to new keep file name******************************************************************SETKEEP  ENTRY         NOP                            switch to assembly         INC   GKFLAG                   set keep flag         INC   KFLAG                    set C's keep flag         MOVE  {STP},WR0                set keep file name         LDY   #0LB1      LDA   (WR0),Y         STA   LDFILE,Y         BEQ   LB2         INY         BNE   LB1LB2      RET         EJECT******************************************************************  Common Data for MERRF, GETLINFO, SETLINFO******************************************************************GL_DCB   DC    I1'11'                   GET_LINFO DCBGSFILE   DS    2                        addr of source file nameGDFILE   DS    2                        addr of keep file nameGPARMS   DS    2                        addr of partial compile listGMERR    DS    1                        max error level allowedGMERRF   DS    1                        max error level foundGLOPS    DS    1                        operations flagGKFLAG   DS    1                        keep flagGOUTF    DS    1                        list output flagGSYMF    DS    1                        list symbols flagGERRF    DS    1                        list errors flagORG      DS    4                        ORG valueLSFILE   DS    80                       source file nameLDFILE   DS    80                       keep file nameLPARMS   DS    255                      partial compile list         END******************************************************************  GETLNUM - Get Language # of Source File**  Inputs:*        TOS - pointer to file name**  Outputs:*        GETLNUM - language # of file******************************************************************GETLNUM  START         COPY  CCEQUATES         NOP                            switch to assembly         MOVE  {STP},WR0                get addr of name         LDY   #0                       move to local bufferGT1      LDA   (WR0),Y         BEQ   GT2         STA   FNAME+1,Y         INY         BNE   GT1GT2      STY   FNAME         GET_INFO GI_DCB                get file info         LDA   LNUM                     save number         JSR   SYSCBOOL         RETFNAME    DS    81                       file nameGI_DCB   DC    I1'10'                   GET_INFO DCB         DC    A'FNAME'         DS    2LNUM     DS    2         DS    11         END******************************************************************  SETLNUM - Set the Language Number of a File**  Inputs:*        TOS - language number*        TOS-1 - pointer to the file name**  Notes:*        Makes sure the file is SRC, not TXT.******************************************************************SETLNUM  START         COPY  CCEQUATES         NOP                            switch to assembly         ADD2  STP,#4,WR2               get addr of name         MOVE  {WR2},WR0         LDY   #0                       move to local bufferST1      LDA   (WR0),Y         BEQ   ST2         STA   FNAME+1,Y         INY         BNE   ST1ST2      STY   FNAME         GET_INFO GI_DCB                get file info         LDY   #0                       set the language number         LDA   (STP),Y         STA   LNUM         LM    FTYPE,#$B0               set file type to SRC         LM    GI_DCB,#7                change DCB to a SET_INFO         SET_INFO GI_DCB                set the language number         LM    GI_DCB,#10               change it back         RETFNAME    DS    81                       file nameGI_DCB   DC    I1'10'                   GET_INFO DCB         DC    A'FNAME'         DS    1FTYPE    DS    1LNUM     DS    2         DS    11         END******************************************************************  FINDGLB - Find a Global Label**  Inputs:*        TOS - pointer to the name of the symbol to find**  Outputs:*        TOS - 0 if not found, else pointer into symbol table******************************************************************FINDGLB  START         USING SYSCCOM         COPY  CCEQUATES         NOP                            switch to assembly         MOVE  {STP},WR0                recover the pointer to the!                                        symbol name         LA    WR4,SYMTAB               start at the beginning...LB1      CMPW  WR4,GLBPTR               quit if at end of table         BEQ   LB2         LDX   #NAMEMAX                 check for equality         JSR   ASMSTREQ         BCS   LB3         ADD2  WR4,#SYMSIZ         JMP   LB1LB2      JSR   SYSCFALSE                symbol not found -> return 0         RETLB3      MOVE  WR4,{STP}                symbol found -> return pointer         LDY   #2         LDA   #0         STA   (STP),Y         INY         STA   (STP),Y         RET         END******************************************************************  FINDLOC - Find a Local Label**  Inputs:*        TOS - pointer to the name of the symbol to find**  Outputs:*        TOS - 0 if not found, else pointer into symbol table******************************************************************FINDLOC  START         USING SYSCCOM         COPY  CCEQUATES         NOP                            switch to assembly         MOVE  {STP},WR0                recover the pointer to the!                                        symbol name         LA    WR4,SYMTAB+NUMGLBS*SYMSIZ+SYMSIZ start at the beginning...LB1      CMPW  WR4,LOCPTR               quit if at end of table         BEQ   LB2         LDX   #NAMEMAX                 check for equality         JSR   ASMSTREQ         BCS   LB3         ADD2  WR4,#SYMSIZ         JMP   LB1LB2      JSR   SYSCFALSE                symbol not found -> return 0         RETLB3      MOVE  WR4,{STP}                symbol found -> return pointer         LDY   #2         LDA   #0         STA   (STP),Y         INY         STA   (STP),Y         RET         END******************************************************************  CH - Return the Current Character**  Outputs:*        TOS - current character**  Notes:*        Uses the fact that the line is less than 255 characters******************************************************************CH       START         USING SYSCCOM         COPY  CCEQUATES         NOP                            switch to assembly         SUB2  STP,#4                   update stack pointer         LDY   LPTR                     get disp into line         LDA   LINE,Y                   load the character         AND   #127                     make it ASCII         JSR   SYSCBOOL                 save it on the stack         RET         END******************************************************************  FINDMAC - Find a Macro in the Table**  Inputs:*        TOS - pointer to the macro name**  Outputs:*        TOS - index in macq of the macro, 0 if not found******************************************************************FINDMAC  START         USING SYSCCOM         COPY  CCEQUATES         NOP                            switch to assembly         ADD2  MACPTR,#MACQ,WR2         get addr of end of table         MOVE  {STP},WR0                get addr of symbol         LA    WR4,MACQ                 get addr of start of macro tableLB1      CMPW  WR4,WR2                  quit if at end of table         BGE   LB2         LDX   #NAMEMAX                 check for match         JSR   ASMSTREQ         BCS   LB3                      branch if match found         JSR   SKIP                     skip over macro name         JSR   SKIP                     skip over macro string         JMP   LB1LB2      JSR   SYSCFALSE                symbol not found -> return 0         RETLB3      JSR   SKIP                     symbol found -> return pointer         SUB2  WR4,#MACQ,{STP}         LDY   #2         LDA   #0         STA   (STP),Y         INY         STA   (STP),Y         RET;;  SKIP - Skips a zero terminated string;SKIP     LDY   #0SK1      LDA   (WR4),Y         BEQ   SK2         INY         BNE   SK1SK2      SEC         TYA         ADC   WR4         STA   WR4         BCC   SK3         INC   WR4+1SK3      RTS         END******************************************************************  STREQ - Check to See if Two Strings Are Equal**  Inputs:*        TOS, TOS-1 - pointers to the strings**  Outputs:*        TOS - 0 if no match, else length of strings matched******************************************************************STREQ    START         USING SYSCCOM         COPY  CCEQUATES         NOP                            switch to assembly         MOVE  {STP},WR0,#8             get the addresses         LDY   #0LB1      LDA   (WR0),Y                  quit if second string is done         BEQ   LB3         CMP   (WR4),Y                  quit if not a match         BNE   LB2         INY         BNE   LB1LB2      LDY   #0                       no match -> return 0LB3      TYA                            return Y         JSR   SYSCBOOL         RET         END******************************************************************  ASTREQ - Match a Fixed Length String**  Inputs:*        TOS - length of the string to match*        TOS-1, TOS-2 - addresses of the strings**  Outputs:*        TOS - 0 if no match, else length of string******************************************************************ASTREQ   START         USING SYSCCOMMR1      EQU   $D0         COPY  CCEQUATES         NOP                            switch to assembly         ADD2  STP,#4,MR1               get addresses of the strings         MOVE  {MR1},WR0,#8         LDY   #0                       get length of strings         LDA   (STP),Y         TAX         JSR   ASMSTREQ                 check for match         BCS   LB1         LDY   #0                       no match -> return 0LB1      TYA                            return length of strings matched         JSR   SYSCBOOL         RET         END******************************************************************  ASMSTREQ - Check to See if Two Fixed Length Strings are Equal**  Inputs:*        WR0, WR2 - addresses of the strings*        X - length of the strings**  Outputs:*        C - set if equal, else clear*        Y - length of strings (if C set)******************************************************************ASMSTREQ START         USING SYSCCOM         COPY  CCEQUATES         LDY   #0LB1      LDA   (WR0),Y                  quit if either string is done         BEQ   LB2         LDA   (WR4),Y         BEQ   LB2         CMP   (WR0),Y                  quit if not equal         BNE   LB2         INY         DBNE  X,LB1                    loop if not at end of stringsLB2      LDA   (WR0),Y                  if either string is alphanumeric, no         JSR   ANUM                      match         BCC   RTS         LDA   (WR4),YANUM     CMP   #'a'                     check for alpha-numeric         BLT   LB3         CMP   #'z'+1         BLT   ANLB3      CMP   #'A'         BLT   LB4         CMP   #'Z'+1         BLT   ANLB4      CMP   #'_'         BEQ   AN         CMP   #'0'         BLT   NO         CMP   #'9'+1         BLT   ANNO       SEC         RTSAN       CLCRTS      RTS         END