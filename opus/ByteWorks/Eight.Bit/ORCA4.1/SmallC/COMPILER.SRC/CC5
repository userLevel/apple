callfunction(ptr)/*****************************************************************  Handle a function call**  Inputs:*      ptr - pointer to the symbol table entry*****************************************************************/   char *ptr;   {int nargs;   nargs = 0;   blanks();               /* already saw open parin */   gen0(47/*mst*/);   while (streq(line+lptr,")") == 0)      {if (endst()) break;      expression();         /* get an argument */      nargs = nargs+longsz;      if (match(",") == 0) break;      }   needbrack(")");   gen2(1/*cup*/,nargs+markstk,ptr);   }junk()/*****************************************************************  Destroy a line in the file*****************************************************************/   {if (iscsym(inbyte()))      while(iscsym(ch())) gch();   else while (iscsym(ch()) == 0)      {if (ch() == 0) break;      gch();      }   blanks();   }endst()/*****************************************************************  Test for end of a line**  Outputs:*      endst - 1 if at eof or if next char is ;, else 0*****************************************************************/   {blanks();   return ((streq(line+lptr,";") | (ch() == EOFCH)));   }multidef(sname)/*****************************************************************  Flags an error for multiply defined symbols**  Inputs:*      sname - pointer to symbol name*****************************************************************/   char *sname;   {error(26);   pl(sname); putchar('\r');   }needbrack(str)/*****************************************************************  Checks for matching } or ]**  Inputs:*      str - pointer to character to check for**  Outsputs:*      needbrack - 1 if match, else 0*****************************************************************/   char *str;   {if (match(str) == 0)      error(27);   }addglb(sname,id,typ,value)/*****************************************************************  Add a symbol to the global symbol table**  Inputs:*      sname - pointer to the name of the symbol*      id - kind of symbol (variable, array, pointer, function)*      typ - type of symbol (cchar, cint)*      value - number of storage units (1 byte per unit for*          cchar, 2 for cint)*****************************************************************/   char *sname,id,typ;   int value;   {char *ptr;   if (cptr = findglb(sname)) return cptr;   if (glbptr >= endglb)      {error(28);      return 0;      }   cptr = ptr = glbptr;   while (iscsym(*ptr++ = *sname++));   cptr[ident] = id;   cptr[type] = typ;   cptr[storage] = statik;   cptr[offset] = value;   cptr[offset+1] = value >> 8;   glbptr = glbptr+symsiz;   return cptr;   }addloc(sname,id,typ,value)/*****************************************************************  Add a symbol to the local symbol table**  Inputs:*      sname - pointer to the name of the symbol*      id - kind of symbol (variable, array, pointer, function)*      typ - type of symbol (cchar, cint)*      value - disp in the stack frame to the start of the*          variable*****************************************************************/   char *sname,id,typ;   int value;   {char *ptr;   if (cptr = findloc(sname)) return cptr;   if (locptr >= endloc)      {error(29);      return 0;      }   cptr = ptr = locptr;   while (iscsym(*ptr++ = *sname++));   /* copy name */   cptr[ident] = id;   cptr[type] = typ;   cptr[storage] = stkloc;   cptr[offset] = value;   cptr[offset+1] = value >> 8;   locptr = locptr+symsiz;   return cptr;   }labelname()/*****************************************************************  See if the input string is a legal label name**  Outputs:*      labelname - true if the string is a label, else false*****************************************************************/   {int k;   blanks();   if (iscsymf(ch()) == 0) return false;   k = 0;   while(iscsym(line[lptr+k])) ++k;   return line[lptr+k] == ':';   }symname(sname)/*****************************************************************  See if the input string is a legal symbol name**  Outputs:*      sname - pointer to name of symbol, if found*      symname - 1 if symbol found, else 0*****************************************************************/   char *sname;   {int k;   blanks();   if (iscsymf(ch()) == 0) return 0;   k = 0;   while (iscsym(ch()) && (k <= namemax)) sname[k++] = gch();   sname[k] = 0;   while (iscsym(ch())) gch();   return 1;   }getlabel()/*****************************************************************  Returns next label number**  Outputs:*      getlabel - integer label number*****************************************************************/   {return (++nxtlab);}printlabel(label)/*****************************************************************  Print a label**  Inputs:*      label - number of the label to print*****************************************************************/   int label;   {outstr("syscc");   outdec(label);   }pl(str)/*****************************************************************  Write a line to the console**  Inputs:*      str - pointer to string to write*****************************************************************/   char *str;   {int k;   k = 0;   while (str[k]) putchar(str[k++]);   putchar('\r');   }addwhile(ptr)/*****************************************************************  Add a while definition to the while queue**  Inputs:*      ptr - pointer to the new entry*****************************************************************/   int ptr[];   {   int k;   if (wqptr == wqmax)      {error(30); return;}   k = 0;   while (k < wqsiz)      {*wqptr++ = ptr[k++];}   }delwhile()/*****************************************************************  Delete an entry from the while queue*****************************************************************/   {if (readwhile()) wqptr = wqptr-wqsiz;}readwhile()/*****************************************************************  Get disp to the top while entry**  Outputs:*      readwhile - 0 if no entries, else disp in while queue*****************************************************************/   {   if (wqptr == wq) {error(31); return 0;}   else return (wqptr-wqsiz);   }nch()/*****************************************************************  Get the character after the current one (look-ahead)**  Outputs:*      nch - character*****************************************************************/   {if (ch() == 0) return 0;   else return(line[lptr+1] & 127);   }gch()/*****************************************************************  Get next character**  Returns the current character, then advances one character**  Outputs:*      gch - current character*****************************************************************/   {if (ch() == 0) return 0;   else return(line[lptr++]&127);   }kill()/*****************************************************************  Dispose of the remainder of this line*****************************************************************/   {lptr = 0;   line[lptr] = 0;   }inbyte()/*****************************************************************  Get a byte from the input stream**  Gets a byte, inputing a line and preprocessing it if necessary.**  Outputs:*      inbyte - character read*****************************************************************/   {   while (ch() == 0)      {if (eof) return 0;      inline();      preprocess();      }   return gch();   }inchar()/*****************************************************************  Get a byte from the input stream**  Outputs:*      inbyte - character read*****************************************************************/   {if (ch() == 0) inline();   if (eof) return 0;   return (gch());   }inline()/*****************************************************************  Get the next input line**  Outputs:*      line - new line*      lptr - 0*****************************************************************/   {int k;   esccheck();   while(1)      {      kill();      if (eof) return;      ++numlines;      while(1)         {if (input2) k = fgetc(input2)&255;         else k = fgetc(input)&255;         eof = k == EOFCH;         if ((eof) | (k == '\r') | (lptr >= linemax)) break;         line[lptr++] = k;         }      line[lptr] = 0;      if ((k == EOFCH) && (0 != input2))         {fclose(input2);         input2 = 0;         eof = false;         lptr = 0;         }      if ((listflag) && (eof == false) && (skipping == false))         {if (numlines < 10000)           {putchar(' ');           if (numlines < 1000)               {putchar(' ');               if (numlines < 100)                   {putchar(' ');                   if (numlines < 10)                       {putchar(' ');}                   }               }           }         putdec(numlines);         putchar(' ');         pl(line);         }      if(ctext && cmode)         {comment();         outstr(line);         outstr("\r");         }      if (lptr) return lptr = 0;      }   }