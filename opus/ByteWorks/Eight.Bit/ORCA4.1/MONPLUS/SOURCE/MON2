******************************************************************  BREAK - BREAK POINT HANDLER******************************************************************BREAK    START         USING DATA         PHP                  LET'S GET THOSE REGISTERS!         SEI         MOVE  $45,AREG,#5         PLP         CLD         LDX   #MONSTACK      INIT MON+ STACK         TXS         SEC                  FIX PC ADDRESS         LDA   PC         SBC   #2         STA   PC         LDA   PC+1         SBC   #0         STA   PC+1         CLC                  FIX STACK POINTER (WHY? WHY? WHY?)         LDA   SREG         ADC   #4         STA   SREGBREAK0   ENTRY         JSR   TONEA         PRINT         PRINT2 '  Breakpoint at $'         LDX   PC         LDA   PC+1         JSR   SHOWBOTH                DISPLAY ADDRESS AND SYMBOL (IF ANY)         PRINT         MOVE  PC,(A1,SAFE+1)         JSR   FINDA1                  IF ADR IS IN TABLE         BCS   BREAK1         LDY   #3         LDA   (SYMPTR),Y              AND BPT ATR IS SET         AND   #BMASK         BEQ   BREAK1         DEY         LDA   (SYMPTR),Y                THEN REPLACE THE OPCODE         LDX   #0         STA   (PC,X)         LM    FASTFLAG,#FALSE             TURN OFF 'FAST TRACE' FLAG         JSR   STEP1                       EXECUTE THE INSTRUCTION         LDA   #0                          REPLACE BREAKPOINTSAFE     STA   $FFFF         JMP   TRACE1                      CONTINUE TRACINGBREAK1   INC   PC                        ELSE ADVANCE PC PAST BRK         BNE   BREAK2         INC   PC+1BREAK2   JSR   SHOWREG                     DISPLAY REGISTERS AND STACK         JSR   SHOWSTACK         JMP   PARSE                       CONTINUE AT PARSE         END******************************************************************  DEC - Print AREG in Decimal******************************************************************DEC      START         USING PRODATA         USING STUFF         LDX   #0DOTENS   CMP   #10         BLT   DOONES         SBC   #10         INX         JMP   DOTENSDOONES   STA   ONES         TXA         ASL   A         ASL   A         ASL   A         ASL   A         ORA   ONES         JSR   PRBYTE         RTSONES     DS    1         END******************************************************************  DECLEN - DECREMENT LEN, BUMP FROM AND TO******************************************************************DECLEN   START         USING DATA         INC   FROM           DECR FROM         BNE   DEC1         INC   FROM+1DEC1     INC   TO             DECR TO         BNE   DEC2         INC   TO+1DEC2     LDA   LEN            IF LEN=0         BNE   DEC3         LDA   LEN+1            THEN IF LEN+1=0         SEC                      THEN RETURN CARRY SET         BEQ   RTS         DEC   LEN+1            ELSE DECR LEN+1 (AND...)DEC3     DEC   LEN            ELSE DECR LEN         CLCRTS      RTS         END******************************************************************  DEFSYM - DEFINE SYMBOL******************************************************************DEFSYM   START         USING DATA         JSR   GETNUM         PARSE ADR         BCS   RTS         STX   A1         STY   A1+1         JSR   INSA1          FIND (OR INSERT) A1 IN SYMBOL TABLE         BCS   RTS              (TABLE FULL; ERROR)         JSR   GETSYM         PARSE SYMBOL         BCS   CLC              (NO SYMBOL, JUST RETURN)         JSR   INSSYMRTS      RTSCLC      CLC         RTS         END******************************************************************  DISASM1 - DISSASSEMBLER******************************************************************DISASM1  START         USING TABLES         USING DATA         JSR   ISSYSOP                 SET JSRFLAG/PARMFLAG         PRINT         LDX   PC         LDA   PC+1         JSR   PRNTAX         COUT  #':'         COUT  #SPACE         LDY   #0         LDA   (PC),Y         JSR   INSDS2                  GET FORMAT AND LENGTH         LM    FORMAT2,FORMAT          STORE FORMAT IN A SAFE PLACEDOHEX    LDY   #$FF                    PRINT HEX BYTESPRNTOP   INY         LDA   (PC),Y         JSR   PRBYTE         CPY   LENGTH         BLT   PRNTOPPRNTBL   INY         CPY   #3         BEQ   PRNTSYM         LDX   #2         JSR   PRBL2         BEQ   PRNTBL         (ALWAYS)PRNTSYM  COUT  #SPACE         LDX   PC         LDA   PC+1         STX   A1         STA   A1+1         JSR   LABA1         LDY   #4         BCS   PSYM1         JSR   PRSYMPSYM1    COUT  #SPACE         INY         CPY   #15         BLT   PSYM1SYSOP    BIT   PARMFLAG       IF THIS IS A JSR W/ PARAMETERS         BPL   OPCODE         LDY   #2               THEN DISPLAY THE SYMBOL (OR ABS ADR)         JSR   FABS         PRINT2 ' [$'             DISPLAY PARAMETER LIST         LDY   #3         LDA   (PC),Y         JSR   PRBYTE         COUT  #','         COUT  #'$'         INY         LDA   (PC),Y         TAX         INY         LDA   (PC),Y         JSR   PRNTAX         COUT  #']'         LM    LENGTH,#5          ADJUST LENGTH         RTSOPCODE   LM    TEMP,#3        DECODE AND PRINT OPCODE (NOT A SYSOP)FP1      LDA   #0         LDY   #5FP2      ASL   OPR         ROL   OPL         ROL   A         DEY         BNE   FP2         ADC   #$BF         COUT         DEC   TEMP         BNE   FP1OPERAND  COUT  #SPACE        PRINT OPERAND         LDY   LENGTH         LDA   MYFORMAT         BNE   F1RTS      RTS                  INVALID OPF1       CMP   #1         BNE   F2         COUT  #'#'          IMMEDIATE         COUT  #'$'         LDA   (PC),Y         JMP   PRBYTEF2       CMP   #2         BNE   F3FZP      LDA   (PC),Y        ZERO PAGE         STA   A1         LDA   #0         STA   A1+1         JSR   LABA1         BCS   FZP1         JMP   PRSYMFZP1     COUT  #'$'         LDA   A1         JMP   PRBYTEF3       CMP   #3         BNE   F4FABS     LDA   (PC),Y        ABSOLUTE         STA   A1+1         DEY         LDA   (PC),Y         STA   A1FABS1    JSR   LABA1         BCS   FABS2         JMP   PRSYMFABS2    COUT  #'$'         LDX   A1         LDA   A1+1         JMP   PRNTAXF4       CMP   #4         BNE   F5         RTS                  IMPLIEDF5       CMP   #5         BNE   F6         COUT  #'A'          ACCUMULATORF6       CMP   #6         BNE   F7         COUT  #'('          (ZPAGE,X)         JSR   FZPX         COUT  #')'F7       CMP   #7         BNE   F8         JSR   FPZP           (ZPAGE),Y         COUT  #COMMA         COUT  #'Y'F8       CMP   #8         BNE   F9FZPX     JSR   FZP            ZPAGE,XFX       COUT  #COMMA         COUT  #'X'F9       CMP   #9         BNE   F10         JSR   FABS           ABS,X         JMP   FXF10      CMP   #10         BNE   F11         JSR   FABS           ABS,YFY       COUT  #COMMA         COUT  #'Y'F11      CMP   #11         BNE   F12         COUT  #'('          (ABS)         JSR   FABS         COUT  #')'F12      CMP   #12         BNE   F13         JSR   FZP            ZPAGE,Y         COUT  #COMMA         COUT  #'Y'F13      CMP   #13         BNE   F14         LDA   (PC),Y         JSR   PCADJ3         TAX         INX         BNE   F13A         INYF13A     STX   A1         STY   A1+1         JMP   FABS1F14      CMP   #14         BNE   F15FPZP     COUT  #'('          (ZPAGE)         JSR   FZP         COUT  #')'F15      CMP   #15         BNE   F15Z         COUT  #'('          (ABS,X)         JSR   FABS         COUT  #COMMA         COUT  #'X'         COUT  #')'F15Z     RTSTEMP     DS    1         END******************************************************************  DOBLOAD******************************************************************DOBLOAD  START         USING DATA         USING STUFF         JSR   MAKEPATH         GET_INFO INFODCB         BCS   RTSERRBL2      LA    OPENDCB+3,IOBUFF                 OPEN FILE         OPEN  OPENDCB         BCS   RTSERR         LM    (READDCB+1,CLOSEDCB+1),OPENDCB+5         MOVE  INFODCB+5,(READDCB+2,LOADADR)    GET LOAD ADDR         LA    READDCB+4,$A000                  REQUEST 40K         READ  READDCB                          READ FILE         BCS   RTSERR         MOVE  READDCB+6,LOADLEN                LOADLEN := TRANS_COUNTRTS      PHP                                    SAVE THE STATUS REGISTER         CLOSE CLOSEDCB                         CLOSE FILE         PLP         RTSRTSERR   JSR   PROERR         BCS   RTSCOUNT    DS    1NAMLEN   DS    1PAGE     DS    1         END******************************************************************  DOCAT - ProDOS CATALOG******************************************************************DOCAT    START         USING PRODATA         USING STUFFPC1      GET_INFO INFODCB         JCS   PCERRPC3      LDA   INFODCB+4               IF FILE ISN'T A DIRECTORY         CMP   #$0F         BEQ   PC4         LDA   #$44                      THEN ISSUE ERROR MESSAGE         JMP   PCERRPC4      LA    OPENDCB+3,IOBUFF        OPEN THE DIRECTORY FILE         OPEN  OPENDCB         JCS   PCERRPC5      LDA   IOBUFF+$23         STA   ENTLEN         LDY   IOBUFF+$24         STY   ENTPERBL         DEY                           (SKIP FIRST ENTRY)         CLC                           OFFSET := ENTLEN+4         LDA   ENTLEN         ADC   #<$0004         TAX         LDA   #>$0004         JMP   PC6APC6      LDX   #<$0004                 OFFSET := #$0004         LDA   #>$0004         LDY   ENTPERBLPC6A     STY   COUNT                   COUNT := ENTRIES PER BLOCK         TAY                           ENTRYPTR := BUFFER + OFFSET         TXA         CLC         ADC   #<BUFFER         STA   ENTRYPTR         TYA         ADC   #>BUFFER         STA   ENTRYPTR+1         LM    READDCB+1,OPENDCB+5     READ NEXT DIR BLOCK INTO BUFFER         LA    READDCB+2,BUFFER         LA    READDCB+4,512         READ  READDCB         BCC   PC7         CMP   #$4C                    IF END OF FILE         JNE   PCERR         JMP   PC9                       THEN WE'RE DONEPC7      LDY   #$0                     IF ENTRY IS ACTIVE (STORAGE_TYPE <> 0)         LDA   (ENTRYPTR),Y         AND   #$F0         BEQ   PC7A         JSR   DOENTRY                   THEN DISPLAY THE ENTRY         JSR   KEYCHECK                IF KEYPRESS THEN BEGIN         BCC   PC7A         CMP   #ESCAPE                   IF ESCAPE         BEQ   PC9                         THEN ABORT         JSR   WAITKEY                   WAIT FOR ANOTHER KEY         CMP   #ESCAPE                   IF ESCAPE         BEQ   PC9                         THEN ABORTPC7A     CLC                           ENTRYPTR := ENTRYPTR + ENTLEN         LDA   ENTRYPTR         ADC   ENTLEN         STA   ENTRYPTR         BCC   PC7B         INC   ENTRYPTR+1PC7B     DEC   COUNT                   NEXT ENTRY IN BLOCK         BNE   PC7                     IF WE'RE DONE WITH THIS BLOCKPC8      JMP   PC6                       THEN READ IN THE NEXT ONEPCERR    JSR   PROERRPC9      LM    CLOSEDCB+1,OPENDCB+5         CLOSE CLOSEDCB                CLOSE DIRECTORY         RTSENTLEN   DS    1       LENGTH OF EACH ENTRYENTPERBL DS    1       NUMBER OF ENTRIES PER BLOCKCOUNT    DS    1       NUMBER OF ENTRIES LEFT IN THIS BLOCK         END******************************************************************  DOENTRY - Displays One File Entry******************************************************************!NAME------------ TYP  $BBBB CC/CC/CC CC:CC  MM/MM/MM MM:MM DNBWR  A$=XXXXDOENTRY  START         USING PRODATA         USING STUFF         LDA   #17         STA   TAB         LDY   #0                      DISPLAY NAME         LDA   (ENTRYPTR),Y         AND   #$0F         TAX         INYNAME1    LDA   (ENTRYPTR),Y         ORA   #$80         COUT         DEC   TAB         INY         DEX         BNE   NAME1         LDX   TAB         JSR   PRBL2         LDY   #$10                    DISPLAY TYPE         LDA   (ENTRYPTR),Y         STA   SCRATCH         LDX   #0TYP1     CMP   TYPES,X         BEQ   TYP3         BLT   TYP2         INX         INX         INX         INX         JMP   TYP1TYP2     COUT  #'$'                      TYPE $FN         LDA   SCRATCH         JSR   PRBYTE         JMP   TYP4TYP3     LDY   #3                        DEFINED TYPETYP3A    INX         LDA   TYPES,X         COUT         DEY         BNE   TYP3ATYP4     LDX   #2         JSR   PRBL2         COUT  #'$'                    DISPLAY BLOCKS         LDY   #$13         LDA   (ENTRYPTR),Y         TAX         INY         LDA   (ENTRYPTR),Y         JSR   PRNTAX         LDX   #2         JSR   PRBL2         LDY   #$18                    DISPLAY CREATE DATE & TIME         LDA   (ENTRYPTR),Y         TAX         INY         LDA   (ENTRYPTR),Y         JSR   SHOWDATE         LDX   #1         JSR   PRBL2         LDY   #$1A         LDA   (ENTRYPTR),Y         TAX         INY         LDA   (ENTRYPTR),Y         JSR   SHOWTIME         LDX   #2         JSR   PRBL2         LDY   #$21                    DISPLAY MOD DATE & TIME         LDA   (ENTRYPTR),Y         TAX         INY         LDA   (ENTRYPTR),Y         JSR   SHOWDATE         LDX   #1         JSR   PRBL2         LDY   #$23         LDA   (ENTRYPTR),Y         TAX         INY         LDA   (ENTRYPTR),Y         JSR   SHOWTIME         LDX   #2         JSR   PRBL2         LDA   #7                      DISPLAY ACCESS         STA   TAB         LDY   #$1E         LDA   (ENTRYPTR),Y         AND   #$E3         STA   SCRATCH         LDY   #7ACC1     ASL   SCRATCH         BCC   ACC2         LDA   ACS,Y         COUT         DEC   TABACC2     DEY         BPL   ACC1         LDX   TAB         JSR   PRBL2         PRINT2 'A=$'                  DISPLAY AUX         LDY   #$1F         LDA   (ENTRYPTR),Y         TAX         INY         LDA   (ENTRYPTR),Y         JSR   PRNTAX         PRINT         RTS         END******************************************************************  DSPBRK - DISPLAY ALL SYMBOLS WHOSE BRK ATTRIBUTE IS SET******************************************************************DSPBRK   START         USING DATA         PRINT2 'Breakpoints: '         LA    SYMPTR,SYMTBLDSPBRK1  LDY   #3         LDA   (SYMPTR),Y     GET ATR BYTE         AND   #$80           IF BPT ATR SET         BEQ   DSPBRK3         LDY   #0         LDA   (SYMPTR),Y       THEN GET ADDR         TAX         INY         LDA   (SYMPTR),YDSPBRK2  JSR   SHOWBOTH           DISPLAY ADDRESS (AND LABEL, IF ANY)         COUT  #SPACEDSPBRK3  JSR   NEXTSYM        NEXT ENTRY         BLT   DSPBRK1         PRINT         CLC         RTS         END******************************************************************  DUMP - DISPLAY SYMBOL TABLE******************************************************************DUMP     START         USING DATA         LDA   #TRUE         BMI   DUMP0ADUMP0    ENTRY                         ENTRY POINT FOR JUST TOTAL SYMBOLS         LDA   #FALSEDUMP0A   STA   SHOWFLAG         LA    SYMPTR,SYMTBL         LA    (SYMBOLS,TOTAL),0DUMP1    LDY   #3         LDA   (SYMPTR),Y              IF SYMBOL IS DEFINED AND INVISIBLE         AND   #DMASK+IMASK         CMP   #DMASK+IMASK         BEQ   DUMP1D                    THEN IGNORE IT (DON'T EVEN TOTAL IT)         CMP   #DMASK                  IF SYMBOL IS DEFINED         BNE   DUMP1C         BIT   SHOWFLAG                  THEN IF SHOWFLAG SET         BPL   DUMP1A         JSR   SHOWATR                       THEN DISPLAY ATTRIBUTESDUMP1A   INC2  SYMBOLS                     BUMP SYMBOLS         JSR   KEYCHECK                    IF KEYPRESS         BCC   DUMP1C         CMP   #ESCAPE                       THEN IF ESCAPE         BNE   DUMP1B         LM    SHOWFLAG,#FALSE                   THEN CLEAR SHOWFLAGDUMP1B   JSR   WAITKEY                         WAIT FOR ANOTHER KEY         CMP   #ESCAPE                         IF ESCAPE         BNE   DUMP1C         LM    SHOWFLAG,#FALSE                   THEN CLEAR SHOWFLAGDUMP1C   INC2  TOTAL                   ++TOTALDUMP1D   JSR   NEXTSYM                 NEXT SYMBOL         BLT   DUMP1DUMP2    LDX   SYMBOLS         LDA   SYMBOLS+1         JSR   PRDEC         PRINT2 ' symbol(s) used out of '         LDX   TOTAL         LDA   TOTAL+1         JSR   PRDEC         PRINT         CLCRTS      RTSSHOWFLAG DS    1SYMBOLS  DS    2TOTAL    DS    2         END******************************************************************  ENTNUM - ACCEPT AND PARSE A NUMBER******************************************************************ENTNUM   START         USING DATA         PROMPT #':'         JSR   GETLN         JSR   UPCASE         CONVERT TO UPPERCASE         LDX   #0         STX   LINEPTR         JSR   GETNUM         RTS         END******************************************************************  FINDA1 - FIND A1 IN SYMBOL TABLE; RETURN SYMPTR******************************************************************FINDA1   START         USING DATA         LA    SYMPTR,SYMTBLF1       LDY   #3         LDA   (SYMPTR),Y       IF DEFINED BIT IS SET         AND   #DMASK         BEQ   F2         LDY   #0         LDA   (SYMPTR),Y         THEN IF ADR=A1         CMP   A1         BNE   F2         INY         LDA   (SYMPTR),Y         CMP   A1+1         CLC         BEQ   F3                   THEN RETURN CARRY CLEARF2       JSR   NEXTSYM          (NEXT ENTRY)         BLT   F1F3       RTS         END******************************************************************  FINDSLOT - FIND EMPTY SLOT IN SYMBOL TABLE******************************************************************FINDSLOT START         USING DATA         LA    SYMPTR,SYMTBLF1       LDY   #3         LDA   (SYMPTR),Y       IF DEFINED BIT ISN'T SET         AND   #DMASK         CLC         BEQ   RTS                THEN RETURN CARRY CLEARF2       JSR   NEXTSYM          (NEXT ENTRY)         BLT   F1         PRINT         PRINT ' Symbol table full!'         JSR   TONEB         SECRTS      RTS         END******************************************************************  FINDSYM - FIND SYMBOL IN SYMBOL TABLE******************************************************************FINDSYM  START         USING DATA         LA    SYMPTR,SYMTBLFS1      LDY   #3         LDA   (SYMPTR),Y       IF DEFINED BIT IS SET         AND   #DMASK         BEQ   FS2         INY         LDX   #0FS1A     LDA   (SYMPTR),Y         THEN IF NAME=SYMBOL         CMP   SYMBOL,X         BNE   FS2         INX         INY         CPX   #SYMLEN         BLT   FS1A         CLC                      THEN RETURN CARRY CLEAR         RTSFS2      JSR   NEXTSYM          ELSE NEXT SYMBOL         BLT   FS1         SEC         RTS         END******************************************************************  GETLNZ - GET A LINE******************************************************************GETLNZ   START         PRINT                  PRINT A CARRIAGE RETURNGETLN    ENTRY         MOVE  #$A0,LINE,#255         LM    COUNT,#0         INITIALIZE THE CHARACTER COUNTER         LDA   $33              PRINT THE PROMPT         COUTGS1      RDKEY                  READ A CHARACTER         ORA   #$80             SET THE HI BIT         STA   CHAR             SAVE IT         CMP   #LARROW          CHECK FOR LEFT ARROW         BNE   GS2         DEC   COUNT         BMI   GETLNZ         COUT         JMP   GS1GS2      CMP   #RARROW          CHECK FOR RIGHT ARROW         BNE   GS4         LDX   COUNT         LDA   LINE,X         STA   CHAR             PRINT THE OLD CHARACTERGS4      CMP   #RETURN          CHECK FOR A RETURN         BNE   GS5         INC   COUNT            FINISH OFF THE LINE         LDX   COUNT         STA   LINE-1,X         CLEOL                  CLEAR TO THE END OF LINE         LDA   CHAR         COUT         RTSGS5      CMP   #CTRL_X          QUIT IF WE GOT A CTRL_X         BEQ   GS7         CMP   #SPACE           IGNORE CONTROL CHARACTERS         BLT   GS1         CMP   #$FF         BEQ   GS1         COUT                   WRITE OUT THE CHARACTER         INC   COUNT         LDX   COUNT         LDA   CHAR         STA   LINE-1,X         CPX   #254         BLT   GS1         JSR   TONEBGS7      LDA   #'\'         COUT         JMP   GETLNZCHAR     DS    1COUNT    DS    1         END******************************************************************  GETNAME - PARSE FILENAME FROM INPUT LINE******************************************************************GETNAME  START         USING DATA         USING STUFF         LDX   #29         LDA   #' '             NAME := SPACESGETNAM1  STA   NAME,X         DEX         BPL   GETNAM1         JSR   SKIPSPACE        SKIP OVER SPACES IN LINE         LDX   LINEPTR         LDY   #0GETNAM2  STY   LEN         LDA   LINE,X         CMP   #','         BEQ   GETNAMP         CMP   #RETURN         BEQ   RTS         STA   NAME,Y         INX         STX   LINEPTR         INY         CPY   #MAXNAME         BLT   GETNAM2RTS      LDA   LEN         BEQ   ERR         CLC         RTSERR      SEC         RTSGETNAMP  JSR   GETPARMS         JMP   RTSLEN      DS    1         END******************************************************************  GETNUM - PARSE NUMBER FROM INPUT LINE; RETURNS NUMBER IN YREG/XREG******************************************************************GETNUM   START         USING DATA         JSR   SKIPSPACE        SKIP OVER SPACES         LDY   #0               NUM := 0         STY   NUM         STY   NUM+1         LDX   LINEPTR         LDA   LINE,X         CMP   #'@'             IF SYMBOL         BEQ   TRYSYM             GO PARSE ITG1       LDA   LINE,X         EOR   #$B0         CMP   #$0A         BCC   DIG         ADC   #$88         CMP   #$FA         BCS   DIG         STX   LINEPTR         LDA   LINE,X           A := 1ST NON-HEX DIGIT         CPY   #0               IF Y=0         PHP         LDX   NUM         LDY   NUM+1         PLP         BEQ   ERTS               THEN NUMBER IS NULL (SET CARRY)         CLC         RTSERTS     SEC         RTSDIG      ASL   A         ASL   A         ASL   A         ASL   A         LDY   #3DIG1     ASL   A         ROL   NUM         ROL   NUM+1         DEY         BPL   DIG1         INX         BNE   G1               (ALWAYS)TRYSYM   INX                  BUMP PTR PAST '@'         STX   LINEPTR         JSR   GETSYM           PARSE SYMBOL         BCS   RTS               (ERROR, NULL SYMBOL)         JSR   FINDSYM          FIND SYMBOL         BCS   RTS               (ERROR, SYMBOL NOT FOUND)         LDX   LINEPTR         LDA   LINE,X           GET 1ST CHAR PAST LABEL         PHA         LDY   #0         LDA   (SYMPTR),Y       GET ADDR OF LABEL         TAX         INY         LDA   (SYMPTR),Y         TAY         STX   NUM         STY   NUM+1         PLA         CLCRTS      RTSGETSYM5  LDX   LINEPTR          SYMBOL NOT FOUND         LDA   LINE,X         LDX   #0         LDY   #0         SEC         RTSXENT     DS    1         END******************************************************************  GETPARMS - PARSE SLOT AND DRIVE FROM THE INPUT LINE******************************************************************GETPARMS START         USING DATAGETP0    LDX   LINEPTR         DEXGETP1    INXGETP1A   STX   LINEPTR         LDA   LINE,X         CMP   #' '         BEQ   GETP1         CMP   #RETURN         CLC         BEQ   RTS         CMP   #'S'             SLOT?         BEQ   GETSLOT         CMP   #'D'         BEQ   GETDRIVE         CMP   #','         BEQ   GETP1SEC      SECRTS      RTSGETDRIVE INX         STX   LINEPTR         JSR   GETNUM                   DRIVE 1         BCS   SEC         CPX   #1         BLT   SEC         CPX   #3         BGE   SEC         STX   DRNUM         JMP   GETP0GETSLOT  INX         STX   LINEPTR         JSR   GETNUM                   SLOT1         BCS   SEC         CPX   #1         BCC   SEC         CPX   #8         BCS   SEC         STX   SLNUM         JMP   GETP0         END******************************************************************  GETSYM - PARSE SYMBOL FROM INPUT LINE******************************************************************GETSYM   START         USING DATA         LDY   #SYMLEN-1        SYMBOL := SPACES         LDA   #' 'GS0      STA   SYMBOL,Y         DEY         BPL   GS0         LDX   LINEPTR          SKIP PAST LEADING SPACES         DEXGS0A     INX         LDA   LINE,X         CMP   #' '         BEQ   GS0A         CMP   #$8D         BEQ   RTS              (ERROR; NULL SYMBOL)         LDY   #0GS1      LDA   LINE,X           COPY SYMBOL INTO SYMBOL         CMP   #'0'             (UP TO 1ST NON-ALPHANUMERIC)         BLT   GS2         CMP   #'9'+1         BLT   GS1A         CMP   #'A'         BLT   GS2         CMP   #'Z'+1         BLT   GS1A         CMP   #'A'         BLT   GS2         CMP   #'Z'+1         BGE   GS2         CMP   #$8D         BEQ   GS2GS1A     STA   SYMBOL,Y         INX         INY         CPY   #SYMLEN+1               IF SYMBOL TOO LONG         BLT   GS1                       THEN IGNORE EXTRAGS2      STX   LINEPTR         CLCRTS      RTS         END******************************************************************  GETTHREE - PARSE 'ADR1.ADR2.ADR3' FROM INPUT LINE******************************************************************GETTHREE START         USING DATA         JSR   GETNUM           A1,A2 := RANGE         STX   A1         STY   A1+1         BCS   ERTS         CMP   #'.'         BNE   ERTS         INC   LINEPTR         JSR   GETNUM         BCS   ERTS         STX   A2         STY   A2+1         JSR   GETNUM           A4 := NUMBER         BCS   ERTS         STX   A4         STY   A4+1         RTSERTS     PRINT 'Expecting adr1.adr2 adr3'         SEC         RTS         END******************************************************************  INSA1 - FIND A1 IN SYMBOL TABLE; INSERT IF NOT FOUND******************************************************************INSA1    START         USING DATA         JSR   FINDA1           IF A1 ALREADY IN TABLE         BCC   INS9               THEN RETURN SUCCESS         JSR   FINDSLOT         IF THERE ARE NO EMPTY SLOTS LEFT         BCS   INS9               THEN RETURN FAILURE         LDY   #0               COPY A1 TO ENTRY         LDA   A1         STA   (SYMPTR),Y         INY         LDA   A1+1         STA   (SYMPTR),Y         LDY   #3               SET 'DEFINED' ATR         LDA   #DMASK         STA   (SYMPTR),Y         CLC                  RETURN SUCCESSINS9     RTS         END******************************************************************  INSDS2 - GET LENGTH AND FORMAT OF OPCODE (IN AREG)******************************************************************INSDS2   START         USING TABLES         USING DATA         LDY   #0DIS1A    CMP   EXCEP,Y          LOOKUP OPCODE IN EXCEPTION TABLE         BEQ   GOTEXCEP         HANDLE EXCEPTION         INY         INY         INY         INY         CPY   #LEXCEP         BLT   DIS1A         TAY                  IF NOT IN TABLE, HANDLE AS 6502         LSR   A         BCC   IEVEN         ROR   A         BCS   ERR         AND   #$87IEVEN    LSR   A         TAX         LDA   FMT1,X           (FMT1)         JSR   SCRN2            (SCRN2)         BNE   GF1ERR      LDY   #$80         LDA   #0GF1      STA   MYFORMAT         JSR   GETFMT           (GETFMT)         TAY         LDA   MNEML,Y          GET OPCODE MNEMONIC         STA   OPL         LDA   MNEMR,Y         STA   OPR         RTSGOTEXCEP LDA   EXCEP+1,Y        GET OPCODE MNEMONIC         STA   OPL         LDA   EXCEP+2,Y         STA   OPR         LDA   EXCEP+3,Y        GET FORMAT         AND   #$0F         STA   MYFORMAT         TAX         LDA   FMT2,X           (FMT2)         CPX   #14         BLT   GE1         LDA   #$49         CPX   #14         BEQ   GE1         LDA   #$5AGE1      STA   FORMAT         AND   #$03         STA   LENGTH         RTS         END******************************************************************  INSSYM - INSERT SYMBOL IN TABLE******************************************************************INSSYM   START         USING DATA         JSR   FINDSYM          FIND SYMBOL         BCS   DS2              IF SYMBOL FOUND         PRINT2 'Duplicate label'  THEN ERROR         JSR   SHOWATRDSERR    SEC         RTSDS2      JSR   FINDA1           FIND A1 AGAIN         LDX   #0               COPY SYMBOL TO SYMBOL TABLE         LDY   #4DS2A     LDA   SYMBOL,X         STA   (SYMPTR),Y         INY         INX         CPX   #SYMLEN         BLT   DS2ADS9      CLC         RTS         END******************************************************************  ISSYSOP - SETS JSRFLAG IF OP IS A JSR******************************************************************ISSYSOP  START         USING DATA         LM    (JSRFLAG,PARMFLAG),#FALSE        ASSUME NEITHER JSR NOR SYSOP         LDY   #0         LDA   (PC),Y         CMP   #$20                             IF OP=JSR         BNE   RTS         LM    JSRFLAG,#TRUE                      THEN JSRFLAG := TRUE         INY         LDA   (PC),Y         STA   A1         INY         LDA   (PC),Y         STA   A1+1         JSR   FINDA1                           (A1 NOT IN TABLE)         BCS   RTS         LDY   #3         LDA   (SYMPTR),Y         AND   #PMASK         BEQ   RTS                              (ROUTINE HAS NO PARAMS)         LM    PARMFLAG,#TRUERTS      RTS         END******************************************************************  KEYCHECK - CHECK FOR KEYPRESS******************************************************************KEYCHECK START         LDA   $C000            IF NOT (KEYPRESS)         BMI   GOTKEY         LDA   #0                 THEN AREG := 0         CLC                      RETURN CARRY CLEAR         RTSWAITKEY  ENTRY         STA   $C010WAIT1    LDA   $C000         BPL   WAIT1GOTKEY   STA   $C010            ELSE CLEAR STROBE         CMP   #$E1               CONVERT KEY TO UPPERCASE         BLT   GOTKEY1         AND   #$DFGOTKEY1  SEC                    RETURN CARRY SET, AREG := CHAR         RTS         END******************************************************************  LABA1 - SEE IF LABEL IF DEFINED FOR A1******************************************************************LABA1    START         USING DATA         JSR   FINDA1         BCS   RTS         LDY   #4         LDA   (SYMPTR),Y         SEC         BEQ   RTS         CMP   #' '         BEQ   RTS         CLCRTS      RTS         END******************************************************************  MAKEPATH******************************************************************MAKEPATH START         USING STUFF         LDY   #0             CONVERT NAME TO A PATHNAMEMP1      LDX   NAME,Y         STA   NAME,Y         CPX   #' '         BEQ   MP2         TXA         INY         CPY   #MAXNAME+1         BLT   MP1MP2      STY   NAME         RTS         END******************************************************************  MARKUSED          (PRODOS 1.0)**  SET BIT IN MEMMAP INDICATING PAGE IS USED.**  INPUTS:*        AREG= PAGE NUMBER*        YREG= NUMBER OF PAGES TO MARK*  OUTPUTS:*        MEMMAP UPDATED**  COPYRIGHT 1983, MICROSEEDS, INC.**   DATE WRITTEN:  9 NOV 83  DBW*  LAST MODIFIED: 16 FEB 84  DBW******************************************************************MARKUSED START         USING STUFF         LDX   #0             XREG := FALSE         BEQ   MU1MARKFREE ENTRY         LDX   #$FF           XREG := TRUEMU1      STX   FREE           SAVE FREE FLAG AND PAGE COUNT         STY   COUNT         JSR   MAP1           (AREG = PAGE#)MU2      STA   ORMASK         BIT   FREE           IF FREE = FALSE         BMI   MU2A         ORA   MEMMAP,X         THEN MARK PAGE AS USED         JMP   MU2BMU2A     EOR   #$FF             ELSE MARK PAGE AS FREE         AND   MEMMAP,XMU2B     STA   MEMMAP,X         DEC   COUNT         BEQ   MURTS         LDA   ORMASK         (NEXT BIT OF BITMASK)         LSR   A         BCC   MU2         ROR   A         INX                  (NEXT BYTE OF BITMASK)         JMP   MU2MURTS    RTSMAP1     ENTRY         TAY                  XREG := BYTE OFFSET WITHIN MEMMAP         LSR   A         LSR   A         LSR   A         TAX         TYA                  YREG := BITNUMBER (0-7)         AND   #$07         TAY         LDA   #$80           AREG := OR MASK FOR MEMMAP BYTE         CPY   #0         BEQ   MAP1RTSMAP1A    LSR   A         DEY         BNE   MAP1AMAP1RTS  RTSCOUNT    DS  1FREE     DS  1                'MARK AS FREE' BOOLEANORMASK   DS  1         END******************************************************************  NEXTSYM - POINTS SYMPTR AT NEXT ENTRY IN SYMBOL TABLE******************************************************************NEXTSYM  START         USING DATA         USING STUFF         LDA   SYMPTR           POINT SYMPTR AT NEXT ENTRY         CLC         ADC   #ENTRYLEN         STA   SYMPTR         BCC   NS1         INC   SYMPTR+1NS1      CMP   #<SYMEND         LDA   SYMPTR+1         SBC   #>SYMEND         RTS                  RETURN CARRY SET IF END OF TABLE         END******************************************************************  PRDEC - PRINT AREG/XREG AS DECIMAL NUMBER******************************************************************PRDEC    START         USING DATA         JSR   SCVDC         LDX   #$FFP1       INX         CPX   #4         BEQ   P2         LDA   DECIMAL,X         CMP   #'0'         BEQ   P1         CMP   #$FD         BNE   P2A         LDA   #'3'         BNE   P2AP2       LDA   DECIMAL,XP2A      COUT         INX         CPX   #5         BNE   P2         RTS         END******************************************************************  PRSYM - PRINT SYMBOL POINTED TO BY SYMPTR******************************************************************PRSYM    START         USING DATA         LDY   #4PS1      LDA   (SYMPTR),Y         BEQ   RTS              EXIT ON NULL         CMP   #' '               OR SPACE         BEQ   RTS         COUT         INY         CPY   #4+SYMLEN          OR END OF SYMBOL         BLT   PS1RTS      RTS         END******************************************************************  PUTYX - PRINT YREG/XREG IN BOTH HEX AND DECIMAL******************************************************************PUTYX    START         USING DATA         STX   NUM1         STY   NUM1+1PUTNUM1  ENTRY         COUT  #SPACE         COUT  #'='         LDX   NUM1         LDA   NUM1+1         JSR   PRNTAX         PRINT2 '  ('         DISPLAY '  (DECIMAL)'         BIT   NUM1+1           IF NEGATIVE         BPL   PN2         SEC                    THEN CONVERT TO POSITIVE         LDA   #0         SBC   NUM1         STA   NUM1         LDA   #0         SBC   NUM1+1         STA   NUM1+1         COUT  #'-'                PRINT NEGATIVE SIGNPN2      LDX   NUM1         LDA   NUM1+1         JSR   PRDEC         COUT  #')'         PRINT         CLC         RTS         END******************************************************************  RESTC - RESTORE $C0 - $C5******************************************************************RESTC    START         USING DATA         STA   TA         STX   TX         STY   TY         MOVE  COSAVE,$C0,#6         LDA   TA         LDX   TX         LDY   TY         RTSTA       DS    1TX       DS    1TY       DS    1         END******************************************************************  RESTORE - RESTORE USER REGISTERS******************************************************************RESTORE  START         USING DATA         LDA   PREG         PHA         LDY   YREG         LDX   XREG         LDA   AREG         PLP         RTS         END******************************************************************  SAVE - SAVE USER REGISTERS******************************************************************SAVE     START         USING DATA         STA   AREG         STX   XREG         STY   YREG         PHP         PLA         STA   PREG         RTS         END******************************************************************  SAVEC - SAVE $C0 - $C5******************************************************************SAVEC    START         USING DATA         MOVE  $C0,COSAVE,#6         RTS         END******************************************************************  SCANSPACE - SKIP TO NEXT SPACE OR (RETURN) IN INPUT LINE******************************************************************SCANSPACE START         USING DATA         LDX   LINEPTR         DEXSCANSP1  INX         LDA   LINE,X         CMP   #' '         BEQ   SCANSP2         CMP   #RETURN         BNE   SCANSP1SCANSP2  STX   LINEPTR         RTS         END******************************************************************  SCVDC - CONVERTS AREG/XREG TO DECIMAL VALUE******************************************************************SCVDC    START         USING DATA         USING STUFF         PHA         TXA         PHA         MOVE  M1,ZSAVE,#5     SAVE ZERO PAGE         PLA         STA   M1         PLA         STA   M1+1         LDX   #0               SET LOOP COUNTERCV1      STX   CTR              SET DENOMINATOR         LDA   HDL,X         STA   M3         LDA   HDH,X         STA   M3+1         LA    M2,0             DIVIDE         LDY   #$10             LOOP FOR 16 BITSDV2      ASL   M1               ROLL UP NEXT NUMBER         ROL   M1+1         ROL   M2         ROL   M2+1         SEC                    SUBTRACT FOR THIS DIGIT         LDA   M2         SBC   M3         TAX         LDA   M2+1         SBC   M3+1         BCC   DV3              BRANCH IF MINUS         STX   M2               TURN BIT ON         STA   M2+1         INC   M1DV3      DEY                    NEXT BIT         BNE   DV2         LDA   M1               SET DECIMAL CHAR         ORA   #$B0         LDX   CTR         STA   DECIMAL,X         MOVE  M2,M1            MOVE REMAINDER         INX                    LOOP         CPX   #5         BLT   CV1         MOVE  ZSAVE,M1,#5       RESTORE ZERO PAGE         RTSCTR      DS    1HDH      DC    H'27 03 00 00 00'HDL      DC    H'10 E8 64 0A 01'ZSAVE    DS    6                ZERO PAGE SAVE         END******************************************************************  SCWAT - Clear The Wait Flag**  OUTPUTS:*        WAITF - set to 0*        TWAITF - old value of WAITF******************************************************************SCWAT    START         USING DATA         MOVE  WAITF,PC                 move the address         LDY   #0         LDA   (PC),Y         STA   TWAITF                   save WAIT         TYA         STA   (PC),Y                   clear WAIT         RTS         END******************************************************************  SHOWATR - DISPLAY ATTRIBUTES FOR SYMBOL POINTED TO BY SYMPTR******************************************************************SHOWATR  START         USING DATA         PRINT2 '   $'        DISPLAY ADDRESS         LDY   #0         LDA   (SYMPTR),Y         TAX         INY         LDA   (SYMPTR),Y         JSR   PRNTAX         COUT  #SPACE         LDY   #3               GET ATTRIBUTE BYTE         LDA   (SYMPTR),Y         STA   ATRBYTE         LDX   #0               DISPLAY ATTRIBUTESSHOW1    ASL   ATRBYTE         LDA   #'-'         BCC   SHOW2         LDA   CODES,XSHOW2    COUT         INX         CPX   #7         BLT   SHOW1         COUT  #SPACE         JSR   PRSYM         PRINT         RTSATRBYTE  DS    1              ATTRIBUTE BYTE!  KEEP THESE IN SYNC WITH BMASK, TMASK, ETC!!CODES    DC    C'BTRPI21D'    BREAKPNT, TRACEPNT, REALTIME, PARAMETERS!                             INVISIBLE, 2, 1, DEFINED         END******************************************************************  SHOWBOTH******************************************************************SHOWBOTH START         USING DATA         STX   A1             SAVE ADR         STA   A1+1         JSR   PRNTAX         DISPLAY IT IN HEX         JSR   LABA1          IF THERE'S A LABEL FOR IT         BCS   RTS         COUT  #'/'             THEN DISPLAY THAT, TOO         JSR   PRSYMRTS      RTS         END******************************************************************  SHOWDATE - Displays Date******************************************************************SHOWDATE START         USING PRODATA         USING STUFF         STX   LO         LSR   A         STA   YEAR         TXA         ROR   A         LSR   A         LSR   A         LSR   A         LSR   A         BEQ   NODATE         CMP   #13         BGE   NODATE         STA   MONTH         LDA   LO         AND   #$1F         BEQ   NODATE         CMP   #32         BGE   NODATE         STA   DAY         LDA   YEAR         BEQ   NODATE         CMP   #100         BGE   NODATE         LDA   DAY         JSR   DEC         COUT  #SPACE         DEC   MONTH         LDA   MONTH         ASL   A         ADC   MONTH         TAX         LDY   #3SD1      LDA   MONTHS,X         COUT         INX         DEY         BNE   SD1         COUT  #SPACE         LDA   YEAR         JSR   DEC         RTSNODATE   PRINT2 '<No date>'         RTSLO       DS    1MONTH    DS    1DAY      DS    1YEAR     DS    1MONTHS   DC    C'JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC'         END******************************************************************  SHOWMEM - DISPLAY LEN BYTES STARTING AT FROM******************************************************************SHOWMEM  START         USING DATA         PRINTMEM2A    MOVE  FROM,FROMSAVE   SAVE FROM AND LEN VALUES         MOVE  LEN,LENSAVE         LDX   FROM             DISPLAY FROM ADR AND COLON         LDA   FROM+1         JSR   PRNTAX         COUT  #':'MEM2B    LDA   FROM             IF SEVEN BYTES HAVE BEEN DISPLAYED         AND   #$07         BNE   MEM2B1         COUT  #SPACE            THEN PRINT AN EXTRA SPACEMEM2B1   JSR   LOADFROM         LDA (FROM)         JSR   PRBYTE         COUT  #SPACE         JSR   DECLEN         BCS   DOASCII          IF END OF RANGE DISPLAY ASCIIMEM2C    LDA   FROM             IF LINE ISN'T FULL YET         AND   XAMMASK         BNE   MEM2B              THEN DISPLAY NEXT BYTEMEM3     JSR   DOASCII          DISPLAY ASCII BYTES         JSR   KEYCHECK         IF KEYPRESS         BCC   MEM3A         CMP   #ESCAPE            THEN IF ESCAPE         BEQ   RTS1                 THEN ABORT         JSR   WAITKEY            ELSE WAIT FOR ANOTHER KEY         CMP   #ESCAPE              IF ESCAPE         BEQ   RTS1                   THEN ABORTMEM3A    LDA   FROM             IF END OF MEMORY PAGE (FROM=0)         BNE   MEM2A         JMP   SHOWMEM            THEN DOUBLE SPACEDOASCII  COUT  #'\'         MOVE  FROMSAVE,FROM   RESTORE FROM AND LEN VALUES         MOVE  LENSAVE,LENASC1     JSR   LOADFROM         LDA (FROM)         ORA   #$80         CMP   #' '         BCS   ASC2         LDA   #'.'ASC2     COUT         JSR   DECLEN         BCS   RTS1         LDA   FROM         AND   XAMMASK         BNE   ASC1RTS1     PRINT         CLCRTS      RTSFROMSAVE DS    2LENSAVE  DS    2         END******************************************************************  SHOWTIME - Displays Time******************************************************************SHOWTIME START         USING PRODATA         USING STUFF         STA   HOURS         STX   MINUTES         CPX   #60         BCS   NOTIME         CMP   #23         BCS   NOTIME         ORA   MINUTES         BEQ   NOTIME         LDA   HOURS         JSR   DEC         COUT  #':'         LDA   MINUTES         JSR   DEC         RTSNOTIME   LDX   #5         JSR   PRBL2         RTSHOURS    DS    1MINUTES  DS    1         END******************************************************************  SKIPSPACE - SKIP OVER SPACES IN LINE******************************************************************SKIPSPACE START         USING DATA         LDX   LINEPTR         DEXSKIPSP2  INX         LDA   LINE,X         CMP   #' '         BEQ   SKIPSP2         STX   LINEPTR         RTS         END******************************************************************  SRDTS/SWRTS - READ AND WRITE DISK SECTOR******************************************************************SRDTS    START         USING DATA         USING STUFF         LDA   #$80         BNE   RWTSSWRTS    ENTRY         LDA   #$81RWTS     STA   RWCALL+3                (SAVE CMD)         LDA   DRNUM                   CONVERT SLOT/DRIVE TO UNIT_NUM         ASL   A         ASL   A         ASL   A         ORA   SLNUM         ASL   A         ASL   A         ASL   A         ASL   A         EOR   #$80                    (INVERT DRIVE BIT)         STA   RWDCB+1RWTS1    MOVE  BUFFPTR,RWDCB+2         REPEAT         MOVE  TRACK,RWDCB+4             READ/WRITE BLOCK1         JSR   RWCALL         BCS   RWTS9         INC2  TRACK                     BLOCK1 := BLOCK1 + 1         INC   BUFFPTR+1                 BUFFPTR := BUFFPTR + $200         INC   BUFFPTR+1         CMP2  TRACK,SECTOR            UNTIL BLOCK1 > BLOCK2         BLE   RWTS1RWTS8    CLCRWTS9    RTSRWCALL   READ_BLK RWDCB         BCC   RWCALL1         JSR   PROERRRWCALL1  RTSRWDCB    DC    I1'3'          PARAM_COUNT         DS    1              UNIT_NUM         DC    A'BUFFER'      BUFFER         DS    2              BLOCK_NUM         END******************************************************************  SRITE - PRINT STRING******************************************************************SRITE    START         USING   STUFFRETAD    EQU   $F9            (RETURN ADDR)CHRAD    EQU   $FB            (CHAR ADDR)         MOVE  RETAD,SRETAD         MOVE  CHRAD,SCHRAD         PLA         STA   RETAD         PLA         STA   RETAD+1         LDY   #1                      INPUT FLAGS         LDA   (RETAD),Y         STA   FLAGS         INY                           # OF CHARS         LDA   (RETAD),Y         TAX         INY         LDA   FLAGS         AND   #$40         BEQ   RT1         LDA   (RETAD),Y               ABS ADDR         STA   CHRAD         INY         LDA   (RETAD),Y         STA   CHRAD+1         ADD2  RETAD,#5         JMP   RT2RT1      ADD2  RETAD,#2                IMM ADDR         ADD2  RETAD,#1,CHRAD         CLC         TXA         ADC   RETAD         STA   RETAD         BCC   RT2         INC   RETAD+1RT2      LDY   #0                        PRINT CHARSRT3      LDA   (CHRAD),Y         COUT         INY         DEX         BNE   RT3         LDA   FLAGS                   [RETURN]?         BPL   RTS         PRINTRTS      LDA   RETAD+1         PHA         LDA   RETAD         PHA         MOVE  SRETAD,RETAD         MOVE  SCHRAD,CHRAD         RTSFLAGS    DS    1LY       DS    1SRETAD   DS    2SCHRAD   DS    2         END******************************************************************  SRWAT - Restore The Wait Flag**  OUTPUTS:*        WAITF - set to TWAITF******************************************************************SRWAT    START         USING DATA         MOVE  WAITF,PC                 move the address         LDY   #0         LDA   TWAITF                   load TWAITF         STA   (PC),Y                   WAIT := TWAITF         RTS         END******************************************************************  STORE - STORE BYTES INTO MEMORY STARTING AT TO******************************************************************STORE    START         USING DATAS1       JSR   GETNUM           GET A BYTE         BCS   S2               IF ERROR, CHECK FOR QUOTE         TXA                    ELSE SAVE BYTE IN (TO)         JSR   STOREA         JMP   S1DOUBQUOTE EQU  $A2SINGQUOTE EQU  $A7S2       LDX   #$FF             IF DOUBLE QUOTE         CMP   #DOUBQUOTE         THEN MASK HI BIT ON         BEQ   S3                   GO STORE CHARSS2A      LDX   #$7F             IF SINGLE QUOTE         CMP   #SINGQUOTE         BEQ   S3S2B      CMP   #RETURN          IF IT'S RETURN         BEQ   RTS                THEN RETURN CARRY CLEARERTS     SEC                  (ERROR, UNKNOWN CHAR)         RTS! STORE CHARS INTO TO ADR TIL NEXT QUOTE OR RETURNS3       STX   CHARMASK         SAVE CHARACTER MASKS3A      INC   LINEPTR          BUMP LINEPTR         LDX   LINEPTR         LDA   LINE,X           GET CHAR AT LINEPTR         CMP   #DOUBQUOTE       IF IT'S DOUBLE QUOTE         BEQ   S3B         CMP   #SINGQUOTE       OR SINGLE QUOTE         BEQ   S3B                THEN BACK TO STORING BYTES         CMP   #RETURN          IF IT'S RETURN         BEQ   RTS                THEN WE'RE DONE         AND   CHARMASK         MASK THE CHAR         JSR   STOREA           STORE IT         JMP   S3A              GET NEXT CHARS3B      INC   LINEPTR          MOVE LINEPTR PAST QUOTE         JMP   S1STOREA   JSR   SAVETO           STA (TO)         INC   TO         BNE   RTS         INC   TO+1RTS      CLC                  RETURN CARRY CLEAR         RTSCHARMASK DS    1         END******************************************************************  SURE - ASK IF THEY'RE SURE******************************************************************SURE     STARTS0       PRINT2 '   Are you sure? '         JSR   TONEA         LDA   #0         LDX   #17         JMP   YESORNO         END******************************************************************  TONEB - SOUND VARIOUS BEEPS******************************************************************TONEB    START         USING DATANICETONE EQU   $1FNICEDUR  EQU   $1FNICEREST EQU   $80BADTONE  EQU   6*NICETONE         JSR   TONEB1           ERROR TONE (BAD TONE, TWICE)TONEB1   ENTRY         LDA   #BADTONE         BNE   TONEA1TONEC    ENTRY         JSR   TONEA            NICE TONE, TWICETONEA    ENTRY         LDA   #NICETONE        NICE TONE, ONCETONEA1   LDX   #NICEDURTONEAX   STA   TEMP1            SAVE PITCH AND DURATION         STX   TEMP2TONEREST LDA   #NICEREST        PAUSE BETWEEN NOTES         JSR   WAITTONE0    LDX   TEMP1            TONE ROUTINE FROM RED BOOK         LDA   $C030TONE1    DEY         BNE   TONE2         DEC   TEMP2         BEQ   TONE3TONE2    DEX         BNE   TONE1         BEQ   TONE0TONE3    RTSTEMP1    DS    1TEMP2    DS    1         END******************************************************************  YESORNO - ACCEPTS Y/N KEYPRESS******************************************************************YESORNO  START         CMP   #0               CONVERT AREG TO 0/1 BOOLEAN         BEQ   YN00         LDA   #1YN00     STA   DEFKEY         STX   CHSAVE         TAX         LDA   YN,X         COUT         LDX   CHSAVE         STX   CH         GOTOXY CH,CVYN1      RDKEY                GET UPPERCASE KEY         ORA   #$80         CMP   #'A'         BLT   YN1A         AND   #$DFYN1A     CMP   #RETURN          IF [RETURN]         BNE   YN2         LDX   DEFKEY             THEN USE DEFAULT         LDA   YN,XYN2      LDX   #1               IF NOT (Y OR N)YN2A     CMP   YN,X         BEQ   YN3         DEX         BPL   YN2A         JSR   TONEB              THEN ERROR         JMP   YN1                  TRY AGAINYN3      LDY   TF,X             CONVERT 0/1 BOOLEAN TO 0/FF BOOLEAN         STY   BOOL         COUT                   PRINT RESPONSE         PRINT         LDA   BOOL             RETURN WITH AREG=BOOLEANRTS      RTSCHSAVE   DS    1DEFKEY   DS    1       DEFAULT KEY IF [RETURN] IS PRESSEDBOOL     DS    1       =01 (Y) OR =00 (N)YN       DC    C'NY?'TF       DC    I1'FALSE,TRUE'         END******************************************************************  UPCASE - Convert Input Buffer To Uppercase******************************************************************UPCASE   START         USING PRODATA         USING STUFF         PHA         TXA         PHA         LDX   #$00UP1      LDA   LINE,X         CMP   #RETURN         BEQ   UP3         CMP   #$E1         BCC   UP2         CMP   #$FB         BCS   UP2         SEC         SBC   #$20         STA   LINE,XUP2      INX         BNE   UP1UP3      PLA         TAX         PLA         RTS         END******************************************************************  SYSCOUT - Character Output**  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        $36 - pointer to current character output routine*        A - character to output******************************************************************SYSCOUT  STARTOUT      EQU   $36                      output hook         ORA   #$80         JMP   (OUT)         END******************************************************************  SYMTBL - SYMBOL TABLE******************************************************************SYMTBL   START                         THIS MUST BE THE LAST SEGMENT IN MON+ !         END