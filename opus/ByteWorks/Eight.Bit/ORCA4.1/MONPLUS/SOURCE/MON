         65816 OFF         65C02 OFF         ORG   $9000         SETCOM 20         KEEP  DEBUG         MCOPY MON.MACROS******************************************************************  MON+ (ORCA HOST VERSION)            LAST MOD: 24 NOV 84 (DBW)**  COPYRIGHT 1984 MICROSEEDS, INC.  ALL RIGHTS RESERVED**  REVISION 3.7a*******************************************************************  Version 4.1*  28 June 1988*  Mike Westerfield**  1.    The program has been converted for cross assembly using*        ORCA/M on the Apple IIGS.*  2.    All uses of the F8 ROM have been collected into a single*        code segment.  These uses have been checked against the*        AppleIIGS Firmware Reference Manual (1988).  Any*        subroutines or tables not documented in that manual have*        been replaced with local code and tables.******************************************************************MONPLUS  START                          coldstart         JSR   SCWAT                    clear the wait flag         JMP   INIT         END******************************************************************  COMMON DATA AREA******************************************************************DATA     DATATYPE80   GEQU  1                        type of display;                                       0 = 40 col's;                                       1 - 80 col'sTRUE     GEQU  $FFFALSE    GEQU  $00ORCA     GEQU  TRUE                     true if running under ORCA O/SWAITF    GEQU  $808                     HOST wait flagORG      GEQU  $9000ENTRYPTR GEQU  $00BMASK    GEQU  $80                      breakpoint ATR (symbol attribute byte)TMASK    GEQU  $40                      tracepoint ATRRMASK    GEQU  $20                      realtime ATRPMASK    GEQU  $10                      parameters ATRIMASK    GEQU  $08                      invisible ATRDMASK    GEQU  $01                      defined ATR;;  Zero page locations;CH       GEQU  $24CV       GEQU  $25FORMAT   GEQU  $2ELENGTH   GEQU  $2FYSAV     GEQU  $34L        GEQU  $35A1       GEQU  $3CA2       GEQU  $3EA3       GEQU  $40SYMPTR   GEQU  $40A4       GEQU  $42PC       GEQU  $3AFMT      GEQU  $44;;  Key codes;SPACE    GEQU  $A0                      spaceCOMMA    GEQU  $AC                      commaRETURN   GEQU  $8DLARROW   GEQU  $88RARROW   GEQU  $95CTRL_X   GEQU  $98ESCAPE   GEQU  $9B;;  Fixed hardware locations;LINE     GEQU  $200BVECT    GEQU  $3F0RVECT    GEQU  $3F2IRQVECT  GEQU  $3FE;;  MSC;MONSTACK EQU   $40            MON+ STACK LOCATIONAREG     DS    1                        6502 registersXREG     DS    1YREG     DS    1PREG     DC    H'04'          START WITH INTERRUPTS DISABLEDSREG     DC    H'B0'          INIT USER SREG AWAY FROM MON+'STWAITF   DS    1              TEMPORARY WAIT FLAG STORAGEADRSAVE  DS    1              NEXT ADR TO STORE INTOBUFFPTR  DS    2              POINTER TO BUFFER (RWTS)CALLER   DS    2              RETURN ADDR IS STORED HERECMD      DS    1              COMMAND NUMBER (0-N)DECIMAL  DS    6              DECIMAL PRINT CHARS (FROM SCVDC)DRNUM    DS    1              DRIVE NUMBERCOLS     DS    1              NUMBER OF COL'SEIGHTY   DS    1              EIGHTY COLUMN FLAGFASTFLAG DS    1              FAST TRACE MODE FLAGFORMAT1  DS    1FORMAT2  DS    1INDEX1   DS    1INDEX2   DS    1JSRFLAG  DS    1              WAS LAST OPCODE A JSR?LASTOP   DS    1              LAST OPCODE ENCOUNTERED BY STEPLASTPC   DS    2              LAST PC ENCOUNTERED BY STEPLINEPTR  DS    1              PTR TO NEXT CHAR IN LINEMYFORMAT DS    1NEXTPC   DS    2              NEXT LINE AFTER JSR (TRACE)NUM      DS    2NUM1     DS    2              1ST ARGNUM2     DS    2              2ND ARGOPCODE   DS    1OPL      DS    1OPR      DS    1PARMFLAG DS    1              WAS LAST INSTR A JSR TO A SYSTEM ROUTINE?PREFJSR  DC    I1'TRUE'PREFSTAK DC    I1'FALSE'SECTOR   DS    2              SECTOR NUMBER (READ/WRITE)SLNUM    DS    1              SLOT NUMBERSYMBOL   DS    10             SYMBOL NAMETEMP     DS    1TRACK    DS    2              TRACK NUMBER (READ/WRITE)XAMMASK  DS    1              EQUALS ENTRIES PER LINE MINUS 1COSAVE   DS    6              $C0 SAVE LOCATIONLOADFROM DC    H'AD'          LDA ABS OPCODEFROM     ENTRY         DC    H'00 00'         DC    H'60'          RTSSAVETO   DC    H'8D'          STA ABS OPCODETO       ENTRY         DC    H'00 00'         DC    H'60'          RTSLEN      DS    2SYMLEN   GEQU  10ENTRYLEN GEQU  SYMLEN+4         END******************************************************************  F8ROM - Entry points (and replacements) for the F8 ROM******************************************************************F8ROM    START;;  F8 ROM entry points supported by Apple;PRNTAX   GEQU  $F941          print A,X in hex formatPRBLNK   GEQU  $F948          print 3 spacesPRBL2    GEQU  $F94A          print X spacesPCADJ    GEQU  $F953          adjust monitor program counterSETPWRC  GEQU  $FB6F          create power-up byteBELL1    GEQU  $FBDD          ring bellBS       GEQU  $FC10          backspaceCURSUP   GEQU  $FC1A          move up a lineWAIT     GEQU  $FCA8          delay loopNEXTA4   GEQU  $FCB4          increment pointer at $42NEXTA1   GEQU  $FCBA          compare $3C with $3E and inc $3CPRBYTE   GEQU  $FDDA          print a hex bytePRHEX    GEQU  $FDE3          print a hex digit;;  Tables from the old F8 ROM;FMT1     ENTRY         DC    H'04 20 54 30 0D 80 04 90  03 22 54 33 0D 80 04 90'         DC    H'04 20 54 33 0D 80 04 90  04 20 54 3B 0D 80 04 90'         DC    H'00 22 44 33 0D C8 44 00  11 22 44 33 0D C8 44 A9'         DC    H'01 22 44 33 0D 80 04 90  01 22 44 33 0D 80 04 90'         DC    H'26 31 87 9A'FMT2     ENTRY         DC    H'00 21 81 82 00 00 59 4D  91 92 86 4A 85 9D'CHAR1    ENTRY         DC    H'AC A9 AC A3 A8 A4'CHAR2    ENTRY         DC    H'D9 00 D8 A4 A4 00'MNEML    ENTRY         DC    H'1C 8A 1C 23 5D 8B 1B A1  9D 8A 1D 23 9D 8B 1D A1'         DC    H'00 29 19 AE 69 A8 19 23  24 53 1B 23 24 53 19 A1'         DC    H'00 1A 5B 5B A5 69 24 24  AE AE A8 AD 29 00 7C 00'         DC    H'15 9C 6D 9C A5 69 29 53  84 13 34 11 A5 69 23 A0'MNEMR    ENTRY         DC    H'D8 62 5A 48 26 62 94 88  54 44 C8 54 68 44 E8 94'         DC    H'00 B4 08 84 74 B4 28 6E  74 F4 CC 4A 72 F2 A4 8A'         DC    H'00 AA A2 A2 74 74 74 72  44 68 B2 32 B2 00 22 00'         DC    H'1A 1A 26 26 72 72 88 C8  C4 CA 26 48 44 44 A2 C8';;  Replaced entry points;SCRN2    ENTRY         BCC   RTMSKZ         LSR   A         LSR   A         LSR   A         LSR   ARTMSKZ   AND   #$0F         RTSGETFMT   ENTRY         TAX         LDA   FMT2,X         STA   FORMAT         AND   #$03         STA   LENGTH         TYA         AND   #$8F         TAX         TYA         LDY   #$03         CPX   #$8A         BEQ   MNNDX3MNNDX1   LSR   A         BCC   MNNDX3         LSR   AMNNDX2   LSR   A         ORA   #$20         DEY         BNE   MNNDX2         INYMNNDX3   DEY         BNE   MNNDX1         RTSPCL      EQU   $3APCH      EQU   $3BPCADJ2   ENTRY         LDA   LENGTHPCADJ3   ENTRY         LDY   PCH         TAX         BPL   PCADJ4         DEYPCADJ4   ADC   PCL         BCC   RTS2         INYRTS2     RTS         END******************************************************************  TABLE OF EXCEPTIONAL (65C02) OPCODES******************************************************************TABLES   DATAEXCEP    DC    H'04 AD 06 12'        TSB $00         DC    H'0A 15 1A 05'        ASL A         DC    H'0C AD 06 23'        TSB $0000         DC    H'12 84 C4 1E'        ORA ($00)         DC    H'14 AC C6 12'        TRB $00         DC    H'1A 53 C8 05'        INC A         DC    H'1C AC C6 23'        TRB $0000         DC    H'2A 9C 1A 05'        ROL A         DC    H'32 13 CA 1E'        AND ($00)         DC    H'34 1A AA 18'        BIT $00,X         DC    H'3A 29 88 05'        DEC A         DC    H'3C 1A AA 29'        BIT $0000,X         DC    H'4A 6D 26 05'        LSR A         DC    H'52 34 26 1E'        EOR ($00)         DC    H'5A 8A 74 04'        PHY         DC    H'64 A5 76 12'        STZ $00         DC    H'6A 9C 26 05'        ROR A         DC    H'72 11 48 1E'        ADC ($00)         DC    H'74 A5 76 18'        STZ $00,X         DC    H'7A 8B 74 04'        PHY         DC    H'7C 5B A2 2F'        JMP ($0000,X)         DC    H'80 1C C4 1D'        BRA $302         DC    H'89 1A AA 11'        BIT #$00         DC    H'92 A5 44 1E'        STA ($00)         DC    H'9C A5 76 23'        STZ $0000         DC    H'9E A5 76 29'        STZ $0000,X         DC    H'B2 69 44 1E'        LDA ($00)         DC    H'D2 23 A2 1E'        CMP ($00)         DC    H'DA 8A 72 04'        PHX         DC    H'F2 A0 C8 1E'        SBC ($00)         DC    H'FA 8B 72 04'        PLXEXCEPA   ANOPLEXCEP   EQU   EXCEPA-EXCEP         END******************************************************************  HOST STUFF******************************************************************STUFF    DATA         USING DATAPREFBUFF EQU   $B800          128 BYTE PREFIX BUFFERNAME     EQU   $B880          PATHNAME AREAIOBUFF   EQU   $B900          1024 BYTE IO BUFFERBUFFER   EQU   $BD00          512 BYTE BUFFER (BLOCKS & MISC)! SYSTEM VARIABLESMAXNAME  EQU   64             MAX LENGTH OF FILENAME (PATHNAME)SYMEND   EQU   PREFBUFF-ENTRYLENPRODOS   EQU   $BF00MEMMAP   EQU   $BF58M1       DS    2              USED BY SYSDIVDM2       DS    2M3       DS    2OLDRESET DS    2              OLD RESET VECTOROLDBVECT DS    2              OLD BREAK VECTORLOADADR  DS    2              LOAD ADDR USED BY BLOAD AND BRUNLOADLEN  DS    2INFODCB  DC    I1'10'         DC    A'NAME'        PATHNAME         DS    1              ACCESS         DS    1              FILE_TYPE         DS    2              AUX_TYPE         DS    1              STORAGE_TYPE         DS    2              BLOCKS_USED         DS    4              MOD_DATE/TIME         DS    4              CREATE_DATE/TIMEOPENDCB  DC    I1'3'         DC    A'NAME'        PATHNAME         DS    2              IO_BUFF         DS    1              REF_NUMREADDCB  DC    I1'4'         DS    1              REF_NUM         DS    2              DATA_BUFFER         DS    2              REQUEST_COUNT         DS    2              TRANS_COUNTCLOSEDCB DC    I1'1'         DS    1              REF_NUMPREFDCB  DC    I1'1'         DC    A'PREFBUFF'    PATHNAME         END! DISPLAY PRODOS ERROR NUMBERPROERR   START         USING STUFF         CMP   #$46         BEQ   ERR1         PHA         PRINT2 'ProDOS err $'         PLA         JSR   PRBYTE         PRINT         SEC         RTSERR1     PRINT 'File Not Found'         SEC         RTS         END******************************************************************  PRODATA - Common Data Area For Procat******************************************************************PRODATA  DATA         USING STUFFTAB      DS    1SCRATCH  DS    2ACS      DC    C'RW234BND'             THE ACCESS BITS, BACKWARDS!TYPES    DC    H'01',C'BAD'         DC    H'04',C'TXT'   TEXT         DC    H'06',C'BIN'   BINARY         DC    H'0F',C'DIR'   DIRECTORY         DC    H'B0',C'SRC'   ORCA SOURCE         DC    H'F0',C'CMD'   COMMAND         DC    H'FC',C'BAS'   BASIC         DC    H'FD',C'VAR'   BASIC VARIABLES         DC    H'FE',C'REL'   RELATIVE         DC    H'FF',C'SYS'   SYSTEM         END******************************************************************  COMMANDS TABLE******************************************************************COMMANDS START                LIST OF MON+ COMMANDS AND COMMAND HANDLERS         MSB   OFF         DCI   'ADD'        ADD         DCI   'AND'        LOGICAL AND         DCI   'ASM'        ENTER MINI-ASSEMBLER         DCI   'BLOAD'      LOAD A BINARY FILE         DCI   'BRUN'       BRUN A BINARY FILE         DCI   'CONTINU'    CONTINUE RUNNING A PROGRAM         DCI   'CAT'        DISPLAY CATALOG         DCI   'CLRB'       CLEAR BREAKPOINT         DCI   'CLRSYM'     CLEAR SYMBOL TABLE         DCI   'COMPARE'    COMPARE         DCI   'CONFIG'     CHANGE PREFERENCES         DCI   'EOR'        LOGICAL EXCLUSIVE OR         DCI   'FIND'       FIND (SEARCH)         DCI   'FILL'       FILL MEMORY WITH BYTE         DCI   'GO'         GOSUB ADR         DCI   'GETSYM'     GET SYMBOL TABLE         DCI   'HELP'       DISPLAY COMMAND LIST         DCI   'JUMP'       JUMP ADR         DCI   'LIST'       LIST         DCI   'LABEL'      DEFINE LABEL (SAME AS SYM)         DCI   'MEM'        MEMORY DUMP         DCI   'MOVE'       MEMORY MOVE         DCI   'NEGATE'     2'S COMPLEMENT         DCI   'NOT'        1'S COMPLEMENT         DCI   'OR'         LOGICAL OR         DCI   'PAGE'       PAGE DUMP         DCI   'PREFIX'     PREFERENCES         DCI   'PRON'       PRINTER ON         DCI   'PROFF'      PRINTER OFF         DCI   'QUIT'       ENTER ORCA MONITOR         DCI   'READ'       READ         DCI   'REG'        EXAMINE REGISTERS         DCI   'SETB'       SET BREAKPOINT         DCI   'SUB'        SUBTRACT         DCI   'SYMBOL'     DEFINE SYMBOL         DCI   'TRACE'      TRACE         DCI   'VECTOR'     DISP/CHG BREAK AND RESET VECTORS         DCI   'WRITE'      WRITE         DC    H'00'         MSB   ONJUMPS    ENTRY         DC    A'ADD-1'         DC    A'AND-1'         DC    A'ASM-1'         DC    A'BLOAD-1'         DC    A'BRUN-1'         DC    A'JUMP-1'         DC    A'CAT-1'         DC    A'CLRB-1'         DC    A'CLRSYM-1'         DC    A'COMP-1'         DC    A'CONFIG-1'         DC    A'EOR-1'         DC    A'FIND-1'         DC    A'FILL-1'         DC    A'GO-1'         DC    A'GET-1'         DC    A'HELP-1'         DC    A'JUMP-1'         DC    A'LIST-1'         DC    A'SYM-1'         DC    A'MEM-1'         DC    A'MOVE-1'         DC    A'NEG-1'         DC    A'NOT-1'         DC    A'OR-1'         DC    A'PAGE-1'         DC    A'PREFIX-1'         DC    A'PRON-1'         DC    A'PROFF-1'         DC    A'QUIT-1'         DC    A'READ-1'         DC    A'REG-1'         DC    A'SETB-1'         DC    A'SUB-1'         DC    A'SYM-1'         DC    A'TRACE-1'         DC    A'VECT-1'         DC    A'WRITE-1'         END******************************************************************  ADD - Arithmetic Add******************************************************************ADD      START         USING DATA         LDA   #0         STA   NUM1         STA   NUM1+1A1       JSR   GETNUM         BCS   A2         LDA   NUM         ADC   NUM1         STA   NUM1         LDA   NUM+1         ADC   NUM1+1         STA   NUM1+1         JMP   A1A2       JMP   PUTNUM1         END******************************************************************  AND - Logical And******************************************************************AND      START         USING DATA         LDA   #$FF         STA   NUM1         STA   NUM1+1A1       JSR   GETNUM         BCS   A2         TXA         AND   NUM1         STA   NUM1         TYA         AND   NUM1+1         STA   NUM1+1         JMP   A1A2       JMP   PUTNUM1         END******************************************************************  ASM - Mini Assembler******************************************************************ASM      START         USING DATA         JSR   GETNUM         BCS   ASM1         STX   PC         STY   PC+1ASM1     JMP   NXTLINEREL      SBC   #$81         LSR   A         JNE   ERR         LDY   A2+1         LDX   A2         BNE   REL2         DEYREL2     DEX         TXA         CLC         SBC   PC         STA   A2         BPL   REL3         INYREL3     TYA         SBC   PC+1         JNE   ERRFINDOP   LDY   LENGTHFNDOP2   LDA   A1+1,Y         STA   (PC),Y         DEY         BPL   FNDOP2         JSR   CURSUP         JSR   CURSUP         JSR   DISASM1         JSR   PCADJ         STY   PC+1         STA   PC         JMP   NXTLINETRYNEXT  LDA   A1+1         JSR   INSDS2         LDA   OPR         CMP   A4         BNE   NEXTOP         LDA   OPL         CMP   A4+1         BNE   NEXTOP         LDA   FMT         LDY   FORMAT         CPY   #$9D         BEQ   RELNREL     CMP   FORMAT         BEQ   FINDOPNEXTOP   DEC   A1+1         BNE   TRYNEXT         INC   FMT         DEC   L         BEQ   TRYNEXT         JMP   ERRERR      LDX   PC             SAVE PC         LDA   PC+1         STX   PCSAVE         STA   PCSAVE+1         LDA   #$FF           PARSE A MON+ COMMAND AND RETURN         JSR   PARSE1         LDX   PCSAVE         RESTORE PC         LDA   PCSAVE+1         STX   PC         STA   PC+1NXTLINE  PRINT         LDX   PC             DISPLAY PC         LDA   PC+1         JSR   SHOWBOTH         PROMPT #':'          SET PROMPT         JSR   GETLN         JSR   UPCASE         LDA   #$03         STA   A1+1         LDY   #0NXTMN    JSR   GETNSP         GET NEXT NONSPACE         CMP   #RETURN        IF [RETURN] IS FIRST CHAR IN LINE         BNE   NXTM         CPY   #1         BNE   NXTM         JMP   PARSE            THEN RETURN TO PARSENXTM     ASL   A         SBC   #$BE         CMP   #$C2         JLT   ERR         ASL   A         ASL   A         LDX   #$04NXTM2    ASL   A         ROL   A4         ROL   A4+1         DEX         BPL   NXTM2         DEC   A1+1         BEQ   NXTM2         BPL   NXTMNFORM1    LDX   #$05FORM2    JSR   GETNSP         STY   YSAV         CMP   CHAR1,X         BNE   FORM3         JSR   GETNSP         CMP   CHAR2,X         BEQ   FORM5         LDA   CHAR2,X         BEQ   FORM4         CMP   #'$'         BEQ   FORM4         LDY   YSAVFORM3    CLCFORM4    DEYFORM5    ROL   FMT         CPX   #$03         BNE   FORM7         STY   LINEPTR         JSR   GETNUM         STX   A2         STY   A2+1         LDY   LINEPTR         INY         LDX   #0         BCS   F5A         INXF5A      LDA   A2+1         BEQ   FORM6         INXFORM6    STX   L         LDX   #$03         DEYFORM7    STX   A1+1         DEX         BPL   FORM2         LDA   FMT         ASL   A         ASL   A         ORA   L         CMP   #$20         BCS   FORM8         LDX   L         BEQ   FORM8         ORA   #$80FORM8    STA   FMT         STY   YSAV         LDA   LINE,Y         CMP   #';'         BEQ   FORM9         CMP   #$8D         BEQ   FORM9         JMP   ERRFORM9    JMP   TRYNEXTGETNSP   LDA   LINE,Y         GET NEXT NONSPACE CHAR         INY         CMP   #' '         BEQ   GETNSP         RTSPCSAVE   DS    2         END******************************************************************  BLOAD - Load A Binary File******************************************************************BLOAD    START         USING DATA         USING STUFF         JSR   GETNAME        NAME := NAME PARSED FROM LINE         BCS   RTS         JSR   DOBLOAD         LM    $48,#0         $48 := 0 (DOBLOAD PROBABLY WIPED IT OUT)         BCS   RTS         PRINT2 ' File loaded at $'         LDX   LOADADR         LDA   LOADADR+1         JSR   SHOWBOTH         PRINT         CLCRTS      RTS         END******************************************************************  BRUN - Load And Run A Binary File******************************************************************BRUN     START         USING DATA         USING STUFF         JSR   BLOAD          BLOAD THE FILE         BCS   RTS            IF NO PROBLEMS         JSR   BRUN1            THEN CALL IT AS A SUBR         CLCRTS      RTSBRUN1    JMP   (LOADADR)         END******************************************************************  CAT - Catalog Disk******************************************************************CAT      START         USING STUFF         JSR   GETNAME                 GET PATHNAME         BCS   CAT1         JSR   MAKEPATH         JMP   DOCAT                   CATALOG ITCAT1     GET_PREFIX TEMPDCB            NO PATHNAME SPECIFIED; GET PREFIX         JCS   PROERR         MOVE  PREFBUFF,NAME,#128      COPY IT INTO NAME         JMP   DOCAT                   CATALOG ITTEMPDCB  DC    I1'1'         DC    A'PREFBUFF'         END******************************************************************  CLRB - Clear Breakpoint******************************************************************CLRB     START         USING DATA         JSR   DEFSYM         BCS   RTS         LDY   #3         LDA   (SYMPTR),Y     IF BPT ATR SET         AND   #BMASK         BEQ   RTS         EOR   (SYMPTR),Y       THEN CLEAR IT         STA   (SYMPTR),Y         DEY         LDA   (SYMPTR),Y         REPLACE ORIGINAL OPCODE         LDX   #0         STA   (A1,X)RTS      JMP   DSPBRK         END******************************************************************  CLRSYM - Clear Symbol Table******************************************************************CLRSYM   START         USING DATA         USING STUFF         JSR   SURE         BEQ   RTS         LDA   #TRUE         BMI   CS0CLRSYM0  ENTRY         LDA   #FALSECS0      STA   CLRBP         LA    SYMPTR,SYMTBLCLRSYM1  BIT   CLRBP          IF WE'RE CLEARING BREAKPOINTS         BPL   CLRSYM2         LDY   #3         LDA   (SYMPTR),Y       THEN IF BPT ATR SET         AND   #BMASK         BEQ   CLRSYM2         LDY   #0                 THEN REMOVE BREAKPOINT         LDA   (SYMPTR),Y         STA   A1         INY         LDA   (SYMPTR),Y         STA   A1+1         INY         LDA   (SYMPTR),Y         LDX   #0         STA   (A1,X)CLRSYM2  LDY   #0             ZERO OUT ENTRY         TYACLRSYM2A STA   (SYMPTR),Y         INY         CPY   #ENTRYLEN         BLT   CLRSYM2A         JSR   NEXTSYM         BCC   CLRSYM1         LA    A1,$BF00         MOVE  PROSYM,SYMBOL,#10         JSR   ADDPSYM         BCS   RTS         LA    A1,$00FD         MOVE  ORCASYM,SYMBOL,#10         JSR   ADDPSYMRTS      RTSADDPSYM  JSR   INSA1                   INSERT ADDR A1         BCS   ADDRTS         JSR   INSSYM                  INSERT THE LABEL         LDY   #3                      ATTRIBUTES: PARAMETER, DEFINED         LDA   #PMASK+DMASK            (+IMASK?)         STA   (SYMPTR),YADDRTS   RTSCLRBP    DS    1              CLEAR BREAKPOINTS?PROSYM   DC    C'PRODOS    'ORCASYM  DC    C'ORCAHOST  '         END******************************************************************  COMP - Compare Memory Ranges******************************************************************COMP     START         USING DATA         JSR   GETTHREE       GET SOURCE RANGE         BCS   RTSCOMP1    LDY   #0         LDA   (A1),Y         CMP   (A4),Y         BEQ   COMP2         LDX   A1         LDA   A1+1         JSR   PRNTAX         COUT  #':'         LDA   (A1),Y         JSR   PRBYTE         COUT   #'/'         LDA   (A4),Y         JSR   PRBYTE         JSR   KEYCHECK         BCC   COMP1A         CMP   #ESCAPE         BEQ   RTSCOMP1A   PRINTCOMP2    JSR   NEXTA4         BCC   COMP1CLC      CLCRTS      RTS         END******************************************************************  CONFIG - Display/Change Preferences******************************************************************CONFIG   START         USING DATA         PRINT2 'Display stack? '         LDA   PREFSTAK         LDX   #15         JSR   YESORNO         STA   PREFSTAK         PRINT2 ' Pause on JSR? '         LDA   PREFJSR         LDX   #15         JSR   YESORNO         STA   PREFJSR         CLC         RTS         END******************************************************************  EOR - Logical Exclusive OR******************************************************************EOR      START         USING DATA         LDA   #0         STA   NUM1         STA   NUM1+1E1       JSR   GETNUM         BCS   E2         TXA         EOR   NUM1         STA   NUM1         TYA         EOR   NUM1+1         STA   NUM1+1         JMP   E1E2       JMP   PUTNUM1         END******************************************************************  FILL - Fill Memory With A One Byte Value******************************************************************FILL     START         USING DATA         JSR   GETTHREE       GET RANGE AND VALUE         BCS   RTS         JSR   SURE         BEQ   RTS1         LDY   #0FILL1    LDA   A4         STA   (A1),Y         JSR   NEXTA1         BCC   FILL1RTS1     CLCRTS      RTS         END******************************************************************  FIND - Search Memory******************************************************************FIND     START         USING DATA         JSR   GETNUM         GET RANGE START         BCS   ERTS         CMP   #'.'         BNE   ERTS         STX   NUM1         STY   NUM1+1         INC   LINEPTR         JSR   GETNUM         GET RANGE END         BCS   ERTS         STX   NUM2         STY   NUM2+1         LA    TO,FREEBLOK    STORE BYTES INTO FREEBLOK         JSR   STORE         BCS   ERTS         SEC         LDA   TO         SBC   #FREEBLOK         TAY                  Y := # SEARCH BYTES         BEQ   ERTS         DEY         STY   COUNT         MOVE  NUM1,A1,#4      A1,A2 := NUM1,NUM2MYSRCH3  LDY   COUNTMYSRCH4  LDA   FREEBLOK,Y    GET CHAR FROM SEARCH STRING         CMP   (A1),Y        COMPARE WITH NEXT CHAR!-       BEQ   MYSRCH5       IF MATCH, CONTINUE W/ NEXT CHR!        BIT   WILDFLAG      (NOMATCH) IF WILDCARD FLAG SET!        BPL   MYSRCH6!-       CMP   WILDCARD        THEN IF CHAR<>WILDCHAR CHAR         BNE   MYSRCH6           THEN BUMP A1MYSRCH5  DEY                 MATCH! CHECK NEXT CHAR         BPL   MYSRCH4         COUT   #SPACE         LDX   A1            STRING MATCHED, DISPLAY ADDR         LDA   A1+1         JSR   SHOWBOTHMYSRCH6  JSR   NEXTA1        BUMP A1 (CARRY SET IF DONE)         BCC   MYSRCH3RTS      CLC         RTSERTS     SEC         RTSFREEBLOK DS    16               ROOM FOR 16 BYTESCOUNT    DS    1                NUMBER OF SEARCH BYTES         END******************************************************************  GET SYMBOL TABLE FROM USER PROGRAM******************************************************************GET      START         USING DATAPTR      EQU   $0         MOVE  PTR,ZERO       SAVE ZERO PAGE         JSR   GETNUM         PARSE ADDR         BCS   RTS         STX   PTR         STY   PTR+1G1       LDY   #0             GET SYMBOL FROM THEIR LIST         LDA   (PTR),Y         BEQ   G2             (ZERO MARKS END OF LIST)         LDX   #0             COPY THEIR SYMBOL TO SYMBOLG1A      LDA   (PTR),Y         ORA   #$80           ENSURE HI BIT ON         CMP   #$E1           ENSURE UPPERCASE         BLT   G1AA         AND   #$DFG1AA     STA   SYMBOL,X         INY         INX         CPX   #SYMLEN         BLT   G1A         LDA   (PTR),Y        COPY THEIR ADDR TO A1         STA   A1         INY         LDA   (PTR),Y         STA   A1+1         JSR   INSA1          FIND (OR INSERT) A1 IN SYMBOL TABLE         BCS   RTS              (ERROR; TABLE FULL)         JSR   INSSYM         INSERT SYMBOL IN TABLE         CLC                  POINT A2 AT NEXT ENTRY IN THEIR LIST         LDA   PTR         ADC   #2+SYMLEN         STA   PTR         BCC   G1B         INC   PTR+1G1B      JMP   G1             PARSE NEXT ENTRY IN THEIR LISTG2       JSR   DUMP0          DISPLAY TOTAL SYMBOLS USEDRTS      MOVE  ZERO,PTR       RESTORE ZERO PAGE         RTSZERO     DS    2         END******************************************************************  GO - JSR TO ADDR******************************************************************GO       START                JSR TO ROUTINE         USING DATA         JSR   GETNUM         BCS   GOPCGOYX     ENTRY         STX   PC         STY   PC+1GOPC     ENTRY         LDA   PREG         AND   #$F7           FORCE BINARY MODE         STA   PREG         TSX                  SAVE STACK POINTER         STX   OLDSP         GETREGS              GET USER REGS         JSR   GOPC1          JSR TO PC         PUTREGS              SAVE USER REGS         LDX   OLDSP          RESTORE STACK POINTER         TXS         CLC         RTSGOPC1    JMP   (PC)OLDSP    DS    1              OLD STACK POINTER         END******************************************************************  HELP - Display List Of Commands******************************************************************HELP     START         USING DATA         USING STUFFWIDTH    EQU   8PTR      EQU   A1         SEC         LDA   COLS           MAXCOL := COLS-#WIDTH         SBC   #WIDTH         STA   MAXCOL         LA    PTR,COMMANDS   PTR := ADR(COMMANDS)H0       PRINT         LM    C,#0           CURRENT COLUMN := 0H1       LDY   #0             DISPLAY COMMANDH2       LDA   (PTR),Y         BNE   H2A         CLC                  (END OF COMMAND LIST)         RTSH2A      PHP                  SAVE SIGN BIT         ORA   #$80         COUT         INY         PLP                  RESTORE SIGN BIT         BPL   H2             (NEGATIVE MEANS END OF COMMAND)         TYA                  PTR := ADR(NEXT COMMAND)         CLC         ADC   PTR         STA   PTR         BCC   H3         INC   PTR+1H3       COUT  #SPACE         FILL REST OF FIELD WITH SPACES         INY         CPY   #WIDTH         BLT   H3         CLC                  IF LINE ISN'T FULL YET         LDA   C         ADC   #WIDTH         STA   C         CMP   MAXCOL         BLT   H1               THEN DISPLAY ANOTHER CMD ON IT         JMP   H0               ELSE SKIP TO NEXT LINE BEFORE DISPLAYINGC        DS    1              CURR COLMAXCOL   DS    1              MAX COL         END******************************************************************  INIT - Initialization Code******************************************************************INIT     START         USING DATA         USING STUFFR0       EQU   $2             INPUT LINE POINTERDISP40   EQU   $C00CCOLD     LDX   WASHERE        IF WE'VE NEVER BEEN HERE BEFORE THEN BEGIN         BNE   COLD1         LDY   #0               GET THE INPUT LINEIN       LDA   (R0),Y         ORA   #$80         STA   LINE,Y         INY         BNE   IN         PLA                    SAVE RETURN ADR IN CALLER         STA   CALLER         PLA         STA   CALLER+1         INC2  CALLERCOLD1    CLD         JSR   SINIT          INITIALIZE SYSTEM DEPENDANT STUFF         JSR   CLRSYM0          CLEAR SYMBOL TABLEWARM     ENTRY         AIF   TYPE80=1,.A180         STA   DISP40         RAM   READ=ROM,BANK=2         JSR   PROFF         HOME         AGO   .D180.A180         AIF   ORCA,.B180         LA    $36,$C300.B180         HOME         JSR   PROFF.D180         JSR   TONEA          BEEP AND PRINT BANNER         PRINT 'MON+ 4.1  Copyright 1985,1988  Microseeds Inc'         AIF TYPE80=1,.A280   SPLIT ON 40 OR EIGHTY COL DISPLAY         LM    EIGHTY,#FALSE    THEN EIGHTY := FALSE         LM    XAMMASK,#7         XAMMASK := 8 ENTRIES/LINE         LM    COLS,#40           COLS := 40         AGO   .D280.A280         LM    EIGHTY,#TRUE     THEN EIGHTY := TRUE         LM    XAMMASK,#15        XAMMASK := 16 ENTRIES/LINE         LM    COLS,#80           COLS := 80.D280         LDA   PREG           CLEAR DECIMAL MODE IN STATUS BYTE         AND   #$F7         STA   PREG         LDX   WASHERE         BNE   IN1         DEX                    WASHERE := TRUE         STX   WASHERE         JSR   UPCASE         CAPITOLIZE THE INPUT LINE         JSR   BLOAD          TRY TO BLOAD A FILE FROM THE INPUT LINEIN1      JMP   PARSE          ENTER PARSE ROUTINE;; Initialize System;SINIT    LDA   #>ORG          BITMAP: MON+ AND SYMBOL TABLE AREAS ARE USED         LDY   #>PREFBUFF-ORG         JSR   MARKUSED         LDA   #>PREFBUFF     BITMAP: PREFBUFF, IOBUFF AND BUFFER AREAS ARE FREE         LDY   #>$BF00-PREFBUFF         JSR   MARKFREE         LM    SLNUM,#6       DEFAULT DRIVE IS S6,D1         LM    DRNUM,#1         LDA   #0         TAYIN2      STA   $2000,Y        DESTROY MONITOR CONT OR JUMP EFFECT         INY         BNE   IN2         MOVE  $3F2,OLDRESET  SAVE OLD RESET VECTOR         LA    $3F2,WARM      POINT IT AT OUR WARMSTART ROUTINE         MOVE  BVECT,OLDBVECT SAVE OLD BREAK VECTOR         LM    BVECT-1,#$4C         LA    BVECT,BREAK    POINT IT AT OUR BREAK ROUTINE         JSR   SETPWRC         RTSWASHERE  DC    I1'0'         END******************************************************************  JUMP - JMP TO ADDR******************************************************************JUMP     START                JMP TO ROUTINE         USING DATA         JSR   GETNUM         PC := ADR ENTERED (IF ANY)         BCS   JUMPPC         STX   PC         STY   PC+1JUMPPC   ENTRY         LDA   PREG           FORCE BINARY MODE         AND   #$F7         STA   PREG         GETREGS              GET USER REGS         JMP   (PC)           JUMP TO ROUTINE         END******************************************************************  LIST - Dissamble Memory******************************************************************LIST     START         USING DATA         LA    ENDADR,$FFFF   SET DEFAULT VALUES         LA    LINES,20         JSR   GETNUM         IF START ADDRESS ENTERED         BCS   LIST1         STX   PC               THEN REMEMBER IT         STY   PC+1LIST1    CMP   #'.'           IF RANGE ENTERED         BNE   LIST2         INC   LINEPTR          THEN GET ENDADR         JSR   GETNUM         BCS   LIST2         STX   ENDADR         STY   ENDADR+1         LA    LINES,0            LINES := 0         JMP   LIST3LIST2    CMP   #' '           ELSE IF LINE COUNT ENTERED         BNE   LIST3         JSR   GETNUM           THEN GET NUMBER OF LINES TO LIST         BCS   LIST3         STX   LINES         STY   LINES+1LIST3    JSR   DISASM1        LIST 1 INSTRUCTION         JSR   PCADJ         STA   PC         STY   PC+1         LDA   LINES          IF LINES != 0         ORA   LINES+1         BEQ   LIST3A         DEC2  LINES            THEN --LINES         BEQ   DONE               (DONE IF LINES = 0)LIST3A   JSR   KEYCHECK       IF KEYPRESS         BCC   LIST3B         CMP   #ESCAPE          THEN IF [ESCAPE]         BEQ   RTS                THEN ABORT         JSR   WAITKEY            ELSE WAIT FOR ANOTHER KEY         CMP   #ESCAPE              IF [ESCAPE]         BEQ   RTS                    THEN ABORTLIST3B   CMP2  ENDADR,PC      CHECK FOR END OF RANGE         BCS   LIST3DONE     CLCRTS      RTSLINES    DS    2ENDADR   DS    2         END******************************************************************  MEM - Display/Change Memory******************************************************************MEM      START         USING DATA         JSR   GETNUM           GET FROM         BCS   RTS         STX   FROM         STY   FROM+1         CMP   #'.'             IF RANGE ENTERED         BNE   MEM1         INC   LINEPTR            THEN GET ENDING ADR ALSO         JSR   GETNUM         BCC   MEM1RTS      RTSMEM1     CMP   #' '             IF WE'RE STORING INTO MEMORY         BEQ   GOSTORE         CMP   #':'         BEQ   GOSTORE            THEN GO DO ITMEM2     ENTRY                (FROM PAGE ROUTINE)         TXA                  CALCULATE LEN         SEC         SBC   FROM         STA   LEN         TYA         SBC   FROM+1         STA   LEN+1         JMP   SHOWMEM          GO DISPLAY MEMORYGOSTORE  MOVE  FROM,TO         JMP   STORE            GO STORE IN MEMORYFROMSAVE DS    2LENSAVE  DS    2CHARMASK DS    1         END******************************************************************  MOVE - Copy Memory Range******************************************************************MOVE     START         USING DATA         JSR   GETTHREE         GET RANGE AND ADR         BCS   ERTS         JSR   SURE         BEQ   ERTS         LDA   A1               IF A1 <  A4         CMP   A4         LDA   A1+1         SBC   A4+1         BCC   UP                 THEN MOVE UP         LDY   #0               ELSE MOVE DOWNDOWN1    LDA   (A1),Y         STA   (A4),Y         JSR   NEXTA4         BCC   DOWN1RTS      CLC         RTSERTS     SEC         RTSUP       LDA   A4               ADJUST: A4 := A4+(A2-A1)         ADC   A2         TAX         LDA   A4+1         ADC   A2+1         TAY         SEC         TXA         SBC   A1         STA   A4         TYA         SBC   A1+1         STA   A4+1         LDY   #0               MOVE FROM TOP OF A2 ON DOWNUP1      LDA   (A2),Y         STA   (A4),Y         JSR   PREVA4         BCC   UP1         BCS   RTSPREVA4   ENTRY         DEC2  A4              DECR A4         CMP2  A1,A2           COMPARE A1 TO A2 (SET/CLR CARRY)         DEC2  A2              DECR A2         RTSTEMP     DS    2         END******************************************************************  NEG - 2's Complement******************************************************************NEG      START         USING DATA         JSR   GETNUM         BCS   N2         SEC         LDA   #0         SBC   NUM         TAX         LDA   #0         SBC   NUM+1         TAYN2       JMP   PUTYX         END******************************************************************  NOT - 1's Complement******************************************************************NOT      START         USING DATA         JSR   GETNUM         BCS   N2         TXA         EOR   #$FF         TAX         TYA         EOR   #$FF         TAYN2       JMP   PUTYX         END******************************************************************  OR - Logical OR******************************************************************OR       START         USING DATA         LDA   #0         STA   NUM1         STA   NUM1+1O1       JSR   GETNUM         BCS   O2         TXA         ORA   NUM1         STA   NUM1         TYA         ORA   NUM1+1         STA   NUM1+1         JMP   O1O2       JMP   PUTNUM1         END******************************************************************  PAGE -******************************************************************PAGE     START         USING DATA         JSR   GETNUM         BCS   P1         STX   FROM         STY   FROM+1P1       LDY   FROM+1         LDX   #$FF         JMP   MEM2         END******************************************************************  PARSE - Accepts Commands From Keyboard, Calls Specific*          Command Handler******************************************************************PARSE    START         USING DATA         LDX   #MONSTACK        INIT STACK PTR         TXS         CLD         SEI                    DISABLE INTERRUPTS!         PROMPT #'+'         LM    FASTFLAG,#FALSEP1       JSR   GETLNZ           INPUT LINE         JSR   UPCASE         LDA   #0               RTSFLAG := FALSEPARSE1   ENTRY         STA   RTSFLAG          SAVE RETURN FLAG         LDX   #0               SKIP OVER LEADING SPACES         STX   LINEPTR         STX   CMD              (CMD := 0)         JSR   SKIPSPACE         CMP   #RETURN          IF LINE IS EMPTY         BEQ   P1                 THEN INPUT ANOTHERCOMMANDQ LA    A1,COMMANDS    POINT A1 AT COMMAND TABLENEXTCMD  LDY   #0             CHECK NEXT COMMAND         LDX   LINEPTR        POINT X AT LINE CMDNEXTCH   LDA   (A1),Y         GET NEXT CHAR FROM TABLE         BNE   NEXTCH1        IF ZERO THEN END OF TABLE         JMP   NUMBERQ          (IS IT A NUMBER?)NEXTCH1  ORA   #$80           SET HIBIT OF CHAR         CMP   LINE,X         IF IT MATCHES LINE CHAR         BEQ   MATCH            THEN KEEP GOING         LDA   LINE,X         IF LINE CHAR WAS SPACE OR RETURN         CMP   #' '         BEQ   GOTCMD           THEN WE'VE GOT OUR COMMAND         CMP   #RETURN         BEQ   GOTCMD         INC   CMD            TRY NEXT COMMAND         LDY   #0             POINT A1 AT NEXT CMD IN TABLESKIP     INC2  A1         LDA   (A1),Y         BPL   SKIP         INC2  A1         JMP   NEXTCMD          CHECK THAT COMMANDMATCH    LDA   (A1),Y         IF TABLE CHAR IS NEGATIVE         BMI   GOTCMD           THEN WE'RE DONE         INX                    ELSE CHECK NEXT CHARACTER         INY         JMP   NEXTCHNUMBERQ  LM    LINEPTR,#0     IF WE CAN PARSE A NUMBER OUT OF THIS         JSR   GETNUM         BCS   BADCMD         LM    LINEPTR,#0       THEN SIMULATE MEM CMD         JSR   MEM         JMP   GC2GOTCMD   STX   LINEPTR        SAVE NEW LINEPTR         JSR   SCANSPACE      SCAN OVER TRAILING NON-BLANKS         LDY   #7GC1      LDA   A1,Y         STA   ZSAVE,Y         DEY         BPL   GC1         JSR   DOCMDGC2      BCC   GC2A         JSR   TONEBGC2A     LDY   #7GC2B     LDA   ZSAVE,Y         STA   A1,Y         DEY         BPL   GC2B         JMP   PARSE9BADCMD   PRINT ' Huh?'        UNKNOWN COMMAND         JSR   TONEBPARSE9   BIT   RTSFLAG          IF RETURN IS TRUE         BMI   RTS                THEN RTS         JMP   PARSE              ELSE PARSERTS      RTSDOCMD    LDA   CMD         ASL   A         TAY         LDA   JUMPS+1,Y         PHA         LDA   JUMPS,Y         PHA         RTSRTSFLAG  DS    1       RETURN/LOOP FLAGZSAVE    DS    8       ZERO PAGE SAVE AREA         END******************************************************************  PREFIX - Get/Set ProDOS Prefix******************************************************************PREFIX   START         USING DATA         USING STUFF         JSR   UPCASE         CONVERT LINE TO UPPERCASE         JSR   SKIPSPACE      SKIP OVER SPACES IN LINE         LDX   LINEPTR         LDY   #0GP1      LDA   LINE,X         CMP   #SPACE         BEQ   GP2         CMP   #RETURN         BEQ   GP2         INY         STA   PREFBUFF,Y         INX         CPY   #127         BLT   GP1GP2      CPY   #0         BEQ   GETITSETIT    STY   PREFBUFF       SET PREFIX         SET_PREFIX PREFDCB         BCC   RTSERR      JMP   PROERRGETIT    GET_PREFIX PREFDCB   GET PREFIX         BCS   ERR         PRINT2 'PREFIX: '         LDY   #0GETIT1   CPY   PREFBUFF         BEQ   GETIT2         LDA   PREFBUFF+1,Y         ORA   #$80         COUT         INY         BNE   GETIT1GETIT2   PRINT         CLCRTS      RTS         END******************************************************************  PRON - Turn The Printer On******************************************************************PRON     START         REDIRECT DCB2         RTS         MSB   OFFDCB2     DC    I1'2'         DC    I1'0'         DC    A'PRINTER'PRINTER  DC    I1'8'         DC    C'.PRINTER'         MSB   ON         END******************************************************************  PROFF - Turn The Printer Off******************************************************************PROFF    START         LM    DCB+1,#0         REDIRECT DCB                   to the console         LM    DCB+1,#1         REDIRECT DCB         RTS         MSB   OFFDCB      DC    I1'2'         DC    I1'0'         DC    A'CONSOLE'CONSOLE  DC    I1'8'         DC    C'.CONSOLE'         MSB   ON         END******************************************************************  QUIT - Enter ORCA MONITOR******************************************************************QUIT     START         USING STUFF         USING DATA         JSR   PROFF         HOME         LDA   #>ORG          FREE UP MON+ AREA         LDY   #>SYMEND-ORG         JSR   MARKFREE         LM    BVECT-1,#$4C   RESTORE ORIGINAL BREAK VECTOR         MOVE  OLDBVECT,BVECT         MOVE  OLDRESET,$3F2  RESTORE ORIGINAL RESET VECTOR         JSR   SETPWRC         JSR   SRWAT          RESTORE THE WAIT FLAG         JMP   (CALLER)       RETURN TO THE CALLER         END******************************************************************  READ - read a disk sector******************************************************************READ     START         USING DATA         USING STUFF         JSR   GETTHREE         BCS   RTS         JSR   GETPARMS         ,S,D?         JSR   SURE         BEQ   RTS         MOVE  A1,TRACK         MOVE  A2,SECTOR         MOVE  A4,BUFFPTR         JSR   SRDTSRTS      RTS         END******************************************************************  REG - Display/Change Registers******************************************************************REG      START         USING DATA         LDA   #FALSE           DISPLAY REGISTERS (BUT NOT STACK)         JSR   SHOWREG         PRINT         PRINT2 '  Change? '         LDA   #0         LDX   #10         JSR   YESORNO         BNE   REG1         CLC         RTSREG1     LDX   #0REGA     STX   TEMP         COUT  #SPACE         COUT         LDA   REGNAME,X         COUT         LDA   #'='         STA   $33         COUT         LDA   AREG,X         JSR   PRBYTE         LDA   #' '         COUT         JSR   ENTNUM           ENTER A NUMBER         TXA         LDX   TEMP         BCS   REGB         STA   AREG,XREGB     INX         CPX   #5         BCC   REGASHOWREG  ENTRY         LDX   #0                      DISPLAY REGISTERSSR0      COUT  #SPACE         LDA   REGNAME,X         COUT         COUT  #'='         LDA   AREG,X         JSR   PRBYTE         INX         CPX   #5         BLT   SR0         LDX   #2                      BREAK OUT PREG INTO BITS         JSR   PRBL2         LDA   PREG         AND   #%11001111         LDX   #7SR1      ASL   A         TAY         LDA   #'-'         BCC   SR2         LDA   FLAGS,XSR2      COUT         TYA         DEX         BPL   SR1         LDA   SREG             IF STACK PTR < #MONSTACK         CMP   #MONSTACK         BCS   SR3!        JSR   TONEB              THEN WARN THEM         PRINT         PRINT 'WARNING: Stack conflict with MON+'SR3      CLC         RTSSHOWSTACK ENTRY         LDA   PREFSTAK         IF THEY WANT TO SEE THE STACK         BEQ   SS2         PRINT                  THEN SHOW IT TO THEM         PRINT2 '  Stack ($'         LDA   SREG                 DISPLAY THE STACK POINTER         JSR   PRBYTE         PRINT2 '): '         LDX   SREG                 DISPLAY TOP FEW BYTES ON STACK         INX         LDY   #8SS1      LDA   $100,X         JSR   PRBYTE         COUT  #SPACE         INX         DEY         BNE   SS1SS2      CLC         RTSFLAGS    DC    C'CZIDB?VN'REGNAME  DC    C'AXYPS'         END******************************************************************  SETB - SET BREAK POINT******************************************************************SETB     START         USING DATA         LM    BVECT-1,#$4C         LA    BVECT,BREAK    POINT IT AT OUR BREAK ROUTINE         JSR   DEFSYM           DEFINE SYMBOL         BCS   RTS              (ERROR)         LDY   #3         LDA   (SYMPTR),Y         AND   #BMASK         BNE   RTS              (ALREADY SET)         LDA   (SYMPTR),Y       SET BREAKPOINT ATR         ORA   #BMASK         STA   (SYMPTR),Y         LDX   #0               SAVE OPCODE         DEY         LDA   (A1,X)         STA   (SYMPTR),Y         TXA                  REPLACE OPCODE WITH BRK         STA   (A1,X)RTS      JMP   DSPBRK         END******************************************************************  STEP - SINGEL SETP PROGRAM******************************************************************STEP     START         USING DATALENGTH   EQU   $2FRTN      EQU   $2CXQT      EQU   $3C         JSR   GETNUM         BCS   STEP1         STX   PC         STY   PC+1STEP1    ENTRY         MOVE  PC,LASTPC      SAVE PC         LDY   #0             IF NEXT INSTR IS BRK         LDA   (PC),Y         BNE   STEP1A!        LDA   SREG             THEN ADJUST STACK POINTER!        SEC!        SBC   #4!        STA   SREG         JMP   JUMPPC             LET THE BREAKPOINT HANDLER TAKE CARE OF ITSTEP1A   BIT   FASTFLAG       IF FASTFLAG         BPL   STEP1A1         JSR   INSDS2           THEN GET FORMAT AND LENGTH (SANS DISASSEMBLY)         JSR   ISSYSOP            SET JSRFLAG/PARMFLAG         JMP   STEP1BSTEP1A1  JSR   DISASM1          ELSE DISASM INSTR (AND SET JSRFLAG/PARMFLAG)STEP1B   PLA         STA   RTN         PLA         STA   RTN+1         TSX                  SAVE MY SP         STX   MYSP         LDX   SREG           RESTORE USER SP         TXS         LDX   #8XQINIT   LDA   INITBL,X         INIT XEQ AREA         STA   XQT,X         DEX         BNE   XQINIT         LDA   (PC,X)           USR OPCODE BYTE         STA   LASTOP         BEQ   XBRK             SPECIAL IF BREAK         LDY   LENGTH           LENGTH FROM DISASSEM         CMP   #$20         BEQ   XJSR             HANDLE JSR,RTS,JMP,JMP(),RTI         CMP   #$60         BEQ   XRTS         CMP   #$4C         JEQ   XJMP         CMP   #$6C         JEQ   XJMPAT         CMP   #$40         BEQ   XRTI         CMP   #$7C         JEQ   XJMPAT2         CMP   #$80             CONVERT BRA ($80)         BNE   XQ0         LDA   #$10               INTO BPLXQ0      AND   #$1F             TEST FOR BRANCH         EOR   #$14         CMP   #$04         BEQ   XQ2              COPY USR INTR INTO XEQ AREAXQ1      LDA   (PC),YXQ2      STA   XQT,Y         DEY         BPL   XQ1         JSR   RESTORE          RESTORE USER REGS         JMP   XQT              XEQ USER OPXBRK     JMP   BREAK0           GOTO BREAKPOINT HANDLERXRTI     CLC         PLA                  SIMULATE RTI         STA   PREGXRTS     PLA         STA   PC         PLA         TSX         STX   SREGPCINC2   STA   PC+1PCINC3   LDA   LENGTH           UPDATE PC BY LEN         SEC         JSR   PCADJ3         STY   PC+1         CLC         BCC   NEWPCLXJSR     BIT   PARMFLAG       IF JSR ADR HAS PARAM ATR SET         JMI   XPJSR            THEN HANDLE IT SPECIALXJSR0    CLC                  UPDATE PC AND PUSH ONTO STACK         LDY   #2         JSR   PCADJ2         TAX         TYA                  (FOR JSR SIMULATION)         PHA         TXA         PHA         INX                  SAVE RETURN ADDR IN NEXTPC         BNE   XJSR1         INYXJSR1    STX   NEXTPC         STY   NEXTPC+1         TSX                  SAVE NEW STACK PTR         STX   SREG         LDY   #$2XJMP     CLCXJMPAT   LDA   (PC),Y         TAX                  LOAD PC FOR JMP         DEY                  NOW (JMP)         LDA   (PC),Y         STX   PC+1NEWPCL   STA   PC         BCS   XJMP         BCC   RTNJMPXJMPAT2  LDA   (PC),Y         TAX         DEY         LDA   (PC),Y         STX   PC+1         STA   PC         LDY   $46              (XREG)         INY         JMP   XJMPREGCOL   EQU   44RTNJMP   BIT   FASTFLAG         IF NOT FASTFLAG         BMI   RTJ3         BIT   EIGHTY             THEN IF 80 COLUMNS         BPL   RTJ1         LDA   CH         CMP   #REGCOL         BLT   RTJ0         PRINTRTJ0     LDA   #REGCOL              THEN HTAB TO REGCOL         STA   CH         GOTOXY CH,CV         JMP   RTJ2RTJ1     PRINT                      ELSE (40COL) NEWLINERTJ2     JSR   SHOWREG            DISPLAY REGS         JSR   SHOWSTACK          DISPLAY STACKRTJ3     LDX   MYSP             RESTORE MY SP         TXS         LDA   RTN+1            RETURN TO CALLER         PHA         LDA   RTN         PHA         RTSBRANCH   CLC                  BRANCH TAKEN,         LDY   #1               ADD LEN+2 TO PC         LDA   (PC),Y         JSR   PCADJ3         STA   PC         TYA         SEC         JMP   PCINC2NBRNCH   JSR   SAVE           NORMAL RETURN AFTER EXECUTING USER OP         TSX         STX   SREG         SEC         JMP   PCINC3         GO UPDATE PCINITBL   NOP         NOP                  DUMMY FILL FOR XEQ AREA         NOP         JMP   NBRNCH         JMP   BRANCHXPJSR    LDY   #5             COPY JSR & PARMS TO PXAREAXPJSR1   LDA   (PC),Y         STA   PXAREA,Y         DEY         BPL   XPJSR1         JSR   RESTORE        RESTORE REGSPXAREA   NOP                  DO THE JSR         NOP         NOP         NOP         NOP         NOP         JSR   SAVE           SAVE REGS         CLC                  ADJUST PC (SKIP OVER JSR AND PARAMS)         LDA   PC         ADC   #6         STA   PC         LDA   PC+1         ADC   #0         STA   PC+1         JMP   RTNJMP         CONTINUE AS IF NOTHING HAPPENEDMYSP     DS    1              MY STACK POINTER         END******************************************************************  SUB - ARITHMETIC SUBTRACT******************************************************************SUB      START                SUBTRACTION         USING DATA         JSR   GETNUM         STX   NUM1         STY   NUM1+1         BCS   S2S1       JSR   GETNUM         BCS   S2         SEC         LDA   NUM1         SBC   NUM         STA   NUM1         LDA   NUM1+1         SBC   NUM+1         STA   NUM1+1         JMP   S1S2       JMP   PUTNUM1         END******************************************************************  SYM - DISPLAY/DEFINE/CHANGE SYMBOL******************************************************************SYM      START         USING DATA         JSR   DEFSYM           DEFINE SYMBOL         BCS   SYM1               (ERROR; DUMP SYMBOL TABLE)         JSR   SHOWATR          DISPLAY ATTRIBUTES         CLC         RTSSYM1     JMP   DUMP         END******************************************************************  TRACE - TRACE PROGRAM******************************************************************TRACE    START         USING DATA         JSR   GETNUM                  GET STARTING ADDR         BCS   TRACE0                  (IF THERE IS ONE)         STX   PC         STY   PC+1TRACE0   JSR   STEP1                   EXECUTE ONE INSTRUCTIONTRACE1   ENTRY         LM    PAUSE,#TRUE             YES! PAUSE!         LM    FASTFLAG,#FALSE         TURN OFF FAST MODETRACE2   BIT   JSRFLAG                 IF LAST INSTR WAS A JSR         BPL   TRACE2A         LDA   PAUSE                     THEN IF PAUSE         BNE   TRACE2J         LDA   PREFJSR                   OR PREFJSR         BEQ   TRACE2ATRACE2J  JSR   TONEA                       THEN BEEP         JMP   TRACE2W                       WAIT FOR KEYPRESSTRACE2A  LDA   PAUSE                   IF PAUSE         BNE   TRACE2W                   THEN WAIT FOR KEYTRACE2C  JSR   KEYCHECK                IF NOT KEYPRESS         BCC   TRACE4                    THEN TAKE ANOTHER STEP         JMP   TRACE3                    ELSE CHECK KEYTRACE2W  JSR   WAITKEY                 WAIT FOR KEYTRACE3   CMP   #ESCAPE                 IF [ESCAPE]         BNE   TRACE3A         BIT   JSRFLAG                   AND LAST INSTR WAS A JSR         BPL   TRACE3X         BIT   PARMFLAG                  AND WASN'T A SYSTEM CALL         BMI   TRACE3X         INC   SREG                        THEN RESTORE SREG         INC   SREG         MOVE  LASTPC,PC                     RESTORE LAST PCTRACE3X  JMP   RTS                       EXITTRACE3A  CMP   #'C'             IF [C]         BEQ   CONTINUE           THEN JMP TO PC         CMP   #'J'             IF [J]         BEQ   CONTINUE         CMP   #'R'             IF [R]         BEQ   REALTIME           THEN JSR TO PC         CMP   #'F'             IF [F]         BEQ   FASTTIME           THEN FAST TRACE TO NEXT RTS         CMP   #SPACE           IF [SPACE]         BNE   TRACE3B         LM    PAUSE,#1           THEN PAUSE := TRUE         JMP   TRACE4TRACE3B  LM    PAUSE,#FALSE       ELSE PAUSE := FALSETRACE4   JSR   STEP1            TAKE ANOTHER STEP         JMP   TRACE2CONTINUE PRINT                CONTINUE PROGRAM (JMP TO PC)         PRINT ' Continuing...'         GETREGS         JMP   (PC)REALTIME BIT   PARMFLAG       IF LAST INSTR WAS A SYSTEM CALL         BMI   RT1         BIT   JSRFLAG        OR IT WASN'T A JSR         BMI   RT2RT1      JMP   TRACE4           THEN JUST STEP ONE INSTRUCTIONRT2      JSR   REALSUB          ELSE DO IT IN REALTIME         JMP   TRACE0FASTTIME PRINT                         FAST TRACE:         PRINT ' Fast trace...'         LM    FASTFLAG,#TRUE          FASTFLAG := TRUEFAST1    JSR   KEYCHECK                IF KEYPRESS         BCS   FAST2                     THEN GET OUT OF FAST TRACE MODE         LDY   #0                      GET NEXT OPCODE         LDA   (PC),Y         CMP   #$60                      IF RTS         BEQ   FAST2                       THEN GET OUT OF FAST TRACE MODE         CMP   #$20                      IF JSR         BNE   FAST1A         JSR   STEP1                       THEN STEP THE JSR         JSR   REALSUB1                      EXECUTE SUBR IN REALTIME         JMP   FAST1FAST1A   JSR   STEP1                     STEP         JMP   FAST1FAST2    LM    FASTFLAG,#FALSE         FASTFLAG := FALSE         JMP   TRACE0                  CONTINUE TRACINGREALSUB  PRINT         PRINT ' Running free...'REALSUB1 JSR   GOPC             EXECUTE CODE STARTING AT PC         INC   SREG             ADJUST USER SP         INC   SREG         MOVE  NEXTPC,PC       PC := NEXTPC (ADR AFTER JSR)         LA    NEXTPC,0         NEXTPC := 0         RTSRTS      JMP   PARSEPAUSE    DS    1         END******************************************************************  VECT - DISPLAY/CHANGE BREAK AND RESET VECTORS******************************************************************VECT     START         USING DATA         PRINT2 'Reset vector ='         LDX   RVECT         LDA   RVECT+1         JSR   SHOWBOTH         JSR   ENTNUM         BCS   V1         STX   RVECT         STY   RVECT+1         TYA         EOR   #$A5         STA   RVECT+2V1       PRINT         PRINT2 'Break vector ='         LDX   BVECT         LDA   BVECT+1         JSR   SHOWBOTH         JSR   ENTNUM         BCS   V2         STX   BVECT         STY   BVECT+1V2       PRINT         PRINT2 ' IRQ  vector ='         LDX   IRQVECT         LDA   IRQVECT+1         JSR   SHOWBOTH         JSR   ENTNUM         BCS   V3         STX   IRQVECT         STY   IRQVECT+1V3       CLC         RTS         END******************************************************************  WRITE - WRITE DISK SECTOR******************************************************************WRITE    START         USING DATA         USING STUFF         JSR   GETTHREE         BCS   RTS         JSR   GETPARMS         ,S,D?         JSR   SURE         BEQ   RTS         MOVE  A1,TRACK         MOVE  A2,SECTOR         MOVE  A4,BUFFPTR         JSR   SWRTSRTS      RTS         END         APPEND MON2