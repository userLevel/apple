         LIST  OFF         SYMBOL OFF         MCOPY /RAM/I8.MACROS         KEEP  E.INT8         COPY  COMMON******************************************************************  SYSCV48 - Convert Four Byte Integer to Eight Byte Integer**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - four byte integer**  OUTPUTS:*        SYSS1 - eight byte integer******************************************************************SYSCV48  START         LDA   #0         LDX   SYSS1+3         BPL   CV1         LDA   #$FFCV1      STA   SYSS1+4         STA   SYSS1+5         STA   SYSS1+6         STA   SYSS1+7         RTS         END******************************************************************  SYSCV82 - Convert Eight Byte Integer to Two Byte Integer**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - eight byte integer**  OUTPUTS:*        SYSS1 - two byte integer******************************************************************SYSCV82  START         LDA   SYSS1+2         BEQ   CV1         CMP   #$FF         BNE   CV2CV1      CMP   SYSS1+3         BNE   CV2         CMP   SYSS1+4         BNE   CV2         CMP   SYSS1+5         BNE   CV2         CMP   SYSS1+6         BNE   CV2         CMP   SYSS1+7         BNE   CV2         AND   #$80         EOR   SYSS1+1         BPL   CV3CV2      ERROR #7                       OverflowCV3      RTS         END******************************************************************  SYSCV84 - Convert Eight Byte Integer to Four Byte Integer**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - eight byte integer**  OUTPUTS:*        SYSS1 - four byte integer******************************************************************SYSCV84  START         LDA   SYSS1+4         BEQ   CV1         CMP   #$FF         BNE   CV2CV1      CMP   SYSS1+5         BNE   CV2         CMP   SYSS1+6         BNE   CV2         CMP   SYSS1+7         BNE   CV2         AND   #$80         EOR   SYSS1+4         BPL   CV3CV2      ERROR #7                       OverflowCV3      RTS         END******************************************************************  SYSSQR8 - Eight Byte Integer Square Root**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - argument**  OUTPUTS:*        SYSS1 - result**  NOTES:*        1)  If the argument is negative, the result is*              SQRT(-SYSS1)*        2)  Uses SYSDIV8, SYSMUL8, SYSSIG8, SYSSUB8, SYSADD8.******************************************************************SYSSQR8  START;;  Create an initial guess;         LDA   SYSS1+7                  check for a negative argument         BPL   CG1         LDX   #7         LDY   #0CG0      LDA   SYSS1,X         STA   SYSS2,X         STY   SYSS1,X         DBPL  X,CG0         JSR   SYSSUB8         ERROR #5                       invalid operationCG1      LDY   #28                      the initial guess is the largest power         LDX   #7                        of two that is <= the answerCG1A     LDA   SYSS1,X         BNE   CG2         DEY         DEY         DEY         DEY         DBNE  X,CG1A         LDA   SYSS1         BEQ   CG3CG2      INY         LSR   A         LSR   A         BNE   CG2         DEYCG3      SEC         STA   GUESS+1         STA   GUESS+2         STA   GUESS+3         STA   GUESS+4         STA   GUESS+5         STA   GUESS+6         STA   GUESS+7CG4      ROL   A         ROL   GUESS+1         ROL   GUESS+2         ROL   GUESS+3         DBPL  Y,CG4         STA   GUESS;;  Iterate to a final solution;         LDX   #7                       LAST = 0FS0      LDA   #0                       N = input number         STA   LAST,X         LDA   SYSS1,X         STA   N,X         DBPL  X,FS0FS1      CMPW  GUESS+6,LAST+6           while GUESS <> LAST do         BNE   FS1A         CMPW  GUESS+4,LAST+4         BNE   FS1A         CMPW  GUESS+2,LAST+2         BNE   FS1A         CMPW  GUESS,LAST         BNE   FS1A         JMP   FS2FS1A     LDX   #7                          LAST = GUESSFS1B     LDA   GUESS,X                     GUESS = (GUESS+N/GUESS)/2         STA   LAST,X         STA   SYSS2,X         LDA   N,X         STA   SYSS1,X         DBPL  X,FS1B         JSR   SYSDIV8         MOVE  GUESS,SYSS2,#8         JSR   SYSADD8         CLC         LDX   #7FS1C     LDA   SYSS1,X         ROR   A         STA   SYSS1,X         STA   SYSS2,X         STA   GUESS,X         DBPL  X,FS1C         JSR   SYSMUL8                     if GUESS*GUESS > N then         LDA   N+7                            GUESS = GUESS-1         CMP   SYSS1+7         BNE   FS1D         LDA   N+6         CMP   SYSS1+6         BNE   FS1D         LDA   N+5         CMP   SYSS1+5         BNE   FS1D         LDA   N+4         CMP   SYSS1+4         BNE   FS1D         LDA   N+3         CMP   SYSS1+3         BNE   FS1D         LDA   N+2         CMP   SYSS1+2         BNE   FS1D         LDA   N+1         CMP   SYSS1+1         BNE   FS1D         LDA   N         CMP   SYSS1FS1D     JGE   FS1         SEC         LDA   GUESS         SBC   #1         STA   GUESS         LDA   GUESS+1         SBC   #0         STA   GUESS+1         LDA   GUESS+2         SBC   #0         STA   GUESS+2         LDA   GUESS+3         SBC   #0         STA   GUESS+3         LDA   GUESS+4         SBC   #0         STA   GUESS+4         LDA   GUESS+5         SBC   #0         STA   GUESS+5         LDA   GUESS+6         SBC   #0         STA   GUESS+6         LDA   GUESS+7         SBC   #0         STA   GUESS+7         JMP   FS1FS2      MOVE  GUESS,SYSS1,#8           endwhile         RTSGUESS    DS    8LAST     DS    8N        DS    8         END******************************************************************  SYSADD8 - Eight Byte Signed Integer Addition**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - first argument*        SYSS2 - second argument**  OUTPUTS:*        SYSS1 - result*        V - set for overflow******************************************************************SYSADD8  START         CLC         LDA   SYSS1         ADC   SYSS2         STA   SYSS1         LDA   SYSS1+1         ADC   SYSS2+1         STA   SYSS1+1         LDA   SYSS1+2         ADC   SYSS2+2         STA   SYSS1+2         LDA   SYSS1+3         ADC   SYSS2+3         STA   SYSS1+3         LDA   SYSS1+4         ADC   SYSS2+4         STA   SYSS1+4         LDA   SYSS1+5         ADC   SYSS2+5         STA   SYSS1+5         LDA   SYSS1+6         ADC   SYSS2+6         STA   SYSS1+6         LDA   SYSS1+7         ADC   SYSS2+7         STA   SYSS1+7         BVC   AD1         ERROR #7                       overflowAD1      RTS         END******************************************************************  SYSCMP8 - Eight Byte Signed Integer Compare**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - first argument*        SYSS2 - second argument**  OUTPUTS:*        C - set if SYSS1 >= SYSS2, else clear*        Z - set if SYSS1 = SYSS2, else clear******************************************************************SYSCMP8  START         LDA   SYSS1+7                  branch if both numbers have the same         EOR   SYSS2+7                   sign         BPL   CP1         LDA   SYSS2+7                  do a comparison of opositely signed         CMP   SYSS1+7                   numbers         RTSCP1      LDA   SYSS1+7                  do a comparison of numbers with the         CMP   SYSS2+7                   same sign         BNE   CP2         LDA   SYSS1+6         CMP   SYSS2+6         BNE   CP2         LDA   SYSS1+5         CMP   SYSS2C5         BNE   CP2         LDA   SYSS1+4         CMP   SYSS2+4         BNE   CP2         LDA   SYSS1+3         CMP   SYSS2+3         BNE   CP2         LDA   SYSS1+2         CMP   SYSS2+2         BNE   CP2         LDA   SYSS1+1         CMP   SYSS2+1         BNE   CP2         LDA   SYSS1         CMP   SYSS2CP2      RTS         END******************************************************************  SYSDIV8 - Eight Byte Signed Integer Divide**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - denominator*        SYSS2 - numerator**  OUTPUTS:*        SYSS1 - result**  NOTES:*        1) Uses SYSSIG8, SYSSUB8.******************************************************************SYSDIV8  START;;  Initialize;         LDA   SYSS2                    check for division by zero         ORA   SYSS2+1         ORA   SYSS2+2         ORA   SYSS2+3         ORA   SYSS2+4         ORA   SYSS2+5         ORA   SYSS2+6         ORA   SYSS2+7         BNE   DV1         ERROR #6                       division by zero         RTSDV1      JSR   SYSSIG8                  convert to positive numbers;;  64 BIT DIVIDE;         LDY   #64                      64 bits to goDV3      ASL   SYSS1                    roll up the next number         ROL   SYSS1+1         ROL   SYSS1+2         ROL   SYSS1+3         ROL   SYSS1+4         ROL   SYSS1+5         ROL   SYSS1+6         ROL   SYSS1+7         ROL   SYSS1+8         ROL   SYSS1+9         ROL   SYSS1+10         ROL   SYSS1+11         ROL   SYSS1+12         ROL   SYSS1+13         ROL   SYSS1+14         ROL   SYSS1+15         SEC                            subtract for this digit         LDA   SYSS1+8         SBC   SYSS2         STA   TEMP         LDA   SYSS1+9         SBC   SYSS2+1         STA   TEMP+1         LDA   SYSS1+10         SBC   SYSS2+2         STA   TEMP+2         LDA   SYSS1+11         SBC   SYSS2+3         STA   TEMP+3         LDA   SYSS1+12         SBC   SYSS2+4         STA   TEMP+4         LDA   SYSS1+13         SBC   SYSS2+5         STA   TEMP+5         LDA   SYSS1+14         SBC   SYSS2+6         STA   TEMP+6         LDA   SYSS1+15         SBC   SYSS2+7         STA   TEMP+7         BCC   DV4                      branch if minus         MOVE  TEMP,SYSS1+8,#8          turn the bit on         INC   SYSS1DV4      DBNE  Y,DV3                    next bit;;  SET SIGN;         LDA   SIGN                     branch if positive         BEQ   DV6         LDX   #7                       negate the result         LDY   #0DV5      LDA   SYSS1,X         STA   SYSS2,X         STY   SYSS1,X         DBPL  X,DV5         JSR   SYSSUB8DV6      RTSTEMP     DS    8         END******************************************************************  SYSMOD8 - Eight Byte Signed Integer Modulo Operation**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - denominator*        SYSS2 - numerator**  OUTPUTS:*        SYSS1 - result*        V - set for division by zero**  NOTES:*        1) Uses SYSDIV8, SYSSIG8, SYSSUB8.******************************************************************SYSMOD8  START         JSR   SYSDIV8         BVS   MD1         MOVE  SYSS1+8,SYSS1,#8MD1      RTS         END******************************************************************  SYSMUL8 - Eight Byte Signed Integer Multiply**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - multiplicand*        SYSS2 - multipier**  OUTPUTS:*        SYSS1 - result**  NOTES:*        1) Uses SYSSIG8.******************************************************************SYSMUL8  START;;  Initialize the sign.;         JSR   SYSSIG8;;  Do a 64 bit by 64 bit multiply.;         LDY   #64                      64 bit multiplyML1      LDA   SYSS1                    SYSS1*SYSS1+2+SYSS1+2 -> SYSS1,SYSS1+2         LSR   A         BCC   ML2         CLC                            add multiplicand to the partial product         LDA   SYSS1+8         ADC   SYSS2         STA   SYSS1+8         LDA   SYSS1+9         ADC   SYSS2+1         STA   SYSS1+9         LDA   SYSS1+10         ADC   SYSS2+2         STA   SYSS1+10         LDA   SYSS1+11         ADC   SYSS2+3         STA   SYSS1+11         LDA   SYSS1+12         ADC   SYSS2+4         STA   SYSS1+12         LDA   SYSS1+13         ADC   SYSS2+5         STA   SYSS1+13         LDA   SYSS1+14         ADC   SYSS2+6         STA   SYSS1+14         LDA   SYSS1+15         ADC   SYSS2+7         STA   SYSS1+15ML2      ROR   SYSS1+15                 shift the interem result         ROR   SYSS1+14         ROR   SYSS1+13         ROR   SYSS1+12         ROR   SYSS1+11         ROR   SYSS1+10         ROR   SYSS1+9         ROR   SYSS1+8         ROR   SYSS1+7         ROR   SYSS1+6         ROR   SYSS1+5         ROR   SYSS1+4         ROR   SYSS1+3         ROR   SYSS1+2         ROR   SYSS1+1         ROR   SYSS1         DBNE  Y,ML1                    loop til done;;  Check for overflows and set the sign.;         LDA   SYSS1+7                  check for an overflow         AND   #$80         ORA   SYSS1+8         ORA   SYSS1+9         ORA   SYSS1+10         ORA   SYSS1+11         ORA   SYSS1+12         ORA   SYSS1+13         ORA   SYSS1+14         ORA   SYSS1+15         BEQ   ML3         ERROR #7                       overflow         RTSML3      LDA   SIGN                     set the sign         BEQ   ML5         LDX   #7                       negate the result         LDY   #0ML4      LDA   SYSS1,X         STA   SYSS2,X         STY   SYSS1,X         DBPL  X,ML4         JSR   SYSSUB8ML5      RTS         END******************************************************************  SYSSGN8 - Eight Byte Signed Integer SIGN Function**  Produces a result from the following table:**        input            output**        <0               -1*        0                0*        >0               1**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - argument**  OUTPUTS:*        SYSS1 - result******************************************************************SYSSGN8  START         LDA   SYSS1         ORA   SYSS1+1         ORA   SYSS1+2         ORA   SYSS1+3         ORA   SYSS1+4         ORA   SYSS1+5         ORA   SYSS1+6         ORA   SYSS1+7         BEQ   SG2         LDA   SYSS1+7         BPL   SG1         MOVE  #$FF,SYSS1,#8         RTSSG1      MOVE  #0,SYSS1,#8         INC   SYSS1SG2      RTS         END******************************************************************  SYSSIG8 - Obtain the Sign for Eight Byte Integer Operations**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - first number*        SYSS2 - second number**  OUTPUTS:*        SYSS1 - ABS(SYSS1)*        SYSS2 - ABS(SYSS2)*        SYSS1+8 to SYSS1+15 - 0*        SIGN - 0 if SYSS1*SYSS2 > 0, else non-zero******************************************************************SYSSIG8  START;;  Initialize;         MOVE  #0,SYSS1+8,#8         STA   SIGN;;  Make the numbers positive.;         LDA   SYSS1+7         BPL   PS1         LDX   #SYSS1         JSR   SUB         INC   SIGNPS1      LDA   SYSS2+7         BPL   RTS         LDX   #SYSS2         DEC   SIGNSUB      SEC         LDA   #0         SBC   0,X         STA   0,X         LDA   #0         SBC   1,X         STA   1,X         LDA   #0         SBC   2,X         STA   2,X         LDA   #0         SBC   3,X         STA   3,X         LDA   #0         SBC   4,X         STA   4,X         LDA   #0         SBC   5,X         STA   5,X         LDA   #0         SBC   6,X         STA   6,X         LDA   #0         SBC   7,X         STA   7,XRTS      RTS         END******************************************************************  SYSSUB8 - Eight Byte Signed Integer Subtraction**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - first argument*        SYSS2 - second argument**  OUTPUTS:*        SYSS1 - result******************************************************************SYSSUB8  START         SEC         LDA   SYSS1         SBC   SYSS2         STA   SYSS1         LDA   SYSS1+1         SBC   SYSS2+1         STA   SYSS1+1         LDA   SYSS1+2         SBC   SYSS2+2         STA   SYSS1+2         LDA   SYSS1+3         SBC   SYSS2+3         STA   SYSS1+3         LDA   SYSS1+4         SBC   SYSS2+4         STA   SYSS1+4         LDA   SYSS1+5         SBC   SYSS2+5         STA   SYSS1+5         LDA   SYSS1+6         SBC   SYSS2+6         STA   SYSS1+6         LDA   SYSS1+7         SBC   SYSS2+7         STA   SYSS1+7         BVC   SB1         ERROR #7                       overflowSB1      RTS         END