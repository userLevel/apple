         LIST  OFF         SYMBOL OFF         MCOPY /RAM/I2.MACROS         KEEP  C.INT2         COPY  COMMON******************************************************************  SYSRANI - Pseudo Random Integer**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  OUTPUTS:*        SYSS1 - result**  NOTES:*        1)  Eight pseudo-random bytes are placed at SYSS1,*              and serve as a random integer of any length.******************************************************************SYSRANI  START         JSR   SYSRANX         MOVE  SYSRANX+3,SYSS1,#8         RTS         END******************************************************************  SYSRANX - Pseudo Random Number Generator**  Creates a 16 byte sequence of pseudo-random bits for use by*  the format dependent random number generation routines.**  By Mike Westerfield*  Copyright (C) September 1983, All rights reserved*  By Hayden Computer Company, Inc.**  OUTPUTS:*        SYSRANX+3 - 16 byte pseudo-random bit sequence***  NOTES:*        1)  Entry at SYSRANX2 initializes the random number*              generator.  For this call, the input is a two*              byte seed contained in X-A.*        2)  The pseudo-random sequence proceeds from most to*              least random.*        3)  The method is adapted from Arthur Matheny,*              "Random Number Generation for the Apple,"*              August 1982 Micro, pp 57-60.******************************************************************SYSRANX   START         JMP   RN1SEED     DS    16                       random bit streamRN1      CLC                            randomize the bit stream         LDX   #14         LDA   SEED+15RN2      ADC   SEED,X         STA   SEED,X         DBPL  X,RN2         LDX   #15RN3      INC   SEED,X         BNE   RN4         DBPL  X,RN3RN4      RTSSYSRANX2 ENTRY                          initialize the random bit stream         LDY   #15SD1      STA   SEED,Y         DEY         PHA         TXA         STA   SEED,Y         PLA         DBPL  Y,SD1         RTS         END******************************************************************  SYSCMP2 - Two Byte Signed Integer Compare**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - first argument*        SYSS2 - second argument**  OUTPUTS:*        C - set if SYSS1 >= SYSS2, else clear*        Z - set if SYSS1 = SYSS2, else clear******************************************************************SYSCMP2  START         LDA   SYSS1+1                  branch if both numbers have the same         EOR   SYSS2+1                   sign         BPL   CP1         LDA   SYSS2+1                  do a comparison of oppositely signed         CMP   SYSS1+1                   numbers         RTSCP1      LDA   SYSS1+1                  do a comparison of numbers with the         CMP   SYSS2+1                   same sign         BNE   CP2         LDA   SYSS1         CMP   SYSS2CP2      RTS         END******************************************************************  SYSMOD2 - Two Byte Signed Integer Modulo Operation**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - denominator*        SYSS2 - numerator**  OUTPUTS:*        SYSS1 - result*        V - set for division by zero**  NOTES:*        1) Uses SYSDIV2, SYSSIGN.******************************************************************SYSMOD2  START         JSR   SYSDIV2         BVS   MD1         LM    SYSS1,SYSS1+2         LM    SYSS1+1,SYSS1+3MD1      RTS         END******************************************************************  SYSSQR2 - Two Byte Integer Square Root**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - argument**  OUTPUTS:*        SYSS1 - result**  NOTES:*        1)  If the argument is negative, the result is*              SQRT(-SYSS1)*        2)  Uses SYSDIV2, SYSMUL2, SYSSIGN.******************************************************************SYSSQR2  START;;  Create an initial guess;         LDA   SYSS1+1                  check for a negative argument         BPL   CG1         SUB2  #0,SYSS1,SYSS1         ERROR #5                       invalid operationCG1      LDX   #4                       the initial guess is the largest power         LDA   SYSS1+1                   of two that is <= the answer         BNE   CG2         LDX   #0         LDA   SYSS1         BEQ   CG3CG2      INX         LSR   A         LSR   A         BNE   CG2         DEXCG3      SECCG4      ROL   A         DBPL  X,CG4         STA   GUESS         LM    GUESS+1,#0;;  Iterate to a final solution;         STA   LAST                     LAST = 0         STA   LAST+1         MOVE  SYSS1,N                  N = input numberFS1      CMPW  GUESS,LAST               while GUESS <> LAST do         BEQ   FS2         MOVE  GUESS,LAST                  LAST = GUESS         MOVE  N,SYSS1                     GUESS = (GUESS+N/GUESS)/2         MOVE  GUESS,SYSS2         JSR   SYSDIV2         ADD2  SYSS1,GUESS         LDA   SYSS1+1         LSR   A         STA   SYSS1+1         STA   SYSS2+1         STA   GUESS+1         LDA   SYSS1         ROR   A         STA   SYSS1         STA   SYSS2         STA   GUESS         JSR   SYSMUL2                     if GUESS*GUESS > N then         CMPW  N,SYSS1                        GUESS = GUESS-1         BGE   FS1         DEC2  GUESS         JMP   FS1FS2      MOVE  GUESS,SYSS1              endwhile         RTSGUESS    DS    2LAST     DS    2N        DS    2         END******************************************************************  SYSDIV2 - Two Byte Signed Integer Divide**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - denominator*        SYSS2 - numerator**  OUTPUTS:*        SYSS1 - result*        V - set for division by zero**  NOTES:*        1) Uses SYSSIGN.******************************************************************SYSDIV2  START;;  Initialize;         LDA   SYSS2                    check for division by zero         ORA   SYSS2+1         BNE   DV1         ERROR #6                       division by zero         RTSDV1      JSR   SYSSIGN                  convert to positive numbers         CMPW  SYSS1,SYSS2              if SYSS1<SYSS2 then the result is zero         BCS   DV2         MOVE  SYSS1,SYSS1+2         LA    SYSS1,0         RTSDV2      LDA   SYSS1+1                  do 8 bit divides separately         ORA   SYSS2+1         BEQ   DV5;;  16 BIT DIVIDE;         LDY   #16                      16 bits to goDV3      ASL   SYSS1                    roll up the next number         ROL   SYSS1+1         ROL   SYSS1+2         ROL   SYSS1+3         SEC                            subtract for this digit         LDA   SYSS1+2         SBC   SYSS2         TAX         LDA   SYSS1+3         SBC   SYSS2+1         BCC   DV4                      branch if minus         STX   SYSS1+2                  turn the bit on         STA   SYSS1+3         INC   SYSS1DV4      DBNE  Y,DV3                    next bit         BEQ   DV9                      go do the sign;;  8 BIT DIVIDE;DV5      LDA   #0                       initialize the remainder         LDY   #8                       8 bits to goDV6      ASL   SYSS1                    roll up the next number         ROL   A         SEC                            subtract the digit         SBC   SYSS2         BCS   DV7         ADC   SYSS2                    digit is 0         DBNE  Y,DV6         BEQ   DV8DV7      INC   SYSS1                    digit is 1         DBNE  Y,DV6DV8      STA   SYSS1+2                  save the remainder;;  SET SIGN;DV9      LDA   SIGN                     branch if positive         BEQ   DV10         SUB2  #0,SYSS1,SYSS1           negate the resultDV10     RTS         END******************************************************************  SYSMUL2 - Two Byte Signed Integer Multiply**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - multiplicand*        SYSS2 - multipier**  OUTPUTS:*        SYSS1 - result*        V - set if an overflow occurred**  NOTES:*        1) Uses SYSSIGN.******************************************************************SYSMUL2  START;;  Initialize the sign and split on precision.;         JSR   SYSSIGN         LDA   SYSS1+1         BEQ   ML3;;  Do a 16 bit by 16 bit multiply.;         LDY   #16                      16 bit multiply         JSR   ML1         JMP   ML7ML1      LDA   SYSS1                    SYSS1*SYSS1+2+SYSS1+2 -> SYSS1,SYSS1+2         LSR   A         BCC   ML2         ADD2  SYSS1+2,SYSS2            add multiplicand to the partial productML2      ROR   SYSS1+3                  shift the interem result         ROR   SYSS1+2         ROR   SYSS1+1         ROR   SYSS1         DBNE  Y,ML1                    loop til done         RTS;;  Do and 8 bit by 16 bit multiply.;ML3      ORA   SYSS2+1                      branch if 8x8 is possible         BEQ   ML4         LDY   #8                       set up for 8 bits         JSR   ML1                      do the multiply         LM    SYSS1,SYSS1+1            move the answer         LM    SYSS1+1,SYSS1+2         LM    SYSS1+2,SYSS1+3         STY   SYSS1+3                  (Y=0)         JMP   ML7;;  Do an 8 bit by 8 bit multiply.;ML4      LDY   #8                       set the 8 bit counter         LM    SYSS1+1,SYSS1,X          move the low byteML5      LSR   SYSS1+1                  test the bit         BCC   ML6                      branch if the bit is off         CLC         ADC   SYSS2ML6      ROR   A                        shift the answer         ROR   SYSS1         DEY           LOOP         BNE   ML5         STA   SYSS1+1                  save the high byte;;  Check for overflows and set the sign bit for all multiply precisions.;ML7      LDA   SYSS1+1                  check for an overflow         AND   #$80         ORA   SYSS1+2         ORA   SYSS1+3         BEQ   ML8         ERROR #7                       overflow         RTSML8      LDA   SIGN                     set the sign         BEQ   ML9         SUB2  #0,SYSS1,SYSS1ML9      RTS         END******************************************************************  SYSSGN2 - Two Byte Signed Integer SIGN Function**  Produces a result from the following table:**        input            output**        <0               -1*        0                0*        >0               1**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - argument**  OUTPUTS:*        SYSS1 - result******************************************************************SYSSGN2  START         LDA   SYSS1         ORA   SYSS1+1         BEQ   SG2         LDA   SYSS1+1         BPL   SG1         LA    SYSS1,-1         RTSSG1      LA    SYSS1,1SG2      RTS         END******************************************************************  SYSSIGN - Obtain the Sign for Two Byte Integer Operations**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - first number*        SYSS2 - second number**  OUTPUTS:*        SYSS1 - ABS(SYSS1)*        SYSS2 - ABS(SYSS2)*        SYSS1+2,SYSS1+3 - 0*        SIGN - 0 if SYSS1*SYSS2 > 0, else non-zero******************************************************************SYSSIGN  START;;  Initialize;         LM    (SYSS1+2,SYSS1+3,SIGN),#0;;  Make the numbers positive.;         LDA   SYSS1+1         BPL   PS1         SUB2  #0,SYSS1,SYSS1         INC   SIGNPS1      LDA   SYSS2+1         BPL   RTS         SUB2  #0,SYSS2,SYSS2         DEC   SIGNRTS      RTS         END