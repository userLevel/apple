******************************************************************  PCDRVR - CRT Driver**  The subroutines that follow provide a driver for the*  CRT driver.  Primitives include:**       Op Code   Subroutine  Description**       90        SCPOSN      read X, Y*       91        SCSIZE      screen size*       92        SCPUTC      put character*       93        SCPUTX      put character w/o advance******************************************************************         EJECT******************************************************************  SCCOMM - Common Area for CRT Driver******************************************************************SCCOMM   DATA;;  Zero page equates;BASL     GEQU  $28                      line addressBASL2    GEQU  $2A                      alternate line addressRAND     GEQU  $4E                      random number seed;;  Firmware switches;KEYBOARD EQU   $C000                    keyboard inputCOL80    EQU   $C001                    enable 80 column page selection switchesSTROBE   EQU   $C010                    keyboard strobeSPEAKER  EQU   $C030                    click the speakerPAGE1    EQU   $C054                    80 column page selection switchesPAGE2    EQU   $C055PREAD    EQU   $FB1E                    game paddle inputWAIT     EQU   $FCA8                    wait routine;;  Montior equates;VTAB     EQU   $FC22                    F8 ROM line address calculation;;  ASCII character codes;RETURN   EQU   $0D                      RETURN keyASCFS    EQU   $1C                      forward spaceASCGS    EQU   $1D                      clear to EOL;;  System constants;         AIF   (TYPE80=0).OR.(TYPE80=3),.APPCHMASK   DC    H'00'                    character mask         AGO   .DONE.APPCHMASK   DC    H'80'.DONE         AIF   TYPE80<>3,.NOT40ONSCREEN DC    I1'0'                    start col number on the screen.NOT40MAXCH    DC    I1'79'                   screen sizeMAXCV    DC    I1'23'         END******************************************************************  SCCTRL - Interpret Terminal Control Codes**  INPUTS:*        A - character**  OUTPUTS:*        C - set if a control code was interpreted**  NOTES:*        1)  All registers are returned intact.*        2)  If a GOTO was received, the next two characters*            will also be intercepted by this routine,*            regardless of what they are.******************************************************************SCCTRL   START         USING SCCOMM;..............................................................;;                                                              ;;  Check for control codes.                                    ;;                                                              ;;..............................................................;;;  Check for an active GOTO.;         ASL   MASK         BCC   CC1         STA   CHAR         LM    X,Y         SEC         LDA   CHAR         SBC   #32         STA   Y         LDA   MASK         BNE   CG1         LDX   X         LDY   Y         JSR   SCGOTO                   goto X,YCG1      SEC         RTS;;  Check for control codes.;CC1      CMP   #' '                     return if it is not a control code         BLT   CC2         CLC         RTSCC2      STA   CHAR                     save the registers         SAVE         LDY   CHAR                     see if this code gets interpreted         LDA   DISP,Y         BEQ   CC3         TAY                            yes -> find the subroutine address         LDA   ADDS-2,Y         STA   JSR+1         LDA   ADDS-1,Y         STA   JSR+2JSR      JSR   JSR                      call the interpreting subroutineCC3      RESTORE                        restore the registers         SEC                            tell the caller we took it         RTS         EJECT;..............................................................;;                                                              ;;  Control code interpreters.                                  ;;                                                              ;;..............................................................;;;  BEL: Ring the bell.;BEL      LDA   #32                      sound the ProDOS tone         STA   CHARBEL1     LDA   #2         JSR   WAIT         STA   SPEAKER         LDA   #36         JSR   WAIT         STA   SPEAKER         DBNE  CHAR,BEL1         RTSWAIT     SEC                            wait routine for BELWAIT2    PHAWAIT3    SBC   #1         BNE   WAIT3         PLA         SBC   #1         BNE   WAIT2         RTS;;  BS: Non-desructive back space.;BS       DEC   CH         BPL   BS1         INC   CHBS1      ANOP         AIF   (TYPE80=0).OR.(TYPE80=3),.BSD         LDX   CH                       Videx portion         LDY   CV         JMP   SCGOTO                   goto X,Y         AGO   .BSF.BSD         RTS.BSF;;  LF: Line feed.;LF       LDY   CV                       check for scroll         CPY   MAXCV         BLT   LF1         JMP   SCROLL                   scroll screenLF1      INY                            increment Y         LDX   CH         JMP   SCGOTO                   goto X,Y;;  VT: Clear to end of screen.;VT       ANOP         AIF   (TYPE80=0).OR.(TYPE80=3),.VTAPP         LDA   CV                       Videx portion         PHA                            save cursor         LDA   CH         PHA         LDA   #$B                      set videx code         JSR   SCVIDX                   hardware call         PLA                            restore cursor         STA   CH         PLA         STA   CV         LDX   CH         LDY   CV         JMP   SCGOTO                   goto X,Y         AGO   .DVT.VTAPP         JSR   GS                       clear to EOL         LDA   CV                       save the cursor         STA   CHAR         LDA   CH         PHAVT1      INC   CV                       clear remaining lines         LDY   CV         CPY   MAXCV         BGT   VT2         LDX   #0         JSR   SCGOTO                   goto X,Y         JSR   GS         JMP   VT1VT2      PLA                            restore the cursor         TAX         LDY   CHAR         JMP   SCGOTO                   goto X,Y.DVT;;  FF: Form feed.;FF       ANOP         AIF   (TYPE80=0).OR.(TYPE80=3),.FFAP         LDA   #$0C         JMP   SCVIDX         AGO   .FFDN.FFAP         JSR   SCLEAR         JMP   EM.FFDN;;  CR: Carriage return.;CR       JSR   LF         LM    CH,#0         AIF   (TYPE80=0).OR.(TYPE80=3),.CRAP         LDX   CH         LDY   CV         JSR   SCGOTO.CRAP         JMP   SCWAIT                   check for pause/wait;;  SO: Use standard characters.;SO       ANOP         AIF   (TYPE80=3).OR.(TYPE80=2),.D1         AIF   TYPE80=1,.FLIP         LM    CHMASK,#$80         AGO   .D1.FLIP         LM    CHMASK,#0.D1         RTS;;  SI: Use alternate characters.;SI       ANOP         AIF   (TYPE80=3).OR.(TYPE80=2),.D2         AIF   TYPE80=1,.FLIP2         LM    CHMASK,#0         AGO   .D2.FLIP2         LM    CHMASK,#$80.D2         RTS;;  EM: Home the cursor.;EM       LDX   #0                       set the cursor to 0,0         LDY   #0         JMP   SCGOTO                   goto X,Y;;  FS: Forward space.;FS       LDA   MAXCH                    check to see if at EOL         CMP   CH         BEQ   CR                       if at EOL then issue a carriage return         INC   CH         AIF   (TYP80=0).OR.(TYPE80=3),.FSD         LDX   CH                       videx portion         LDY   CV         JMP   SCGOTO                   goto X,Y         AGO   .FSF.FSD         RTS.FSF;;  GS: Clear to EOL.;GS       LDY   CH                       print out blanks from CH to EOL         LDA   #' '         ORA   CHMASKGS1      JSR   SCPRHV                   print out character         INC   CH         LDX   MAXCH         CPX   CH         BGE   GS1         STY   CH         RTS;;  RS: Screen GOTO.;RS       LM    MASK,#%11000000         RTS;;  US: Reverse linefeed.;US       DEC   CV         BPL   US1         INC   CVUS1      LDX   CH         LDY   CV         JMP   SCGOTO         EJECT;..............................................................;;                                                              ;;  Local data.                                                 ;;                                                              ;;..............................................................;;ADDS     DC    A'BEL'                   ring the bell         DC    A'BS'                    non-destructive back space         DC    A'LF'                    line feed         DC    A'VT'                    clear to EOS         DC    A'FF'                    form feed         DC    A'CR'                    carriage return         DC    A'SO'                    standard characters         DC    A'SI'                    alternate characters         DC    A'EM'                    home cursor         DC    A'FS'                    forward space         DC    A'GS'                    clear to EOL         DC    A'RS'                    screen GOTO         DC    A'US'                    reverse line feedCHAR     DS    1                        temp storage for input charDISP     DC    I1'00,00,00,00,00,00,00,02' disps into ADDS for control codes         DC    I1'04,00,06,08,10,12,14,16'         DC    I1'00,00,00,00,00,00,00,00'         DC    I1'00,18,00,00,20,22,24,26'MASK     DC    I1'0'                    GOTO maskX        DS    1                        X position for GOTOY        DS    1                        Y position for GOTO         END******************************************************************  SCGOTO - Position the Cursor**  INPUTS:*        X - column*        Y - row**  NOTES:*        1)  Row and column numbers count from 0.*        2)  All registers are returned intact.******************************************************************SCGOTO   START         USING SCCOMM         AIF   (TYPE80=0).OR.(TYPE80=3),.APP         CPX   MAXCH                    set horizontal position         BLT   LB1         LDX   MAXCHLB1      STX   LCH         CPY   MAXCV                    check range of vertical position         BLT   LB2         LDY   MAXCVLB2      STY   LCV                      set the vertical cursor position         LDA   #$1E                     set videx code         JSR   SCVIDX                   hardware call         CLC         LDA   LCH         ADC   #$20         JSR   SCVIDX         LDA   LCV         ORA   #$20         JSR   SCVIDX         LM    CH,LCH         LM    CV,LCV         AGO   .DONE.APP         CPX   MAXCH                    set horizontal position         BLT   LB1         LDX   MAXCHLB1      STX   CH         CPY   MAXCV                    check range of vertical position         BLT   LB2         LDY   MAXCVLB2      STY   CV                       set the vertical cursor position         JSR   VTAB.DONE         RTS         AIF   (TYPE80=0).OR.(TYPE80=3),.ENDLCH      DS    1LCV      DS    1.END         END******************************************************************  SCHIFT - Capitolize a Character**  Inputs:*        A - character to capitolize (high bit set)**  Outputs:*        A - capitol character******************************************************************SCHIFT   START         AIF   TYPE80<>3,.HIFT40         CMP   #$E0         BLT   RTS         AND   #%11011111RTS      RTS.HIFT40         END******************************************************************  SCINIT - CRT Initialization**  This routine is called at boot time, and for every RESET.******************************************************************SCINIT   START         USING SCCOMMWNDW     EQU   $21                      window widthALTMEM   EQU   $C001                    store to alternate memoryDISP40   EQU   $C00C                    display 40 columnsDISP80   EQU   $C00D                    display 80 columnsALTCHR   EQU   $C00F                    use alternate character setAPPLE80  EQU   $C300                    initialize Apple 80 columns         AIF   TYPE80=3,.AP40         LDA   #0         JSR   APPLE80         AIF   TYPE80=0,.APP         LM    $C0B0,#$A                Videx portion         LM    $C0B1,#$68               set the underline blinking cursor         AGO   .DONE.APP         STA   DISP80                   Apple portion         STA   ALTMEM         STA   ALTCHR         STA   PAGE1         AGO   .DONE.AP40                                   40 col driver         STA   DISP40                   show 40 cols         RAM   READ=ROM,BANK=2.DONE         LM    WNDW,#80         RTS         END******************************************************************  SCLEAR - Clear the Screen**  NOTES:*        1)  CV and CH are unchanged.*        2)  All registers are returned intact.******************************************************************SCLEAR   START         USING SCCOMM         SAVE                           save the registers         AIF   TYPE80=3,.AP40         LDA   CV                       save the cursor         PHA         LM    CV,MAXCV                 for each lineLB1      JSR   VTAB                        set the line address         LDA   MAXCH                       clear the primary bank         LSR   A         PHA         TAY         LDA   #' '         ORA   CHMASKLB2      STA   (BASL),Y         DBPL  Y,LB2         PLA                               clear the secondary bank         TAY         LDA   #' '         ORA   CHMASK         STA   PAGE2LB3      STA   (BASL),Y         DBPL  Y,LB3         STA   PAGE1         DBPL  CV,LB1                   next line         PLA                            restore the cursor         STA   CV         JSR   VTAB         AGO   .DONE.AP40                                   40 col driver         LDA   CV                       save the cursor         PHA         LM    CV,MAXCV                 for each lineLB1      JSR   VTAB                        set the line address         RAM   BANK=2                   allow access to alternate bank         ADD2  BASL,#$CC00,BASL2         LDA   MAXCH                       clear the primary bank         LSR   A         TAY         LDA   #' '         ORA   CHMASKLB2      STA   (BASL),Y         STA   (BASL2),Y         DBPL  Y,LB2         RAM   READ=ROM,BANK=2          restore bank settings         DBPL  CV,LB1                   next line         PLA                            restore the cursor         STA   CV         JSR   VTAB.DONE         RESTORE                        restore the registers         RTS         END         APPEND OH.SCPOSN