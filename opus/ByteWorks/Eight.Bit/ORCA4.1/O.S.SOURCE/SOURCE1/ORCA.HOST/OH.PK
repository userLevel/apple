******************************************************************  PKDRVR - Keyboard Driver**  The subroutines that follow provide a driver for the*  Apple ][ keyboard.  They use the same common area as the*  CRT driver.  Primitives include**       Op Code   Subroutine  Description**       98        SKEYIN      read key w/o cursor*       99        SKEYCR      read key with cursor*       9A        SKEYPR      check for keypress******************************************************************         EJECT******************************************************************  SKEYCR - Read Key With Cursor**  Places an inverse cursor on the screen and waits for a*  keypress.  After getting one, the cursor is erased.**  OUTPUTS:*        A - ASCII character read**  NOTES:*        1)  The X and Y registers are unaffected.******************************************************************SKEYCR   START         JSR   SAEXEC                   check for exec input         AIF   TYPE80=0,.APPLE80         AIF   TYPE80=3,.APPLE40         JMP   SKEYIN                   Videx portion         AGO   .DONE.APPLE80         JSR   SKRSCR                   invert the current character         EOR   #$80         JSR   SCPRHV         JSR   SKEYIN                   read a key         PHA                            restore the old character         JSR   SKRSCR         EOR   #$80         JSR   SCPRHV         PLA         RTS         AGO   .DONE.APPLE40         JSR   SKSWTC                   switch to current side of screen         JSR   SKRSCR                   invert the current character         STA   CHAR         EOR   #$80         AND   #%10111111         JSR   SCPRHV         JSR   SKEYIN                   read a key         PHA                            restore the old character         LDA   CHAR         JSR   SCPRHV         PLA         RTSCHAR     DS    1.DONE         END******************************************************************  SKEYIN - Read Key Without Cursor**  Continuously updates the random number seed while waiting*  for a keypress.**  OUTPUTS:*        A - ASCII character read*        RAND - random number seed**  NOTES:*        1)  The X and Y registers are unaffected.******************************************************************SKEYIN   START         USING SACOMM         USING SCCOMM         JSR   SAEXEC                   see if input is from exec file         AIF   TYPE80<>3,.NOT40         40 col driver         JSR   SKSWTC.NOT40LB1      LDA   KEYBOARD                 continuously increment the random number         BMI   LB2                       seed until a key is pressed         INC2  RAND         JMP   LB1LB2      LDA   CLICK                    if audible echo has been selected, make         BEQ   LB3                       a typewritter keystroke sound         TXA         PHA         TYA         PHA         LDX   #10LB2A     LDA   SPEAKER         LDY   #120LB2B     DEY         BNE   LB2B         DEX         BNE   LB2A         PLA         TAY         PLA         TAXLB3      STA   STROBE                   reset the keyboard strobe         LDA   KEYBOARD         RTS         END******************************************************************  SKEYPR - Check for a Keypress**  OUTPUTS:*        A - 1 if a key has been pressed, else 0**  NOTES:*        1)  The X and Y registers are unaffected.******************************************************************SKEYPR   START         USING SACOMM         USING SCCOMM         LDA   OPENE                    check for open input or exec files         ORA   OPENI         BEQ   SK1         LDA   #1                       input from file         JMP   RTSSK1      LDA   KEYBOARD                 check the keyboard         ASL   A         LDA   #0         ROL   ARTS      RTS         END******************************************************************  SKRSCR - Read the Screen**  Reads a character from the display screen.**  INPUTS:*        CV - vertical position*        CH - horizontal position**  OUTPUTS:*        A - ASCII character read**  NOTES:*        1)  The X and Y registers are unaffected.******************************************************************SKRSCR   START         USING SCCOMM         AIF   TYPE80=3,.RSCR40         STY   LY                       save the Y register         STA   COL80                    enable 80 column page selection         LDA   CH                       get the displacement         LSR   A         BCS   RC1         STA   PAGE2RC1      TAY                            read the character         LDA   (BASL),Y         STA   PAGE1         LDY   LY                       restore the Y register         RTSLY       DS    1         AGO   .RSCRDONE.RSCR40         STY   LY                       save the Y register         LDA   CH                       get the displacement         CMP   #40         BLT   RC1         SBC   #40RC1      TAY                            read the character         LDA   (BASL),Y         LDY   LY                       restore the Y register         RTSLY       DS    1.RSCRDONE         END******************************************************************  SKSWTC - Switch Sides of 40 Col Screen******************************************************************SKSWTC   START         USING SACOMM         USING SCCOMM         AIF   TYPE80<>3,.SWTC80         LDA   CH                       see if correct stuff is on screen         CMP   #40         BLT   LB0         LDA   ONSCREEN         BNE   LB1         BEQ   SWITCHLB0      LDA   ONSCREEN         BEQ   LB1SWITCH   SAVE         LDA   CV                       switch screen areas         PHA         LM    CV,#23LB0A     JSR   VTAB         ADD2  BASL,#$CC00,BASL2         RAM   BANK=2         LDY   #39LB0B     LDA   (BASL),Y         TAX         LDA   (BASL2),Y         STA   (BASL),Y         TXA         STA   (BASL2),Y         DBPL  Y,LB0B         RAM   READ=ROM,BANK=2         DBPL  CV,LB0A         PLA         STA   CV         JSR   VTAB         LDA   ONSCREEN         EOR   #40         STA   ONSCREEN         RESTORELB1      RTS.SWTC80         END*****************************************************************  These are the standard library routines used by ORCA.HOST.*  There is some unused code that could be removed should you*  need the room.*****************************************************************   EJECT******************************************************************  SYSPUTC - Format a Character for Output**  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - character for output******************************************************************SYSPUTC  START         LDX   SYSS2                    print blanks to right justify the         BEQ   PC1                       character in the print field         DEX         BEQ   PC1         JSR   SYSPRBLPC1      LDA   SYSS1                    print the character         JMP   SYSCOUT         END******************************************************************  SYSPUTS - String Output**  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        WR0 - address of string******************************************************************SYSPUTS  START         LDY   #1                       print enough blanks to right justify         SEC                             the output         LDA   SYSS2         SBC   (SYSS1),Y         BEQ   PT1         BCC   PT1         TAX         JSR   SYSPRBLPT1      LDA   (SYSS1),Y                get the length of the string and its         BEQ   PT3                       starting address         TAX         ADD2  SYSS1,#2         LDY   #0PT2      LDA   (SYSS1),Y                write the string         JSR   SYSCOUT         INY         DBNE  X,PT2PT3      RTS         END******************************************************************  SYSPRBL - Print Blanks**  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        X - number of blanks to print******************************************************************SYSPRBL  START         LDA   #' 'LB1      JSR   SYSCOUT         DBNE  X,LB1         RTS         END******************************************************************  SYSCOUT - Character Output**  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        $36 - pointer to current character output routine*        A - character to output******************************************************************SYSCOUT  STARTOUT      EQU   $36                      output hook         ORA   #$80         JMP   (OUT)         END******************************************************************  SYSFBUF - Find Buffer**  Locates an area of free memory and returns its address.**  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        WR0 - place to store result*        WR2 - amount of memory needed**  OUTPUTS:*        C - set if successful******************************************************************SYSFBUF  STARTBITMAP   EQU   $BF58                    ProDOS memory bit map         LDA   WR2                      WR3 = number of pages needed         BEQ   LB1         INC   WR3LB1      LM    WR2,#0                   WR2 = number of pages found         LM    WR4,#$BE                 WR4 = current page numberLB2      LDA   WR4                      see if this page is free         JSR   SYSMASK         AND   BITMAP,X         BNE   LB3         INC   WR2                      yes -> inc the page count         LDA   WR2                      loop if this is not enough pages yet         CMP   WR3         BLT   LB4         LDY   #0                       give the result to the caller         TYA         STA   (WR0),Y         LDA   WR4         INY         STA   (WR0),Y         SEC         RTSLB3      LM    WR2,#0                   page used - start overLB4      DEC   WR4                      check the next page         BNE   LB2         CLC         RTS         END******************************************************************  SYSMASK - Create Bit Map Mask**  Creates the mask for a particular page in the system*  memory bit mask.**  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        A - page number to create mask for**  OUTPUTS:*        A - bit mask; a 1 marks the bit used for this page*        X - disp in bit mask table******************************************************************SYSMASK  START         PHA         MLSR  A,3         TAX         PLA         AND   #7         TAY         SEC         LDA   #0MS1      ROR   A         DBPL  Y,MS1         RTS         END******************************************************************  SYSRELS - Release Memory**  Releases memory in the ProDOS system bit map.**  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        WR0 - first location to release*        WR2 - number of bytes to release******************************************************************SYSRELS  STARTBITMAP   EQU   $BF58                    ProDOS memory bit map         CLC                            update the number of bytes to release         LDA   WR0                       based on the limitation of releasing         ADC   WR2                       memory in units of 1 page         STA   WR2         BCC   LB1         INC   WR3LB1      LDA   WR2                      compute number of pages to release         BEQ   LB2         INC   WR3LB2      LDA   WR1                      release the memory         JSR   SYSMASK         EOR   #$FF         AND   BITMAP,X         STA   BITMAP,X         INC   WR1         DBNE  WR3,LB2         RTS         END******************************************************************  SYSRESV - Reserve Memory**  Reserves memory in the ProDOS system bit map.**  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        WR0 - first location to reserve*        WR2 - number of bytes to reserve******************************************************************SYSRESV  STARTBITMAP   EQU   $BF58                    ProDOS memory bit map         CLC                            update the number of bytes to reserve         LDA   WR0                       based on the limitation of reserving         ADC   WR2                       memory in units of 1 page         STA   WR2         BCC   LB1         INC   WR3LB1      LDA   WR2                      compute number of pages to reserve         BEQ   LB2         INC   WR3LB2      LDA   WR1                      reserve the memory         JSR   SYSMASK         ORA   BITMAP,X         STA   BITMAP,X         INC   WR1         DBNE  WR3,LB2         RTS         END******************************************************************  SYSLDOP - Load an Operand**  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        WR2 - address to load to*        A - addressing mode*        X - load type******************************************************************SYSLDOP  START         STX   TYPE                     save inputs         JSR   SYSLDAD                  compute the effective address         LDA   TYPE                     move the value into the work space         CMP   #10         BNE   LD4         MOVE  WR0,{WR2}         RTSLD3      LDA   (WR0),Y         STA   (WR2),YLD4      DBPL  Y,LD3         RTSTYPE     DS    1         END******************************************************************  SYSLDAD - Load Effective Address**  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        A - addressing mode*        X - load type**  OUTPUTS:*        WR0 - effective address*        Y - size of operand******************************************************************SYSLDAD  START         STX   TYPE                     save the type         TAY                            get the size of the entry         LDA   SIZES,X         STA   SIZE         CPY   #1                       split on operand type         BLT   LD2         PHP                            absolute and indirect         MOVE  {STR},WR0         PLP         BEQ   LD1         LDY   #0         LDA   (WR0),Y         TAX         INY         LDA   (WR0),Y         STA   WR1         STX   WR0LD1      ADD2  STR,#2         LDY   SIZE         RTSLD2      MOVE  STR,WR0                  immediate         LDY   SIZE         TYA         LDX   TYPE         CPX   #10         BNE   LD3         LDY   #0         LDA   (STR),Y         ADC   #1         LDY   #2LD3      CLC         ADC   STR         STA   STR         BCC   LD4         INC   STR+1LD4      RTSSIZE     DS    1                        operand sizeTYPE     DS    1                        type inputSIZES    DC    I1'2,4,8,0,4,8,0,0,1,1,2'         END******************************************************************  SYSLINE - Input Line Buffer Area**  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.******************************************************************SYSLINE  START         DS    256         END