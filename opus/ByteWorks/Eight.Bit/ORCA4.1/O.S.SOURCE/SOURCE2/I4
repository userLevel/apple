         LIST  OFF         SYMBOL OFF         MCOPY /RAM/I4.MACROS         KEEP  D.INT4         COPY  COMMON******************************************************************  SYSCV24 - Convert Two Byte Integer to Four Byte Integer*  SYSCV28 - Convert Two Byte Integer to Eight Byte Integer**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - two byte integer**  OUTPUTS:*        SYSS1 - eight byte integer******************************************************************SYSCV24  STARTSYSCV28  ENTRY         LDA   #0         LDX   SYSS1+1         BPL   CV1         LDA   #$FFCV1      LDX   #5CV2      STA   SYSS1+2,X         DBPL  X,CV2         RTS         END******************************************************************  SYSCV42 - Convert Four Byte Integer to Two Byte Integer**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - four byte integer**  OUTPUTS:*        SYSS1 - two byte integer******************************************************************SYSCV42  START         LDA   SYSS1+2         BEQ   CV1         CMP   #$FF         BNE   CV2CV1      CMP   SYSS1+3         BNE   CV2         AND   #$80         EOR   SYSS1+1         BPL   CV3CV2      ERROR #7                       OverflowCV3      RTS         END******************************************************************  SYSSQR4 - Four Byte Integer Square Root**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - argument**  OUTPUTS:*        SYSS1 - result**  NOTES:*        1)  If the argument is negative, the result is*              SQRT(-SYSS1)*        2)  Uses SYSDIV4, SYSMUL4, SYSSIG4.******************************************************************SYSSQR4  START;;  Create an initial guess;         LDA   SYSS1+3                  check for a negative argument         BPL   CG1         LDX   #3         LDY   #0CG0      LDA   SYSS1,X         STA   SYSS2,X         STY   SYSS1,X         DBPL  X,CG0         JSR   SYSSUB4         ERROR #5                       invalid operationCG1      LDY   #12                      the initial guess is the largest power         LDX   #3                        of two that is <= the answerCG1A     LDA   SYSS1,X         BNE   CG2         DEY         DEY         DEY         DEY         DBNE  X,CG1A         LDA   SYSS1         BEQ   CG3CG2      INY         LSR   A         LSR   A         BNE   CG2         DEYCG3      SEC         STA   GUESS+1         STA   GUESS+2         STA   GUESS+3CG4      ROL   A         ROL   GUESS+1         DBPL  Y,CG4         STA   GUESS;;  Iterate to a final solution;         STA   LAST                     LAST = 0         STA   LAST+1         STA   LAST+2         STA   LAST+3         MOVE  SYSS1,N,#4               N = input numberFS1      CMPW  GUESS+2,LAST+2           while GUESS <> LAST do         BNE   FS1A         CMPW  GUESS,LAST         BEQ   FS2FS1A     LDX   #3                          LAST = GUESSFS1B     LDA   GUESS,X                     GUESS = (GUESS+N/GUESS)/2         STA   LAST,X         STA   SYSS2,X         LDA   N,X         STA   SYSS1,X         DBPL  X,FS1B         JSR   SYSDIV4         MOVE  GUESS,SYSS2,#4         JSR   SYSADD4         CLC         LDX   #3FS1C     LDA   SYSS1,X         ROR   A         STA   SYSS1,X         STA   SYSS2,X         STA   GUESS,X         DBPL  X,FS1C         JSR   SYSMUL4                     if GUESS*GUESS > N then         LDA   N+3                            GUESS = GUESS-1         CMP   SYSS1+3         BNE   FS1D         LDA   N+2         CMP   SYSS1+2         BNE   FS1D         LDA   N+1         CMP   SYSS1+1         BNE   FS1D         LDA   N         CMP   SYSS1FS1D     BGE   FS1         SEC         LDA   GUESS         SBC   #1         STA   GUESS         LDA   GUESS+1         SBC   #0         STA   GUESS+1         LDA   GUESS+2         SBC   #0         STA   GUESS+2         LDA   GUESS+3         SBC   #0         STA   GUESS+3         JMP   FS1FS2      MOVE  GUESS,SYSS1,#4           endwhile         RTSGUESS    DS    4LAST     DS    4N        DS    4         END******************************************************************  SYSADD4 - Four Byte Signed Integer Addition**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - first argument*        SYSS2 - second argument**  OUTPUTS:*        SYSS1 - result*        V - set for overflow******************************************************************SYSADD4  START         CLC         LDA   SYSS1         ADC   SYSS2         STA   SYSS1         LDA   SYSS1+1         ADC   SYSS2+1         STA   SYSS1+1         LDA   SYSS1+2         ADC   SYSS2+2         STA   SYSS1+2         LDA   SYSS1+3         ADC   SYSS2+3         STA   SYSS1+3         BVC   AD1         ERROR #7                       overflowAD1      RTS         END******************************************************************  SYSCMP4 - Four Byte Signed Integer Compare**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - first argument*        SYSS2 - second argument**  OUTPUTS:*        C - set if SYSS1 >= SYSS2, else clear*        Z - set if SYSS1 = SYSS2, else clear******************************************************************SYSCMP4  START         LDA   SYSS1+3                  branch if both numbers have the same         EOR   SYSS2+3                   sign         BPL   CP1         LDA   SYSS2+3                  do a comparison of opositely signed         CMP   SYSS1+3                   numbers         RTSCP1      LDA   SYSS1+3                  do a comparison of numbers with the         CMP   SYSS2+3                   same sign         BNE   CP2         LDA   SYSS1+2         CMP   SYSS2+2         BNE   CP2         LDA   SYSS1+1         CMP   SYSS2+1         BNE   CP2         LDA   SYSS1         CMP   SYSS2CP2      RTS         END******************************************************************  SYSDIV4 - Four Byte Signed Integer Divide**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - denominator*        SYSS2 - numerator**  OUTPUTS:*        SYSS1 - result**  NOTES:*        1) Uses SYSSIG4.******************************************************************SYSDIV4  START;;  Initialize;         LDA   SYSS2                    check for division by zero         ORA   SYSS2+1         ORA   SYSS2+2         ORA   SYSS2+3         BNE   DV1         ERROR #6                       division by zero         RTSDV1      JSR   SYSSIG4                  convert to positive numbers;;  32 BIT DIVIDE;         LDY   #32                      32 bits to goDV3      ASL   SYSS1                    roll up the next number         ROL   SYSS1+1         ROL   SYSS1+2         ROL   SYSS1+3         ROL   SYSS1+4         ROL   SYSS1+5         ROL   SYSS1+6         ROL   SYSS1+7         SEC                            subtract for this digit         LDA   SYSS1+4         SBC   SYSS2         STA   SYSS2+4         LDA   SYSS1+5         SBC   SYSS2+1         STA   SYSS2+5         LDA   SYSS1+6         SBC   SYSS2+2         STA   SYSS2+6         LDA   SYSS1+7         SBC   SYSS2+3         STA   SYSS2+7         BCC   DV4                      branch if minus         LDA   SYSS2+4                  turn the bit on         STA   SYSS1+4         LDA   SYSS2+5         STA   SYSS1+5         LDA   SYSS2+6         STA   SYSS1+6         LDA   SYSS2+7         STA   SYSS1+7         INC   SYSS1DV4      DBNE  Y,DV3                    next bit;;  SET SIGN;         LDA   SIGN                     branch if positive         BEQ   DV5         SEC                            negate the result         LDA   #0         SBC   SYSS1         STA   SYSS1         LDA   #0         SBC   SYSS1+1         STA   SYSS1+1         LDA   #0         SBC   SYSS1+2         STA   SYSS1+2         LDA   #0         SBC   SYSS1+3         STA   SYSS1+3DV5      RTS         END******************************************************************  SYSMOD4 - Four Byte Signed Integer Modulo Operation**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - denominator*        SYSS2 - numerator**  OUTPUTS:*        SYSS1 - result*        V - set for division by zero**  NOTES:*        1) Uses SYSDIV4, SYSSIG4.******************************************************************SYSMOD4  START         JSR   SYSDIV4         BVS   MD1         MOVE  SYSS1+4,SYSS1,#4MD1      RTS         END******************************************************************  SYSMUL4 - Four Byte Signed Integer Multiply**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - multiplicand*        SYSS2 - multipier**  OUTPUTS:*        SYSS1 - result**  NOTES:*        1) Uses SYSSIG4.******************************************************************SYSMUL4  START;;  Initialize the sign.;         JSR   SYSSIG4;;  Do a 32 bit by 32 bit multiply.;         LDY   #32                      32 bit multiplyML1      LDA   SYSS1                    SYSS1*SYSS1+2+SYSS1+2 -> SYSS1,SYSS1+2         LSR   A         BCC   ML2         CLC                            add multiplicand to the partial product         LDA   SYSS1+4         ADC   SYSS2         STA   SYSS1+4         LDA   SYSS1+5         ADC   SYSS2+1         STA   SYSS1+5         LDA   SYSS1+6         ADC   SYSS2+2         STA   SYSS1+6         LDA   SYSS1+7         ADC   SYSS2+3         STA   SYSS1+7ML2      ROR   SYSS1+7                  shift the interem result         ROR   SYSS1+6         ROR   SYSS1+5         ROR   SYSS1+4         ROR   SYSS1+3         ROR   SYSS1+2         ROR   SYSS1+1         ROR   SYSS1         DBNE  Y,ML1                    loop til done;;  Check for overflows and set the sign.;         LDA   SYSS1+3                  check for an overflow         AND   #$80         ORA   SYSS1+4         ORA   SYSS1+5         ORA   SYSS1+6         ORA   SYSS1+7         BEQ   ML3         ERROR #7                       overflow         RTSML3      LDA   SIGN                     set the sign         BEQ   ML4         SEC                            negate the result         LDA   #0         SBC   SYSS1         STA   SYSS1         LDA   #0         SBC   SYSS1+1         STA   SYSS1+1         LDA   #0         SBC   SYSS1+2         STA   SYSS1+2         LDA   #0         SBC   SYSS1+3         STA   SYSS1+3ML4      RTS         END******************************************************************  SYSSGN4 - Four Byte Signed Integer SIGN Function**  Produces a result from the following table:**        input            output**        <0               -1*        0                0*        >0               1**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - argument**  OUTPUTS:*        SYSS1 - result******************************************************************SYSSGN4  START         LDA   SYSS1         ORA   SYSS1+1         ORA   SYSS1+2         ORA   SYSS1+3         BEQ   SG2         LDA   SYSS1+3         BPL   SG1         LDA   #$FF         STA   SYSS1         STA   SYSS1+1         STA   SYSS1+2         STA   SYSS1+3         RTSSG1      LDX   #1         STX   SYSS1         DEX         STX   SYSS1+1         STX   SYSS1+2         STX   SYSS1+3SG2      RTS         END******************************************************************  SYSSIG4 - Obtain the Sign for Four Byte Integer Operations**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - first number*        SYSS2 - second number**  OUTPUTS:*        SYSS1 - ABS(SYSS1)*        SYSS2 - ABS(SYSS2)*        SYSS1+4 to SYSS1+7 - 0*        SIGN - 0 if SYSS1*SYSS2 > 0, else non-zero******************************************************************SYSSIG4  START;;  Initialize;         LM    (SYSS1+4,SYSS1+5,SYSS1+6,SYSS1+7,SIGN),#0;;  Make the numbers positive.;         LDA   SYSS1+3         BPL   PS1         LDX   #SYSS1         JSR   SUB         INC   SIGNPS1      LDA   SYSS2+3         BPL   RTS         LDX   #SYSS2         DEC   SIGNSUB      SEC         LDA   #0         SBC   0,X         STA   0,X         LDA   #0         SBC   1,X         STA   1,X         LDA   #0         SBC   2,X         STA   2,X         LDA   #0         SBC   3,X         STA   3,XRTS      RTS         END******************************************************************  SYSSUB4 - Four Byte Signed Integer Subtraction**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        SYSS1 - first argument*        SYSS2 - second argument**  OUTPUTS:*        SYSS1 - result******************************************************************SYSSUB4  START         SEC         LDA   SYSS1         SBC   SYSS2         STA   SYSS1         LDA   SYSS1+1         SBC   SYSS2+1         STA   SYSS1+1         LDA   SYSS1+2         SBC   SYSS2+2         STA   SYSS1+2         LDA   SYSS1+3         SBC   SYSS2+3         STA   SYSS1+3         BVC   SB1         ERROR #7                       overflowSB1      RTS         END