******************************************************************  SALID - Alphabetic Identification**  Inputs:*        A - character to check**  Outputs:*        C - set if alphabetic******************************************************************SALID    START         CMP   #'A'         BLT   RTS         CMP   #'Z'+1         BLT   OK         CMP   #'_'         BEQ   OK         CMP   #'~'         BEQ   OK         CLCRTS      RTSOK       SEC         RTS         END******************************************************************  SCESC - Check for ESC after RETURN**  Inputs:*        S - S reg for error return******************************************************************SCESC    START         USING COMMONESC      EQU   27         LDA   KEYBOARD         CMP   #ESC         BNE   RTS         LDX   S         TXS         JMP   SFINIRTS      RTS         END******************************************************************  SDEFN - Save Label Definitions******************************************************************SDEFN    START         USING COMMON         LDA   CRSREF                   quit if list is off         BEQ   RTS         LM    CNT,#0                   scan for symbol definitionsDF1      LDY   CNT         LDA   (R4),Y         BEQ   RTS         CMP   #2         BNE   DF2         JSR   SGSYM                    get symbol name         JSR   SFSYM                    find symbol in table         BCC   RTS         ADD2  R0,#12                   define symbol pointer         JSR   SPINT         BCC   RTSDF2      INC   CNT                      next symbol         BNE   DF1RTS      RTS         END******************************************************************  SDONL - Get the Device On Line**  INPUTS:*        INDEX - device number**  OUTPUTS:*        VOLUME - device prefix name*        C - set is sucessful else clear******************************************************************SDONL    START         USING COMMON         LDY   #0                       get device number         LDX   INDEX         MOVE  DEVTABL,R10SDO      LDA   (R10),Y         BEQ   SDO1         DBEQ  X,SDO1ASDO1     INY         CPY   #14         BLT   SDO         BGE   SDO2                     then device is not connectedSDO1A    STA   UNIT         RELEASE DCB+2,#16              release buffer to ProDOS         ON_LINE DCB                    get vol on line         BCS   RT1                      error detected         RESERVE DCB+2,#16              reserve buffer for ORCA         SEC         RTSSDO2     LDA   #$28                     set the device not connected errorRT1      CLC         RTSDCB      DC    I1'2'                    on line DCBUNIT     DS    1         DC    A'VOLUME'         END******************************************************************  SDVIC - Locate Device**  INPUTS:*        FNAME - file name**  OUTPUTS:*        FNAME - updated with device name instead of number*        C - set if device found else clear******************************************************************SDVIC    START         USING COMMON         LDA   FNAME+1                  check to see if this is a unit         CMP   #'.'         BNE   NOT         JSR   GOBL         LDA   FNAME+1                  insure that we have a 'D'         JSR   SHIFT         CMP   #'D'         BNE   ERR         JSR   GOBL         LM    INDEX,#0                 read the index numberLB1      LDA   FNAME+1         JSR   SYSNMID         BCC   LB2         AND   #$F         PHA         JSR   GOBL         ASL   INDEX         BCS   ERR         LDA   INDEX         ASL   A         BCS   ERR         ASL   A         BCS   ERR         ADC   INDEX         BCS   ERR         STA   INDEX         PLA         CLC         ADC   INDEX         BCS   ERR         STA   INDEX         JMP   LB1LB2      LDX   INDEX                    make sure that the index is valid         BEQ   ERR         CPX   #15         BGE   ERR         JSR   SDONL                    get the volume name         BCC   ERR2         LDA   VOLUME                   put the volume name in the name         AND   #$F         TAXLB3      LDA   VOLUME,X         JSR   INSERT         DBNE  X,LB3         LDA   #'/'         JSR   INSERTNOT      SEC         RTSERR      PUTS  #'Invalid Device Number',CR=TRUE         JMP   ERR3ERR2     PUTS  #'Device not connected',CR=TERR3     LDX   S         TXS         JMP   SFINI;;  INSERT - Insert the character in A into the line at CC.;INSERT   PHA         LDY   #64IN1      LDA   FNAME-1,Y         STA   FNAME,Y         DEY         BNE   IN1         PLA         STA   FNAME+1         INC   FNAME         RTS;;  GOBL - remove the first character from the file name;GOBL     LDY   #1GB1      LDA   FNAME+1,Y         STA   FNAME,Y         INY         CPY   #64         BLT   GB1         DEC   FNAME         RTSCC       DS    1         END******************************************************************  SFETC - Get a Line Number**  Inputs:*        R12 - pointer to next entry**  Outputs:*        R12 - pointer to new entry*        R6 - line number*        C - clear if at end of list******************************************************************SFETC    START         USING COMMON         CMPW  R12,#0         BEQ   FINI         MOVE  {R12},R4,#PTRLEN         MOVE  R4,R12         SEC         RTSFINI     CLC         RTS         END******************************************************************  SFILE - Do COPY and APPEND**  Inputs:*        R6 - copy flag*        R7 - append flag*        (R8) - file name*        COPY - current copy pointer**  Outputs:*        FNAME - file name*        COPY - updated for a copy*        C - set if copy or append******************************************************************SFILE    START         USING COMMON         LDA   R7                       skip if not an append         BEQ   FL1FL0      LM    CLOSE_REF,RD_REF         close old file         CLOSE CLOSE_DCB         MOVE  {R8},FNAME,#65         JMP   SOPEN                    open the new oneFL1      LDA   R6                       skip if not a COPY         BEQ   FL3         FINDBUFF ADDR,#256             find a copy block         BCS   FL2         JSR   SOMEMFL1A     CLC         RTSFL2      RESERVE ADDR,#256              fill it in         MOVE  COPY,{ADDR}         MOVE  ADDR,COPY         ADD2  ADDR,#2         MOVE  FNAME,{ADDR},#65         ADD2  ADDR,#65         LM    MARK_REF,RD_REF         GET_MARK MARK_DCB         MOVE  MARK_VAL,{ADDR},#3         JMP   FL0                      append does the restFL3      SEC         RTS         END******************************************************************  SFINI - Program Termination******************************************************************SFINI    START         CLOSE CLOSE_DCB         RTSCLOSE_DCB DC   I1'1'         DC    I1'0'         END******************************************************************  SFREQ - Save Frequency Count******************************************************************SFREQ    START         USING COMMON         LDA   FREQ         BEQ   RTS         LM    CNT,#0                   scan for frequency countsFR1      LDY   CNT         LDA   (R4),Y         BEQ   RTS         CMP   #4         BNE   FR2         JSR   SGSYM                    get the symbol name         JSR   SFSYM                    find it in the table         BCC   FR2         ADD2  R0,#10                   inc frequency count         ADD2  {R0},#1FR2      INC   CNT         BNE   FR1RTS      RTS         END******************************************************************  SFRML - Form the Line**  Outputs:*        LINE - line from the file*        C - clear if at end of file******************************************************************SFRML    START         USING COMMON;;  Read a line from the open file.;         MOVE  #$20,LINE,#80            blank out the line         LM    R0,#0                    disp into the lineRD1      RELEASE #CH,#1                 read a character         READ  RD_DCB         PHA         RESERVE #CH,#1         PLA         BNE   RD3         LDA   CH                       quit if at EOL         CMP   #RETURN         BEQ   RD2         LDX   R0                       save it in LINE         CPX   #80         BGE   RD1         STA   LINE,X         INC   R0         JMP   RD1RD2      SEC                            quit         RTSRD3      CMP   #$4C         BEQ   RD5         PUTS  #'File read error.',CR=TRD4      CLC         RTS;;  Reopen COPY files.;RD5      LDA   COPY                     quit if none copied         ORA   COPY+1         BEQ   RD4         MOVE  COPY,ADDR                recover values         RELEASE COPY,#256         MOVE  {ADDR},COPY         ADD2  ADDR,#2         MOVE  {ADDR},FNAME,#65         ADD2  ADDR,#65         MOVE  {ADDR},MARK_VAL,#3         LM    CLOSE_REF,RD_REF         close the current file         CLOSE CLOSE_DCB         JSR   SOPEN                    open the old one         BCC   RD4         LM    MARK_REF,RD_REF          reset the mark         SET_MARK MARK_DCB         JMP   SFRML                    get the line         END******************************************************************  SFSYM - Find a Symbol**  Inputs:*        SNAME - name of symbol to find*        RANGE - character ranges**  Outputs:*        R0 - address of the symbol entry*        C - clear if error*        ERR - 1 for terminal error**  Notes:*        1) If the symbol is not found, one is created.******************************************************************SFSYM    START         USING COMMON         LDA   SNAME                    quit if the range is not valid         CMP   #'_'         BEQ   FS0         CMP   #'~'         BEQ   FS0         LDY   #0CS1      LDA   SNAME         CMP   RANGE,Y         BLT   CS2         CMP   RANGE+1,Y         BLT   FS0         BEQ   FS0CS2      INY         INY         LDA   RANGE,Y         BNE   CS1         CLC         RTSFS0      MOVE  STABLE,R0                search for symbolFS1      CMPW  R0,STE         BGE   FS5         LDY   #0                       check this oneFS2      LDA   (R0),Y         CMP   SNAME,Y         BNE   FS3         INY         CPY   #10         BNE   FS2         SEC         RTSFS3      BGE   FS4                      next symbol         ADD2  R0,#SYMLEN         JMP   FS1FS4      CLC                            insert SYMLEN bytes         LDA   STE         STA   R12         ADC   #SYMLEN         STA   R10         LDA   STE+1         STA   R13         ADC   #0         STA   R11         SUB2  STE,R0,R14         INC2  R14         JSR   SINSTFS5      ADD2  STE,#SYMLEN              inc STE         JSR   SOVFL                    check for overflow         BCC   RTS         LDY   #SYMLEN-1                init the entry         LDA   #0FS6      STA   (R0),Y         DBNE  Y,FS6         MOVE  SNAME,{R0},#10         SECRTS      RTS         END******************************************************************  SGETC - Get a Command Line Character**  Inputs:*        R0 - address of the command line**  Outputs:*        R0 - incremented*        A - character read******************************************************************SGETC    START         USING COMMON         LDY   #0                       get a char from the lineLB1      LDA   (R0),Y         INC2  R0         CMP   #' '         BEQ   LB1         CMP   #RETURN         BNE   RTS         LDA   #0RTS      RTS         END         APPEND XR.SGSUB