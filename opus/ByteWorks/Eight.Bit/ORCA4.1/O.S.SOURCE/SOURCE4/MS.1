******************************************************************  SYSBOPR - Binary Operator*  SYSCOPR - Compare Operation*  SYSUOPR - Unary Operator*  SYSROPR - Random Number Operation**  Does parameter set up and result stroage for all math*  operations.**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        * - address of routine to call*        *+2 - control byte; for binary operations:*                 15-13 - type of operands*                 12-10 - type of addressing for first*                    argument*                 9-7 - type of operands*                 6-4 - type of addressing for second argument*                 3-1 - type of addressing for result*              for unary operations:*                 15-13 - type of input*                 12-10 - addressing mode for input*                 9-7 - type of output*                 6-4 - addressing mode for output*        *+4 - operands needed**  NOTES:*        1) Operand types are:*              000 - 2 byte integer*              001 - 4 byte integer*              010 - 8 byte integer*              100 - floating point*              101 - double precision*        2) addressing modes are:*              000 - immediate (requires n byte operand)*              001 - absolute (requires 2 byte address)*              010 - indirect (requires 2 byte address)*              011 - stack******************************************************************SYSBOPR  START         LDA   #0                       remember type of call         BEQ   LB1SYSCOPR  ENTRY         LDA   #1         BNE   LB1SYSUOPR  ENTRY         LDA   #-1         BNE   LB1SYSROPR  ENTRY         LDA   #2LB1      STA   ENTRY;..............................................................;;;  Perform a math operation;;..............................................................;;;  Initialization;         PLA                            recover operand address         STA   STR         PLA         STA   STR+1         INC2  STR         MOVE  {STR},JAD,#4             load call address and control byte         ADD2  STR,#4         LDA   ENTRY                    skip loads if generating a random number         CMP   #2         BEQ   RN1         LA    WR2,SYSS1                load first operand         JSR   ROLL         TAX         JSR   ROLL         STA   AMODE         JSR   SYSLDOP         LDA   ENTRY                    split on number of operands         BPL   CP1;;  One operand instruction;         JSR   OPR                      do the operation         PHP         JSR   ROLL         TAX         JMP   SR1;;  Compare operation;CP1      BEQ   TP1         LA    WR2,SYSS2         JSR   ROLL         TAX         JSR   ROLL         JSR   SYSLDOP         JSR   OPR         JMP   (STR);;  Random number generation;RN1      JSR   OPR         JSR   ROLL         TAX         PHP         JMP   SR1;;  Two operand instruction;TP1      LA    WR2,SYSS2                load second operand         JSR   ROLL         STA   TYPE         TAX         JSR   ROLL         PHA         JSR   SYSLDOP         PLA         CMP   AMODE         BNE   TP3         CMP   #%00000011         BNE   TP3         LDX   #9TP2      LDA   SYSS1,X         LDY   SYSS2,X         STY   SYSS1,X         STA   SYSS2,X         DBPL  X,TP2TP3      JSR   OPR                      do the operation         PHP         LDX   TYPE;;  Save the result;SR1      STX   TYPE                     get result address         JSR   ROLL         PHA         JSR   SYSLDAD         PLA         CMP   #3         BNE   SR2         TYA         ASL   A         SOFTCALL SYSISTK         MOVE  SYSESTE,WR0SR2      LDA   TYPE                     split on result type         BNE   SR3         MOVE  SYSS1,{WR0}              save int2         JMP   SR6SR3      CMP   #2                       save int4         BGE   SR3A         MOVE  SYSS1,{WR0},#4         JMP   SR6SR3A     BNE   SR4                      save int8         MOVE  SYSS1,{WR0},#8         JMP   SR6SR4      PHA         MOVE  WR0,MR2         LA    MR0,SYSS1         PLA         CMP   #4                       save floating point         BNE   SR5         SOFTCALL SYSPAKF         JMP   SR6SR5      SOFTCALL SYSPAKD               save double precisionSR6      PLP         JMP   (STR);..............................................................;;;  Internal subroutines;;..............................................................;;;  OPR: Indirect subroutine call.;OPR      JMP   (JAD);;  ROLL: Roll 3 bits from the control bytes into the accumulator;ROLL     LDA   #0         ASL   CBYTE+1         ROL   CBYTE         ROL   A         ASL   CBYTE+1         ROL   CBYTE         ROL   A         ASL   CBYTE+1         ROL   CBYTE         ROL   A         RTS;..............................................................;;;  Data areas;;..............................................................;;JAD      DS    2                        subroutine addressCBYTE    DS    2                        control byteTYPE     DS    1                        operand typeENTRY    DS    1                        entry typeAMODE    DS    1                        addressing mode for 1st opnd         END******************************************************************  SYSCFST - Convert from String**  Converts a string to its equivalent number.**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        * - address of the format routine*        *+2 - control bytes*              15-13 - unused*              12-10 - addressing mode for input*              9-7 - type of output*              6-4 - addressing mode for output*        *+4 - operand needed******************************************************************SYSCFST  STARTSYSIN    EQU   $38                      input hookRETURN   EQU   $0D                      RETURN key code         PLA                            recover operand addresses         STA   STR         PLA         STA   STR+1         INC2  STR         MOVE  {STR},JAD,#4             load operands         ADD2  STR,#4         JSR   ROLL                     load the argument address         TAX         JSR   ROLL         JSR   SYSLDAD         LM    CC,#1                    init the position in the string         LM    (SYSKBIN,SYSCRPB),#$4C   set the input hook to the local routine         LA    SYSKBIN+1,IN         LA    SYSCRPB+1,PB         JSR   OPR         LDX   #2                       reset to standard input         LDA   #$EACF1      STA   SYSKBIN,X         STA   SYSCRPB,X         DBPL  X,CF1         JSR   ROLL                     get the effective address for the result         TAX         JSR   ROLL         PHA         JSR   SYSLDAD         PLA                            correct the effective addr for stack         CMP   #3                        saves         BNE   CF2         TYA         ASL   A         SOFTCALL SYSISTK         MOVE  SYSESTE,WR0CF2      DEY                            do savesCF4      LDA   SYSS1,Y         STA   (WR0),Y         DBPL  Y,CF4         JMP   (STR);;  ROLL: Roll 3 bits from the control bytes into A.;ROLL     LDA   #0         ASL   CBYTE+1         ROL   CBYTE         ROL   A         ASL   CBYTE+1         ROL   CBYTE         ROL   A         ASL   CBYTE+1         ROL   CBYTE         ROL   A         RTS;;  OPR: Indirect subroutine call.;OPR      JMP   (JAD);;  IN: Fake character input routine.;IN       STY   LY         LDY   #0         STY   SYSEOL         INY         LDA   (WR0),Y         CMP   CC         BLT   IN2         LDY   CC         INY         LDA   (WR0),Y         STY   CC         LDY   LY         RTSIN2      LDA   #RETURN         LDY   LY         INC   SYSEOLPB       RTS;;  Local data areas.;LY       DS    1CC       DS    1JAD      DS    2CBYTE    DS    2         END         APPEND MS.2