         LIST  OFF         SYMBOL OFF         MCOPY /RAM/MS.MACROS         KEEP  H.MSC         COPY  COMMON******************************************************************  SYSFBUF - Find Buffer**  Locates an area of free memory and returns its address.**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        WR0 - place to store result*        WR2 - amount of memory needed**  OUTPUTS:*        C - set if successful******************************************************************SYSFBUF  STARTBITMAP   EQU   $BF58                    ProDOS memory bit map         LDA   WR2                      WR3 = number of pages needed         BEQ   LB1         INC   WR3LB1      LM    WR2,#0                   WR2 = number of pages found         LM    WR4,#$BE                 WR4 = current page numberLB2      LDA   WR4                      see if this page is free         JSR   SYSMASK         AND   BITMAP,X         BNE   LB3         INC   WR2                      yes -> inc the page count         LDA   WR2                      loop if this is not enough pages yet         CMP   WR3         BLT   LB4         LDY   #0                       give the result to the caller         TYA         STA   (WR0),Y         LDA   WR4         INY         STA   (WR0),Y         SEC         RTSLB3      LM    WR2,#0                   page used - start overLB4      DEC   WR4                      check the next page         BNE   LB2         CLC         RTS         END******************************************************************  SYSMOVB - Move Memory from the Beginning**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        MR0 - from address*        MR2 - to address*        MR4 - move length******************************************************************SYSMOVB  START         JSR   SYSMOVI                  fetch the inputs         LDA   MR5                      split on move size         BEQ   MV2         LDY   #0MV1      LDA   (MR0),Y                  move 256 bytes         STA   (MR2),Y         INY         BNE   MV1         INC   MR1                      next 256 byte block         INC   MR2         DBNE  MR5,MV1MV2      LDY   MR4                      move MR4 bytes         BEQ   MV4         LDY   #0MV3      LDA   (MR0),Y         STA   (MR2),Y         INY         BEQ   MV4         CPY   MR4         BLT   MV3MV4      RTS         END******************************************************************  SYSMOVE - Move Memory from the End**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        MR0 - from address*        MR2 - to address*        MR4 - move length******************************************************************SYSMOVE  START         JSR   SYSMOVI                  fetch the inputs         ADD2  MR0,MR4         DEC2  MR0         ADD2  MR2,MR4         DEC2  MR2         LDA   MR5                      split on move size         BEQ   IN3         LDY   #0                       move the first byteIN1      LDA   (MR0),Y         STA   (MR2),Y         DEC   MR1                      initialize the loop variables         DEC   MR3         DEYIN2      LDA   (MR0),Y                  move 255 bytes         STA   (MR2),Y         DBNE  Y,IN2         DBNE  MR5,IN1                  next 256 byte blockIN3      LDY   MR4                      move MR4 bytes         BEQ   IN8         DEC   MR4         SEC         LDA   MR2         SBC   MR4         STA   MR2         BCS   IN4         DEC   MR3         SECIN4      LDA   MR0         SBC   MR4         STA   MR0         BCS   IN5         DEC   MR1IN5      DEY         BEQ   IN7IN6      LDA   (MR0),Y         STA   (MR2),Y         DBNE  Y,IN6IN7      LDA   (MR0),Y         STA   (MR2),YIN8      RTS         END******************************************************************  SYSMOVI - Move Initialization**  Initialization routine for SYSMOVB and SYSMOVE.**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        * - addressing modes*        *+2 - from address*        *+4 - to address*        *+6 - move length**  OUTPUTS:*        MR0 - from address*        MR2 - to address*        MR4 - move length******************************************************************SYSMOVI  START         PLA                            recover return address         STA   WR0         PLA         STA   WR1         PLA                            recover operand address         STA   WR2         PLA         STA   WR3         INC2  WR0         LDY   #1                       get the operand format         LDA   (WR2),Y         STA   WR4         INY         LDA   (WR2),Y         STA   WR5         ADD2  WR2,#3         LA    WR6,MR0                  fetch the operands         JSR   FORM         JSR   FORM         JSR   FORM         DEC2  WR2                      fix return address         LDA   WR3         PHA         LDA   WR2         PHA         JMP   (WR0)                    return to move routine;;  FORM - form an operand.;FORM     LDA   #0                       get operand type         ASL   WR5         ROL   WR4         ROL   A         ASL   WR5         ROL   WR4         ROL   A         ASL   WR5         ROL   WR4         ROL   A         BNE   FR2                      immediate operand         JSR   FETCH         MOVE  MR6,{WR6}         JMP   FR5FR2      CMP   #2                       absolute operand         BGE   FR3         JSR   FETCH         JMP   FR3AFR3      BNE   FR4                      indirect         JSR   FETCH         LDY   #0         LDA   (MR6),Y         TAX         INY         LDA   (MR6),Y         STA   MR7         STX   MR6FR3A     MOVE  {MR6},{WR6}         JMP   FR5FR4      MOVE  {SYSESTE},{WR6}          stack         ADD2  SYSESTE,#2FR5      ADD2  WR6,#2         RTS;;  FETCH - fetch an operand.;FETCH    MOVE  {WR2},MR6         ADD2  WR2,#2         RTS         END******************************************************************  SYSRELS - Release Memory**  Releases memory in the ProDOS system bit map.**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        WR0 - first location to release*        WR2 - number of bytes to release******************************************************************SYSRELS  STARTBITMAP   EQU   $BF58                    ProDOS memory bit map         CLC                            update the number of bytes to release         LDA   WR0                       based on the limitation of releasing         ADC   WR2                       memory in units of 1 page         STA   WR2         BCC   LB1         INC   WR3LB1      LDA   WR2                      compute number of pages to release         BEQ   LB2         INC   WR3LB2      LDA   WR1                      release the memory         JSR   SYSMASK         EOR   #$FF         AND   BITMAP,X         STA   BITMAP,X         INC   WR1         DBNE  WR3,LB2         RTS         END******************************************************************  SYSRESV - Reserve Memory**  Reserves memory in the ProDOS system bit map.**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        WR0 - first location to reserve*        WR2 - number of bytes to reserve******************************************************************SYSRESV  STARTBITMAP   EQU   $BF58                    ProDOS memory bit map         CLC                            update the number of bytes to reserve         LDA   WR0                       based on the limitation of reserving         ADC   WR2                       memory in units of 1 page         STA   WR2         BCC   LB1         INC   WR3LB1      LDA   WR2                      compute number of pages to reserve         BEQ   LB2         INC   WR3LB2      LDA   WR1                      reserve the memory         JSR   SYSMASK         ORA   BITMAP,X         STA   BITMAP,X         INC   WR1         DBNE  WR3,LB2         RTS         END******************************************************************  SYSMASK - Create Bit Map Mask**  Creates the mask for a particular page in the system*  memory bit mask.**  By Mike Westerfield*  Copyright (C) June 1984, All rights reserved*  By the Byte Works, Inc.**  INPUTS:*        A - page number to create mask for**  OUTPUTS:*        A - bit mask; a 1 marks the bit used for this page*        X - disp in bit mask table******************************************************************SYSMASK  START         PHA         MLSR  A,3         TAX         PLA         AND   #7         TAY         SEC         LDA   #0MS1      ROR   A         DBPL  Y,MS1         RTS         END         APPEND MS.1