			case  on	seg   ''******************************************************************  signal - Asyncronous event signal handler**  April 1990*  Mike Westerfield**  Copyright 1990*  Byte Works, Inc.******************************************************************;	INCLUDE	'equates.asm';-----------------------------------------------;;   Imported addresses;;-----------------------------------------------	IMPORT	errno;-----------------------------------------------;;   Forward addresses and entries;;-----------------------------------------------	ENTRY	subABRT******************************************************************  This file contains constant values defined in the C interfaces*  that are also used in the assembly language portion of the*  libraries.*****************************************************************;;  error numbers;EDOM     equ   1                        ;domain errorERANGE   equ   2                        ;# too large, too small, or illegalENOMEM   equ   3                        ;Not enough memoryENOENT   equ   4                        ;No such file or directoryEIO      equ   5                        ;I/O errorEINVAL   equ   6                        ;Invalid argumentEBADF    equ   7                        ;bad file descriptorEMFILE   equ   8                        ;too many files are openEACCES   equ   9                        ;access bits prevent the operationEEXIST   equ   10                       ;the file existsENOSPC   equ   11                       ;the file is too large;;  masks for the __ctype array;_digit   equ   $01                      ;['0'..'9']_upper   equ   $02                      ;['A'..'Z']_lower   equ   $04                      ;['a'..'z']_control equ   $08                      ;[chr(0)..chr(31),chr(127)]_punctuation equ  $10                   ;[' ','!'..'/',':'..'@','['..'`','{'..'~']_space   equ   $20                      ;[chr(9)..chr(13),' ']_hex     equ   $40                      ;['0'..'9','a'..'f','A'..'F']_print   equ   $80                      ;[' '..'~'];;  masks for the __ctype2 array;_csym    equ   $01                      ;['0'..'9','A'..'Z','a'..'z','_']_csymf   equ   $02                      ;['A'..'Z','a'..'z'.'_']_octal   equ   $04                      ;['0'..'7'];;  signal numbers;SIGABRT  equ   1SIGFPE   equ   2SIGILL   equ   3SIGINT   equ   4SIGSEGV  equ   5SIGTERM  equ   6;;  The FILE record;*                                       ;flags*                                       ;-----_IOFBF   equ   $0001                    ;full buffering_IONBF   equ   $0002                    ;no buffering_IOLBF   equ   $0004                    ;flush when a \n is written_IOREAD  equ   $0008                    ;currently reading_IOWRT   equ   $0010                    ;currently writing_IORW    equ   $0020                    ;read/write enabled_IOMYBUF equ   $0040                    ;buffer was allocated by stdio_IOEOF   equ   $0080                    ;has an EOF been found?_IOERR   equ   $0100                    ;has an error occurred?_IOTEXT  equ   $0200                    ;is this file a text file?_IOTEMPFILE equ  $0400                  ;was this file created by tmpfile()?*                                       ;record structure*                                       ;----------------FILE_next equ  0                        ;disp to next pointer (must stay 0!)FILE_ptr  equ  FILE_next+4              ;next location to write toFILE_base equ  FILE_ptr+4               ;first byte of the bufferFILE_end  equ  FILE_base+4              ;end of the file bufferFILE_size equ  FILE_end+4               ;size of the file bufferFILE_cnt  equ  FILE_size+4              ;# chars that can be read/writen to bufferFILE_pbk  equ  FILE_cnt+4               ;put back characterFILE_flag equ  FILE_pbk+2               ;buffer flagsFILE_file equ  FILE_flag+2              ;GS/OS file IDsizeofFILE equ  FILE_file+2             ;size of the recordBUFSIZ   equ   1024                     ;default file buffer size_LBUFSIZ equ   255                      ;line buffer sizeL_tmpnam equ   9                        ;size of a temp nameTMP_MAX  equ   10000                    ;# of uniq temp names;;  Seek codes for fseek;SEEK_CNT equ   0                        ;seek from start of fileSEEK_CUR equ   1                        ;seek from current positionSEEK_END equ   2                        ;seek from end of file;;  Values for fcntl.h;OPEN_MAX equ   30                       ;files in the file arrayF_DUPFD  equ   1                        ;dup file flag (fcntl)O_RDONLY equ   $0001                    ;file is read onlyO_WRONLY equ   $0002                    ;file is write onlyO_RDWR   equ   $0004                    ;file is read/writeO_NDELAY equ   $0008                    ;not usedO_APPEND equ   $0010                    ;append to file on all writesO_CREAT  equ   $0020                    ;create a new file if neededO_TRUNC  equ   $0040                    ;erase old fileO_EXCL   equ   $0080                    ;don't create a new fileO_BINARY equ   $0100                    ;file is binary;;  Misc.;EOF      equ   -1                       ;end of file characterstdinID  equ   -1                       ;standard in file IDstdoutID equ   -2                       ;standard out file IDstderrID equ   -3                       ;error out file IDSIG_DFL  equ   -3SIG_IGN  equ   -2SIG_ERR  equ   -1SIGMAX   equ   6                        ;maximum number of signals******************************************************************  void (*signal(int sig, void (*func) (int)))(int);**  Set the interupt handler**  Inputs:*        sig - signal number*        func - signal handler**  Returns:*        Pointer to the last signal handler; SIG_ERR if sig*        is out of range.******************************************************************		EXPORT	signal   signal   PROC	;using signalCommonptr      equ   1                        ;old sugnal handler;;       csubroutine (2:sig,4:func),4	; sig      equ   0+4+4func     equ   2+4+4         tsc         sec         sbc   #4         tcs         phd         tcd;;       lla   ptr,SIG_ERR              ;assume we will find an error	;          LDA   #SIG_ERR         STA   ptr         LDA   #^SIG_ERR         STA   2+ptr         lda   sig                      ;if (!sig in [1..6])         beq   lb1         cmp   #SIGMAX+1         blt   lb2lb1      lda   #ERANGE                  ;  errno = ERANGE         sta   >errno         bra   lb3lb2      asl   A                        ;get the old signal handler address         asl   A         tax         lda   >subABRT-4,X         sta   ptr         lda   >subABRT-2,X         sta   ptr+2         lda   func                     ;set the new signal handler address         sta   >subABRT-4,X         lda   func+2         sta   >subABRT-2,X;;lb3    creturn 4:ptrlb3	;          ldx   ptr+2         ldy   ptr         lda   4+2         sta   4+6+2         lda   4+1         sta   4+6+1         pld         tsc         clc         adc   #4+6         tcs         tya         rtl		ENDP******************************************************************  int raise(int sig);**  Raise a signal.**  Inputs:*        sig - signal number**  Returns:*        0 if successful, -1 if sig is out of range******************************************************************		EXPORT	raise    raise    PROC	;using signalCommonval      equ   1                        ;value to return;;       csubroutine (2:sig),2	; sig      equ   0+4+2         tsc         sec         sbc   #2         tcs         phd         tcd         stz   val                      ;no error         lda   sig                      ;if (!sig in [1..6])         beq   lb1         cmp   #SIGMAX+1         blt   lb2lb1      lda   #-1                      ;  val = -1         sta   val         lda   #ERANGE                  ;  errno = ERANGE         sta   >errno         bra   lb3lb2      asl   A                        ;get the signal handler address         asl   A         tax         lda   >subABRT-4,X         tay         lda   >subABRT-2,X         bmi   lb3                      ;skip if it is SIG_DFL or SIG_IGN;;       short M                        ;set up the call address         SEP   #1*32+0*16			LONGA OFF         sta   >jsl+3;;       long  M         REP   #1*32+0*16			LONGA ON         tya         sta   >jsl+1;;       ph2   sig                      ;call the user signal handler	;          LDA   sig         PHAjsl      jsl   jsl;;lb3    creturn 2:vallb3	;          ldy   val         lda   2+2         sta   2+2+2         lda   2+1         sta   2+2+1         pld         tsc         clc         adc   #2+2         tcs         tya         rtl		ENDP******************************************************************  signalCommon - data area for the signal unit*******************************************************************signalCommon privdatasignalCommon		PROC			ENTRY	subABRTsubABRT	DC.L	SIG_DFL		ENTRY	subFPEsubFPE	DC.L	SIG_DFL		ENTRY	subILLsubILL	DC.L	SIG_DFL		ENTRY	subINTsubINT	DC.L	SIG_DFL		ENTRY	subSEGVsubSEGV	DC.L	SIG_DFL		ENTRY	subTERMsubTERM	DC.L	SIG_DFL		ENDP		END