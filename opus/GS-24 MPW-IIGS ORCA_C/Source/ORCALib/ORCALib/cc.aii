	seg   ''******************************************************************  CC - C Specific Run Time Libraries**  October 1988*  Mike Westerfield**  Copyright 1988*  Byte Works, Inc.******************************************************************;-----------------------------------------------;;   Imported addresses;;-----------------------------------------------	IMPORT	L	IMPORT	SystemError	IMPORT	~CommandLine	IMPORT	~PUTS	IMPORT	~Quit	IMPORT	~RTL	IMPORT	~TOOLERROR	IMPORT	~User_ID			case  on	IMPORT	fclose	IMPORT	stderr	IMPORT	~InitIO			case  off;-----------------------------------------------;;   Forward addresses and entries;;-----------------------------------------------	ENTRY	~Exit	ENTRY	~ExitList******************************************************************  ~CopyBF - Copy a bit field*  ~SaveBF - Save a bit field**  Inputs:*        addr - address to copy to*        bitDisp - displacement past the address*        bitNum - number of bits*        val - value to copy******************************************************************		EXPORT	~CopyBF  ~CopyBF  PROCret      equ   2                        ;return addressval      equ   5                        ;value to copybitNum   equ   9                        ;number of bitsbitDisp  equ   11                       ;displacement past the addressaddr     equ   13                       ;address to copy to         lda   #0                       ;set the call type         bra   lb1		EXPORT	~SaveBF~SaveBF		;		         lda   #1lb1      phb         phk         plb         sta   isSave         tsc                            ;set up the stack frame         phd         tcd;;       move4 val,lval                 ;save the value (for copybf only);;       ~SETM	;          LDA   2+val         STA   2+lval         LDA   val         STA   lval;;       ~RESTM	;          stz   mask+2                   ;set up the and mask         ldx   bitNum         lda   #0lb2      sec         rol   A         rol   mask+2         dex         bne   lb2         sta   mask         and   val                      ;and out extra bits in the mask         sta   val         lda   mask+2         and   val+2         sta   val+2         ldx   bitDisp                  ;shift the mask and value         beq   lb4         lda   masklb3      asl   A         rol   mask+2         asl   val         rol   val+2         dex         bne   lb3         sta   masklb4      ldy   #2                       ;place the bits in memory         lda   mask         eor   #$FFFF         and   [addr]         ora   val         sta   [addr]         lda   mask+2         eor   #$FFFF         and   [addr],Y         ora   val+2         sta   [addr],Y         lda   isSave                   ;branch based on call type         beq   lb5         lda   ret+1                    ;return from save         sta   addr+2         lda   ret         sta   addr+1         pld         plb         tsc         clc         adc   #12         tcs         rtl;;lb5    move4 lval,addr                ;place the value back on the stack;;lb5    ~SETMlb5	;          LDA   2+lval         STA   2+addr         LDA   lval         STA   addr;;       ~RESTM	;          lda   ret+1                    ;return from copy         sta   bitDisp         lda   ret         sta   bitDisp-1         pld         plb         tsc         clc         adc   #8         tcs         rtl;;  local data;mask		DS.B 4                        ;bit maskisSave		DS.B 2                        ;is the call a save? (or copy?)lval		DS.B 4                        ;temp storage for val		ENDP******************************************************************  ~C_ShutDown - do shut down peculiar to the C language**  Inputs:*        A - shell return code******************************************************************		EXPORT	~C_ShutDown ~C_ShutDown PROC         pha                            ;save the return code         jsr   ~Exit                    ;do exit processing         pla                            ;quit         jml   ~Quit		ENDP******************************************************************  ~C_ShutDown2 - do shut down peculiar ;to the C language**  Inputs:*        A - shell return code******************************************************************		EXPORT	~C_ShutDown2 ~C_ShutDown2 PROC         pha                            ;save the return code         jsr   ~Exit                    ;do exit processing         pla                            ;quit         jml   ~RTL		ENDP******************************************************************  ~C_StartUp - do startup peculiar to the C language******************************************************************		EXPORT	~C_StartUp ~C_StartUp PROCargv     equ   11                       ;argument vectorargc     equ   9                        ;argument countcLine    equ   1                        ;command line addressTAB      equ   9                        ;TAB key code         phb                            ;remove our return address         phk         plb         plx         ply         pea   0                        ;make room for argc, argv         pea   0         pea   0         phy                            ;put the return addr back on the stack         phx;;       ph4   ~CommandLine             ;create some work space	;          LDA   ~CommandLine+2         PHA         LDA   ~CommandLine         PHA         tsc                            ;set up our stack frame         phd         tcd         stz   ~ExitList                ;no exit routines, yet         stz   ~ExitList+2			case  on         jsl   ~InitIO                  ;reset standard I/O			case  off         lda   cLine                    ;if cLine == 0 then         ora   cLine+2;;       jeq   rtl                      ;  exit         BNE   *+5         BRL   rtl;;       add4  cLine,#8                 ;skip the shell identifier;;       ~SETM	;          CLC;;       ~LDA  cLine         LDA   cLine;;       ~OP   ADC,#8         ADC   #8;;       ~STA  cLine         STA   cLine         BCC   ~4;;       ~OP.H INC,cLine	;          INC   2+cLine~4	; ;;       ~RESTM	;          ldx   #0                       ;count the arguments         txy;;       short M         SEP   #1*32+0*16			LONGA OFFlb2      lda   [cLine],Y         beq   lb6         cmp   #' '         beq   lb3         cmp   #'"'         beq   lb3         cmp   #TAB         bne   lb4lb3      iny         bra   lb2lb4      inxlb5      lda   [cLine],Y         beq   lb6         cmp   #' '         beq   lb2         cmp   #'"'         beq   lb2         cmp   #TAB         beq   lb2         iny         bra   lb5;;lb6    long  Mlb6      REP   #1*32+0*16			LONGA ON         txa                            ;we need (X+1)*4 + strlen(cLine)+1 bytes         inc   A         asl   A         asl   A         sta   start         phy         sec         adc   1,S         ply         pha         pha         pea   0         pha;;       ph2   >~User_ID	;          LDA   >~User_ID         PHA;;       ph2   #$C008	;          PEA   $C008;;       ph4   #0	;          PEA   +(0)>>16         PEA   0;;       _NewHandle         LDX   #$0902         JSL   $E10000         bcc   lb7;;       puts  #'Out of memory',cr=t,errout=t;;       ~SETM	;          BRA   ~17~L17	DC.B	13~S17	DC.B	'Out of memory'~17	; ;;       ~PUSHA ~L17-1	;          PEA   +(~L17-1)>>16         PEA   ~L17-1         PEA   0;;       PH2   #C:&CR	;          PEA   1;;       PH2   #C:&ERROUT	;          PEA   1         JSL   ~PUTS;;       ~RESTM	;          lda   #-1         jml   ~Quit;;lb7    pl4   argv                     ;get the pointer to the arealb7	;          PLA         STA   argv         PLA         STA   argv+2         ldy   #2         lda   [argv],Y         tax         lda   [argv]         sta   targv         stx   targv+2         clc                            ;get a pointer to the command line string         adc   start         bcc   lb8         inxlb8      sta   argv         stx   argv+2;;       short M                        ;move the command line string         SEP   #1*32+0*16			LONGA OFF         ldy   #0lb9      lda   [cLine],Y         sta   [argv],Y         beq   lb10         iny         bra   lb9;;lb10   long  Mlb10     REP   #1*32+0*16			LONGA ON;;       move4 argv,cLine               ;save the pointer;;       ~SETM	;          LDA   2+argv         STA   2+cLine         LDA   argv         STA   cLine;;       ~RESTM	; ;;       move4 targv,argv               ;set up the pointer to argv;;       ~SETM	;          LDA   2+targv         STA   2+argv         LDA   targv         STA   argv;;       ~RESTM	; av1      lda   [cLine]                  ;skip leading spaces         and   #$00FF         beq   av8         cmp   #' '         beq   av2         cmp   #TAB         bne   av3;;av2    inc4  cLine;;av2    ~SETMav2	;          INC   cLine         BNE   ~32         INC   2+cLine;;~32    ~RESTM~32	;          bra   av1av3      tax                            ;save the argument         cmp   #'"'                     ;if the argument is quoted then         bne   av4;;       inc4  cLine                    ;  skip the quote;;       ~SETM	;          INC   cLine         BNE   ~35         INC   2+cLine;;~35    ~RESTM~35	; av4      ldy   #2                       ;save the address in argv         lda   cLine         sta   [argv]         lda   cLine+2         sta   [argv],Y;;       add4  argv,#4;;       ~SETM	;          CLC;;       ~LDA  argv         LDA   argv;;       ~OP   ADC,#4         ADC   #4;;       ~STA  argv         STA   argv         BCC   ~38;;       ~OP.H INC,argv	;          INC   2+argv~38	; ;;       ~RESTM	;          inc   argc                     ;inc the # of arguments         cpx   #'"'                     ;if the string is quoted then         bne   av6av5      lda   [cLine]                  ;  skip to the next quote         and   #$00FF         beq   av8         cmp   #'"'         beq   av7;;       inc4  cLine;;       ~SETM	;          INC   cLine         BNE   ~45         INC   2+cLine;;~45    ~RESTM~45	;          bra   av5                      ;elseav6      lda   [cLine]                  ;  skip to the next whitespace char         and   #$00FF         beq   av8         cmp   #' '         beq   av7         cmp   #TAB         beq   av7;;       inc4  cLine;;       ~SETM	;          INC   cLine         BNE   ~48         INC   2+cLine;;~48    ~RESTM~48	;          bra   av6;;av7    short M                        ;null terminate the parameterav7      SEP   #1*32+0*16			LONGA OFF         lda   #0         sta   [cLine];;       long  M         REP   #1*32+0*16			LONGA ON         bra   av2                      ;get the next parameterav8      lda   #0                       ;null terminate the arg list         sta   [argv]         ldy   #2         sta   [argv],Y;;       move4 targv,argv               ;set up the pointer to argv;;       ~SETM	;          LDA   2+targv         STA   2+argv         LDA   targv         STA   argv;;       ~RESTM	; rtl      pld                            ;return         pla         pla         plb         rtltargv		DS.B 4start		DS.B 2                        ;start of the command line string		ENDP******************************************************************  ~C_StartUp2 - do C startup for RTL pragma programs******************************************************************		EXPORT	~C_StartUp2 ~C_StartUp2 PROC         phb                            ;remove our return address         phk         plb         plx         ply         pea   0                        ;set argc, argv to 0         pea   0         pea   0         phy                            ;put the return addr back on the stack         phx         stz   ~ExitList                ;no exit routines, yet         stz   ~ExitList+2         plb                            ;return         rtl		ENDP******************************************************************  ~Exit - call exit routines and clean ;up open files**  Inputs:*        ~ExitList - list of exit routines******************************************************************		EXPORT	~Exit    ~Exit    PROCptr      equ   3                        ;pointer to exit routines;;  Set up our stack frame;         phb         phk         plb;;       ph4   ~ExitList                ;set up our stack frame	;          LDA   ~ExitList+2         PHA         LDA   ~ExitList         PHA         phd         tsc         tcd;;  Call the exit functions;lb1      lda   ptr                      ;if the pointer is non-nil then         ora   ptr+2         beq   LB3         pea   +(lb2-1)>>8              ;call the function         pea   +(lb2-1)<<8         phb         pla         ldy   #5         lda   [ptr],Y         pha         dey         dey         lda   [ptr],Y         pha         phb         pla         rtllb2      ldy   #2                       ;  dereference the pointer         lda   [ptr],Y         tax         lda   [ptr]         sta   ptr         stx   ptr+2         bra   lb1;;  Close (and flush) any open files;			case  onLB3      lda   >stderr+6                ;while there is a next file         ora   >stderr+4         beq   LB4;;       ph4   >stderr+4                ;  close it	;          LDA   >stderr+4+2         PHA         LDA   >stderr+4         PHA	DC.B	$22	;  (jsl fclose, soft reference)	DC.A	fclose         bra   LB3			case  off;;  return;LB4      pld                            ;return         pla         pla         plb         rts		ENDP******************************************************************  ~ExitList - list of exit routines******************************************************************		EXPORT	~ExitList ~ExitList PROC		DS.B 4		ENDP******************************************************************  ~IntChkC - check for integer math error**  Inputs:*        V - set for error******************************************************************		EXPORT	~IntChkC ~IntChkC PROC         bvc   lb1                      ;branch if no error         php         pha         phx         phy;;       error #9                       ;integer math error;;       ph2   #9	;          PEA   9         jsl   SystemError         ply         plx         pla         plplb1      rtl		ENDP******************************************************************  ~LoadBF - load a bit field**  Inputs:*        addr - address to load from*        bitDisp - displacement past the address*        bitNum - number of bits******************************************************************		EXPORT	~LoadBF  ~LoadBF  PROCmask     equ   1                        ;bit masksign     equ   5                        ;sign mask;;       csubroutine (2:bitNum,2:bitDisp,4:addr),8	; bitNum   equ   0+4+8bitDisp  equ   2+4+8addr     equ   4+4+8         tsc         sec         sbc   #8         tcs         phd         tcd         ldy   #2                       ;get the value         lda   [addr],Y         tax         lda   [addr]         sta   addr         stx   addr+2         ldx   bitDisp                  ;normalize the value         beq   lb2lb1      lsr   addr+2         ror   addr         dex         bne   lb1lb2      stz   mask                     ;form the bit and sign mask         lda   #-1         sta   sign         sta   sign+2         lda   #0         ldx   bitNumlb3      sec         rol   A         rol   mask         asl   sign         rol   sign+2         dex         bne   lb3         sec                            ;adjust the sign flag         ror   sign+2         ror   sign         and   addr                     ;and out the extra bits         sta   addr         lda   mask         and   addr+2         sta   addr+2         lda   addr                     ;if the value is negative then         and   sign         bne   lb4         lda   addr+2         and   sign+2         beq   lb5lb4      lda   addr                     ;  or in the sign bits         ora   sign         sta   addr         lda   addr+2         ora   sign+2         sta   addr+2;;lb5    creturn 4:addrlb5	;          ldx   addr+2         ldy   addr         lda   8+2         sta   8+8+2         lda   8+1         sta   8+8+1         pld         tsc         clc         adc   #8+8         tcs         tya         rtl		ENDP******************************************************************  ~LoadStruct - load a long value onto ;the stack**  Inputs:*        addr - address of the structure to load*        size - size of the structure******************************************************************		EXPORT	~LoadStruct ~LoadStruct PROC         phb                            ;save the caller's data bank;;       pl4   >ret                     ;get the return address	;          PLA         STA   >ret         PLA         STA   >ret+2         plx                            ;get the transfer size         pla                            ;get the absolute save addr         sta   >ad1+1         sta   >ad2+1         plb                            ;set the data bank         phb                            ; remove the data bank & extra addr byte         pla         txa                            ;quit if there are no bytes to move         beq   lb3         lsr   a                        ;branch if the # of bytes is even         bcc   lb1         dex                            ;move one byte;;       short M         SEP   #1*32+0*16			LONGA OFFad1      lda   ad1,X         pha;;       long  M         REP   #1*32+0*16			LONGA ON         txa         beq   lb3lb1      dex                            ;move the words         dex         bmi   lb3ad2      lda   ad2,X         pha         bra   lb1;;lb3    ph4   >ret                     ;return to the callerlb3	;          LDA   >ret+2         PHA         LDA   >ret         PHA         plb         rtl;;  Local data;ret		DS.B 4		ENDP******************************************************************  ~LoadUBF - load an unsigned bit field**  Inputs:*        addr - address to load from*        bitDisp - displacement past the address*        bitNum - number of bits******************************************************************		EXPORT	~LoadUBF ~LoadUBF PROCmask     equ   1                        ;msw of bit mask;;       csubroutine (2:bitNum,2:bitDisp,4:addr),2	; bitNum   equ   0+4+2bitDisp  equ   2+4+2addr     equ   4+4+2         tsc         sec         sbc   #2         tcs         phd         tcd         ldy   #2                       ;get the value         lda   [addr],Y         tax         lda   [addr]         sta   addr         stx   addr+2         ldx   bitDisp                  ;normalize the value         beq   lb2lb1      lsr   addr+2         ror   addr         dex         bne   lb1lb2      stz   mask                     ;form the bit mask         lda   #0         ldx   bitNumlb3      sec         rol   A         rol   mask         dex         bne   lb3         and   addr                     ;and out the extra bits         sta   addr         lda   mask         and   addr+2         sta   addr+2;;       creturn 4:addr	;          ldx   addr+2         ldy   addr         lda   2+2         sta   2+8+2         lda   2+1         sta   2+8+1         pld         tsc         clc         adc   #2+8         tcs         tya         rtl		ENDP******************************************************************  ~LongMove2 - move some bytes**  Inputs:*        source - pointer to source bytes*        dest - pointer to destination bytes*        len - number of bytes to move**  Notes:*        This subroutine leaves the destination address on the*        stack.  It is used by C for multiple assignment of*        arrays and structures.  It differs from ~Move2 in that*        it can move 64K or more.******************************************************************		EXPORT	~LongMove2 ~LongMove2 PROC;;       csubroutine (4:len,4:source),0	; len      equ   0+4+0source   equ   4+4+0         tsc         phd         tcddest     equ   source+4         ldx   len+2                    ;move whole banks         beq   lm2         ldy   #0lm1      lda   [source],Y         sta   [dest],Y         dey         dey         bne   lm1         inc   source+2         inc   dest+2         dex         bne   lm1lm2      lda   len                      ;move one byte if the move length is odd         lsr   a         bcc   lb1;;       short M         SEP   #1*32+0*16			LONGA OFF         lda   [source]         sta   [dest];;       long  M         REP   #1*32+0*16			LONGA ON;;       inc4  source;;       ~SETM	;          INC   source         BNE   ~5         INC   2+source;;~5     ~RESTM~5	; ;;       inc4  dest;;       ~SETM	;          INC   dest         BNE   ~8         INC   2+dest;;~8     ~RESTM~8	;          dec   lenlb1      ldy   len                      ;move the bytes         beq   lb4         dey         dey         beq   lb3lb2      lda   [source],Y         sta   [dest],Y         dey         dey         bne   lb2lb3      lda   [source]         sta   [dest];;lb4    creturnlb4	;          lda   0+2         sta   0+8+2         lda   0+1         sta   0+8+1         pld         tsc         clc         adc   #0+8         tcs         rtl		ENDP******************************************************************  ~LShr4 - Shift an unsigned long value right**  Inputs:*        A - value to shift*        X - # bits to shift by**  Outputs:*        A - result******************************************************************		EXPORT	~LShr4   ~LShr4   PROCnum1     equ   8                        ;number to shiftnum2     equ   4                        ;# bits to shift by         tsc                            ;set up DP         phd         tcd         lda   num2+2                   ;if num2 < 0 then         bpl   lb2         cmp   #$FFFF                   ;  shift left         bne   zero         ldx   num2         cpx   #-34         blt   zerolb1      asl   num1         rol   num1+2         inx         bne   lb1         bra   lb4zero     stz   num1                     ;  (result is zero)         stz   num1+2         bra   lb4lb2      bne   zero                     ;else shift right         ldx   num2         beq   lb4         cpx   #33         bge   zerolb3      lsr   num1+2         ror   num1         dex         bne   lb3lb4      lda   0                        ;fix stack and return         sta   num2         lda   2         sta   num2+2         pld         pla         pla         rtl		ENDP******************************************************************  ~Move2 - move some bytes**  Inputs:*        source - pointer to source bytes*        dest - pointer to destination bytes*        len - number of bytes to move**  Notes:*        This subroutine leaves the destination address on the*        stack.  It is used by C for multiple assignment of*        arrays and structures.******************************************************************		EXPORT	~Move2   ~Move2   PROC;;       csubroutine (2:len,4:source),0	; len      equ   0+4+0source   equ   2+4+0         tsc         phd         tcddest     equ   source+4         lda   len                      ;move one byte if the move length is odd         lsr   a         bcc   lb1;;       short M         SEP   #1*32+0*16			LONGA OFF         lda   [source]         sta   [dest];;       long  M         REP   #1*32+0*16			LONGA ON;;       inc4  source;;       ~SETM	;          INC   source         BNE   ~5         INC   2+source;;~5     ~RESTM~5	; ;;       inc4  dest;;       ~SETM	;          INC   dest         BNE   ~8         INC   2+dest;;~8     ~RESTM~8	;          dec   lenlb1      ldy   len                      ;move the bytes         beq   lb4         dey         dey         beq   lb3lb2      lda   [source],Y         sta   [dest],Y         dey         dey         bne   lb2lb3      lda   [source]         sta   [dest];;lb4    creturnlb4	;          lda   0+2         sta   0+6+2         lda   0+1         sta   0+6+1         pld         tsc         clc         adc   #0+6         tcs         rtl		ENDP******************************************************************  extern pascal PDosInt(int callNum, void *parm)**  Make a ProDOS or shell call**  Inputs:*        callNum - ProDOS call number*        parm - address of the parameter block******************************************************************		EXPORT	PDOSINT  PDOSINT  PROCProDOS   equ   $E100A8;;       csubroutine (4:parm,2:callNum),0	; parm     equ   0+4+0callNum  equ   4+4+0         tsc         phd         tcd         lda   callNum         sta   >lb1         lda   parm         sta   >lb2         lda   parm+2         sta   >lb2+2         jsl   ProDOSlb1		DS.B 2lb2		DS.B 4         sta   >~TOOLERROR;;       creturn	;          lda   0+2         sta   0+6+2         lda   0+1         sta   0+6+1         pld         tsc         clc         adc   #0+6         tcs         rtl		ENDP******************************************************************  ~UDiv4 - Four byte unsigned integer divide**  Inputs:*        num1 - numerator*        X-A - denominator**  Outputs:*        ans - result******************************************************************		EXPORT	~UDiv4   ~UDiv4   PROCnum1     equ   12                       ;argumentsans      equ   1                        ;answerrem      equ   5                        ;remainderreturn   equ   9;;  Initialize;         tay                            ;place the values in the correct spot         pea   0                        ; on the stack frame         pea   0         lda   10,S         pha         lda   10,S         pha         tsc                            ;set up DP         phd         tcd         sty   num1         stx   num1+2         tya                            ;check for division by zero         ora   num1+2         beq   dv10         lda   num1+2                   ;do 16 bit divides separately         ora   ans+2         beq   dv5;;  32 bit divide;         ldy   #32                      ;32 bits to godv3      asl   ans                      ;roll up the next number         rol   ans+2         rol   ans+4         rol   ans+6         sec                            ;subtract for this digit         lda   ans+4         sbc   num1         tax         lda   ans+6         sbc   num1+2         bcc   dv4                      ;branch if minus         stx   ans+4                    ;turn the bit on         sta   ans+6         inc   ansdv4      dey                            ;next bit         bne   dv3         bra   dv9                      ;go do the sign;;  16 bit divide;dv5      lda   #0                       ;initialize the remainder         ldy   #16                      ;16 bits to godv6      asl   ans                      ;roll up the next number         rol   a         sec                            ;subtract the digit         sbc   num1         bcs   dv7         adc   num1                     ;digit is 0         dey         bne   dv6         bra   dv8dv7      inc   ans                      ;digit is 1         dey         bne   dv6dv8      sta   ans+4                    ;save the remainder;;  Return the result;;;dv9    move4 ans,num1                 ;move answer;;dv9    ~SETMdv9	;          LDA   2+ans         STA   2+num1         LDA   ans         STA   num1;;       ~RESTM	; dv10     pld                            ;return         tsc         clc         adc   #8         tcs         rtl		ENDP******************************************************************  ~UMod4 - Four byte unsigned integer remainder**  Inputs:*        num1 - numerator*        X-A - denominator**  Outputs:*        ans - result******************************************************************		EXPORT	~UMod4   ~UMod4   PROCnum1     equ   12                       ;argumentsans      equ   1                        ;answerrem      equ   5                        ;remainderreturn   equ   9;;  Initialize;         tay                            ;place the values in the correct spot         pea   0                        ; on the stack frame         pea   0         lda   10,S         pha         lda   10,S         pha         tsc                            ;set up DP         phd         tcd         sty   num1         stx   num1+2         tya                            ;check for division by zero         ora   num1+2         beq   dv10         lda   num1+2                   ;do 16 bit divides separately         ora   ans+2         beq   dv5;;  32 bit divide;         ldy   #32                      ;32 bits to godv3      asl   ans                      ;roll up the next number         rol   ans+2         rol   ans+4         rol   ans+6         sec                            ;subtract for this digit         lda   ans+4         sbc   num1         tax         lda   ans+6         sbc   num1+2         bcc   dv4                      ;branch if minus         stx   ans+4                    ;turn the bit on         sta   ans+6         inc   ansdv4      dey                            ;next bit         bne   dv3         bra   dv9                      ;go do the sign;;  16 bit divide;dv5      lda   #0                       ;initialize the remainder         ldy   #16                      ;16 bits to godv6      asl   ans                      ;roll up the next number         rol   a         sec                            ;subtract the digit         sbc   num1         bcs   dv7         adc   num1                     ;digit is 0         dey         bne   dv6         bra   dv8dv7      inc   ans                      ;digit is 1         dey         bne   dv6dv8      sta   ans+4                    ;save the remainder;;  Return the result;;;dv9    move4 ans+4,num1               ;move answer;;dv9    ~SETMdv9	;          LDA   2+ans+4         STA   2+num1         LDA   ans+4         STA   num1;;       ~RESTM	; dv10     pld                            ;return         tsc         clc         adc   #8         tcs         rtl		ENDP******************************************************************  ~Zero - zero an area of direct page memory**  Inputs:*        addr - address of the memory*        size - number of bytes to zero ;(must be > 1)******************************************************************		EXPORT	~Zero    ~Zero    PROC;;       csubroutine (2:size,4:addr),0	; size     equ   0+4+0addr     equ   2+4+0         tsc         phd         tcd         lda   #0         sta   [addr]         ldx   addr         txy         iny         lda   size         dea         dea         phb         mvn   0,0         plb;;       creturn	;          lda   0+2         sta   0+6+2         lda   0+1         sta   0+6+1         pld         tsc         clc         adc   #0+6         tcs         rtl		ENDP		END