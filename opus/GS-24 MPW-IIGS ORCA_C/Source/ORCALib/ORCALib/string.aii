			case  on	seg   ''******************************************************************  String - String Processing Library**  This code implements the subroutines ;needed to support the*  standard C library STRING.**  December 1988*  Mike Westerfield**  Copyright 1988*  Byte Works, Inc.******************************************************************;-----------------------------------------------;;   Imported addresses;;-----------------------------------------------	IMPORT	sys_errlist;-----------------------------------------------;;   Forward addresses and entries;;-----------------------------------------------	ENTRY	strset******************************************************************  c2pCommon - common work buffer for c2pstr and p2cstr*******************************************************************c2pCommon privdatac2pCommon		PROC			ENTRY	str1str1		DS.B 258		ENDP******************************************************************  char *c2pstr(str)*        char *str;**  Inputs:*        str - pointer to the c string to convert**  Outputs:*        Returns a pointer to the p string.**  Notes:*        Any characters after the 255th ;are truncated without*        warning.******************************************************************		EXPORT	c2pstr   c2pstr   PROC	;using c2pCommonaddr     equ   1;;       csubroutine (4:str),4	; str      equ   0+4+4         tsc         sec         sbc   #4         tcs         phd         tcd         phb         phk         plb;;       short I,M         SEP   #1*32+1*16			LONGA OFF			LONGI OFF         ldy   #0lb1      lda   [str],Y         sta   str1+1,Y         beq   lb2         iny         bne   lb1         deylb2      sty   str1;;       long  I,M         REP   #1*32+1*16			LONGA ON			LONGI ON;;       lla   addr,str1	;          LDA   #str1         STA   addr         LDA   #^str1         STA   2+addr         plb;;       creturn 4:addr	;          ldx   addr+2         ldy   addr         lda   4+2         sta   4+4+2         lda   4+1         sta   4+4+1         pld         tsc         clc         adc   #4+4         tcs         tya         rtl		ENDP******************************************************************  makeset - create a set of characters**  This subroutine is called by strspn, ;strcspn, strpbrk and*  strrpbrk to create a set of characters.**  Inputs:*        set - pointer to the set of characters**  Outputs:*        strset - set of bytes; non-sero for chars in set*******************************************************************makeset  privatemakeset		PROCset      equ   8                        ;string set         lda   set                      ;if the set is null then         ora   set+2         beq   lb3                      ;  return         lda   #0                       ;clear the string set         sta   >strset         phb;;       move  strset,strset+1,#255	;          LDA   #255-1         LDX   #strset         LDY   #strset+1         MVN   strset,strset+1         plb;;       short I,M                      ;while there are chars in the set do         SEP   #1*32+1*16			LONGA OFF			LONGI OFF         ldy   #0lb1      lda   [set],Y         beq   lb2         tax                            ;  set the array element for this char         lda   #1         sta   >strset,X         iny                            ;endwhile         bne   lb1         inc   set+1         bne   lb1         inc   set+2         bra   lb1;;lb2    long  I,Mlb2      REP   #1*32+1*16			LONGA ON			LONGI ONlb3      rts		ENDP******************************************************************  memchr - find a byte in memory**  Returns a pointer to the byte in memory**  Inputs:*        ptr - first byte to search*        val - byte to search for*        len - # bytes to search**  Outputs:*        A,X - pointer to the byte; NULL for no match******************************************************************		EXPORT	memchr   memchr   PROCptr      equ   4                        ;pointer to the first byteval      equ   8                        ;byte to search forlen      equ   10                       ;# bytes to searchrtl      equ   1                        ;return address         tsc                            ;establish DP addressing         phd         tcd;;       short M         SEP   #1*32+0*16			LONGA OFF         ldy   #0         ldx   len+2                    ;scan 64K blocks         beq   lb1alb1      lda   [ptr],Y         cmp   val         beq   lb3         iny         bne   lb1         inc   ptr+2         dex         bpl   lb1lb1a     ldx   len         beq   lb2alb2      lda   [ptr],Y                  ;scan the remaining characters         cmp   val         beq   lb3         iny         dex         bne   lb2;;lb2a   long  M                        ;no match found -> return NULLlb2a     REP   #1*32+0*16			LONGA ON         ldx   #0         txy         bra   lb4;;lb3    long  M                        ;compute the lengthlb3      REP   #1*32+0*16			LONGA ON         tya         clc         adc   ptr         tay         ldx   ptr+2         bcc   lb4         inxlb4      lda   rtl+1                    ;remove parameters from the stack         sta   len+2         lda   rtl         sta   len+1         pld         tsc         clc         adc   #10         tcs         tya                            ;return the pointer in X-A         rtl		ENDP******************************************************************  memcmp - memory compare**  Compare *s1 to *s2.  If *s1 < *s2 then return -1; if they are*  equal, return 0; otherwise, return 1.**  Inputs:*        p1 - string to concatonate to*        p2 - string to concatonate**  Outputs:*        A - result******************************************************************		EXPORT	memcmp   memcmp   PROCp1       equ   4                        ;pointer to memory area 1p2       equ   8                        ;pointer to memory area 2len      equ   12                       ;length to comparertl      equ   1                        ;return address         tsc                            ;establish DP addressing         phd         tcd;;       short M         SEP   #1*32+0*16			LONGA OFF         ldy   #0                       ;scan 64K chunks         ldx   len+2         beq   lb2lb1      lda   [p1],Y         cmp   [p2],Y         bne   lb4         iny         bne   lb1         inc   p1+2         inc   p2+2         dex         bne   lb1lb2      ldx   len         beq   lb5lb3      lda   [p1],Y                   ;scan until the end of memory is reached         cmp   [p2],Y                   ; or a difference is found         bne   lb4         iny         dex         bne   lb3         ldx   #0                       ;memory matches         bra   lb5lb4      blt   less                     ;memory differs - set the result         ldx   #1         bra   lb5less     ldx   #-1;;lb5    long  Mlb5      REP   #1*32+0*16			LONGA ON         lda   rtl                      ;remove the parameters from the stack         sta   len+1         lda   rtl+1         sta   len+2         pld         tsc         clc         adc   #12         tcs         txa                            ;return the result         rtl		ENDP******************************************************************  memcpy - memory copy**  Copy len bytes from p1 to p2.**  Inputs:*        p1 - destination pointer*        p2 - source pointer*        len - # bytes to copy**  Outputs:*        X-A - p1**  Notes: The memory areas should not overlap******************************************************************		EXPORT	memcpy   memcpy   PROCp1       equ   4                        ;destination pointerp2       equ   8                        ;source pointerlen      equ   12                       ;length to comparertl      equ   1                        ;return address         tsc                            ;establish DP addressing         phd         tcd;;       ph4   p1                       ;save the dest pointer	;          LDA   p1+2         PHA         LDA   p1         PHA         lda   len                      ;if there are an odd # of bytes then         lsr   A         bcc   lb1;;       short M                        ;  move 1 byte now         SEP   #1*32+0*16			LONGA OFF         lda   [p2]         sta   [p1];;       long  M         REP   #1*32+0*16			LONGA ON         dec   len;;       inc4  p1;;       ~SETM	;          INC   p1         BNE   ~5         INC   2+p1;;~5     ~RESTM~5	; ;;       inc4  p2;;       ~SETM	;          INC   p2         BNE   ~8         INC   2+p2;;~8     ~RESTM~8	; lb1	; ;endif         ldx   len+2                    ;move full banks of memory         beq   lb1b         ldy   #0lb1a     lda   [p2],Y         sta   [p1],Y         dey         dey         bne   lb1a         inc   p2+2         inc   p1+2         dex         bne   lb1alb1b     ldy   len                      ;move len bytes         beq   lb4         dey         dey         beq   lb3lb2      lda   [p2],Y         sta   [p1],Y         dey         dey         bne   lb2lb3      lda   [p2]         sta   [p1]lb4      ply                            ;get the original source pointer         plx         lda   rtl                      ;remove the parameters from the stack         sta   len+1         lda   rtl+1         sta   len+2         pld         tsc         clc         adc   #12         tcs         tya                            ;return the result         rtl		ENDP******************************************************************  memmove - memory move**  Move len bytes from p1 to p2.**  Inputs:*        p1 - destination pointer*        p2 - source pointer*        len - # bytes to copy**  Outputs:*        X-A - p2**  Notes: The memory areas may overlap; ;the move will still work******************************************************************		EXPORT	memmove  memmove  PROCp1       equ   4                        ;destination pointerp2       equ   8                        ;source pointerlen      equ   12                       ;length to comparertl      equ   1                        ;return address         tsc                            ;establish DP addressing         phd         tcd;;       ph4   p1                       ;save the dest pointer	;          LDA   p1+2         PHA         LDA   p1         PHA         lda   p1+2                     ;if p1 < p2 then         cmp   p2+2         bne   lb1         lda   p1         cmp   p2lb1      bge   lb5;;       short M                        ;  move len bytes, starting with the 1st         SEP   #1*32+0*16			LONGA OFF         ldy   #0         ldx   len+2                    ;  move 64K chunks         beq   lb3lb2      lda   [p2],Y         sta   [p1],Y         iny         bne   lb2         inc   p2+2         inc   p1+2         dex         bne   lb2lb3      ldx   len                      ;  skip if there are no more bytes to         beq   lb11                     ;    movelb4      lda   [p2],Y                   ;  move the remaining bytes         sta   [p1],Y         iny         dex         bne   lb4         bra   lb11                     ;else			longa on;;lb5    add2  p1+2,len+2               ;  move len bytes, starting from the end;;lb5    ~SETMlb5	;          CLC;;       ~LDA  p1+2         LDA   p1+2;;       ~OP   ADC,len+2         ADC   len+2;;       ~STA  p1+2         STA   p1+2;;       ~RESTM	; ;;       add2  p2+2,len+2;;       ~SETM	;          CLC;;       ~LDA  p2+2         LDA   p2+2;;       ~OP   ADC,len+2         ADC   len+2;;       ~STA  p2+2         STA   p2+2;;       ~RESTM	; ;;       short M         SEP   #1*32+0*16			LONGA OFF         ldy   len                      ;  branch if there are no individual         beq   lb8                      ;    bytes to move         dey                            ;  move the individual bytes         beq   lb7lb6      lda   [p2],Y         sta   [p1],Y         dey         bne   lb6lb7      lda   [p2]         sta   [p1]lb8      ldx   len+2                    ;  branch if there are no 64K chunks to         beq   lb11                     ;    movelb9      dec   p1+2                     ;  move the 64K chunks         dec   p2+2         ldy   #$FFFFlb10     lda   [p2],Y         sta   [p1],Y         dey         bne   lb10         lda   [p2]         sta   [p1]         dex         bne   lb9;;lb11   long  Mlb11     REP   #1*32+0*16			LONGA ON         ply                            ;get the original source pointer         plx         lda   rtl                      ;remove the parameters from the stack         sta   len+1         lda   rtl+1         sta   len+2         pld         tsc         clc         adc   #12         tcs         tya                            ;return the result         rtl		ENDP******************************************************************  memset - set memory to a value**  Set len bytes, starting at p, to val.**  Inputs:*        p - destination pointer*        val - value (byte!) to set memory to*        len - # bytes to set**  Outputs:*        X-A - p**  Notes: The memory areas should not overlap******************************************************************		EXPORT	memset   memset   PROCp        equ   4                        ;destination pointerval      equ   8                        ;source pointerlen      equ   10                       ;length to comparertl      equ   1                        ;return address         tsc                            ;establish DP addressing         phd         tcd;;       ph4   p                        ;save the pointer	;          LDA   p+2         PHA         LDA   p         PHA         lda   val                      ;form a 2 byte value         xba         ora   val         sta   val         lda   len                      ;if there are an odd # of bytes then         lsr   A         bcc   lb1;;       short M                        ;  set 1 byte now         SEP   #1*32+0*16			LONGA OFF         lda   val         sta   [p];;       long  M         REP   #1*32+0*16			LONGA ON         dec   len;;       inc4  p;;       ~SETM	;          INC   p         BNE   ~5         INC   2+p;;~5     ~RESTM~5	; lb1	; ;endif         lda   val                      ;set len bytes         ldx   len+2                    ;set full banks         beq   lb1b         ldy   #0lb1a     sta   [p],Y         dey         dey         bne   lb1a         inc   p+2         dex         bne   lb1alb1b     ldy   len                      ;set a partial bank         beq   lb4         dey         dey         beq   lb3lb2      sta   [p],Y         dey         dey         bne   lb2lb3      sta   [p]lb4      ply                            ;get the original source pointer         plx         lda   rtl                      ;remove the parameters from the stack         sta   len+1         lda   rtl+1         sta   len+2         pld         tsc         clc         adc   #10         tcs         tya                            ;return the result         rtl		ENDP******************************************************************  char *p2cstr(str)*        char *str;**  Inputs:*        str - pointer to the p string to convert**  Outputs:*        Returns a pointer to the c string.******************************************************************		EXPORT	p2cstr   p2cstr   PROC	;using c2pCommonaddr     equ   1;;       csubroutine (4:str),4	; str      equ   0+4+4         tsc         sec         sbc   #4         tcs         phd         tcd         phb         phk         plb;;       short I,M         SEP   #1*32+1*16			LONGA OFF			LONGI OFF         lda   [str]         tay         lda   #0         sta   str1,Y         tyx         beq   lb2lb1      lda   [str],Y         sta   str1-1,Y         dey         bne   lb1;;lb2    long  I,Mlb2      REP   #1*32+1*16			LONGA ON			LONGI ON;;       lla   addr,str1	;          LDA   #str1         STA   addr         LDA   #^str1         STA   2+addr         plb;;       creturn 4:addr	;          ldx   addr+2         ldy   addr         lda   4+2         sta   4+4+2         lda   4+1         sta   4+4+1         pld         tsc         clc         adc   #4+4         tcs         tya         rtl		ENDP******************************************************************  strcat - string concatonation**  Place *s2 at the end of *s1, returning a pointer to *s1.  No*  checking for length is performed.**  Inputs:*        s1 - string to concatonate to*        s2 - string to concatonate**  Outputs:*        X-A - pointer to the result (s1)******************************************************************		EXPORT	strcat   strcat   PROCs1       equ   8                        ;pointer to string 1s2       equ   12                       ;pointer to string 2rtl      equ   5                        ;return addressrval     equ   1                        ;string value to return         lda   6,S                      ;save the starting value of s1         pha         lda   6,S         pha         tsc                            ;establish DP addressing         phd         tcd         ldy   #0                       ;advance s1 to point to the terminating;;       short M                        ; null         SEP   #1*32+0*16			LONGA OFFlb1      lda   [s1],Y         beq   lb2         iny         bne   lb1         inc   s1+2         bra   lb1;;lb2    long  Mlb2      REP   #1*32+0*16			LONGA ON         tya         clc         adc   s1         sta   s1;;       short M                        ;copy characters 'til the null is found         SEP   #1*32+0*16			LONGA OFF         ldy   #0lb3      lda   [s2],Y         sta   [s1],Y         beq   lb4         iny         bne   lb3         inc   s1+2         inc   s2+2         bra   lb3;;lb4    long  M                        ;return to the callerlb4      REP   #1*32+0*16			LONGA ON         lda   rtl         sta   s2+1         lda   rtl+1         sta   s2+2         ldx   rval+2         ldy   rval         pld         tsc         clc         adc   #12         tcs         tya         rtl		ENDP******************************************************************  strchr - find a character in a string**  Returns a pointer to the character in the string**  Inputs:*        str - string to search*        c - character to search for**  Outputs:*        A,X - pointer to the character; NULL for no match******************************************************************		EXPORT	strchr   strchr   PROCstr      equ   4                        ;pointer to the stringc        equ   8                        ;character         tsc                            ;establish DP addressing         phd         tcd;;       short M                        ;advance s1 to point to the char         SEP   #1*32+0*16			LONGA OFF         ldy   #0lb1      lda   [str],Y         cmp   c         beq   lb3         cmp   #0         beq   lb2         iny         bne   lb1         inc   str+2         bra   lb1;;lb2    long  M                        ;no match found -> return NULLlb2      REP   #1*32+0*16			LONGA ON         ldy   #0         tyx         bra   lb4;;lb3    long  M                        ;compute the lengthlb3      REP   #1*32+0*16			LONGA ON         tya         clc         adc   str         tay         ldx   str+2         bcc   lb4         inxlb4      pld                            ;remove parameters from the stack         lda   2,S         sta   8,S         pla         sta   5,S         pla         pla         tya                            ;return the pointer in X-A         rtl		ENDP******************************************************************  strcmp - string compare**  Compare *s1 to *s2.  If *s1 < *s2 then return -1; if they are*  equal, return 0; otherwise, return 1.**  Inputs:*        s1 - first string ptr*        s2 - second string ptr**  Outputs:*        A - result******************************************************************		EXPORT	strcmp   strcmp   PROCs1       equ   4                        ;pointer to string 1s2       equ   8                        ;pointer to string 2rtl      equ   1                        ;return address         tsc                            ;establish DP addressing         phd         tcd         ldy   #0                       ;scan until the end of string is reached;;       short M                        ; or a difference is found         SEP   #1*32+0*16			LONGA OFFlb1      lda   [s1],Y         beq   lb2         cmp   [s2],Y         bne   lb3         iny         bne   lb1         inc   s1+2         inc   s2+2         bra   lb1lb2      ldx   #0                       ;s1 is finished.  If s2 is, too, the         lda   [s2],Y                   ; strings are equal.         beq   lb4less     ldx   #-1                      ;It wasn't, so *s1 < *s2         bra   lb4lb3      blt   less                     ;the strings differ - set the result         ldx   #1;;lb4    long  Mlb4      REP   #1*32+0*16			LONGA ON         lda   rtl                      ;remove the parameters from the stack         sta   s2+1         lda   rtl+1         sta   s2+2         pld         tsc         clc         adc   #8         tcs         txa                            ;return the result         rtl		ENDP******************************************************************  strcpy - string copy**  Copy string *s2 to string *s1.  Return a pointer to s1.**  Inputs:*        s1 - string to copy to*        s2 - string to copy**  Outputs:*        X-A - pointer to the result (s1)******************************************************************		EXPORT	strcpy   strcpy   PROCs1       equ   8                        ;pointer to string 1s2       equ   12                       ;pointer to string 2rtl      equ   5                        ;return addressrval     equ   1                        ;string value to return         lda   6,S                      ;save the starting value of s1         pha         lda   6,S         pha         tsc                            ;establish DP addressing         phd         tcd;;       short M                        ;copy characters 'til the null is found         SEP   #1*32+0*16			LONGA OFF         ldy   #0lb1      lda   [s2],Y         sta   [s1],Y         beq   lb2         iny         bne   lb1         inc   s1+2         inc   s2+2         bra   lb1;;lb2    long  M                        ;return to the callerlb2      REP   #1*32+0*16			LONGA ON         lda   rtl         sta   s2+1         lda   rtl+1         sta   s2+2         ldx   rval+2         ldy   rval         pld         tsc         clc         adc   #12         tcs         tya         rtl		ENDP******************************************************************  strcspn - find the first char in str in set**  Inputs:*        str - pointer to the string to scan*        set - set of characters to check against**  Outputs:*        A - disp to first char in str******************************************************************		EXPORT	strcspn  strcspn  PROCstr      equ   4                        ;string to scanset      equ   8                        ;set of charactersrtl      equ   1                        ;return address         tsc                            ;establish DP addressing         phd         tcd         jsr   makeset                  ;form the set of characters         stz   set                      ;set initial displacement         stz   set+2;;       short I,M                      ;scan for a matching char         SEP   #1*32+1*16			LONGA OFF			LONGI OFF         ldy   #0lb1      lda   [str],Y         beq   lb2         tax         lda   >strset,X         bne   lb2         iny         bne   lb1;;       long  M         REP   #1*32+0*16			LONGA ON         inc   str+1         inc   set+1;;       short M         SEP   #1*32+0*16			LONGA OFF         bra   lb1lb2      sty   set                      ;set the disp past the current disp;;       long  I,M         REP   #1*32+1*16			LONGA ON			LONGI ON         ldx   set+2                    ;get the return value         ldy   set         lda   rtl+1                    ;remove the parameters         sta   set+2         lda   rtl         sta   set+1         pld         tsc         clc         adc   #8         tcs         tya                            ;return the disp         rtl		ENDP******************************************************************  strerror - return the addr of an error message**  Inputs:*        err - error number to return the error for******************************************************************		EXPORT	strerror strerror PROC         phb                            ;get the error number         plx         ply         pla         phy         phx         phk                            ;use local data bank         plb         asl   A                        ;compute the index         asl   A         tay         ldx   sys_errlist+2,Y          ;load the address         lda   sys_errlist,Y         plb                            ;restore caller's data bank         rtl		ENDP******************************************************************  strlen - find the length of a string**  Returns the length of the string.**  Inputs:*        str - string to find the length of**  Outputs:*        X-A - length of the string******************************************************************		EXPORT	strlen   strlen   PROCstr      equ   4                        ;pointer to the string         tsc                            ;establish DP addressing         phd         tcd         ldy   #0                       ;advance s1 to point to the terminating         ldx   #0                       ; null;;       short M         SEP   #1*32+0*16			LONGA OFFlb1      lda   [str],Y         beq   lb2         iny         bne   lb1         inx         inc   str+2         bra   lb1;;lb2    long  Mlb2      REP   #1*32+0*16			LONGA ON         pld                            ;remove str from the stack         lda   2,S         sta   6,S         pla         sta   3,S         pla         tya                            ;return the length         rtl		ENDP******************************************************************  strncat - string concatonation with max length**  Place *s2 at the end of *s1, returning a pointer to *s1.  No*  checking for length is performed.**  Inputs:*        s1 - string to concatonate to*        s2 - string to concatonate*        n - max # chars to copy**  Outputs:*        X-A - pointer to the result (s1)******************************************************************		EXPORT	strncat  strncat  PROCrval     equ   1                        ;string value to return;;       csubroutine (4:s1,4:s2,4:n),4	; s1       equ   0+4+4s2       equ   4+4+4n        equ   8+4+4         tsc         sec         sbc   #4         tcs         phd         tcd;;       move4 s1,rval                  ;save the address to return;;       ~SETM	;          LDA   2+s1         STA   2+rval         LDA   s1         STA   rval;;       ~RESTM	;          ldy   #0                       ;advance s1 to point to the terminating;;       short M                        ; null         SEP   #1*32+0*16			LONGA OFFlb1      lda   [s1],Y         beq   lb2         iny         bne   lb1         inc   s1+2         bra   lb1;;lb2    long  Mlb2      REP   #1*32+0*16			LONGA ON         tya         clc         adc   s1         sta   s1;;       short M                        ;copy characters 'til the null is found         SEP   #1*32+0*16			LONGA OFF         ldy   #0         ldx   n         beq   lb4         bmi   lb4lb3      lda   [s2],Y         sta   [s1],Y         beq   lb4         iny         dex         bne   lb3         lda   n+2         beq   lb4         dec   n+2         bra   lb3lb4      lda   #0                       ;write the terminating null         sta   [s1],Y;;       long  M                        ;return to the caller         REP   #1*32+0*16			LONGA ON;;       creturn 4:rval	;          ldx   rval+2         ldy   rval         lda   4+2         sta   4+12+2         lda   4+1         sta   4+12+1         pld         tsc         clc         adc   #4+12         tcs         tya         rtl		ENDP******************************************************************  strncmp - string compare; max length ;of n**  Compare *s1 to *s2.  If *s1 < *s2 then return -1; if they are*  equal, return 0; otherwise, return 1.**  Inputs:*        s1 - string to concatonate to*        s2 - string to concatonate*        n - max length of the strings**  Outputs:*        A - result******************************************************************		EXPORT	strncmp  strncmp  PROCflag     equ   1                        ;return flag;;       csubroutine (4:s1,4:s2,4:n),2	; s1       equ   0+4+2s2       equ   4+4+2n        equ   8+4+2         tsc         sec         sbc   #2         tcs         phd         tcd         ldy   #0                       ;scan until the end of string is reached         ldx   n+2                      ; or a difference is found         bmi   equal         bne   lb0         ldx   n         beq   equallb0      ldx   n;;       short M         SEP   #1*32+0*16			LONGA OFFlb1      lda   [s1],Y         beq   lb2         cmp   [s2],Y         bne   lb3         dex         bne   lb1a         lda   n+2         beq   equal         dec   n+2lb1a     iny         bne   lb1         inc   s1+2         inc   s2+2         bra   lb1lb2      ldx   #0                       ;s1 is finished.  If s2 is, too, the         lda   [s2],Y                   ; strings are equal.         beq   lb4less     ldx   #-1                      ;It wasn't, so *s1 < *s2         bra   lb4equal    ldx   #0         bra   lb4lb3      blt   less                     ;the strings differ - set the result         ldx   #1lb4      stx   flag                     ;return the result;;       long  M         REP   #1*32+0*16			LONGA ON;;       creturn 2:flag	;          ldy   flag         lda   2+2         sta   2+12+2         lda   2+1         sta   2+12+1         pld         tsc         clc         adc   #2+12         tcs         tya         rtl		ENDP******************************************************************  strncpy - string copy; max length of ;n**  Copy string *s2 to string *s1.  Return a pointer to s1.**  Inputs:*        s1 - string to copy to*        s2 - string to copy*        n - max length of the string**  Outputs:*        X-A - pointer to the result (s1)******************************************************************		EXPORT	strncpy  strncpy  PROCrval     equ   1                        ;string value to return;;       csubroutine (4:s1,4:s2,4:n),4	; s1       equ   0+4+4s2       equ   4+4+4n        equ   8+4+4         tsc         sec         sbc   #4         tcs         phd         tcd;;       move4 s1,rval                  ;save the address to return;;       ~SETM	;          LDA   2+s1         STA   2+rval         LDA   s1         STA   rval;;       ~RESTM	; ;;       short M                        ;copy characters 'til the null is found         SEP   #1*32+0*16			LONGA OFF         ldy   #0                       ; or we have copied n characters         ldx   n+2         bmi   lb4         bne   lb0         ldx   n         beq   lb4lb0      ldx   nlb1      lda   [s2],Y         sta   [s1],Y         beq   lb2         dex         bne   lb1a         lda   n+2         beq   lb4         dec   n+2lb1a     iny         bne   lb1         inc   s1+2         inc   s2+2         bra   lb1lb3      iny                            ;null terminate the string         sta   [s1],Ylb2      dex         bne   lb3;;lb4    long  M                        ;return to the callerlb4      REP   #1*32+0*16			LONGA ON;;       creturn 4:rval	;          ldx   rval+2         ldy   rval         lda   4+2         sta   4+12+2         lda   4+1         sta   4+12+1         pld         tsc         clc         adc   #4+12         tcs         tya         rtl		ENDP******************************************************************  strpbrk - find the first char in str in set**  Inputs:*        str - pointer to the string to scan*        set - set of characters to check against**  Outputs:*        X-A - pointer to first char in str; NULL if none found******************************************************************		EXPORT	strpbrk  strpbrk  PROCstr      equ   4                        ;string to scanset      equ   8                        ;set of charactersrtl      equ   1                        ;return address         tsc                            ;establish DP addressing         phd         tcd         jsr   makeset                  ;form the set of characters;;       short I,M                      ;scan for a matching char         SEP   #1*32+1*16			LONGA OFF			LONGI OFF         ldy   #0lb1      lda   [str],Y         beq   lb2         tax         lda   >strset,X         bne   lb3         iny         bne   lb1;;       long  M         REP   #1*32+0*16			LONGA ON         inc   str+1;;       short M         SEP   #1*32+0*16			LONGA OFF         bra   lb1;;lb2    long  I,M                      ;no match found -> return NULLlb2      REP   #1*32+1*16			LONGA ON			LONGI ON         ldx   #0         txy         bra   lb4;;lb3    long  I,M                      ;increment str by Y and load the valuelb3      REP   #1*32+1*16			LONGA ON			LONGI ON         tya         and   #$00FF         clc         adc   str         tay         lda   str+2         adc   #0         taxlb4      lda   rtl+1                    ;remove the parameters         sta   set+2         lda   rtl         sta   set+1         pld         tsc         clc         adc   #8         tcs         tya                            ;return the ptr         rtl		ENDP******************************************************************  strpos - find a character in a string**  Returns the position of a character in a string**  Inputs:*        str - string to search*        c - character to search for**  Outputs:*        A - position of the character; ;-1 of none******************************************************************		EXPORT	strpos   strpos   PROCstr      equ   4                        ;pointer to the stringc        equ   8                        ;character         tsc                            ;establish DP addressing         phd         tcd         ldy   #0                       ;advance s1 to point to the char;;       short M         SEP   #1*32+0*16			LONGA OFFlb1      lda   [str],Y         cmp   c         beq   lb3         cmp   #0         beq   lb2         iny         bpl   lb1lb2      ldy   #-1                      ;no match found -> return -1;;lb3    long  Mlb3      REP   #1*32+0*16			LONGA ON         pld                            ;remove parameters from the stack         lda   2,S         sta   8,S         pla         sta   5,S         pla         pla         tya                            ;return the result         rtl		ENDP******************************************************************  strrchr - find the last occurrance of a character in a string**  Returns a pointer to the last occurrance of the character**  Inputs:*        str - string to search*        c - character to search for**  Outputs:*        A,X - pointer to the character; NULL for no match******************************************************************		EXPORT	strrchr  strrchr  PROCstr      equ   8                        ;pointer to the stringc        equ   12                       ;characterptr      equ   1                        ;result pointer         pea   0                        ;initialize the result         pea   0         tsc                            ;establish DP addressing         phd         tcd;;       short M                        ;advance s1 to point to the char         SEP   #1*32+0*16			LONGA OFF         ldy   #0lb1      lda   [str],Y         cmp   c         beq   lb3         cmp   #0         beq   lb4lb2      iny         bne   lb1         inc   str+2         bra   lb1;;lb3    long  M                        ;compute the pointerlb3      REP   #1*32+0*16			LONGA ON         tya         clc         adc   str         sta   ptr         lda   str+2         adc   #0         sta   ptr+2         sep   #$20         lda   [str],Y         bne   lb2;;lb4    long  Mlb4      REP   #1*32+0*16			LONGA ON         pld                            ;rest DP         ply                            ;remove the return value         plx         lda   2,S                      ;remove the parameters         sta   8,S         pla         sta   5,S         pla         pla         tya                            ;return the pointer in X-A         rtl		ENDP******************************************************************  strrpos - find the last occurrance of a character in a string**  Returns the position of the las occurrance of the character**  Inputs:*        str - string to search*        c - character to search for**  Outputs:*        A - position of the character; ;-1 of none******************************************************************		EXPORT	strrpos  strrpos  PROCstr      equ   4                        ;pointer to the stringc        equ   8                        ;character         tsc                            ;establish DP addressing         phd         tcd         ldx   #-1                      ;assume we won't find it         ldy   #0                       ;advance s1 to point to the char;;       short M         SEP   #1*32+0*16			LONGA OFFlb1      lda   [str],Y         cmp   c         bne   lb2         tyxlb2      cmp   #0         beq   lb3         iny         bpl   lb1;;lb3    long  Mlb3      REP   #1*32+0*16			LONGA ON         pld                            ;remove parameters from the stack         lda   2,S         sta   8,S         pla         sta   5,S         pla         pla         txa                            ;return the result         rtl		ENDP******************************************************************  strrpbrk - find the first char in str in set**  Inputs:*        str - pointer to the string to scan*        set - set of characters to check against**  Outputs:*        X-A - pointer to first char in str; NULL if none found******************************************************************		EXPORT	strrpbrk strrpbrk PROCstr      equ   4                        ;string to scanset      equ   8                        ;set of charactersrtl      equ   1                        ;return address         tsc                            ;establish DP addressing         phd         tcd         jsr   makeset                  ;form the set of characters         stz   set                      ;assume no match will be found         stz   set+2;;       short I,M                      ;scan for a matching char         SEP   #1*32+1*16			LONGA OFF			LONGI OFF         ldy   #0lb1      lda   [str],Y         beq   lb4         tax         lda   >strset,X         bne   lb3lb2      iny         bne   lb1;;       long  M         REP   #1*32+0*16			LONGA ON         inc   str+1;;       short M         SEP   #1*32+0*16			LONGA OFF         bra   lb1;;lb3    long  I,M                      ;set the address of the match foundlb3      REP   #1*32+1*16			LONGA ON			LONGI ON         tya         and   #$00FF         clc         adc   str         sta   set         lda   str+2         adc   #0         sta   set+2;;       short I,M         SEP   #1*32+1*16			LONGA OFF			LONGI OFF         bra   lb2;;lb4    long  I,Mlb4      REP   #1*32+1*16			LONGA ON			LONGI ON         ldy   set                      ;get the address         ldx   set+2         lda   rtl+1                    ;remove the parameters         sta   set+2         lda   rtl         sta   set+1         pld         tsc         clc         adc   #8         tcs         tya                            ;return the ptr         rtl		ENDP******************************************************************  strset - work area for string operations*******************************************************************strset   privatestrset		PROC		DS.B 256		ENDP******************************************************************  strspn - find the first char in str not in set**  Inputs:*        str - pointer to the string to scan*        set - set of characters to check against**  Outputs:*        A - disp to first char not in str******************************************************************		EXPORT	strspn   strspn   PROCstr      equ   4                        ;string to scanset      equ   8                        ;set of charactersrtl      equ   1                        ;return address         tsc                            ;establish DP addressing         phd         tcd         jsr   makeset                  ;form the set of characters         stz   set                      ;set initial displacement         stz   set+2;;       short I,M                      ;scan for a non-matching char         SEP   #1*32+1*16			LONGA OFF			LONGI OFF         ldy   #0lb1      lda   [str],Y         beq   lb2         tax         lda   >strset,X         beq   lb2         iny         bne   lb1;;       long  M         REP   #1*32+0*16			LONGA ON         inc   str+1         inc   set+1;;       short M         SEP   #1*32+0*16			LONGA OFF         bra   lb1lb2      sty   set                      ;set the disp past the current disp;;       long  I,M         REP   #1*32+1*16			LONGA ON			LONGI ON         ldx   set+2                    ;get the return value         ldy   set         lda   rtl+1                    ;remove the parameters         sta   set+2         lda   rtl         sta   set+1         pld         tsc         clc         adc   #8         tcs         tya                            ;return the disp         rtl		ENDP******************************************************************  strstr - string search**  Inputs:*        src - string to search*        sub - string to search for**  Outputs:*        X-A - pointer to the string; NULL if not found******************************************************************		EXPORT	strstr   strstr   PROClen      equ   1                        ;length of remaining string - strlen(sub)lensub   equ   5                        ;strlen(sub)p1       equ   9                        ;temp pointerp2       equ   13cnt      equ   17                       ;temp counternum1     equ   21                       ;temp numberworkLen  equ   24                       ;length of work spacesrc      equ   workLen+4                ;string to scansub      equ   workLen+8                ;string to search forrtl      equ   workLen+1                ;return address;;  Set up our local variables;         tsc                            ;create work space         sec         sbc   #workLen         tcs         tsc                            ;establish DP addressing         phd         tcd         phb                            ;use local data areas         phk         plb;;  Calculate the max # chars we can search;         lda   sub                      ;if the search string is null, return null         ora   sub+2         beq   fl0         lda   src                      ;if the string to search is null,         ora   src+2                    ; return null         beq   fl0;;       ph4   sub                      ;get the length of the search string	;          LDA   sub+2         PHA         LDA   sub         PHA         jsl   strlen         stx   strset+2         sta   strset         stx   lensub+2         sta   lensub;;       ph4   src                      ;get the length of the string to search	;          LDA   src+2         PHA         LDA   src         PHA         jsl   strlen         sec                            ;subtract off the length of the search         sbc   lensub                   ; string         sta   len         txa         sbc   lensub+2         sta   len+2         bpl   fl1                      ;if there aren't enough chars for a matchfl0      stz   src         stz   src+2                    ;  then return NULL         brl   rt1fl1	; ;;  Set up the displacement array (used to see how far we can shift);         lda   strset+1                 ;if strlen(sub) > 255 then         ora   strset+2                 ;  use 255 for the max move         beq   ds1         lda   #255         sta   strset;;ds1    move  strset,strset+1,#255     ;init all char disps to strlen(sub)ds1	;          LDA   #255-1         LDX   #strset         LDY   #strset+1         MVN   strset,strset+1         lda   strset                   ;skip if the length is 1         and   #$00FF         dec   A         beq   ds5         stz   cnt                      ;no chars processed so far         stz   cnt+2;;       move4 sub,p1                   ;for each char but the last do;;       ~SETM	;          LDA   2+sub         STA   2+p1         LDA   sub         STA   p1;;       ~RESTM	; ds3      lda   [p1]                     ;  branch if this is the last char         and   #$FF00         beq   ds5;;       sub4  lensub,cnt,num1          ;  compute strlen(sub) - cnt - 1;;       ~SETM	;          SEC;;       ~LDA  lensub         LDA   lensub;;       ~OP   SBC,cnt         SBC   cnt;;       ~STA  num1         STA   num1;;       ~LDA.H lensub	;          LDA   2+lensub;;       ~OP.H SBC,cnt	;          SBC   2+cnt;;       ~STA.H num1	;          STA   2+num1;;       ~RESTM	; ;;       dec4  num1;;       ~SETM	;          LDA   num1         BNE   ~17         DEC   2+num1~17      DEC   num1;;       ~RESTM	;          lda   num1+1         ora   num1+2         bne   ds4                      ;  if the result is <= 255 then;;       short I,M                      ;    set the char index         SEP   #1*32+1*16			LONGA OFF			LONGI OFF         lda   [p1]         tax         lda   num1         sta   strset,X;;       long  I,M         REP   #1*32+1*16			LONGA ON			LONGI ON;;ds4    inc4  cnt                      ;next char;;ds4    ~SETMds4	;          INC   cnt         BNE   ~22         INC   2+cnt;;~22    ~RESTM~22	; ;;       inc4  p1;;       ~SETM	;          INC   p1         BNE   ~25         INC   2+p1;;~25    ~RESTM~25	;          bra   ds3ds5	; ;;  Search for the string;ss0      lda   lensub                   ;if the length of the sreach string is         and   #$8000                   ;  > 32767 then use a long method         ora   lensub+2         beq   ss3;;       add4  lensub,src,p1            ; set the pointer to the end of the;;       ~SETM	;          CLC;;       ~LDA  lensub         LDA   lensub;;       ~OP   ADC,src         ADC   src;;       ~STA  p1         STA   p1;;       ~LDA.H lensub	;          LDA   2+lensub;;       ~OP.H ADC,src	;          ADC   2+src;;       ~STA.H p1	;          STA   2+p1;;       ~RESTM	; ;;       dec4  p1                       ;  string to search;;       ~SETM	;          LDA   p1         BNE   ~37         DEC   2+p1~37      DEC   p1;;       ~RESTM	; ;;       add4  lensub,sub,p2            ; set the pointer to the end of the;;       ~SETM	;          CLC;;       ~LDA  lensub         LDA   lensub;;       ~OP   ADC,sub         ADC   sub;;       ~STA  p2         STA   p2;;       ~LDA.H lensub	;          LDA   2+lensub;;       ~OP.H ADC,sub	;          ADC   2+sub;;       ~STA.H p2	;          STA   2+p2;;       ~RESTM	; ;;       dec4  p2                       ;  search string;;       ~SETM	;          LDA   p2         BNE   ~49         DEC   2+p2~49      DEC   p2;;       ~RESTM	; ;;       move4 lensub,cnt               ; set the # chars to check;;       ~SETM	;          LDA   2+lensub         STA   2+cnt         LDA   lensub         STA   cnt;;       ~RESTM	; ss1      lda   [p1]                     ; branch if the characters do not match         eor   [p2]         and   #$00FF         bne   ss2;;       dec4  p1                       ; match - next char;;       ~SETM	;          LDA   p1         BNE   ~55         DEC   2+p1~55      DEC   p1;;       ~RESTM	; ;;       dec4  p2;;       ~SETM	;          LDA   p2         BNE   ~58         DEC   2+p2~58      DEC   p2;;       ~RESTM	; ;;       dec4  cnt;;       ~SETM	;          LDA   cnt         BNE   ~61         DEC   2+cnt~61      DEC   cnt;;       ~RESTM	;          lda   cnt         ora   cnt+2         bne   ss1         bra   rt1                      ; match - return the pointer;;ss2    add4  lensub,src,p1            ; no match - find the skip length;;ss2    ~SETMss2	;          CLC;;       ~LDA  lensub         LDA   lensub;;       ~OP   ADC,src         ADC   src;;       ~STA  p1         STA   p1;;       ~LDA.H lensub	;          LDA   2+lensub;;       ~OP.H ADC,src	;          ADC   2+src;;       ~STA.H p1	;          STA   2+p1;;       ~RESTM	; ;;       dec4  p1;;       ~SETM	;          LDA   p1         BNE   ~73         DEC   2+p1~73      DEC   p1;;       ~RESTM	;          lda   [p1]         bra   ss6                      ; go to common handling for no matchss3      ldy   lensub                   ;strlen(sub) < 32K, so use fast search         dey;;       short M         SEP   #1*32+0*16			LONGA OFFss4      lda   [src],Y         cmp   [sub],Y         bne   ss5         dey         bpl   ss4;;       long  M                        ; match - return the pointer         REP   #1*32+0*16			LONGA ON         bra   rt1;;ss5    long  M                        ; no match - find the skip lengthss5      REP   #1*32+0*16			LONGA ON         ldy   lensub         dey         lda   [src],Yss6      and   #$00FF         tax         lda   strset,X         and   #$00FF         sta   cnt                      ;update the source string pointer         clc         adc   src         sta   src         bcc   ss7         inc   src+2ss7      sec                            ;update the # of chars left         lda   len         sbc   cnt         sta   len         lda   len+2         sbc   #0         sta   len+2;;       jcs   ss0                      ;go try for another match         BCC   *+5         BRL   ss0         stz   src                      ;no match - return NULL         stz   src+2;;  Return to the caller;rt1      ldx   src+2                    ;get the return value         ldy   src         lda   rtl+1                    ;remove the parameters         sta   sub+2         lda   rtl         sta   sub+1         plb         pld         tsc         clc         adc   #8+workLen         tcs         tya                            ;return the disp         rtl		ENDP******************************************************************  strtok - find a token**  Inputs:*        str - pointer to the string to scan*        set - set of characters to check against**  Outputs:*        X-A - pointer to the token; NULL if none******************************************************************		EXPORT	strtok   strtok   PROCstr      equ   4                        ;string to scanset      equ   8                        ;set of charactersrtl      equ   1                        ;return address         tsc                            ;establish DP addressing         phd         tcd         phb                            ;use our local direct page         phk         plb         jsr   makeset                  ;form the set of characters         lda   str                      ;if str is not NULL then         ora   str+2         beq   lb3;;       short I,M                      ;  scan for a non-matching char         SEP   #1*32+1*16			LONGA OFF			LONGI OFF         ldy   str         stz   strlb1      lda   [str],Y         tax         lda   strset,X         beq   lb2         iny         bne   lb1;;       long  M         REP   #1*32+0*16			LONGA ON         inc   str+1;;       short M         SEP   #1*32+0*16			LONGA OFF         bra   lb1lb2      sty   str                      ;  set the disp past the current disp;;       long  I,M         REP   #1*32+1*16			LONGA ON			LONGI ON         bra   lb4                      ;elselb3      lda   isp                      ;  str := internal state pointer         ldx   isp+2         sta   str         stx   str+2lb4	; ;endif         lda   [str]                    ;if we are at the end of the string then         and   #$00FF         bne   lb5         stz   set                      ;  return NULL         stz   set+2         stz   isp                      ;  set the isp to NULL         stz   isp+2         bra   lb10                     ;elselb5      lda   [str]                    ;  scan to the 1st char not in the set         and   #$00FF         beq   lb8a         tax         lda   strset,X         and   #$00FF         beq   lb6;;       inc4  str;;       ~SETM	;          INC   str         BNE   ~6         INC   2+str;;~6     ~RESTM~6	;          bra   lb5lb6      lda   str                      ;  return a ptr to the string         sta   set         lda   str+2         sta   set+2lb7      lda   [str]                    ;  scan to the 1st char in the set         and   #$00FF         beq   lb8a         tax         lda   strset,X         and   #$00FF         bne   lb8;;       inc4  str;;       ~SETM	;          INC   str         BNE   ~9         INC   2+str;;~9     ~RESTM~9	;          bra   lb7;;lb8    short M                        ;  if a match was found thenlb8      SEP   #1*32+0*16			LONGA OFF         lda   #0                       ;    null terminate the token         sta   [str];;       long  I,M                      ;    set isp to the char past the token         REP   #1*32+1*16			LONGA ON			LONGI ON;;       add4  str,#1,isp;;       ~SETM	;          CLC;;       ~LDA  str         LDA   str;;       ~OP   ADC,#1         ADC   #1;;       ~STA  isp         STA   isp;;       ~LDA.H str	;          LDA   2+str;;       ~OP.H ADC,#1	;          ADC   #^1;;       ~STA.H isp	;          STA   2+isp;;       ~RESTM	;          bra   lb9;;lb8a   long  I,M                      ;  elselb8a     REP   #1*32+1*16			LONGA ON			LONGI ON         stz   isp                      ;    set isp to NULL         stz   isp+2lb9	; ;  endiflb10     ldx   set+2                    ;get the return value         ldy   set         lda   rtl+1                    ;remove the parameters         sta   set+2         lda   rtl         sta   set+1         plb         pld         tsc         clc         adc   #8         tcs         tya                            ;return the disp         rtlisp		DS.B 4                        ;internal state pointer (isp)		ENDP		END