			case  on	seg   ''******************************************************************  fcntl - UNIX primitive input/output facilities**  This code implements the tables and subroutines needed to*  support a subset of the UNIX library ;FCNTL.**  October 1989*  Mike Westerfield**  Copyright 1989*  Byte Works, Inc.******************************************************************;-----------------------------------------------;;   Imported addresses;;-----------------------------------------------	IMPORT	errno	IMPORT	free	IMPORT	malloc;-----------------------------------------------;;   Forward addresses and entries;;-----------------------------------------------	ENTRY	fcntl	ENTRY	files	ENTRY	openfile	ENTRY	unixtoprodos;        copy  equates.asm******************************************************************  This file contains constant values defined in the C interfaces*  that are also used in the assembly language portion of the*  libraries.*****************************************************************;;  error numbers;EDOM     equ   1                        ;domain errorERANGE   equ   2                        ;# too large, too small, or illegalENOMEM   equ   3                        ;Not enough memoryENOENT   equ   4                        ;No such file or directoryEIO      equ   5                        ;I/O errorEINVAL   equ   6                        ;Invalid argumentEBADF    equ   7                        ;bad file descriptorEMFILE   equ   8                        ;too many files are openEACCES   equ   9                        ;access bits prevent the operationEEXIST   equ   10                       ;the file existsENOSPC   equ   11                       ;the file is too large;;  masks for the __ctype array;_digit   equ   $01                      ;['0'..'9']_upper   equ   $02                      ;['A'..'Z']_lower   equ   $04                      ;['a'..'z']_control equ   $08                      ;[chr(0)..chr(31),chr(127)]_punctuation equ  $10                   ;[' ','!'..'/',':'..'@','['..'`','{'..'~']_space   equ   $20                      ;[chr(9)..chr(13),' ']_hex     equ   $40                      ;['0'..'9','a'..'f','A'..'F']_print   equ   $80                      ;[' '..'~'];;  masks for the __ctype2 array;_csym    equ   $01                      ;['0'..'9','A'..'Z','a'..'z','_']_csymf   equ   $02                      ;['A'..'Z','a'..'z'.'_']_octal   equ   $04                      ;['0'..'7'];;  signal numbers;SIGABRT  equ   1SIGFPE   equ   2SIGILL   equ   3SIGINT   equ   4SIGSEGV  equ   5SIGTERM  equ   6;;  The FILE record;*                                       ;flags*                                       ;-----_IOFBF   equ   $0001                    ;full buffering_IONBF   equ   $0002                    ;no buffering_IOLBF   equ   $0004                    ;flush when a \n is written_IOREAD  equ   $0008                    ;currently reading_IOWRT   equ   $0010                    ;currently writing_IORW    equ   $0020                    ;read/write enabled_IOMYBUF equ   $0040                    ;buffer was allocated by stdio_IOEOF   equ   $0080                    ;has an EOF been found?_IOERR   equ   $0100                    ;has an error occurred?_IOTEXT  equ   $0200                    ;is this file a text file?_IOTEMPFILE equ  $0400                  ;was this file created by tmpfile()?*                                       ;record structure*                                       ;----------------FILE_next equ  0                        ;disp to next pointer (must stay 0!)FILE_ptr  equ  FILE_next+4              ;next location to write toFILE_base equ  FILE_ptr+4               ;first byte of the bufferFILE_end  equ  FILE_base+4              ;end of the file bufferFILE_size equ  FILE_end+4               ;size of the file bufferFILE_cnt  equ  FILE_size+4              ;# chars that can be read/writen to bufferFILE_pbk  equ  FILE_cnt+4               ;put back characterFILE_flag equ  FILE_pbk+2               ;buffer flagsFILE_file equ  FILE_flag+2              ;GS/OS file IDsizeofFILE equ  FILE_file+2             ;size of the recordBUFSIZ   equ   1024                     ;default file buffer size_LBUFSIZ equ   255                      ;line buffer sizeL_tmpnam equ   9                        ;size of a temp nameTMP_MAX  equ   10000                    ;# of uniq temp names;;  Seek codes for fseek;SEEK_CNT equ   0                        ;seek from start of fileSEEK_CUR equ   1                        ;seek from current positionSEEK_END equ   2                        ;seek from end of file;;  Values for fcntl.h;OPEN_MAX equ   30                       ;files in the file arrayF_DUPFD  equ   1                        ;dup file flag (fcntl)O_RDONLY equ   $0001                    ;file is read onlyO_WRONLY equ   $0002                    ;file is write onlyO_RDWR   equ   $0004                    ;file is read/writeO_NDELAY equ   $0008                    ;not usedO_APPEND equ   $0010                    ;append to file on all writesO_CREAT  equ   $0020                    ;create a new file if neededO_TRUNC  equ   $0040                    ;erase old fileO_EXCL   equ   $0080                    ;don't create a new fileO_BINARY equ   $0100                    ;file is binary;;  Misc.;EOF      equ   -1                       ;end of file characterstdinID  equ   -1                       ;standard in file IDstdoutID equ   -2                       ;standard out file IDstderrID equ   -3                       ;error out file IDstrSize  equ   255                      ;max size of a GS/OS path name		EXPORT	FCNTL    FCNTL    PROC                          ;dummy segment		ENDP******************************************************************  ctoosstr - convert a C string to a GS/OS input string**  Inputs:*        cstr - pointer to the c string**  Outputs:*        returns a pointer to the OS string**  Notes:*        If the C string is longer than ;strSize bytes, the*        string is truncated without warning.*******************************************************************ctoosstr privatectoosstr		PROCosptr    equ   1                        ;os string pointer;;       csubroutine (4:cstr),4	; cstr     equ   0+4+4         tsc         sec         sbc   #4         tcs         phd         tcd         phb                            ;use a local B reg         phk         plb;;       short M                        ;copy over the characters         SEP   #1*32+0*16			LONGA OFF         ldy   #0lb1      lda   [cstr],Y         beq   lb2         sta   osstr+2,Y         iny         cpy   #strSize         bne   lb1lb2      sty   osstr                    ;set the string length;;       long  M         REP   #1*32+0*16			LONGA ON;;       lla   osptr,osstr              ;set the address of the string	;          LDA   #osstr         STA   osptr         LDA   #^osstr         STA   2+osptr         plb                            ;restore caller's B;;       creturn 4:osptr                ;return osptr	;          ldx   osptr+2         ldy   osptr         lda   4+2         sta   4+4+2         lda   4+1         sta   4+4+1         pld         tsc         clc         adc   #4+4         tcs         tya         rtlosstr		DS.B 2+strSize                ;GS/OS string buffer		ENDP******************************************************************  int chmod(char *path, int mode);**  Changes the access bits.**  Inputs:*        path - name of the file*        mode - zero or more flags to set:*              0x0100 - read*              0x0080 - write*              0x1000 - delete*              0x2000 - rename*              0x4000 - backup*              0x8000 - invisible**  Outputs:*        returns 0 if successful; else -1*        errno - set if an error occurred******************************************************************		EXPORT	chmod    chmod    PROCerr      equ   1                        ;error return code;;       csubroutine (4:path,2:mode),2	; path     equ   0+4+2mode     equ   4+4+2         tsc         sec         sbc   #2         tcs         phd         tcd         phb                            ;use local B         phk         plb         stz   err                      ;err = 0 {no error}         lda   mode                     ;convert mode to ProDOS format         jsr   unixtoprodos         sta   siAccess;;       ph4   path                     ;set the path name	;          LDA   path+2         PHA         LDA   path         PHA         jsl   ctoosstr         sta   siPathname         stx   siPathname+2;;       OSSet_File_Info siRec          ;set the access bits         JSL   $E100A8	DC.W	$2005	DC.L	siRec         bcs   lb1         lda   siAccess                 ;if the backup bit is clear then         and   #$0020         bne   lb2;;       move4 siPathname,cbPathname    ;  clear the backup bit;;       ~SETM	;          LDA   2+siPathname         STA   2+cbPathname         LDA   siPathname         STA   cbPathname;;       ~RESTM	; ;;       OSClear_Backup cbRec         JSL   $E100A8	DC.W	$200B	DC.L	cbRec         bcc   lb2lb1      lda   #ENOENT                  ;flag an error         sta   >errno         dec   errlb2      plb;;       creturn 2:err	;          ldy   err         lda   2+2         sta   2+6+2         lda   2+1         sta   2+6+1         pld         tsc         clc         adc   #2+6         tcs         tya         rtlcbRec	DC.W	1	;ClearBackup recordcbPathname		DS.B 4siRec	DC.W	2	;SetFileInfo recordsiPathname		DS.B 4siAccess		DS.B 2		ENDP******************************************************************  int close(int filds);**  Close a file.**  Inputs:*        filds - file ID of the file to ;close**  Outputs:*        returns 0 if successful; else -1*        errno - set if an error occurred******************************************************************		EXPORT	close    close    PROCerr      equ   1                        ;error return code;;       csubroutine (2:filds),2	; filds    equ   0+4+2         tsc         sec         sbc   #2         tcs         phd         tcd         stz   err                      ;err = 0 {no error}         lda   filds                    ;error if there are too many open files         bmi   lb2         cmp   #OPEN_MAX         bge   lb2         asl   A                        ;get the file reference number         asl   A         tax         lda   >files,X         beq   lb2         sta   >clRefnum         lda   #0                       ;free the file record         sta   >files,X         ldx   #OPEN_MAX*4-4            ;for each file record do         lda   >clRefnum                ;  if the file is a duplicate thenlb1      cmp   >files,X         beq   lb3                      ;    skip the close         dex         dex         dex         dex         bpl   lb1;;       OSClose clRec                  ;close the file         JSL   $E100A8	DC.W	$2014	DC.L	clRec         bcc   lb3lb2      lda   #EBADF                   ;an error occurred - set errno         sta   >errno         dec   err                      ;err = -1;;lb3    creturn 2:errlb3	;          ldy   err         lda   2+2         sta   2+2+2         lda   2+1         sta   2+2+1         pld         tsc         clc         adc   #2+2         tcs         tya         rtlclRec	DC.W	1	;close recordclRefnum		DS.B 2		ENDP******************************************************************  int creat(char *path, int mode);**  Create a file.**  Inputs:*        path - name of the file*        mode - zero or more flags to set:*              0x0100 - read*              0x0080 - write*              0x1000 - delete*              0x2000 - rename*              0x4000 - backup*              0x8000 - invisible**  Outputs:*        returns 0 if successful; else -1*        errno - set if an error occurred******************************************************************		EXPORT	creat    creat    PROCerr      equ   1                        ;error return code;;       csubroutine (4:path,2:mode),2	; path     equ   0+4+2mode     equ   4+4+2         tsc         sec         sbc   #2         tcs         phd         tcd;;       ph2   #O_WRONLY+O_TRUNC+O_CREAT	;          PEA   O_WRONLY+O_TRUNC+O_CREAT;;       ph2   mode	;          LDA   mode         PHA;;       ph4   path	;          LDA   path+2         PHA         LDA   path         PHA         jsl   openfile         sta   err;;       creturn 2:err	;          ldy   err         lda   2+2         sta   2+6+2         lda   2+1         sta   2+6+1         pld         tsc         clc         adc   #2+6         tcs         tya         rtl		ENDP******************************************************************  int dup(int old);**  Duplicate a file descriptor**  Inputs:*        old - existing file descriptor**  Outputs:*        returns 0 if successful; else -1*        errno - set if an error occurred******************************************************************		EXPORT	dup      dup      PROCerr      equ   1                        ;error return code;;       csubroutine (2:old),2	; old      equ   0+4+2         tsc         sec         sbc   #2         tcs         phd         tcd;;       ph2   #0	;          PEA   0;;       ph2   #F_DUPFD	;          PEA   F_DUPFD;;       ph2   old	;          LDA   old         PHA         jsl   fcntl         sta   err;;       creturn 2:err	;          ldy   err         lda   2+2         sta   2+2+2         lda   2+1         sta   2+2+1         pld         tsc         clc         adc   #2+2         tcs         tya         rtl		ENDP******************************************************************  int fcntl(int filds, int cmd, int arg);**  Open file control**  Inputs:*        filds - file ID of file*        cmd - command; F_DUPD is the only one accepted*        arg - lowest acceptable returned file ID**  Outputs:*        returns -1 for an error; new filds for success*        errno - set if an error occurred******************************************************************		EXPORT	fcntl    fcntl    PROCerr      equ   1                        ;error return coderefnum   equ   3                        ;reference numberflags    equ   5                        ;file flags;;       csubroutine (2:filds,2:cmd,2:arg),6	; filds    equ   0+4+6cmd      equ   2+4+6arg      equ   4+4+6         tsc         sec         sbc   #6         tcs         phd         tcd         stz   err                      ;err = 0 {no error}         lda   cmd                      ;the command must be F_DUPFD         cmp   #F_DUPFD         beq   lb1         dec   err         lda   #EINVAL         sta   >errno         bra   lb7lb1      lda   filds                    ;error if there are too many open files         bmi   lb2         cmp   #OPEN_MAX         bge   lb2         asl   A                        ;get the file reference number         asl   A         tax         lda   >files,X         bne   lb3lb2      dec   err                      ;flag an invalid filds error         lda   #EBADF         sta   >errno         bra   lb7lb3      sta   refnum         lda   >files+2,X               ;get the file flags         sta   flags         lda   arg                      ;find a new filds         bmi   lb5         cmp   #OPEN_MAX         bge   lb5         asl   A         asl   Alb4      lda   >files,X         beq   lb6         inx         inx         inx         inx         cpx   #OPEN_MAX*4         bne   lb4lb5      dec   err                      ;none are available -- flag the error         lda   #EMFILE         sta   >errno         bra   lb7lb6      lda   refnum                   ;set the new refnum         sta   >files,X         lda   flags                    ;set the new flags         sta   >files+2,X         txa                            ;return the filds         lsr   A         lsr   A         sta   err;;lb7    creturn 2:errlb7	;          ldy   err         lda   6+2         sta   6+6+2         lda   6+1         sta   6+6+1         pld         tsc         clc         adc   #6+6         tcs         tya         rtl		ENDP******************************************************************  files - array of file records**  There are OPEN_MAX elements, each with the following format:**        bytes use*        ----- ---*        2     file reference number; 0 ;if element is free*        2     flags; set by open command**  Notes:  Array calculations throughout the module depend on*          a record size within the array of exactly 4 bytes.*******************************************************************files    privatefiles		PROC		DS.B 4*OPEN_MAX		ENDP******************************************************************  long lseek(int filds, long offset, int whence);**  Set the file mark**  Inputs:*        filds - file ID of file*        offset - new file mark*        whence - set the mark in relation to:*              0 - file start*              1 - current mark*              2 - file end**  Outputs:*        returns file pointer if successful; -1 for an error*        errno - set if an error occurred******************************************************************		EXPORT	lseek    lseek    PROCmark     equ   1                        ;new file mark;;       csubroutine (2:filds,4:offset,2:whence),4	; filds    equ   0+4+4offset   equ   2+4+4whence   equ   6+4+4         tsc         sec         sbc   #4         tcs         phd         tcd         lda   #$FFFF                   ;assume we will get an error         sta   mark         sta   mark+2         lda   filds                    ;get the file refnum         bmi   lb1         cmp   #OPEN_MAX         bge   lb1         asl   A         asl   A         tax         lda   >files,X         bne   lb2lb1      lda   #EBADF                   ;bad refnum error         sta   >errno         bra   lb4lb2      sta   >smRefnum                ;set the file refnum         sta   >gmRefnum         lda   whence                   ;convert from UNIX whence to GS/OS base         beq   lb3         eor   #$0003         cmp   #4         bge   lb2a         cmp   #2         bne   lb3         sta   >smBase         lda   offset+2         bpl   lb3a;;       sub4  #0,offset,offset;;       ~SETM	;          SEC;;       ~LDA  #0         LDA   #0;;       ~OP   SBC,offset         SBC   offset;;       ~STA  offset         STA   offset;;       ~LDA.H #0	;          LDA   #^0;;       ~OP.H SBC,offset	;          SBC   2+offset;;       ~STA.H offset	;          STA   2+offset;;       ~RESTM	;          lda   #3         bra   lb3lb2a     lda   #EINVAL                  ;invalid whence flag         sta   >errno         bra   lb4lb3      sta   >smBase                  ;save the base parameterlb3a     lda   offset                   ;set the displacement         sta   >smDisplacement         lda   offset+2         sta   >smDisplacement+2;;       OSSet_Mark smRec               ;set the file mark         JSL   $E100A8	DC.W	$2016	DC.L	smRec         bcs   lb1;;       OSGet_Mark gmRec               ;get the new mark         JSL   $E100A8	DC.W	$2017	DC.L	gmRec         bcs   lb1         lda   >gmDisplacement         sta   mark         lda   >gmDisplacement+2         sta   mark+2;;lb4    creturn 4:marklb4	;          ldx   mark+2         ldy   mark         lda   4+2         sta   4+8+2         lda   4+1         sta   4+8+1         pld         tsc         clc         adc   #4+8         tcs         tya         rtlsmRec	DC.W	3	;SetMark recordsmRefnum		DS.B 2smBase		DS.B 2smDisplacement		DS.B 4gmRec	DC.W	2	;GetMark recordgmRefnum		DS.B 2gmDisplacement		DS.B 4		ENDP******************************************************************  int open(char *path, int oflag);**  Open a file**  Inputs:*        path - name of the file*        oflag - output flags**  Outputs:*        returns 0 if successful; else -1*        errno - set if an error occurred******************************************************************		EXPORT	open     open     PROCerr      equ   1                        ;error return code;;       csubroutine (4:path,2:oflag),2	; path     equ   0+4+2oflag    equ   4+4+2         tsc         sec         sbc   #2         tcs         phd         tcd;;       ph2   oflag	;          LDA   oflag         PHA;;       ph2   #$7180	;          PEA   $7180;;       ph4   path	;          LDA   path+2         PHA         LDA   path         PHA         jsl   openfile         sta   err;;       creturn 2:err	;          ldy   err         lda   2+2         sta   2+6+2         lda   2+1         sta   2+6+1         pld         tsc         clc         adc   #2+6         tcs         tya         rtl		ENDP******************************************************************  int openfile(char *path, int mode, int oflag);**  Open a file**  Inputs:*        path - name of the file*        mode - zero or more flags to set:*              0x0100 - read*              0x0080 - write*              0x1000 - delete*              0x2000 - rename*              0x4000 - backup*              0x8000 - invisible*        oflag - output flags**  Outputs:*        returns 0 if successful; else -1*        errno - set if an error occurred*******************************************************************openfile privateopenfile		PROCerr      equ   1                        ;error return codeindex    equ   3                        ;index into the files arrayBIN      equ   $06                      ;BIN file typeTXT      equ   $04                      ;TXT file type;;       csubroutine (4:path,2:mode,2:oflag),6	; path     equ   0+4+6mode     equ   4+4+6oflag    equ   6+4+6         tsc         sec         sbc   #6         tcs         phd         tcd         phb                            ;use local B         phk         plb         stz   err                      ;err = 0 {no error}         ldx   #0                       ;find a free file entrylb1      lda   files,X         beq   lb2         inx         inx         inx         inx         cpx   #OPEN_MAX*4         bne   lb1         dec   err                      ;flag the open file error         lda   #EMFILE         sta   >errno         brl   lb11lb2      stx   index                    ;save the index to the file;;       ph4   path                     ;convert the path to an OS string	;          LDA   path+2         PHA         LDA   path         PHA         jsl   ctoosstr         sta   opPathname         stx   opPathname+2         sta   giPathname         stx   giPathname+2         sta   crPathname         stx   crPathname+2         lda   mode                     ;set the access bits for the create call         jsr   unixtoprodos         sta   crAccess         lda   oflag                    ;set the flags in the files array         ldx   index         sta   files+2,X         and   #O_BINARY                ;if the file is binary then         beq   lb3         lda   #BIN                     ;  set the create file type to BIN         bra   lb4                      ;elselb3      lda   #TXT                     ;  set the create file type to TXTlb4      sta   crFileType;;       OSGet_File_Info giRec          ;if the file exists then         JSL   $E100A8	DC.W	$2006	DC.L	giRec         bcs   lb5         lda   oflag                    ;  if O_EXCL is set then         and   #O_EXCL         beq   lb4a         dec   err                      ;    flag the error         lda   #ENOENT         sta   >errno         bra   lb11;;lb4a   ph2   mode                     ;  set the access bitslb4a	;          LDA   mode         PHA;;       ph4   path	;          LDA   path+2         PHA         LDA   path         PHA         jsl   chmod         bra   lb8                      ;elselb5      lda   oflag                    ;  if O_CREAT is not set then         and   #O_CREAT         bne   lb7         dec   err                      ;    flag the error         lda   #EEXIST         sta   >errno         bra   lb11;;lb7    OSCreate crRec                 ;  create the filelb7      JSL   $E100A8	DC.W	$2001	DC.L	crRec         bcs   lb9lb8	; ;;       OSOpen opRec                   ;open the file         JSL   $E100A8	DC.W	$2010	DC.L	opRec         bcs   lb9         lda   oflag                    ;if the O_TRUNC flag is set then         and   #O_TRUNC         beq   lb10         lda   opRefnum                 ;  set the EOF to 0         sta   efRefnum;;       OSSet_EOF efRec         JSL   $E100A8	DC.W	$2018	DC.L	efRec         bcc   lb10lb9      dec   err                      ;  flag an I/O error         lda   #EACCES         sta   >errno         bra   lb11lb10     lda   opRefnum                 ;save the reference number         ldx   index         sta   files,X         txa                            ;set the return file index         lsr   A         lsr   A         sta   errlb11     plb                            ;restore the caller's B;;       creturn 2:err	;          ldy   err         lda   6+2         sta   6+8+2         lda   6+1         sta   6+8+1         pld         tsc         clc         adc   #6+8         tcs         tya         rtlcrRec	DC.W	3	;Create recordcrPathname		DS.B 4crAccess		DS.B 2crFileType		DS.B 2giRec	DC.W	2	;GetFileInfo recordgiPathname		DS.B 4		DS.B 2opRec	DC.W	2	;Open recordopRefnum		DS.B 2opPathname		DS.B 4efRec	DC.W	3	;SetEOF recordefRefnum		DS.B 2	DC.W	0	DC.L	0		ENDP******************************************************************  int read(int filds, char *buf, int n);**  Read from a file**  Inputs:*        filds - file ID of file*        buf - file buffer*        n - # of bytes to read**  Outputs:*        returns 0 if successful; else -1*        errno - set if an error occurred******************************************************************		EXPORT	read     read     PROCerr      equ   1                        ;error return code;;       csubroutine (2:filds,4:buf,2:n),2	; filds    equ   0+4+2buf      equ   2+4+2n        equ   6+4+2         tsc         sec         sbc   #2         tcs         phd         tcd         stz   err                      ;err = 0 {no error}         phb                            ;use our B         phk         plb         lda   filds                    ;error if the file has not been opened         bmi   lb0         cmp   #OPEN_MAX         bge   lb0         asl   A                        ;get the file reference number         asl   A         tax         lda   files,X         beq   lb0         sta   rdRefnum         stx   filds         lda   files+2,X                ;make sure the file is open for reading         and   #O_RDONLY+O_RDWR         bne   lb0alb0      lda   #EBADF                   ;errno = EBANF         sta   >errno         dec   err                      ;return = -1         bra   lb5;;lb0a   move4 buf,rdDataBuffer         ;set the location to read to;;lb0a   ~SETMlb0a	;          LDA   2+buf         STA   2+rdDataBuffer         LDA   buf         STA   rdDataBuffer;;       ~RESTM	;          lda   n                        ;set the number of bytes to read         sta   rdRequestCount;;       OSRead rdRec                   ;read the bytes         JSL   $E100A8	DC.W	$2012	DC.L	rdRec         bcc   lb1                      ;if an error occurred         cmp   #$4C                     ;  and it was not EOF then         beq   lb1         lda   #EIO                     ;  errno = EIO         sta   >errno         dec   err                      ;  return -1         bra   lb5lb1      ldy   rdTransferCount          ;return the bytes read         sty   err         beq   lb5lb2      ldx   filds                    ;if the file is not binary then         lda   files+2,X         and   #O_BINARY         bne   lb5         dey                            ;  for each byte do         beq   lb4a;;       short M         SEP   #1*32+0*16			LONGA OFFlb3      lda   [buf],Y                  ;    if the byte is \r then         cmp   #13         bne   lb4         lda   #10                      ;      change it to \n         sta   [buf],Ylb4      dey                            ;  next byte         bne   lb3lb4a     lda   [buf]                    ;  if the first byte is \r then         cmp   #13         bne   lb4b         lda   #10                      ;    change it to \n         sta   [buf];;lb4b   long  Mlb4b     REP   #1*32+0*16			LONGA ONlb5      plb                            ;restore B;;       creturn 2:err	;          ldy   err         lda   2+2         sta   2+8+2         lda   2+1         sta   2+8+1         pld         tsc         clc         adc   #2+8         tcs         tya         rtlrdRec	DC.W	4	;Read recordrdRefnum		DS.B 2rdDataBuffer		DS.B 4rdRequestCount		DS.B 4rdTransferCount		DS.B 4		ENDP******************************************************************  unixtoprodos - Convert UNIX access flags to ProDOS access flags**  Inputs:*        A - UNIX access flags**  Outputs:*        A - ProDOS access flags*******************************************************************unixtoprodos privateunixtoprodos		PROCbits     equ   3                        ;ProDOS bits         pea   0                        ;set ProDOS bits to 0         phd                            ;set up a stack frame         tax         tsc         tcd         txa         bit   #$1000                   ;if unix delete bit is set then         beq   lb1         sec                            ;  set the ProDOS delete bit         rol   bitslb1      bit   #$2000                   ;if unix rename bit is set then         beq   lb2         sec                            ;  set the ProDOS rename bit         bra   lb3                      ;elselb2      clc                            ;  clear the ProDOS rename bitlb3      rol   bits         bit   #$4000                   ;if unix backup bit is set then         beq   lb4         sec                            ;  set the ProDOS backup bit         bra   lb5                      ;elselb4      clc                            ;  clear the ProDOS backup bitlb5      rol   bits         rol   bits                     ;roll in the two unused bit fields         rol   bits         bit   #$8000                   ;if unix invisible bit is set then         beq   lb6         sec                            ;  set the ProDOS invisible bit         bra   lb7                      ;elselb6      clc                            ;  clear the ProDOS invisible bitlb7      rol   bits         bit   #$0080                   ;if unix write bit is set then         beq   lb8         sec                            ;  set the ProDOS write bit         bra   lb9                      ;elselb8      clc                            ;  clear the ProDOS write bitlb9      rol   bits         bit   #$0100                   ;if unix read bit is set then         beq   lb10         sec                            ;  set the ProDOS read bit         bra   lb11                     ;elselb10     clc                            ;  clear the ProDOS read bitlb11     rol   bits         pld                            ;return the new flags         pla         rts		ENDP******************************************************************  int write(filds, char *buf, unsigned ;n);**  Write to a file**  Inputs:*        filds - file ID of file*        buf - file buffer*        n - # of bytes to write**  Outputs:*        returns 0 if successful; else -1*        errno - set if an error occurred******************************************************************		EXPORT	write    write    PROCerr      equ   1                        ;error return codenbuff    equ   3                        ;new buffer pointer;;       csubroutine (2:filds,4:buf,2:n),6	; filds    equ   0+4+6buf      equ   2+4+6n        equ   6+4+6         tsc         sec         sbc   #6         tcs         phd         tcd         stz   err                      ;err = 0 {no error}         phb                            ;use our B         phk         plb         lda   filds                    ;error if the file has not been opened         bmi   lb0         cmp   #OPEN_MAX         bge   lb0         asl   A                        ;get the file reference number         asl   A         tax         lda   files,X         beq   lb0         sta   wrRefnum         stx   filds         lda   files+2,X                ;make sure the file is open for writing         and   #O_WRONLY+O_RDWR         bne   lb0alb0      lda   #EBADF                   ;errno = EBADF         sta   >errno         dec   err                      ;return = -1         brl   lb5;;lb0a   move4 buf,wrDataBuffer         ;set the location to write from;;lb0a   ~SETMlb0a	;          LDA   2+buf         STA   2+wrDataBuffer         LDA   buf         STA   wrDataBuffer;;       ~RESTM	;          lda   n                        ;set the number of bytes to read         sta   wrRequestCount         stz   nbuff                    ;nbuff == nil         stz   nbuff+2         ldx   filds                    ;if the file is not binary then         lda   files+2,X         and   #O_BINARY         bne   lb0g         pea   0                        ;  reserve a file buffer;;       ph2   n	;          LDA   n         PHA         jsl   malloc         sta   nbuff         stx   nbuff+2         ora   nbuff+2         bne   lb0b         dec   err                      ;  flag an out of memory error         lda   #ENOSPC         sta   >errno         bra   lb5lb0b     ldy   n                        ;  move the bytes to the new buffer,         beq   lb0f                     ;    converting \n chars to \r chars         dey                            ;    in the process         beq   lb0da;;       short M         SEP   #1*32+0*16			LONGA OFFlb0c     lda   [buf],Y         cmp   #10         bne   lb0d         lda   #13lb0d     sta   [nbuff],Y         dey         bne   lb0clb0da    lda   [buf]         cmp   #10         bne   lb0e         lda   #13lb0e     sta   [nbuff];;       long  M         REP   #1*32+0*16			LONGA ON;;lb0f   move4 nbuff,wrDataBuffer       ;  set the data buffer start;;lb0f   ~SETMlb0f	;          LDA   2+nbuff         STA   2+wrDataBuffer         LDA   nbuff         STA   wrDataBuffer;;       ~RESTM	; ;;lb0g   OSWrite wrRec                  ;write the byteslb0g     JSL   $E100A8	DC.W	$2013	DC.L	wrRec         bcc   lb1                      ;if an error occurred then         lda   #EIO                     ;  errno = EIO         sta   >errno         dec   err                      ;  return -1         bra   lb5lb1      ldy   wrTransferCount          ;return the bytes read         sty   err         lda   nbuff                    ;if nbuff <> NULL then         ora   nbuff+2         beq   lb2;;       ph4   nbuff                    ;  dispose of the buffer	;          LDA   nbuff+2         PHA         LDA   nbuff         PHA         jsl   freelb2	; lb5      plb                            ;restore B;;       creturn 2:err	;          ldy   err         lda   6+2         sta   6+8+2         lda   6+1         sta   6+8+1         pld         tsc         clc         adc   #6+8         tcs         tya         rtlwrRec	DC.W	4	;Write recordwrRefnum		DS.B 2wrDataBuffer		DS.B 4wrRequestCount		DS.B 4wrTransferCount		DS.B 4		ENDP		END