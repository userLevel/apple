			case  on	seg   ''******************************************************************  StdIO - Standard I/O Library**  This code implements the tables and subroutines needed to*  support the standard C library STDIO.**  November 1988*  Mike Westerfield**  Copyright 1988*  Byte Works, Inc.**  Note: Portions of this library appear in SysFloat.******************************************************************;-----------------------------------------------;;   Imported addresses;;-----------------------------------------------	IMPORT	SYSCHARERROUT	IMPORT	SYSCHAROUT	IMPORT	SYSKEYIN	IMPORT	Scan_b	IMPORT	Scan_c	IMPORT	Scan_d	IMPORT	Scan_f	IMPORT	Scan_i	IMPORT	Scan_lbrack	IMPORT	Scan_n	IMPORT	Scan_o	IMPORT	Scan_p	IMPORT	Scan_percent	IMPORT	Scan_s	IMPORT	Scan_u	IMPORT	Scan_x	IMPORT	__ctype	IMPORT	errno	IMPORT	free	IMPORT	malloc	IMPORT	memcpy	IMPORT	numChars	IMPORT	scanCount	IMPORT	stderr	IMPORT	stdin	IMPORT	stdout	IMPORT	strcat	IMPORT	strcpy	IMPORT	strlen	IMPORT	~DIV4	IMPORT	~Format_e	IMPORT	~Format_E	IMPORT	~Format_f	IMPORT	~Format_g	IMPORT	~Format_G	IMPORT	~Scan_f	IMPORT	~MUL4	IMPORT	~UMUL4;-----------------------------------------------;;   Forward addresses and entries;;-----------------------------------------------	ENTRY	fclose	ENTRY	fflush	ENTRY	fgetc	ENTRY	fputc	ENTRY	ftell	ENTRY	putchar	ENTRY	sys_errlist	ENTRY	ungetc	ENTRY	~InitBuffer	ENTRY	~LeftJustify	ENTRY	~RightJustify	ENTRY	~SetFilePointer	ENTRY	~VerifyStream	ENTRY	~altForm	ENTRY	~assignments	ENTRY	~fieldWidth	ENTRY	~getchar	ENTRY	~hexPrefix	ENTRY	~ioerror	ENTRY	~isLong	ENTRY	~leftJustify	ENTRY	~num	ENTRY	~numChars	ENTRY	~osname	ENTRY	~paddChar	ENTRY	~precision	ENTRY	~precisionSpecified	ENTRY	~printf	ENTRY	~putback	ENTRY	~putchar	ENTRY	~removeZeros	ENTRY	~scanCount	ENTRY	~scanError	ENTRY	~scanWidth	ENTRY	~scanf	ENTRY	~sign	ENTRY	~size	ENTRY	~stdout	ENTRY	~str	ENTRY	~suppress;	INCLUDE	'equates.asm'******************************************************************  This file contains constant values defined in the C interfaces*  that are also used in the assembly language portion of the*  libraries.*****************************************************************;;  error numbers;EDOM     equ   1                        ;domain errorERANGE   equ   2                        ;# too large, too small, or illegalENOMEM   equ   3                        ;Not enough memoryENOENT   equ   4                        ;No such file or directoryEIO      equ   5                        ;I/O errorEINVAL   equ   6                        ;Invalid argumentEBADF    equ   7                        ;bad file descriptorEMFILE   equ   8                        ;too many files are openEACCES   equ   9                        ;access bits prevent the operationEEXIST   equ   10                       ;the file existsENOSPC   equ   11                       ;the file is too large;;  masks for the __ctype array;_digit   equ   $01                      ;['0'..'9']_upper   equ   $02                      ;['A'..'Z']_lower   equ   $04                      ;['a'..'z']_control equ   $08                      ;[chr(0)..chr(31),chr(127)]_punctuation equ  $10                   ;[' ','!'..'/',':'..'@','['..'`','{'..'~']_space   equ   $20                      ;[chr(9)..chr(13),' ']_hex     equ   $40                      ;['0'..'9','a'..'f','A'..'F']_print   equ   $80                      ;[' '..'~'];;  masks for the __ctype2 array;_csym    equ   $01                      ;['0'..'9','A'..'Z','a'..'z','_']_csymf   equ   $02                      ;['A'..'Z','a'..'z'.'_']_octal   equ   $04                      ;['0'..'7'];;  signal numbers;SIGABRT  equ   1SIGFPE   equ   2SIGILL   equ   3SIGINT   equ   4SIGSEGV  equ   5SIGTERM  equ   6;;  The FILE record;*                                       ;flags*                                       ;-----_IOFBF   equ   $0001                    ;full buffering_IONBF   equ   $0002                    ;no buffering_IOLBF   equ   $0004                    ;flush when a \n is written_IOREAD  equ   $0008                    ;currently reading_IOWRT   equ   $0010                    ;currently writing_IORW    equ   $0020                    ;read/write enabled_IOMYBUF equ   $0040                    ;buffer was allocated by stdio_IOEOF   equ   $0080                    ;has an EOF been found?_IOERR   equ   $0100                    ;has an error occurred?_IOTEXT  equ   $0200                    ;is this file a text file?_IOTEMPFILE equ  $0400                  ;was this file created by tmpfile()?*                                       ;record structure*                                       ;----------------FILE_next equ  0                        ;disp to next pointer (must stay 0!)FILE_ptr  equ  FILE_next+4              ;next location to write toFILE_base equ  FILE_ptr+4               ;first byte of the bufferFILE_end  equ  FILE_base+4              ;end of the file bufferFILE_size equ  FILE_end+4               ;size of the file bufferFILE_cnt  equ  FILE_size+4              ;# chars that can be read/writen to bufferFILE_pbk  equ  FILE_cnt+4               ;put back characterFILE_flag equ  FILE_pbk+2               ;buffer flagsFILE_file equ  FILE_flag+2              ;GS/OS file IDsizeofFILE equ  FILE_file+2             ;size of the recordBUFSIZ   equ   1024                     ;default file buffer size_LBUFSIZ equ   255                      ;line buffer sizeL_tmpnam equ   9                        ;size of a temp nameTMP_MAX  equ   10000                    ;# of uniq temp names;;  Seek codes for fseek;SEEK_CNT equ   0                        ;seek from start of fileSEEK_CUR equ   1                        ;seek from current positionSEEK_END equ   2                        ;seek from end of file;;  Values for fcntl.h;OPEN_MAX equ   30                       ;files in the file arrayF_DUPFD  equ   1                        ;dup file flag (fcntl)O_RDONLY equ   $0001                    ;file is read onlyO_WRONLY equ   $0002                    ;file is write onlyO_RDWR   equ   $0004                    ;file is read/writeO_NDELAY equ   $0008                    ;not usedO_APPEND equ   $0010                    ;append to file on all writesO_CREAT  equ   $0020                    ;create a new file if neededO_TRUNC  equ   $0040                    ;erase old fileO_EXCL   equ   $0080                    ;don't create a new fileO_BINARY equ   $0100                    ;file is binary;;  Misc.;EOF      equ   -1                       ;end of file characterstdinID  equ   -1                       ;standard in file IDstdoutID equ   -2                       ;standard out file IDstderrID equ   -3                       ;error out file IDlen~str  equ   83                       ;l:~str******************************************************************  void clearerr(stream)*        FILE *stream;**  Clears the error flag for the givin stream.**  Inputs:*        stream - file to clear******************************************************************		EXPORT	clearerr clearerr PROCstream   equ   4                        ;input stream         tsc         phd         tcd;;       ph4   stream                   ;verify that stream exists	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   ~VerifyStream         bcs   lb1         ldy   #FILE_flag               ;clear the error flag         lda   [stream],Y         and   #$FFFF-_IOERR-_IOEOF         sta   [stream],Ylb1      pld         lda   2,S         sta   6,S         pla         sta   3,S         pla         rtl		ENDP******************************************************************  int fclose(stream)*        FILE *stream;**  Inputs:*        stream - pointer to the file buffer to close**  Outputs:*        A - EOF for an error; 0 if there was no error******************************************************************		EXPORT	fclose   fclose   PROCnameBuffSize equ 8*1024                 ;pathname buffer sizeerr      equ   1                        ;return valuep        equ   3                        ;work pointerstdfile  equ   7                        ;is this a standard file?;;       csubroutine (4:stream),8	; stream   equ   0+4+8         tsc         sec         sbc   #8         tcs         phd         tcd         phb         phk         plb         lda   #EOF                     ;assume we will get an error         sta   err;;       ph4   stream                   ;verify that stream exists	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   ~VerifyStream;;       jcs   rts         BCC   *+5         BRL   rts;;       ph4   stream                   ;do any pending I/O	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   fflush         tax;;       jne   rts         BEQ   *+5         BRL   rts         stz   stdfile                  ;not a standard file         lda   stream+2                 ;bypass file disposal if the file is         cmp   #^stdin+4                ; one of the standard ones         bne   cl0         lda   stream         cmp   #stdin+4         beq   lb1         cmp   #stdout+4         beq   lb1         cmp   #stderr+4         bne   cl0lb1      inc   stdfile         bra   cl3a;;cl0    lla   p,stderr+4               ;find the file record that points to thiscl0	;          LDA   #stderr+4         STA   p         LDA   #^stderr+4         STA   2+p         ldy   #2                       ; onecl1      lda   [p]         ora   [p],Y;;       jeq   rts         BNE   *+5         BRL   rts         lda   [p],Y         tax         lda   [p]         cmp   stream         bne   cl2         cpx   stream+2         beq   cl3cl2      stx   p+2         sta   p         bra   cl1cl3      lda   [stream]                 ;remove stream from the file list         sta   [p]         lda   [stream],Y         sta   [p],Ycl3a     ldy   #FILE_flag               ;if the file was opened by tmpfile then         lda   [stream],Y         and   #_IOTEMPFILE         beq   cl3d;;       ph4   #nameBuffSize            ;  p = malloc(nameBuffSize)	;          PEA   +(nameBuffSize)>>16         PEA   nameBuffSize         jsl   malloc                   ;  grPathname = p         sta   p                        ;  dsPathname = p+2         stx   p+2         sta   grPathname         stx   grPathname+2         clc         adc   #2         bcc   cl3b         inxcl3b     sta   dsPathname         stx   dsPathname+2         lda   #nameBuffSize            ;  p->size = nameBuffSize         sta   [p]         ldy   #FILE_file               ;  clRefnum = grRefnum = stream->_file         lda   [stream],Y         beq   cl3e         sta   grRefnum;;       GetRefInfoGS gr                ;  GetRefInfoGS(gr)         jsl   $E100A8	DC.W	$2039	DC.L	gr         bcs   cl3c         lda   grRefnum                 ;  OSClose(cl)         sta   clRefNum;;       OSClose cl         JSL   $E100A8	DC.W	$2014	DC.L	cl;;       DestroyGS ds                   ;  DestroyGS(ds)         jsl   $E100A8	DC.W	$2002	DC.L	ds;;cl3c   ph4   p                        ;  free(p)cl3c	;          LDA   p+2         PHA         LDA   p         PHA         jsl   free         bra   cl3e                     ;elsecl3d     ldy   #FILE_file               ;  close the file         lda   [stream],Y         beq   cl3e         sta   clRefNum;;       OSClose cl         JSL   $E100A8	DC.W	$2014	DC.L	clcl3e     ldy   #FILE_flag               ;if the buffer was allocated by fopen then         lda   [stream],Y         and   #_IOMYBUF         beq   cl4         ldy   #FILE_base+2             ;  dispose of the file buffer         lda   [stream],Y         pha         dey         dey         lda   [stream],Y         pha         jsl   freecl4      lda   stdfile                  ;if this is not a standard file then         bne   cl5;;       ph4   stream                   ;  dispose of the file buffer	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   free         bra   cl7                      ;else;;cl5    add4  stream,#sizeofFILE-4,p   ;  reset the standard out stuff;;cl5    ~SETMcl5	;          CLC;;       ~LDA  stream         LDA   stream;;       ~OP   ADC,#sizeofFILE-4         ADC   #sizeofFILE-4;;       ~STA  p         STA   p;;       ~LDA.H stream	;          LDA   2+stream;;       ~OP.H ADC,#sizeofFILE-4	;          ADC   #^sizeofFILE-4;;       ~STA.H p	;          STA   2+p;;       ~RESTM	;          ldy   #sizeofFILE-2cl6      lda   [p],Y         sta   [stream],Y         dey         dey         cpy   #2         bne   cl6cl7      stz   err                      ;no error foundrts      plb;;       creturn   2:err	;          ldy   err         lda   8+2         sta   8+4+2         lda   8+1         sta   8+4+1         pld         tsc         clc         adc   #8+4         tcs         tya         rtlcl	DC.W	1	;parameter block for OScloseclRefNum		DS.B 2gr	DC.W	3	;parameter block for GetRefInfoGSgrRefnum		DS.B 2		DS.B 2grPathname		DS.B 4ds	DC.W	1	;parameter block for DestroyGSdsPathname		DS.B 4		ENDP******************************************************************  int feof(stream)*        FILE *stream;**  Inputs:*        stream - file to check**  Outputs:*        Returns _IOEOF if an end of file has been reached; else*        0.******************************************************************		EXPORT	feof     feof     PROCstream   equ   4                        ;input stream         tsc         phd         tcd;;       ph4   stream                   ;verify that stream exists	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   ~VerifyStream         ldx   #_IOEOF         bcs   lb1         ldy   #FILE_flag               ;check for eof         lda   [stream],Y         and   #_IOEOF         taxlb1      pld         lda   2,S         sta   6,S         pla         sta   3,S         pla         txa         rtl		ENDP******************************************************************  int ferror(stream)*        FILE *stream;**  Inputs:*        stream - file to check**  Outputs:*        Returns _IOERR if an end of file has been reached; else*        0.******************************************************************		EXPORT	ferror   ferror   PROCstream   equ   4                        ;input stream         tsc         phd         tcd;;       ph4   stream                   ;verify that stream exists	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   ~VerifyStream         ldx   #_IOERR         bcs   lb1         ldy   #FILE_flag               ;return the error status         lda   [stream],Y         and   #_IOERR         taxlb1      pld         lda   2,S         sta   6,S         pla         sta   3,S         pla         txa         rtl		ENDP******************************************************************  int fflush(steam)*        FILE *stream;**  Write any pending characters to the output file**  Inputs:*        stream - file buffer**  Outputs:*        A - EOF for an error; 0 if there was no error******************************************************************		EXPORT	fflush   fflush   PROCerr      equ   1                        ;return value;;       csubroutine (4:stream),2	; stream   equ   0+4+2         tsc         sec         sbc   #2         tcs         phd         tcd         phb         phk         plb         lda   #EOF                     ;assume there is an error         sta   err;;       ph4   stream                   ;verify that stream exists	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   ~VerifyStream         bcs   rts         ldy   #FILE_flag               ;if the mode is not writting, quit         lda   [stream],Y         and   #_IOWRT         beq   fl2         ldy   #FILE_file               ;set the reference number         lda   [stream],Y         sta   wrRefNum         ldy   #FILE_base               ;set the starting location         lda   [stream],Y         sta   wrDataBuffer         iny         iny         lda   [stream],Y         sta   wrDataBuffer+2         sec                            ;set the # of bytes to write         ldy   #FILE_ptr         lda   [stream],Y         sbc   wrDataBuffer         sta   wrRequestCount         iny         iny         lda   [stream],Y         sbc   wrDataBuffer+2         sta   wrRequestCount+2         ora   wrRequestCount           ;skip the write if there are no         beq   fl1                      ; characters;;       OSwrite wr                     ;write the info         JSL   $E100A8	DC.W	$2013	DC.L	wr         bcc   fl1;;       ph4   stream	;          LDA   stream+2         PHA         LDA   stream         PHA         jsr   ~ioerror         bra   rts;;fl1    ph4   stream                   ;prepare file for outputfl1	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   ~InitBuffer         ldy   #FILE_flag               ;if the file is open for read/write then         lda   [stream],Y         bit   #_IORW         beq   fl2         and   #$FFFF-_IOWRT            ;  turn off the writing flag         sta   [stream],Yfl2      stz   err                      ;no error foundrts      plb;;       creturn 2:err	;          ldy   err         lda   2+2         sta   2+4+2         lda   2+1         sta   2+4+1         pld         tsc         clc         adc   #2+4         tcs         tya         rtlwr	DC.W	5	;parameter block for OSwritewrRefNum		DS.B 2wrDataBuffer		DS.B 4wrRequestCount		DS.B 4		DS.B 4	DC.W	1		ENDP******************************************************************  int fgetc(stream)*        FILE *stream;**  Read a character from a file**  Inputs:*        stream - file to read from**  Outputs:*        A - character read; EOF for an ;error******************************************************************		EXPORT	fgetc    fgetc    PROCc        equ   1                        ;character readp        equ   3                        ;work pointer;;       csubroutine (4:stream),6	; stream   equ   0+4+6         tsc         sec         sbc   #6         tcs         phd         tcd         phb         phk         plb;;       ph4   stream                   ;verify that stream exists	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   ~VerifyStream         bcs   lb0         ldy   #FILE_flag               ;quit with error if the end of file         lda   [stream],Y               ; has been reached or an error has been         and   #_IOEOF+_IOERR           ; encountered         beq   lb1lb0      lda   #EOF         sta   c         brl   gc9lb1      ldy   #FILE_pbk                ;if there is a char in the putback buffer         lda   [stream],Y         and   #$0080         bne   lb2         lda   [stream],Y               ;  return it         and   #$00FF         sta   c         lda   [stream],Y               ;  pop the putback buffer         xba         ora   #$FF00         sta   [stream],Y         brl   gc9lb2      ldy   #FILE_file               ;branch if this is a disk file         lda   [stream],Y         bpl   gc2         cmp   #stdinID                 ;if stream = stdin then         bne   gc1         jsl   SYSKEYIN                 ;  get a character         tax                            ;  branch if not eof         bne   st1         lda   #_IOEOF                  ;  set EOF flag         ora   >stdin+4+FILE_flag         sta   >stdin+4+FILE_flag         jsl   SYSKEYIN                 ;  read the closing cr         lda   #EOF                     ;  return EOFst1      sta   c         brl   gc9;;gc1    ph4   stream                   ;else flag the errorgc1	;          LDA   stream+2         PHA         LDA   stream         PHA         jsr   ~ioerror         lda   #EOF         sta   c         brl   gc9gc2      ldy   #FILE_flag               ;if the file is not read enabled then         lda   [stream],Y         bit   #_IOREAD         bne   gc2a         bit   #_IOWRT                  ;  it is an error if it is write enabled         bne   gc1         bra   gc2bgc2a     ldy   #FILE_cnt                ;we're ready if there are characters         lda   [stream],Y               ; left         iny         iny         ora   [stream],Y;;       jne   gc8         BEQ   *+5         BRL   gc8gc2b     ldy   #FILE_flag               ;  if input is unbuffered then         lda   [stream],Y         bit   #_IONBF         beq   gc3         stz   rdDataBuffer+2           ;    set up to read one char to c         tdc         clc         adc   #c         sta   rdDataBuffer;;       lla   rdRequestCount,1	;          LDA   #1         STA   rdRequestCount         LDA   #^1         STA   2+rdRequestCount         bra   gc4gc3      ldy   #FILE_base               ;else set up to read a buffer full         lda   [stream],Y         sta   rdDataBuffer         iny         iny         lda   [stream],Y         sta   rdDataBuffer+2         ldy   #FILE_size         lda   [stream],Y         sta   rdRequestCount         iny         iny         lda   [stream],Y         sta   rdRequestCount+2gc4      ldy   #FILE_file               ;set the file reference number         lda   [stream],Y         sta   rdRefNum;;       OSRead rd                      ;read the data         JSL   $E100A8	DC.W	$2012	DC.L	rd         bcc   gc7                      ;if there was a read error then         ldy   #FILE_flag         cmp   #$4C                     ;  if it was eof then         bne   gc5         lda   #_IOEOF                  ;    set the EOF flag         bra   gc6                      ;  elsegc5      lda   #_IOERR                  ;    set the error flaggc6      ora   [stream],Y         sta   [stream],Y         lda   #EOF                     ;  return EOF         sta   c         brl   gc9gc7      ldy   #FILE_flag               ;we're done if the read is unbuffered         lda   [stream],Y         and   #_IONBF;;       jne   gc9         BEQ   *+5         BRL   gc9         clc                            ;set the end of the file buffer         ldy   #FILE_end         lda   rdDataBuffer         adc   rdTransferCount         sta   [stream],Y         iny         iny         lda   rdDataBuffer+2         adc   rdTransferCount+2         sta   [stream],Y         ldy   #FILE_base               ;reset the file pointer         lda   [stream],Y         tax         iny         iny         lda   [stream],Y         ldy   #FILE_ptr+2         sta   [stream],Y         dey         dey         txa         sta   [stream],Y         ldy   #FILE_cnt                ;set the # chars in the buffer         lda   rdTransferCount         sta   [stream],Y         iny         iny         lda   rdTransferCount+2         sta   [stream],Y         ldy   #FILE_flag               ;note that the file is read enabled         lda   [stream],Y         ora   #_IOREAD         sta   [stream],Ygc8      ldy   #FILE_ptr                ;get the next character         lda   [stream],Y         sta   p         clc         adc   #1         sta   [stream],Y         iny         iny         lda   [stream],Y         sta   p+2         adc   #0         sta   [stream],Y         lda   [p]         and   #$00FF         sta   c         ldy   #FILE_cnt                ;dec the # chars in the buffer         sec         lda   [stream],Y         sbc   #1         sta   [stream],Y         bcs   gc8a         iny         iny         lda   [stream],Y         dec   A         sta   [stream],Ygc8a     ldy   #FILE_flag               ;if the file is read/write         lda   [stream],Y         and   #_IORW         beq   gc9         ldy   #FILE_cnt                ;and the buffer is empty then         lda   [stream],Y         iny         iny         ora   [stream],Y         bne   gc9         ldy   #FILE_flag               ;  note that no chars are left         lda   [stream],Y         eor   #_IOREAD         sta   [stream],Ygc9      lda   c                        ;if c = \r then         cmp   #13         bne   gc10         ldy   #FILE_flag               ;  if this is a text file then         lda   [stream],Y         and   #_IOTEXT         beq   gc10         lda   #10         sta   cgc10     plb;;       creturn 2:c	;          ldy   c         lda   6+2         sta   6+4+2         lda   6+1         sta   6+4+1         pld         tsc         clc         adc   #6+4         tcs         tya         rtl;;  Local data;rd	DC.W	4	;parameter block for OSReadrdRefNum		DS.B 2rdDataBuffer		DS.B 4rdRequestCount		DS.B 4rdTransferCount		DS.B 4	DC.W	1	;cache priority		ENDP******************************************************************  char *fgets(str, n, stream)*        char *str;*        int n;*        FILE *stream;**  Reads a line into the string str.**  Inputs:*        str - location to put the string read.*        n - size of the string*        stream - file to read from**  Outputs:*        Returns NULL if an EOF is encountered, placing any*        characters read before the EOF ;into str.  Returns str if*        a line or part of a line is read.******************************************************************		EXPORT	fgets    fgets    PROCRETURN   equ   13                       ;RETURN key codeLF       equ   10                       ;newlinedisp     equ   1                        ;disp in str;;       csubroutine (4:str,2:n,4:stream),2	; str      equ   0+4+2n        equ   4+4+2stream   equ   6+4+2         tsc         sec         sbc   #2         tcs         phd         tcd;;       ph4   stream                   ;verify that stream exists	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   ~VerifyStream         bcs   err1;;       ph4   stream                   ;quit with NULL if at EOF	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   feof         tax         beq   lb0err1     stz   str         stz   str+2         bra   rtslb0      stz   disp                     ;no characters processed so far         lda   #0         sta   [str]         dec   n                        ;leave room for the null terminator         bmi   err         beq   err;;lb1    ph4   stream                   ;get a characterlb1	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   fgetc         tax                            ;quit with error if it is an EOF         bpl   lb2err      stz   str         stz   str+2         bra   rtslb2      cmp   #RETURN                  ;if the char is a return, switch to lf         bne   lb3         lda   #LFlb3      ldy   disp                     ;place the char in the string         sta   [str],Y                  ; (null terminates automatically)         inc   disp         cmp   #LF                      ;quit if it was an LF         beq   rts         dec   n                        ;next character         bne   lb1;;rts    creturn 4:strrts	;          ldx   str+2         ldy   str         lda   2+2         sta   2+10+2         lda   2+1         sta   2+10+1         pld         tsc         clc         adc   #2+10         tcs         tya         rtl		ENDP******************************************************************  int fgetpos(FILE *stream, fpos_t *pos);**  Inputs:*        stream - pointer to stream to get position of*        pos - pointer to location to place position**  Outputs:*        A - 0 if successful; else -1 if not*        errno - if unsuccessful, errno ;is set to EIO******************************************************************		EXPORT	fgetpos  fgetpos  PROCerr      equ   1                        ;error code;;       csubroutine (4:stream,4:pos),2	; stream   equ   0+4+2pos      equ   4+4+2         tsc         sec         sbc   #2         tcs         phd         tcd;;       ph4   stream                   ;get the position	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   ftell         cmp   #-1                      ;if the position = -1 then         bne   lb1         cpx   #-1         bne   lb1         sta   err                      ;  err = -1         bra   lb2                      ;  returnlb1      sta   [pos]                    ;else         txa                            ;  *pos = position         ldy   #2         sta   [pos],Y         stz   err                      ;  err = 0lb2	; ;endif;;       creturn 2:err	;          ldy   err         lda   2+2         sta   2+8+2         lda   2+1         sta   2+8+1         pld         tsc         clc         adc   #2+8         tcs         tya         rtl		ENDP******************************************************************  FILE *fopen(filename, type)*        char *filename, *type;**  Inputs:*        filename - pointer to the file ;name*        type - pointer to the type string**  Outputs:*        X-A - pointer to the file variable; NULL for an error******************************************************************		EXPORT	fopen    fopen    PROCBIN      equ   6                        ;file type for BIN filesTXT      equ   4                        ;file type for TXT filesfileType equ   1                        ;file type letterfileBuff equ   3                        ;pointer to the file bufferbuffStart equ  7                        ;start of the file bufferOSname   equ   11                       ;pointer to the GS/OS file name;;  initialization;;;       csubroutine (4:filename,4:type),14	; filename equ   0+4+14type     equ   4+4+14         tsc         sec         sbc   #14         tcs         phd         tcd         phb                            ;use our data bank         phk         plb         stz   fileBuff                 ;no file so far         stz   fileBuff+2         lda   [type]                   ;make sure the file type is in ['a','r','w']         and   #$00FF         sta   fileType         ldx   #$0003         cmp   #'a'         beq   cn1         ldx   #$0002         cmp   #'w'         beq   cn1         ldx   #$0001         cmp   #'r'         beq   cn1         lda   #EINVAL         sta   >errno         brl   rt2;;  create a GS/OS file name;cn1      stx   opAccess                 ;set the access flags;;       ph4   filename                 ;get the length of the name buffer	;          LDA   filename+2         PHA         LDA   filename         PHA         jsl   ~osname         sta   OSname         stx   OSname+2         ora   OSname+2;;       jeq   rt2         BNE   *+5         BRL   rt2;;  check for file modifier characters + ;and b;         lda   #TXT                     ;we must open a new file - determine it's         sta   crFileType               ; type by looking for the 'b' designator         ldy   #1         lda   [type],Y         jsr   Modifier         bcc   cm1         iny         lda   [type],Y         jsr   Modifiercm1	; ;;  open the file;;;       move4 OSname,opName            ;try to open an existing file;;       ~SETM	;          LDA   2+OSname         STA   2+opName         LDA   OSname         STA   opName;;       ~RESTM	; ;;       OSopen op         JSL   $E100A8	DC.W	$2010	DC.L	op         bcc   of2         lda   fileType                 ;if the type is 'r', flag an error         cmp   #'r'         bne   of1         lda   #ENOENT         sta   >errno         brl   rt1;;of1    move4 OSname,crPathName        ;create the file;;of1    ~SETMof1	;          LDA   2+OSname         STA   2+crPathName         LDA   OSname         STA   crPathName;;       ~RESTM	; ;;       OScreate cr         JSL   $E100A8	DC.W	$2001	DC.L	cr         bcs   errEIO;;       OSopen op                      ;open the file         JSL   $E100A8	DC.W	$2010	DC.L	op         bcc   of2errEIO   lda   #EIO         sta   >errno         brl   rt1of2      lda   fileType                 ;if the file type is 'w' then         cmp   #'w'         bne   of3         lda   opRefNum                 ;  reset it         sta   efRefNum;;       OSSet_EOF ef         JSL   $E100A8	DC.W	$2018	DC.L	ef         bcc   ar1                      ;  allow 'not a block device error'         cmp   #$0058         beq   ar1         bra   errEIO                   ;  flag the errorof3      cmp   #'a'                     ;else if the file type is 'a' then         bne   ar1         lda   opRefNum         sta   gfRefNum         sta   smRefNum;;       OSGet_EOF gf                   ;  append to it         JSL   $E100A8	DC.W	$2019	DC.L	gf         bcs   errEIO;;       move4 gfEOF,smDisplacement;;       ~SETM	;          LDA   2+gfEOF         STA   2+smDisplacement         LDA   gfEOF         STA   smDisplacement;;       ~RESTM	; ;;       OSSet_Mark sm         JSL   $E100A8	DC.W	$2016	DC.L	sm         bcs   errEIO;;  allocate and fill in the file record;;;ar1    ph4   #sizeofFILE              ;get space for the file recordar1	;          PEA   +(sizeofFILE)>>16         PEA   sizeofFILE         jsl   malloc         sta   fileBuff         stx   fileBuff+2         ora   fileBuff+2         beq   ar2;;       ph4   #BUFSIZ                  ;get space for the file buffer	;          PEA   +(BUFSIZ)>>16         PEA   BUFSIZ         jsl   malloc         sta   buffStart         stx   buffStart+2         ora   buffStart+2         bne   ar3;;       ph4   fileBuff                 ;memory error	;          LDA   fileBuff+2         PHA         LDA   fileBuff         PHA         jsl   freear2      lda   #ENOMEM         sta   >errno         brl   rt1ar3      ldy   #2                       ;insert the record right after stderr         lda   >stderr+4         sta   [fileBuff]         lda   >stderr+6         sta   [fileBuff],Y         lda   fileBuff         sta   >stderr+4         lda   fileBuff+2         sta   >stderr+6         lda   buffStart                ;set the start of the buffer         ldy   #FILE_base         sta   [fileBuff],Y         iny         iny         lda   buffStart+2         sta   [fileBuff],Y         ldy   #FILE_ptr+2         sta   [fileBuff],Y         dey         dey         lda   buffStart         sta   [fileBuff],Y         ldy   #FILE_size               ;set the buffer size         lda   #BUFSIZ         sta   [fileBuff],Y         iny         iny         lda   #^BUFSIZ         sta   [fileBuff],Y         ldy   #1                       ;set the flags         lda   [type],Y         and   #$00FF         cmp   #'+'         beq   ar3a         cmp   #'b'         bne   ar4         iny         lda   [type],Y         and   #$00FF         cmp   #'+'         bne   ar4ar3a     lda   #_IOFBF+_IORW+_IOMYBUF         bra   ar6ar4      lda   fileType         cmp   #'r'         beq   ar5         lda   #_IOFBF+_IOWRT+_IOMYBUF         bra   ar6ar5      lda   #_IOFBF+_IOREAD+_IOMYBUFar6      ldy   #FILE_flag         ldx   crFileType         cpx   #BIN         beq   ar6a         ora   #_IOTEXTar6a     sta   [fileBuff],Y         ldy   #FILE_cnt                ;no chars in buffer         lda   #0         sta   [fileBuff],Y         iny         iny         sta   [fileBuff],Y         ldy   #FILE_pbk                ;nothing in the putback buffer         lda   #$FFFF         sta   [fileBuff],Y         ldy   #FILE_file               ;set the file ID         lda   opRefNum         sta   [fileBuff],Y;;  return the result;;;rt1    ph4   OSname                   ;dispose of the file name bufferrt1	;          LDA   OSname+2         PHA         LDA   OSname         PHA         jsl   freert2      plb                            ;restore caller's data bank;;       creturn 4:fileBuff             ;return	;          ldx   fileBuff+2         ldy   fileBuff         lda   14+2         sta   14+8+2         lda   14+1         sta   14+8+1         pld         tsc         clc         adc   #14+8         tcs         tya         rtl;;  Modifier - local subroutine to check ;modifier character;;  Returns: C=0 if no modifier found, else C=1;Modifier and   #$00FF         beq   md3         cmp   #'+'         bne   md1         lda   #$0003         sta   opAccess         sec         rtsmd1      cmp   #'b'         bne   md2         lda   #BIN         sta   crFileTypemd2      sec         rtsmd3      clc         rts;;  local data areas;op	DC.W	3	;parameter block for OSopenopRefNum		DS.B 2opName		DS.B 4opAccess		DS.B 2gf	DC.W	2	;GetEOF recordgfRefNum		DS.B 2gfEOF		DS.B 4sm	DC.W	3	;SetMark recordsmRefNum		DS.B 2smBase	DC.W	0smDisplacement		DS.B 4ef	DC.W	3	;parameter block for OSSet_EOFefRefNum		DS.B 2	DC.W	0	DC.L	0cr	DC.W	7	;parameter block for OScreatecrPathName		DS.B 4	DC.W	$C3crFileType		DS.B 2	DC.L	0	DC.W	1	DC.L	0	DC.L	0;	DC	R'fgetc';	DC	R'fputc';	DC	R'fclose'		ENDP******************************************************************  FILE *freopen(filename, type, stream)*        char *filename, *type;*        FILE *stream;**  Inputs:*        filename - pointer to the file ;name*        type - pointer to the type string*        stream - file buffer to use**  Outputs:*        X-A - pointer to the file variable; NULL for an error******************************************************************		EXPORT	freopen  freopen  PROCBIN      equ   6                        ;file type for BIN filesTXT      equ   4                        ;file type for TXT filesfileType equ   1                        ;file type letterbuffStart equ  3                        ;start of the file bufferOSname   equ   7                        ;pointer to the GS/OS file namefileBuff equ   11                       ;file buffer to return;;  initialization;;;       csubroutine (4:filename,4:type,4:stream),14	; filename equ   0+4+14type     equ   4+4+14stream   equ   8+4+14         tsc         sec         sbc   #14         tcs         phd         tcd         phb                            ;use our data bank         phk         plb         stz   fileBuff                 ;the open is not legal, yet         stz   fileBuff+2;;       ph4   stream                   ;verify that stream exists	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   ~VerifyStream;;       jcs   rt2         BCC   *+5         BRL   rt2         lda   [type]                   ;make sure the file type is in ['a','r','w']         and   #$00FF         sta   fileType         cmp   #'a'         beq   cl1         cmp   #'w'         beq   cl1         cmp   #'r'         beq   cl1         lda   #EINVAL         sta   >errno         brl   rt2;;  close the old file;cl1      ldy   #FILE_file               ;branch if the file is not a disk file         lda   [stream],Y         bmi   cn1;;       ph4   stream                   ;do any pending I/O	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   fflush         ldy   #FILE_file               ;close the file         lda   [stream],Y         sta   clRefNum;;       OSclose cl         JSL   $E100A8	DC.W	$2014	DC.L	cl         ldy   #FILE_flag               ;if the buffer was allocated by fopen then         lda   [stream],Y         and   #_IOMYBUF         beq   cn1         ldy   #FILE_base+2             ;  dispose of the file buffer         lda   [stream],Y         pha         dey         dey         lda   [stream],Y         pha         jsl   free;;  create a GS/OS file name;;;cn1    ph4   filename                 ;get the length of the name buffercn1	;          LDA   filename+2         PHA         LDA   filename         PHA         jsl   ~osname         sta   OSname         stx   OSname+2         ora   OSname+2;;       jeq   rt2         BNE   *+5         BRL   rt2;;  open the file;         lda   #TXT                     ;we must open a new file - determine it's         sta   crFileType               ; type by looking for the 'b' designator         ldy   #1         lda   [type],Y         and   #$00FF         cmp   #'+'         bne   nl1         iny         lda   [type],Y         and   #$00FFnl1      cmp   #'b'         bne   nl2         lda   #BIN         sta   crFileType;;nl2    move4 OSname,opName            ;try to open an existing file;;nl2    ~SETMnl2	;          LDA   2+OSname         STA   2+opName         LDA   OSname         STA   opName;;       ~RESTM	; ;;       OSopen op         JSL   $E100A8	DC.W	$2010	DC.L	op         bcc   of2         lda   fileType                 ;if the type is 'r', flag an error         cmp   #'r'         bne   of1;;errEIO ph4   streamerrEIO	;          LDA   stream+2         PHA         LDA   stream         PHA         jsr   ~ioerror         brl   rt1;;of1    move4 OSname,crPathName        ;create the file;;of1    ~SETMof1	;          LDA   2+OSname         STA   2+crPathName         LDA   OSname         STA   crPathName;;       ~RESTM	; ;;       OScreate cr         JSL   $E100A8	DC.W	$2001	DC.L	cr         bcs   errEIO;;       OSopen op                      ;open the file         JSL   $E100A8	DC.W	$2010	DC.L	op         bcs   errEIOof2      lda   fileType                 ;if the file type is 'w', reset it         cmp   #'w'         bne   ar1         lda   opRefNum         sta   efRefNum;;       OSSet_EOF ef         JSL   $E100A8	DC.W	$2018	DC.L	ef         bcs   errEIO;;  fill in the file record;;;ar1    ph4   #BUFSIZ                  ;get space for the file bufferar1	;          PEA   +(BUFSIZ)>>16         PEA   BUFSIZ         jsl   malloc         sta   buffStart         stx   buffStart+2         ora   buffStart+2         bne   ar3         lda   #ENOMEM                  ;memory error         sta   >errno         bra   rt1;;ar3    move4 stream,fileBuff          ;set the file buffer address;;ar3    ~SETMar3	;          LDA   2+stream         STA   2+fileBuff         LDA   stream         STA   fileBuff;;       ~RESTM	;          lda   buffStart                ;set the start of the buffer         ldy   #FILE_base         sta   [fileBuff],Y         iny         iny         lda   buffStart+2         sta   [fileBuff],Y         ldy   #FILE_ptr+2         sta   [fileBuff],Y         dey         dey         lda   buffStart         sta   [fileBuff],Y         ldy   #FILE_size               ;set the buffer size         lda   #BUFSIZ         sta   [fileBuff],Y         iny         iny         lda   #^BUFSIZ         sta   [fileBuff],Y         ldy   #1                       ;set the flags         lda   [type],Y         and   #$00FF         cmp   #'+'         bne   ar4         lda   #_IOFBF+_IORW+_IOMYBUF         bra   ar6ar4      lda   fileType         cmp   #'r'         beq   ar5         lda   #_IOFBF+_IOWRT+_IOMYBUF         bra   ar6ar5      lda   #_IOFBF+_IOREAD+_IOMYBUFar6      ldy   #FILE_flag         ldx   crFileType         cpx   #BIN         beq   ar6a         ora   #_IOTEXTar6a     sta   [fileBuff],Y         ldy   #FILE_cnt                ;no chars in buffer         lda   #0         sta   [fileBuff],Y         iny         iny         sta   [fileBuff],Y         ldy   #FILE_pbk                ;nothing in the putback buffer         lda   #$FFFF         sta   [fileBuff],Y         ldy   #FILE_file               ;set the file ID         lda   opRefNum         sta   [fileBuff],Y;;  return the result;;;rt1    ph4   OSname                   ;dispose of the file name bufferrt1	;          LDA   OSname+2         PHA         LDA   OSname         PHA         jsl   freert2      plb                            ;restore caller's data bank;;       creturn 4:fileBuff             ;return	;          ldx   fileBuff+2         ldy   fileBuff         lda   14+2         sta   14+12+2         lda   14+1         sta   14+12+1         pld         tsc         clc         adc   #14+12         tcs         tya         rtl;;  local data areas;op	DC.W	2	;parameter block for OSopenopRefNum		DS.B 2opName		DS.B 4ef	DC.W	3	;parameter block for OSSet_EOFefRefNum		DS.B 2	DC.W	0	DC.L	0cr	DC.W	7	;parameter block for OScreatecrPathName		DS.B 4	DC.W	$C3crFileType		DS.B 2	DC.L	0	DC.W	1	DC.L	0	DC.L	0cl	DC.W	1	;parameter block for OScloseclRefNum		DS.B 2;;  Patch for standard out;stdoutFile jmp stdoutPatchstdoutPatch phb         plx         ply         pla         pha         pha         pha         phy         phx         plb         lda   >stdout         sta   6,S         lda   >stdout+2         sta   8,S         brl   fputc;;  Patch for standard in;stdinFile jmp stdinPatch;;stdinPatch ph4 #stdin+4stdinPatch	;          PEA   +(stdin+4)>>16         PEA   stdin+4         jsl   fgetc         rtl		ENDP******************************************************************  int fprintf(stream, char *format, additional arguments)**  Print the format string to standard out.******************************************************************		EXPORT	fprintf  fprintf  PROC	;using ~printfCommon         phb                            ;use local addressing         phk         plb         plx                            ;remove the return address         ply         pla                            ;save the stream         sta   stream         pla         sta   stream+2         phy                            ;restore return address/data bank         phx         plb         lda   >stream+2                ;verify that stream exists         pha         lda   >stream         pha         jsl   ~VerifyStream         bcc   lb1         lda   #EIO         sta   >errno         lda   #EOF         bra   rtslb1      lda   #put                     ;set up output routine         sta   >~putchar+4         lda   #>put         sta   >~putchar+5         tsc                            ;find the argument list address         clc         adc   #8         sta   >args         pea   0         pha         jsl   ~printf                  ;call the formatter         sec                            ;compute the space to pull from the stack         pla         sbc   >args         clc         adc   #4         sta   >args         pla         phb                            ;remove the return address         plx         ply         tsc                            ;update the stack pointer         clc         adc   >args         tcs         phy                            ;restore the return address         phx         plb         lda   >~numChars               ;return the value         rtl                            ;returnput      phb                            ;remove the char from the stack         phk         plb         plx         pla         ply         pha         phx         plb         lda   stream+2                 ;write to a file         pha         lda   stream         pha         phy         jsl   fputcrts      rtlargs		DS.B 2                        ;original argument addressstream		DS.B 4                        ;stream address		ENDP******************************************************************  int fputc(c, stream)*        char c;*        FILE *stream;**  Write a character to a file**  Inputs:*        c - character to write*        stream - file to write to**  Outputs:*        A - character written; EOF for ;an error******************************************************************		EXPORT	fputc    fputc    PROCc2       equ   5                        ;output charp        equ   1                        ;work pointer;;       csubroutine (2:c,4:stream),6	; c        equ   0+4+6stream   equ   2+4+6         tsc         sec         sbc   #6         tcs         phd         tcd;;       ph4   stream                   ;verify that stream exists	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   ~VerifyStream         bcs   lb0         ldy   #FILE_flag               ;quit with error if the end of file         lda   [stream],Y               ; has been reached or an error has been         and   #_IOEOF+_IOERR           ; encountered         beq   lb1lb0      lda   #EOF         sta   c         brl   pc8lb1      ldy   #FILE_flag               ;if the file is not prepared for         lda   [stream],Y               ; writing then         bit   #_IOWRT         bne   lb2         bit   #_IOREAD                 ;  if it is being read then         bne   pc2                      ;    flag the error         ora   #_IOWRT                  ;  set the writting flag         sta   [stream],Ylb2      ldy   #FILE_file               ;branch if this is a disk file         lda   [stream],Y         bpl   pc3         cmp   #stdoutID                ;if stream = stdout then         bne   pc1;;       ph2   c                        ;  write the character	;          LDA   c         PHA         jsl   ~stdout         brl   pc8pc1      cmp   #stderrID                ;else if stream = stderr then         bne   pc2         lda   c                        ;  (for \n, write \r)         cmp   #10         bne   pc1a         lda   #13pc1a     pha                            ;  write to error out         jsl   SYSCHARERROUT         brl   pc8;;pc2    ph4   stream                   ;else stream = stdin; flag the errorpc2	;          LDA   stream+2         PHA         LDA   stream         PHA         jsr   ~ioerror         lda   #EOF         sta   c         brl   pc8pc3      lda   c                        ;set the output char         sta   c2         ldy   #FILE_flag               ;if this is a text file then         lda   [stream],Y         and   #_IOTEXT         beq   pc3a         lda   c                        ;  if the char is lf then         cmp   #10         bne   pc3a         lda   #13                      ;    substitute a cr         sta   c2pc3a     ldy   #FILE_cnt                ;if the buffer is full then         lda   [stream],Y         iny         iny         ora   [stream],Y         bne   pc4;;pc3b   ph4   stream                   ;  purge itpc3b	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   fflushpc4      ldy   #FILE_ptr                ;deposit the character in the buffer,         lda   [stream],Y               ; incrementing the buffer pointer         sta   p         clc         adc   #1         sta   [stream],Y         iny         iny         lda   [stream],Y         sta   p+2         adc   #0         sta   [stream],Y;;       short M         SEP   #1*32+0*16			LONGA OFF         lda   c2         sta   [p];;       long  M         REP   #1*32+0*16			LONGA ON         ldy   #FILE_cnt                ;dec the buffer counter         sec         lda   [stream],Y         sbc   #1         sta   [stream],Y         bcs   pc5         iny         iny         lda   [stream],Y         dec   A         sta   [stream],Ypc5      ldy   #FILE_cnt                ;if the buffer is full         lda   [stream],Y         iny         iny         ora   [stream],Y         beq   pc7         lda   c2                       ; or if (c = '\n') and (flag & _IOLBF)         cmp   #13         beq   pc5a         cmp   #10         bne   pc6pc5a     ldy   #FILE_flag         lda   [stream],Y         and   #_IOLBF         bne   pc7pc6      ldy   #FILE_flag               ; or is flag & _IONBF then         lda   [stream],Y         and   #_IONBF         beq   pc8;;pc7    ph4   stream                   ;  flush the streampc7	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   fflush;;pc8    creturn 2:cpc8	;          ldy   c         lda   6+2         sta   6+6+2         lda   6+1         sta   6+6+1         pld         tsc         clc         adc   #6+6         tcs         tya         rtl		ENDP******************************************************************  int fputs(str,stream)*     char *str;**  Print the string to standard out.******************************************************************		EXPORT	fputs    fputs    PROCerr      equ   1                        ;return code;;       csubroutine (4:str,4:stream),2	; str      equ   0+4+2stream   equ   4+4+2         tsc         sec         sbc   #2         tcs         phd         tcd;;       ph4   stream                   ;verify that stream exists	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   ~VerifyStream         lda   #EOF         sta   err         bcs   lb4         stz   err                      ;no error so far         bra   lb2                      ;skip initial increment;;lb1    inc4  str                      ;next char;;lb1    ~SETMlb1	;          INC   str         BNE   ~4         INC   2+str;;~4     ~RESTM~4	; ;;lb2    ph4   stream                   ;push the stream, just in case...lb2	;          LDA   stream+2         PHA         LDA   stream         PHA         lda   [str]                    ;exit loop if at end of string         and   #$00FF         beq   lb3         pha                            ;push char to write         jsl   fputc                    ;write the character         cmp   #EOF                     ;loop if no error         bne   lb1         sta   err                      ;set the error code         bra   lb4lb3      pla                            ;remove stream from the stack         pla;;lb4    creturn 2:errlb4	;          ldy   err         lda   2+2         sta   2+8+2         lda   2+1         sta   2+8+1         pld         tsc         clc         adc   #2+8         tcs         tya         rtl		ENDP******************************************************************  size_t fread(ptr, element_size, count, stream)*        void *ptr;*        size_t element_size;*        size_t count;*        FILE *stream;**  Reads element*count bytes to stream, ;putting the bytes in*  ptr.**  Inputs:*        ptr - location to store the bytes read*        element_size - size of each element*        count - number of elements*        stream - file to read from**  Outputs:*        Returns the number of elements ;actually read.******************************************************************		EXPORT	fread    fread    PROCtemp     equ   1;;       csubroutine (4:ptr,4:element_size,4:count,4:stream),4	; ptr      equ   0+4+4element_size equ 4+4+4count    equ   8+4+4stream   equ   12+4+4         tsc         sec         sbc   #4         tcs         phd         tcd         phb         phk         plb         stz   rdTransferCount          ;set the # of elements read         stz   rdTransferCount+2;;       ph4   stream                   ;verify that stream exists	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   ~VerifyStream;;       jcs   lb6         BCC   *+5         BRL   lb6;;       ph4   stream                   ;reset file pointer	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   ~SetFilePointer;;       mul4  element_size,count,rdRequestCount set the # of bytes;;       ~SETM	; ;;       PH4   element_size	;          LDA   element_size+2         PHA         LDA   element_size         PHA;;       PH4   count	;          LDA   count+2         PHA         LDA   count         PHA         JSL   ~MUL4;;       PL4   rdRequestCount	;          PLA         STA   rdRequestCount         PLA         STA   rdRequestCount+2;;       ~RESTM	;          lda   rdRequestCount           ;quit if the request count is 0         ora   rdRequestCount+2;;       jeq   lb6         BNE   *+5         BRL   lb6         ldy   #FILE_file               ;set the file ID number         lda   [stream],Y         bpl   lb2                      ;branch if it is a file         cmp   #stdinID                 ;if the file is stdin then;;       jne   lb6         BEQ   *+5         BRL   lb6         stz   rdTransferCount         stz   rdTransferCount+2         lda   >stdin+4+FILE_flag         and   #_IOEOF;;       jne   lb6         BEQ   *+5         BRL   lb6lb1      jsl   SYSKEYIN                 ;  read the bytes         tax                            ;  branch if not eof         bne   lb1a         lda   #_IOEOF                  ;  set EOF flag         ora   >stdin+4+FILE_flag         sta   >stdin+4+FILE_flag         jsl   SYSKEYIN                 ;  read the closing cr         brl   lb6;;lb1a   short M                        ;  set characterlb1a     SEP   #1*32+0*16			LONGA OFF         sta   [ptr];;       long  M         REP   #1*32+0*16			LONGA ON;;       inc4  rdTransferCount;;       ~SETM	;          INC   rdTransferCount         BNE   ~17         INC   2+rdTransferCount;;~17    ~RESTM~17	; ;;       inc4  ptr;;       ~SETM	;          INC   ptr         BNE   ~20         INC   2+ptr;;~20    ~RESTM~20	; ;;       dec4  rdRequestCount;;       ~SETM	;          LDA   rdRequestCount         BNE   ~23         DEC   2+rdRequestCount~23      DEC   rdRequestCount;;       ~RESTM	;          lda   rdRequestCount         ora   rdRequestCount+2         bne   lb1         bra   lb6lb2      sta   rdRefNum                 ;set the reference number;;       move4 ptr,rdDataBuffer         ;set the start address;;       ~SETM	;          LDA   2+ptr         STA   2+rdDataBuffer         LDA   ptr         STA   rdDataBuffer;;       ~RESTM	; ;;       OSRead rd                      ;read the bytes         JSL   $E100A8	DC.W	$2012	DC.L	rd         bcc   lb5         cmp   #$4C                     ;if the error was $4C then         bne   lb3         jsr   SetEOF                   ;  set the EOF flag         bra   lb5;;lb3    ph4   stream                   ;I/O errorlb3	;          LDA   stream+2         PHA         LDA   stream         PHA         jsr   ~ioerror*                                       ;set the # records read;;lb5    div4  rdTransferCount,element_size;;lb5    ~SETMlb5	; ;;       PH4   rdTransferCount	;          LDA   rdTransferCount+2         PHA         LDA   rdTransferCount         PHA;;       PH4   element_size	;          LDA   element_size+2         PHA         LDA   element_size         PHA         JSL   ~DIV4;;       PL4   rdTransferCount	;          PLA         STA   rdTransferCount         PLA         STA   rdTransferCount+2         PLA         PLA;;       ~RESTM	;          lda   count                    ;if there were too few elements read then         cmp   rdTransferCount         bne   lb5a         lda   count+2         cmp   rdTransferCount+2         beq   lb6lb5a     jsr   SetEOF                   ;  set the EOF flag;;lb6    move4 rdTransferCount,temp;;lb6    ~SETMlb6	;          LDA   2+rdTransferCount         STA   2+temp         LDA   rdTransferCount         STA   temp;;       ~RESTM	;          plb;;       creturn 4:temp	;          ldx   temp+2         ldy   temp         lda   4+2         sta   4+16+2         lda   4+1         sta   4+16+1         pld         tsc         clc         adc   #4+16         tcs         tya         rtl;;  Local data;rd	DC.W	5	;parameter block for OSReadrdRefNum		DS.B 2rdDataBuffer		DS.B 4rdRequestCount		DS.B 4rdTransferCount		DS.B 4	DC.W	1;;  Set the EOF flag;SetEOF   ldy   #FILE_flag               ;  set the eof flag         lda   [stream],Y         ora   #_IOEOF         sta   [stream],Y         rts		ENDP******************************************************************  int fscanf(stream, format, additional arguments)*     char *format;*     FILE *stream;**  Read a string from a string.******************************************************************		EXPORT	fscanf   fscanf   PROC	;using ~scanfCommon         phb                            ;use local addressing         phk         plb         plx                            ;remove the return address         ply         pla                            ;save the stream         sta   stream         pla         sta   stream+2         phy                            ;restore return address/data bank         phx         plb;;       ph4   >stream                  ;verify that stream exists	;          LDA   >stream+2         PHA         LDA   >stream         PHA         jsl   ~VerifyStream         bcc   lb1         lda   #EOF         rtllb1      lda   #get                     ;set up our routines         sta   >~getchar+10         lda   #>get         sta   >~getchar+11         lda   #unget         sta   >~putback+12         lda   #>unget         sta   >~putback+13         brl   ~scanf;;get    ph4   stream                   ;get a characterget	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   fgetc         rtlunget    ldx   stream+2                 ;put a character back         phx         ldx   stream         phx         pha         jsl   ungetc         rtlstream		DS.B 4		ENDP******************************************************************  int fseek(stream,offset,wherefrom)*        FILE *stream;*        long int offset;*        int wherefrom;**  Change the read/write location for the stream.**  Inputs:*        stream - file to change*        offset - position to move to*        wherefrom - move relative to this location**  Outputs:*        Returns non-zero for error******************************************************************		EXPORT	fseek    fseek    PROCerr      equ   1                        ;return value;;       csubroutine (4:stream,4:offset,2:wherefrom),2	; stream   equ   0+4+2offset   equ   4+4+2wherefrom equ  8+4+2         tsc         sec         sbc   #2         tcs         phd         tcd         phb         phk         plb         lda   #-1                      ;assume we will get an error         sta   err;;       ph4   stream                   ;verify that stream exists	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   ~VerifyStream;;       jcs   rts         BCC   *+5         BRL   rts;;       ph4   stream                   ;purge the file	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   fflush         ldy   #FILE_file               ;set the file reference         lda   [stream],Y;;       jmi   lb6         BPL   *+5         BRL   lb6         sta   gpRefNum         sta   spRefNum         lda   wherefrom                ;if position is relative to the end then         cmp   #SEEK_END         bne   lb2;;       OSGet_EOF gp                   ;  get the eof         JSL   $E100A8	DC.W	$2019	DC.L	gp;;       jcs   erEIO         BCC   *+5         BRL   erEIO;;       add4  offset,gpPosition        ;  add it to the offset;;       ~SETM	;          CLC;;       ~LDA  offset         LDA   offset;;       ~OP   ADC,gpPosition         ADC   gpPosition;;       ~STA  offset         STA   offset;;       ~LDA.H offset	;          LDA   2+offset;;       ~OP.H ADC,gpPosition	;          ADC   2+gpPosition;;       ~STA.H offset	;          STA   2+offset;;       ~RESTM	;          bra   lb3lb2      cmp   #SEEK_CUR                ;else if relative to current position then         bne   lb3;;       ph4   stream                   ;  get the current position	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   ftell         clc                            ;  add it to the offset         adc   offset         sta   offset         txa         adc   offset+2         sta   offset+2;;lb3    OSGet_EOF gp                   ;get the end of the filelb3      JSL   $E100A8	DC.W	$2019	DC.L	gp;;       jcs   erEIO         BCC   *+5         BRL   erEIO         lda   offset+2                 ;if the offset is >= EOF then         cmp   gpPosition+2         bne   lb4         lda   offset         cmp   gpPosition;;lb4    ble   lb5lb4      BLT   lb5         BEQ   lb5;;       move4 offset,spPosition        ;  extend the file;;       ~SETM	;          LDA   2+offset         STA   2+spPosition         LDA   offset         STA   spPosition;;       ~RESTM	; ;;       OSSet_EOF sp         JSL   $E100A8	DC.W	$2018	DC.L	sp         bcs   erEIO;;lb5    move4 offset,spPosition;;lb5    ~SETMlb5	;          LDA   2+offset         STA   2+spPosition         LDA   offset         STA   spPosition;;       ~RESTM	; ;;       OSSet_Mark sp         JSL   $E100A8	DC.W	$2016	DC.L	sp         bcs   erEIOlb6      ldy   #FILE_flag               ;clear the EOF , READ, WRITE flags         lda   #$FFFF-_IOEOF-_IOREAD-_IOWRT         and   [stream],Y         sta   [stream],Y         ldy   #FILE_cnt                ;clear the character count         lda   #0         sta   [stream],Y         iny         iny         sta   [stream],Y         ldy   #FILE_base+2             ;reset the file pointer         lda   [stream],Y         tax         dey         dey         lda   [stream],Y         ldy   #FILE_ptr         sta   [stream],Y         iny         iny         txa         sta   [stream],Y         ldy   #FILE_size               ;set the buffer size         ldy   #FILE_pbk                ;nothing in the putback buffer         lda   #$FFFF         sta   [stream],Y         stz   errrts      plb;;       creturn 2:err	;          ldy   err         lda   2+2         sta   2+10+2         lda   2+1         sta   2+10+1         pld         tsc         clc         adc   #2+10         tcs         tya         rtl;;erEIO  ph4   stream                   ;flag an IO errorerEIO	;          LDA   stream+2         PHA         LDA   stream         PHA         jsr   ~ioerror         bra   rtsgp	DC.W	2	;parameter block for OSGet_EOFgpRefNum		DS.B 2gpPosition		DS.B 4sp	DC.W	3	;parameter block for OSSet_EOFspRefNum		DS.B 2                        ; and OSSet_Mark	DC.W	0spPosition		DS.B 4		ENDP******************************************************************  int fsetpos(FILE *stream, fpos_t *pos);**  Inputs:*        stream - pointer to stream to set position of*        pos - pointer to location to set position**  Outputs:*        A - 0 if successful; else -1 if not*        errno - if unsuccessful, errno ;is set to EIO******************************************************************		EXPORT	fsetpos  fsetpos  PROCerr      equ   1                        ;error code;;       csubroutine (4:stream,4:pos),2	; stream   equ   0+4+2pos      equ   4+4+2         tsc         sec         sbc   #2         tcs         phd         tcd;;       ph2   #SEEK_CNT	;          PEA   SEEK_CNT         ldy   #2         lda   [pos],Y         pha         lda   [pos]         pha;;       ph4   stream	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   fseek         sta   err;;       creturn 2:err	;          ldy   err         lda   2+2         sta   2+8+2         lda   2+1         sta   2+8+1         pld         tsc         clc         adc   #2+8         tcs         tya         rtl		ENDP******************************************************************  long int ftell(stream)*        FILE *stream;**  Find the number of characters already passed in the file.**  Inputs:*        stream - strem to find the location in**  Outputs:*        Returns the position, or -1L for an error.******************************************************************		EXPORT	ftell    ftell    PROCpos      equ   1                        ;position in the file;;       csubroutine (4:stream),4	; stream   equ   0+4+4         tsc         sec         sbc   #4         tcs         phd         tcd         phb         phk         plb         lda   #-1                      ;assume an error         sta   pos         sta   pos+2;;       ph4   stream                   ;verify that stream exists	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   ~VerifyStream         bcs   rts;;       ph4   stream                   ;do any pending writes	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   fflush         tax         bne   rts         ldy   #FILE_file               ;get the file's mark         lda   [stream],Y         sta   gmRefNum;;       OSGet_Mark gm         JSL   $E100A8	DC.W	$2017	DC.L	gm         bcc   lb1;;       ph4   stream	;          LDA   stream+2         PHA         LDA   stream         PHA         jsr   ~ioerror         bra   rts;;lb1    move4 gmPosition,pos           ;set the position;;lb1    ~SETMlb1	;          LDA   2+gmPosition         STA   2+pos         LDA   gmPosition         STA   pos;;       ~RESTM	;          ldy   #FILE_flag               ;if the file is being read then         lda   [stream],Y         bit   #_IOREAD         beq   rts         sec                            ;  subtract off characters left to be         ldy   #FILE_cnt                ;    read         lda   pos         sbc   [stream],Y         sta   pos         iny         iny         lda   pos+2         sbc   [stream],Y         sta   pos+2         ldy   #FILE_pbk                ;  if there is a char in the putback         lda   [stream],Y               ;    buffer then         and   #$0080         bne   rts;;       dec4  pos                      ;    dec pos by 1;;       ~SETM	;          LDA   pos         BNE   ~10         DEC   2+pos~10      DEC   pos;;       ~RESTM	; rts      plb;;       creturn 4:pos	;          ldx   pos+2         ldy   pos         lda   4+2         sta   4+4+2         lda   4+1         sta   4+4+1         pld         tsc         clc         adc   #4+4         tcs         tya         rtlgm	DC.W	2	;parameter block for OSGetMarkgmRefNum		DS.B 2gmPosition		DS.B 4		ENDP******************************************************************  size_t fwrite(ptr, element_size, count, stream)*        void *ptr;*        size_t element_size;*        size_t count;*        FILE *stream;**  Writes element*count bytes to stream, taking the bytes from*  ptr.**  Inputs:*        ptr - pointer to the bytes to write*        element_size - size of each element*        count - number of elements*        stream - file to write to**  Outputs:*        Returns the number of elements ;actually written.******************************************************************		EXPORT	fwrite   fwrite   PROC;;       csubroutine (4:ptr,4:element_size,4:count,4:stream),0	; ptr      equ   0+4+0element_size equ 4+4+0count    equ   8+4+0stream   equ   12+4+0         tsc         phd         tcd         phb         phk         plb         stz   wrTransferCount          ;set the # of elements written         stz   wrTransferCount+2;;       ph4   stream                   ;verify that stream exists	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   ~VerifyStream;;       jcs   lb6         BCC   *+5         BRL   lb6;;       mul4  element_size,count,wrRequestCount set the # of bytes;;       ~SETM	; ;;       PH4   element_size	;          LDA   element_size+2         PHA         LDA   element_size         PHA;;       PH4   count	;          LDA   count+2         PHA         LDA   count         PHA         JSL   ~MUL4;;       PL4   wrRequestCount	;          PLA         STA   wrRequestCount         PLA         STA   wrRequestCount+2;;       ~RESTM	;          lda   wrRequestCount           ;quit if the request count is 0         ora   wrRequestCount+2;;       jeq   lb6         BNE   *+5         BRL   lb6         ldy   #FILE_file               ;set the file ID number         lda   [stream],Y         bpl   lb4                      ;branch if it is a file         cmp   #stdoutID                ;if the file is stdout then         bne   lb2lb1      lda   [ptr]                    ;  write the bytes         pha         jsl   ~stdout;;       inc4  ptr;;       ~SETM	;          INC   ptr         BNE   ~12         INC   2+ptr;;~12    ~RESTM~12	; ;;       dec4  wrRequestCount;;       ~SETM	;          LDA   wrRequestCount         BNE   ~15         DEC   2+wrRequestCount~15      DEC   wrRequestCount;;       ~RESTM	;          lda   wrRequestCount         ora   wrRequestCount+2         bne   lb1;;       move4 count,wrTransferCount    ;set the # of elements written;;       ~SETM	;          LDA   2+count         STA   2+wrTransferCount         LDA   count         STA   wrTransferCount;;       ~RESTM	;          bra   lb6lb2      cmp   #stderrID                ;if the file is stderr then         bne   lb6lb3      lda   [ptr]                    ;  write the bytes         pha         jsl   SYSCHARERROUT;;       inc4  ptr;;       ~SETM	;          INC   ptr         BNE   ~21         INC   2+ptr;;~21    ~RESTM~21	; ;;       dec4  wrRequestCount;;       ~SETM	;          LDA   wrRequestCount         BNE   ~24         DEC   2+wrRequestCount~24      DEC   wrRequestCount;;       ~RESTM	;          lda   wrRequestCount         ora   wrRequestCount+2         bne   lb3;;       move4 count,wrTransferCount    ;set the # of elements written;;       ~SETM	;          LDA   2+count         STA   2+wrTransferCount         LDA   count         STA   wrTransferCount;;       ~RESTM	;          bra   lb6lb4      sta   wrRefNum                 ;set the reference number;;       ph4   stream                   ;purge the file	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   fflush;;       move4 ptr,wrDataBuffer         ;set the start address;;       ~SETM	;          LDA   2+ptr         STA   2+wrDataBuffer         LDA   ptr         STA   wrDataBuffer;;       ~RESTM	; ;;       OSWrite wr                     ;write the bytes         JSL   $E100A8	DC.W	$2013	DC.L	wr         bcc   lb5;;       ph4   stream                   ;I/O error	;          LDA   stream+2         PHA         LDA   stream         PHA         jsr   ~ioerror*                                       ;set the # records written;;lb5    div4  wrTransferCount,element_size;;lb5    ~SETMlb5	; ;;       PH4   wrTransferCount	;          LDA   wrTransferCount+2         PHA         LDA   wrTransferCount         PHA;;       PH4   element_size	;          LDA   element_size+2         PHA         LDA   element_size         PHA         JSL   ~DIV4;;       PL4   wrTransferCount	;          PLA         STA   wrTransferCount         PLA         STA   wrTransferCount+2         PLA         PLA;;       ~RESTM	; lb6      plb;;       creturn 4:count                ;return	;          ldx   count+2         ldy   count         lda   0+2         sta   0+16+2         lda   0+1         sta   0+16+1         pld         tsc         clc         adc   #0+16         tcs         tya         rtlwr	DC.W	5	;parameter block for OSReadwrRefNum		DS.B 2wrDataBuffer		DS.B 4wrRequestCount		DS.B 4wrTransferCount		DS.B 4	DC.W	1		ENDP******************************************************************  int getchar()**  Read a character from standard in.  No errors are possible.**  The character read is returned in A. ; The null character*  is mapped into EOF.******************************************************************		EXPORT	getchar  getchar  PROC;;  Determine which method to use;         lda   >stdin                   ;use fgetc if stdin has changed         cmp   #stdin+4         bne   fl1         lda   >stdin+2         cmp   #^stdin+4         bne   fl1         lda   >stdin+4+FILE_file       ;use fgetc if stdio has a bogus file ID         cmp   #stdinID         bne   fl1;;  get the char from the keyboard;         lda   >stdin+4+FILE_pbk        ;if there is a char in the putback         and   #$0080                   ; buffer then         bne   lb1         lda   >stdin+4+FILE_pbk        ;  save it in x         and   #$00FF         tax         lda   >stdin+4+FILE_pbk        ;  pop the buffer         xba         ora   #$FF00         sta   >stdin+4+FILE_pbk         txa                            ;  restore the char         bra   lb2lb1      jsl   SYSKEYIN                 ;else get a char from the keyboard         tax                            ;  branch if not eof         bne   lb2         lda   #_IOEOF                  ;  set EOF flag         ora   >stdin+4+FILE_flag         sta   >stdin+4+FILE_flag         jsl   SYSKEYIN                 ;  read the closing cr         lda   #EOF                     ;  return EOFlb2      cmp   #13                      ;if the char is \r then         bne   lb3         lda   #10                      ;  return \nlb3      rtl;;  Call fgetc;;;fl1    ph4   >stdinfl1	;          LDA   >stdin+2         PHA         LDA   >stdin         PHA	DC.B	$22	;jsl   fgetc	DC.A	fgetc         rtl		ENDP******************************************************************  char *gets(str)*        char str;**  Read a line from standard in.**  Inputs:*        str - string to read to.**  Outputs:*        Returns a pointer to the string******************************************************************		EXPORT	gets     gets     PROCLF       equ   10                       ;\n key codedisp     equ   1                        ;disp in str;;       csubroutine (4:str),2	; str      equ   0+4+2         tsc         sec         sbc   #2         tcs         phd         tcd         stz   disp                     ;no characters processed so farlb1      jsl   getchar                  ;get a character         tax                            ;quit with error if it is an EOF         bpl   lb2         stz   str         stz   str+2         bra   rtslb2      cmp   #LF                      ;quit if it was a \n         beq   lb3         ldy   disp                     ;place the char in the string         sta   [str],Y         inc   disp         bra   lb1                      ;next characterlb3      ldy   disp                     ;null terminate;;       short M         SEP   #1*32+0*16			LONGA OFF         lda   #0         sta   [str],Y;;       long  M         REP   #1*32+0*16			LONGA ON;;rts    creturn 4:strrts	;          ldx   str+2         ldy   str         lda   2+2         sta   2+4+2         lda   2+1         sta   2+4+1         pld         tsc         clc         adc   #2+4         tcs         tya         rtl		ENDP******************************************************************  void perror(str);*        char *str;**  Prints the string str and the error in ;errno to standard out.******************************************************************		EXPORT	perror   perror   PROCmaxErr   equ   ENOSPC                   ;max error in sys_errliststr      equ   4                        ;string address         tsc                            ;set up DP addressing         phd         tcd;;       ph4   >stderr                  ;write the error string	;          LDA   >stderr+2         PHA         LDA   >stderr         PHA;;       ph4   str	;          LDA   str+2         PHA         LDA   str         PHA         jsl   fputs;;       ph4   >stderr                  ;write ': '	;          LDA   >stderr+2         PHA         LDA   >stderr         PHA         pea   ':'         jsl   fputc;;       ph4   >stderr	;          LDA   >stderr+2         PHA         LDA   >stderr         PHA         pea   ' '         jsl   fputc;;       ph4   >stderr                  ;write the error message	;          LDA   >stderr+2         PHA         LDA   >stderr         PHA         lda   >errno         cmp   #maxErr+1         blt   lb1         lda   #0lb1      asl   A         asl   A         tax         lda   >sys_errlist+2,X         pha         lda   >sys_errlist,X         pha         jsl   fputs;;       ph4   >stderr                  ;write lf, cr	;          LDA   >stderr+2         PHA         LDA   >stderr         PHA         pea   10         jsl   fputc;;       ph4   >stderr	;          LDA   >stderr+2         PHA         LDA   >stderr         PHA         pea   13         jsl   fputc         pld                            ;remove parm and return         lda   2,S         sta   6,S         pla         sta   3,S         pla         rtl		ENDP******************************************************************  int printf(format, additional arguments)*     char *format;**  Print the format string to standard out.******************************************************************		EXPORT	printf   printf   PROC	;using ~printfCommon         lda   #putchar         sta   >~putchar+4         lda   #>putchar         sta   >~putchar+5         tsc                            ;find the argument list address         clc         adc   #8         sta   >args         pea   0         pha         jsl   ~printf                  ;call the formatter         sec                            ;compute the space to pull from the stack         pla         sbc   >args         clc         adc   #4         sta   >args         pla         phb                            ;remove the return address         plx         ply         tsc                            ;update the stack pointer         clc         adc   >args         tcs         phy                            ;restore the return address         phx         plb         lda   >~numChars               ;return the value         rtl                            ;returnargs		DS.B 2                        ;original argument address		ENDP******************************************************************  int putchar(c)*     char c;**  Print the character to standard out. ; The character is*  returned.  No errors are possible.**  The character \n is automatically followed by a $0D, which*  causes the IIGS to respond the way \n works on other machines.******************************************************************		EXPORT	putchar  putchar  PROC	;using ~printfCommon_n       equ   10                       ;linefeed character_r       equ   13                       ;RETURN key code;;  Determine which method to use;         lda   >stdout                  ;use fgetc if stdin has changed         cmp   #stdout+4         bne   fl1         lda   >stdout+1         cmp   #>stdout+4         bne   fl1         lda   >stdout+4+FILE_file      ;use fgetc if stdio has a bogus file ID         cmp   #stdoutID         bne   fl1;;  Write to the CRT;		EXPORT	~stdout~stdout		;		         php                            ;remove the parameter from the stack         plx         ply         pla         phy         phx         plp         pha                            ;save the parameter         cmp   #_n                      ;if this is a line feed, do a         bne   lb1                      ; carriage return, instead.         lda   #_rlb1      pha                            ;write the character         jsl   SYSCHAROUT         pla                            ;return the input character         rtl;;  Use fputc;;;fl1    ph4   >stdoutfl1	;          LDA   >stdout+2         PHA         LDA   >stdout         PHA         lda   8,S         pha	DC.B	$22	;jsl   fputc	DC.A	fputc         phb         plx         ply         pla         phy         phx         plb         rtl		ENDP******************************************************************  int puts(str)*     char *str;**  Print the string to standard out.  A ;zero is returned; no*  error is possible.******************************************************************		EXPORT	puts     puts     PROCLINEFEED equ   10                       ;linefeed charactererr      equ   1                        ;erro code;;       csubroutine (4:str),2	; str      equ   0+4+2         tsc         sec         sbc   #2         tcs         phd         tcd         stz   err                      ;no errorlb1      lda   [str]                    ;print the string         and   #$00FF         beq   lb2         pha         jsl   putchar;;       inc4  str;;       ~SETM	;          INC   str         BNE   ~3         INC   2+str;;~3     ~RESTM~3	;          bra   lb1lb2      pea   LINEFEED                 ;print the linefeed         jsl   putchar;;       creturn 2:err	;          ldy   err         lda   2+2         sta   2+4+2         lda   2+1         sta   2+4+1         pld         tsc         clc         adc   #2+4         tcs         tya         rtl		ENDP******************************************************************  int remove(filename)*        char *filename;**  Inputs:*        filename - name of the file to ;delete**  Outputs:*        Returns zero if successful, GS/OS error code if not.******************************************************************		EXPORT	remove   remove   PROCerr      equ   1                        ;return code;;       csubroutine (4:filename),2	; filename equ   0+4+2         tsc         sec         sbc   #2         tcs         phd         tcd         phb         phk         plb;;       ph4   filename                 ;convert to a GS/OS file name	;          LDA   filename+2         PHA         LDA   filename         PHA         jsl   ~osname         sta   dsPathName         stx   dsPathName+2         ora   dsPathName+2         bne   lb1         lda   #$FFFF         sta   err         bra   lb2;;lb1    OSDestroy ds                   ;delete the filelb1      JSL   $E100A8	DC.W	$2002	DC.L	ds         sta   err                      ;set the error code         bcc   lb1a         lda   #ENOENT         sta   >errno;;lb1a   ph4   dsPathName               ;dispose of the name bufferlb1a	;          LDA   dsPathName+2         PHA         LDA   dsPathName         PHA         jsl   freelb2      plb;;       creturn 2:err	;          ldy   err         lda   2+2         sta   2+4+2         lda   2+1         sta   2+4+1         pld         tsc         clc         adc   #2+4         tcs         tya         rtlds	DC.W	1	;parameter block for OSDestroydsPathName		DS.B 4		ENDP******************************************************************  int rename(oldname,newname)*        char *filename;**  Inputs:*        filename - name of the file to ;delete**  Outputs:*        Returns zero if successful, GS/OS error code if not.******************************************************************		EXPORT	rename   rename   PROCerr      equ   1                        ;return code;;       csubroutine (4:oldname,4:newname),2	; oldname  equ   0+4+2newname  equ   4+4+2         tsc         sec         sbc   #2         tcs         phd         tcd         phb         phk         plb;;       ph4   oldname                  ;convert oldname to a GS/OS file name	;          LDA   oldname+2         PHA         LDA   oldname         PHA         jsl   ~osname         sta   cpPathName         stx   cpPathName+2         ora   cpPathName+2         bne   lb1         lda   #$FFFF         sta   err         bra   lb4;;lb1    ph4   newname                  ;convert newname to a GS/OS file namelb1	;          LDA   newname+2         PHA         LDA   newname         PHA         jsl   ~osname         sta   cpNewPathName         stx   cpNewPathName+2         ora   cpNewPathName+2         bne   lb2         lda   #$FFFF         sta   err         bra   lb3;;lb2    OSChange_Path cp               ;rename the filelb2      JSL   $E100A8	DC.W	$2004	DC.L	cp         sta   err                      ;set the error code;;       ph4   cpNewPathName            ;dispose of the new name buffer	;          LDA   cpNewPathName+2         PHA         LDA   cpNewPathName         PHA         jsl   free;;lb3    ph4   cpPathName               ;dispose of the old name bufferlb3	;          LDA   cpPathName+2         PHA         LDA   cpPathName         PHA         jsl   freelb4      plb;;       creturn 2:err	;          ldy   err         lda   2+2         sta   2+8+2         lda   2+1         sta   2+8+1         pld         tsc         clc         adc   #2+8         tcs         tya         rtlcp	DC.W	2	;parameter block for OSChange_PathcpPathName		DS.B 4cpNewPathName		DS.B 4		ENDP******************************************************************  int scanf(format, additional arguments)*     char *format;**  Read a string from standard in.******************************************************************		EXPORT	scanf    scanf    PROC	;using ~scanfCommon         lda   #getchar         sta   >~getchar+10         lda   #>getchar         sta   >~getchar+11         lda   #unget         sta   >~putback+12         lda   #>unget         sta   >~putback+13         brl   ~scanfunget    tax         lda   >stdin+2         pha         lda   >stdin         pha         phx         jsl   ungetc         rtl		ENDP******************************************************************  int setvbuf(stream,buf,type,size)*        FILE *stream;*        char *buf;*        int type,size;**  Set the buffer type and size.**  Inputs:*        stream - file to set the buffer for*        buf - buffer to use, or NULL for automatic buffer*        type - buffer type; _IOFBF, _IOLBF or _IONBF*        size - size of the buffer**  Outputs:*        Returns zero if successful, -1 ;for an error******************************************************************		EXPORT	setvbuf  setvbuf  PROCerr      equ   1                        ;return code;;       csubroutine (4:stream,4:buf,2:type,4:size),2	; stream   equ   0+4+2buf      equ   4+4+2type     equ   8+4+2size     equ   10+4+2         tsc         sec         sbc   #2         tcs         phd         tcd         phb         phk         plb         lda   #-1                      ;assume we will get an error         sta   err;;       ph4   stream                   ;verify that stream exists	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   ~VerifyStream;;       jcs   rts         BCC   *+5         BRL   rts         ldy   #FILE_ptr                ;make sure the buffer is not in use         lda   [stream],Y         ldy   #FILE_base         cmp   [stream],Y;;       jne   rts         BEQ   *+5         BRL   rts         ldy   #FILE_ptr+2         lda   [stream],Y         ldy   #FILE_base+2         cmp   [stream],Y;;       jne   rts         BEQ   *+5         BRL   rtscb1      lda   size                     ;if size is zero then         ora   size+2         bne   lb1         lda   type                     ; if ~(type & _IONBF) then         and   #_IONBF;;       jeq   rts                      ;    flag the error         BNE   *+5         BRL   rts         inc   size                     ;  else size = 1lb1      lda   type                     ;error if type is not one of these         cmp   #_IOFBF         beq   lb2         cmp   #_IOLBF         beq   lb2         cmp   #_IONBF         bne   rtslb2      lda   buf                      ;if the buffer is not supplied by the         ora   buf+2                    ;  caller then         bne   sb1;;       ph4   size                     ;  allocate a buffer	;          LDA   size+2         PHA         LDA   size         PHA         jsl   malloc         sta   buf         stx   buf+2         ora   buf+2                    ;  quit if there was no memory         beq   rts         lda   type                     ;  set the buffer flag         ora   #_IOMYBUF         sta   typesb1      ldy   #FILE_flag               ;if the buffer was allocated by fopen then         lda   [stream],Y         bit   #_IOMYBUF         beq   sb2         ldy   #FILE_base+2             ;  dispose of the old buffer         lda   [stream],Y         pha         dey         dey         lda   [stream],Y         pha         jsl   freesb2      ldy   #FILE_flag               ;clear the old buffering flags         lda   #$FFFF-_IOFBF-_IOLBF-_IONBF-_IOMYBUF         and   [stream],Y         ora   type                     ;set the new buffer flag         sta   [stream],Y         lda   buf                      ;set the start of the buffer         ldy   #FILE_base         sta   [stream],Y         iny         iny         lda   buf+2         sta   [stream],Y         ldy   #FILE_ptr+2         sta   [stream],Y         dey         dey         lda   buf         sta   [stream],Y         ldy   #FILE_size               ;set the buffer size         lda   size         sta   [stream],Y         iny         iny         lda   size+2         sta   [stream],Y         ldy   #FILE_cnt                ;no chars in buffer         lda   #0         sta   [stream],Y         iny         iny         sta   [stream],Y         stz   err                      ;no errorrts      plb;;       creturn 2:err	;          ldy   err         lda   2+2         sta   2+14+2         lda   2+1         sta   2+14+1         pld         tsc         clc         adc   #2+14         tcs         tya         rtl		ENDP******************************************************************  int sprintf(str, format, additional arguments)*     char *format;**  Print the format string to a string.******************************************************************		EXPORT	sprintf  sprintf  PROC	;using ~printfCommon         phb                            ;use local addressing         phk         plb         plx                            ;remove the return address         ply         pla                            ;save the stream         sta   string         pla         sta   string+2         phy                            ;restore return address/data bank         phx         plb         lda   #put                     ;set up output routine         sta   >~putchar+4         lda   #>put         sta   >~putchar+5         tsc                            ;find the argument list address         clc         adc   #8         sta   >args         pea   0         pha         jsl   ~printf                  ;call the formatter         sec                            ;compute the space to pull from the stack         pla         sbc   >args         clc         adc   #4         sta   >args         pla         phb                            ;remove the return address         plx         ply         tsc                            ;update the stack pointer         clc         adc   >args         tcs         phy                            ;restore the return address         phx         plb         lda   >~numChars               ;return the value         rtl                            ;returnput      phb                            ;remove the char from the stack         plx         pla         ply         pha         phx         plb         ldx   string+2                 ;write to a file         phx         ldx   string         phx         phd         tsc         tcd         tya         and   #$00FF         sta   [3]         pld         pla         pla         phb         phk         plb;;       inc4  string;;       ~SETM	;          INC   string         BNE   ~2         INC   2+string;;~2     ~RESTM~2	;          plb         rtlargs		DS.B 2                        ;original argument addressstring		DS.B 4                        ;string address		ENDP******************************************************************  int sscanf(str, format, additional arguments)*     char *str, *format;**  Read a string from a string.******************************************************************		EXPORT	sscanf   sscanf   PROC	;using ~scanfCommon         phb                            ;use local addressing         phk         plb         plx                            ;remove the return address         ply         pla                            ;save the stream         sta   string         pla         sta   string+2         phy                            ;restore return address/data bank         phx         plb         lda   #get                     ;set up our routines         sta   >~getchar+10         lda   #>get         sta   >~getchar+11         lda   #unget         sta   >~putback+12         lda   #>unget         sta   >~putback+13         brl   ~scanf;;get    ph4   string                   ;get a characterget	;          LDA   string+2         PHA         LDA   string         PHA         phd         tsc         tcd         lda   [3]         and   #$00FF         bne   gt1;;       dec4  string;;       ~SETM	;          LDA   string         BNE   ~3         DEC   2+string~3       DEC   string;;       ~RESTM	;          lda   #EOFgt1      pld         ply         ply;;       inc4  string;;       ~SETM	;          INC   string         BNE   ~6         INC   2+string;;~6     ~RESTM~6	;          rtlunget    cmp   #EOF                     ;put a character back         beq   ug1;;       dec4  string;;       ~SETM	;          LDA   string         BNE   ~9         DEC   2+string~9       DEC   string;;       ~RESTM	; ug1      rtlstring		DS.B 4		ENDP******************************************************************  sys_errlist - array of pointers to messages******************************************************************		EXPORT	sys_errlist sys_errlist PROC	DC.L	~EUNDEF	;0th message is undefined	DC.L	~EDOM	;(if the size of this list changes,	DC.L	~ERANGE	; change sys_nerr in VARS.ASM)	DC.L	~ENOMEM	DC.L	~ENOENT	DC.L	~EIO	DC.L	~EINVAL	DC.L	~EBADF	DC.L	~EMFILE	DC.L	~EACCESS	DC.L	~EEXISTS	DC.L	~ENOSPC* Note: if more errors are added, change maxErr in perror().;;EUNDEF cstr  'invalid error number'~EUNDEF	DC.B	'invalid error number'	DC.B	0;;EDOM   cstr  'domain error'~EDOM	DC.B	'domain error'	DC.B	0;;ERANGE cstr  '# too large, too small, ;or illegal'~ERANGE	DC.B	'# too large, too small, or illegal'	DC.B	0;;ENOMEM cstr  'not enough memory'~ENOMEM	DC.B	'not enough memory'	DC.B	0;;ENOENT cstr  'no such file or directory'~ENOENT	DC.B	'no such file or directory'	DC.B	0;;EIO    cstr  'I/O error'~EIO	DC.B	'I/O error'	DC.B	0;;EINVAL cstr  'invalid argument'~EINVAL	DC.B	'invalid argument'	DC.B	0;;EBADF  cstr  'bad file descriptor'~EBADF	DC.B	'bad file descriptor'	DC.B	0;;EMFILE cstr  'too many files are open'~EMFILE	DC.B	'too many files are open'	DC.B	0;;EACCESS cstr 'access bits prevent the ;operation'~EACCESS	DC.B	'access bits prevent the operation'	DC.B	0;;EEXISTS cstr 'the file exists'~EEXISTS	DC.B	'the file exists'	DC.B	0;;ENOSPC cstr  'the file is too large'~ENOSPC	DC.B	'the file is too large'	DC.B	0		ENDP******************************************************************  char *tmpnam(buf)*        char *buf;**  Inputs:*        buf - Buffer to write the name ;to.  Buf is assumed to*              be at least L_tmpnam characters long.  It may be*              NULL, in which case the name is not written to*              a buffer.**  Outputs:*        Returns a pointer to the name, ;which is changed on the*        next call to tmpnam or tmpfile.**  Notes:*        If the work prefix is set, and ;is less than or equal*        to 15 characters in length, the file name returned is*        in the work prefix (3); otherwise, it is a partial path*        name.******************************************************************		EXPORT	tmpnam   tmpnam   PROC;;       csubroutine (4:buf),0	; buf      equ   0+4+0         tsc         phd         tcd         phb         phk         plb;;lb1    OSGet_Prefix pr                ;get the prefixlb1      JSL   $E100A8	DC.W	$200A	DC.L	pr         bcc   lb2         stz   name+2;;lb2    short Mlb2      SEP   #1*32+0*16			LONGA OFF         ldx   name+2         stz   cname,X         ldx   #7                       ;update the file numberlb3      inc   syscxxxx,X         lda   syscxxxx,X         cmp   #'9'+1         bne   lb4         lda   #'0'         sta   syscxxxx,X         dex         cpx   #3         bne   lb3;;lb4    long  M                        ;append the two stringslb4      REP   #1*32+0*16			LONGA ON;;       ph4   #syscxxxx	;          PEA   +(syscxxxx)>>16         PEA   syscxxxx;;       ph4   #cname	;          PEA   +(cname)>>16         PEA   cname         jsl   strcat;;       ph4   #cname                   ;if the file exists then	;          PEA   +(cname)>>16         PEA   cname         jsl   strlen         sta   name+2;;       OSGet_File_Info GIParm         JSL   $E100A8	DC.W	$2006	DC.L	GIParm         bcc   lb1                      ;   get a different name         lda   buf                      ;if buf != NULL then         ora   buf+2         beq   lb5;;       ph4   #cname                   ;   move the string	;          PEA   +(cname)>>16         PEA   cname;;       ph4   buf	;          LDA   buf+2         PHA         LDA   buf         PHA         jsl   strcpy;;lb5    lla   buf,cname                ;return the string pointerlb5	;          LDA   #cname         STA   buf         LDA   #^cname         STA   2+buf         plb;;       creturn 4:buf	;          ldx   buf+2         ldy   buf         lda   0+2         sta   0+4+2         lda   0+1         sta   0+4+1         pld         tsc         clc         adc   #0+4         tcs         tya         rtlpr	DC.W	2	;parameter block for OSGet_Prefix	DC.W	3	DC.L	namename	DC.W	16,0	;GS/OS name buffercname		DS.B 26                       ;part of name; also C bufferGS_OSname	DC.W	8	;used for OSGet_File_Infosyscxxxx	DC.B	'SYSC0000'	;for creating unique names	DC.B	0GIParm	DC.W	2	;used to see if the file exists	DC.L	name+2	DC.W	0		ENDP******************************************************************  FILE *tmpfile()**  Outputs:*        Returns a pointer to a temp file; NULL for error.******************************************************************		EXPORT	tmpfile  tmpfile  PROCf        equ   1                        ;file pointer;;       csubroutine ,4	;          tsc         sec         sbc   #4         tcs         phd         tcd;;       ph4   #type                    ;open a file with a temp name	;          PEA   +(type)>>16         PEA   type;;       ph4   #0	;          PEA   +(0)>>16         PEA   0         jsl   tmpnam         phx         pha         jsl   fopen         sta   f         stx   f+2         ora   f+2                      ;if sucessful then         beq   lb1         ldy   #FILE_flag               ;  f->_flag |= _IOTEMPFILE         lda   [f],Y         ora   #_IOTEMPFILE         sta   [f],Y;;lb1    creturn 4:flb1	;          ldx   f+2         ldy   f         pld         tsc         clc         adc   #4+0         tcs         tya         rtl;;type   cstr  'w+b'type	DC.B	'w+b'	DC.B	0		ENDP******************************************************************  int ungetc(c, stream)*        char c;*        FILE *stream;**  Return a character to the input stream.**  Inputs:*        c - character to return*        stream - stream to put it back ;in**  Outputs:*        Returns EOF if the attempt was ;unsuccessful; c if the*        attempt succeeded.******************************************************************		EXPORT	ungetc   ungetc   PROCchar     equ   1                        ;characater to return;;       csubroutine (2:c,4:stream),2	; c        equ   0+4+2stream   equ   2+4+2         tsc         sec         sbc   #2         tcs         phd         tcd         lda   #EOF                     ;assume we will fail         sta   char         ldy   #FILE_flag               ;error if the file is open for output         lda   [stream],Y         bit   #_IOWRT         bne   rts         lda   c                        ;error if EOF is pushed         cmp   #EOF         beq   rts         ldy   #FILE_pbk+1              ;error if the buffer is full;;       short M         SEP   #1*32+0*16			LONGA OFF         lda   [stream],Y         bpl   rts         dey                            ;push the old character (if any)         lda   [stream],Y         iny         sta   [stream],Y         dey         lda   c                        ;put back the character         sta   [stream],Y         sta   char         stz   char+1         bpl   rts         dec   char+1;;rts    long  Mrts      REP   #1*32+0*16			LONGA ON;;       creturn 2:char	;          ldy   char         lda   2+2         sta   2+6+2         lda   2+1         sta   2+6+1         pld         tsc         clc         adc   #2+6         tcs         tya         rtl		ENDP******************************************************************  int vfprintf(stream, char *format, va_list arg)**  Print the format string to standard out.******************************************************************		EXPORT	vfprintf vfprintf PROC	;using ~printfCommon         phb                            ;use local addressing         phk         plb         plx                            ;remove the return address         ply         pla                            ;save the stream         sta   stream         pla         sta   stream+2         phy                            ;restore return address/data bank         phx         plb         lda   >stream+2                ;verify that stream exists         pha         lda   >stream         pha         jsl   ~VerifyStream         bcc   lb1         lda   #EIO         sta   >errno         lda   #EOF         bra   rtslb1      lda   #put                     ;set up output routine         sta   >~putchar+4         lda   #>put         sta   >~putchar+5         phd                            ;find the argument list address         tsc         tcd         lda   [10]         pld         pea   0         pha         jsl   ~printf                  ;call the formatter         ply                            ;update the argument list pointer         plx         phd         tsc         tcd         tya         sta   [10]         pld         phb                            ;remove the return address         plx         ply         tsc                            ;update the stack pointer         clc         adc   #8         tcs         phy                            ;restore the return address         phx         plb         lda   >~numChars               ;return the value         rtl                            ;returnput      phb                            ;remove the char from the stack         phk         plb         plx         pla         ply         pha         phx         plb         lda   stream+2                 ;write to a file         pha         lda   stream         pha         phy         jsl   fputcrts      rtlstream		DS.B 4                        ;stream address		ENDP******************************************************************  int vprintf (const char *format, va_list arg)**  Print the format string to standard out.******************************************************************		EXPORT	vprintf  vprintf  PROC	;using ~printfCommon         lda   #putchar                 ;set up the output hooks         sta   >~putchar+4         lda   #>putchar         sta   >~putchar+5         phd                            ;find the argument list address         tsc         tcd         lda   [10]         pld         pea   0         pha         jsl   ~printf                  ;call the formatter         ply                            ;update the argument list pointer         plx         phd         tsc         tcd         tya         sta   [10]         pld         phb                            ;remove the return address         plx         ply         tsc                            ;update the stack pointer         clc         adc   #8         tcs         phy                            ;restore the return address         phx         plb         lda   >~numChars               ;return the value         rtl                            ;return		ENDP******************************************************************  int vsprintf(char *str, char *format, va_list arg)**  Print the format string to a string.******************************************************************		EXPORT	vsprintf vsprintf PROC	;using ~printfCommon         phb                            ;use local addressing         phk         plb         plx                            ;remove the return address         ply         pla                            ;save the stream         sta   string         pla         sta   string+2         phy                            ;restore return address/data bank         phx         plb         lda   #put                     ;set up output routine         sta   >~putchar+4         lda   #>put         sta   >~putchar+5         phd                            ;find the argument list address         tsc         tcd         lda   [10]         pld         pea   0         pha         jsl   ~printf                  ;call the formatter         ply                            ;update the argument list pointer         plx         phd         tsc         tcd         tya         sta   [10]         pld         phb                            ;remove the return address         plx         ply         tsc                            ;update the stack pointer         clc         adc   #8         tcs         phy                            ;restore the return address         phx         plb         lda   >~numChars               ;return the value         rtl                            ;returnput      phb                            ;remove the char from the stack         plx         pla         ply         pha         phx         plb         ldx   string+2                 ;write to a file         phx         ldx   string         phx         phd         tsc         tcd         tya         and   #$00FF         sta   [3]         pld         pla         pla         phb         phk         plb;;       inc4  string;;       ~SETM	;          INC   string         BNE   ~2         INC   2+string;;~2     ~RESTM~2	;          plb         rtlstring		DS.B 4                        ;string address		ENDP******************************************************************  ~Format_c - format a '%' character**  Inputs:*        ~fieldWidth - output field width*        ~paddChar - padd character*        ~leftJustify - left justify the output?*******************************************************************~Format_c private~Format_c		PROC	;using ~printfCommonargp     equ   7                        ;argument pointer         dec   ~fieldWidth              ;account for the width of the value         jsr   ~RightJustify            ;handle right justification         lda   [argp]                   ;print the character         pha         jsl   ~putchar         inc   argp                     ;remove the parameter from the stack         inc   argp         brl   ~LeftJustify             ;handle left justification		ENDP******************************************************************  ~Format_d - format a signed decimal number*  ~Format_u - format an unsigned decimal number**  Inputs:*        ~fieldWidth - output field width*        ~paddChar - padd character*        ~leftJustify - left justify the output?*        ~isLong - is the operand long?*        ~precision - precision of output*        ~precisionSpecified - was the precision specified?*        ~sign - char to use for positive sign**  Note: The ~Format_IntOut entry point ;is used by other number*  formatting routines to write their number strings.*******************************************************************~Format_d private~Format_d		PROC	;using ~printfCommonargp     equ   7                        ;argument pointer;;  For signed numbers, if the value is negative, use the sign flag;         lda   ~isLong                  ;handle long values         beq   sn1         ldy   #2         lda   [argp],Y         bpl   cn0         sec         lda   #0         sbc   [argp]         sta   [argp]         lda   #0         sbc   [argp],Y         sta   [argp],Y         bra   sn2sn1      lda   [argp]                   ;handle int values         bpl   cn0         eor   #$FFFF         inc   a         sta   [argp]sn2      lda   #'-'         sta   ~sign		ENTRY	~Format_u~Format_u		;		;;  Convert the number to an ASCII string;cn0      stz   ~hexPrefix               ;don't lead with 0x         lda   ~isLong                  ;if the value is long then         beq   cn1         ldy   #2                       ;  push a long value         lda   [argp],Y         pha*        lda   [argp]*        pha*        bra   cn2                      ;elsecn1      lda   [argp]                   ;  push an int value         pha;;cn2    ph4   #~str                    ;push the string addrcn2	;          PEA   +(~str)>>16         PEA   ~str;;       ph2   #len~str                 ;push the string buffer length	;          PEA   len~str;;       ph2   #0                       ;do an unsigned conversion	;          PEA   0         lda   ~isLong                  ;do the proper conversion         beq   cn3;;       _Long2Dec         LDX   #$270B         JSL   $E10000         bra   pd1;;cn3    _Int2Deccn3      LDX   #$260B         JSL   $E10000;;  Padd with the proper number of zeros;		ENTRY	~Format_IntOut~Format_IntOut		;		pd1      lda   ~precisionSpecified      ;if the precision was not specified then         bne   pd2         lda   #1                       ;  use a precision of 1         sta   ~precisionpd2      ldx   ~precision               ;if the precision is zero then         bne   pd2a         lda   ~str+len~str-2           ;  if the result is ' 0' then         cmp   #'0 '         bne   dp0         lda   #'  '                    ;    set the result to the null string         sta   ~str+len~str-2         bra   dp0pd2a     ldy   #0                       ;skip leading blanks;;       short M         SEP   #1*32+0*16			LONGA OFF         lda   #' 'pd3      cmp   ~str,Y         bne   pd4         iny         cpy   #len~str         bne   pd3         bra   pd6pd4      cmp   ~str,Y                   ;deduct any characters from the precision         beq   pd5         dex         beq   pd5         iny         cpy   #len~str         bne   pd4pd5      stx   ~precision;;pd6    long  Mpd6      REP   #1*32+0*16			LONGA ON;;  Determine the padding and do left padding;;;dp0    sub2  ~fieldWidth,~precision   ;subtract off any remaining 0 padds;;dp0    ~SETMdp0	;          SEC;;       ~LDA  ~fieldWidth         LDA   ~fieldWidth;;       ~OP   SBC,~precision         SBC   ~precision;;       ~STA  ~fieldWidth         STA   ~fieldWidth;;       ~RESTM	;          lda   ~sign                    ;if the sign is non-zero, allow for it         beq   dp1         dec   ~fieldWidthdp1      lda   ~hexPrefix               ;if there is a hex prefix, allow for it         beq   dp1a         dec   ~fieldWidth         dec   ~fieldWidthdp1a     ldx   #0                       ;determine the length of the buffer         ldy   #len~str-1;;       short M         SEP   #1*32+0*16			LONGA OFF         lda   #' 'dp2      cmp   ~str,Y         beq   dp3         inx         dey         bpl   dp2;;dp3    long  Mdp3      REP   #1*32+0*16			LONGA ON         sec                            ;subtract it from ~fieldWidth         txa         sbc   ~fieldWidth         eor   #$FFFF         inc   a         sta   ~fieldWidth         lda   ~paddChar                ;skip justification if we are padding         cmp   #'0'         beq   pn0         jsr   ~RightJustify            ;  handle right justification;;  Print the number;pn0      lda   ~sign                    ;if there is a sign character then         beq   pn1         pha                            ;  print it         jsl   ~putcharpn1      lda   ~hexPrefix               ;if there is a hex prefix then         beq   pn1a         pha                            ;  print it         jsl   ~putchar;;       ph2   ~hexPrefix+1	;          LDA   ~hexPrefix+1         PHA         jsl   ~putcharpn1a     lda   ~paddChar                ;if the number needs 0 padding then         cmp   #'0'         bne   pn1c         lda   ~fieldWidth         bmi   pn1c         beq   pn1c;;pn1b   ph2   ~paddChar                ;  print padd zerospn1b	;          LDA   ~paddChar         PHA         jsl   ~putchar         dec   ~fieldWidth         bne   pn1bpn1c     lda   ~precision               ;if the number needs more padding then         beq   pn3;;pn2    ph2   #'0'                     ;  print padd characterspn2	;          PEA   '0'         jsl   ~putchar         dec   ~precision         bne   pn2pn3      ldy   #-1                      ;skip leading blanks in the numberpn4      iny         lda   ~str,Y         and   #$00FF         cmp   #' '         beq   pn4pn5      cpy   #len~str                 ;quit if we're at the end of the ~str         beq   rn1         phy                            ;save Y         lda   ~str,Y                   ;print the character         and   #$00FF         pha         jsl   ~putchar         ply                            ;next character         iny         bra   pn5;;  remove the number from the argument list;rn1      lda   ~isLong         beq   rn2         inc   argp         inc   argprn2      inc   argp         inc   argp;;  Handle left justification;         brl   ~LeftJustify             ;handle left justification		ENDP******************************************************************  ~Format_n - return the number of characters printed**  Inputs:*        ~numChars - characters written*        ~isLong - is the operand long?*******************************************************************~Format_n private~Format_n		PROC	;using ~printfCommonargp     equ   7                        ;argument pointer;;       ph4   argp                     ;save the original argp	;          LDA   argp+2         PHA         LDA   argp         PHA         ldy   #2                       ;dereference argp         lda   [argp],Y         tax         lda   [argp]         sta   argp         stx   argp+2         lda   ~numChars                ;return the value         sta   [argp]         lda   ~isLong                  ;if long, set the high word         beq   lb1         ldy   #2         lda   #0         sta   [argp],Ylb1      clc                            ;restore the original argp+4         pla         adc   #4         sta   argp         pla         sta   argp+2         rts		ENDP******************************************************************  ~Format_o - format an octal number**  Inputs:*        ~altForm - use a leading '0'?*        ~fieldWidth - output field width*        ~paddChar - padd character*        ~leftJustify - left justify the output?*        ~isLong - is the operand long?*        ~precision - precision of output*        ~precisionSpecified - was the precision specified?*******************************************************************~Format_o private~Format_o		PROC	;using ~printfCommonargp     equ   7                        ;argument pointer;;  Initialization;         stz   ~sign                    ;ignore the sign flag         lda   #'  '                    ;initialize the string to blanks         sta   ~str;;       move  ~str,~str+1,#len~str-1	;          LDA   #len~str-1-1         LDX   #~str         LDY   #~str+1         MVN   ~str,~str+1         stz   ~num+2                   ;get the value to convert         lda   ~isLong         beq   cn2         ldy   #2         lda   [argp],Y         sta   ~num+2cn2      lda   [argp]         sta   ~num;;  Convert the number to an ASCII string;;;       short I,M         SEP   #1*32+1*16			LONGA OFF			LONGI OFF         ldy   #len~str-1               ;set up the character indexcn3      lda   ~num+3                   ;quit if the number is zero         ora   ~num+2         ora   ~num+1         ora   ~num         beq   al1         lda   #0                       ;roll off 3 bits         ldx   #3cn4      lsr   ~num+3         ror   ~num+2         ror   ~num+1         ror   ~num         ror   A         dex         bne   cn4         lsr   A                        ;form a character         lsr   A         lsr   A         lsr   A         lsr   A         ora   #'0'         sta   ~str,Y                   ;save the character         dey         bra   cn3;;  If a leading zero is required, be sure we include one;al1      cpy   #len~str-1               ;include a zero if no characters have         beq   al2                      ; been placed in the string         lda   ~altForm                 ;branch if no leading zero is required         beq   al3al2      lda   #'0'         sta   ~str,Y;;al3    long  I,Mal3      REP   #1*32+1*16			LONGA ON			LONGI ON;;  Piggy back off of ~Format_d for output;         stz   ~hexPrefix               ;don't lead with 0x         brl   ~Format_IntOut		ENDP******************************************************************  ~Format_s - format a c-string*  ~Format_b - format a p-string**  Inputs:*        ~fieldWidth - output field width*        ~paddChar - padd character*        ~leftJustify - left justify the output?*******************************************************************~Format_s private~Format_s		PROC	;using ~printfCommonargp     equ   7                        ;argument pointer;;       ph4   argp                     ;save the original argp	;          LDA   argp+2         PHA         LDA   argp         PHA         ldy   #2                       ;dereference argp         lda   [argp],Y         tax         lda   [argp]         sta   argp         stx   argp+2;;       short M                        ;determine the length of the string         SEP   #1*32+0*16			LONGA OFF         ldy   #-1lb1      iny         lda   [argp],Y         bne   lb1;;       long  M         REP   #1*32+0*16			LONGA ON         tya         bra   lb1a		ENTRY	~Format_b~Format_b		;		;;       ph4   argp                     ;save the original argp	;          LDA   argp+2         PHA         LDA   argp         PHA         ldy   #2                       ;dereference argp         lda   [argp],Y         tax         lda   [argp]         sta   argp         stx   argp+2         lda   [argp]                   ;get the length of the string         and   #$00FF;;       inc4  argp;;       ~SETM	;          INC   argp         BNE   ~6         INC   2+argp;;~6     ~RESTM~6	; lb1a     ldx   ~precisionSpecified      ;if the precision is specified then         beq   lb2         cmp   ~precision               ;  if the precision is smaller then         blt   lb2         lda   ~precision               ;    process only precision characterslb2      sta   ~num                     ;save the length in the temp variable area;;       sub2  ~fieldWidth,~num         ;account for the width of the value;;       ~SETM	;          SEC;;       ~LDA  ~fieldWidth         LDA   ~fieldWidth;;       ~OP   SBC,~num         SBC   ~num;;       ~STA  ~fieldWidth         STA   ~fieldWidth;;       ~RESTM	;          jsr   ~RightJustify            ;handle right justification         ldx   ~num                     ;skip printing if the length is 0         beq   lb4         ldy   #0                       ;print the characterslb3      phy         lda   [argp],Y         and   #$00FF         pha         jsl   ~putchar         ply         iny         dec   ~num         bne   lb3lb4      clc                            ;restore and increment argp         pla         adc   #4         sta   argp         pla         sta   argp+2         brl   ~LeftJustify             ;handle left justification		ENDP******************************************************************  ~Format_x - format a hexadecimal number (lowercase output)*  ~Format_X - format a hexadecimal number (uppercase output)*  ~Format_p - format a pointer**  Inputs:*        ~altForm - use a leading '0x'?*        ~fieldWidth - output field width*        ~paddChar - padd character*        ~leftJustify - left justify the output?*        ~isLong - is the operand long?*        ~precision - precision of output*        ~precisionSpecified - was the precision specified?*******************************************************************~Format_x private~Format_x		PROC	;using ~printfCommonargp     equ   7                        ;argument pointer;;  Set the 'or' value; this is used to set the case of character results;         lda   #$20         sta   orVal         bra   cn0		ENTRY	~Format_p~Format_p		;		         lda   #1         sta   ~isLong		ENTRY	~Format_X~Format_X		;		         stz   orVal;;  Initialization;cn0      stz   ~sign                    ;ignore the sign flag         lda   #'  '                    ;initialize the string to blanks         sta   ~str;;       move  ~str,~str+1,#len~str-1	;          LDA   #len~str-1-1         LDX   #~str         LDY   #~str+1         MVN   ~str,~str+1         stz   ~num+2                   ;get the value to convert         lda   ~isLong         beq   cn2         ldy   #2         lda   [argp],Y         sta   ~num+2cn2      lda   [argp]         sta   ~num         stz   ~hexPrefix               ;assume we won't lead with 0x;;  Convert the number to an ASCII string;;;       short I,M         SEP   #1*32+1*16			LONGA OFF			LONGI OFF         ldy   #len~str-1               ;set up the character indexcn3      lda   #0                       ;roll off 4 bits         ldx   #4cn4      lsr   ~num+3         ror   ~num+2         ror   ~num+1         ror   ~num         ror   A         dex         bne   cn4         lsr   A                        ;form a character         lsr   A         lsr   A         lsr   A         ora   #'0'         cmp   #'9'+1                   ;if the character should be alpha,         blt   cn5                      ; adjust it         adc   #6         ora   orValcn5      sta   ~str,Y                   ;save the character         dey         lda   ~num+3                   ;loop if the number is not zero         ora   ~num+2         ora   ~num+1         ora   ~num         bne   cn3;;  If a leading '0x' is required, be sure we include one;         lda   ~altForm                 ;branch if no leading '0x' is required         beq   al3al2      lda   #'X'         ora   orVal         sta   ~hexPrefix+1         lda   #'0'         sta   ~hexPrefix;;al3    long  I,Mal3      REP   #1*32+1*16			LONGA ON			LONGI ON;;  Piggy back off of ~Format_d for output;         brl   ~Format_IntOut;;  Local data;orVal		DS.B 2                        ;for setting the case of characters		ENDP******************************************************************  ~Format_Percent - format the '%' character**  Inputs:*        ~fieldWidth - output field width*        ~paddChar - padd character*        ~leftJustify - left justify the output?*******************************************************************~Format_Percent private~Format_Percent		PROC	;using ~printfCommon         dec   ~fieldWidth              ;account for the width of the value         jsr   ~RightJustify            ;handle right justification         pea   '%'                      ;print the character         jsl   ~putchar         brl   ~LeftJustify             ;handle left justification		ENDP******************************************************************  ~InitBuffer - prepare a file buffer for output**  Inputs:*        stream - buffer to prepare******************************************************************		EXPORT	~InitBuffer ~InitBuffer PROC;;       csubroutine (4:stream),0	; stream   equ   0+4+0         tsc         phd         tcd         ldy   #FILE_base+2             ;set the next buffer location         lda   [stream],Y         tax         dey         dey         lda   [stream],Y         ldy   #FILE_ptr         sta   [stream],Y         iny         iny         txa         sta   [stream],Y         ldy   #FILE_base               ;  set the end of buffer mark         lda   [stream],Y         ldy   #FILE_size         clc         adc   [stream],Y         pha         txa         iny         iny         adc   [stream],Y         ldy   #FILE_end+2         sta   [stream],Y         pla         dey         dey         sta   [stream],Y         ldy   #FILE_size               ;  set the number of chars the buffer         lda   [stream],Y               ;   can hold         tax         iny         iny         lda   [stream],Y         ldy   #FILE_cnt+2         sta   [stream],Y         dey         dey         txa         sta   [stream],Y;;       creturn	;          lda   0+2         sta   0+4+2         lda   0+1         sta   0+4+1         pld         tsc         clc         adc   #0+4         tcs         rtl		ENDP******************************************************************  ~ioerror - flag an I/O error**  Inputs:*        stream - file to clear**  Outputs:*        errno - set to EIO*        stream->flag - error flag set******************************************************************		EXPORT	~ioerror ~ioerror PROCstream   equ   3                        ;input stream         tsc         phd         tcd         ldy   #FILE_flag         lda   [stream],Y         ora   #_IOERR         sta   [stream],Y         lda   #EIO         sta   >errno         pld         pla         ply         ply         pha         rts		ENDP******************************************************************  ~LeftJustify - print padd characters ;for left justification*  ~RightJustify - print padd characters for right justification**  Inputs:*        ~fieldWidth - # chars to print ;( <= 0 prints none)*        ~leftJustify - left justify the output?******************************************************************		EXPORT	~LeftJustify ~LeftJustify PROC	;using ~printfCommon         lda   ~leftJustify             ;padd if we are to left justify the field         bne   paddrts      rts		EXPORT	~RightJustify~RightJustify		;		         lda   ~leftJustify             ;quit if we are to left justify the field         bne   rtspadd     lda   ~fieldWidth              ;quit if the field width is <= 0         bmi   rts         beq   rts;;lb1    ph2   #' '                     ;write the proper # of padd characterslb1	;          PEA   ' '         jsl   ~putchar         dec   ~fieldWidth         bne   lb1         rts		ENDP******************************************************************  ~osname - convert a c string to a GS/OS file name**  Inputs:*        filename - ptr to the c string**  Outputs:*        X-A - ptr to GS/OS file name**  Notes:*        1. Returns nil for error.*        2. Caller must dispose of the name with a free call.*******************************************************************~osname  private~osname		PROCnamelen  equ   1                        ;length of the stringptr      equ   3                        ;pointer to return;;       csubroutine (4:filename),6	; filename equ   0+4+6         tsc         sec         sbc   #6         tcs         phd         tcd;;       ph4   filename                 ;get the length of the name buffer	;          LDA   filename+2         PHA         LDA   filename         PHA         jsl   strlen         sta   namelen         inc   A         inc   A         pea   0                        ;reserve some memory         pha         jsl   malloc         sta   ptr         stx   ptr+2         ora   ptr+2         bne   lb1         lda   #ENOMEM         sta   >errno         brl   lb3lb1      lda   namelen                  ;set the name length         sta   [ptr]         pea   0                        ;copy the file name to the OS name buffer         pha;;       ph4   filename	;          LDA   filename+2         PHA         LDA   filename         PHA         clc         lda   ptr         ldx   ptr+2         adc   #2         bcc   lb2         inxlb2      phx         pha         jsl   memcpy;;lb3    creturn 4:ptrlb3	;          ldx   ptr+2         ldy   ptr         lda   6+2         sta   6+4+2         lda   6+1         sta   6+4+1         pld         tsc         clc         adc   #6+4         tcs         tya         rtl		ENDP******************************************************************  int ~printf(char *format, additional ;arguments)**  Print the format string by calling ~putchar indirectly.  If a*  '%' is found, it is interpreted as follows:**  Optional Flag Characters*  ------------------------**  '-'   Left justify the output.*  '0'   Use '0' for the pad character rather than ' '.  This*        flag is ignored if the '-' flag is also used.*  '+'   Only used for conversion operations 'd' 'e' 'E' 'f' 'g' 'G'.*        Specifies that a leading sign is to be printed for*        positive values.*  ' '   Only used for conversion operations 'd' 'e' 'E' 'f' 'g' 'G'.*        Ignored if '+' is specified.  For positive values, this*        causes a padd space to be written where the sign would*        appear.*  '#'   Modify the conversion operation.**  Optional Min Field Width*  ------------------------**  This field is either a number or *.  ;If it is *, an integer*  argument is consumed from the stack and used as the field*  width.  In either case, the output value is printed in a field*  that is NUMBER characters wide.  By default, the value is*  right justified and blank padded.**  Optional Precision*  ------------------**  This field is a number, *, or is ommitted.  If it is an integer,*  an argument is removed from the stack and used as the precision.*  The precision is used to describe how many digits to print.**  Long Size Specification*  -----------------------**  An 'l' indicates that the 'd', 'o', 'u', 'x' or 'X' argument is*  long.  'L' and 'u' are also accepted ;for compliance with ANSI C,*  but have no effect in this implementation.**  Conversion Specifier*  --------------------**  d,i   Signed decimal conversion from ;type int or long.*  u     Signed decmal conversion from type unsigned or unsigned long.*  o     Octal conversion.*  x,X   Hexadecomal conversion.  'x' generates lowercase hex digits,*        while 'X' generates uppercase hex digits.*  c     Character.*  s     String.*  p     Pascal string.*  n     The argument is (int *); the number of characters written so*        far is written to the location.*  f     Signed decimal floating point.*  e,E   Exponential format floating point.*  g,G   Use f,e or E, as appropriate.*  %     Write a '%' character.*******************************************************************~printf  private~printf		PROC	;using ~printfCommonargp     equ   7                        ;pointer to first argumentformat   equ   14                       ;pointer to format code;;  Set up the stack frame;         phb                            ;save the caller's B         phk                            ;use local addressing         plb         phd                            ;save the caller's DP         tsc                            ;set up a DP         tcd;;  Process the format string;         stz   ~numChars                ;initialize the character counterps1      lda   [format]                 ;get a character         and   #$00FF         beq   rt1                      ;branch if at the end of the format string         cmp   #'%'                     ;branch if this is a conversion         beq   fm1                      ; specification         pha                            ;write the character         jsl   ~putchar;;       inc4  format;;       ~SETM	;          INC   format         BNE   ~2         INC   2+format;;~2     ~RESTM~2	;          bra   ps1;;  Remove the format parameter and return;rt1      lda   format-2                 ;move the return address         sta   format+2         lda   format-3         sta   format+1         pld                            ;restore DP         plb                            ;restore B         rtl                            ;return to top level formatter;;  Handle a format specification;;;fm1    inc4  format                   ;skip the '%';;fm1    ~SETMfm1	;          INC   format         BNE   ~5         INC   2+format;;~5     ~RESTM~5	;          stz   ~removeZeros             ;not a G specifier         stz   ~fieldWidth              ;use only the space required         stz   ~precision               ;use the default precision         stz   ~precisionSpecified         stz   ~isLong                  ;assume short operands         lda   #' '                     ;use a blank for padding         sta   ~paddChar         stz   ~leftJustify             ;right justify the output         stz   ~sign                    ;don't print the sign unless arg < 0         stz   ~altForm                 ;use the primary output formatfm2      jsr   Flag                     ;read and interpret flag characters         bcs   fm2         jsr   GetSize                  ;get the field width (if any)         sta   ~fieldWidth         lda   [format]                 ;if format == '.' then         and   #$00FF         cmp   #'.'         bne   fm3;;       inc4  format                   ;  skip the '.';;       ~SETM	;          INC   format         BNE   ~8         INC   2+format;;~8     ~RESTM~8	;          inc   ~precisionSpecified      ;  note that the precision is specified         jsr   GetSize                  ;  get the precision         sta   ~precision         lda   [format]                 ;if *format == 'l' then         and   #$00FFfm3      cmp   #'l'         bne   fm4         inc   ~isLong                  ;  ~isLong = true         bra   fm5                      ;  ++formatfm4      cmp   #'L'                     ;else if *format in ['L','h'] then         beq   fm5         cmp   #'h'         bne   fm6;;fm5    inc4  format                   ;  ++format;;fm5    ~SETMfm5	;          INC   format         BNE   ~11         INC   2+format;;~11    ~RESTM~11	;          lda   [format]                 ;find the proper format character         and   #$00FF;;fm6    inc4  format;;fm6    ~SETMfm6	;          INC   format         BNE   ~14         INC   2+format;;~14    ~RESTM~14	;          ldx   #fListEnd-fList-4fm7      cmp   fList,X         beq   fm8         dex         dex         dex         dex         bpl   fm7         brl   ps1                      ;none found - continuefm8      pea   ps1-1                    ;push the return address         inx                            ;call the subroutine         inx         jmp   (fList,X);;  Flag - Read and process a flag character;;  If a flag character was found, the carry flag is set.;Flag     lda   [format]                 ;get the character         and   #$00FF         cmp   #'-'                     ;if it is a '-' then         bne   fl1         lda   #1                       ;  left justify the output         sta   ~leftJustify         bra   fl5fl1      cmp   #'0'                     ;if it is a '0' then         bne   fl2         sta   ~paddChar                ;  padd with '0' characters         bra   fl5fl2      cmp   #'+'                     ;if it is a '+' or ' ' then         beq   fl3         cmp   #' '         bne   fl4         ldx   ~sign         cpx   #'+'         beq   fl5fl3      sta   ~sign                    ;  set the sign flag         bra   fl5fl4      cmp   #'#'                     ;if it is a '#' then         bne   fl6         lda   #1                       ;  use the alternate output form         sta   ~altForm;;fl5    inc4  format                   ;  skip the format character;;fl5    ~SETMfl5	;          INC   format         BNE   ~17         INC   2+format;;~17    ~RESTM~17	;          sec         rtsfl6      clc                            ;no flag was found         rts;;  GetSize - get a numeric value;;  The value is returned in A;GetSize  stz   val                      ;assume a value of 0         lda   [format]                 ;if the format character is '*' then         and   #$00FF         cmp   #'*'         bne   gs1;;       inc4  format                   ;  skip the '*' char;;       ~SETM	;          INC   format         BNE   ~20         INC   2+format;;~20    ~RESTM~20	;          lda   [argp]                   ;  fetch the value         sta   val         inc   argp                     ;  remove it from the argument list         inc   argpgs0      lda   val         rtsgs1      lda   [format]                 ;while the character stream had digits do         and   #$00FF         cmp   #'0'         blt   gs0         cmp   #'9'+1         bge   gs0gs2      and   #$000F                   ;  save the ordinal value         pha         asl   val                      ;  A := val*10         lda   val         asl   a         asl   a         adc   val         adc   1,S                      ;  A := A+ord([format])         plx         sta   val                      ;  val := A;;       inc4  format                   ;  skip the character;;       ~SETM	;          INC   format         BNE   ~23         INC   2+format;;~23    ~RESTM~23	;          bra   gs1val		DS.B 2                        ;value;;  List of format specifiers and the equivalent subroutines;fList	DC.B	'%'	;	%	DC.B	0	DC.W	~Format_Percent	DC.B	'n'	;        n	DC.B	0	DC.W	~Format_n	DC.B	's'	;        s	DC.B	0	DC.W	~Format_s	DC.B	'b'	;        b	DC.B	0	DC.W	~Format_b	DC.B	'p'	;        p	DC.B	0	DC.W	~Format_p	DC.B	'c'	;        c	DC.B	0	DC.W	~Format_c	DC.B	'X'	;        X	DC.B	0	DC.W	~Format_X	DC.B	'x'	;        x	DC.B	0	DC.W	~Format_x	DC.B	'o'	;        o	DC.B	0	DC.W	~Format_o	DC.B	'u'	;        u	DC.B	0	DC.W	~Format_u	DC.B	'd'	;        d	DC.B	0	DC.W	~Format_d	DC.B	'i'	;        i	DC.B	0	DC.W	~Format_d	DC.B	'f'	;        f	DC.B	0	DC.W	~Format_f	DC.B	'e'	;        e	DC.B	0	DC.W	~Format_e	DC.B	'E'	;        E	DC.B	0	DC.W	~Format_E	DC.B	'g'	;        g	DC.B	0	DC.W	~Format_g	DC.B	'G'	;        G	DC.B	0	DC.W	~Format_GfListEnd	; 		ENDP******************************************************************  ~printfCommon - common data for formatted output******************************************************************		EXPORT	~printfCommon ~printfCommon PROC;;  ~putchar is a vector to the proper output routine.;		EXPORT	~putchar~putchar	DC.B	$EE	;inc ~numChars	DC.W	~numChars	DC.B	$5C,$00,$00,$00;;  Format options;		EXPORT	~altForm~altForm		DS.B 2                        ;use alternate output format?		EXPORT	~fieldWidth~fieldWidth		DS.B 2                        ;output field width		EXPORT	~hexPrefix~hexPrefix		DS.B 2                        ;hex 0x prefix characters (if present)		EXPORT	~isLong~isLong		DS.B 2                        ;is the operand long?		EXPORT	~leftJustify~leftJustify		DS.B 2                       ;left justify the output?		EXPORT	~paddChar~paddChar		DS.B 2                        ;output padd character		EXPORT	~precision~precision		DS.B 2                        ;precision of output		EXPORT	~precisionSpecified~precisionSpecified		DS.B 2                ;was the precision specified?		EXPORT	~removeZeros~removeZeros		DS.B 2                       ;remove insignificant zeros? (g specifier)		EXPORT	~sign~sign		DS.B 2                        ;char to use for positive sign;;  Work buffers;		EXPORT	~num~num		DS.B 4                        ;long integer		EXPORT	~numChars~numChars		DS.B 2                        ;number of characters printed with this printf		EXPORT	~str~str		DS.B len~str                       ;string buffer;;  Real formatting;		EXPORT	~decForm~decForm	; ;controls SANE's formatting styles		EXPORT	~style~style		DS.B 2                        ;0 -> exponential; 1 -> fixed		EXPORT	~digits~digits		DS.B 2                        ;sig. digits; decimal digits		EXPORT	~decRec~decRec	; ;decimal record		EXPORT	~sgn~sgn		DS.B 2                        ;sign		EXPORT	~exp~exp		DS.B 2                        ;exponent		EXPORT	~sig~sig		DS.B 29                       ;significant digits		ENDP******************************************************************  ~RemoveWord - remove Y words from the stack for printf**  Inputs:*        Y - number of words to remove (must be >0)******************************************************************		EXPORT	~RemoveWord ~RemoveWord PROClb1      lda   13,S                     ;move the critical values         sta   15,S         lda   11,S         sta   13,S         lda   9,S         sta   11,S         lda   7,S         sta   9,S         lda   5,S         sta   7,S         lda   3,S         sta   5,S         pla         sta   1,S         tdc                            ;update the direct page location         inc   a         inc   a         tcd         dey                            ;next word         bne   lb1         rts		ENDP******************************************************************  ~Scan_c - read a character or multiple characters**  Inputs:*        ~scanWidth - # of characters to read (0 implies one)*        ~suppress - suppress save?*******************************************************************~Scan_c  private~Scan_c		PROC	;using ~scanfCommonarg      equ   11                       ;argument         lda   ~scanWidth               ;if ~scanWidth == 0 then         bne   lb1         inc   ~scanWidth               ;  ~scanWidth = 1lb1      jsl   ~getchar                 ;get the character         cmp   #EOF                     ;quit if at EOF         beq   lb3         ldx   ~suppress                ;if input is not suppressed then         bne   lb2;;       short M                        ;  save the value         SEP   #1*32+0*16			LONGA OFF         sta   [arg];;       long  M         REP   #1*32+0*16			LONGA ON;;       inc4  arg                      ;  update the pointer;;       ~SETM	;          INC   arg         BNE   ~4         INC   2+arg;;~4     ~RESTM~4	; lb2      dec   ~scanWidth               ;next character         bne   lb1lb3      lda   ~suppress                ;if input is not suppressed then         bne   lb4         ldy   #2         jsr   ~RemoveWord              ;remove the parameter from the stacklb4      rts		ENDP******************************************************************  ~Scan_d - read an integer*  ~Scan_i - read a based integer**  Inputs:*        ~scanError - has a scan error occurred?*        ~scanWidth - max input length*        ~suppress - suppress save?*        ~size - size specifier*******************************************************************~Scan_d  private~Scan_d		PROC	;using ~scanfCommonarg      equ   11                       ;argument         stz   based                    ;always use base 10         bra   bs1		ENTRY	~Scan_i~Scan_i		;		         lda   #1                       ;allow base 8, 10, 16         sta   basedbs1      stz   read                     ;no chars read         lda   #10                      ;assume base 10         sta   base         stz   val                      ;initialize the value to 0         stz   val+2lb1      jsl   ~getchar                 ;skip leading whitespace         tax         lda   __ctype+1,X         and   #_space         bne   lb1         inc   read         txa         stz   minus                    ;assume positive number         cmp   #'+'                     ;skip leading +         beq   sg1         cmp   #'-'                     ;if - then set minus flag         bne   sg2         inc   minussg1      jsl   ~getchar         inc   readsg2      ldx   based                    ;if base 8, 16 are allowed then         beq   lb2         cmp   #'0'                     ;  if the digit is '0' then         bne   lb2         lda   #8                       ;    assume base 8         sta   base         dec   ~scanWidth               ;    get the next character;;       jeq   lb4a         BNE   *+5         BRL   lb4a         bpl   lb1a         stz   ~scanWidthlb1a     jsl   ~getchar         inc   read         cmp   #'X'                     ;    if it is X then         beq   lb1b         cmp   #'x'         bne   lb2lb1b     asl   base                     ;      use base 16         dec   ~scanWidth               ;      get the next character         beq   lb4a         bpl   lb1c         stz   ~scanWidthlb1c     jsl   ~getchar         inc   readlb2      cmp   #'0'                     ;if the char is a digit then         blt   lb4         cmp   #'7'+1         blt   lb2a         ldx   base         cpx   #8         beq   lb4         cmp   #'9'+1         blt   lb2a         cpx   #16         bne   lb4         and   #$00DF         cmp   #'A'         blt   lb4         cmp   #'F'+1         bge   lb4         sbc   #6lb2a     and   #$000F                   ;  convert it to a value         pha                            ;  save the value;;       ph4   val                      ;  update the old value	;          LDA   val+2         PHA         LDA   val         PHA         lda   base         ldx   #0         jsl   ~UMUL4;;       pl4   val	;          PLA         STA   val         PLA         STA   val+2         pla                            ;  add in the new digit         clc         adc   val         sta   val         bcc   lb3         inc   val+2lb3      dec   ~scanWidth               ;  quit if the max # chars have been         beq   lb4a                     ;    scanned         bpl   lb3a                     ;  make sure 0 stays a 0         stz   ~scanWidthlb3a     jsl   ~getchar                 ;  next char         inc   read         bra   lb2lb4      jsl   ~putback                 ;put the last character backlb4a     lda   read                     ;if no chars read then         bne   lb4b         inc   ~scanError               ;  ~scanError = true         dec   ~assignments             ;  no assignment made         bra   lb6                      ;  skip the savelb4b     lda   ~suppress                ;if input is not suppressed then         bne   lb7         lda   minus                    ;  if minus then         beq   lb4c;;       sub4  #0,val,val               ;    negate the value;;       ~SETM	;          SEC;;       ~LDA  #0         LDA   #0;;       ~OP   SBC,val         SBC   val;;       ~STA  val         STA   val;;       ~LDA.H #0	;          LDA   #^0;;       ~OP.H SBC,val	;          SBC   2+val;;       ~STA.H val	;          STA   2+val;;       ~RESTM	; lb4c     lda   val                      ;  save the value         sta   [arg]         dec   ~size         bmi   lb6         ldy   #2         lda   val+2         sta   [arg],Ylb6      lda   ~suppress                ;if input is not suppressed then         bne   lb7         ldy   #2                       ;  remove the parameter from the stack         jsr   ~RemoveWordlb7      rtsval		DS.B 4                        ;valuebase	DC.L	10	;constant for mul4based		DS.B 2                        ;based conversion?minus		DS.B 2                        ;is the value negative?read		DS.B 2                        ;# chars read		ENDP******************************************************************  ~Scan_lbrack - read character in a set**  Inputs:*        ~scanWidth - max input length*        ~suppress - suppress save?*        ~size - size specifier*******************************************************************~Scan_lbrack private~Scan_lbrack		PROC	;using ~scanfCommon	;using ~printfCommonarg      equ   11                       ;argumentformat   equ   7                        ;pointer to format code;;       move  #0,~str,#32              ;clear the set	;          LDA   #0         STA   ~str         LDA   #32-1         LDX   #~str         LDY   #~str+1         MVN   ~str,~str         stz   negate                   ;don't negate the set         lda   [format]                 ;if the first char is '^' then         and   #$00FF         cmp   #'^'         bne   lb2         dec   negate                   ;  negate the set;;lb1    inc4  format                   ;  skip the ^;;lb1    ~SETMlb1	;          INC   format         BNE   ~3         INC   2+format;;~3     ~RESTM~3	; lb2      lda   [format]                 ;while *format != ']' do         and   #$00FF         cmp   #']'         beq   lb3         jsr   Set                      ;  set the char's bit         ora   ~str,X         sta   ~str,X         bra   lb1                      ;  next char;;lb3    inc4  format                   ;skip the ']';;lb3    ~SETMlb3	;          INC   format         BNE   ~6         INC   2+format;;~6     ~RESTM~6	;          ldy   #30                      ;negate the set (if needed)lb4      lda   ~str,Y         eor   negate         sta   ~str,Y         dey         dey         bpl   lb4lb5      jsl   ~getchar                 ;get a character         cmp   #EOF                     ;quit if at EOF         beq   lb8         pha                            ;quit if not in the set         jsr   Set         ply         and   ~str,X         beq   lb7         ldx   ~suppress                ;if output is not suppressed then         bne   lb6         tya;;       short M                        ;  save the character         SEP   #1*32+0*16			LONGA OFF         sta   [arg];;       long  M         REP   #1*32+0*16			LONGA ON;;       inc4  arg                      ;  update the argument;;       ~SETM	;          INC   arg         BNE   ~11         INC   2+arg;;~11    ~RESTM~11	; lb6      dec   ~scanWidth               ;note that we processed one         beq   lb8         bpl   lb5         stz   ~scanWidth         bra   lb5                      ;next charlb7      tya                            ;put back the last char scanned         jsl   ~putbacklb8      lda   ~suppress                ;if output is not suppressed then         bne   lb9;;       short M                        ;  set the terminating null         SEP   #1*32+0*16			LONGA OFF         lda   #0         sta   [arg];;       long  M         REP   #1*32+0*16			LONGA ON         ldy   #2                       ;  remove the parameter from the stack         jsr   ~RemoveWordlb9      rts;;  Set - form a set disp/bit pattern from a character value;Set      ldx   #1         stx   dispst1      bit   #$0007         beq   st2         asl   disp         dec   A         bra   st1st2      lsr   A         lsr   A         lsr   A         tax         lda   disp         rtsnegate		DS.B 2                        ;negate the set?disp		DS.B 2                        ;used to form the set disp		ENDP******************************************************************  ~Scan_n - return the # of characters ;scanned so far**  Inputs:*        ~suppress - suppress save?**  Notes:*        Decrements ~assignments so the ;increment in scanf will*        leave the assignment count unaffected by this call.*******************************************************************~Scan_n  private~Scan_n		PROC	;using ~scanfCommonarg      equ   11                       ;argument         ldx   ~suppress                ;if output is not suppressed then         bne   lb1         lda   ~scanCount               ;  save the count         sta   [arg]         dec   ~assignments             ;fix assignment countlb1      ldy   #2                       ;remove the parameter from the stack         jsr   ~RemoveWord         rts		ENDP******************************************************************  ~Scan_b - read a pascal string*  ~Scan_s - read a c string**  Inputs:*        ~scanError - has a scan error occurred?*        ~scanWidth - max input length*        ~suppress - suppress save?*        ~size - size specifier*******************************************************************~Scan_b  private~Scan_b		PROC	;using ~scanfCommonarg      equ   11                       ;argument;;       move4 arg,length               ;save the location to store the length;;       ~SETM	;          LDA   2+arg         STA   2+length         LDA   arg         STA   length;;       ~RESTM	; ;;       inc4  arg                      ;increment to the first char position;;       ~SETM	;          INC   arg         BNE   ~5         INC   2+arg;;~5     ~RESTM~5	;          lda   #1         sta   pString                  ;set the p-string flag         bra   lb1		ENTRY	~Scan_s~Scan_s		;		         stz   pString                  ;clear the p-string flaglb1      jsl   ~getchar                 ;skip leading whitespace         cmp   #EOF         bne   lb2         inc   ~scanError         dec   ~assignments             ;(no assignment made)         bra   lb6lb2      tax         lda   __ctype+1,X         and   #_space         bne   lb1lb2a     txa         ldx   ~suppress                ;if output is not suppressed then         bne   lb3;;       short M                        ;  save the character         SEP   #1*32+0*16			LONGA OFF         sta   [arg];;       long  M         REP   #1*32+0*16			LONGA ON;;       inc4  arg                      ;  update the argument;;       ~SETM	;          INC   arg         BNE   ~10         INC   2+arg;;~10    ~RESTM~10	; lb3      dec   ~scanWidth               ;note that we processed one         beq   lb5         bpl   lb4         stz   ~scanWidthlb4      jsl   ~getchar                 ;next char         cmp   #EOF                     ;quit if at EOF         beq   lb5         and   #$00FF                   ;loop if not whitespace         tax         lda   __ctype+1,X         and   #_space         beq   lb2a         txa                            ;whitespace: put it back         jsl   ~putbacklb5      lda   ~suppress                ;if output is not suppressed then         bne   lb6;;       short M                        ;  set the terminating null         SEP   #1*32+0*16			LONGA OFF         lda   #0         sta   [arg];;       long  M         REP   #1*32+0*16			LONGA ON         lda   pString                  ;  if this is a p-string then         beq   lb6         sec                            ;    compute the length         lda   arg         sbc   length         dec   A         ldx   length                   ;    set up the address         stx   arg         ldx   length+2         stx   arg+2;;       short M                        ;    save the length         SEP   #1*32+0*16			LONGA OFF         sta   [arg];;       long  M         REP   #1*32+0*16			LONGA ONlb6      lda   ~suppress                ;if output is not suppressed then         bne   lb7         ldy   #2                       ;  remove the parameter from the stack         jsr   ~RemoveWordlb7      rtslength		DS.B 4                        ;ptr to the length byte (p string only)pString		DS.B 2                        ;is this a p string?		ENDP******************************************************************  ~Scan_percent - read a % character**  Inputs:*        ~scanWidth - max input length*        ~suppress - suppress save?*        ~size - size specifier*******************************************************************~Scan_percent private~Scan_percent		PROC	;using ~scanfCommonarg      equ   11                       ;argument         jsl   ~getchar                 ;get the character         cmp   #'%'                     ;if it is not a percent then         beq   lb1         jsl   ~putback                 ;  put it back         inc   ~scanError               ;  note the error         dec   ~assignments             ;  no assignment donelb1      rts		ENDP******************************************************************  ~Scan_u - read an unsigned integer*  ~Scan_o - read an unsigned octal integer*  ~Scan_x - read an unsigned hexadecimal integer*  ~Scan_p - read a pointer**  Inputs:*        ~scanWidth - max input length*        ~suppress - suppress save?*        ~size - size specifier*******************************************************************~Scan_u  private~Scan_u		PROC	;using ~scanfCommonarg      equ   11                       ;argument         jsr   Init         lda   #10                      ;base 10         bra   bs1		ENTRY	~Scan_o~Scan_o		;		         jsr   Init         lda   #8                       ;base 8         bra   bs1		ENTRY	~Scan_p~Scan_p		;		         lda   #1         sta   ~size		ENTRY	~Scan_x~Scan_x		;		         jsr   Init         jsl   ~getchar                 ;if the initial char is a '0' then         inc   read         sta   ch         cmp   #'0'         bne   hx2         dec   ~scanWidth               ;  get the next character;;       jeq   lb4a         BNE   *+5         BRL   lb4a         bpl   hx1         stz   ~scanWidthhx1      jsl   ~getchar         inc   read         sta   ch         cmp   #'x'                     ;  if it is an 'x' or 'X' then         beq   hx1a         cmp   #'X'         bne   hx2hx1a     dec   ~scanWidth               ;    accept the character;;       jeq   lb4a         BNE   *+5         BRL   lb4a         bpl   hx3         stz   ~scanWidth         bra   hx3hx2      jsl   ~putback                 ;put back the character         dec   readhx3      lda   #16                      ;base 16bs1      sta   base                     ;set the baselb2      jsl   ~getchar                 ;if the char is a digit then         inc   read         sta   ch         cmp   #'0'         blt   lb4         cmp   #'7'+1         blt   lb2a         ldx   base         cpx   #8         beq   lb4         cmp   #'9'+1         blt   lb2a         cpx   #16         bne   lb4         and   #$00DF         cmp   #'A'         blt   lb4         cmp   #'F'+1         bge   lb4         sbc   #6lb2a     and   #$000F                   ;  convert it to a value         pha                            ;  save the value;;       ph4   val                      ;  update the old value	;          LDA   val+2         PHA         LDA   val         PHA         lda   base         ldx   base+2         jsl   ~UMUL4;;       pl4   val	;          PLA         STA   val         PLA         STA   val+2         pla                            ;  add in the new digit         clc         adc   val         sta   val         bcc   lb3         inc   val+2lb3      dec   ~scanWidth               ;  quit if the max # chars have been         beq   lb4a                     ;    scanned         bpl   lb2                      ;  make sure 0 stays a 0         stz   ~scanWidth         bra   lb2lb4      lda   ch                       ;put the last character back         jsl   ~putback         dec   readlb4a     lda   read                     ;if no chars read then         bne   lb4b         inc   ~scanError               ;  ~scanError = true         dec   ~assignments             ;  no assignment made         bra   lb6                      ;  remove the parameterlb4b     lda   ~suppress                ;if input is not suppressed then         bne   lb7         lda   val                      ;  save the value         sta   [arg]         dec   ~size         bmi   lb6         ldy   #2         lda   val+2         sta   [arg],Ylb6      lda   ~suppress                ;if input is not suppressed then         bne   lb7         ldy   #2                       ;  remove the parameter from the stack         jsr   ~RemoveWordlb7      rts;;  Initialization;Init     stz   read                     ;no chars read         stz   val                      ;initialize the value to 0         stz   val+2in1      jsl   ~getchar                 ;skip leading whitespace         tax         lda   __ctype+1,X         and   #_space         bne   in1         txa         jsl   ~putback         rtsch		DS.B 2                        ;char bufferval		DS.B 4                        ;valuebase	DC.L	10	;constant for mul4based		DS.B 2                        ;based conversion?read		DS.B 2                        ;# chars read		ENDP******************************************************************  int ~scanf(format, additional arguments)*     char *format;**  Scan by calling ~getchar indirectly. ; If a '%' is found, it*  is interpreted as follows:**  Assignment Suppression Flag*  ---------------------------**  '*'   Do everyting but save the result and remove a pointer from*        the stack.**  Max Field Width*  ---------------**  No more than this number of characters are removed from the*  input stream.**  Size Specification*  ------------------**  'h'   Used with 'd', 'u', 'o' or 'x' ;to indicate a short store.*  'l'   Used with 'd', 'u', 'o' or 'x' ;to indicate a four-byte store.*        Also used with 'e', 'f' or 'g' ;to indicate double reals.**  Conversion Specifier*  --------------------**  d,i   Signed decimal conversion to type int or long.*  u     Signed decmal conversion to type unsigned short, unsigned or*        unsigned long.*  o     Octal conversion.*  x,X   Hexadecomal conversion.*  c     Character.*  s     String.*  p     Pascal string.*  n     The argument is (int *); the number of characters written so*        far is written to the location.*  f,e,E,g,G Signed floating point conversion.*  %     Read a '%' character.*  [     Scan and included characters and place them in a string.*******************************************************************~scanf   private~scanf		PROC	;using ~scanfCommonformat   equ   7                        ;pointer to format codearg      equ   format+4                 ;first argument;;  Set up the stack frame;         phb                            ;save the caller's B         phk                            ;use local addressing         plb         phd                            ;save the caller's DP         tsc                            ;set up a DP         tcd;;  Process the format string;         stz   ~assignments             ;no assignments yet         stz   ~scanCount               ;no characters scanned         stz   ~scanError               ;no scan error so far         stz   eofFound                 ;eof was not the first char         jsl   ~getchar                 ;test for eof         cmp   #EOF         bne   ps0         sta   eofFoundps0      jsl   ~putbackps1      lda   ~scanError               ;quit if a scan error has occurred         bne   rm1         lda   [format]                 ;get a character         and   #$00FF;;       jeq   rt1                      ;branch if at the end of the format string         BNE   *+5         BRL   rt1         tax                            ;if this is a whitespace char then         lda   __ctype+1,X         and   #_space         beq   ps4;;ps2    inc4  format                   ;  skip whitespace in the format string;;ps2    ~SETMps2	;          INC   format         BNE   ~3         INC   2+format;;~3     ~RESTM~3	;          lda   [format]         and   #$00FF         tax         lda   __ctype+1,X         and   #_space         bne   ps2ps3      jsl   ~getchar                 ;  skip whitespace in the input stream         tax         cpx   #EOF         beq   ps3a         lda   __ctype+1,X         and   #_space         bne   ps3ps3a     txa         jsl   ~putback         bra   ps1ps4      cpx   #'%'                     ;branch if this is a conversion         beq   fm1                      ; specification         stx   ch                       ;make sure the char matches the format;;       inc4  format                   ; specifier;;       ~SETM	;          INC   format         BNE   ~6         INC   2+format;;~6     ~RESTM~6	;          jsl   ~getchar         cmp   ch         beq   ps1         jsl   ~putback                 ;put the character back;;  Remove the parameters for remaining conversion specifications;rm1      lda   [format]                 ;if this is a format specifier then         and   #$00FF         beq   rt1         cmp   #'%'         bne   rm4;;       inc4  format                   ;  if it is not a '%' or '*' then;;       ~SETM	;          INC   format         BNE   ~9         INC   2+format;;~9     ~RESTM~9	;          lda   [format]         and   #$00FF         beq   rt1         cmp   #'%'         beq   rm4         cmp   #'*'         beq   rm4         cmp   #'['                     ;    if it is a '[' then         bne   rm3;;rm2    inc4  format                   ;      skip up to the closing ']';;rm2    ~SETMrm2	;          INC   format         BNE   ~12         INC   2+format;;~12    ~RESTM~12	;          lda   [format]         and   #$00FF         beq   rt1         cmp   #']'         bne   rm2rm3      ldy   #2                       ;    remove an addr from the stack         jsr   ~RemoveWord;;rm4    inc4  format                   ;next format character;;rm4    ~SETMrm4	;          INC   format         BNE   ~15         INC   2+format;;~15    ~RESTM~15	;          bra   rm1;;  Remove the format parameter and return;rt1      lda   format-2                 ;move the return address         sta   format+2         lda   format-3         sta   format+1         pld                            ;restore DP         plb                            ;restore B         pla                            ;remove the extra 4 bytes from the stack         pla         lda   >eofFound                ;return EOF if no characters scanned         bne   rt2         lda   >~assignments            ;return the number of assignmentsrt2      rtl;;  Handle a format specification;;;fm1    inc4  format                   ;skip the '%';;fm1    ~SETMfm1	;          INC   format         BNE   ~18         INC   2+format;;~18    ~RESTM~18	;          inc   ~assignments             ;another one made...         stz   ~suppress                ;assignment is not suppressed         stz   ~size                    ;default operand size         lda   [format]                 ;if the char is an '*' then         and   #$00FF         cmp   #'*'         bne   fm2         inc   ~suppress                ;  suppress the output         dec   ~assignments             ;  no assignment made;;       inc4  format                   ;  skip the '*';;       ~SETM	;          INC   format         BNE   ~21         INC   2+format;;~21    ~RESTM~21	; fm2      jsr   GetSize                  ;get the field width specifier         sta   ~scanWidth         lda   [format]                 ;if the character is an 'l' then         and   #$00FF         cmp   #'l'         bne   fm3         inc   ~size                    ;  long specifier         bra   fm4fm3      cmp   #'h'                     ;else if it is an 'h' then         bne   fm5;;fm4    inc4  format                   ;  ignore the character;;fm4    ~SETMfm4	;          INC   format         BNE   ~24         INC   2+format;;~24    ~RESTM~24	; fm5      lda   [format]                 ;find the proper format character         and   #$00FF;;       inc4  format;;       ~SETM	;          INC   format         BNE   ~27         INC   2+format;;~27    ~RESTM~27	;          ldx   #fListEnd-fList-4fm7      cmp   fList,X         beq   fm8         dex         dex         dex         dex         bpl   fm7         brl   ps1                      ;none found - continuefm8      pea   ps1-1                    ;push the return address         inx                            ;call the subroutine         inx         jmp   (fList,X);;  GetSize - get a numeric value;;  The value is returned in A;GetSize  stz   val                      ;assume a value of 0gs1      lda   [format]                 ;while the character stream had digits do         and   #$00FF         cmp   #'0'         blt   gs3         cmp   #'9'+1         bge   gs3gs2      and   #$000F                   ;  save the ordinal value         pha         asl   val                      ;  A := val*10         lda   val         asl   a         asl   a         adc   val         adc   1,S                      ;  A := A+ord([format])         plx         sta   val                      ;  val := A;;       inc4  format                   ;  skip the character;;       ~SETM	;          INC   format         BNE   ~30         INC   2+format;;~30    ~RESTM~30	;          bra   gs1gs3      lda   val         rtsval		DS.B 2                        ;value;;  List of format specifiers and the equivalent subroutines;fList	DC.B	'd'	;        d	DC.B	0	DC.W	~Scan_d	DC.B	'i'	;        i	DC.B	0	DC.W	~Scan_i	DC.B	'u'	;        u	DC.B	0	DC.W	~Scan_u	DC.B	'o'	;        o	DC.B	0	DC.W	~Scan_o	DC.B	'x'	;        x	DC.B	0	DC.W	~Scan_x	DC.B	'X'	;        X	DC.B	0	DC.W	~Scan_x	DC.B	'p'	;        p	DC.B	0	DC.W	~Scan_p	DC.B	'c'	;        c	DC.B	0	DC.W	~Scan_c	DC.B	's'	;        s	DC.B	0	DC.W	~Scan_s	DC.B	'b'	;        b	DC.B	0	DC.W	~Scan_b	DC.B	'n'	;        n	DC.B	0	DC.W	~Scan_n	DC.B	'f'	;        f	DC.B	0	DC.W	~Scan_f	DC.B	'e'	;        e	DC.B	0	DC.W	~Scan_f	DC.B	'E'	;        E	DC.B	0	DC.W	~Scan_f	DC.B	'g'	;        g	DC.B	0	DC.W	~Scan_f	DC.B	'G'	;        G	DC.B	0	DC.W	~Scan_f	DC.B	'%'	;	%	DC.B	0	DC.W	~Scan_percent	DC.B	'['	;	[	DC.B	0	DC.W	~Scan_lbrackfListEnd	; ;;  Other local data;ch		DS.B 2                        ;temp storageeofFound		DS.B 2                        ;was EOF the first character?		ENDP******************************************************************  ~scanfCommon - common data for formatted input******************************************************************		EXPORT	~scanfCommon ~scanfCommon PROC;;  ~getchar is a vector to the proper input routine.;		EXPORT	~getchar~getchar	DC.B	$AF	;lda   >~scanCount	DC.A	~scanCount	DC.B	$1A	;inc   A	DC.B	$8F	;sta   >~scanCount	DC.A	~scanCount	DC.B	$5C,$00,$00,$00;;  ~putback is a vector to the proper putback routine.;		EXPORT	~putback~putback	DC.B	$48	;pha	DC.B	$AF	;lda   >~scanCount	DC.A	~scanCount	DC.B	$3A	;dec   A	DC.B	$8F	;sta   >~scanCount	DC.A	~scanCount	DC.B	$68	;pla	DC.B	$5C,$00,$00,$00;;  global variables;		EXPORT	~assignments~assignments		DS.B 2                       ;# of assignments made		EXPORT	~suppress~suppress		DS.B 2                        ;suppress assignment?		EXPORT	~scanCount~scanCount		DS.B 2                        ;# of characters scanned		EXPORT	~scanError~scanError		DS.B 2                        ;set to 1 by scaners if an error occurs		EXPORT	~scanWidth~scanWidth		DS.B 2                        ;max # characters to scan		EXPORT	~size~size		DS.B 2                        ;size specifier; -1 -> short, 1 -> long,*                                       ; 0 -> default		ENDP******************************************************************  ~SetFilePointer - makes sure nothing ;is in the input buffer**  Inputs:*        stream - stream to check*******************************************************************~SetFilePointer private~SetFilePointer		PROC;;       csubroutine (4:stream),0	; stream   equ   0+4+0         tsc         phd         tcd         ldy   #FILE_cnt                ;if stream->FILE_cnt != 0         lda   [stream],Y         iny         iny         ora   [stream],Y         ldy   #FILE_pbk                ;  or stream->FILE_pbk != 0 then         ora   [stream],Y         beq   lb1;;       ph2   #SEEK_CUR                ;  fseek(stream, 0L, SEEK_CUR)	;          PEA   SEEK_CUR;;       ph4   #0	;          PEA   +(0)>>16         PEA   0;;       ph4   stream	;          LDA   stream+2         PHA         LDA   stream         PHA         jsl   fseeklb1	; ;;       creturn	;          lda   0+2         sta   0+4+2         lda   0+1         sta   0+4+1         pld         tsc         clc         adc   #0+4         tcs         rtl		ENDP******************************************************************  ~VerifyStream - insures that a stream actually exists**  Inputs:*        stream - stream to check**  Outputs:*        C - set for error; clear if the stream exists*******************************************************************~VerifyStream private~VerifyStream		PROCstream   equ   9                        ;stream to checkptr      equ   1                        ;stream pointer         phb                            ;set up the stack frame         phk         plb;;       ph4   #stdin+4	;          PEA   +(stdin+4)>>16         PEA   stdin+4         tsc         phd         tcdlb1      lda   ptr                      ;error if the list is exhausted         ora   ptr+2         beq   err         lda   ptr                      ;OK if the steams match         cmp   stream         bne   lb2         lda   ptr+2         cmp   stream+2         beq   OKlb2      ldy   #2                       ;next pointer         lda   [ptr],Y         tax         lda   [ptr]         sta   ptr         stx   ptr+2         bra   lb1err      lda   #EIO                     ;set the error code         sta   >errno         sec                            ;return with error         bra   OK2OK       clc                            ;return with no errorOK2      pld         pla         pla         plx         ply         pla         pla         phy         phx         plb         rtl		ENDP		END