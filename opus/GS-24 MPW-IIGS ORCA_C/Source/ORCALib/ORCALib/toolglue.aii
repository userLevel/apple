			case  on	seg   ''******************************************************************  ToolGlue - Glue routines for tools that return records**  June 1989*  Mike Westerfield**  Copyright 1989, 1990, 1992*  Byte Works, Inc.*******************************************************************  November 1992**  Parameter orders corrected.*******************************************************************  August 1990**  1.  Restart() has been corrected to expect a single*      parameter.  In the previous version of the library,*      it expected the same parameter list as InitialLoad().**  2.  All tool calls now store the tool error number returned*      by the toolbox in ~toolError.******************************************************************;-----------------------------------------------;;   Imported addresses;;-----------------------------------------------	IMPORT	~TOOLERROR******************************************************************  MiscTool - Miscelaneous tool kit*******************************************************************  FWEntry - Firmware Entry**  Inputs:*        aRegValue, xRegValue, yRegValue - registers on entry*        eModeEntryPt - call address**  Outputs:*        Returns a pointer to a record with the following*        structure:**  typedef struct FWRec  {*       int yRegExit;*       int xRegExit;*       int aRegExit;*       int status;*       }******************************************************************		EXPORT	FWEntry  FWEntry  PROCaddr     equ   1                        ;work pointer;;       csubroutine (2:eModeEntryPt,2:xRegValue,2:yRegValue,2:aRegValue),4	; eModeEntryPt equ 0+4+4xRegValue equ  2+4+4yRegValue equ  4+4+4aRegValue equ  6+4+4         tsc         sec         sbc   #4         tcs         phd         tcd         pha         pha         pha         pha;;       ph2   aRegValue	;          LDA   aRegValue         PHA;;       ph2   xRegValue	;          LDA   xRegValue         PHA;;       ph2   yRegValue	;          LDA   yRegValue         PHA;;       ph2   eModeEntryPt	;          LDA   eModeEntryPt         PHA;;       _FWEntry         LDX   #$2403         JSL   $E10000         sta   >~TOOLERROR;;       pl2   >yRegExit	;          PLA         STA   >yRegExit;;       pl2   >xRegExit	;          PLA         STA   >xRegExit;;       pl2   >aRegExit	;          PLA         STA   >aRegExit;;       pl2   >status	;          PLA         STA   >status;;       lla   addr,yRegExit	;          LDA   #yRegExit         STA   addr         LDA   #^yRegExit         STA   2+addr;;       creturn 4:addr	;          ldx   addr+2         ldy   addr         lda   4+2         sta   4+8+2         lda   4+1         sta   4+8+1         pld         tsc         clc         adc   #4+8         tcs         tya         rtlyRegExit		DS.B 2                        ;record returnedxRegExit		DS.B 2aRegExit		DS.B 2status		DS.B 2		ENDP******************************************************************  GetAbsClamp - returns the absolute device clamp**  Outputs:*        Returns a pointer to a record with the following*        structure:**  typedef struct ClampRec  {*        int yMaxClamp;*        int yMinClamp;*        int xMaxClamp;*        int xMinClamp;*        }******************************************************************		EXPORT	GetAbsClamp GetAbsClamp PROC         pha         pha         pha         pha;;       _GetAbsClamp         LDX   #$2B03         JSL   $E10000         sta   >~TOOLERROR;;       pl2   >yMaxClamp	;          PLA         STA   >yMaxClamp;;       pl2   >yMinClamp	;          PLA         STA   >yMinClamp;;       pl2   >xMaxClamp	;          PLA         STA   >xMaxClamp;;       pl2   >xMinClamp	;          PLA         STA   >xMinClamp         lda   #yMaxClamp         ldx   #^yMaxClamp         rtlyMaxClamp		DS.B 2                        ;record returnedyMinClamp		DS.B 2xMaxClamp		DS.B 2xMinClamp		DS.B 2		ENDP******************************************************************  GetMouseClamp - returns the mouse clamp**  Outputs:*        Returns a pointer to a record with the following*        structure:**  typedef struct ClampRec  {*        int yMaxClamp;*        int yMinClamp;*        int xMaxClamp;*        int xMinClamp;*        }******************************************************************		EXPORT	GetMouseClamp GetMouseClamp PROC         pha         pha         pha         pha;;       _GetMouseClamp         LDX   #$1D03         JSL   $E10000         sta   >~TOOLERROR;;       pl2   >yMaxClamp	;          PLA         STA   >yMaxClamp;;       pl2   >yMinClamp	;          PLA         STA   >yMinClamp;;       pl2   >xMaxClamp	;          PLA         STA   >xMaxClamp;;       pl2   >xMinClamp	;          PLA         STA   >xMinClamp         lda   #yMaxClamp         ldx   #^yMaxClamp         rtlyMaxClamp		DS.B 2                        ;record returnedyMinClamp		DS.B 2xMaxClamp		DS.B 2xMinClamp		DS.B 2		ENDP******************************************************************  ReadMouse - return mouse statistics**  Outputs:*        Returns a pointer to a record with the following*        structure:**  typedef struct MouseRec  {*        char mouseMode;*        char mouseStatus;*        int  yPos;*        int  xPos;*        }******************************************************************		EXPORT	ReadMouse ReadMouse PROC         pha         pha         pha;;       _ReadMouse         LDX   #$1703         JSL   $E10000         sta   >~TOOLERROR;;       pl2   >mouseMode	;          PLA         STA   >mouseMode;;       pl2   >yPos	;          PLA         STA   >yPos;;       pl2   >xPos	;          PLA         STA   >xPos         lda   #mouseMode         ldx   #^mouseMode         rtlmouseMode		DS.B 1mouseStatus		DS.B 1yPos		DS.B 2xPos		DS.B 2		ENDP******************************************************************  ReadTimeHex - returns the time in hex format**  Outputs:*        Returns a pointer to a record with the following*        structure:**  typedef struct TimeRec  {*        char second;*        char minute;*        char hour;*        char year;*        char day;*        char month;*        char extra;*        char weekDay;*        }******************************************************************		EXPORT	ReadTimeHex ReadTimeHex PROC         pha         pha         pha         pha;;       _ReadTimeHex         LDX   #$0D03         JSL   $E10000         sta   >~TOOLERROR;;       pl2   >second	;          PLA         STA   >second;;       pl2   >hour	;          PLA         STA   >hour;;       pl2   >day	;          PLA         STA   >day;;       pl2   >extra	;          PLA         STA   >extra         lda   #second         ldx   #^second         rtlsecond		DS.B 1minute		DS.B 1hour		DS.B 1year		DS.B 1day		DS.B 1month		DS.B 1extra		DS.B 1weekDay		DS.B 1		ENDP******************************************************************  IntMath - Integer Math Tool Kit*******************************************************************  extern LongDivRec LongDivide();**  typedef struct LongDivRec  {*        Longint     quotient;     /* LongDivRec - Quotient from LongDiv*/*        Longint     remainder;     /* LongDivRec - remainder from LongDiv*/*        }******************************************************************		EXPORT	LongDivide LongDivide PROCaddr     equ   1;;       csubroutine (4:dividend,4:divisor),4	; dividend equ   0+4+4divisor  equ   4+4+4         tsc         sec         sbc   #4         tcs         phd         tcd         tsc         sec         sbc   #8         tcs;;       ph4   dividend	;          LDA   dividend+2         PHA         LDA   dividend         PHA;;       ph4   divisor	;          LDA   divisor+2         PHA         LDA   divisor         PHA;;       _LongDivide         LDX   #$0D0B         JSL   $E10000         sta   >~TOOLERROR;;       pl4   >quotient	;          PLA         STA   >quotient         PLA         STA   >quotient+2;;       pl4   >remainder	;          PLA         STA   >remainder         PLA         STA   >remainder+2;;       lla   addr,quotient	;          LDA   #quotient         STA   addr         LDA   #^quotient         STA   2+addr;;       creturn 4:addr	;          ldx   addr+2         ldy   addr         lda   4+2         sta   4+8+2         lda   4+1         sta   4+8+1         pld         tsc         clc         adc   #4+8         tcs         tya         rtlquotient		DS.B 4remainder		DS.B 4		ENDP******************************************************************  extern LongMulRec LongMul();**  typedef struct LongMulRec  {*        Longint  lsResult; /* LongMulRec - Low Long of result*/*        Longint  msResult;  /* LongMulRec - High long of result*/*        }******************************************************************		EXPORT	LongMul  LongMul  PROCaddr     equ   1;;       csubroutine (4:multiplicand,4:multiplier),4	; multiplicand equ 0+4+4multiplier equ 4+4+4         tsc         sec         sbc   #4         tcs         phd         tcd         tsc         sec         sbc   #8         tcs;;       ph4   multiplicand	;          LDA   multiplicand+2         PHA         LDA   multiplicand         PHA;;       ph4   multiplier	;          LDA   multiplier+2         PHA         LDA   multiplier         PHA;;       _LongMul         LDX   #$0C0B         JSL   $E10000         sta   >~TOOLERROR;;       pl4   >lsResult	;          PLA         STA   >lsResult         PLA         STA   >lsResult+2;;       pl4   >msResult	;          PLA         STA   >msResult         PLA         STA   >msResult+2;;       lla   addr,lsResult	;          LDA   #lsResult         STA   addr         LDA   #^lsResult         STA   2+addr;;       creturn 4:addr	;          ldx   addr+2         ldy   addr         lda   4+2         sta   4+8+2         lda   4+1         sta   4+8+1         pld         tsc         clc         adc   #4+8         tcs         tya         rtllsResult		DS.B 4msResult		DS.B 4		ENDP******************************************************************  extern IntDivRec SDivide();**  typedef struct IntDivRec  {*        Integer     quotient;     /* IntDivRec - quotient from SDivide*/*        Integer     remainder;     /* IntDivRec - remainder from SDivide*/*        } IntDivRec,  *IntDivRecPtr ;******************************************************************		EXPORT	SDivide  SDivide  PROCaddr     equ   1;;       csubroutine (2:dividend,2:divisor),4	; dividend equ   0+4+4divisor  equ   2+4+4         tsc         sec         sbc   #4         tcs         phd         tcd         pha         pha;;       ph2   dividend	;          LDA   dividend         PHA;;       ph2   divisor	;          LDA   divisor         PHA;;       _SDivide         LDX   #$0A0B         JSL   $E10000         sta   >~TOOLERROR;;       pl2   >quotient	;          PLA         STA   >quotient;;       pl2   >remainder	;          PLA         STA   >remainder;;       lla   addr,quotient	;          LDA   #quotient         STA   addr         LDA   #^quotient         STA   2+addr;;       creturn 4:addr	;          ldx   addr+2         ldy   addr         lda   4+2         sta   4+4+2         lda   4+1         sta   4+4+1         pld         tsc         clc         adc   #4+4         tcs         tya         rtlquotient		DS.B 2remainder		DS.B 2		ENDP******************************************************************  extern IntDivRec UDivide();**  typedef struct IntDivRec  {*        Integer     quotient;     /* IntDivRec - quotient from SDivide*/*        Integer     remainder;     /* IntDivRec - remainder from SDivide*/*        } IntDivRec,  *IntDivRecPtr ;******************************************************************		EXPORT	UDivide  UDivide  PROCaddr     equ   1;;       csubroutine (2:dividend,2:divisor),4	; dividend equ   0+4+4divisor  equ   2+4+4         tsc         sec         sbc   #4         tcs         phd         tcd         pha         pha;;       ph2   dividend	;          LDA   dividend         PHA;;       ph2   divisor	;          LDA   divisor         PHA;;       _UDivide         LDX   #$0B0B         JSL   $E10000         sta   >~TOOLERROR;;       pl2   >quotient	;          PLA         STA   >quotient;;       pl2   >remainder	;          PLA         STA   >remainder;;       lla   addr,quotient	;          LDA   #quotient         STA   addr         LDA   #^quotient         STA   2+addr;;       creturn 4:addr	;          ldx   addr+2         ldy   addr         lda   4+2         sta   4+4+2         lda   4+1         sta   4+4+1         pld         tsc         clc         adc   #4+4         tcs         tya         rtlquotient		DS.B 2remainder		DS.B 2		ENDP******************************************************************  Loader*******************************************************************  extern InitialLoadOutputRec InitialLoad();**  typedef struct InitialLoadOutputRec  ;{*        Word     userID;*        Pointer  startAddr;*        Word     dPageAddr;*        Word     buffSize;*        }******************************************************************		EXPORT	InitialLoad InitialLoad PROCaddr     equ   1;;       csubroutine (2:uID,4:stAddr,2:dpAddr),4	; uID      equ   0+4+4stAddr   equ   2+4+4dpAddr   equ   6+4+4         tsc         sec         sbc   #4         tcs         phd         tcd         tsc         sec         sbc   #10         tcs;;       ph2   uID	;          LDA   uID         PHA;;       ph4   stAddr	;          LDA   stAddr+2         PHA         LDA   stAddr         PHA;;       ph2   dpAddr	;          LDA   dpAddr         PHA;;       _InitialLoad         LDX   #$0911         JSL   $E10000         sta   >~TOOLERROR;;       pl2   >userID	;          PLA         STA   >userID;;       pl4   >startAddr	;          PLA         STA   >startAddr         PLA         STA   >startAddr+2;;       pl2   >dPageAddr	;          PLA         STA   >dPageAddr;;       pl2   >buffSize	;          PLA         STA   >buffSize;;       lla   addr,userID	;          LDA   #userID         STA   addr         LDA   #^userID         STA   2+addr;;       creturn 4:addr	;          ldx   addr+2         ldy   addr         lda   4+2         sta   4+8+2         lda   4+1         sta   4+8+1         pld         tsc         clc         adc   #4+8         tcs         tya         rtluserID		DS.B 2startAddr		DS.B 4dPageAddr		DS.B 2buffSize		DS.B 2		ENDP******************************************************************  extern InitialLoadOutputRec InitialLoad2();**  typedef struct InitialLoadOutputRec  ;{*        Word     buffSize;*        Word     dPageAddr;*        Pointer  startAddr;*        Word     userID;*        }******************************************************************		EXPORT	InitialLoad2 InitialLoad2 PROCaddr     equ   1;;       csubroutine (2:uID,4:buffAddr,2:flagWord,2:inputType),4	; uID      equ   0+4+4buffAddr equ   2+4+4flagWord equ   6+4+4inputType equ  8+4+4         tsc         sec         sbc   #4         tcs         phd         tcd         tsc         sec         sbc   #10         tcs;;       ph2   uID	;          LDA   uID         PHA;;       ph4   buffAddr	;          LDA   buffAddr+2         PHA         LDA   buffAddr         PHA;;       ph2   flagWord	;          LDA   flagWord         PHA;;       ph2   inputType	;          LDA   inputType         PHA;;       _InitialLoad2         LDX   #$2011         JSL   $E10000         sta   >~TOOLERROR;;       pl2   >userID	;          PLA         STA   >userID;;       pl4   >startAddr	;          PLA         STA   >startAddr         PLA         STA   >startAddr+2;;       pl2   >dPageAddr	;          PLA         STA   >dPageAddr;;       pl2   >buffSize	;          PLA         STA   >buffSize;;       lla   addr,userID	;          LDA   #userID         STA   addr         LDA   #^userID         STA   2+addr;;       creturn 4:addr	;          ldx   addr+2         ldy   addr         lda   4+2         sta   4+10+2         lda   4+1         sta   4+10+1         pld         tsc         clc         adc   #4+10         tcs         tya         rtluserID		DS.B 2startAddr		DS.B 4dPageAddr		DS.B 2buffSize		DS.B 2		ENDP******************************************************************  extern LoadSegNameOut LoadSegName();**  typedef struct LoadSegNameOut  {*        Pointer  segAddr;*        Word     userID;*        Word     fileNum;*        Word     segNum;*        }******************************************************************		EXPORT	LoadSegName LoadSegName PROCaddr     equ   1;;       csubroutine (2:uID,4:fName,4:sName),4	; uID      equ   0+4+4fName    equ   2+4+4sName    equ   6+4+4         tsc         sec         sbc   #4         tcs         phd         tcd         tsc         sec         sbc   #10         tcs;;       ph2   uID	;          LDA   uID         PHA;;       ph4   fName	;          LDA   fName+2         PHA         LDA   fName         PHA;;       ph4   sName	;          LDA   sName+2         PHA         LDA   sName         PHA;;       _LoadSegName         LDX   #$0D11         JSL   $E10000         sta   >~TOOLERROR;;       pl4   >segAddr	;          PLA         STA   >segAddr         PLA         STA   >segAddr+2;;       pl2   >userID	;          PLA         STA   >userID;;       pl2   >fileNum	;          PLA         STA   >fileNum;;       pl2   >segNum	;          PLA         STA   >segNum;;       lla   addr,segAddr	;          LDA   #segAddr         STA   addr         LDA   #^segAddr         STA   2+addr;;       creturn 4:addr	;          ldx   addr+2         ldy   addr         lda   4+2         sta   4+10+2         lda   4+1         sta   4+10+1         pld         tsc         clc         adc   #4+10         tcs         tya         rtlsegAddr		DS.B 4userID		DS.B 2fileNum		DS.B 2segNum		DS.B 2		ENDP******************************************************************  extern InitialLoadOutputRec Restart();**  typedef struct InitialLoadOutputRec  ;{*        Word     userID;*        Pointer  startAddr;*        Word     dPageAddr;*        Word     buffSize;*        }******************************************************************		EXPORT	Restart  Restart  PROCaddr     equ   1;;       csubroutine (2:uID),4	; uID      equ   0+4+4         tsc         sec         sbc   #4         tcs         phd         tcd         tsc         sec         sbc   #10         tcs;;       ph2   uID	;          LDA   uID         PHA;;       _Restart         LDX   #$0A11         JSL   $E10000         sta   >~TOOLERROR;;       pl2   >userID	;          PLA         STA   >userID;;       pl4   >startAddr	;          PLA         STA   >startAddr         PLA         STA   >startAddr+2;;       pl2   >dPageAddr	;          PLA         STA   >dPageAddr;;       pl2   >buffSize	;          PLA         STA   >buffSize;;       lla   addr,userID	;          LDA   #userID         STA   addr         LDA   #^userID         STA   2+addr;;       creturn 4:addr	;          ldx   addr+2         ldy   addr         lda   4+2         sta   4+2+2         lda   4+1         sta   4+2+1         pld         tsc         clc         adc   #4+2         tcs         tya         rtluserID		DS.B 2startAddr		DS.B 4dPageAddr		DS.B 2buffSize		DS.B 2		ENDP******************************************************************  extern UnloadSegOutRec UnloadSeg();**  typedef struct UnloadSegOutRec  {*        Word     userID;*        Word     fileNum;*        Word     segNum;*        } UnloadSegOutRec,  *UnloadSegOutRecPtr ;******************************************************************		EXPORT	UnloadSeg UnloadSeg PROCaddr     equ   1;;       csubroutine (4:segaddr),4	; segaddr  equ   0+4+4         tsc         sec         sbc   #4         tcs         phd         tcd         pha         pha         pha;;       ph4   segaddr	;          LDA   segaddr+2         PHA         LDA   segaddr         PHA;;       _UnloadSeg         LDX   #$0E11         JSL   $E10000         sta   >~TOOLERROR;;       pl2   >userID	;          PLA         STA   >userID;;       pl2   >fileNum	;          PLA         STA   >fileNum;;       pl2   >segNum	;          PLA         STA   >segNum;;       lla   addr,userID	;          LDA   #userID         STA   addr         LDA   #^userID         STA   2+addr;;       creturn 4:addr	;          ldx   addr+2         ldy   addr         lda   4+2         sta   4+4+2         lda   4+1         sta   4+4+1         pld         tsc         clc         adc   #4+4         tcs         tya         rtluserID		DS.B 2fileNum		DS.B 2segNum		DS.B 2		ENDP******************************************************************  Note Sequencer*******************************************************************  extern LocRec GetLoc();**  typedef struct LocRec {*     Word curPhraseItem;*     Word curPattItem;*     Word curLevel;*     } LocRec, *LocRecPtr, **LocRecHndl;******************************************************************		EXPORT	GetLoc   GetLoc   PROC         pha         pha         pha;;       _GetLoc         LDX   #$0C1A         JSL   $E10000         sta   >~TOOLERROR;;       pl2   >curLevel	;          PLA         STA   >curLevel;;       pl2   >curPattItem	;          PLA         STA   >curPattItem;;       pl2   >curPhraseItem	;          PLA         STA   >curPhraseItem         lda   #curPhraseItem         ldx   #^curPhraseItem         rtlcurPhraseItem		DS.B 2curPattItem		DS.B 2curLevel		DS.B 2		ENDP******************************************************************  TextTools*******************************************************************  extern TxtMaskRec  GetErrGlobals();**  typedef struct TxtMaskRec  {*        Word     orMask;*        Word     andMask;*        } TxtMaskRec,  *TxtMaskRecPtr, ; **TxtMaskRecHndl ;******************************************************************		EXPORT	GetErrGlobals GetErrGlobals PROC         pha         pha;;       _GetErrGlobals         LDX   #$0E0C         JSL   $E10000         sta   >~TOOLERROR;;       pl2   >orMask	;          PLA         STA   >orMask;;       pl2   >andMask	;          PLA         STA   >andMask         lda   #orMask         ldx   #^orMask         rtlorMask		DS.B 2andMask		DS.B 2		ENDP******************************************************************  extern DeviceRec  GetErrorDevice();**  typedef struct DeviceRec  {*        LongWord     ptrOrSlot; /* DeviceRec - slot number or jump table ptr*/*        Word     deviceType;     /* DeviceRec - type of input device*/*        } DeviceRec,  *DeviceRecPtr,  **DeviceRecHndl ;******************************************************************		EXPORT	GetErrorDevice GetErrorDevice PROC         pha         pha         pha;;       _GetErrorDevice         LDX   #$140C         JSL   $E10000         sta   >~TOOLERROR;;       pl4   >ptrOrSlot	;          PLA         STA   >ptrOrSlot         PLA         STA   >ptrOrSlot+2;;       pl2   >deviceType	;          PLA         STA   >deviceType         lda   #ptrOrSlot         ldx   #^ptrOrSlot         rtlptrOrSlot		DS.B 4deviceType		DS.B 2		ENDP******************************************************************  extern TxtMaskRec  GetInGlobals();**  typedef struct TxtMaskRec  {*        Word     orMask;*        Word     andMask;*        } TxtMaskRec,  *TxtMaskRecPtr, ; **TxtMaskRecHndl ;******************************************************************		EXPORT	GetInGlobals GetInGlobals PROC         pha         pha;;       _GetInGlobals         LDX   #$0C0C         JSL   $E10000         sta   >~TOOLERROR;;       pl2   >orMask	;          PLA         STA   >orMask;;       pl2   >andMask	;          PLA         STA   >andMask         lda   #orMask         ldx   #^orMask         rtlorMask		DS.B 2andMask		DS.B 2		ENDP******************************************************************  extern DeviceRec  GetInputDevice();**  typedef struct DeviceRec  {*        LongWord     ptrOrSlot; /* DeviceRec - slot number or jump table ptr*/*        Word     deviceType;     /* DeviceRec - type of input device*/*        } DeviceRec,  *DeviceRecPtr,  **DeviceRecHndl ;******************************************************************		EXPORT	GetInputDevice GetInputDevice PROC         pha         pha         pha;;       _GetInputDevice         LDX   #$120C         JSL   $E10000         sta   >~TOOLERROR;;       pl4   >ptrOrSlot	;          PLA         STA   >ptrOrSlot         PLA         STA   >ptrOrSlot+2;;       pl2   >deviceType	;          PLA         STA   >deviceType         lda   #ptrOrSlot         ldx   #^ptrOrSlot         rtlptrOrSlot		DS.B 4deviceType		DS.B 2		ENDP******************************************************************  extern TxtMaskRec  GetOutGlobals();**  typedef struct TxtMaskRec  {*        Word     orMask;*        Word     andMask;*        } TxtMaskRec,  *TxtMaskRecPtr, ; **TxtMaskRecHndl ;******************************************************************		EXPORT	GetOutGlobals GetOutGlobals PROC         pha         pha;;       _GetOutGlobals         LDX   #$0D0C         JSL   $E10000         sta   >~TOOLERROR;;       pl2   >orMask	;          PLA         STA   >orMask;;       pl2   >andMask	;          PLA         STA   >andMask         lda   #orMask         ldx   #^orMask         rtlorMask		DS.B 2andMask		DS.B 2		ENDP******************************************************************  extern DeviceRec  GetOutputDevice();**  typedef struct DeviceRec  {*        LongWord     ptrOrSlot; /* DeviceRec - slot number or jump table ptr*/*        Word     deviceType;     /* DeviceRec - type of input device*/*        } DeviceRec,  *DeviceRecPtr,  **DeviceRecHndl ;******************************************************************		EXPORT	GetOutputDevice GetOutputDevice PROC         pha         pha         pha;;       _GetOutputDevice         LDX   #$130C         JSL   $E10000         sta   >~TOOLERROR;;       pl4   >ptrOrSlot	;          PLA         STA   >ptrOrSlot         PLA         STA   >ptrOrSlot+2;;       pl2   >deviceType	;          PLA         STA   >deviceType         lda   #ptrOrSlot         ldx   #^ptrOrSlot         rtlptrOrSlot		DS.B 4deviceType		DS.B 2		ENDP		END