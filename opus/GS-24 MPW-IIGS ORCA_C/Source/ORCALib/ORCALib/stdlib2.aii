			case  on	seg   ''******************************************************************  StdDef - Standard Definitions**  This code implements the tables and subroutines needed to*  support the standard C library STDDEF.**  December 1988*  Mike Westerfield**  Copyright 1988*  Byte Works, Inc.** Note: Portions of this library appear ;in SysFloat******************************************************************;-----------------------------------------------;;   Imported addresses;;-----------------------------------------------	IMPORT	__ctype	IMPORT	errno	IMPORT	malloc	IMPORT	raise	IMPORT	strtod	IMPORT	~DIV2	IMPORT	~DIV4	IMPORT	~EXIT	IMPORT	~EXITLIST	IMPORT	~MUL4	IMPORT	~QUIT	IMPORT	~RANX	IMPORT	~RANX2	IMPORT	~SEED;-----------------------------------------------;;   Forward addresses and entries;;-----------------------------------------------	ENTRY	jsl1	ENTRY	jsl2	ENTRY	lsize	ENTRY	rsort	ENTRY	srand	ENTRY	strtol	ENTRY	strtoul	ENTRY	~srand;        copy  equates.asm******************************************************************  This file contains constant values defined in the C interfaces*  that are also used in the assembly language portion of the*  libraries.*****************************************************************;;  error numbers;EDOM     equ   1                        ;domain errorERANGE   equ   2                        ;# too large, too small, or illegalENOMEM   equ   3                        ;Not enough memoryENOENT   equ   4                        ;No such file or directoryEIO      equ   5                        ;I/O errorEINVAL   equ   6                        ;Invalid argumentEBADF    equ   7                        ;bad file descriptorEMFILE   equ   8                        ;too many files are openEACCES   equ   9                        ;access bits prevent the operationEEXIST   equ   10                       ;the file existsENOSPC   equ   11                       ;the file is too large;;  masks for the __ctype array;_digit   equ   $01                      ;['0'..'9']_upper   equ   $02                      ;['A'..'Z']_lower   equ   $04                      ;['a'..'z']_control equ   $08                      ;[chr(0)..chr(31),chr(127)]_punctuation equ  $10                   ;[' ','!'..'/',':'..'@','['..'`','{'..'~']_space   equ   $20                      ;[chr(9)..chr(13),' ']_hex     equ   $40                      ;['0'..'9','a'..'f','A'..'F']_print   equ   $80                      ;[' '..'~'];;  masks for the __ctype2 array;_csym    equ   $01                      ;['0'..'9','A'..'Z','a'..'z','_']_csymf   equ   $02                      ;['A'..'Z','a'..'z'.'_']_octal   equ   $04                      ;['0'..'7'];;  signal numbers;SIGABRT  equ   1SIGFPE   equ   2SIGILL   equ   3SIGINT   equ   4SIGSEGV  equ   5SIGTERM  equ   6;;  The FILE record;*                                       ;flags*                                       ;-----_IOFBF   equ   $0001                    ;full buffering_IONBF   equ   $0002                    ;no buffering_IOLBF   equ   $0004                    ;flush when a \n is written_IOREAD  equ   $0008                    ;currently reading_IOWRT   equ   $0010                    ;currently writing_IORW    equ   $0020                    ;read/write enabled_IOMYBUF equ   $0040                    ;buffer was allocated by stdio_IOEOF   equ   $0080                    ;has an EOF been found?_IOERR   equ   $0100                    ;has an error occurred?_IOTEXT  equ   $0200                    ;is this file a text file?_IOTEMPFILE equ  $0400                  ;was this file created by tmpfile()?*                                       ;record structure*                                       ;----------------FILE_next equ  0                        ;disp to next pointer (must stay 0!)FILE_ptr  equ  FILE_next+4              ;next location to write toFILE_base equ  FILE_ptr+4               ;first byte of the bufferFILE_end  equ  FILE_base+4              ;end of the file bufferFILE_size equ  FILE_end+4               ;size of the file bufferFILE_cnt  equ  FILE_size+4              ;# chars that can be read/writen to bufferFILE_pbk  equ  FILE_cnt+4               ;put back characterFILE_flag equ  FILE_pbk+2               ;buffer flagsFILE_file equ  FILE_flag+2              ;GS/OS file IDsizeofFILE equ  FILE_file+2             ;size of the recordBUFSIZ   equ   1024                     ;default file buffer size_LBUFSIZ equ   255                      ;line buffer sizeL_tmpnam equ   9                        ;size of a temp nameTMP_MAX  equ   10000                    ;# of uniq temp names;;  Seek codes for fseek;SEEK_CNT equ   0                        ;seek from start of fileSEEK_CUR equ   1                        ;seek from current positionSEEK_END equ   2                        ;seek from end of file;;  Values for fcntl.h;OPEN_MAX equ   30                       ;files in the file arrayF_DUPFD  equ   1                        ;dup file flag (fcntl)O_RDONLY equ   $0001                    ;file is read onlyO_WRONLY equ   $0002                    ;file is write onlyO_RDWR   equ   $0004                    ;file is read/writeO_NDELAY equ   $0008                    ;not usedO_APPEND equ   $0010                    ;append to file on all writesO_CREAT  equ   $0020                    ;create a new file if neededO_TRUNC  equ   $0040                    ;erase old fileO_EXCL   equ   $0080                    ;don't create a new fileO_BINARY equ   $0100                    ;file is binary;;  Misc.;EOF      equ   -1                       ;end of file characterstdinID  equ   -1                       ;standard in file IDstdoutID equ   -2                       ;standard out file IDstderrID equ   -3                       ;error out file ID******************************************************************  void abort()**  Stop the program.******************************************************************		EXPORT	abort    abort    PROC;;       ph2   #SIGABRT	;          PEA   SIGABRT         jsl   raise         lda   #-1         jmp   ~QUIT		ENDP******************************************************************  int abs(int i)**  Return the absolute value of i.**  Inputs:*        i - argument**  Outputs:*        Returns abs(i).******************************************************************		EXPORT	abs      abs      PROCi        equ   4                        ;position of argument on stack         lda   i,S                      ;A := i         bpl   lb1                      ;if A < 0 then         eor   #$FFFF                   ;  A := -A         inc   Alb1      tay                            ;return A         lda   2,S         sta   4,S         pla         sta   1,S         tya         rtl		ENDP******************************************************************  int atexit(func)*        void (*func)();**  This function is used to build a list of functions that will*  be called as part of the exit processing.**  Inputs:*        func - address of the function ;to call on exit**  Outputs:*        Returns 0 if successful, -1 if ;not.******************************************************************		EXPORT	atexit   atexit   PROCptr      equ   1                        ;work pointerrval     equ   5                        ;return value;;       csubroutine (4:func),6	; func     equ   0+4+6         tsc         sec         sbc   #6         tcs         phd         tcd         lda   #-1                      ;assume we will fail         sta   rval                     ;assume we will fail;;       dec4  func                     ;we need the addr-1, not the addr;;       ~SETM	;          LDA   func         BNE   ~3         DEC   2+func~3       DEC   func;;       ~RESTM	; ;;       ph4   #8                       ;get space for the record	;          PEA   +(8)>>16         PEA   8         jsl   malloc         stx   ptr+2         sta   ptr         ora   ptr+2                    ;quit now if we failed         beq   lb1         ldy   #2                       ;place the record in the exit list         lda   >~EXITLIST         sta   [ptr]         lda   >~EXITLIST+2         sta   [ptr],Y         lda   ptr         sta   >~EXITLIST         lda   ptr+2         sta   >~EXITLIST+2         iny                            ;place the function address in the record         iny         lda   func         sta   [ptr],Y         iny         iny         lda   func+2         sta   [ptr],Y         inc   rval                     ;success...;;lb1    creturn 2:rvallb1	;          ldy   rval         lda   6+2         sta   6+4+2         lda   6+1         sta   6+4+1         pld         tsc         clc         adc   #6+4         tcs         tya         rtl		ENDP******************************************************************  atof - convert a string to a float**  Inputs:*        str - pointer to the string**  Outputs:*        X-A - pointer to converted number******************************************************************		EXPORT	atof     atof     PROC;;       ph4   #0                       ;no pointer returned	;          PEA   +(0)>>16         PEA   0         lda   10,S                     ;pass the string addr on         pha         lda   10,S         pha         jsl   strtod                   ;convert the string         tay                            ;fix the stack         lda   2,S         sta   6,S         pla         sta   3,S         pla         tya         rtl		ENDP******************************************************************  atoi - convert a string to an int*  atol - convert a string to a long**  Inputs:*        str - pointer to the string**  Outputs:*        X-A - converted number******************************************************************		EXPORT	atoi     atoi     PROC		EXPORT	atolatol		;		;;       ph2   #10                      ;base 10	;          PEA   10;;       ph4   #0                       ;no pointer returned	;          PEA   +(0)>>16         PEA   0         lda   12,S                     ;pass the string addr on         pha         lda   12,S         pha         jsl   strtol                   ;convert the string         tay                            ;fix the stack         lda   2,S         sta   6,S         pla         sta   3,S         pla         tya         rtl		ENDP******************************************************************  char *bsearch(key, base, count, size, compar)*        void *key, *base;*        size_t count, size;*        int (*compar)(const void *, const void *)**  Inputs:*        key - pointer to element to search for*        base - start address of the array to search*        count - # elements in the array*        size - size of each array element*        compar - function that compares array elements**  Outputs:*        Returns a pointer to the array ;element found; NULL if*        no match was found.******************************************************************		EXPORT	bsearch  bsearch  PROCleft     equ   1                        ;left indexright    equ   5                        ;right indextest     equ   9                        ;test indexaddr     equ   13                       ;address of array element of index test;;       csubroutine (4:key,4:base,4:count,4:size,4:compar),16	; key      equ   0+4+16base     equ   4+4+16count    equ   8+4+16size     equ   12+4+16compar   equ   16+4+16         tsc         sec         sbc   #16         tcs         phd         tcd         lda   compar                   ;patch the call address         sta   >jsl+1         lda   compar+1         sta   >jsl+2         stz   left                     ;left = 0         stz   left+2;;       sub4  count,#1,right           ;right = count-1;;       ~SETM	;          SEC;;       ~LDA  count         LDA   count;;       ~OP   SBC,#1         SBC   #1;;       ~STA  right         STA   right;;       ~LDA.H count	;          LDA   2+count;;       ~OP.H SBC,#1	;          SBC   #^1;;       ~STA.H right	;          STA   2+right;;       ~RESTM	; lb1      clc                            ;test = (left+right)/2         lda   left         adc   right         sta   test         lda   left+2         adc   right+2         lsr   A         sta   test+2         ror   test;;       mul4  test,size,addr           ;addr = test*size + base;;       ~SETM	; ;;       PH4   test	;          LDA   test+2         PHA         LDA   test         PHA;;       PH4   size	;          LDA   size+2         PHA         LDA   size         PHA         JSL   ~MUL4;;       PL4   addr	;          PLA         STA   addr         PLA         STA   addr+2;;       ~RESTM	; ;;       add4  addr,base;;       ~SETM	;          CLC;;       ~LDA  addr         LDA   addr;;       ~OP   ADC,base         ADC   base;;       ~STA  addr         STA   addr;;       ~LDA.H addr	;          LDA   2+addr;;       ~OP.H ADC,base	;          ADC   2+base;;       ~STA.H addr	;          STA   2+addr;;       ~RESTM	; ;;       ph4   addr                     ;compare the array elements	;          LDA   addr+2         PHA         LDA   addr         PHA;;       ph4   key	;          LDA   key+2         PHA         LDA   key         PHAjsl      jsl   jsl         tax                            ;quit if *addr = *key         beq   lb6         bmi   lb2                      ;if *key > *addr then;;       add4  test,#1,left             ;  left = test+1;;       ~SETM	;          CLC;;       ~LDA  test         LDA   test;;       ~OP   ADC,#1         ADC   #1;;       ~STA  left         STA   left;;       ~LDA.H test	;          LDA   2+test;;       ~OP.H ADC,#1	;          ADC   #^1;;       ~STA.H left	;          STA   2+left;;       ~RESTM	;          bra   lb3                      ;else;;lb2    sub4  test,#1,right            ;  right = test-1;;lb2    ~SETMlb2	;          SEC;;       ~LDA  test         LDA   test;;       ~OP   SBC,#1         SBC   #1;;       ~STA  right         STA   right;;       ~LDA.H test	;          LDA   2+test;;       ~OP.H SBC,#1	;          SBC   #^1;;       ~STA.H right	;          STA   2+right;;       ~RESTM	; lb3      lda   right+2                  ;loop if right >= left         bmi   lb5         cmp   left+2         bne   lb4         lda   right         cmp   leftlb4      bge   lb1lb5      stz   addr                     ;no match - return null         stz   addr+2;;lb6    creturn 4:addrlb6	;          ldx   addr+2         ldy   addr         lda   16+2         sta   16+20+2         lda   16+1         sta   16+20+1         pld         tsc         clc         adc   #16+20         tcs         tya         rtl		ENDP******************************************************************  div_t div(n,d)*        int n,d;**  Inputs:*        n - numerator*        d - denominator**  Outputs:*        div_t - contains result & remainder******************************************************************		EXPORT	__div      __div    PROCaddr     equ   1;;       csubroutine (2:n,2:d),4	; n        equ   0+4+4d        equ   2+4+4         tsc         sec         sbc   #4         tcs         phd         tcd         phb                            ;use local data         phk         plb         lda   n                        ;do the divide         ldx   d         jsl   ~DIV2         sta   div_t                    ;save the results         stx   div_t+2         tay                            ;if the result is negative then         bpl   lb1;;       sub2  #0,div_t+2,div_t+2       ;  make the remainder negative;;       ~SETM	;          SEC;;       ~LDA  #0         LDA   #0;;       ~OP   SBC,div_t+2         SBC   div_t+2;;       ~STA  div_t+2         STA   div_t+2;;       ~RESTM	; ;;lb1    lla   addr,div_t               ;return the addresslb1	;          LDA   #div_t         STA   addr         LDA   #^div_t         STA   2+addr         plb;;       creturn 4:addr	;          ldx   addr+2         ldy   addr         lda   4+2         sta   4+4+2         lda   4+1         sta   4+4+1         pld         tsc         clc         adc   #4+4         tcs         tya         rtldiv_t		DS.B 4		ENDP******************************************************************  void exit(status)*        int status;**  void _exit(status)*        int status;**  Stop the program.  Exit cleans up, _exit does not.  Status*  is the status returned to the shell.**  Inputs:*        status - exit code******************************************************************		EXPORT	exit     exit     PROC         jsr   ~EXIT		EXPORT	_exit_exit		;		         lda   4,S         jmp   ~QUIT		ENDP******************************************************************  char *getenv(const char *name)**  Returns a pointer to a shell variable.  If the shell variable*  has no value, a null is returned.**  Inputs:*        namePtr - pointer to the name of the shell variable**  Outputs:*        Returns a pointer to the shell ;variable******************************************************************		EXPORT	getenv   getenv   PROCptr      equ   1                        ;pointer to the shell variable;;       csubroutine (4:namePtr),4	; namePtr  equ   0+4+4         tsc         sec         sbc   #4         tcs         phd         tcd         phb                            ;use local addressing         phk         plb;;       lla   ptr,0                    ;initialize the pointer to null	;          LDA   #0         STA   ptr         LDA   #^0         STA   2+ptr;;       short I,M                      ;copy the variable name to the buffer         SEP   #1*32+1*16			LONGA OFF			LONGI OFF         ldy   #0lb1      lda   [namePtr],Y         beq   lb2         iny         sta   name,Y         bne   lb1         deylb2      sty   name;;       long  I,M         REP   #1*32+1*16			LONGA ON			LONGI ON;;       Read_Variable rdRec            ;read the shell variable;;       ~SETM	;          JSL   $E100A8	DC.W	$010B	DC.L	rdRec;;       ~RESTM	;          bcs   lb3                      ;if there was no error then         lda   var                      ;  if the variable was set then         and   #$00FF         beq   lb3;;       short I,M                      ;    set the null terminator         SEP   #1*32+1*16			LONGA OFF			LONGI OFF         ldx   var         stz   var+1,X;;       long  I,M         REP   #1*32+1*16			LONGA ON			LONGI ON;;       lla   ptr,var+1                ;    set the pointer to return	;          LDA   #var+1         STA   ptr         LDA   #^var+1         STA   2+ptrlb3      plb                            ;restore B;;       creturn 4:ptr	;          ldx   ptr+2         ldy   ptr         lda   4+2         sta   4+4+2         lda   4+1         sta   4+4+1         pld         tsc         clc         adc   #4+4         tcs         tya         rtlrdRec	DC.L	name,var	;read variable recordname		DS.B 256                      ;shell variable namevar		DS.B 257                      ;shell variable value		ENDP******************************************************************  long labs(long i)**  Return the absolute value of i.**  Inputs:*        i - argument**  Outputs:*        Returns abs(i).******************************************************************		EXPORT	labs     labs     PROC;;       csubroutine (4:i),0	; i        equ   0+4+0         tsc         phd         tcd         lda   i+2         bpl   lb1;;       sub4  #0,i,i;;       ~SETM	;          SEC;;       ~LDA  #0         LDA   #0;;       ~OP   SBC,i         SBC   i;;       ~STA  i         STA   i;;       ~LDA.H #0	;          LDA   #^0;;       ~OP.H SBC,i	;          SBC   2+i;;       ~STA.H i	;          STA   2+i;;       ~RESTM	; ;;lb1    creturn 4:ilb1	;          ldx   i+2         ldy   i         lda   0+2         sta   0+4+2         lda   0+1         sta   0+4+1         pld         tsc         clc         adc   #0+4         tcs         tya         rtl		ENDP******************************************************************  ldiv_t ldiv(n,d)*        long n,d;**  Inputs:*        n - numerator*        d - denominator**  Outputs:*        ldiv_t - contains result & remainder******************************************************************		EXPORT	ldiv     ldiv     PROCaddr     equ   1;;       csubroutine (4:n,4:d),4	; n        equ   0+4+4d        equ   4+4+4         tsc         sec         sbc   #4         tcs         phd         tcd         phb                            ;use local addressing         phk         plb;;       ph4   n                        ;do the divide	;          LDA   n+2         PHA         LDA   n         PHA;;       ph4   d	;          LDA   d+2         PHA         LDA   d         PHA         jsl   ~DIV4;;       pl4   div_t	;          PLA         STA   div_t         PLA         STA   div_t+2;;       pl4   div_t+4	;          PLA         STA   div_t+4         PLA         STA   div_t+4+2         lda   div_t+2                  ;if the result is negative then         bpl   lb1;;       sub4  #0,div_t+4,div_t+4       ;  make the remainder negative;;       ~SETM	;          SEC;;       ~LDA  #0         LDA   #0;;       ~OP   SBC,div_t+4         SBC   div_t+4;;       ~STA  div_t+4         STA   div_t+4;;       ~LDA.H #0	;          LDA   #^0;;       ~OP.H SBC,div_t+4	;          SBC   2+div_t+4;;       ~STA.H div_t+4	;          STA   2+div_t+4;;       ~RESTM	; ;;lb1    lla   addr,div_t               ;return the resultlb1	;          LDA   #div_t         STA   addr         LDA   #^div_t         STA   2+addr         plb;;       creturn 4:addr	;          ldx   addr+2         ldy   addr         lda   4+2         sta   4+8+2         lda   4+1         sta   4+8+1         pld         tsc         clc         adc   #4+8         tcs         tya         rtldiv_t		DS.B 8		ENDP******************************************************************  void qsort(base, count, size, compar)*        void *base;*        size_t count, size;*        int (*compar)(const void *, const void *)**  Inputs:*        base - start address of the array to sort*        count - # elements in the array*        size - size of each array element*        compar - function that compares array elements**  Outputs:*        The array is sorted on exit.******************************************************************		EXPORT	qsort    qsort    PROC;;       csubroutine (4:base,4:count,4:size,4:compar),0	; base     equ   0+4+0count    equ   4+4+0size     equ   8+4+0compar   equ   12+4+0         tsc         phd         tcd         phb         phk         plb;;       dec4  count                    ;set count to the addr of the last entry;;       ~SETM	;          LDA   count         BNE   ~3         DEC   2+count~3       DEC   count;;       ~RESTM	; ;;       mul4  count,size;;       ~SETM	; ;;       PH4   count	;          LDA   count+2         PHA         LDA   count         PHA;;       PH4   size	;          LDA   size+2         PHA         LDA   size         PHA         JSL   ~MUL4;;       PL4   count	;          PLA         STA   count         PLA         STA   count+2;;       ~RESTM	; ;;       add4  count,base;;       ~SETM	;          CLC;;       ~LDA  count         LDA   count;;       ~OP   ADC,base         ADC   base;;       ~STA  count         STA   count;;       ~LDA.H count	;          LDA   2+count;;       ~OP.H ADC,base	;          ADC   2+base;;       ~STA.H count	;          STA   2+count;;       ~RESTM	; ;;       move4 size,lsize               ;save size in a global var;;       ~SETM	;          LDA   2+size         STA   2+lsize         LDA   size         STA   lsize;;       ~RESTM	;          lda   compar                   ;set the jsl addresses         sta   jsl1+1         sta   jsl2+1         lda   compar+1         sta   jsl1+2         sta   jsl2+2;;       ph4   count                    ;do the sort	;          LDA   count+2         PHA         LDA   count         PHA;;       ph4   base	;          LDA   base+2         PHA         LDA   base         PHA         jsl   rsort         plb;;       creturn	;          lda   0+2         sta   0+16+2         lda   0+1         sta   0+16+1         pld         tsc         clc         adc   #0+16         tcs         rtl		ENDP******************************************************************  rand - get a random number**  Outputs:*        A - random number******************************************************************		EXPORT	rand     rand     PROC         lda   >~srand                  ;if no initialization then         bne   lb1;;       ph2   #1                       ;  initialize with a value of 1	;          PEA   1         jsl   srandlb1      jsl   ~RANX                    ;find the random number         lda   >~SEED         and   #$7FFF         rtl		EXPORT	~srand~srand		;			DC.W	0		ENDP******************************************************************  rsort - recursive sort for qsort**  Inputs:*        first - first array element to ;sort*        last - last array element to sort*******************************************************************rsort    privatersort		PROCleft     equ   1                        ;left addressright    equ   5                        ;right address;;       csubroutine (4:first,4:last),8	; first    equ   0+4+8last     equ   4+4+8         tsc         sec         sbc   #8         tcs         phd         tcd         phb         phk         plbsr0      lda   last+2                   ;if last <= first then quit         cmp   first+2         bne   sr1         lda   last         cmp   first;;sr1    bgt   sr1asr1      BEQ   *+4         BGE   sr1a         plb;;       creturn	;          lda   8+2         sta   8+8+2         lda   8+1         sta   8+8+1         pld         tsc         clc         adc   #8+8         tcs         rtl;;sr1a   move4 last,right               ;right = last;;sr1a   ~SETMsr1a	;          LDA   2+last         STA   2+right         LDA   last         STA   right;;       ~RESTM	; ;;       move4 first,left               ;left = first;;       ~SETM	;          LDA   2+first         STA   2+left         LDA   first         STA   left;;       ~RESTM	;          bra   sr3;;sr2    add4  left,lsize               ;inc left until *left >= *last;;sr2    ~SETMsr2	;          CLC;;       ~LDA  left         LDA   left;;       ~OP   ADC,lsize         ADC   lsize;;       ~STA  left         STA   left;;       ~LDA.H left	;          LDA   2+left;;       ~OP.H ADC,lsize	;          ADC   2+lsize;;       ~STA.H left	;          STA   2+left;;       ~RESTM	; ;;sr3    ph4   lastsr3	;          LDA   last+2         PHA         LDA   last         PHA;;       ph4   left	;          LDA   left+2         PHA         LDA   left         PHA		ENTRY	jsl1jsl1		;		         jsl   jsl1         tax         bmi   sr2sr4      lda   right                    ;quit if right = first         cmp   first         bne   sr4a         lda   right+2         cmp   first+2         beq   sr4b;;sr4a   sub4  right,lsize              ;dec right until *right <= *last;;sr4a   ~SETMsr4a	;          SEC;;       ~LDA  right         LDA   right;;       ~OP   SBC,lsize         SBC   lsize;;       ~STA  right         STA   right;;       ~LDA.H right	;          LDA   2+right;;       ~OP.H SBC,lsize	;          SBC   2+lsize;;       ~STA.H right	;          STA   2+right;;       ~RESTM	; ;;       ph4   last	;          LDA   last+2         PHA         LDA   last         PHA;;       ph4   right	;          LDA   right+2         PHA         LDA   right         PHA		ENTRY	jsl2jsl2		;		         jsl   jsl2         dec   A         bpl   sr4;;sr4b   ph4   left                     ;swap left/right entriessr4b	;          LDA   left+2         PHA         LDA   left         PHA;;       ph4   right	;          LDA   right+2         PHA         LDA   right         PHA         jsr   swap         lda   left+2                   ;loop if left < right         cmp   right+2         bne   sr5         lda   left         cmp   rightsr5      blt   sr2;;       ph4   right                    ;sqap left/right entries	;          LDA   right+2         PHA         LDA   right         PHA;;       ph4   left	;          LDA   left+2         PHA         LDA   left         PHA         jsr   swap;;       ph4   left                     ;swap left/last entries	;          LDA   left+2         PHA         LDA   left         PHA;;       ph4   last	;          LDA   last+2         PHA         LDA   last         PHA         jsr   swap;;       sub4  left,lsize,right         ;sort left part of array;;       ~SETM	;          SEC;;       ~LDA  left         LDA   left;;       ~OP   SBC,lsize         SBC   lsize;;       ~STA  right         STA   right;;       ~LDA.H left	;          LDA   2+left;;       ~OP.H SBC,lsize	;          SBC   2+lsize;;       ~STA.H right	;          STA   2+right;;       ~RESTM	; ;;       ph4   right	;          LDA   right+2         PHA         LDA   right         PHA;;       ph4   first	;          LDA   first+2         PHA         LDA   first         PHA         jsl   rsort;;       add4  left,lsize,first         ;sort right part of array;;       ~SETM	;          CLC;;       ~LDA  left         LDA   left;;       ~OP   ADC,lsize         ADC   lsize;;       ~STA  first         STA   first;;       ~LDA.H left	;          LDA   2+left;;       ~OP.H ADC,lsize	;          ADC   2+lsize;;       ~STA.H first	;          STA   2+first;;       ~RESTM	;          brl   sr0;;  swap - swap two entries;l        equ   3                        ;left entryr        equ   7                        ;right entryswap     tsc                            ;set up addressing         phd         tcd         ldx   lsize+2                  ;move 64K chunks         beq   sw2         ldy   #0sw1      lda   [l],Y         tax         lda   [r],Y         sta   [l],Y         txa         sta   [r],Y         dey         dey         bne   sw1         inc   l+2         inc   r+2         dex         bne   sw1sw2      lda   lsize                    ;if there are an odd number of bytes then         lsr   A         bcc   sw3;;       short M                        ;  move one byte         SEP   #1*32+0*16			LONGA OFF         lda   [l]         tax         lda   [r]         sta   [l]         txa         sta   [r];;       long  M         REP   #1*32+0*16			LONGA ON;;       inc4  l;;       ~SETM	;          INC   l         BNE   ~61         INC   2+l;;~61    ~RESTM~61	; ;;       inc4  r;;       ~SETM	;          INC   r         BNE   ~64         INC   2+r;;~64    ~RESTM~64	;          lda   lsize         lsr   Asw3      asl   A                        ;quit if there are no more bytes         beq   sw6         tay         bra   sw5sw4      lda   [l],Y                    ;move the bytes         tax         lda   [r],Y         sta   [l],Y         txa         sta   [r],Ysw5      dey         dey         bne   sw4         lda   [l]         tax         lda   [r]         sta   [l]         txa         sta   [r]sw6      pld         plx         tsc         clc         adc   #8         tcs         phx         rts;;  local data;		ENTRY	lsizelsize		;				DS.B 4                        ;local copy of size		ENDP******************************************************************  srand - seed the random number generator**  Inputs:*        4,S - random number seed******************************************************************		EXPORT	srand    srand    PROC         lda   #1         sta   >~srand         phb         plx         ply         pla         phy         phx         plb         brl   ~RANX2		ENDP******************************************************************  strtol - convert a string to a long**  Inputs:*        str - pointer to the string*        ptr - pointer to a pointer; a pointer to the first*              char past the number is placed here.  If ptr is*              nil, no pointer is returned*        base - base of the number**  Outputs:*        X-A - converted number******************************************************************		EXPORT	strtol   strtol   PROCbase     equ   18                       ;baseptr      equ   14                       ;*return pointerstr      equ   10                       ;string pointerrtl      equ   7                        ;return addressval      equ   3                        ;valuenegative equ   1                        ;is the number negative?         pea   0                        ; make room for & initialize negative         pea   0                        ; make room for & initialize val         pea   0         tsc                            ;set up direct page addressing         phd         tcd;;  Skip any leading whitespace;         lda   ptr                      ;if ptr in non-null then         ora   ptr+2         beq   sw1         lda   str                      ;  initialize it to str         sta   [ptr]         ldy   #2         lda   str+2         sta   [ptr],Ysw1      lda   [str]                    ;skip the white space         and   #$00FF         tax         lda   >__ctype+1,X         and   #_space         beq   cn0;;       inc4  str;;       ~SETM	;          INC   str         BNE   ~2         INC   2+str;;~2     ~RESTM~2	;          bra   sw1;;  Convert the number;cn0      lda   [str]                    ;if the next char is '-' then         and   #$00FF         cmp   #'-'         bne   cn1         inc   negative                 ;  negative := true         bra   cn2                      ;  ++strcn1      cmp   #'+'                     ;else if the char is '+' then         bne   cn3;;cn2    inc4  str                      ;  ++str;;cn2    ~SETMcn2	;          INC   str         BNE   ~5         INC   2+str;;~5     ~RESTM~5	; ;;cn3    ph4   str                      ;save the starting stringcn3	;          LDA   str+2         PHA         LDA   str         PHA;;       ph2   base                     ;convert the unsigned number	;          LDA   base         PHA;;       ph4   ptr	;          LDA   ptr+2         PHA         LDA   ptr         PHA;;       ph4   str	;          LDA   str+2         PHA         LDA   str         PHA         jsl   strtoul         stx   val+2         sta   val         txy                            ;see if we have an overflow         bpl   rt1;;  Overflow - flag the error;         lda   #ERANGE                  ;errno = ERANGE         sta   >errno         lda   ptr                      ;if ptr <> NULL then         ora   ptr+2         bne   rt1         lda   1,S                      ;  *ptr = original str         sta   [ptr]         ldy   #2         lda   3,S         sta   [ptr],Y;;  return the results;rt1      pla                            ;remove the original value of str from         pla                            ; the stack         lda   negative                 ;if negative then         beq   rt2;;       sub4  #0,val,val               ;  val = -val;;       ~SETM	;          SEC;;       ~LDA  #0         LDA   #0;;       ~OP   SBC,val         SBC   val;;       ~STA  val         STA   val;;       ~LDA.H #0	;          LDA   #^0;;       ~OP.H SBC,val	;          SBC   2+val;;       ~STA.H val	;          STA   2+val;;       ~RESTM	; rt2      ldx   val+2                    ;get the value         ldy   val         lda   rtl                      ;fix the stack         sta   base-1         lda   rtl+1         sta   base         pld         tsc         clc         adc   #16         tcs         tya                            ;return         rtl		ENDP******************************************************************  strtoul - convert a string to an unsigned long**  Inputs:*        str - pointer to the string*        ptr - pointer to a pointer; a pointer to the first*              char past the number is placed here.  If ptr is*              nil, no pointer is returned*        base - base of the number**  Outputs:*        X-A - converted number******************************************************************		EXPORT	strtoul  strtoul  PROCbase     equ   18                       ;baseptr      equ   14                       ;*return pointerstr      equ   10                       ;string pointerrtl      equ   7                        ;return addressval      equ   3                        ;valuefoundOne equ   1                        ;have we found a number?         pea   0                        ; make room for & initialize foundOne         pea   0                        ; make room for & initialize val         pea   0         tsc                            ;set up direct page addressing         phd         tcd;;  Skip any leading whitespace;         lda   ptr                      ;if ptr in non-null then         ora   ptr+2         beq   sw1         lda   str                      ;  initialize it to str         sta   [ptr]         ldy   #2         lda   str+2         sta   [ptr],Ysw1      lda   [str]                    ;skip the white space         and   #$00FF         tax         lda   >__ctype+1,X         and   #_space         beq   db1;;       inc4  str;;       ~SETM	;          INC   str         BNE   ~2         INC   2+str;;~2     ~RESTM~2	;          bra   sw1;;  Deduce the base;db1      lda   [str]                    ;skip any leading '+'         and   #$00FF         cmp   #'+'         bne   db1a;;       inc4  str;;       ~SETM	;          INC   str         BNE   ~5         INC   2+str;;~5     ~RESTM~5	; db1a     lda   base                     ;if the base is zero then         bne   db2         lda   #10                      ;  assume base 10         sta   base         lda   [str]                    ;  if the first char is 0 then         and   #$00FF         cmp   #'0'         bne   db2         lda   #8                       ;    assume base 8         sta   base         ldy   #1                       ;    if the second char is 'X' or 'x' then         lda   [str],Y         and   #$005F         cmp   #'X'         bne   db2         asl   base                     ;      base 16db2      lda   [str]                    ;if the first two chars are 0x or 0X then         and   #$5F7F         cmp   #'X0'         bne   cn1;;       add4  str,#2                   ;  skip them;;       ~SETM	;          CLC;;       ~LDA  str         LDA   str;;       ~OP   ADC,#2         ADC   #2;;       ~STA  str         STA   str         BCC   ~8;;       ~OP.H INC,str	;          INC   2+str~8	; ;;       ~RESTM	;          lda   base                     ;  make sure the base is 16         cmp   #16         bne   returnERANGE;;  Convert the number;cn1      lda   [str]                    ;get a (possible) digit         and   #$00FF         cmp   #'0'                     ;branch if it is not a digit         blt   cn5         cmp   #'9'+1                   ;branch if it is a numeric digit         blt   cn2         and   #$005F                   ;convert lowercase to uppercase         cmp   #'A'                     ;branch if it is not a digit         blt   cn5         cmp   #'Z'+1                   ;branch if it is not a digit         bge   cn5         sbc   #'A'-11                  ;convert 'alpha' digit to value         bra   cn3                      ;go test the digitcn2      and   #$000F                   ;convert digit to valuecn3      cmp   base                     ;branch if the digit is too big         bge   cn5         ldx   #1                       ;note that we have found a number         stx   foundOne         pha                            ;save the digit         pha                            ;val = val*base         pha         pha         pha;;       ph4   val	;          LDA   val+2         PHA         LDA   val         PHA         pea   0;;       ph2   base	;          LDA   base         PHA;;       _LongMul         LDX   #$0C0B         JSL   $E10000;;       pl4   val	;          PLA         STA   val         PLA         STA   val+2         pla                            ;branch if there was an error         ora   1,S         plx         ply         tax         bne   returnERANGE         clc                            ;add in the new digit         tya         adc   val         sta   val         bcc   cn4         inc   val+2         beq   returnERANGE;;cn4    inc4  str                      ;next char;;cn4    ~SETMcn4	;          INC   str         BNE   ~19         INC   2+str;;~19    ~RESTM~19	;          bra   cn1cn5      lda   foundOne                 ;if no digits were found, flag the error         bne   rt1;;  flag an error;returnERANGE	;          lda   #ERANGE                  ;errno = ERANGE         sta   >errno         bra   rt2                      ;skip setting ptr;;  return the results;rt1      lda   ptr                      ;if ptr is non-null then         ora   ptr+2         beq   rt2         lda   str                      ;  set it to str         sta   [ptr]         ldy   #2         lda   str+2         sta   [ptr],Yrt2      ldx   val+2                    ;get the value         ldy   val         lda   rtl                      ;fix the stack         sta   base-1         lda   rtl+1         sta   base         pld         tsc         clc         adc   #16         tcs         tya                            ;return         rtl		ENDP******************************************************************  int system(command)*        char *command;**  Executes the command steam as an exec file.**  Inputs:*        command - command string**  Outputs:*        Returns the status of the command******************************************************************		EXPORT	system   system   PROC         phb                            ;get the addr of the string from the         phk                            ; stack         plb         plx         ply         pla         sta   exComm         pla         sta   exComm+2         phy                            ;execute the command         phx         plb;;       Execute ex;;       ~SETM	;          JSL   $E100A8	DC.W	$010D	DC.L	ex;;       ~RESTM	;          rtlex	DC.W	$8000exComm		DS.B 4		ENDP******************************************************************  void va_end(list)*        va_list list;**  Remove variable length arguments from the stack.**  Inputs:*        list - Pointer to an array.  The second element is a*              pointer to the first variable argument, while*              the first is a pointer to the first byte past*              the argument list.**  Notes:*        1. The number of bytes to remove must be even.*        2. D is incremented by the # of bytes removed.******************************************************************		EXPORT	va_end   va_end   PROClist     equ   7                        ;pointer to the arrayD        equ   1                        ;caller's DP         phb                            ;save the caller's data bank         phd                            ;save the caller's D reg         tsc                            ;set up our stack frame         tcd         sec                            ;calculate the # of bytes to be removed         ldy   #4         lda   [list]         sbc   [list],Y         sta   >toRemove         clc                            ;update the caller's DP         adc   D         sta   D         lda   [list],Y                 ;set the source address         tax         dex         lda   [list]                   ;set the destination address         tay         dey         sec                            ;set the # of bytes to move - 1         tsc         sbc   [list]         eor   #$FFFF         mvp   0,0                      ;move the bytes         clc                            ;update out stack ptr         tsc         adc   >toRemove         tcs         pld                            ;resore the caller's DP         plx                            ;remove the parameter from the stack         ply         pla         pla         phy         phx         plb                            ;restore the caller's data bank         rtltoRemove		DS.B 2                        ;# bytes to remove		ENDP		END