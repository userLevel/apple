	seg   ''******************************************************************  Native Code Libraries**  These libraries are common routines used by the 65816 ORCA*  native code compilers.**  Copyright 1987, 1990*  Byte Works, Inc.*  All rights reserved.**  By Mike Westerfield and Phil Montoya*  May 1987******************************************************************;-----------------------------------------------;;   Imported addresses;;-----------------------------------------------	IMPORT	EndDesk	IMPORT	EndGraph	IMPORT	ErrorOutputChar	IMPORT	InputChar	IMPORT	OutputChar	IMPORT	SysCharErrout	IMPORT	SysGraphTextShutdown	IMPORT	SysGraphTextStartup	IMPORT	SysIOShutdown	IMPORT	SysIOStartup	IMPORT	~DISPOSE	IMPORT	~MM_DisposeAll	IMPORT	~MM_Init	IMPORT	~NEW	IMPORT	~PUT2	IMPORT	~PUTS	IMPORT	~sign;-----------------------------------------------;;   Forward addresses and entries;;-----------------------------------------------	ENTRY	SystemEnvironmentInit	ENTRY	SystemMMShutDown	ENTRY	SystemMinStack	ENTRY	SystemPrintError	ENTRY	SystemSANEInit	ENTRY	SystemSANEShutDown	ENTRY	SystemUserID	ENTRY	~LineNumber	ENTRY	~NBA_D	ENTRY	~ProcList	ENTRY	~ProcName	ENTRY	~Quit	ENTRY	~ResetName	ENTRY	~User_ID******************************************************************  SystemErrorLocation - Stop execution ;due to a run time error******************************************************************		EXPORT	SystemErrorLocation SystemErrorLocation PROC			longa on			longi on         phk                            ;set data bank         plb         lda   ~LineNumber              ;if there is a non-zero line number then;;       jeq   lb3         BNE   *+5         BRL   lb3;;       puts  #'Error occurred at line ',errout=t print location of error;;       ~SETM	;          BRA   ~3~L3	DC.B	23~S3	DC.B	'Error occurred at line '~3	; ;;       ~PUSHA ~L3-1	;          PEA   +(~L3-1)>>16         PEA   ~L3-1         PEA   0;;       PH2   #C:&CR	;          PEA   0;;       PH2   #C:&ERROUT	;          PEA   1         JSL   ~PUTS;;       ~RESTM	; ;;       put2  ~LineNumber,#1,errout=t;;       ~SETM	; ;;       PH2   ~LineNumber	;          LDA   ~LineNumber         PHA;;       PH2   #1	;          PEA   1;;       PH2   #C:&CR	;          PEA   0;;       PH2   #C:&ERROUT	;          PEA   1         JSL   ~PUT2;;       ~RESTM	; ;;       puts  #' in procedure ',errout=t;;       ~SETM	;          BRA   ~16~L16	DC.B	14~S16	DC.B	' in procedure '~16	; ;;       ~PUSHA ~L16-1	;          PEA   +(~L16-1)>>16         PEA   ~L16-1         PEA   0;;       PH2   #C:&CR	;          PEA   0;;       PH2   #C:&ERROUT	;          PEA   1         JSL   ~PUTS;;       ~RESTM	; ;;       puts  ~ProcName-1,errout=t,cr=t;;       ~SETM	; ;;       ~PUSHA ~ProcName-1	;          PEA   +(~ProcName-1)>>16         PEA   ~ProcName-1         PEA   0;;       PH2   #C:&CR	;          PEA   1;;       PH2   #C:&ERROUT	;          PEA   1         JSL   ~PUTS;;       ~RESTM	;          jsl   ~ResetName               ;  pop proclist         lda   ~ProcList                ;  if ~ProcList <> nil then         ora   ~ProcList+2;;       jeq   lb2         BNE   *+5         BRL   lb2;;       putcr errout=t                 ;    print traceback header;;       ~SETM	;          PEA   $0D         JSL   SysCharErrout         PEA   $0A         JSL   SysCharErrout;;       ~RESTM	; ;;       puts  #'  Line  Name',cr=t,errout=t;;       ~SETM	;          BRA   ~32~L32	DC.B	12~S32	DC.B	'  Line  Name'~32	; ;;       ~PUSHA ~L32-1	;          PEA   +(~L32-1)>>16         PEA   ~L32-1         PEA   0;;       PH2   #C:&CR	;          PEA   1;;       PH2   #C:&ERROUT	;          PEA   1         JSL   ~PUTS;;       ~RESTM	; ;;       puts  #'  ----  ----',cr=t,errout=t;;       ~SETM	;          BRA   ~38~L38	DC.B	12~S38	DC.B	'  ----  ----'~38	; ;;       ~PUSHA ~L38-1	;          PEA   +(~L38-1)>>16         PEA   ~L38-1         PEA   0;;       PH2   #C:&CR	;          PEA   1;;       PH2   #C:&ERROUT	;          PEA   1         JSL   ~PUTS;;       ~RESTM	; lb1      lda   ~ProcList                ;    while ~ProcList <> nil do         ora   ~ProcList+2         beq   lb2;;       put2  ~LineNumber,#6,errout=t  ;      print location of call;;       ~SETM	; ;;       PH2   ~LineNumber	;          LDA   ~LineNumber         PHA;;       PH2   #6	;          PEA   6;;       PH2   #C:&CR	;          PEA   0;;       PH2   #C:&ERROUT	;          PEA   1         JSL   ~PUT2;;       ~RESTM	; ;;       puts  #'  ',errout=t;;       ~SETM	;          BRA   ~51~L51	DC.B	2~S51	DC.B	'  '~51	; ;;       ~PUSHA ~L51-1	;          PEA   +(~L51-1)>>16         PEA   ~L51-1         PEA   0;;       PH2   #C:&CR	;          PEA   0;;       PH2   #C:&ERROUT	;          PEA   1         JSL   ~PUTS;;       ~RESTM	; ;;       puts  ~ProcName-1,errout=t,cr=t;;       ~SETM	; ;;       ~PUSHA ~ProcName-1	;          PEA   +(~ProcName-1)>>16         PEA   ~ProcName-1         PEA   0;;       PH2   #C:&CR	;          PEA   1;;       PH2   #C:&ERROUT	;          PEA   1         JSL   ~PUTS;;       ~RESTM	;          jsl   ~ResetName               ;      pop proclist         bra   lb1                      ;      endwhilelb2	; ;  endiflb3	; ;endif         lda   #$FFFF                   ;quit         brl   ~Quit		ENDP******************************************************************  SystemError - Handle run time errors**  Inputs:*        4,S - error number******************************************************************		EXPORT	SystemError SystemError PROC			longa on			longi onerrorNumber equ 4                       ;error number         lda   errorNumber,S         pha         jsl   SystemPrintError         jml   SystemErrorLocation		ENDP******************************************************************  SystemPrintError - Write a run time error message to errout**  Inputs:*        4,S - error number******************************************************************		EXPORT	SystemPrintError SystemPrintError PROC			longa on			longi onerrorNumber equ 10                      ;error numberaddress  equ   1                        ;address of the error message         phd                            ;save DP;;       ph4   #errorMessages           ;set initial string addr	;          PEA   +(errorMessages)>>16         PEA   errorMessages         tsc                            ;set DP         tcd         ldx   errorNumber              ;find correct stringlb1      dex         beq   lb2         sec         lda   [address]         and   #$00FF         adc   address         sta   address         bra   lb1lb2      dec   address                  ;write it to error out;;       ph2   #0	;          PEA   0;;       ph2   #1	;          PEA   1;;       ph2   #1	;          PEA   1         jsl   ~Puts         pld                            ;restore DP         lda   2,s                      ;fix stack for return         sta   4,s         pla         sta   1,s         rtlerrorMessages	; ;error messages;;       dw    'Subrange exceeded'	DC.B	17SYSA6	DC.B	'Subrange exceeded';;       dw    'File is not open'	DC.B	16SYSA7	DC.B	'File is not open';;       dw    'Read while at end of file'	DC.B	25SYSA8	DC.B	'Read while at end of file';;       dw    'I/O error'	DC.B	9SYSA9	DC.B	'I/O error';;       dw    'Out of memory'	DC.B	13SYSA10	DC.B	'Out of memory';;       dw    'EOLN while at end of file'	DC.B	25SYSA11	DC.B	'EOLN while at end of file';;       dw    'Set overflow'	DC.B	12SYSA12	DC.B	'Set overflow';;       dw    'Jump to undefined case statement label'	DC.B	38SYSA13	DC.B	'Jump to undefined case statement label';;       dw    'Integer math error'	DC.B	18SYSA14	DC.B	'Integer math error';;       dw    'Real math error'	DC.B	15SYSA15	DC.B	'Real math error';;       dw    'Underflow'	DC.B	9SYSA16	DC.B	'Underflow';;       dw    'Overflow'	DC.B	8SYSA17	DC.B	'Overflow';;       dw    'Divide by zero'	DC.B	14SYSA18	DC.B	'Divide by zero';;       dw    'Inexact'	DC.B	7SYSA19	DC.B	'Inexact';;       dw    'Stack overflow'	DC.B	14SYSA20	DC.B	'Stack overflow';;       dw    'Stack error'	DC.B	11SYSA21	DC.B	'Stack error'		ENDP******************************************************************  ~_BWCommon - Global data for the compiler******************************************************************		EXPORT	~_BWCommon ~_BWCommon PROC;;  Misc. variables;		EXPORT	~CommandLine~CommandLine		;		;address of the shell command line		DS.B 4		EXPORT	~EOFInput~EOFInput		;		;end of file flag for input		DS.B 2		EXPORT	~EOLNInput~EOLNInput		;		;end of line flag for input		DS.B 2		EXPORT	ErrorOutputErrorOutput		;		;error output file variable	DC.L	~ErrorOutputChar		EXPORT	~ErrorOutputChar~ErrorOutputChar		;		;error output file buffer		DS.B 2		EXPORT	InputInput		;		;standard input file variable	DC.L	~InputChar		EXPORT	~InputChar~InputChar		;		;standard input file buffer		DS.B 2		EXPORT	~MinStack~MinStack		;		;lowest reserved bank zero address		DS.B 2		EXPORT	OutputOutput		;		;standard output file variable	DC.L	~OutputChar		EXPORT	~OutputChar~OutputChar		;		;standard output file buffer		DS.B 2		EXPORT	~RealVal~RealVal		;		;last real value returned by a function		DS.B 10		EXPORT	~SANEStarted~SANEStarted		;		;did we start SANE?	DC.W	0		EXPORT	~ThisFile~ThisFile		;		;pointer to current file variable		DS.B 4		EXPORT	~StringList~StringList		;		;string buffer list		DS.B 4		EXPORT	~callerStack~callerStack		;		;caller's stack location		DS.B 2;;  Traceback variables;		EXPORT	~ProcList~ProcList		;		;traceback list head		DS.B 4		EXPORT	~LineNumber~LineNumber		;		;current line number		DS.B 2		EXPORT	~ProcName~ProcName		;		;current procedure name		DS.B 32		ENDP******************************************************************  ~_IOCommon - Global data for the IO routines******************************************************************		EXPORT	~_IOCommon ~_IOCommon PROC		EXPORT	sDevTypesDevType		DS.B 2                        ;standard output device type		EXPORT	sDevPointersDevPointer		DS.B 4                        ;standard output device pointer		EXPORT	eDevTypeeDevType		DS.B 2                        ;error output device type		EXPORT	eDevPointereDevPointer		DS.B 4                        ;error output device pointer		EXPORT	~ssRef~ssRef		DS.B 4                        ;StartUpTools reference		ENDP******************************************************************  ~_BWStartUp - Compiler initialization**  Inputs:*        A - user ID*        X-Y - address of the command line*        D - lowest reserved bank zero address*        4,S - amount of stack space to ;reserve**  Outputs:*        ~User_ID - user ID*        ~CommandLine - address of the command line*        ~MinStack - lowest reserved bank zero address*        ~InputChar - set to ' '******************************************************************		EXPORT	~_BWStartUp ~_BWStartUp PROC;;  Set up initial registers;         phk                            ;set the data bank register         plb         ora   #$0100                   ;use local user ID         sta   >~User_ID                ;save the user ID for memory manager use         stx   ~CommandLine+2           ;save the address of the command line         sty   ~CommandLine;;  Allocate bank zero space for stack frames;         tsc                            ;save the caller's stack         clc         adc   #5         sta   ~callerStack;;       ph4   #0                       ;allocate a bank zero	;          PEA   +(0)>>16         PEA   0;;       ph2   #0	;          PEA   0         lda   10,S         pha;;       ph2   >~User_ID	;          LDA   >~User_ID         PHA;;       ph2   #$C105	;          PEA   $C105;;       ph4   #0	;          PEA   +(0)>>16         PEA   0;;       _NewHandle         LDX   #$0902         JSL   $E10000         bcs   oom         tsc                            ;get handle         tcd         lda   [1]                      ;set min stack loc.         sta   ~MinStack         clc                            ;calculate stack address         adc   8,S         dec   A         tax         plx                            ;remove handle         plx         phb                            ;recover return addresses         plx         ply         tcs                            ;set stack pointer         phy                            ;reset return addresses         phx         plb;;  Initialize the environment;         jsl   SystemSANEInit           ;Start up SANE         jsl   SystemEnvironmentInit    ;Set up the various environment variables         jsl   SysIOStartup             ;Start the GS/OS text I/O system         rtl;;  Flag an out of stack memory error;;;oom    puts  #'Insufficient bank zero memory',cr=t,errout=t;;oom    ~SETMoom	;          BRA   ~8~L8	DC.B	29~S8	DC.B	'Insufficient bank zero memory'~8	; ;;       ~PUSHA ~L8-1	;          PEA   +(~L8-1)>>16         PEA   ~L8-1         PEA   0;;       PH2   #C:&CR	;          PEA   1;;       PH2   #C:&ERROUT	;          PEA   1         JSL   ~PUTS;;       ~RESTM	;          lda   #-1         brl   ~Quit		ENDP******************************************************************  ~_BWStartUp2 - Compiler initialization for RTL pragma programs**  Inputs:*        A - user ID*        4,S - amount of stack space to ;reserve (may be 0)**  Outputs:*        ~User_ID - user ID*        ~CommandLine - set to NULL*        ~InputChar - set to ' '******************************************************************		EXPORT	~_BWStartUp2 ~_BWStartUp2 PROC;;  Set up initial registers;         phb                            ;set the data bank register         phk         plb         ora   #$0100                   ;use local user ID         sta   >~User_ID                ;save the user ID for memory manager use         stz   ~CommandLine+2           ;set the address of the command line         stz   ~CommandLine             ; to NULL;;  Allocate bank zero space for stack frames;         tsc                            ;save the caller's stack         clc         adc   #6         sta   ~callerStack;;       ph4   #0                       ;allocate a bank zero	;          PEA   +(0)>>16         PEA   0;;       ph2   #0	;          PEA   0         lda   11,S         pha;;       ph2   >~User_ID	;          LDA   >~User_ID         PHA;;       ph2   #$C105	;          PEA   $C105;;       ph4   #0	;          PEA   +(0)>>16         PEA   0;;       _NewHandle         LDX   #$0902         JSL   $E10000         bcs   oom         tsc                            ;get handle         tcd         lda   [1]                      ;set min stack loc.         sta   ~MinStack         clc                            ;calculate stack address         adc   9,S         dec   A         tax         plx                            ;remove handle         plx         plx                            ;recover return addresses         ply         tcs                            ;set stack pointer         phy                            ;reset return addresses         phx;;  Set up compiler variables;         lda   #' '                     ;reset(input)         sta   ~InputChar         stz   ~EOLNInput         stz   ~EOFInput         stz   ~LineNumber              ;initialize traceback info         stz   ~ProcName         stz   ~ProcList         stz   ~ProcList+2         stz   ~StringList              ;initialize the string buffer list         stz   ~StringList+2         stz   ~thisFile                ;initialize file lists         stz   ~thisFile+2         stz   ~SANEStarted             ;SANE not started         plb                            ;reset caller's B         rtl;;  Flag an out of stack memory error;;;oom    puts  #'Insufficient bank zero memory',cr=t,errout=t;;oom    ~SETMoom	;          BRA   ~8~L8	DC.B	29~S8	DC.B	'Insufficient bank zero memory'~8	; ;;       ~PUSHA ~L8-1	;          PEA   +(~L8-1)>>16         PEA   ~L8-1         PEA   0;;       PH2   #C:&CR	;          PEA   1;;       PH2   #C:&ERROUT	;          PEA   1         JSL   ~PUTS;;       ~RESTM	;          lda   #-1         brl   ~Quit		ENDP******************************************************************  ~_BWStartUp3 - Compiler initialization using stack frames**  Inputs:*        A - user ID*        X-Y - address of the command line*        D - lowest reserved bank zero address**  Outputs:*        ~User_ID - user ID*        ~CommandLine - address of the command line*        ~MinStack - lowest reserved bank zero address*        ~InputChar - set to ' '**  Notes:*        This subroutine differs from ~_BWStartUp, which it*        replaces, in that it uses whatever stack segment the*        program launcher allocated.  Compilers allocate stack*        frames of a particular size by ;creating their own stack*        segment.******************************************************************		EXPORT	~_BWStartUp3 ~_BWStartUp3 PROC         pha                            ;save the input values         phx         phy         jsl   SystemUserID         jsl   SystemMinStack           ;Set ~MinStack to the start of the stack segment         jsl   SystemSANEInit           ;Start up SANE         jsl   SystemEnvironmentInit    ;Set up the various environment variables         jsl   SysIOStartup             ;Start the GS/OS text I/O system         rtl		ENDP******************************************************************  ~_BWStartUp4 - Compiler initialization for RTL pragma programs*        using stack frames**  Inputs:*        A - user ID**  Outputs:*        ~User_ID - user ID*        ~CommandLine - set to NULL*        ~InputChar - set to ' '******************************************************************		EXPORT	~_BWStartUp4 ~_BWStartUp4 PROC         pha                            ;save the user ID         pea   0                        ;no command line         pea   0         jsl   SystemUserID         tsc                            ;save the SP         clc         adc   #3         sta   >~callerStack         jsl   SystemMinStack           ;Set ~MinStack to the start of the stack segment         lda   #0                       ;SANE is not started         sta   >~SANEStarted         jsl   SystemEnvironmentInit    ;Set up the various environment variables         rtl		ENDP******************************************************************  Pasvars - Pascal variables******************************************************************		EXPORT	~PasVars ~PasVars PROC		EXPORT	~ToolError~ToolError		;		;last error in a tool call (Pascal)		DS.B 2		EXPORT	~User_ID~User_ID		;		;user ID (Pascal, libraries)		DS.B 2		ENDP******************************************************************  ~AShr4 - Shift a signed long value right**  Inputs:*        A - value to shift*        X - # bits to shift by**  Outputs:*        A - result******************************************************************		EXPORT	~AShr4   ~AShr4   PROCnum1     equ   8                        ;number to shiftnum2     equ   4                        ;# bits to shift by         tsc                            ;set up DP         phd         tcd         lda   num2+2                   ;if num2 < 0 then         bpl   lb2         cmp   #$FFFF                   ;  shift left         bne   zero         ldx   num2         cpx   #-34         blt   zerolb1      asl   num1         rol   num1+2         inx         bne   lb1         bra   lb4zero     stz   num1                     ;  (result is zero)         stz   num1+2         bra   lb4lb2      bne   zero                     ;else shift right         ldx   num2         beq   lb4         cpx   #33         bge   zerolb3      lda   num1+2         asl   A         ror   num1+2         ror   num1         dex         bne   lb3lb4      lda   0                        ;fix stack and return         sta   num2         lda   2         sta   num2+2         pld         pla         pla         rtl		ENDP******************************************************************  ~CheckStack - check for a stack overflow**  This routine is called on entry to each procedure or*  function (if RangeCheck+ has been specified) to check for*  an overflow of the run time stack.**  Inputs:*        4,S - amount of stack space to ;be allocated*        ~MinStack - lowest available stack location**  Notes:*        1. X register MUST be preserved.******************************************************************		EXPORT	~CheckStack ~CheckStack PROCEvalRoom equ   200                      ;# bytes to leave free for the*                                       ; evaluation stack         sec                            ;compute the lowest stack value         tsc                            ; endangered by this call         sbc   4,S         sbc   #EvalRoom         cmp   >~MinStack               ;if it is smaller than ~MinStack then         bge   ck1         phx;;       error #15                      ;  flag stack overflow error;;       ph2   #15	;          PEA   15         jsl   SystemError         plxck1      lda   2,S                      ; remove input from stack & return         sta   4,S         lda   0,S         sta   2,S         pla         rtl		ENDP******************************************************************  ~EndDesk - Shut down QuickDraw and desktop tools; return to text mode*  ~EndGraph - Shut down QuickDraw; return to text mode******************************************************************		EXPORT	~EndDesk ~EndDesk PROC		EXPORT	~EndGraph~EndGraph		;			;using ~_IOCommon         phb         phk         plb;;       ph2   #0	;          PEA   0;;       ph4   ~ssRef	;          LDA   ~ssRef+2         PHA         LDA   ~ssRef         PHA;;       _ShutDownTools         ldx   #$1901         jsl   $E10000         jsl   SysGraphTextShutdown         plb         rtl		ENDP******************************************************************  ~GeqL - Test two long integers for A ;>= B**  Inputs:*        num1 - 1st argument*        X-A - 2nd argument**  Outputs:*        A - 1 if true, else 0*        Z - 0 if true, else 1******************************************************************		EXPORT	~GeqL    ~GeqL    PROC			longa on			longi onnum1     equ   8                        ;disp of 1st argret      equ   5                        ;return addressworkDP   equ   1                        ;disp of 2nd argument         ldy   #0                       ;assume false         phx                            ;save 2nd argument         pha         tsc                            ;set up stack frame         phd         tcd         txa                            ;if numbers have opposite sign then         eor   num1+2         bpl   lb1         lda   workDP+2                 ;  reverse sense of compare         cmp   num1+2         bra   lb2lb1      lda   num1+2                   ;else         cmp   workDP+2                 ;  compare numbers         bne   lb2         lda   num1         cmp   workDPlb2	; ;endif         blt   lb3         iny                            ;restult is truelb3      lda   ret+1                    ;restore stack         sta   num1+2         lda   ret         sta   num1+1         pld         tsc         clc         adc   #8         tcs         tya                            ;result -> A reg         rtl		ENDP******************************************************************  ~GrtL - Test two long integers for A ;> B**  Inputs:*        n1,n2: numbers**  Outputs:*        A - 1 if true, else 0*        Z - 0 if true, else 1******************************************************************		EXPORT	~GrtL    ~GrtL    PROC			longa on			longi onnum1     equ   8                        ;disp of 1st argnum2     equ   4                        ;disp of 2nd arg         ldx   #0                       ;assume false         lda   num1+2,S                 ;if numbers have opposite sign then         eor   num2+2,S         bpl   lb1         lda   num2+2,S                 ;  reverse sense of compare         cmp   num1+2,S         bra   lb2lb1      lda   num1+2,S                 ;else         cmp   num2+2,S                 ;  compare numbers         bne   lb2         lda   num1,S         cmp   num2,Slb2	; ;endif         blt   lb3         beq   lb3         inx                            ;restult is truelb3      phb                            ;restore stack         pla         sta   7,S         pla         sta   7,S         pla         pla         plb         txa                            ;result -> A reg         rtl		ENDP******************************************************************  ~Halt - Stop execution and return with error code**  Inputs:*        error - error code******************************************************************		EXPORT	~Halt    ~Halt    PROCerror    equ   4         lda   error,S         brl   ~Quit		ENDP******************************************************************  ~LoadTools - Load the tools from the ;boot disk*  ~UnLoadTools - Unload the tools from ;the boot disk******************************************************************		EXPORT	~LoadTools ~LoadTools PROC			longa on			longi on;;       ph4   #toolTable               ;try loading tools	;          PEA   +(toolTable)>>16         PEA   toolTable;;       _LoadTools         LDX   #$0E01         JSL   $E10000         rts;;  Unload tools (uses the same table as ;load tools for accuracy);		EXPORT	~UnLoadTools~UnLoadTools		;		         phb         phk         plb         ldx   toolTable         ldy   #2un1      lda   toolTable,Y         phy         phx         pha;;       _UnloadOneTool         LDX   #$1001         JSL   $E10000         plx         pla         clc         adc   #4         tay         dex         bne   un1         plb         rts;;  Local data;toolTable	DC.W	13	DC.W	4,$0101	;quickdraw	DC.W	5,$0100	;desk manager	DC.W	6,$0100	;event manager	DC.W	14,$0103	;window manager	DC.W	15,$0103	;menu manager	DC.W	16,$0103	;control manager	DC.W	18,$0100	;quickdraw aux tools	DC.W	20,$0100	;line edit	DC.W	21,$0100	;dialog manager	DC.W	22,$0100	;scrap manager	DC.W	23,$0100	;standard files	DC.W	27,$0100	;font manager	DC.W	30,$0100	;resource manager		ENDP******************************************************************  ~LongMove - move some bytes**  Inputs:*        source - pointer to source bytes*        dest - pointer to destination bytes*        len - number of bytes to move**  Notes:*        This subroutine leaves the destination address on the*        stack.  It differs from ~Move in that it can move 64K*        or more.******************************************************************		EXPORT	~LongMove ~LongMove PROC;;       sub   (4:len,4:source,4:dest),0	; len      EQU   3source   EQU   7dest     EQU   11         TDC         TAX         TSC         SEC         SBC   #0-1         TCD         DEC   A         TCS         PHX         ldx   len+2                    ;move whole banks         beq   lm2         ldy   #0lm1      lda   [source],Y         sta   [dest],Y         dey         dey         bne   lm1         inc   source+2         inc   dest+2         dex         bne   lm1lm2      lda   len                      ;move one byte if the move length is odd         lsr   a         bcc   lb1;;       short M         SEP   #1*32+0*16			LONGA OFF         lda   [source]         sta   [dest];;       long  M         REP   #1*32+0*16			LONGA ON;;       inc4  source;;       ~SETM	;          INC   source         BNE   ~5         INC   2+source;;~5     ~RESTM~5	; ;;       inc4  dest;;       ~SETM	;          INC   dest         BNE   ~8         INC   2+dest;;~8     ~RESTM~8	;          dec   lenlb1      ldy   len                      ;move the bytes         beq   lb4         dey         dey         beq   lb3lb2      lda   [source],Y         sta   [dest],Y         dey         dey         bne   lb2lb3      lda   [source]         sta   [dest];;lb4    returnlb4      LDA   0+1         STA   15-2         LDA   0         STA   15-3         CLC         TDC         ADC   #15-4         PLD         TCS         RTL		ENDP******************************************************************  ~Move - move some bytes**  Inputs:*        source - pointer to source bytes*        dest - pointer to destination bytes*        len - number of bytes to move******************************************************************		EXPORT	~Move    ~Move    PROC;;       sub   (2:len,4:source,4:dest),0	; len      EQU   3source   EQU   5dest     EQU   9         TDC         TAX         TSC         SEC         SBC   #0-1         TCD         DEC   A         TCS         PHX         lda   len                      ;move one byte if the move length is odd         lsr   a         bcc   lb1;;       short M         SEP   #1*32+0*16			LONGA OFF         lda   [source]         sta   [dest];;       long  M         REP   #1*32+0*16			LONGA ON;;       inc4  source;;       ~SETM	;          INC   source         BNE   ~5         INC   2+source;;~5     ~RESTM~5	; ;;       inc4  dest;;       ~SETM	;          INC   dest         BNE   ~8         INC   2+dest;;~8     ~RESTM~8	;          dec   lenlb1      ldy   len                      ;move the bytes         beq   lb4         dey         dey         beq   lb3lb2      lda   [source],Y         sta   [dest],Y         dey         dey         bne   lb2lb3      lda   [source]         sta   [dest];;lb4    returnlb4      LDA   0+1         STA   13-2         LDA   0         STA   13-3         CLC         TDC         ADC   #13-4         PLD         TCS         RTL		ENDP******************************************************************  __NBACallBack - HyperStudio callback**  extern pascal void __NBACALLBACK (int, HSParamPtr);**  Inputs:*        call - call number*        HSParamPtr - parameter block******************************************************************		EXPORT	__NBACallBack __NBACallBack PROC	;using ~NBACommoncall     equ   10                       ;callback numberHSParamPtr equ 6                        ;HyperStudio parameter record         phd                            ;set up HyperStudio D reg         lda   >~NBA_D         tcd         lda   HSParamPtr,S             ;set up the parameter address         sta   0         lda   HSParamPtr+2,S         sta   2         ldy   #24                      ;set up the callback number         lda   call,S         sta   [0],Y         ldy   #16                      ;set up the jsl address         lda   [0],Y         sta   >jsl+1         iny         lda   [0],Y         sta   >jsl+2jsl      jsl   jsl         pld                            ;return         phb         plx         ply         pla         pla         pla         phy         phx         plb         rtl		ENDP******************************************************************  ~NBACommon - common area for HyperStudio New Button Action*******************************************************************~NBACommon privdata~NBACommon		PROC			ENTRY	~NBA_B~NBA_B		DS.B 2                        ;caller's B register		ENTRY	~NBA_D~NBA_D		DS.B 2                        ;caller's D register		ENDP******************************************************************  ~NBAShutdown - shutdown code for a HyperStudio New Button Action******************************************************************		EXPORT	~NBAShutdown ~NBAShutdown PROC	;using ~NBACommon         jsl   ~MM_DisposeAll           ;shut down the compiler's memory manager         jsl   ~MM_Init         lda   >~NBA_B                  ;restore HyperStudio B         pha         plb         plb         rtl		ENDP******************************************************************  ~NBAStartup - startup code for a HyperStudio New Button Action******************************************************************		EXPORT	~NBAStartup ~NBAStartup PROC	;using ~NBACommon         phx                            ;save the parameter address         phy         phb                            ;save the caller's data bank         phb         pla         sta   >~NBA_B         phk                            ;set up our data bank         plb         ora   #$0100                   ;set up our user ID         sta   >~User_ID         tdc                            ;save the HyperStudio DP         sta   >~NBA_D         jsl   SystemEnvironmentInit    ;Set up the various environment variables         ply         plx         rtl		ENDP******************************************************************  ~PDiv4 - Four Byte Signed Integer Divide**  Inputs:*        NUM1 - denominator*        NUM2 - numerator**  Outputs:*        ANS - result*        REM - remainder*        V - set for division by zero**  Notes*        1) Uses ~SIGN.******************************************************************		EXPORT	~PDiv4   ~PDiv4   PROCsign     equ   1                        ;sign of answernum1     equ   20                       ;argumentsnum2     equ   16ans      equ   5                        ;answerrem      equ   9                        ;remainderreturn   equ   13;;  Initialize;         tsc                            ;set up DP         sec         sbc   #12         tcs         phd         tcd         lda   num2                     ;check for division by zero         ora   num2+2         bne   dv1;;       error #9                       ;integer math error;;       ph2   #9	;          PEA   9         jsl   SystemError         brl   dv10dv1      jsl   ~sign                    ;convert to positive numbers         lda   num1+2                   ;do 16 bit divides separately         ora   num2+2         beq   dv5;;  32 bit divide;         ldy   #32                      ;32 bits to godv3      asl   ans                      ;roll up the next number         rol   ans+2         rol   ans+4         rol   ans+6         sec                            ;subtract for this digit         lda   ans+4         sbc   num2         tax         lda   ans+6         sbc   num2+2         bcc   dv4                      ;branch if minus         stx   ans+4                    ;turn the bit on         sta   ans+6         inc   ansdv4      dey                            ;next bit         bne   dv3         beq   dv9                      ;go do the sign;;  16 bit divide;dv5      lda   #0                       ;initialize the remainder         ldy   #16                      ;16 bits to godv6      asl   ans                      ;roll up the next number         rol   A         sec                            ;subtract the digit         sbc   num2         bcs   dv7         adc   num2                     ;digit is 0         dey         bne   dv6         beq   dv8dv7      inc   ans                      ;digit is 1         dey         bne   dv6dv8      sta   ans+4                    ;save the remainder;;  Set sign;dv9      lda   sign                     ;branch if positive         beq   dv10         sec                            ;negate the result         lda   #0         sbc   ans         sta   ans         lda   #0         sbc   ans+2         sta   ans+2dv10     lda   ans                      ;move answer, remainder to stack         sta   num1         lda   ans+2         sta   num1+2         lda   return-1         sta   num2         lda   return+1         sta   num2+2         clv         pld                            ;fix stack, DP         tsc         clc         adc   #16         tcs         rtl		ENDP******************************************************************  ~Quit - Quit code for normal compiler shutdown******************************************************************		EXPORT	~Quit    ~Quit    PROC         pha                            ;save the return code         jsl   SysIOShutdown            ;Shut down the GS/OS text I/O system         jsl   SystemSANEShutDown       ;shut down SANE         jsl   SystemMMShutDown         ;shut down the compiler's memory manager         pla                            ;restore the return code;;       QuitGS qt_dcb                  ;return to the calling shell         jsl   $E100A8	DC.W	$2029	DC.L	qt_dcbqt_dcb	DC.W	2		EXPORT	~QuitPath~QuitPath		;			DC.L	0		EXPORT	~QuitFlags~QuitFlags		;			DC.W	0		ENDP******************************************************************  ~ResetName - reset the name and line ;number**  Inputs:*        ~ProcList - head of procedure list**  Outputs:*        ~ProcList - new head of procedure list*        ~LineNumber - old line number*        ~ProcName - old procedure name******************************************************************		EXPORT	~ResetName ~ResetName PROC			longa on			longi onpRecLen  equ   38                       ;length of the position recordptr      equ   1                        ;work pointer         phb         phk         plb;;       ph4   ~ProcList	;          LDA   ~ProcList+2         PHA         LDA   ~ProcList         PHA         tsc         phd         tcd         ldy   #pRecLen-2lb1      lda   [ptr],Y         sta   ~ProcList,Y         dey         dey         bpl   lb1;;       dispose ptr;;       PH4   ptr	;          LDA   ptr+2         PHA         LDA   ptr         PHA         JSL   ~DISPOSE         pld         pla         pla         plb         rtl		ENDP******************************************************************  ~RTL - Exit from an RTL program******************************************************************		EXPORT	~RTL     ~RTL     PROC         jsl   SystemMMShutDown         ;shut down the compiler's memory manager         tax                            ;save return code         lda   >~callerStack            ;restore original stack         tcs         txa                            ;reset return code         rtl                            ;return to caller		ENDP******************************************************************  ~SetLineNumber - set the current line number**  Inputs:*        4,S - line number**  Outputs:*        ~LineNumber - current line #**  Notes:*        Must preserve registers and condition flags******************************************************************		EXPORT	~SetLineNumber ~SetLineNumber PROC         php         pha         lda   7,S         sta   >~LineNumber         lda   5,S         sta   7,S         lda   3,S         sta   5,S         lda   1,S         sta   3,S         pla         pla         plp         rtl		ENDP******************************************************************  ~SetName - save the name and line number**  Inputs:*        ~ProcList - head of procedure list*        ~LineNumber - line number*        ~ProcName - procedure name*        name - pointer to new proc name**  Outputs:*        ~ProcList - new head of procedure list******************************************************************		EXPORT	~SetName ~SetName PROC			longa on			longi onpRecLen  equ   38                       ;length of the position recordname     equ   9                        ;ptr to new nameptr      equ   1                        ;work pointer         phb                            ;set data bank         phk         plb         pha                            ;set up ptr         pha         tsc         phd         tcd;;       new   ptr,#pRecLen             ;allocate space for record;;       PH4   #pRecLen	;          PEA   +(pRecLen)>>16         PEA   pRecLen         JSL   ~NEW         STA   ptr         STX   ptr+2         ldy   #pRecLen-2               ;save the recordlb1      lda   ~ProcList,Y         sta   [ptr],Y         dey         dey         bpl   lb1;;       move4 ptr,~ProcList            ;set new head of list;;       ~SETM	;          LDA   2+ptr         STA   2+~ProcList         LDA   ptr         STA   ~ProcList;;       ~RESTM	;          ldy   #30                      ;move the name into its spacelb2      lda   [name],Y         sta   ~ProcName,Y         dey         dey         bpl   lb2;;       short M                        ;make sure the name is not too long         SEP   #1*32+0*16			LONGA OFF         lda   ~ProcName         cmp   #32         blt   lb3         lda   #31         sta   ~ProcName;;lb3    long  Mlb3      REP   #1*32+0*16			LONGA ON         pld                            ;restore the stack         pla         pla         plx         ply         pla         pla         phy         phx         plb                            ;reset data bank         rtl		ENDP******************************************************************  ~ShiftLeft - Shift a value left**  Inputs:*        A - value to shift*        X - # bits to shift by**  Outputs:*        A - result******************************************************************		EXPORT	~ShiftLeft ~ShiftLeft PROC			longa on			longi on         txy                            ;if # bits is 0, quit         beq   rtl         bmi   lb2                      ;if # bits is > 0 thenlb1      asl   A                        ;  shift left         dex         bne   lb1         bra   rtl                      ;elselb2      lsr   A                        ;  shift right         inx         bne   lb2rtl      rtl		ENDP******************************************************************  ~SHL4 - Shift a long value left**  Inputs:*        A - value to shift*        X - # bits to shift by**  Outputs:*        A - result******************************************************************		EXPORT	~SHL4    ~SHL4    PROC			longa on			longi onnum1     equ   8                        ;number to shiftnum2     equ   4                        ;# bits to shift by         tsc                            ;set up DP         phd         tcd         lda   num2+2                   ;if num2 < 0 then         bpl   lb2         cmp   #$FFFF                   ;  shift right         bne   zero         ldx   num2         cpx   #-34         blt   zerolb1      lda   num1+2         asl   a         ror   num1+2         ror   num1         inx         bne   lb1         bra   lb4zero     stz   num1                     ;  (result is zero)         stz   num1+2         bra   lb4lb2      bne   zero                     ;else shift left         ldx   num2         beq   lb4         cpx   #33         bge   zerolb3      asl   num1         rol   num1+2         dex         bne   lb3lb4      lda   0                        ;fix stack and return         sta   num2         lda   2         sta   num2+2         pld         pla         pla         rtl		ENDP******************************************************************  ~SShiftRight - Shift a signed value right**  Inputs:*        A - value to shift*        X - # bits to shift by**  Outputs:*        A - result******************************************************************		EXPORT	~SShiftRight ~SShiftRight PROC         txy                            ;if # bits is 0, quit         beq   rtl         bpl   lb2                      ;if # bits is < 0 thenlb1      asl   A                        ;  shift left         inx         bne   lb1         bra   rtl                      ;elselb2      bit   #$8000                   ;  if value >= 0 then         bne   lb4lb3      lsr   A                        ;    unsigned shift right         dex         bne   lb3         rtl                            ;  elselb4      sec                            ;    signed shift right         ror   A         dex         bne   lb4rtl      rtl		ENDP******************************************************************  ~StartDesk - start quickdraw, and tools needed for desktop**  Inputs:*        size - horrizontal screen size******************************************************************		EXPORT	~StartDesk ~StartDesk PROC	;using ~_IOCommon			longa on			longi onqSize    equ   20                       ;event manager queue sizemaxY     equ   200                      ;max y coordinate;;       sub   (2:size),0	; size     EQU   3         TDC         TAX         TSC         SEC         SBC   #0-1         TCD         DEC   A         TCS         PHX         phb         phk         plb         lda   size                     ;set the video mode         lsr   A         lsr   A         and   #$80         sta   ssVideoMode         pha                            ;start the tools         pha;;       ph2   >~User_ID	;          LDA   >~User_ID         PHA;;       ph2   #0	;          PEA   0;;       ph4   #ssRec	;          PEA   +(ssRec)>>16         PEA   ssRec;;       _StartUpTools         ldx   #$1801         jsl   $E10000         bcs   toolError;;       pl4   ~ssRef	;          PLA         STA   ~ssRef         PLA         STA   ~ssRef+2;;       _InitCursor         ldx   #$CA04         jsl   $E10000         jsl   SysGraphTextStartuprts      plb;;       return         LDA   0+1         STA   5-2         LDA   0         STA   5-3         CLC         TDC         ADC   #5-4         PLD         TCS         RTL;;  Handle a tool error;toolError pha;;       ph4   #msg                     ;not maskable	;          PEA   +(msg)>>16         PEA   msg;;       _SysFailMgr         LDX   #$1503         JSL   $E10000;;  Local data;;;msg    dw    'Could not start tools: 'msg	DC.B	23SYSA12	DC.B	'Could not start tools: ';	DC	R'~EndDesk'	;make sure EndDesk gets linkedssRec	DC.W	0	;flagsssVideoMode		DS.B 2                        ;video mode	DC.W	0	DC.L	0	DC.W	(ssEnd-ssStart)/4ssStart	; 	DC.W	3,$0302	;Miscellaneos Tool Set	DC.W	4,$0307	;QuickDraw II	DC.W	5,$0304	;Desk Manager	DC.W	6,$0301	;Event Manager	DC.W	11,$0300	;Integer Math Tool Set	DC.W	14,$0303	;Window Manager	DC.W	15,$0303	;Menu Manager	DC.W	16,$0303	;Control Manager	DC.W	18,$0304	;QuickDraw II Auxiliary	DC.W	20,$0303	;Line Edit Tool Set	DC.W	21,$0304	;Dialog Manager	DC.W	22,$0301	;Scrap Manager	DC.W	23,$0303	;Standard File Operations	DC.W	27,$0303	;Font Manager	DC.W	28,$0303	;List Manager	DC.W	30,$0102	;Resource ManagerssEnd	; 		ENDP******************************************************************  ~StartGraph - start quickdraw**  Inputs:*        size - horrizontal screen size******************************************************************		EXPORT	~StartGraph ~StartGraph PROC	;using ~_IOCommon			longa on			longi onformFeed equ   $0C;;       sub   (2:size),0	; size     EQU   3         TDC         TAX         TSC         SEC         SBC   #0-1         TCD         DEC   A         TCS         PHX         phb         phk         plb         lda   size                     ;set the video mode         lsr   A         lsr   A         and   #$80         sta   ssVideoMode         pha                            ;start the tools         pha;;       ph2   >~User_ID	;          LDA   >~User_ID         PHA;;       ph2   #0	;          PEA   0;;       ph4   #ssRec	;          PEA   +(ssRec)>>16         PEA   ssRec;;       _StartUpTools         ldx   #$1801         jsl   $E10000;;       jcs   toolError         BCC   *+5         BRL   toolError;;       pl4   ~ssRef	;          PLA         STA   ~ssRef         PLA         STA   ~ssRef+2;;       _HideCursor                    ;hide the cursor         ldx   #$9004         jsl   $E10000;;       ph2   #0                       ;clear the screen	;          PEA   0;;       _ClearScreen         LDX   #$1504         JSL   $E10000;;       jcs   toolError         BCC   *+5         BRL   toolError;;       ph2   #$FFFF                   ;set the pen to solid white	;          PEA   $FFFF;;       _SetSolidPenPat         LDX   #$3704         JSL   $E10000;;       jcs   toolError         BCC   *+5         BRL   toolError         lda   #1                       ;set the pen to 'or' mode         pha                            ;(put pen size on stack now)         pha         pha;;       _SetPenMode         LDX   #$2E04         JSL   $E10000;;       jcs   toolError         BCC   *+5         BRL   toolError;;       _SetPenSize                    ;set the pen size to 1x1         LDX   #$2C04         JSL   $E10000;;       jcs   toolError         BCC   *+5         BRL   toolError;;       ph2   #$FFFF	;          PEA   $FFFF;;       _SetForeColor         LDX   #$A004         JSL   $E10000;;       jcs   toolError         BCC   *+5         BRL   toolError;;       ph2   #0	;          PEA   0;;       _SetBackColor         LDX   #$A204         JSL   $E10000         bcs   toolError         jsl   SysGraphTextStartuprts      plb;;       return         LDA   0+1         STA   5-2         LDA   0         STA   5-3         CLC         TDC         ADC   #5-4         PLD         TCS         RTL;;  Handle a tool error;toolError pha;;       ph4   #msg                     ;not maskable	;          PEA   +(msg)>>16         PEA   msg;;       _SysFailMgr         LDX   #$1503         JSL   $E10000;;  Local data;;;msg    dw    'Could not start tools: 'msg	DC.B	23SYSA28	DC.B	'Could not start tools: ';	DC	R'~EndGraph'            ;make sure EndGraph gets linkedssRec	DC.W	0	;flagsssVideoMode		DS.B 2                        ;video mode	DC.W	0	DC.L	0	DC.W	(ssEnd-ssStart)/4ssStart	; 	DC.W	3,$0302	;Miscellaneos Tool Set	DC.W	4,$0307	;QuickDraw IIssEnd	; 		ENDP******************************************************************  ~StackErr - check for stack errors**  Inputs:*        Y - expected stack location******************************************************************		EXPORT	~StackErr ~StackErr PROC         pha         tya         sta   >SS         tsc         clc         adc   #5         cmp   >SS         beq   lb1         phx;;       ph2   #16	;          PEA   16         jsl   SystemError         plxlb1      pla         rtlSS		DS.B 2		ENDP******************************************************************  SystemEnvironmentInit - Set up the various environment variables******************************************************************		EXPORT	SystemEnvironmentInit SystemEnvironmentInit PROC         phb         phk         plb         lda   #' '                     ;reset(input)         sta   ~InputChar         stz   ~EOLNInput         stz   ~EOFInput         stz   ~LineNumber              ;initialize traceback info         stz   ~ProcName         stz   ~ProcList         stz   ~ProcList+2         stz   ~StringList              ;initialize the string buffer list         stz   ~StringList+2         stz   ~thisFile                ;initialize file lists         stz   ~thisFile+2         plb         rtl		ENDP******************************************************************  SystemMinStack - set ~MinStack**  Sets the system variable ~MinStack to the start of the*  current stack segment.  ~MinStack is ;used by tool allocation*  subrountines to find space for initializing tools, as well*  as by error checking routines that check for stack overflows.******************************************************************		EXPORT	SystemMinStack SystemMinStack PROC         pha                            ;find the stack segment handle         pha         pea   0         tsc         pha;;       _FindHandle         ldx   #$1A02         jsl   $E10000         phd                            ;set up a direct page         tsc         tcd         lda   [3]                      ;dereference the handle         pld                            ;restore caller's DP         sta   >~MinStack               ;set ~MinStack         pla         pla         rtl		ENDP******************************************************************  SystemMMShutDown - shut down the compilers' memory manager******************************************************************		EXPORT	SystemMMShutDown SystemMMShutDown PROC         jsl   ~MM_Init                 ;zero the memory manager;;       ph2   >~User_ID                ;dispose of any remaining memory	;          LDA   >~User_ID         PHA;;       _DisposeAll                    ; allocated by the memory manager         LDX   #$1102         JSL   $E10000         rtl		ENDP******************************************************************  SystemQuitFlags - set the Quit flags**  Inputs:*        path - GS/OS input path to quit to******************************************************************		EXPORT	SystemQuitFlags SystemQuitFlags PROC         phb         plx         ply         pla         sta   >~QuitFlags         phy         phx         plb         rtl		ENDP******************************************************************  SystemQuitPath - set the Quit pathname**  Inputs:*        path - GS/OS input path to quit to******************************************************************		EXPORT	SystemQuitPath SystemQuitPath PROC         phb         plx         ply         pla         sta   >~QuitPath         pla         sta   >~QuitPath+2         phy         phx         plb         rtl		ENDP******************************************************************  SystemSANEInit - If it hasn't already been started, start SANE******************************************************************		EXPORT	SystemSANEInit SystemSANEInit PROC         lda   #0                       ;SANE has not been started by us (yet)         sta   >~SANEStarted         pha                            ;if SANE has not been started then;;       _SANEStatus         LDX   #$060A         JSL   $E10000         pla         bne   sn1         lda   >~MinStack               ;  get some bank zero memory for SANE         pha         clc         adc   #$0100         sta   >~MinStack;;       _SANEStartUp                   ;  initialize SANE         LDX   #$020A         JSL   $E10000         lda   #1                       ;  set the SANE startup flag         sta   >~SANEStartedsn1      rtl		ENDP******************************************************************  SystemSANEShutDown - If we started SANE, shut it down******************************************************************		EXPORT	SystemSANEShutDown SystemSANEShutDown PROC         lda   >~SANEStarted            ;if we started SANE then         beq   qt1;;       _SANEShutDown                  ;  shut it down         LDX   #$030A         JSL   $E10000         lda   #0                       ;  clear the flag (for restarts)         sta   >~SANEStartedqt1      rtl		ENDP******************************************************************  SystemUserID - set up the user ID and command line**  Inputs:*        8,S - user ID*        4,S - command line address******************************************************************		EXPORT	SystemUserID SystemUserID PROC         phk                            ;remove the return address         plx         ply         pla                            ;save the command line address         sta   >~CommandLine         pla         sta   >~CommandLine+2         pla                            ;set up our user ID         ora   #$0100         sta   >~User_ID         phy                            ;return to the caller         phx         plb                            ;(set up B, too)         rtl		ENDP******************************************************************  ~UDiv2 - Two Byte Unsigned Integer Divide**  Inputs:*        X - denominator*        A - numerator**  Outputs:*        A - result*        X - remainder*        V - set for division by zero**  Notes:*        1) Assumes long A and X on entry.******************************************************************		EXPORT	~UDiv2   ~UDiv2   PROCnum1     equ   3                        ;numeratornum2     equ   1                        ;denominator         txy                            ;check for division by zero         beq   err         pha                            ;save the arguments         phx         tsc                            ;set up DP         phd         tcd         lda   #0                       ;initialize the remainder         ldy   #16                      ;16 bits to godv3      asl   num1                     ;roll up the next number         rol   A         sec                            ;subtract the digit         sbc   num2         bcs   dv4         adc   num2                     ;digit is 0         dey         bne   dv3         bra   dv5dv4      inc   num1                     ;digit is 1         dey         bne   dv3dv5      tax                            ;save the remainder         lda   num1                     ;get the result         clv                            ;clear the error flagdv7      pld                            ;reset DP         ply                            ;clean up stack         ply         rtlerr      pla         sep   #%01000000               ;SEV         rtl		ENDP******************************************************************  ~UMul2 - unsigned multiply**  Inputs:*        X,A - operands**  Outputs:*        A - result**  Notes:*        This routine is used for array ;index calculations and*        fur unsigned multiplies in C.  ;It does not check for*        overflows.******************************************************************		EXPORT	~UMul2   ~UMul2   PROCn1       equ   3n2       equ   5;;  Initialization;         phx                            ;save the operands         pha         phd                            ;set up our DP         tsc         tcd         cpx   n1                       ;make sure n1 is the smaller argument         bge   in1         lda   n1         stx   n1         sta   n2in1	; ;;  Do the multiply;         lda   #0         lsr   n1         bcc   lb1         clc         adc   n2lb1      asl   n2         lsr   n1         bcc   lb2         clc         adc   n2lb2      asl   n2         lsr   n1         bcc   lb3         clc         adc   n2lb3      asl   n2         lsr   n1         beq   abrt4         bcc   lb4         clc         adc   n2lb4      asl   n2         lsr   n1         bcc   lb5         clc         adc   n2lb5      asl   n2         lsr   n1         bcc   lb6         clc         adc   n2lb6      asl   n2         lsr   n1         bcc   lb7         clc         adc   n2lb7      asl   n2         lsr   n1         bcc   lb8         clc         adc   n2lb8      asl   n2* Note: We're done: since n1 < n2, we either overflow or the remaining bits are* zero.;;  Return the result;         pld         plx         plx         rtl;;  Abort with n1 = 0 after 4 shifts;abrt4    bcc   aa1         clc         adc   n2aa1      pld                            ;return the result         plx         plx         rtl		ENDP******************************************************************  ~UMul4 - Four byte unsigned integer multiply**  Inputs:*        num2,X-A - operands**  Outputs:*        ans - result******************************************************************		EXPORT	~UMul4   ~UMul4   PROCnum2     equ   12                       ;argumentsans      equ   1                        ;answerreturn   equ   9;;  Initialize the sign and split on precision.;         pea   0                        ;set up stack frame         pea   0         phx         pha         tsc         phd         tcd         txa                            ;branch if the multiplier is 16 bit         beq   ml3;;  Do a 32 bit by 32 bit multiply.;         ldy   #32                      ;32 bit multiply         jsr   ml1         brl   ml7ml1      lda   ans                      ;SYSS1*SYSS1+2+SYSS1+2 -> SYSS1,SYSS1+2         lsr   a         bcc   ml2         clc                            ;add multiplicand to the partial product         lda   ans+4         adc   num2         sta   ans+4         lda   ans+6         adc   num2+2         sta   ans+6ml2      ror   ans+6                    ;shift the interem result         ror   ans+4         ror   ans+2         ror   ans         dey                            ;loop til done         bne   ml1         rts;;  Do and 16 bit by 32 bit multiply.;ml3      lda   num2+2                   ;branch if 16x16 is possible         beq   ml4         ldy   #16                      ;set up for 16 bits         jsr   ml1                      ;do the multiply;;       move4 ans+2,num2               ;move the answer;;       ~SETM	;          LDA   2+ans+2         STA   2+num2         LDA   ans+2         STA   num2;;       ~RESTM	;          bra   ml8;;  Do a 16 bit by 16 bit multiply.;ml4      ldy   #16                      ;set the 16 bit counter         ldx   ans                      ;move the low word         stx   ans+2ml5      lsr   ans+2                    ;test the bit         bcc   ml6                      ;branch if the bit is off         clc         adc   num2ml6      ror   a                        ;shift the answer         ror   ans         dey                            ;loop         bne   ml5         sta   ans+2                    ;save the high word;;  Return the result.;;;ml7    move4 ans,num2                 ;fix the stack;;ml7    ~SETMml7	;          LDA   2+ans         STA   2+num2         LDA   ans         STA   num2;;       ~RESTM	; ml8      pld                            ;fix stack, DP         tsc         clc         adc   #8         tcs         rtl		ENDP******************************************************************  ~UShiftRight - Shift an unsigned value right**  Inputs:*        A - value to shift*        X - # bits to shift by**  Outputs:*        A - result******************************************************************		EXPORT	~UShiftRight ~UShiftRight PROC         txy                            ;if # bits is 0, quit         beq   rtl         bpl   lb2                      ;if # bits is < 0 thenlb1      asl   A                        ;  shift left         inx         bne   lb1         bra   rtl                      ;elselb2      lsr   A                        ;  shift right         dex         bne   lb2rtl      rtl		ENDP******************************************************************  ~XCMDCommon - common area for HyperCard XCMD*******************************************************************~XCMDCommon privdata~XCMDCommon		PROC			ENTRY	~XCMD_B~XCMD_B		DS.B 2                        ;caller's B register		ENDP******************************************************************  ~XCMDShutdown - shutdown code for a HyperCard XCMD******************************************************************		EXPORT	~XCMDShutdown ~XCMDShutdown PROC	;using ~XCMDCommon         jsl   ~MM_DisposeAll           ;shut down the compiler's memory manager         jsl   ~MM_Init         lda   >~XCMD_B                 ;restore HyperCard B         pha         plb         plb         rtl		ENDP******************************************************************  ~XCMDStartup - startup code for a HyperCard XCMD******************************************************************		EXPORT	~XCMDStartup ~XCMDStartup PROC	;using ~XCMDCommon         lda   9,S                      ;set up the parameter for main()         tax         lda   7,S         tay         lda   5,S         sta   9,S         lda   4,S         sta   8,S         tya         sta   4,S         txa         sta   6,S         phb                            ;save the caller's data bank         phb         pla         sta   >~XCMD_B         phk                            ;set up our data bank         plb         ora   #$0100                   ;set up our user ID         sta   >~User_ID         jsl   SystemEnvironmentInit    ;Set up the various environment variables         rtl		ENDP******************************************************************  ~XJPError - indexed jump error******************************************************************		EXPORT	~XJPError ~XJPError PROC			longa on			longi on;;       error #8                       ;Jump to undefined case statement label;;       ph2   #8	;          PEA   8         jsl   SystemError         lda   #$FFFF         jmp   ~Quit		ENDP		END