	seg   ''**************************************************************** * *  Input, ouput and integer conversion libraries * *  By Mike Westerfield * *  Copyright January 1987, All rights reserved *  By the Byte Works, Inc. * **************************************************************** * ;------------------------------------------;; Equates from procedure ~IOCom;;------------------------------------------~strlen   equ   40                      ;length of string buffer ;-----------------------------------------------;;   Imported addresses;;-----------------------------------------------	IMPORT	L	IMPORT	line	IMPORT	strlen	IMPORT	~Div8	IMPORT	~MUL8	IMPORT	~SUB8;-----------------------------------------------;;   Forward addresses and entries;;-----------------------------------------------	ENTRY	SysCharErrout	ENTRY	SysCharOut	ENTRY	SysKeyin	ENTRY	SysLineIn	ENTRY	SysPutback	ENTRY	~GETN	ENTRY	~MovStr	ENTRY	~PUTS**************************************************************** * *  ~GSOSIO - Common area for the GS/OS text I/O package * **************************************************************** * *~GSOSIO  privdata ~GSOSIO		PROC	 ; ;  When input comes from .CONSOLE, it is read one line at a time to allow for ;  input editing.  The line is stuffed into ~line, then scanned using ;  ~lineDisp as an index. ; ;  The end of a line is marked by chr(13), after which any character ;  read forces a new line read. ; ;  chr(0) is treated as an end of file condition.  End of file is reported ;  for the remainder of the program execution. ; ;  If an error occurs during startup, end of file is reported on the first ;  character read. ; ;  ~putback provides a one-character putback buffer.  This buffer is ;  valid whether input is comming from .CONSOLE or from a file. ; 		ENTRY	~line~line		DS.B 256                      ;input line 		ENTRY	~lineDisp~lineDisp		DS.B 2                        ;disp in ~line for next char 		ENTRY	~lineLength~lineLength		DS.B 2                        ;length of the current line 		ENTRY	~putback~putback		DS.B 2                        ;one character putback buffer ; ;  File reference numbers ; 		ENTRY	~stinRefnum~stinRefnum		DS.B 2 		ENTRY	~stoutRefnum~stoutRefnum		DS.B 2 		ENTRY	~erroutRefnum~erroutRefnum		DS.B 2 ; ;  If we open a file, we should close it.  These flags tell us if we opened ;  a particular channel. ; 		ENTRY	~opened~opened		DS.B 6                        ;boolean flags for channels; did we open them? ; ;  This flag is true if input is comming from .CONSOLE.  It is used to decide ;  if the console driver's line input routine should be used.  If 0, .CONSOLE ;  is not in use; if non-zero, this is the device number for .CONSOLE. ; 		ENTRY	~inputIsConsole~inputIsConsole		DS.B 2                    ;is standard in from .CONSOLE? 		ENDP  **************************************************************** * *  ~IOCom - Common data area * **************************************************************** * *~IOCom   privdata ~IOCom		PROC	  ;;~string dstr  ,~strlen                ;string buffer in string format 		ENTRY	~string~string	DC.B	~strlen	DC.B	0		DS.B ~strlen 		ENTRY	~ASCII~ASCII		DS.B ~strlen                  ;string buffer in ASCII format 		ENDP  **************************************************************** * *  ~CV28 - Convert 2 byte integer to 8 byte integer * *  Inputs: *        A - 2 byte integer * *  Outputs: *        * - 8 byte integer * **************************************************************** * 		EXPORT	~CV28    ~CV28    PROC           phb                            ;save return addr          tay          pla          sta   >retadl          pla          ldx   #0                       ;set X to sign part          cpy   #$8000          blt   lb1          dex lb1      phx                            ;save number          phx          phx          phy          pha                            ;restore return addr          lda   >retadl          pha          plb          rtl  retadl		DS.B 2 		ENDP  **************************************************************** * *  ~CV2S - Convert 2 byte integer to a string * *  Inputs: *        A - 2 byte integer *        * - address of string buffer * **************************************************************** * 		EXPORT	~CV2S    ~CV2S    PROC 	;using ~IOCom           pha                            ;save number to convert ;;       ph4   #~ASCII                  ;set addr of output string 	;          PEA   +(~ASCII)>>16          PEA   ~ASCII ;;       ph2   #~strlen                 ;set max length of string 	;          PEA   ~strlen ;;       ph2   #1                       ;value is signed 	;          PEA   1 ;;       _Int2Dec                       ;convert the number          ldx   #$260B          jsl   $E10000          jmp   ~MovStr                  ;move the string to the string buffer 		ENDP  **************************************************************** * *  ~CV42 - Convert 4 byte integer to 2 byte integer * *  Inputs: *        * - 4 byte integer * *  Outputs: *        A - 2 byte integer *        V - set if an overflow occurred * **************************************************************** * 		EXPORT	~CV42    ~CV42    PROC           ldx   #0                       ;Y = value          lda   4,S                      ;X = expected most sig word          tay          bpl   lb1          dex lb1      txa                            ;branch if most sig word does not match          cmp   6,S          bne   err          clv          bra   out  err      sep   #%01000000               ;SEV out      lda   0,S                      ;fix return addr          sta   4,S          lda   2,S          sta   6,S          pla          pla          tya                            ;set value          rtl 		ENDP  **************************************************************** * *  ~CV48 - Convert 4 byte integer to 8 byte integer * *  Inputs: *        * - 4 byte integer * *  Outputs: *        * - 8 byte integer * **************************************************************** * 		EXPORT	~CV48    ~CV48    PROC           pha                            ;make room for result          pha          lda   4,S                      ;move return address          sta   0,S          lda   6,S          sta   2,S          lda   8,S                      ;move number          sta   4,S          ldx   #0          lda   10,S          sta   6,S          bpl   lb1                      ;set X to sign part          dex lb1      txa                            ;save sign part          sta   8,S          sta   10,S          rtl 		ENDP  **************************************************************** * *  ~CV4S - Convert 4 byte integer to a string * *  Inputs: *        NUM1 - 4 byte integer * **************************************************************** * 		EXPORT	~CV4S    ~CV4S    PROC 	;using ~IOCom           lda   2,S                      ;swap number and return addr          tay          lda   1,S          tax          lda   4,S          sta   1,S          lda   6,S          sta   3,S          txa          sta   5,S          tya          sta   6,S ;;       ph4   #~ASCII                  ;set addr of output string 	;          PEA   +(~ASCII)>>16          PEA   ~ASCII ;;       ph2   #~strlen                 ;set max length of string 	;          PEA   ~strlen ;;       ph2   #1                       ;value is signed 	;          PEA   1 ;;       _Long2Dec                      ;convert the number          ldx   #$270B          jsl   $E10000          jmp   ~MovStr                  ;move the string to the string buffer 		ENDP  **************************************************************** * *  ~CV82 - Convert 8 byte integer to 2 byte integer * *  Inputs: *        * - 8 byte integer * *  Outputs: *        A - 2 byte integer *        V - set if an overflow occurred * **************************************************************** * 		EXPORT	~CV82    ~CV82    PROC           ldx   #0                       ;X = expected most sig word          lda   4,S          tay          bpl   lb1          dex lb1      txa                            ;branch if most sig word does not match          cmp   6,S          bne   err          cmp   8,S          bne   err          cmp   10,S          bne   err          clv          bra   out  err      sep   #%01000000               ;SEV out      lda   0,S                      ;fix return addr          sta   8,S          lda   2,S          sta   10,S          pla          pla          pla          pla          tya                            ;set value          rtl 		ENDP  **************************************************************** * *  ~CV84 - Convert 8 byte integer to 4 byte integer * *  Inputs: *        * - 8 byte integer * *  Outputs: *        * - 4 byte integer *        V - set if an overflow occurred * **************************************************************** * 		EXPORT	~CV84    ~CV84    PROC           ldx   #0                       ;X = expected most sig word          lda   6,S          bpl   lb1          dex lb1      txa                            ;branch if most sig word does not match          cmp   8,S          bne   err          cmp   10,S          bne   err          clv          bra   out  err      sep   #%01000000               ;SEV out      lda   4,S                      ;set return value          sta   8,S          lda   6,S          sta   10,S          lda   0,S                      ;fix return addr          sta   4,S          lda   2,S          sta   6,S          pla          pla          rtl 		ENDP  **************************************************************** * *  ~CV8S - Convert 8 byte integer to a string * *  Inputs: *        num1 - 8 byte integer *        STR - addr of string * **************************************************************** * 		EXPORT	~CV8S    ~CV8S    PROC 	;using ~IOCom num1     equ   12                       ;number to convert adr      equ   8                        ;addr of string buffer index    equ   3                        ;index into ASCII string buffer neg      equ   1                        ;negative?           pea   ~strlen-1                ;initialize index          pea   0                        ;initialize neg          tsc                            ;set up DP          phd          tcd ;;       short M                        ;blank string          SEP   #1*32+0*16 			LONGA OFF          lda   #' '          ldx   #~strlen-2 lb1      sta   >~ASCII,X ;;       dbpl  X,lb1          DEX          BPL   lb1          lda   #'0'          sta   ~ASCII+~strlen-1         ;set initial value ;;       long  M          REP   #1*32+0*16 			LONGA ON          lda   num1+6                   ;if num1 < 0 then          bpl   lb3          inc   neg                      ;  neg = 1          sec                            ;  num1 = -num1          lda   #0          sbc   num1          sta   num1          lda   #0          sbc   num1+2          sta   num1+2          lda   #0          sbc   num1+4          sta   num1+4          lda   #0          sbc   num1+6          sta   num1+6          bpl   lb3                      ;  if still neg, use default ;;       short M          SEP   #1*32+0*16 			LONGA OFF          ldx   #20-1 lb2      lda   >bstr,X          sta   >~ASCII+~strlen-20,X ;;       dbpl  X,lb2          DEX          BPL   lb2 ;;       long  M          REP   #1*32+0*16 			LONGA ON          bra   lb7 lb3	; ;endif lb4      lda   num1                     ;while num1 <> 0 do          ora   num1+2          ora   num1+4          ora   num1+6          beq   lb5 ;;       ph8   num1                     ;  num1 = num1 div 10 	;          LDX   #6 ~8       LDA   num1,X          PHA          DEX          DEX          BPL   ~8          lda   #0                       ;  A = num1 mod 10          pha          pha          pha          pea   10          jsl   ~Div8 ;;       pl8   num1 	;          PLA          STA   num1          PLA          STA   num1+2          PLA          STA   num1+4          PLA          STA   num1+6          pla          plx          plx          plx          ldx   index                    ;  save digit          ora   #'0' ;;       short M          SEP   #1*32+0*16 			LONGA OFF          sta   >~ASCII,X ;;       long  M          REP   #1*32+0*16 			LONGA ON          dec   index          bra   lb4                      ;endwhile lb5      lda   neg                      ;if neg then          beq   lb6 ;;       short M                        ;  save - char          SEP   #1*32+0*16 			LONGA OFF          lda   #'-'          ldx   index          sta   >~ASCII,X ;;       long  M          REP   #1*32+0*16 			LONGA ON lb6	; ;endif ;;lb7    ph4   adr                      ;move the characters to the string buffer lb7	;          LDA   adr+2          PHA          LDA   adr          PHA          jsl   ~MovStr ;;       move4 4,num1+4                 ;fix return addr ;;       ~SETM 	;          LDA   2+4          STA   2+num1+4          LDA   4          STA   num1+4 ;;       ~RESTM 	;          pld                            ;fix DP          clc                            ;fix stack          tsc          adc   #16          tcs          rtl  bstr	DC.B	'-9223372036854775808'		ENDP  **************************************************************** * *  ~CVS2 - Convert string to 2 byte integer * *  Inputs: *        adr - addr of string to convert * *  Outputs: *        A - number *        V - set if error, else clear * **************************************************************** * 		EXPORT	~CVS2    ~CVS2    PROC adr      equ   4           tsc                            ;set up DP          phd          tcd          pha                            ;make space for result          clc                            ;push addr of string          lda   adr          adc   #2          tax          lda   adr+2          adc   #0          pha          phx          LDY   #1                       ;push length of string          lda   [adr],Y          and   #$00FF          pha          pea   1                        ;push sign flag ;;       _Dec2Int                       ;convert to integer          ldx   #$280B          jsl   $E10000          pla                            ;recover value          ldx   0                        ;move return addr          stx   4          ldx   2          stx   6          clv                            ;V = C          bcc   lb1          sep   #$40 lb1      pld                            ;reset DP          plx                            ;remove address          plx          rtl 		ENDP  **************************************************************** * *  ~CVS4 - Convert string to 4 byte integer * *  Inputs: *        adr - address of string to convert * *  Outputs: *        adr - number *        V - set if error, else clear * **************************************************************** * 		EXPORT	~CVS4    ~CVS4    PROC adr      equ   4           tsc                            ;set up DP          phd          tcd          pha                            ;make space for result          pha          clc                            ;push addr of string          lda   adr          adc   #2          tax          lda   adr+2          adc   #0          pha          phx          ldy   #1                       ;push length of string          lda   [adr],Y          and   #$00FF          pha          pea   1                        ;push sign flag ;;       _Dec2Long                      ;convert to integer          ldx   #$290B          jsl   $E10000          pla                            ;recover value          sta   adr                      ;move return addr          pla          sta   adr+2          clv                            ;V = C          bcc   lb1          sep   #$40 lb1      pld                            ;reset DP          rtl 		ENDP  **************************************************************** * *  ~CVS8 - Convert string to 8 byte integer * *  Inputs: *        adr - address of string to convert * *  Outputs: *        NUM - number *        V - set if error, else clear * **************************************************************** * 		EXPORT	~CVS8    ~CVS8    PROC adr      equ   18                       ;address of string RETURN   equ   15                       ;return address neg      equ   13                       ;negative? cc       equ   11                       ;disp in string maxlen   equ   9                        ;max disp in string num      equ   1                        ;number           tsc                            ;set up DP          sec          sbc   #14          tcs          phd          tcd          ldy   #1                       ;maxlen = len(adr)+2          lda   [adr],Y          and   #$00FF          inc   A          inc   A          sta   maxlen          stz   num                      ;num = 0          stz   num+2          stz   num+4          stz   num+6          stz   neg                      ;neg = false          ldy   #2                       ;CC = 2 lb1      lda   [adr],Y                  ;while adr[CC] = ' ' do          and   #$00FF          cmp   #' '          bne   lb2          iny                            ;  ++CC          bra   lb1                      ;endwhile lb2      lda   [adr],Y                  ;if adr[CC] = '-' then          and   #$00FF          cmp   #'-'          bne   lb3          inc   neg                      ;  neg = true          iny                            ;  ++cc lb3      sty   cc                       ;endif lb4      ldy   cc                       ;while (cc < maxlen)          cpy   maxlen                   ;  and isdigit(adr[cc]) do          bge   lb6          lda   [adr],Y          and   #$00FF          cmp   #'0'          blt   lb6          cmp   #'9'+1          bge   lb6 ;;       mul8  num,#10                  ;  num = num*10 ;;       ~SETM 	; ;;       PH8   num 	;          LDX   #6 ~4       LDA   num,X          PHA          DEX          DEX          BPL   ~4 ;;       PH8   #10 	;          BRA   ~B5 ~A5	DC.W	10,0,0,0 ;i8'10'~B5      LDX   #6 ~C5      LDA   ~A5,X          PHA          DEX          DEX          BPL   ~C5          JSL   ~MUL8 ;;       PL8   num 	;          PLA          STA   num          PLA          STA   num+2          PLA          STA   num+4          PLA          STA   num+6 ;;       ~RESTM 	;          bvs   err                      ;  if overflow then error          ldy   cc                       ;  num = num+adr[cc]          lda   [adr],Y          and   #$000F          clc          adc   num          sta   num          bcc   lb5          inc   num+2          bne   lb5          inc   num+4          bne   lb5          inc   num+6          bmi   err                      ;  if num < 0 then error lb5      iny                            ;  ++cc          sty   cc          bra   lb4                      ;endwhile lb6      lda   neg                      ;if neg then          beq   lb7 ;;       sub8  #0,num,num               ;  num = -num ;;       ~SETM 	; ;;       PH8   #0 	;          BRA   ~B10 ~A10	DC.W	0,0,0,0 ;i8'0'~B10     LDX   #6 ~C10     LDA   ~A10,X          PHA          DEX          DEX          BPL   ~C10 ;;       PH8   num 	;          LDX   #6 ~11      LDA   num,X          PHA          DEX          DEX          BPL   ~11          JSL   ~SUB8 ;;       PL8   num 	;          PLA          STA   num          PLA          STA   num+2          PLA          STA   num+4          PLA          STA   num+6 ;;       ~RESTM 	; lb7	; ;endif          clv          bra   lb8 err      sep   #$40                     ;SEV ;;lb8    move4 RETURN,cc ;;lb8    ~SETM lb8	;          LDA   2+RETURN          STA   2+cc          LDA   RETURN          STA   cc ;;       ~RESTM 	; ;;       move4 num,RETURN-1 ;;       ~SETM 	;          LDA   2+num          STA   2+RETURN-1          LDA   num          STA   RETURN-1 ;;       ~RESTM 	; ;;       move4 num+4,adr ;;       ~SETM 	;          LDA   2+num+4          STA   2+adr          LDA   num+4          STA   adr ;;       ~RESTM 	;          pld          pla          pla          pla          pla          pla          rtl 		ENDP  **************************************************************** * *  ~GET2 - Get a Two Byte Integer * *  Inputs: *        X - CR flag * *  Outputs: *        A - result *        V - set for number overflow * **************************************************************** * 		EXPORT	~GET2    ~GET2    PROC 	;using ~IOCom           jsl   ~GETN                    ;read the number          bvs   err ;;       ph4   #~string                 ;convert string to number 	;          PEA   +(~string)>>16          PEA   ~string          jsl   ~CVS2 err      rtl 		ENDP  **************************************************************** * *  ~GET4 - Get a Four Byte Integer * *  Inputs: *        X - CR flag * *  Outputs: *        * - result *        V - set for number overflow * **************************************************************** * 		EXPORT	~GET4    ~GET4    PROC 	;using ~IOCom           jsl   ~GETN                    ;read the number          bvc   lb1 ;;       ph4   #0 	;          PEA   +(0)>>16          PEA   0          bra   lb2 ;;lb1    ph4   #~string                 ;convert string to number lb1	;          PEA   +(~string)>>16          PEA   ~string          jsl   ~CVS4 lb2      php                            ;swap RETURN, number          lda   6,S          tax          lda   7,S          tay          lda   4,S          sta   7,S          lda   2,S          sta   5,S          txa          sta   2,S          tya          sta   3,S          plp          rtl 		ENDP  **************************************************************** * *  ~GET8 - Get an Eight Byte Integer * *  Inputs: *        X - CR flag * *  Outputs: *        * - result *        V - set for number overflow * **************************************************************** * 		EXPORT	~GET8    ~GET8    PROC 	;using ~IOCom           jsl   ~GETN                    ;read the number          bvc   lb1 ;;       ph8   #0 	;          BRA   ~B2 ~A2	DC.W	0,0,0,0 ;i8'0'~B2      LDX   #6 ~C2      LDA   ~A2,X          PHA          DEX          DEX          BPL   ~C2          bra   lb2 ;;lb1    ph4   #~string                 ;convert string to number lb1	;          PEA   +(~string)>>16          PEA   ~string          jsl   ~CVS8 lb2      php                            ;swap RETURN, number          lda   10,S          tax          lda   11,S          tay          lda   8,S          sta   11,S          lda   6,S          sta   9,S          lda   4,S          sta   7,S          lda   2,S          sta   5,S          txa          sta   2,S          tya          sta   3,S          plp          rtl 		ENDP  **************************************************************** * *  ~GETC - Get a Character * *  Inputs: *        X - carriage return flag * *  Outputs: *        A - character read * **************************************************************** * 		EXPORT	~GETC    ~GETC    PROC RETURN   equ   $0D                      ;RETURN key code           phx                            ;save CR          jsl   SysKeyin          plx                            ;fetch CR          cmp   #RETURN                  ;done if we got a CR          beq   GC3          txy                            ;done if no skip to CR needed          beq   GC3          pha GC2      jsl   SysKeyin                 ;skip to CR (or EOF)          tax          beq   GC2a          cmp   #RETURN          bne   GC2 GC2a     pla GC3      rtl 		ENDP  **************************************************************** * *  ~GETN - Get a Numeric String * *  Inputs: *        X - CR flag * *  Outputs: *        ~string - result *        V - set for no string * *  Notes: *        1)  The integer ends with the first non-blank, non- *              numeric character. *        2)  Leading signs are allowed. *        3)  Leading white space is skipped, Pascal style * **************************************************************** * 		EXPORT	~GETN    ~GETN    PROC 	;using ~IOCom CR       equ   3                        ;carriage return flag cc       equ   1                        ;character counter TAB      equ   9                        ;TAB key code RETURN   equ   13                       ;RETURN key code           phx                            ;CR = X          pea   2                        ;cc = 2          tsc                            ;set up DP          phd          tcd lb1      jsl   SysKeyin                 ;A := SysKeyin          cmp   #TAB                     ;while whitespace(A) do          beq   lb1                      ;  A := SysKeyin          cmp   #RETURN                  ;endwhile          beq   lb1          cmp   #' '          beq   lb1          cmp   #'-'                     ;if A = '-' then          bne   lb2          ldx   cc                       ;  ~string[cc] := A          sta   >~string,X          inx                            ;  ++cc          stx   cc          jsl   SysKeyin                 ;  A := SysKeyin lb2	; ;endif          jsr   IsDigit                  ;if IsDigit(A) then ;;       jcc   lb9          BCS   *+5          BRL   lb9          cmp   #'0'                     ;  if A = '0' then          bne   lb4          ldx   cc                       ;    ~string[cc] := A          sta   >~string,X          inx                            ;    ++cc          stx   cc lb3      cmp   #'0'                     ;    while A = '0' do          bne   lb4          jsl   SysKeyin                 ;      A := SysKeyin          bra   lb3                      ;    endwhile lb4	; ;  endif lb5      ldx   cc                       ;  while (cc < ~strlen)          cpx   #~strlen          bge   lb6          jsr   IsDigit                  ;    and IsDigit(cc) do          bcc   lb6          sta   >~string,X               ;    ~string[cc] := A          inx                            ;    ++cc          stx   cc          jsl   SysKeyin                 ;    A := SysKeyin          bra   lb5                      ;  endwhile lb6      ldx   CR                       ;  if CR then          beq   lb8 lb7      cmp   #RETURN                  ;    while A <> RETURN do          beq   lb8          tax          beq   lb8          jsl   SysKeyin                 ;      A := SysKeyin          bra   lb7                      ;    endwhile lb8	; ;  endif          pha                            ;  SysPutback(A)          jsl   SysPutback ;;       short M                        ;  set string length          SEP   #1*32+0*16 			LONGA OFF          lda   cc          dec   A          dec   A          sta   ~string+1 ;;       long  M          REP   #1*32+0*16 			LONGA ON          clv                            ;  clv          bra   lb10 lb9	; ;else          sep   #$40                     ;  SEV lb10	; ;endif          pld                            ;reset DP          pla                            ;pull work space off of stack          pla          rtl ; ;  IsDigit ; IsDigit  cmp   #'0'          blt   no          cmp   #'9'+1          bge   no          sec          rts no       clc          rts 		ENDP  **************************************************************** * *  ~GetRef - get a reference number * *  Inputs: *        prefix - prefix number * *  Outputs: *        A - reference number for a GS/OS file, or 0 for an *            error. * *  Notes:  If the file is opened, ~opened[prefix] is true. * **************************************************************** * *~GetRef  private ~GetRef		PROC	;using ~GSOSIO refnum   equ   1                        ;reference number handle   equ   3                        ;memory handle ptr      equ   7                        ;memory pointer  buffSize equ   8*1024  ;;       lsub  (2:prefix),10 	; prefix   equ   0+4+10          tsc          sec          sbc   #10          tcs          phd          tcd           stz   refNum                   ;refNum := 0 (in case of error)          lda   prefix                   ;~opened[prefix] := false          asl   A          tax          stz   ~opened-20,X           lda   prefix                   ;try for an opened file          sta   gsPrefixNum ;;       GetStdRefnumGS gsRec          jsl   $E100A8 	DC.W	$2037	DC.L	gsRec         bcs   lb1          lda   gsRefnum          beq   lb1          sta   refnum          brl   lb4  lb1      pha                            ;get a file buffer          pha ;;       ph4   #buffSize 	;          PEA   +(buffSize)>>16          PEA   buffSize          pha ;;       ph2   #0 	;          PEA   0          pha          pha ;;       ph4   #~GetRef 	;          PEA   +(~GetRef)>>16          PEA   ~GetRef ;;       _FindHandle          ldx   #$1A02          jsl   $E10000 ;;       _SetHandleID          ldx   #$3002          jsl   $E10000 ;;       ph2   #$C010 	;          PEA   $C010 ;;       ph4   #0 	;          PEA   +(0)>>16          PEA   0 ;;       _NewHandle          ldx   #$0902          jsl   $E10000          ply          plx          bcs   lb4          stx   handle+2                 ;dereference the file buffer handle          sty   handle          ldy   #2          lda   [handle],Y          sta   ptr+2          sta   gpPrefix+2          sta   grPathname+2          sta   opPathname+2          lda   [handle]          sta   ptr          sta   gpPrefix          inc   A          inc   A          sta   grPathname          sta   opPathname          lda   #buffSize                ;set the buffer size          sta   [ptr]          lda   prefix                   ;get the prefix name          sta   gpPrefixNum ;;       GetPrefixGS gpRec          jsl   $E100A8 	DC.W	$200A	DC.L	gpRec         bcs   lb3 ;;       GetRefNumGS grRec              ;if the file is open then          jsl   $E100A8 	DC.W	$2038	DC.L	grRec         bcs   lb2          lda   grRefnum                 ;  return the reference number          sta   refnum          bne   lb3 ;;lb2    OpenGS opRec                   ;if the file can be opened then lb2      jsl   $E100A8 	DC.W	$2010	DC.L	opRec         bcs   lb3          lda   opRefnum                 ;  return the reference number          sta   refNum  ;;lb3    ph4   handle                   ;dispose of the file name buffer lb3	;          LDA   handle+2          PHA          LDA   handle          PHA ;;       _DisposeHandle          ldx   #$1002          jsl   $E10000  ;;lb4    lret  2:refnum lb4	;          ldy   refnum          lda   10+2          sta   10+2+2          lda   10+1          sta   10+2+1          pld          tsc          clc          adc   #10+2          tcs          tya          rtl  gpRec	DC.W	2	;GetPrefix record gpPrefixNum		DS.B 2 gpPrefix		DS.B 4  gsRec	DC.W	2	;GetStdRefNum record gsPrefixNum		DS.B 2 gsRefnum		DS.B 2  grRec	DC.W	2	;GetRefNum record grPathname		DS.B 4 grRefnum		DS.B 2  opRec	DC.W	2	;Open record opRefnum		DS.B 2 opPathname		DS.B 4 		ENDP  **************************************************************** * *  ~GETS - String Input * *  Inputs: *        adr - address of string * **************************************************************** * 		EXPORT	~GETS    ~GETS    PROC RETURN   equ   13                       ;RETURN key code adr      equ   6                        ;address of string len      equ   1                        ;length of string           pha                            ;make room for len          tsc                            ;set up DP          phd          tcd          lda   [adr]                    ;get length of string ;;       inc4  adr ;;       ~SETM 	;          INC   adr          BNE   ~2          INC   2+adr ;;~2     ~RESTM ~2	;          and   #$FF          sta   len ;;       short M          SEP   #1*32+0*16 			LONGA OFF          beq   gt2          ldy   #1                       ;place string in output buffer ;;gt1    long  M gt1      REP   #1*32+0*16 			LONGA ON          phy          jsl   SysKeyin          ply ;;       short M          SEP   #1*32+0*16 			LONGA OFF          sta   [adr],Y          cmp   #RETURN          beq   gt3          tax          beq   gt3          iny          cpy   len          blt   gt1 ;;gt2    long  M gt2      REP   #1*32+0*16 			LONGA ON          phy          jsl   SysKeyin                 ;if not at end, skip to eol          ply ;;       short M          SEP   #1*32+0*16 			LONGA OFF          cmp   #0          beq   gt3          cmp   #RETURN          bne   gt2 gt3      dey                            ;set the length of the string          tya          sta   [adr] ;;       long  M          REP   #1*32+0*16 			LONGA ON ;;       move4 2,adr                    ;fix return addr ;;       ~SETM 	;          LDA   2+2          STA   2+adr          LDA   2          STA   adr ;;       ~RESTM 	;          pld                            ;reset DP          pla                            ;remove work space from stack          pla          pla          rtl 		ENDP  **************************************************************** * *  ~MovStr - Move a string to its destination * *  Inputs: *        ASCII - ASCII character sequence *        * - address of string buffer * **************************************************************** * 		EXPORT	~MovStr  ~MovStr  PROC 	;using ~IOCom str      equ   6                        ;address of string buffer           phd                            ;set up DP          tsc          tcd ;;       short M                        ;find disp to start of string          SEP   #1*32+0*16 			LONGA OFF          ldx   #0          lda   #' ' lb1      cmp   >~ASCII,X          bne   lb2          inx          bra   lb1 ;;lb2    long  M                        ;compute length of string lb2      REP   #1*32+0*16 			LONGA ON          txa          sec          sbc   #~strlen          eor   #$FFFF          inc   A ;;       short M                        ;see if string is too long          SEP   #1*32+0*16 			LONGA OFF          cmp   [str] ;;       bgt   error          BEQ   *+4          BGE   error          ldy   #1                       ;set length of string          sta   [str],Y lb3      lda   >~ASCII,X                ;copy characters to string buffer          iny          sta   [str],Y          inx          cpx   #~strlen          blt   lb3 ;;       long  M          REP   #1*32+0*16 			LONGA ON          clv                            ;clear error flag          bra   lb4  ;;error  long  M                        ;flag error error    REP   #1*32+0*16 			LONGA ON          sep   #%01000000               ;SEV  lb4      lda   2,S                      ;fix return addr          sta   6,S          lda   4,S          sta   8,S          pld                            ;fix DP          pla                            ;remove extra stack stuff          pla          rtl 		ENDP  **************************************************************** * *  ~PRBL - Print Blanks * *  Inputs: *        A - number of blanks to print *        Y - error out flag * **************************************************************** * 		EXPORT	~PRBL    ~PRBL    PROC count    equ   3                        ;# blanks to print           pha                            ;save # blanks          phd                            ;set up DP addressing          tsc          tcd           tya                            ;branch to the proper print loop          beq   lb2  lb1      pea   ' '                      ;print blanks to error out          jsl   SysCharErrout          dec   count          bne   lb1          bra   lb3  lb2      pea   ' '                      ;print blanks to standard out          jsl   SysCharOut          dec   count          bne   lb2  lb3      pld                            ;restore everything          pla          rtl 		ENDP  **************************************************************** * *  ~PUT2 - Format a Two Byte Integer for Output * *  Inputs: *        N - number to write *        F1 - field width *        CR - carriage return flag *        err - error output flag * **************************************************************** * 		EXPORT	~PUT2    ~PUT2    PROC 	;using ~IOCom N        equ   10                       ;number to write F1       equ   8                        ;field width CR       equ   6                        ;carriage return flag err      equ   4                        ;error output flag           tsc                            ;set up DP          phd          tcd ;;       ph4   #~string                 ;convert number to string 	;          PEA   +(~string)>>16          PEA   ~string          lda   N          jsl   ~CV2S ;;       ph4   #~string                 ;write the string 	;          PEA   +(~string)>>16          PEA   ~string ;;       ph2   F1 	;          LDA   F1          PHA ;;       ph2   CR 	;          LDA   CR          PHA ;;       ph2   err 	;          LDA   err          PHA          jsl   ~PUTS ;;       move4 0,F1                     ;patch return addr ;;       ~SETM 	;          LDA   2+0          STA   2+F1          LDA   0          STA   F1 ;;       ~RESTM 	;          pld                            ;fix DP          pla                            ;remove extra stack space          pla          pla          pla          rtl 		ENDP  **************************************************************** * *  ~PUT4 - Format a Four Byte Integer for Output * *  Inputs: *        N - number to write *        F1 - field width *        CR - carriage return flag *        err - error output flag * **************************************************************** * 		EXPORT	~PUT4    ~PUT4    PROC 	;using ~IOCom N        equ   10                       ;number to write F1       equ   8                        ;field width CR       equ   6                        ;carriage return flag err      equ   4                        ;error output flag  ;;       ph4   #~string                 ;push addr of string 	;          PEA   +(~string)>>16          PEA   ~string          lda   N+6,S                    ;convert number to string          pha          lda   N+6,S          pha          jsl   ~CV4S          lda   #^~string                ;write the string          sta   N+2,S          lda   #~string          sta   N,S          jmp   ~PUTS 		ENDP  **************************************************************** * *  ~PUT8 - Format an Eight Byte Integer ;for Output * *  Inputs: *        N - number to write *        F1 - field width *        CR - carriage return flag *        err - error output flag * **************************************************************** * 		EXPORT	~PUT8    ~PUT8    PROC 	;using ~IOCom N        equ   10                       ;number to write F1       equ   8                        ;field width CR       equ   6                        ;carriage return flag err      equ   4                        ;error output flag           tsc                            ;set up DP          phd          tcd ;;       ph8   N                        ;convert number to string 	;          LDX   #6 ~2       LDA   N,X          PHA          DEX          DEX          BPL   ~2 ;;       ph4   #~string 	;          PEA   +(~string)>>16          PEA   ~string          jsl   ~CV8S ;;       ph4   #~string                 ;write the string 	;          PEA   +(~string)>>16          PEA   ~string ;;       ph2   F1 	;          LDA   F1          PHA ;;       ph2   CR 	;          LDA   CR          PHA ;;       ph2   err 	;          LDA   err          PHA          jsl   ~PUTS ;;       move4 0,N+4                    ;patch return addr ;;       ~SETM 	;          LDA   2+0          STA   2+N+4          LDA   0          STA   N+4 ;;       ~RESTM 	;          pld                            ;fix DP          clc                            ;remove extra stack space          tsc          adc   #14          tcs          rtl 		ENDP  **************************************************************** * *  ~PUTB - Format a Boolean Variable * *  Inputs: *        N - boolean value to write *        F1 - field width *        CR - carriage return flag *        err - error output flag * **************************************************************** * 		EXPORT	~PUTB    ~PUTB    PROC 	;using ~IOCom N        equ   10                       ;number to write F1       equ   8                        ;field width CR       equ   6                        ;carriage return flag err      equ   4                        ;error output flag           tsc                            ;set up DP          phd          tcd          lda   N                        ;push addr of correct string          beq   lb1 ;;       ph4   #true 	;          PEA   +(true)>>16          PEA   true          bra   lb2 ;;lb1    ph4   #false lb1	;          PEA   +(false)>>16          PEA   false ;;lb2    ph2   F1                       ;write the string lb2	;          LDA   F1          PHA ;;       ph2   CR 	;          LDA   CR          PHA ;;       ph2   err 	;          LDA   err          PHA          jsl   ~PUTS ;;       move4 0,F1                     ;patch return addr ;;       ~SETM 	;          LDA   2+0          STA   2+F1          LDA   0          STA   F1 ;;       ~RESTM 	;          pld                            ;fix DP          pla                            ;remove extra stack space          pla          pla          pla          rtl  ;;true   dstr  true true	DC.B	4 ;L:SYSA10	DC.B	4 ;L:SYSA10SYSA10	DC.B	'true';;false  dstr  false false	DC.B	5 ;L:SYSA11	DC.B	5 ;L:SYSA11SYSA11	DC.B	'false'		ENDP  **************************************************************** * *  ~PUTC - Format a Character for Output * *  Inputs: *        N - character to write *        F1 - field width *        CR - carriage return flag *        err - error output flag * **************************************************************** * 		EXPORT	~PUTC    ~PUTC    PROC 	;using ~IOCom N        equ   10                       ;number to write F1       equ   8                        ;field width CR       equ   6                        ;carriage return flag err      equ   4                        ;error output flag           tsc                            ;set up DP          phd          tcd          lda   #1                       ;set up string          sta   ~string+1          lda   N          sta   ~string+2 ;;       ph4   #~string                 ;write the string 	;          PEA   +(~string)>>16          PEA   ~string ;;       ph2   F1 	;          LDA   F1          PHA ;;       ph2   CR 	;          LDA   CR          PHA ;;       ph2   err 	;          LDA   err          PHA          jsl   ~PUTS ;;       move4 0,F1                     ;patch return addr ;;       ~SETM 	;          LDA   2+0          STA   2+F1          LDA   0          STA   F1 ;;       ~RESTM 	;          pld                            ;fix DP          pla                            ;remove extra stack space          pla          pla          pla          rtl 		ENDP **************************************************************** * *  ~PUTS - String Output * *  Inputs: *        adr - address of string to write *        F1 - field width *        CR - carriage return flag *        err - error output flag * **************************************************************** * 		EXPORT	~PUTS    ~PUTS    PROC 	;using ~IOCom adr      equ   10                       ;address of string to write F1       equ   8                        ;field width CR       equ   6                        ;carriage return flag err      equ   4                        ;error output flag           tsc                            ;set up DP          phd          tcd ;;       inc4  adr ;;       ~SETM 	;          INC   adr          BNE   ~2          INC   2+adr ;;~2     ~RESTM ~2	;          lda   [adr]                    ;A = - # lead blanks          and   #$00FF          sec          sbc   F1          bpl   lb1                      ;if A < 0 then          eor   #$FFFF                   ;  A = -A          inc   A          ldy   err                      ;  print A blanks          jsl   ~PRBL lb1	; ;endif           lda   [adr]                    ;f1 = length(adr^)          and   #$00FF          beq   lb4                      ;if f1 = 0 then          sta   f1                       ;  goto lb2 ;;       inc4  adr                      ;++adr ;;       ~SETM 	;          INC   adr          BNE   ~5          INC   2+adr ;;~5     ~RESTM ~5	;          lda   err                      ;if err then          beq   lb3 lb2      lda   [adr]                    ;  write the string to error out          and   #$00FF          pha          jsl   SysCharErrout ;;       inc4  adr ;;       ~SETM 	;          INC   adr          BNE   ~8          INC   2+adr ;;~8     ~RESTM ~8	;          dec   f1          bne   lb2          lda   cr                       ;  if cr then          beq   lb4          pea   13                       ;    write a return character          jsl   SysCharErrout          bra   lb4                      ;else lb3      lda   [adr]                    ;  write the string to standard out          and   #$00FF          pha          jsl   SysCharOut ;;       inc4  adr ;;       ~SETM 	;          INC   adr          BNE   ~11          INC   2+adr ;;~11    ~RESTM ~11	;          dec   f1          bne   lb3          lda   cr                       ;  if cr then          beq   lb4          pea   13                       ;    write a return character          jsl   SysCharOut lb4	; ;endif  ;;       move4 0,adr                    ;patch return addr ;;       ~SETM 	;          LDA   2+0          STA   2+adr          LDA   0          STA   adr ;;       ~RESTM 	;          pld                            ;fix DP          clc                            ;remove extra stack space          tsc          adc   #10          tcs          rtl 		ENDP  **************************************************************** * *  SysCharErrout - write a character to ;error out * *  Inputs: *        ch - character to write * **************************************************************** * 		EXPORT	SysCharErrout SysCharErrout PROC 	;using ~GSOSIO           jmp   trap                     ;used for intercepting I/O trap	;  ;;       lsub  (2:ch),0 	; ch       equ   0+4+0          tsc          phd          tcd           lda   ch          sta   >lch          lda   >~erroutRefnum          sta   >wrRefnum ;;       WriteGS wrRec          jsl   $E100A8 	DC.W	$2013	DC.L	wrRec ;;       lret 	;          lda   0+2          sta   0+2+2          lda   0+1          sta   0+2+1          pld          tsc          clc          adc   #0+2          tcs          rtl  wrRec	DC.W	4wrRefnum		DS.B 2 	DC.L	lch	DC.L	1		DS.B 4  lch		DS.B 2 		ENDP  **************************************************************** * *  SysCharOut - write a character to standard out * *  Inputs: *        ch - character to write * **************************************************************** * 		EXPORT	SysCharOut SysCharOut PROC 	;using ~GSOSIO           jmp   trap                     ;used for intercepting I/O trap	;  ;;       lsub  (2:ch),0 	; ch       equ   0+4+0          tsc          phd          tcd           lda   ch          sta   >lch          lda   >~stoutRefnum          sta   >wrRefnum ;;       WriteGS wrRec          jsl   $E100A8 	DC.W	$2013	DC.L	wrRec ;;       lret 	;          lda   0+2          sta   0+2+2          lda   0+1          sta   0+2+1          pld          tsc          clc          adc   #0+2          tcs          rtl  wrRec	DC.W	4wrRefnum		DS.B 2 	DC.L	lch	DC.L	1		DS.B 4  lch		DS.B 2 		ENDP  **************************************************************** * *  SysGraphTextCharOut - Single character graphics output * **************************************************************** * *SysGraphTextCharOut private SysGraphTextCharOut		PROCreturn   equ   13                       ;key codes lineFeed equ   10 ch       equ   5                        ;location of ch on stack           phb          phk          plb ; ;  Check the pen location ; ;;       ph4   #cPoint                  ;if pen location has changed from the 	;          PEA   +(cPoint)>>16          PEA   cPoint ;;       _GetPen                        ;  last time we were called          ldx   #$2904          jsl   $E10000          lda   cPoint          cmp   lPoint          bne   wt1          lda   cPoint+2          cmp   lPoint+2          beq   wt2 ;;wt1    move4 cPoint,rPoint            ;  set new return value ;;wt1    ~SETM wt1	;          LDA   2+cPoint          STA   2+rPoint          LDA   cPoint          STA   rPoint ;;       ~RESTM 	; ; ;  Printable character output ; wt2      lda   ch,S                     ;if this is not a CR then          cmp   #return          beq   wt3          cmp   #lineFeed                ;  ignore lineFeed character          beq   wt5          pha                            ;  write the character ;;       _DrawChar          ldx   #$A404          jsl   $E10000          bra   wt5 ; ;  CR output ; wt3      lda   #'A'                     ;else handle CR          pha ;;       ph4   #rect                    ;  get the character bounds 	;          PEA   +(rect)>>16          PEA   rect ;;       _CharBounds          ldx   #$AC04          jsl   $E10000          sec                            ;  compute the line feed length          lda   rect+4          sbc   rect          clc          adc   rPoint          sta   rPoint  ;;       ph4   rPoint                   ;  do the return 	;          LDA   rPoint+2          PHA          LDA   rPoint          PHA ;;       _MoveTo          ldx   #$3A04          jsl   $E10000 ; ;  Record the new pen location ; ;;wt5    ph4   #lPoint                  ;get the last pen location wt5	;          PEA   +(lPoint)>>16          PEA   lPoint ;;       _GetPen          ldx   #$2904          jsl   $E10000           plx                            ;remove parameter          ply          pla          phy          phx          plb                            ;restore B          rtl ; ;  Local data ; cPoint		DS.B 4                        ;current pen location lPoint		DS.B 4                        ;last known pen location rPoint		DS.B 4                        ;return point rect		DS.B 8                        ;character bounds rect 		ENDP  **************************************************************** * *  SysGraphTextLineIn - Graphics line input * *  Outputs: *        ~lineLength - new line length *        ~lineDisp - 0 *        ~line - input line * *  Notes: This subroutine is not currently tied to the actual *        output device.  It is also used by the CDA console *        driver as an input system. * **************************************************************** * 		EXPORT	SysGraphTextLineIn SysGraphTextLineIn PROC 	;using ~GSOSIO           phb          phk          plb           stz   emActive                 ;set the emActive flag          pha ;;       _EMStatus          ldx   #$0606          jsl   $E10000          pla          bcs   gt1          tay          beq   gt1          inc   emActive ;;gt1    KeyPressGS kpRec               ;set the shellActive flag ;;gt1    ~setm gt1	;          jsl   $E100A8 	DC.W	$015E	DC.L	kpRec;;       ~restm 	;          lda   #0          rol   A          eor   #$0001          sta   shellActive          stz   ~lineDisp                ;~lineDisp = 0          stz   ~lineLength              ;~lineLength = 0  gt2      jsr   GetCh                    ;read a character          pha                            ;echo it          pha          jsl   SysCharOut          pla ;;       short M                        ;save it          SEP   #1*32+0*16 			LONGA OFF          ldx   ~lineLength          sta   ~line,X ;;       long  M          REP   #1*32+0*16 			LONGA ON          cpx   #255                     ;if there is room in the line buffer then          bge   gt3          inc   ~lineLength              ;  ++~lineLength gt3      tax                            ;if not ch in [0, 13] then          beq   gt4                      ;  loop          cmp   #13          bne   gt2  gt4      plb          rtl ; ;  Read a single character ; GetCh    lda   emActive                 ;if emActive then          beq   gc3  gc1      pha                            ;  get a key event from the event manager ;;       ph2   #$0028 	;          PEA   $0028 ;;       ph4   #evRec 	;          PEA   +(evRec)>>16          PEA   evRec ;;       _GetNextEvent          ldx   #$0A06          jsl   $E10000          pla          beq   gc1          lda   evWhat          cmp   #5          beq   gc2          cmp   #3          bne   gc1 gc2      lda   evMessage          and   #$00FF          rts  gc3      lda   shellActive              ;else if shellActive then          beq   gc4 ;;       ReadKeyGS rkRec                ;  get a key from the shell ;;       ~setm 	;          jsl   $E100A8 	DC.W	$015F	DC.L	rkRec;;       ~restm 	;          lda   rkKey          rts  ;;gc4    short M                        ;else gc4      SEP   #1*32+0*16 			LONGA OFF gc5      lda   >$00C000                 ;  get a key from the keyboard latch          bpl   gc5          sta   >$00C010 ;;       long  M          REP   #1*32+0*16 			LONGA ON          and   #$007F          rts ; ;  Local data ; emActive		DS.B 2                        ;is the event manager active? shellActive		DS.B 2                        ;is the ORCA/Shell active?  kpRec	DC.W	3	;KeyPressGS record 		DS.B 2 		DS.B 2 		DS.B 2  rkRec	DC.W	2	;ReadKeyGS record rkKey		DS.B 2 		DS.B 2  evRec	; ;event record evWhat		DS.B 2 evMessage		DS.B 4 evWhen		DS.B 4 evWhere		DS.B 4 evModifiers		DS.B 2 		ENDP  **************************************************************** * *  SysGraphTextShutdown - reverse the effects of SysGraphTextStartup * **************************************************************** * 		EXPORT	SysGraphTextShutdown SysGraphTextShutdown PROC           lda   #SysCharErrout+3          sta   >SysCharErrout+1          lda   #SysCharOut+3          sta   >SysCharOut+1          lda   #SysLineIn+3          sta   >SysLineIn+1          rtl 		ENDP  **************************************************************** * *  SysGraphTextStartup - send console output to the current window * **************************************************************** * 		EXPORT	SysGraphTextStartup SysGraphTextStartup PROC           lda   #SysGraphTextCharOut          sta   >SysCharErrout+1          sta   >SysCharOut+1          lda   #SysGraphTextLineIn          sta   >SysLineIn+1          rtl 		ENDP  **************************************************************** * *  SysIOShutdown - Shut down the GS/OS text I/O system * **************************************************************** * 		EXPORT	SysIOShutDown SysIOShutDown PROC 	;using ~GSOSIO           phb          phk          plb          lda   ~opened                  ;if ~opened[10] then          beq   lb1          lda   ~stinRefnum              ;  Close(~stinRefnum)          sta   clRefnum ;;       CloseGS clRec          jsl   $E100A8 	DC.W	$2014	DC.L	clReclb1      lda   ~opened+2                ;if ~opened[11] then          beq   lb2          lda   ~stoutRefnum             ;  Close(~stoutRefnum)          sta   clRefnum ;;       CloseGS clRec          jsl   $E100A8 	DC.W	$2014	DC.L	clReclb2      lda   ~opened+4                ;if ~opened[12] then          beq   lb3          lda   ~erroutRefnum            ;  Close(~erroutRefnum)          sta   clRefnum ;;       CloseGS clRec          jsl   $E100A8 	DC.W	$2014	DC.L	clReclb3      plb          rtl  clRec	DC.W	1	;Close record clRefnum		DS.B 2 		ENDP  **************************************************************** * *  SysKeyAvail - see if a keypress is avaliable * *  Outputs: *        A - 1 if available, else 0 * **************************************************************** * 		EXPORT	SysKeyAvail SysKeyAvail PROC 	;using ~GSOSIO           lda   ~putback                 ;if ~putback <> 0 then          bne   true                     ;  return true          lda   ~lineLength              ;if ~lineLength <> 0 then          beq   lb1          cmp   ~lineDisp                ;  if ~lineLength <> ~lineDisp then          beq   lb1                      ;    return ~line[~lineLength] <> 0          ldx   ~lineDisp          lda   ~line,X          and   #$00FF          bne   true          bra   false  lb1      lda   ~inputIsConsole          ;if ~inputIsConsole then          beq   lb4          pha                            ;  if the Event Manager is active then ;;       _EMStatus          ldx   #$0606          jsl   $E10000          pla          bcs   lb2          tay          beq   lb2          pha                            ;    if a keypress is available then ;;       ph2   #$0028                   ;      return true 	;          PEA   $0028 ;;       ph4   evRec                    ;    else 	;          LDA   evRec+2          PHA          LDA   evRec          PHA ;;       _EventAvail                    ;      return false          ldx   #$0B06          jsl   $E10000          pla          bcs   false          tay          beq   false          bra   true ;;lb2    KeyPressGS kpRec               ;  else if shell is active then ;;lb2    ~setm lb2	;          jsl   $E100A8 	DC.W	$015E	DC.L	kpRec;;       ~restm 	;          bcs   lb3          lda   kpAvailable              ;    return kpAvailable          rtl  ;;lb3    short M                        ;  else lb3      SEP   #1*32+0*16 			LONGA OFF          lda   >$00C000                 ; return [$0C000000] & $0080 ;;       long  M          REP   #1*32+0*16 			LONGA ON          and   #$0080          bne   true          bra   false lb4      jsl   SysKeyin                 ;else          sta   ~putback                 ;  ~putback := SysKeyin          tax                            ;  return ~putback <> 0          beq   false  true     lda   #1          rtl  false    lda   #0          rtl  evRec		DS.B 16                       ;dummy event record  kpRec	DC.W	3		DS.B 2 		DS.B 2 kpAvailable		DS.B 2 		ENDP  **************************************************************** * *  SysKeyin - read a keypress * **************************************************************** * 		EXPORT	SysKeyin SysKeyin PROC 	;using ~GSOSIO           phb          phk          plb  top      lda   ~putback                 ;if ~putback then          beq   lb1          stz   ~putback                 ;  return ~putback, zeroing it          plb          rtl  lb1      ldx   ~lineDisp                ;if ~lineDisp < lineLength then          cpx   ~lineLength          bge   lb3          lda   ~line,X                  ;  return char, incrementing ~lineDisp          and   #$00FF                   ;    if the char is not chr(0)          beq   lb2          inc   ~lineDisp lb2      plb          rtl  lb3      jsl   SysLineIn                ;read an input line          bra   top                      ;loop 		ENDP  **************************************************************** * *  SysLinein - read an input line * *  Outputs: *        ~lineLength - new line length *        ~lineDisp - 0 *        ~line - input line * **************************************************************** * 		EXPORT	SysLinein SysLinein PROC 	;using ~GSOSIO           jmp   trap                     ;used for intercepting I/O trap	;           phb          phk          plb          lda   ~inputIsConsole          ;if ~inputIsConsole then          beq   lb4          jsr   ReadLine                 ;  read a new line          plb                            ;  return          rtl  lb4      lda   ~stinRefnum              ;else read a char from a file          sta   rdRefnum          stz   ~lineDisp          lda   #1          sta   ~lineLength          stz   ~line ;;       ReadGS rdRec          jsl   $E100A8 	DC.W	$2012	DC.L	rdRec         plb          rtl ; ;  ReadLine - read a line from .CONSOLE ; ReadLine	;           lda   ~inputIsConsole          ;set the device number          sta   trDevnum          sta   drDevnum          sta   gsDevnum          sta   frDevnum ;;       DControlGS trRec               ;set the terminators          jsl   $E100A8 	DC.W	$202E	DC.L	trRec;;       DControlGS frRec               ;do a formatted read          jsl   $E100A8 	DC.W	$202E	DC.L	frRec;;       DReadGS drRec                  ;read a line          jsl   $E100A8 	DC.W	$202F	DC.L	drRec;;       DStatusGS gsRec                ;find the terminator          jsl   $E100A8 	DC.W	$202D	DC.L	gsRec         ldx   drTransferCount          ;set the line length          inx          stx   ~lineLength ;;       short M                        ;put the terminator in the line          SEP   #1*32+0*16 			LONGA OFF          lda   gsLastTermChar          cmp   #$2E          bne   rl1          lda   #0          bra   rl2 rl1      cmp   #13          bne   rl2 ;;       long  M          REP   #1*32+0*16 			LONGA ON ;;       ph2   #13 	;          PEA   13          jsl   SysCharOut ;;       short M          SEP   #1*32+0*16 			LONGA OFF          lda   #13 rl2      sta   ~line-1,X ;;       long  M          REP   #1*32+0*16 			LONGA ON          stz   ~lineDisp                ;start the scanner at the first char          rts ; ;  Local data ; trRec	DC.W	5	;DControl record for setting terminators trDevnum		DS.B 2 	DC.W	$8001	DC.L	terminators	;control list ptr 	DC.L	10 ;l:termList+4	;request count 	DC.L	0	;transfer count  terminators	DC.W	$827F,3 ;l:termList/2termList	DC.W	$0200,$802E,$000D	;ctrl-@, open-apple ., RETURN  drRec	DC.W	6	;DRead record drDevnum		DS.B 2 	DC.L	~line	DC.L	255	DC.L	0	DC.W	0drTransferCount		DS.B 4  gsRec	DC.W	5	;DStatus record for reading the input port gsDevnum		DS.B 2 	DC.W	$8001	DC.L	list	;control list ptr 	DC.L	17	;request count 	DC.L	0	;transfer count  list		DS.B 1                        ;fill character 		DS.B 1                        ;default cursor mode 		DS.B 1                        ;current cursor mode 		DS.B 1                        ;beep flag 		DS.B 1                        ;initial entry flag 		DS.B 1                        ;exit type 		DS.B 1                        ;last char read 		DS.B 1                        ;last modifier key read gsLastTermChar		DS.B 1                     ;last terminator read 		DS.B 1                        ;last terminator modifier 		DS.B 1                        ;cursor position 		DS.B 1                        ;length of the returned string 		DS.B 1                        ;input field 		DS.B 1                        ;horizontal cursor position 		DS.B 2                        ;UIR origin.x 		DS.B 1                        ;vertical cursor position  rdRec	DC.W	4	;Read record rdRefnum		DS.B 2 	DC.L	~line	DC.L	1		DS.B 4  frRec	; ;DCB for D_Control to request UIM read 	DC.W	5	;parameter count frDevnum		DS.B 2                        ;device number 	DC.W	$8003	;control code 	DC.L	zero	;control list ptr 	DC.L	2	;request count 	DC.L	0 zero	DC.W	0		ENDP  **************************************************************** * *  SysIOStartup - Start up the GS/OS text I/O system * **************************************************************** * 		EXPORT	SysIOStartup SysIOStartup PROC 	;using ~GSOSIO           phb          phk          plb          stz   ~line                    ;start with an empty input line          stz   ~lineDisp          stz   ~lineLength          stz   ~putback                 ;nothing in the putback buffer ;;       ph2   #10                      ;set the standard in reference number 	;          PEA   10          jsl   ~GetRef          sta   ~stinRefnum           stz   ~inputIsConsole          ;~inputIsConsole := false          lda   ~stinRefnum              ;get the name for ~stinRefnum          sta   giRefnum ;;       GetRefInfoGS giRec          jsl   $E100A8 	DC.W	$2039	DC.L	giRec         bcs   lb1                      ;if (toolerror = 0)          lda   name+2                   ;   and (name = '.CONSOLE') then          cmp   #9          bne   la1          lda   name+12          and   #$00FF          cmp   #':'          bne   lb1          dec   name+2 la1      ldy   #8 lb0      lda   name+2,Y          cmp   console,Y          bne   lb1          dey          dey          bpl   lb0 ;;       GetDevNumberGS grRec           ;    inputIsConsole := GetDevNumber(.CONSOLE)          jsl   $E100A8 	DC.W	$2020	DC.L	grRec         bcs   lb1          lda   grRefnum          sta   ~inputIsConsole lb1	; ;endif  ;;       ph2   #11                      ;set the standard out reference number 	;          PEA   11          jsl   ~GetRef          sta   ~stoutRefnum  ;;       ph2   #12                      ;set the error out reference number 	;          PEA   12          jsl   ~GetRef          sta   ~erroutRefnum          plb          rtl  giRec	DC.W	3	;GetRefInfo record giRefnum		DS.B 2 		DS.B 2 	DC.L	name name	DC.W	13,0	;name returned by GetRefInfo 	DC.B	' '	DC.B	' '	DC.B	' '	DC.B	' '	DC.B	' '	DC.B	' '	DC.B	' '	DC.B	' '	DC.B	' ' grRec	DC.W	2	;GetDevNumber record 	DC.L	consolegrRefnum		DS.B 2  ;;console dosw '.CONSOLE' console	DC.W	8 ;L:~A7~A7	DC.B	'.CONSOLE'		ENDP  **************************************************************** * *  SysPutback - put a character in the putback buffer * *  Inputs: *        ch - character to put back * **************************************************************** * 		EXPORT	SysPutback SysPutback PROC 	;using ~GSOSIO           phb          plx          ply          pla          sta   ~putback          phy          phx          plb          rtl 		ENDP		END