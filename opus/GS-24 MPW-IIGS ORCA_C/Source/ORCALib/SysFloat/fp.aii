	seg   ''******************************************************************  SANE Floating Point Libraries**  These libraries are common routines used by the 65816 ORCA*  native code compilers for accessing SANE.**  Copyright 1987, 1990, 1992*  Byte Works, Inc.*  All rights reserved.**  By Mike Westerfield**  Notes: Some subroutines in this library do not contain SANE*  calls, but they are called by other subroutines that do.*  Many are also called from ORCALib or ;PasLib, so do not change*  the call protocall or global variables.******************************************************************;------------------------------------------;; Equates from procedure ~FileCom;;------------------------------------------~flLen   equ   $0                       ;length of the buffer~flRef   equ   $4                       ;ProDOS reference number~flKind  equ   $6                       ;Open for input (1), output (2),~flEOLN  equ   $8                       ;end of line flag~flEOF   equ   $A                       ;end of file flag~flNameLen equ $C                       ;length of the file name~flName  equ   $E                       ;pointer to name of file~flHeader equ  $12                      ;length of the file header; bufferpasStringLen equ 81			;length of the pasString buffer;-----------------------------------------------;;   Imported addresses;;-----------------------------------------------	IMPORT	SysKeyin	IMPORT	SysPutback	IMPORT	SystemError	IMPORT	~EOFInput	IMPORT	~EOLNInput	IMPORT	~GetBuffer	IMPORT	~InputChar	IMPORT	~New	IMPORT	~Puts	IMPORT	~RealVal	IMPORT	~StringList	IMPORT	~_COut	IMPORT	~ranx	IMPORT	~seed;-----------------------------------------------;;   Forward addresses and entries;;-----------------------------------------------	ENTRY	decForm	ENTRY	decrec	ENTRY	digits	ENTRY	index	ENTRY	one	ENTRY	pasString	ENTRY	pi	ENTRY	piover2	ENTRY	style	ENTRY	t1	ENTRY	t2	ENTRY	valid	ENTRY	~ArcSinE	ENTRY	~FormatReal	ENTRY	~GetSBuffer	ENTRY	~StringToStandard******************************************************************  SetFPESlot - Set the FPE slot number**  Inputs:*        slot - slot number******************************************************************		EXPORT	SetFPESlot SetFPESlot PROC         phb         phk         plb         plx         ply         pla         phy         phx         plb         rtl		ENDP******************************************************************  ~AddE - Add two SANE extended numbers**  Inputs:*        n1,n2: numbers******************************************************************		EXPORT	~AddE    ~AddE    PROC			longa on			longi on         tsc                            ;push the addresses         pea   0         clc         adc   #4         pha         pea   0         adc   #10         pha;;       faddx                          ;add the two numbers         PEA   0         LDX   #$090A         JSL   $E10000         lda   0,S                      ;remove the left over from the stack         sta   10,S         lda   2,S         sta   12,S         tsc         clc         adc   #10         tcs         rtl		ENDP******************************************************************  ~ArcCosE - ArcCos function**  Inputs:*        1,S - return address*        4,S - number******************************************************************		EXPORT	~ArcCosE ~ArcCosE PROC			longa on			longi on	;using ~RealCom         lda   12,S                     ;t1 := arcsin(x)         pha         lda   12,S         pha         lda   12,S         pha         lda   12,S         pha         lda   12,S         pha         jsl   ~ArcSinE         pla         sta   >t1         pla         sta   >t1+2         pla         sta   >t1+4         pla         sta   >t1+6         pla         sta   >t1+8         lda   >piover2                 ;x := pi/2         sta   4,S         lda   >piover2+2         sta   6,S         lda   >piover2+4         sta   8,S         lda   >piover2+6         sta   10,S         lda   >piover2+8         sta   12,S;;       ph4   #t1                      ;x := x-t1	;          PEA   +(t1)>>16         PEA   t1         pea   0         clc         tsc         adc   #10         pha;;       fsubx         PEA   2         LDX   #$090A         JSL   $E10000         rtl		ENDP******************************************************************  ~ArcSinE - ArcSin function**  Inputs:*        1,S - return address*        4,S - number******************************************************************		EXPORT	~ArcSinE ~ArcSinE PROC			longa on			longi on	;using ~RealComloc      equ   6                        ;location of number         phd                            ;set up local DP         tsc         tcd         phb                            ;set up local data addressing         phk         plb         ldx   #8                       ;t1 := onelb1      lda   one,X                    ;t2 := x         sta   t1,X         lda   loc,X         sta   t2,X         dex         dex         bpl   lb1         pea   0                        ;push addresses onto the stack         clc                            ; push(x)         tdc         adc   #loc         pha         ldy   #^t1                     ; push(t1)         ldx   #t1         phy         phx         pea   0                        ; push(x)         pha         phy                            ; push(t1);         phx         lda   #t2                      ; push(t2)         phy         pha         phy                            ; push(t1)         phx         phy                            ; push(t2)         pha         phy                            ; push(t2)         pha;;       fmulx                          ;t2 := t2*t2         PEA   4         LDX   #$090A         JSL   $E10000;;       fsubx                          ;t1 := t1-t2         PEA   2         LDX   #$090A         JSL   $E10000;;       fsqrtx                         ;t1 := sqrt(t1)         PEA   $12         LDX   #$090A         JSL   $E10000;;       fdivx                          ;x := x/t1         PEA   6         LDX   #$090A         JSL   $E10000;;       fatanx                         ;x := arctan(x)         PEA   $18         LDX   #$0B0A         JSL   $E10000         plb                            ;reset data bank         pld                            ;restore DP         rtl		ENDP******************************************************************  ~ArcTan2E - Take the two argument arc tangent of two SANE extended numbers**  Inputs:*        n1,n2: numbers******************************************************************		EXPORT	~ArcTan2E ~ArcTan2E PROC			longa on			longi on	;using ~RealCom         lda   12,S                     ;y := arctan(y/x);         pha                            ;(save signs)         lda   24,S         pha         clc         tsc         adc   #8         tay         adc   #10         pea   0         pha         pea   0         phy         pea   0         pha;;       fdivx         PEA   6         LDX   #$090A         JSL   $E10000;;       fatanx         PEA   $18         LDX   #$0B0A         JSL   $E10000         ply                            ;if x < 0 then         plx                            ;  if y >= 0 then         bpl   lb2                      ;    y := y+pi         pea   pi>>16                   ;  else         pea   pi                       ;    y := y-pi         pea   0         clc         tsc         adc   #20         pha         tya         bmi   lb1;;       faddx         PEA   0         LDX   #$090A         JSL   $E10000         bra   lb2;;lb1    fsubxlb1      PEA   2         LDX   #$090A         JSL   $E10000lb2      lda   0,S                      ;remove the left over from the stack         sta   10,S         lda   2,S         sta   12,S         tsc         clc         adc   #10         tcs         rtl		ENDP******************************************************************  ~AtnE - ArcTan function**  Inputs:*        1,S - return address*        4,S - number******************************************************************		EXPORT	~AtnE    ~AtnE    PROC			longa on			longi on         tsc                            ;push the addresse twice         pea   0         clc         adc   #4         pha;;       fatanx                         ;compute function         PEA   $18         LDX   #$0B0A         JSL   $E10000         rtl		ENDP******************************************************************  ~CCompRet - Save a comp function return value in ~RealVal**  Inputs:*        rval - comp value to save**  Outputs:*        X-Y - address of ~RealVal******************************************************************		EXPORT	~CCompRet ~CCompRet PROClcAfterMarkStack equ 1                  ;location of function return value         pea   0                        ;push address of double value         tdc         clc         adc   #lcAfterMarkStack         pha;;       ph4   #~RealVal                ;push address of extended value	;          PEA   +(~RealVal)>>16         PEA   ~RealVal;;       fc2x                           ;convert to extended         PEA   $050E         LDX   #$090A         JSL   $E10000         ldx   #^~RealVal               ;load address of result         ldy   #~RealVal         rtl                            ;return		ENDP******************************************************************  ~CDoubleRet - Save a double function ;return value in ~RealVal**  Inputs:*        rval - double value to save**  Outputs:*        X-Y - address of ~RealVal******************************************************************		EXPORT	~CDoubleRet ~CDoubleRet PROClcAfterMarkStack equ 1                  ;location of function return value         pea   0                        ;push address of double value         tdc         clc         adc   #lcAfterMarkStack         pha;;       ph4   #~RealVal                ;push address of extended value	;          PEA   +(~RealVal)>>16         PEA   ~RealVal;;       fd2x                           ;convert to extended         PEA   $010E         LDX   #$090A         JSL   $E10000         ldx   #^~RealVal               ;load address of result         ldy   #~RealVal         rtl                            ;return		ENDP******************************************************************  ~CExtendedRet - Save an extended function return value in ~RealVal**  Inputs:*        rval - extended value to save**  Outputs:*        X-Y - address of ~RealVal******************************************************************		EXPORT	~CExtendedRet ~CExtendedRet PROClcAfterMarkStack equ 1                  ;location of function return value         ldx   #8                       ;move the valuelb1      lda   lcAfterMarkStack,X         sta   >~RealVal,X         dex         dex         bpl   lb1         ldx   #^~RealVal               ;load address of result         ldy   #~RealVal         rtl                            ;return		ENDP******************************************************************  ~CnvES - convert extended sane to string**  Inputs:*        1,S - return address*        4,S - fixed precision digit count*        6,S - field width*        8,S - extended format real number**  Outputs:*        stack - length of result string*        stack-1 - pointer to result string******************************************************************		EXPORT	~CnvES   ~CnvES   PROC	;using ~RealCom			longa on			longi onsLen     equ   0sAddr    equ   2                        ;string pointerreturn   equ   0decDig   equ   3fw       equ   5ext      equ   7rLen     equ   11                       ;return string lengthrAddr    equ   13                       ;return string address         tdc                            ;set up stack and direct page         tax         tsc         sec         sbc   #$FFFF         tcd         dec   a         tcs         phx         phb                            ;set data bank reg         phk         plb         ldx   #12                      ;format the numbercv1      lda   decDig,X         pha         dex         dex         bpl   cv1         jsl   ~FormatReal         lda   pasString         and   #$00FF         sta   rLen         beq   rts         ldx   #0         jsr   ~GetSBuffer         sta   rAddr         stx   rAddr+2         bcs   err         ldy   rLen         dey;;       short M         SEP   #1*32+0*16			LONGA OFFcv2      lda   pasString+1,y         sta   [rAddr],y         dey         bpl   cv2;;       long  M         REP   #1*32+0*16			LONGA ONrts      plb         lda   return+1         sta   rLen-2         lda   return         sta   rLen-3         clc         tdc         adc   #rLen-4         pld         tcs         rtl;;err    error #5                       ;out of memory;;err    ph2   #5err	;          PEA   5         jsl   SystemError         stz   sLen                     ;return 0         bra   rts		ENDP******************************************************************  ~CnvIntReal - convert an integer into an extended SANE real**  Inputs:*        A - integer**  Outputs:*        extended real on stack******************************************************************		EXPORT	~CnvIntReal ~CnvIntReal PROC			longa on			longi on         phb                            ;recover return addr         plx         ply         pha                            ;make room for extended value         pha         pha         pha         pha         phy                            ;fix return address         phx         plb         pha                            ;save integer on stack         tsc                            ;push address of integer         ina         pea   0         pha         pea   0                        ;push address of extended real         clc         adc   #5         pha;;       fi2x                           ;convert         PEA   $040E         LDX   #$090A         JSL   $E10000         pla                            ;remove integer         rtl                            ;return		ENDP******************************************************************  ~CnvLE - convert a longint into an extended SANE real**  Inputs:*        longint on stack**  Outputs:*        extended real on stack******************************************************************		EXPORT	~CnvLE   ~CnvLE   PROC	;using ~RealCom			longa on			longi on         phb                            ; recover return addr & set up bank addr         phk         plb;;       pl4   t1+4	;          PLA         STA   t1+4         PLA         STA   t1+4+2;;       pl4   t1                       ;fetch number to convert	;          PLA         STA   t1         PLA         STA   t1+2;;       ph4   #t1                      ;push addr of integer	;          PEA   +(t1)>>16         PEA   t1;;       ph4   #t2                      ;push addr to place result	;          PEA   +(t2)>>16         PEA   t2;;       fl2x                           ;convert         PEA   $030E         LDX   #$090A         JSL   $E10000         lda   t2+8                     ;push real result         pha         lda   t2+6         pha         lda   t2+4         pha         lda   t2+2         pha         lda   t2         pha;;       ph4   t1+4                     ;fix stack	;          LDA   t1+4+2         PHA         LDA   t1+4         PHA         plb         rtl                            ;return		ENDP******************************************************************  ~CnvLongReal - convert a long integer into an extended SANE real**  Inputs:*        A - integer**  Outputs:*        extended real on stack******************************************************************		EXPORT	~CnvLongReal ~CnvLongReal PROC		EXPORT	~CnvULongReal~CnvULongReal		;		         phb                            ;save the long value         phk         plb         sta   lval         stx   lval+2         plx                            ;recover return addr         ply         pha                            ;make room for extended value         pha         pha         pha         pha         phy                            ;fix return address         phx         plb;;       ph4   #lval                    ;push address of integer	;          PEA   +(lval)>>16         PEA   lval         pea   0                        ;push address of extended real         clc         tsc         adc   #10         pha;;       fl2x                           ;convert         PEA   $030E         LDX   #$090A         JSL   $E10000         rtl                            ;returnlval		DS.B 4                        ;long value		ENDP******************************************************************  ~CnvRealInt - trunc and convert a real to an integer**  Inputs:*        extended real on stack**  Outputs:*        A - integer******************************************************************		EXPORT	~CnvRealInt ~CnvRealInt PROC			longa on			longi on         tsc                            ;push address of real 2 times         clc         adc   #4         pea   0         pha         pea   0         pha         pea   0                        ;push address of integer         pha;;       ftintx                         ;round         PEA   $0016         LDX   #$090A         JSL   $E10000;;       fx2i                           ;convert         PEA   $0410         LDX   #$090A         JSL   $E10000         phb                            ;move return address         pla         sta   9,S         pla         sta   9,S         pla                            ;remove integer         plx                            ;fix stack         plx         plb         tax                            ;set condition codes         rtl                            ;return		ENDP******************************************************************  ~CnvRealLong - trunc and convert a real to a long**  Inputs:*        extended real on stack**  Outputs:*        X-A - integer******************************************************************		EXPORT	~CnvRealLong ~CnvRealLong PROC         tsc                            ;push address of real 2 times         clc         adc   #4         pea   0         pha         pea   0         pha         pea   0                        ;push address of integer         pha;;       ftintx                         ;round         PEA   $0016         LDX   #$090A         JSL   $E10000;;       fx2l                           ;convert         PEA   $0310         LDX   #$090A         JSL   $E10000         phb                            ;move return address         pla         sta   9,S         pla         sta   9,S         pla                            ;remove integer         plx         ply                            ;fix stack         plb         tay                            ;set condition codes         bne   lb1         txylb1      rtl                            ;return		ENDP******************************************************************  ~CnvRealUInt - trunc and convert a real to an integer**  Inputs:*        extended real on stack**  Outputs:*        A - integer******************************************************************		EXPORT	~CnvRealUInt ~CnvRealUInt PROC			longa on			longi on         tsc                            ;push address of real 2 times         clc         adc   #4         pea   0         pha         pea   0         pha         pea   0                        ;push address of integer         pha;;       ftintx                         ;round         PEA   $0016         LDX   #$090A         JSL   $E10000;;       fx2l                           ;convert         PEA   $0310         LDX   #$090A         JSL   $E10000         phb                            ;move return address         pla         sta   9,S         pla         sta   9,S         pla                            ;remove integer         plx                            ;fix stack         plx         plb         tax                            ;set condition codes         rtl                            ;return		ENDP******************************************************************  ~CnvSE - convert string to extended sane**  Inputs:*        1,S - return address*        4,S - string len*        6,S - string**  Outputs:*        stack - length of result string*        stack-1 - pointer to result string******************************************************************		EXPORT	~CnvSE   ~CnvSE   PROC			longa on			longi on	;using ~FileCom	;using ~RealComdpage    equ   1                        ;caller's direct pagereturn   equ   3                        ;return addressext      equ   6slen     equ   10                       ;string lengthsAddr    equ   12                       ;string address         lda   3,S                      ;move and save return address         pha         lda   3,S         pha         phd                            ;save direct page         tsc                            ;set up direct page         tcd         phb                            ;save data bank         phk                            ;set up local data bank         plb;;       ph4   sAddr                    ;convert string to standard form	;          LDA   sAddr+2         PHA         LDA   sAddr         PHA;;       ph2   sLen	;          LDA   sLen         PHA         jsr   ~StringToStandard;;       pl2   sLen	;          PLA         STA   sLen;;       pl4   sAddr	;          PLA         STA   sAddr         PLA         STA   sAddr+2         lda   sLen         tax;;       short M                        ;move over the string         SEP   #1*32+0*16			LONGA OFF         sta   pasString         lda   #0         sta   pasString+1,X         txy         beq   cv3         bra   cv2cv1      lda   [sAddr],Y         sta   pasString+1,Ycv2      dey         bpl   cv1;;  Convert the string into a number;;;cv3    long  Mcv3      REP   #1*32+0*16			LONGA ON         ldy   #0                       ;skip leading blanks         lda   #' ';;       short M         SEP   #1*32+0*16			LONGA OFFcv4      cmp   pasString+1,Y         bne   cv5         iny         bra   cv4;;cv5    long  Mcv5      REP   #1*32+0*16			LONGA ON         sty   index;;       ph4   #pasString+1             ;lvp^.rval := cnvsr(digit);	;          PEA   +(pasString+1)>>16         PEA   pasString+1;;       ph4   #index                   ;{convert from ascii to decform}	;          PEA   +(index)>>16         PEA   index;;       ph4   #decrec	;          PEA   +(decrec)>>16         PEA   decrec;;       ph4   #valid	;          PEA   +(valid)>>16         PEA   valid         stz   index;;       fcstr2dec         PEA   2         LDX   #$0A0A         JSL   $E10000         lda   valid                    ;{flag an error if SANE said to}         beq   err1         lda   pasString         and   #$00FF         cmp   index         bne   err1;;       ph4   #decrec                  ;{convert decform to real}	;          PEA   +(decrec)>>16         PEA   decrec         pea   0         clc         tdc         adc   #ext         pha;;       fdec2x         PEA   $09         LDX   #$090A         JSL   $E10000         bcc   rts;;err1   error #10                      ;real math error;;err1   ph2   #10err1	;          PEA   10         jsl   SystemErrorrts      plb         pld         rtl		ENDP******************************************************************  ~CompFix - Convert a parameter from extended to comp**  Inputs:*        rval - disp in stack frame of real value******************************************************************		EXPORT	~CompFix ~CompFix PROC			longa on			longi onrval     equ   4         tdc                            ;push address of real value         clc         adc   rval,S         pea   0         pha         pea   0         pha;;       fx2c                           ;convert from extended         PEA   $0510         LDX   #$090A         JSL   $E10000         lda   2,S                      ;fix return addr         sta   4,S         pla         sta   1,S         rtl		ENDP******************************************************************  ~CompRet2 - Save a comp function return value in ~RealVal**  Inputs:*        rval - real value to save**  Outputs:*        X-Y - address of ~RealVal**  Notes: Pascal 2.0 version******************************************************************		EXPORT	~CompRet2 ~CompRet2 PROC         lda   1,S                      ;swap address of value         tax                            ; and return address         lda   2,S         tay         lda   4,S         sta   1,S         lda   6,S         sta   3,S         tya         sta   6,S         txa         sta   5,S;;       ph4   #~RealVal                ;push address of extended value	;          PEA   +(~RealVal)>>16         PEA   ~RealVal;;       fc2x                           ;convert to extended         PEA   $050E         LDX   #$090A         JSL   $E10000         ldx   #^~RealVal               ;load address of result         ldy   #~RealVal         rtl                            ;return		ENDP******************************************************************  ~CopyComp - Save a comp value**  Inputs:*        1,S - return address*        4,S - address to save to*        8,S - extended real value******************************************************************		EXPORT	~CopyComp ~CopyComp PROC;;       csubroutine (4:addr),0	; addr     equ   0+4+0         tsc         phd         tcdext      equ   addr+4;;       ph2   #0                       ;push addr of extended #	;          PEA   0         clc         tdc         adc   #ext         pha;;       ph4   addr                     ;push addr of real value	;          LDA   addr+2         PHA         LDA   addr         PHA;;       fx2c                           ;convert and move         PEA   $0510         LDX   #$090A         JSL   $E10000;;       creturn	;          lda   0+2         sta   0+4+2         lda   0+1         sta   0+4+1         pld         tsc         clc         adc   #0+4         tcs         rtl		ENDP******************************************************************  ~CopyDouble - Copy a double value**  Inputs:*        1,S - return address*        4,S - address to save to*        8,S - extended real value******************************************************************		EXPORT	~CopyDouble ~CopyDouble PROC;;       csubroutine (4:addr),0	; addr     equ   0+4+0         tsc         phd         tcdext      equ   addr+4;;       ph2   #0                       ;push addr of extended #	;          PEA   0         clc         tdc         adc   #ext         pha;;       ph4   addr                     ;push addr of real value	;          LDA   addr+2         PHA         LDA   addr         PHA;;       fx2d                           ;convert and move         PEA   $0110         LDX   #$090A         JSL   $E10000;;       creturn	;          lda   0+2         sta   0+4+2         lda   0+1         sta   0+4+1         pld         tsc         clc         adc   #0+4         tcs         rtl		ENDP******************************************************************  ~CopyExtended - Save an extended value**  Inputs:*        1,S - return address*        4,S - address to save to*        8,S - extended real value******************************************************************		EXPORT	~CopyExtended ~CopyExtended PROC;;       csubroutine (4:addr),0	; addr     equ   0+4+0         tsc         phd         tcdext      equ   addr+4         ldx   #8lb1      txy         lda   ext,X         sta   [addr],Y         dex         dex         bpl   lb1;;       creturn	;          lda   0+2         sta   0+4+2         lda   0+1         sta   0+4+1         pld         tsc         clc         adc   #0+4         tcs         rtl		ENDP******************************************************************  ~CopyReal - Save a real value**  Inputs:*        1,S - return address*        4,S - address to save to*        8,S - extended real value******************************************************************		EXPORT	~CopyReal ~CopyReal PROC;;       csubroutine (4:addr),0	; addr     equ   0+4+0         tsc         phd         tcdext      equ   addr+4;;       ph2   #0                       ;push addr of extended #	;          PEA   0         clc         tdc         adc   #ext         pha;;       ph4   addr                     ;push addr of real value	;          LDA   addr+2         PHA         LDA   addr         PHA;;       fx2s                           ;convert and move         PEA   $0210         LDX   #$090A         JSL   $E10000;;       creturn	;          lda   0+2         sta   0+4+2         lda   0+1         sta   0+4+1         pld         tsc         clc         adc   #0+4         tcs         rtl		ENDP******************************************************************  ~CosE - Cosine function**  Inputs:*        1,S - return address*        4,S - number******************************************************************		EXPORT	~CosE    ~CosE    PROC			longa on			longi on         tsc                            ;push the addresse twice         pea   0         clc         adc   #4         pha;;       fcosx                          ;compute function         PEA   $1C         LDX   #$0B0A         JSL   $E10000         rtl		ENDP******************************************************************  ~CRealRet - Save a real function return value in ~RealVal**  Inputs:*        rval - real value to save**  Outputs:*        X-Y - address of ~RealVal******************************************************************		EXPORT	~CRealRet ~CRealRet PROClcAfterMarkStack equ 1                  ;size of default part of stack frame         pea   0                        ;push address of real value         tdc         clc         adc   #lcAfterMarkStack         pha;;       ph4   #~RealVal                ;push address of extended value	;          PEA   +(~RealVal)>>16         PEA   ~RealVal;;       fs2x                           ;convert to extended         PEA   $020E         LDX   #$090A         JSL   $E10000         ldx   #^~RealVal               ;load address of result         ldy   #~RealVal         rtl                            ;return		ENDP******************************************************************  ~DivE - Divide two SANE extended numbers**  Inputs:*        n1,n2: numbers******************************************************************		EXPORT	~DivE    ~DivE    PROC			longa on			longi on         tsc                            ;push the addresses         pea   0         clc         adc   #4         pha         pea   0         adc   #10         pha;;       fdivx                          ;divide the two numbers         PEA   6         LDX   #$090A         JSL   $E10000         lda   0,S                      ;remove the left over from the stack         sta   10,S         lda   2,S         sta   12,S         tsc         clc         adc   #10         tcs         rtl		ENDP******************************************************************  ~DoubleFix - Convert a parameter from extended to double**  Inputs:*        rval - disp in stack frame of double value******************************************************************		EXPORT	~DoubleFix ~DoubleFix PROC			longa on			longi onrval     equ   4         tdc                            ;push address of double value         clc         adc   rval,S         pea   0         pha         pea   0         pha;;       fx2d                           ;convert from extended         PEA   $0110         LDX   #$090A         JSL   $E10000         lda   2,S                      ;fix return addr         sta   4,S         pla         sta   1,S         rtl		ENDP******************************************************************  ~DoubleRet - Save a double function return value in ~RealVal**  Inputs:*        rval - double value to save**  Outputs:*        X-Y - address of ~RealVal******************************************************************		EXPORT	~DoubleRet ~DoubleRet PROC			longa on			longi onlcAfterMarkStack equ 22                 ;location of function return value         pea   0                        ;push address of double value         tdc         clc         adc   #lcAfterMarkStack         pha;;       ph4   #~RealVal                ;push address of extended value	;          PEA   +(~RealVal)>>16         PEA   ~RealVal;;       fd2x                           ;convert to extended         PEA   $010E         LDX   #$090A         JSL   $E10000         ldx   #^~RealVal               ;load address of result         ldy   #~RealVal         rtl                            ;return		ENDP******************************************************************  ~DoubleRet2 - Save a double function ;return value in ~RealVal**  Inputs:*        rval - double value to save**  Outputs:*        X-Y - address of ~RealVal**  Notes: Pascal 2.0 version******************************************************************		EXPORT	~DoubleRet2 ~DoubleRet2 PROC         lda   1,S                      ;swap address of double value         tax                            ; and return address         lda   2,S         tay         lda   4,S         sta   1,S         lda   6,S         sta   3,S         tya         sta   6,S         txa         sta   5,S;;       ph4   #~RealVal                ;push address of extended value	;          PEA   +(~RealVal)>>16         PEA   ~RealVal;;       fd2x                           ;convert to extended         PEA   $010E         LDX   #$090A         JSL   $E10000         ldx   #^~RealVal               ;load address of result         ldy   #~RealVal         rtl                            ;return		ENDP******************************************************************  ~EquE - Test two SANE extended numbers for equality**  Inputs:*        n1,n2: numbers**  Outputs:*        A - 1 if equal, else 0*        Z - 0 if equal, else 1******************************************************************		EXPORT	~EquE    ~EquE    PROC			longa on			longi on         tsc                            ;push the addresses         pea   0         clc         adc   #4         pha         pea   0         adc   #10         pha;;       fcpxx                          ;add the two numbers         PEA   $0A         LDX   #$090A         JSL   $E10000         lda   0,S                      ;remove the left over from the stack         sta   20,S         lda   2,S         sta   22,S         tsc         clc         adc   #20         tcs         txa                            ;set the result         lsr   A         and   #1         rtl		ENDP******************************************************************  ~ExpE - Exponent function**  Inputs:*        1,S - return address*        4,S - number******************************************************************		EXPORT	~ExpE    ~ExpE    PROC			longa on			longi on         tsc                            ;push the addresse twice         pea   0         clc         adc   #4         pha;;       fexpx                          ;compute function         PEA   8         LDX   #$0B0A         JSL   $E10000         rtl		ENDP******************************************************************  ~ExtendedRet2 - Save an extended function return value in ~RealVal**  Inputs:*        rval - real value to save**  Outputs:*        X-Y - address of ~RealVal**  Notes: Pascal 2.0 version******************************************************************		EXPORT	~ExtendedRet2 ~ExtendedRet2 PROC         lda   1,S                      ;swap address of value         tax                            ; and return address         lda   2,S         tay         lda   4,S         sta   1,S         lda   6,S         sta   3,S         tya         sta   6,S         txa         sta   5,S         tsc                            ;set up a stack frame         phd         tcd         phb         phk         plb         ldy   #8                       ;move the extended valuelb1      lda   [1],Y         sta   ~RealVal,Y         dey         dey         bpl   lb1         plb                            ;get rid of the stack frame         pld         pla         pla         ldx   #^~RealVal               ;load address of result         ldy   #~RealVal         rtl                            ;return		ENDP******************************************************************  ~FileCom - common area for files******************************************************************		EXPORT	~FileCom ~FileCom PROC;;  Definition of a file structure;*                                       ;  text input (5), text output (6);;  File buffer variables;		EXPORT	~fileBuff~fileBuff		DS.B 4                        ;pointer to next file buffer		EXPORT	~fileRecBuff~fileRecBuff		DS.B 4                       ;pointer to next file record buffer		ENDP******************************************************************  ~FormatReal - convert an extended SANE number to a string**  Inputs:*        ext - extended format real number*        fw - field width*        decDig - fixed precision digit ;count**  Outputs:*        passtring - string with leading length byte******************************************************************		EXPORT	~FormatReal ~FormatReal PROC			longa on			longi on	;using ~RealCom;;       sub   (2:decDig,2:fw,10:ext),0	; decDig   EQU   3fw       EQU   5ext      EQU   7         TDC         TAX         TSC         SEC         SBC   #0-1         TCD         DEC   A         TCS         PHX         phb         phk         plb         lda   decDig                   ;if exponential format then         bne   lb3         stz   style                    ;  set style to exponential         sec                            ;  set # sig digits         lda   fw         bmi   lb1         sbc   #7         bmi   lb1         cmp   #2         bge   lb2lb1      lda   #2lb2      sta   digits         bra   lb4                      ;elselb3      sta   digits                   ;  set # decimal digits         lda   #1                       ;  set style to fixed         sta   stylelb4	; ;endif;;       ph4   #decForm                 ;convert to decimal record	;          PEA   +(decForm)>>16         PEA   decForm;;       ph2   #0	;          PEA   0         clc         tdc         adc   #ext         pha;;       ph4   #decRec	;          PEA   +(decRec)>>16         PEA   decRec;;       fx2dec         PEA   $0B         LDX   #$090A         JSL   $E10000;;       ph4   #decForm                 ;convert to string	;          PEA   +(decForm)>>16         PEA   decForm;;       ph4   #decRec	;          PEA   +(decRec)>>16         PEA   decRec;;       ph4   #pasString	;          PEA   +(pasString)>>16         PEA   pasString;;       fdec2str         PEA   1         LDX   #$0A0A         JSL   $E10000         lda   decDig                   ;if exponential format then         bne   lb7;;       short I,M         SEP   #1*32+1*16			LONGA OFF			LONGI OFF         ldx   pasString                ;  if format is e+0 then         lda   pasString-2,X         cmp   #'e'         bne   lb5         lda   pasString,X              ;    make it e+00         sta   pasString+1,X         lda   #'0'         sta   pasString,X         inc   pasStringlb5	; ;  endif         ldx   pasString                ;  if format is e+00 then         lda   pasString-3,X         cmp   #'e'         bne   lb6         lda   pasString,X              ;    make it e+000         sta   pasString+1,X         lda   pasString-1,X         sta   pasString,X         lda   #'0'         sta   pasString-1,X         inc   pasStringlb6	; ;  endif;;       long  I,M         REP   #1*32+1*16			LONGA ON			LONGI ONlb7	; ;endif         lda   #80                      ;if fw > 80 then fw := 80;         cmp   fw         bge   lb8         sta   fwlb8	; lb9      lda   pasString                ;while len(string) < fw do         and   #$00FF         cmp   fw         bge   lb11;;       short I,M                      ;  insert(' ',string);         SEP   #1*32+1*16			LONGA OFF			LONGI OFF         ldx   pasStringlb10     lda   pasString,X         sta   pasString+1,X         dex         bne   lb10         lda   #' '         sta   pasString+1         inc   pasString;;       long  I,M         REP   #1*32+1*16			LONGA ON			LONGI ON         bra   lb9lb11	;          plb;;       return         LDA   0+1         STA   17-2         LDA   0         STA   17-3         CLC         TDC         ADC   #17-4         PLD         TCS         RTL		ENDP******************************************************************  ~GeqE - Test two SANE extended numbers for A >= B**  Inputs:*        n1,n2: numbers**  Outputs:*        A - 1 if true, else 0*        Z - 0 if true, else 1******************************************************************		EXPORT	~GeqE    ~GeqE    PROC			longa on			longi on         tsc                            ;push the addresses         pea   0         clc         adc   #14         pha         pea   0         sec         sbc   #10         pha;;       fcpxx                          ;compare the two numbers         PEA   $0A         LDX   #$090A         JSL   $E10000         lda   0,S                      ;remove the left over from the stack         sta   20,S         lda   2,S         sta   22,S         tsc         clc         adc   #20         tcs         txa                            ;set the result         and   #$0042         beq   lb1         lda   #1lb1      rtl		ENDP******************************************************************  ~GetCharInput - read a character from standard in*  ~ReadCharInput - read a character from standard in**  Outputs:*        ~EOLNInput - eoln(input)*        ~EOFInput - eof(input)*        A - character read*        ~InputChar - character read******************************************************************		EXPORT	~GetCharInput ~GetCharInput PROC		EXPORT	~ReadCharInput~ReadCharInput		;					longa on			longi onreturn   equ   13                       ;RETURN key code         phb         phk         plb         lda   ~EOFInput                ;check for read at EOF         beq   lb0;;       error #3                       ;(read while at end of file);;       ph2   #3	;          PEA   3         jsl   SystemError         stz   ~EOFInputlb0      jsl   SysKeyin                 ;get a character         and   #$00FF         stz   ~EOLNInput               ;eoln(input) := false         cmp   #return                  ;if its a return then         bne   lb1                      ;  eoln(input) := true         inc   ~EOLNInput         lda   #' '                     ;  return a spacelb1      cmp   #0                       ;if its a null then         bne   lb2                      ;  eof(input) := true         inc   ~EOFInput         inc   ~EOLNInput         lda   #' '                     ;  return a space;;lb2    short M                        ;return the charlb2      SEP   #1*32+0*16			LONGA OFF         sta   ~InputChar;;       long  M         REP   #1*32+0*16			LONGA ON         plb         rtl		ENDP******************************************************************  ~GetSBuffer - allocate a string buffer**  Inputs:*        a,x - number of bytes to allocate**  Outputs:*        a,x - pointer to buffer*        ~StringList - buffer is added to string list******************************************************************		EXPORT	~GetSBuffer ~GetSBuffer PROC			longa on			longi onr0       equ   0                        ;save 0 page pointer         phb                            ;set data bank reg         phk         plb         clc                            ;add the node pointer         adc   #4         bcc   gs1         inxgs1      phx                            ;get a buffer         pha         jsl   ~New         sta   buff         stx   buff+2         ora   buff+2         beq   err;;       ph4   r0                       ;save 0 page	;          LDA   r0+2         PHA         LDA   r0         PHA;;       move4 buff,r0                  ;insert the buffer into the list;;       ~SETM	;          LDA   2+buff         STA   2+r0         LDA   buff         STA   r0;;       ~RESTM	;          lda   ~StringList         sta   [r0]         ldy   #2         lda   ~StringList+2         sta   [r0],y;;       move4 buff,~StringList;;       ~SETM	;          LDA   2+buff         STA   2+~StringList         LDA   buff         STA   ~StringList;;       ~RESTM	; ;;       add4  buff,#4                  ;adjust buffer pointer past node;;       ~SETM	;          CLC;;       ~LDA  buff         LDA   buff;;       ~OP   ADC,#4         ADC   #4;;       ~STA  buff         STA   buff         BCC   ~9;;       ~OP.H INC,buff	;          INC   2+buff~9	; ;;       ~RESTM	; ;;       pl4   r0	;          PLA         STA   r0         PLA         STA   r0+2         lda   buff                     ;return the pointer         ldx   buff+2         plb         clc         rtserr      plb                            ;restore data bank reg         sec         rtsbuff		DS.B 4                        ;buffer pointer		ENDP******************************************************************  ~GrtE - Test two SANE extended numbers for A > B**  Inputs:*        n1,n2: numbers**  Outputs:*        A - 1 if true, else 0*        Z - 0 if true, else 1******************************************************************		EXPORT	~GrtE    ~GrtE    PROC			longa on			longi on         tsc                            ;push the addresses         pea   0         clc         adc   #14         pha         pea   0         sec         sbc   #10         pha;;       fcpxx                          ;compare the two numbers         PEA   $0A         LDX   #$090A         JSL   $E10000         lda   0,S                      ;remove the left over from the stack         sta   20,S         lda   2,S         sta   22,S         tsc         clc         adc   #20         tcs         txa                            ;set the result         and   #$0040         beq   lb1         lda   #1lb1      rtl		ENDP******************************************************************  ~LoadComp - Load a comp value**  Inputs:*        4,S - address of the comp value**  Outputs:*        extended # on stack******************************************************************		EXPORT	~LoadComp ~LoadComp PROC         tsc                            ;make room on stack         sec         sbc   #14         tcs         lda   18,S                     ;move passed address         sta   5,S         lda   20,S         sta   7,S         lda   16,S                     ;move return address         sta   10,S         lda   14,S         sta   8,S         clc                            ;set addr of extended number         tsc         adc   #12         sta   1,S         lda   #0         sta   3,S;;       fc2x                           ;convert to extended         PEA   $050E         LDX   #$090A         JSL   $E10000         rtl                            ;return		ENDP******************************************************************  ~LoadDouble - Load a double value**  Inputs:*        1,S - return address*        4,S - address of the double value**  Outputs:*        extended # on stack******************************************************************		EXPORT	~LoadDouble ~LoadDouble PROC			longa on			longi on         tsc                            ;make room on stack         sec         sbc   #14         tcs         lda   18,S                     ;move passed address         sta   5,S         lda   20,S         sta   7,S         lda   16,S                     ;move return address         sta   10,S         lda   14,S         sta   8,S         clc                            ;set addr of extended number         tsc         adc   #12         sta   1,S         lda   #0         sta   3,S;;       fd2x                           ;convert to extended         PEA   $010E         LDX   #$090A         JSL   $E10000         rtl                            ;return		ENDP******************************************************************  ~LoadExtended - Load an extended value**  Inputs:*        4,S - address of the comp value**  Outputs:*        extended # on stack******************************************************************		EXPORT	~LoadExtended ~LoadExtended PROCext      equ   10                       ;addr of extended value on stack frameaddr     equ   3                        ;ptr to extended value to load         tsc                            ;make room on stack         sec         sbc   #10         tcs         lda   14,S                     ;move passed address         sta   1,S         lda   16,S         sta   3,S         lda   11,S                     ;move return address         sta   5,S         lda   12,S         sta   6,S         phd                            ;set up addressing         tsc         tcd         ldx   #8                       ;move the valuelb1      txy         lda   [addr],Y         sta   ext,X         dex         dex         bpl   lb1         pld                            ;return         pla         pla         rtl		ENDP******************************************************************  ~LoadReal - Load a real value**  Inputs:*        4,S - address of the real value**  Outputs:*        extended # on stack******************************************************************		EXPORT	~LoadReal ~LoadReal PROC			longa on			longi on         tsc                            ;make room on stack         sec         sbc   #14         tcs         lda   18,S                     ;move passed address         sta   5,S         lda   20,S         sta   7,S         lda   16,S                     ;move return address         sta   10,S         lda   14,S         sta   8,S         clc                            ;set addr of extended number         tsc         adc   #12         sta   1,S         lda   #0         sta   3,S;;       fs2x                           ;convert to extended         PEA   $020E         LDX   #$090A         JSL   $E10000         rtl                            ;return		ENDP******************************************************************  ~LogE - Natural log function**  Inputs:*        1,S - return address*        4,S: number******************************************************************		EXPORT	~LogE    ~LogE    PROC			longa on			longi on         tsc                            ;push the addresse twice         pea   0         clc         adc   #4         pha;;       flnx                           ;compute function         PEA   0         LDX   #$0B0A         JSL   $E10000         rtl		ENDP******************************************************************  ~MulE - Multiply two SANE extended numbers**  Inputs:*        n1,n2: numbers******************************************************************		EXPORT	~MulE    ~MulE    PROC			longa on			longi on         tsc                            ;push the addresses         pea   0         clc         adc   #4         pha         pea   0         adc   #10         pha;;       fmulx                          ;multiply the two numbers         PEA   4         LDX   #$090A         JSL   $E10000         lda   0,S                      ;remove the left over from the stack         sta   10,S         lda   2,S         sta   12,S         tsc         clc         adc   #10         tcs         rtl		ENDP******************************************************************  ~Power - Raise one number to the power of another**  Inputs:*        n1,n2: numbers******************************************************************		EXPORT	~Power   ~Power   PROC			longa on			longi on         tsc                            ;push the addresses         pea   0         clc         adc   #4         pha         pea   0         adc   #10         pha;;       fxpwry                         ;do the operation         PEA   $12         LDX   #$0B0A         JSL   $E10000         lda   0,S                      ;remove the left over from the stack         sta   10,S         lda   2,S         sta   12,S         tsc         clc         adc   #10         tcs         rtl		ENDP******************************************************************  ~PutCharInput - Put back a character, checking for EOL**  Inputs:*        A - character to put back*        ~EOLNInput - EOLN flag******************************************************************		EXPORT	~PutCharInput ~PutCharInput PROCreturn   equ   13                       ;RETURN key code         tax         lda   >~EOLNInput         beq   lb1         ldx   #return         lda   #0         sta   >~EOLNInputlb1      phx         jsl   SysPutback         rtl		ENDP******************************************************************  ~ReadReal - Read a real**  Inputs:*        filePtr - pointer to file buffer**  Outputs:*        4,S - result******************************************************************		EXPORT	~ReadReal ~ReadReal PROC			longa on			longi on	;using ~FileCom	;using ~RealComtab      equ   9                        ;TAB key codefilePtr  equ   7                        ;file pointer/result pointer         phb         phk         plb         phd         tsc         tcd;;       sub4  filePtr,#~flHeader       ;point to file variable, not buffer;;       ~SETM	;          SEC;;       ~LDA  filePtr         LDA   filePtr;;       ~OP   SBC,#~flHeader         SBC   #~flHeader;;       ~STA  filePtr         STA   filePtr         BCS   ~2;;       ~OP.H DEC,filePtr	;          DEC   2+filePtr~2	; ;;       ~RESTM	;          ldy   #~flHeader               ;skip leading white space         lda   [filePtr],Y         and   #$00FFlb1      cmp   #tab         beq   lb2         cmp   #' '         bne   lb3lb2      jsr   NextCh         bra   lb1lb3      stz   pasString                ;read the leading sign, if any         cmp   #'+'         beq   lb3a         cmp   #'-'         bne   lb4         sta   pasString+1         inc   pasStringlb3a     jsr   NextChlb4      jsr   NMID                     ;read the leading digits         bcc   lb6         jsr   WriteCh;;       jcs   err1         BCC   *+5         BRL   err1         jsr   NextCh         bra   lb4lb6      cmp   #'.'                     ;allow for the decimal point         bne   lb8         jsr   WriteCh;;       jcs   err1         BCC   *+5         BRL   err1         jsr   NextChlb7      jsr   NMID                     ;read the decimal digits         bcc   lb8         jsr   WriteCh;;       jcs   err1         BCC   *+5         BRL   err1         jsr   NextCh         bra   lb7lb8      cmp   #'e'                     ;allow for an exponent         beq   lb9         cmp   #'E'         bne   cv1lb9      jsr   WriteCh;;       jcs   err1         BCC   *+5         BRL   err1         jsr   NextCh         cmp   #'-'                     ;allow for a sign on the exponent         beq   lb10         cmp   #'+'         bne   lb12lb10     jsr   WriteCh         bcs   err1         jsr   NextChlb12     jsr   NMID                     ;read the exponent digits         bcc   cv1         jsr   WriteCh         bcs   err1         jsr   NextCh         bra   lb12;;  Convert the string into a number;;;cv1    ph4   #pasString+1             ;        lvp^.rval := cnvsr(digit);cv1	;          PEA   +(pasString+1)>>16         PEA   pasString+1;;       ph4   #index                   ;        {convert from ascii to decform}	;          PEA   +(index)>>16         PEA   index;;       ph4   #decrec	;          PEA   +(decrec)>>16         PEA   decrec;;       ph4   #valid	;          PEA   +(valid)>>16         PEA   valid         stz   index;;       fcstr2dec         PEA   2         LDX   #$0A0A         JSL   $E10000         lda   valid                    ;        {flag an error if SANE said to}         beq   err1         lda   pasString         and   #$00FF         cmp   index         bne   err1;;       ph4   #decrec                  ;        {convert decform to real}	;          PEA   +(decrec)>>16         PEA   decrec;;       ph4   #t1	;          PEA   +(t1)>>16         PEA   t1;;       fdec2x         PEA   $09         LDX   #$090A         JSL   $E10000         bcc   rts;;err1   error #10                      ;real math error;;err1   ph2   #10err1	;          PEA   10         jsl   SystemErrorrts      pld                            ;return the result         plx         ply         pla         pla         lda   t1+8         pha         lda   t1+6         pha         lda   t1+4         pha         lda   t1+2         pha         lda   t1         pha         phy         phx         plb         rtl;;  Read the next character from the input file;NextCh   ldy   #~flEOF         lda   [filePtr],Y         beq   nc1         lda   #' '         rts;;nc1    ph4   filePtrnc1	;          LDA   filePtr+2         PHA         LDA   filePtr         PHA         jsl   ~GetBuffer         ldy   #~flHeader         lda   [filePtr],Y         and   #$00FF         rts;;  Save a character in the output buffer - return C set if overflow;WriteCh  pha         inc   pasString         lda   pasString         and   #$00FF         tax         pla         sta   pasString,X         cpx   #pasStringLen-1         rts;;  Return C set if the character is a number;NMID     cmp   #'0'         blt   no         cmp   #'9'+1         bge   no         sec         rtsno       clc         rts		ENDP******************************************************************  ~ReadRealInput - Read a real from standard in**  Outputs:*        4,S - result******************************************************************		EXPORT	~ReadRealInput ~ReadRealInput PROC			longa on			longi on	;using ~FileCom	;using ~RealComtab      equ   9                        ;TAB key code         phb         phk         plblb1      jsl   ~GetCharInput            ;skip leading white space         cmp   #tab         beq   lb1         cmp   #' '         beq   lb1         stz   pasString                ;read the leading sign, if any         cmp   #'+'         beq   lb3a         cmp   #'-'         bne   lb4         sta   pasString+1         inc   pasStringlb3a     jsl   ~GetCharInputlb4      jsr   NMID                     ;read the leading digits         bcc   lb6         jsr   WriteCh;;       jcs   err1         BCC   *+5         BRL   err1         jsl   ~GetCharInput         bra   lb4lb6      cmp   #'.'                     ;allow for the decimal point         bne   lb8         jsr   WriteCh;;       jcs   err1         BCC   *+5         BRL   err1         jsl   ~GetCharInputlb7      jsr   NMID                     ;read the decimal digits         bcc   lb8         jsr   WriteCh;;       jcs   err1         BCC   *+5         BRL   err1         jsl   ~GetCharInput         bra   lb7lb8      cmp   #'e'                     ;allow for an exponent         beq   lb9         cmp   #'E'         bne   cv1lb9      jsr   WriteCh;;       jcs   err1         BCC   *+5         BRL   err1         jsl   ~GetCharInput         cmp   #'-'                     ;allow for a sign on the exponent         beq   lb10         cmp   #'+'         bne   lb12lb10     jsr   WriteCh;;       jcs   err1         BCC   *+5         BRL   err1         jsl   ~GetCharInputlb12     jsr   NMID                     ;read the exponent digits         bcc   cv1         jsr   WriteCh         bcs   err1         jsl   ~GetCharInput         bra   lb12;;  Convert the string into a number;cv1      jsl   ~PutCharInput;;       ph4   #pasString+1             ;        lvp^.rval := cnvsr(digit);	;          PEA   +(pasString+1)>>16         PEA   pasString+1;;       ph4   #index                   ;        {convert from ascii to decform}	;          PEA   +(index)>>16         PEA   index;;       ph4   #decrec	;          PEA   +(decrec)>>16         PEA   decrec;;       ph4   #valid	;          PEA   +(valid)>>16         PEA   valid         stz   index;;       fcstr2dec         PEA   2         LDX   #$0A0A         JSL   $E10000         lda   valid                    ;        {flag an error if SANE said to}         beq   err1         lda   pasString         and   #$00FF         cmp   index         bne   err1;;       ph4   #decrec                  ;        {convert decform to real}	;          PEA   +(decrec)>>16         PEA   decrec;;       ph4   #t1	;          PEA   +(t1)>>16         PEA   t1;;       fdec2x         PEA   $09         LDX   #$090A         JSL   $E10000         bcc   rts;;err1   error #10                      ;real math error;;err1   ph2   #10err1	;          PEA   10         jsl   SystemErrorrts      plx         ply         lda   t1+8         pha         lda   t1+6         pha         lda   t1+4         pha         lda   t1+2         pha         lda   t1         pha         phy         phx         plb         rtl;;  Save a character in the output buffer - return C set if overflow;WriteCh  pha         inc   pasString         lda   pasString         and   #$00FF         tax         pla         sta   pasString,X         cpx   #pasStringLen-1         rts;;  Return C set if the character is a number;NMID     cmp   #'0'         blt   no         cmp   #'9'+1         bge   no         sec         rtsno       clc         rts		ENDP******************************************************************  ~RealFix - Convert a parameter from extended to real**  Inputs:*        rval - disp in stack frame of real value******************************************************************		EXPORT	~RealFix ~RealFix PROC			longa on			longi onrval     equ   4         tdc                            ;push address of real value         clc         adc   rval,S         pea   0         pha         pea   0         pha;;       fx2s                           ;convert from extended         PEA   $0210         LDX   #$090A         JSL   $E10000         lda   2,S                      ;fix return addr         sta   4,S         pla         sta   1,S         rtl		ENDP******************************************************************  ~RealRet - Save a real function return value in ~RealVal**  Inputs:*        rval - real value to save**  Outputs:*        X-Y - address of ~RealVal******************************************************************		EXPORT	~RealRet ~RealRet PROC			longa on			longi onlcAfterMarkStack equ 22                 ;size of default part of stack frame         pea   0                        ;push address of real value         tdc         clc         adc   #lcAfterMarkStack         pha;;       ph4   #~RealVal                ;push address of extended value	;          PEA   +(~RealVal)>>16         PEA   ~RealVal;;       fs2x                           ;convert to extended         PEA   $020E         LDX   #$090A         JSL   $E10000         ldx   #^~RealVal               ;load address of result         ldy   #~RealVal         rtl                            ;return		ENDP******************************************************************  ~RealRet2 - Save a real function return value in ~RealVal**  Inputs:*        rval - real value to save**  Outputs:*        X-Y - address of ~RealVal**  Notes: Pascal 2.0 version******************************************************************		EXPORT	~RealRet2 ~RealRet2 PROC         lda   1,S                      ;swap address of value         tax                            ; and return address         lda   2,S         tay         lda   4,S         sta   1,S         lda   6,S         sta   3,S         tya         sta   6,S         txa         sta   5,S;;       ph4   #~RealVal                ;push address of extended value	;          PEA   +(~RealVal)>>16         PEA   ~RealVal;;       fs2x                           ;convert to extended         PEA   $020E         LDX   #$090A         JSL   $E10000         ldx   #^~RealVal               ;load address of result         ldy   #~RealVal         rtl                            ;return		ENDP******************************************************************  ~RandomE - Return a random sane extended format number**  Outputs:*        extended random real on stack******************************************************************		EXPORT	~RandomE ~RandomE PROC			longa on			longi onmantisa  equ   4exponent equ   12         phb                            ;get return address         plx         ply         pea   $3FFE                    ;set up exponent         lda   #0         pha                            ;make room for mantisa         pha         pha         pha         phy                            ;set the return address         phx         plb         tsc                            ;get the stack pointer         phd                            ;save direct page         tcd                            ;set direct page         jsl   ~ranx                    ;get the random mantisa         lda   >~seed         sta   mantisa         lda   >~seed+2         sta   mantisa+2         lda   >~seed+4         sta   mantisa+4         lda   >~seed+6         sta   mantisa+6         ora   mantisa+4                ;if mantisa = 0         ora   mantisa+2         ora   mantisa         beq   re2re1      lda   mantisa+6                ;  while msb of mantisa <> 1         bmi   re3         dec   exponent                 ;    exponent = exponent - 1         asl   mantisa                  ;    mantisa = mantisa << 1         rol   mantisa+2         rol   mantisa+4         rol   mantisa+6         bra   re1re2      stz   exponent                 ;else exponent = 0         bra   rtsre3      lda   >~seed+8                 ;set the sign         and   #$8000         ora   exponent         sta   exponentrts      pld         rtl		ENDP******************************************************************  ~RealCom - Real common area*******************************************************************~RealCom privdata~RealCom		PROC			ENTRY	decFormdecForm	; ;decForm record		ENTRY	stylestyle		DS.B 2                        ;0 -> exponential; 1 -> fixed		ENTRY	digitsdigits		DS.B 2                        ;significant digits; decimal digits		ENTRY	decRecdecRec	; ;decimal record		ENTRY	sgnsgn		DS.B 2                        ;sign		ENTRY	expexp		DS.B 2                        ;exponent		ENTRY	sigsig		DS.B 29                       ;significant digits		ENTRY	pasStringpasString	DS.B    pasStringLen          ;printable string		ENTRY	indexindex		DS.B 2                        ;index for number conversions		ENTRY	validvalid		DS.B 2                        ;valid flag for SANE scanner		ENTRY	oneone	DC.B	$00,$00,$00,$00,$00,$00,$00,$80,$FF,$3F	;SANE extended 1		ENTRY	pipi	DC.B	$35,$C2,$68,$21,$A2,$DA,$0F,$C9,$00,$40	;pi/2		ENTRY	piover2piover2	DC.B	$35,$C2,$68,$21,$A2,$DA,$0F,$C9,$FF,$3F	;pi/2		ENTRY	t1t1		DS.B 10                       ;temporary numbers		ENTRY	t2t2		DS.B 10		ENDP******************************************************************  ~RealFn - place the return value from a real function on the stack*  ~DoubleFn - place the return value from a double function on the stack**  Inputs:*        X-A - pointer to function value******************************************************************		EXPORT	~RealFn  ~RealFn  PROC		EXPORT	~DoubleFn~DoubleFn		;					longa on			longi on         phb                            ;use local addressing         phk         plb         stz   lb1+2                    ;save the source address         sta   lb1+1         txa         xba         ora   lb1+2         sta   lb1+2         plx                            ;save return address         ply         tsc                            ;make room for value         sec         sbc   #10         tcs         phy                            ;fix return address         phx         plb         clc                            ;set up the store addr         tsc         adc   #4         sta   >lb2+1         ldx   #8                       ;move the valuelb1      lda   >0,Xlb2      sta   >0,X         dex         dex         bpl   lb1         rtl		ENDP******************************************************************  ~Round - round and convert a real to ;an integer**  Inputs:*        extended real on stack**  Outputs:*        A - integer******************************************************************		EXPORT	~Round   ~Round   PROC			longa on			longi on         tsc                            ;push address of real 2 times         clc         adc   #4         pea   0         pha         pea   0         pha         pea   0                        ;push address of integer         pha;;       frintx                         ;round         PEA   $14         LDX   #$090A         JSL   $E10000;;       fx2i                           ;convert         PEA   $0410         LDX   #$090A         JSL   $E10000         phb                            ;move return address         pla         sta   9,S         pla         sta   9,S         pla                            ;remove integer         plx                            ;fix stack         plx         plb         tax                            ;set condition codes         rtl                            ;return		ENDP******************************************************************  ~Round4 - round and convert a real to a long**  Inputs:*        extended real on stack**  Outputs:*        X,A - integer******************************************************************		EXPORT	~Round4  ~Round4  PROC			longa on			longi on         tsc                            ;push address of real 2 times         clc         adc   #4         pea   0         pha         pea   0         pha         pea   0                        ;push address of integer         pha;;       frintx                         ;round         PEA   $14         LDX   #$090A         JSL   $E10000;;       fx2l                           ;convert         PEA   $0310         LDX   #$090A         JSL   $E10000         phb                            ;move return address         pla         sta   9,S         pla         sta   9,S         pla                            ;remove integer         plx         ply                            ;fix stack         plb         tay                            ;set condition codes         bne   lb1         txylb1      rtl                            ;return		ENDP******************************************************************  ~SaveComp - Save a comp value**  Inputs:*        1,S - return address*        4,S - address to save to*        8,S - extended real value******************************************************************		EXPORT	~SaveComp ~SaveComp PROC;;       csubroutine (4:addr,10:ext),0	; addr     equ   0+4+0ext      equ   4+4+0         tsc         phd         tcd;;       ph2   #0                       ;push addr of extended #	;          PEA   0         clc         tdc         adc   #ext         pha;;       ph4   addr                     ;push addr of real value	;          LDA   addr+2         PHA         LDA   addr         PHA;;       fx2c                           ;convert and move         PEA   $0510         LDX   #$090A         JSL   $E10000;;       creturn	;          lda   0+2         sta   0+14+2         lda   0+1         sta   0+14+1         pld         tsc         clc         adc   #0+14         tcs         rtl		ENDP******************************************************************  ~SaveDouble - Save a double value**  Inputs:*        1,S - return address*        4,S - address to save to*        8,S - extended real value******************************************************************		EXPORT	~SaveDouble ~SaveDouble PROC			longa on			longi on;;       sub   (4:addr,10:ext),0	; addr     EQU   3ext      EQU   7         TDC         TAX         TSC         SEC         SBC   #0-1         TCD         DEC   A         TCS         PHX;;       ph2   #0                       ;push addr of extended #	;          PEA   0         clc         tdc         adc   #ext         pha;;       ph4   addr                     ;push addr of real value	;          LDA   addr+2         PHA         LDA   addr         PHA;;       fx2d                           ;convert and move         PEA   $0110         LDX   #$090A         JSL   $E10000;;       return         LDA   0+1         STA   17-2         LDA   0         STA   17-3         CLC         TDC         ADC   #17-4         PLD         TCS         RTL		ENDP******************************************************************  ~SaveExtended - Save an extended value**  Inputs:*        1,S - return address*        4,S - address to save to*        8,S - extended real value******************************************************************		EXPORT	~SaveExtended ~SaveExtended PROC;;       csubroutine (4:addr,10:ext),0	; addr     equ   0+4+0ext      equ   4+4+0         tsc         phd         tcd         ldx   #8                       ;move the valuelb1      txy         lda   ext,X         sta   [addr],Y         dex         dex         bpl   lb1;;       creturn	;          lda   0+2         sta   0+14+2         lda   0+1         sta   0+14+1         pld         tsc         clc         adc   #0+14         tcs         rtl		ENDP******************************************************************  ~SaveReal - Save a real value**  Inputs:*        1,S - return address*        4,S - address to save to*        8,S - extended real value******************************************************************		EXPORT	~SaveReal ~SaveReal PROC			longa on			longi on;;       sub   (4:addr,10:ext),0	; addr     EQU   3ext      EQU   7         TDC         TAX         TSC         SEC         SBC   #0-1         TCD         DEC   A         TCS         PHX;;       ph2   #0                       ;push addr of extended #	;          PEA   0         clc         tdc         adc   #ext         pha;;       ph4   addr                     ;push addr of real value	;          LDA   addr+2         PHA         LDA   addr         PHA;;       fx2s                           ;convert and move         PEA   $0210         LDX   #$090A         JSL   $E10000;;       return         LDA   0+1         STA   17-2         LDA   0         STA   17-3         CLC         TDC         ADC   #17-4         PLD         TCS         RTL		ENDP******************************************************************  ~SinE - Sin function**  Inputs:*        1,S - return address*        4,S - number******************************************************************		EXPORT	~SinE    ~SinE    PROC			longa on			longi on         tsc                            ;push the addresse twice         pea   0         clc         adc   #4         pha;;       fsinx                          ;compute function         PEA   $1A         LDX   #$0B0A         JSL   $E10000         rtl		ENDP******************************************************************  ~SqrE - Square a SANE extended number**  Inputs:*        1,S - return address*        4,S - number******************************************************************		EXPORT	~SqrE    ~SqrE    PROC			longa on			longi on         tsc                            ;push the addresse twice         pea   0         clc         adc   #4         pha         pea   0         pha;;       fmulx                          ;multiply         PEA   4         LDX   #$090A         JSL   $E10000         rtl		ENDP******************************************************************  ~SqtE - Square root function**  Inputs:*        1,S - return address*        4,S - number******************************************************************		EXPORT	~SqtE    ~SqtE    PROC			longa on			longi on         tsc                            ;push the addresse twice         pea   0         clc         adc   #4         pha;;       fsqrtx                         ;compute function         PEA   $12         LDX   #$090A         JSL   $E10000         rtl		ENDP******************************************************************  StringToStandard - Convert a string to standard form**  'Standard form' means the pointer points to the first char*  of the string, and the length is the ;current length.  See*  also ~StringToMaxStandard.**  Inputs:*        addr - address of string*        len - length of string**  Outputs:*        addr - ptr to first char*        len - current length of string******************************************************************		EXPORT	~StringToStandard ~StringToStandard PROCaddr     equ   7                        ;string addresslen      equ   5                        ;string length         phd                            ;set up local DP         tsc         tcd         lda   len                      ;if length < 0 then         beq   lb5         bpl   lb2         inc   a                        ;  if length = -1 then         bne   lb1         lda   addr+2                   ;    if char = 0 then         and   #$00FF                   ;      {string is a null character}         bne   lb0         stz   len                      ;      len := 0         bra   lb5                      ;    endiflb0      lda   #1                       ;    len := 1         sta   len                      ;    {string is a single character}         lda   addr+2         sta   >char;;       lla   addr,char	;          LDA   #char         STA   addr         LDA   #^char         STA   2+addr         bra   lb5                      ;    endif*                                       ;  endif*                                       ;  {string has a length byte}lb1      lda   [addr]                   ;  len := addr^         and   #$00FF         sta   len;;       inc4  addr                     ;  ++addr {skip length byte};;       ~SETM	;          INC   addr         BNE   ~3         INC   2+addr;;~3     ~RESTM~3	;          bra   lb5                      ;else*                                       ;  {string is a nul terminated string}lb2      ldx   len                      ;  scan string for nul to find length         ldy   #0;;       short M         SEP   #1*32+0*16			LONGA OFFlb3      lda   [addr],Y         beq   lb4         iny         dex         bne   lb3lb4      sty   len;;       long  M                        ;endif         REP   #1*32+0*16			LONGA ONlb5      pld         rtschar		DS.B 2                        ;value of a character string		ENDP******************************************************************  ~SubE - Subtract two SANE extended numbers**  Inputs:*        n1,n2: numbers******************************************************************		EXPORT	~SubE    ~SubE    PROC			longa on			longi on         tsc                            ;push the addresses         pea   0         clc         adc   #4         pha         pea   0         adc   #10         pha;;       fsubx                          ;subtract the two numbers         PEA   2         LDX   #$090A         JSL   $E10000         lda   0,S                      ;remove the left over from the stack         sta   10,S         lda   2,S         sta   12,S         tsc         clc         adc   #10         tcs         rtl		ENDP******************************************************************  ~TanE - Tan function**  Inputs:*        1,S - return address*        4,S - number******************************************************************		EXPORT	~TanE    ~TanE    PROC			longa on			longi on         tsc                            ;push the addresse twice         pea   0         clc         adc   #4         pha;;       ftanx                          ;compute function         PEA   $1E         LDX   #$0B0A         JSL   $E10000         rtl		ENDP******************************************************************  ~WriteReal - Write a real value to a ;file**  Inputs:*        ext - extended format real number*        fw - field width*        decDig - fixed precision digit ;count*        filePtr - pointer to the file buffer******************************************************************		EXPORT	~WriteReal ~WriteReal PROC			longa on			longi on	;using ~RealComfPtr     equ   3                        ;file pointer for use by ~_COutlen      equ   0                        ;length of the stringdisp     equ   7                        ;displacement into the string;;       sub   (4:filePtr,2:decDig,2:fw,10:ext),9	; filePtr  EQU   12decDig   EQU   16fw       EQU   18ext      EQU   20         TDC         TAX         TSC         SEC         SBC   #9-1         TCD         DEC   A         TCS         PHX         phb         phk         plb;;       move4 filePtr,fPtr             ;set up file pointer for ~_COut;;       ~SETM	;          LDA   2+filePtr         STA   2+fPtr         LDA   filePtr         STA   fPtr;;       ~RESTM	;          ldx   #12                      ;format the numberlb1      lda   decDig,X         pha         dex         dex         bpl   lb1         jsl   ~FormatReal         lda   pasString                ;write the string         and   #$00FF         sta   len         lda   #1         sta   displb5      ldx   disp         lda   pasString,X         jsl   ~_COut         inc   disp;;       dbne  len,lb5         DEC   len         BNE   lb5         plb;;       return         LDA   9+1         STA   30-2         LDA   9         STA   30-3         CLC         TDC         ADC   #30-4         PLD         TCS         RTL		ENDP******************************************************************  ~WriteRealEO - Write a real value to ;error out**  Inputs:*        ext - extended format real number*        fw - field width*        decDig - fixed precision digit ;count******************************************************************		EXPORT	~WriteRealEO ~WriteRealEO PROC			longa on			longi on	;using ~RealCom;;       sub   (2:decDig,2:fw,10:ext),0	; decDig   EQU   3fw       EQU   5ext      EQU   7         TDC         TAX         TSC         SEC         SBC   #0-1         TCD         DEC   A         TCS         PHX         phb         phk         plb         ldx   #12                      ;format the numberlb1      lda   decDig,X         pha         dex         dex         bpl   lb1         jsl   ~FormatReal;;       ph4   #pasString-1             ;write the string	;          PEA   +(pasString-1)>>16         PEA   pasString-1;;       ph2   #1	;          PEA   1;;       ph2   #0	;          PEA   0;;       ph2   #1	;          PEA   1         jsl   ~Puts         plb;;       return         LDA   0+1         STA   17-2         LDA   0         STA   17-3         CLC         TDC         ADC   #17-4         PLD         TCS         RTL		ENDP******************************************************************  ~WriteRealOutput - Write a real value to standard out**  Inputs:*        ext - extended format real number*        fw - field width*        decDig - fixed precision digit ;count******************************************************************		EXPORT	~WriteRealOutput ~WriteRealOutput PROC			longa on			longi on	;using ~RealCom;;       sub   (2:decDig,2:fw,10:ext),0	; decDig   EQU   3fw       EQU   5ext      EQU   7         TDC         TAX         TSC         SEC         SBC   #0-1         TCD         DEC   A         TCS         PHX         phb         phk         plb         ldx   #12                      ;format the numberlb1      lda   decDig,X         pha         dex         dex         bpl   lb1         jsl   ~FormatReal;;       ph4   #pasString-1             ;write the string	;          PEA   +(pasString-1)>>16         PEA   pasString-1;;       ph2   #1	;          PEA   1;;       ph2   #0	;          PEA   0;;       ph2   #0	;          PEA   0         jsl   ~Puts         plb;;       return         LDA   0+1         STA   17-2         LDA   0         STA   17-3         CLC         TDC         ADC   #17-4         PLD         TCS         RTL		ENDP		END