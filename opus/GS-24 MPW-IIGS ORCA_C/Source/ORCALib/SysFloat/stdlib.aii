	case  on	seg   ''******************************************************************  StdDef - Standard Definitions**  This code implements the tables and subroutines needed to*  support the standard C library stdlib.**  This porition of the library contains subroutines that are*  dependent on the way floating-point calculations are*  performed.  The main portion of the library is in ORCACLib.**  December 1988*  Mike Westerfield**  Copyright 1988*  Byte Works, Inc.******************************************************************;-----------------------------------------------;;   Imported addresses;;-----------------------------------------------	IMPORT	errno;-----------------------------------------------;;   Forward addresses and entries;;-----------------------------------------------	ENTRY	decrec	ENTRY	huge_val	ENTRY	index	ENTRY	t1	ENTRY	valid	ENTRY	zero;        copy  equates.asm******************************************************************  This file contains constant values defined in the C interfaces*  that are also used in the assembly language portion of the*  libraries.*****************************************************************;;  error numbers;EDOM     equ   1                        ;domain errorERANGE   equ   2                        ;# too large, too small, or illegalENOMEM   equ   3                        ;Not enough memoryENOENT   equ   4                        ;No such file or directoryEIO      equ   5                        ;I/O errorEINVAL   equ   6                        ;Invalid argumentEBADF    equ   7                        ;bad file descriptorEMFILE   equ   8                        ;too many files are openEACCES   equ   9                        ;access bits prevent the operationEEXIST   equ   10                       ;the file existsENOSPC   equ   11                       ;the file is too large;;  masks for the __ctype array;_digit   equ   $01                      ;['0'..'9']_upper   equ   $02                      ;['A'..'Z']_lower   equ   $04                      ;['a'..'z']_control equ   $08                      ;[chr(0)..chr(31),chr(127)]_punctuation equ  $10                   ;[' ','!'..'/',':'..'@','['..'`','{'..'~']_space   equ   $20                      ;[chr(9)..chr(13),' ']_hex     equ   $40                      ;['0'..'9','a'..'f','A'..'F']_print   equ   $80                      ;[' '..'~'];;  masks for the __ctype2 array;_csym    equ   $01                      ;['0'..'9','A'..'Z','a'..'z','_']_csymf   equ   $02                      ;['A'..'Z','a'..'z'.'_']_octal   equ   $04                      ;['0'..'7'];;  signal numbers;SIGABRT  equ   1SIGFPE   equ   2SIGILL   equ   3SIGINT   equ   4SIGSEGV  equ   5SIGTERM  equ   6;;  The FILE record;*                                       ;flags*                                       ;-----_IOFBF   equ   $0001                    ;full buffering_IONBF   equ   $0002                    ;no buffering_IOLBF   equ   $0004                    ;flush when a \n is written_IOREAD  equ   $0008                    ;currently reading_IOWRT   equ   $0010                    ;currently writing_IORW    equ   $0020                    ;read/write enabled_IOMYBUF equ   $0040                    ;buffer was allocated by stdio_IOEOF   equ   $0080                    ;has an EOF been found?_IOERR   equ   $0100                    ;has an error occurred?_IOTEXT  equ   $0200                    ;is this file a text file?_IOTEMPFILE equ  $0400                  ;was this file created by tmpfile()?*                                       ;record structure*                                       ;----------------FILE_next equ  0                        ;disp to next pointer (must stay 0!)FILE_ptr  equ  FILE_next+4              ;next location to write toFILE_base equ  FILE_ptr+4               ;first byte of the bufferFILE_end  equ  FILE_base+4              ;end of the file bufferFILE_size equ  FILE_end+4               ;size of the file bufferFILE_cnt  equ  FILE_size+4              ;# chars that can be read/writen to bufferFILE_pbk  equ  FILE_cnt+4               ;put back characterFILE_flag equ  FILE_pbk+2               ;buffer flagsFILE_file equ  FILE_flag+2              ;GS/OS file IDsizeofFILE equ  FILE_file+2             ;size of the recordBUFSIZ   equ   1024                     ;default file buffer size_LBUFSIZ equ   255                      ;line buffer sizeL_tmpnam equ   9                        ;size of a temp nameTMP_MAX  equ   10000                    ;# of uniq temp names;;  Seek codes for fseek;SEEK_CNT equ   0                        ;seek from start of fileSEEK_CUR equ   1                        ;seek from current positionSEEK_END equ   2                        ;seek from end of file;;  Values for fcntl.h;OPEN_MAX equ   30                       ;files in the file arrayF_DUPFD  equ   1                        ;dup file flag (fcntl)O_RDONLY equ   $0001                    ;file is read onlyO_WRONLY equ   $0002                    ;file is write onlyO_RDWR   equ   $0004                    ;file is read/writeO_NDELAY equ   $0008                    ;not usedO_APPEND equ   $0010                    ;append to file on all writesO_CREAT  equ   $0020                    ;create a new file if neededO_TRUNC  equ   $0040                    ;erase old fileO_EXCL   equ   $0080                    ;don't create a new fileO_BINARY equ   $0100                    ;file is binary;;  Misc.;EOF      equ   -1                       ;end of file characterstdinID  equ   -1                       ;standard in file IDstdoutID equ   -2                       ;standard out file IDstderrID equ   -3                       ;error out file ID******************************************************************  strtod - convert string to extended sane**  Inputs:*        str - pointer to the string*        ptr - pointer to a pointer; a pointer to the first*              char past the number is placed here.  If ptr is*              nil, no pointer is returned**  Outputs:*        X-A - pointer to result string******************************************************************		EXPORT	strtod   strtod   PROC	;using ~stdglobalsptr      equ   8                        ;*return pointerstr      equ   4                        ;string pointerrtl      equ   1                        ;return address         tsc                            ;set up direct page addressing         phd         tcd         phb                            ;use our data bank         phk         plb;;       ph4   str                      ;lvp^.rval := cnvsr(digit);	;          LDA   str+2         PHA         LDA   str         PHA;;       ph4   #index                   ;{convert from ascii to decform}	;          PEA   +(index)>>16         PEA   index;;       ph4   #decrec	;          PEA   +(decrec)>>16         PEA   decrec;;       ph4   #valid	;          PEA   +(valid)>>16         PEA   valid         stz   index;;       fcstr2dec         PEA   $04         LDX   #$0A0A         JSL   $E10000         lda   valid                    ;{flag an error if SANE said to}         bne   cn1         lda   index         beq   cn2;;cn1    ph4   #decrec                  ;{convert decform to real}cn1	;          PEA   +(decrec)>>16         PEA   decrec;;       ph4   #t1	;          PEA   +(t1)>>16         PEA   t1;;       fdec2x         PEA   $0009         LDX   #$090A         JSL   $E10000         ldx   #^t1                     ;set the return value         ldy   #t1         bcc   cn4                      ;branch if there was no error;;       fgetenv                        ;if overflow then         PEA   $03         LDX   #$090A         JSL   $E10000         txa         bit   #$0400         beq   cn2         ldx   #^huge_val               ;  return *huge_val         ldy   #huge_val         bra   cn3cn2      ldx   #^zero                   ;return *0.0         ldy   #zerocn3      lda   #ERANGE                  ;errno = ERANGE         sta   >errno         stz   index                    ;index = 0cn4      lda   ptr                      ;if ptr != NULL then         ora   ptr+2         beq   cn5         phy                            ;  *ptr = str+index         ldy   #2         clc         lda   index         adc   str         sta   [ptr]         lda   str+2         adc   #0         sta   [ptr],Y         plycn5      lda   rtl+1                    ; fix the stack & registers         sta   ptr+2         lda   rtl         sta   ptr+1         plb         pld         tsc         clc         adc   #8         tcs         tya                            ;set the return value         rtl                            ;return		ENDP******************************************************************  ~stdglobals - standard globals*******************************************************************~stdglobals privdata~stdglobals		PROC	;;  globals used to convert strings to real numbers;		ENTRY	decrecdecrec	; ;decimal record		ENTRY	sgnsgn		DS.B 2                        ;sign		ENTRY	expexp		DS.B 2                        ;exponent		ENTRY	sigsig		DS.B 29                       ;significant digits		ENTRY	indexindex		DS.B 2                        ;index for number conversions		ENTRY	validvalid		DS.B 2                        ;valid flag for SANE scanner;;  floating point constants;		ENTRY	zerozero	DC.X	"0.0"		ENTRY	huge_valhuge_val	DC.X	"3.4e38";;  temp work space;		ENTRY	t1t1		DS.B 10                       ;real number		ENDP		END