			case  on	seg   ''******************************************************************  Math - Math libraries for C**  This code implements the tables and subroutines needed to*  support the standard C library MATH.**  January 1989*  Mike Westerfield**  Copyright 1989*  Byte Works, Inc.******************************************************************;        copy  equates.asm;-----------------------------------------------;;   Imported addresses;;-----------------------------------------------	IMPORT	errno******************************************************************  This file contains constant values defined in the C interfaces*  that are also used in the assembly language portion of the*  libraries.*****************************************************************;;  error numbers;EDOM     equ  1                        ;domain errorERANGE   equ  2                        ;# too large, too small, or illegalENOMEM   equ  3                        ;Not enough memoryENOENT   equ  4                        ;No such file or directoryEIO      equ  5                        ;I/O errorEINVAL   equ  6                        ;Invalid argumentEBADF    equ  7                        ;bad file descriptorEMFILE   equ  8                        ;too many files are openEACCES   equ  9                        ;access bits prevent the operationEEXIST   equ  10                       ;the file existsENOSPC   equ  11                       ;the file is too large;;  masks for the __ctype array;_digit   equ  $01                      ;['0'..'9']_upper   equ  $02                      ;['A'..'Z']_lower   equ  $04                      ;['a'..'z']_control equ  $08                      ;[chr(0)..chr(31),chr(127)]_punctuation equ $10                   ;[' ','!'..'/',':'..'@','['..'`','{'..'~']_space   equ  $20                      ;[chr(9)..chr(13),' ']_hex     equ  $40                      ;['0'..'9','a'..'f','A'..'F']_print   equ  $80                      ;[' '..'~'];;  masks for the __ctype2 array;_csym    equ  $01                      ;['0'..'9','A'..'Z','a'..'z','_']_csymf   equ  $02                      ;['A'..'Z','a'..'z'.'_']_octal   equ  $04                      ;['0'..'7'];;  signal numbers;SIGABRT  equ  1SIGFPE   equ  2SIGILL   equ  3SIGINT   equ  4SIGSEGV  equ  5SIGTERM  equ  6;;  The FILE record;*                                       ;flags*                                       ;-----_IOFBF   equ  $0001                    ;full buffering_IONBF   equ  $0002                    ;no buffering_IOLBF   equ  $0004                    ;flush when a \n is written_IOREAD  equ  $0008                    ;currently reading_IOWRT   equ  $0010                    ;currently writing_IORW    equ  $0020                    ;read/write enabled_IOMYBUF equ  $0040                    ;buffer was allocated by stdio_IOEOF   equ  $0080                    ;has an EOF been found?_IOERR   equ  $0100                    ;has an error occurred?_IOTEXT  equ  $0200                    ;is this file a text file?_IOTEMPFILE equ $0400                  ;was this file created by tmpfile()?*                                       ;record structure*                                       ;----------------FILE_next equ 0                        ;disp to next pointer (must stay 0!)FILE_ptr  equ FILE_next+4              ;next location to write toFILE_base equ FILE_ptr+4               ;first byte of the bufferFILE_end  equ FILE_base+4              ;end of the file bufferFILE_size equ FILE_end+4               ;size of the file bufferFILE_cnt  equ FILE_size+4              ;# chars that can be read/writen to bufferFILE_pbk  equ FILE_cnt+4               ;put back characterFILE_flag equ FILE_pbk+2               ;buffer flagsFILE_file equ FILE_flag+2              ;GS/OS file IDsizeofFILE equ FILE_file+2             ;size of the recordBUFSIZ   equ  1024                     ;default file buffer size_LBUFSIZ equ  255                      ;line buffer sizeL_tmpnam equ  9                        ;size of a temp nameTMP_MAX  equ  10000                    ;# of uniq temp names;;  Seek codes for fseek;SEEK_CNT equ  0                        ;seek from start of fileSEEK_CUR equ  1                        ;seek from current positionSEEK_END equ  2                        ;seek from end of file;;  Values for fcntl.h;OPEN_MAX equ  30                       ;files in the file arrayF_DUPFD  equ  1                        ;dup file flag (fcntl)O_RDONLY equ  $0001                    ;file is read onlyO_WRONLY equ  $0002                    ;file is write onlyO_RDWR   equ  $0004                    ;file is read/writeO_NDELAY equ  $0008                    ;not usedO_APPEND equ  $0010                    ;append to file on all writesO_CREAT  equ  $0020                    ;create a new file if neededO_TRUNC  equ  $0040                    ;erase old fileO_EXCL   equ  $0080                    ;don't create a new fileO_BINARY equ  $0100                    ;file is binary;;  Misc.;EOF      equ  -1                       ;end of file characterstdinID  equ  -1                       ;standard in file IDstdoutID equ  -2                       ;standard out file IDstderrID equ  -3                       ;error out file ID******************************************************************  MathCommon - common work areas for the math library*******************************************************************MathCommon privdataMathCommon		PROC	;;  constants;		ENTRY	pipi	DC.B	$35,$C2,$68,$21,$A2,$DA,$0F,$C9,$00,$40		ENTRY	piover2piover2	DC.B	$35,$C2,$68,$21,$A2,$DA,$0F,$C9,$FF,$3F		ENTRY	quarterquarter	DC.B	$00,$00,$00,$00,$00,$00,$00,$80,$FD,$3F		ENTRY	halfhalf	DC.B	$00,$00,$00,$00,$00,$00,$00,$80,$FE,$3F		ENTRY	oneone	DC.B	$00,$00,$00,$00,$00,$00,$00,$80,$FF,$3F		ENTRY	twotwo	DC.B	$00,$00,$00,$00,$00,$00,$00,$80,$00,$40;;  temporary work space;		ENTRY	t1t1		DS.B 10		ENTRY	t2t2		DS.B 10		ENTRY	t3t3		DS.B 10		ENTRY	signsign		DS.B 2		ENDP******************************************************************  asin - return arcsin(x)**  Inputs:*        stack - extended number**  Outputs:*        X-A - addr of the result******************************************************************		EXPORT	asin     asin     PROC	;using MathCommon;;  Intialization;         phb                            ;place the number in a work area         plx         ply         phk         plb         pla         sta   t1         pla         sta   t1+2         pla         sta   t1+4         pla         sta   t1+6         pla         sta   t1+8         phy         phx;;  do general initialization;;;       move  one,t3,#10               ;t3 := 1.0	;          LDA   #10-1         LDX   #one         LDY   #t3         MVN   one,t3         lda   t1                       ;t2 := t1         sta   t2         lda   t1+2         sta   t2+2         lda   t1+4         sta   t2+4         lda   t1+6         sta   t2+6         lda   t1+8         sta   t2+8;;  if t2 >= 2^-33 then arcsine(t1) := atan(t1/sqrt(1-sqr(t2));  else arssine(t1) := t1;         and   #$7FFF                   ;branch if the value is less than 2^-33         cmp   #$3FDE         blt   lb3         lda   #t2                      ;t2 := sqr(t2)         ldx   #^t2         phx         pha         phx         pha;;       fmulx         PEA   $0004         LDX   #$090A         JSL   $E10000;;       ph4   #t2                      ;t3 := t3-t2	;          PEA   +(t2)>>16         PEA   t2;;       ph4   #t3	;          PEA   +(t3)>>16         PEA   t3;;       fsubx         PEA   $0002         LDX   #$090A         JSL   $E10000lb2      lda   #t3                      ;t3 := sqrt(t3)         ldx   #^t3         phx         pha         phx         pha;;       fsqrtx         PEA   $0012         LDX   #$090A         JSL   $E10000;;       ph4   #t1                      ;t1 := t1/t3	;          PEA   +(t1)>>16         PEA   t1;;       fdivx         PEA   $0006         LDX   #$090A         JSL   $E10000;;       ph4   #t1                      ;t1 := atan(t1)	;          PEA   +(t1)>>16         PEA   t1;;       fatanx         PEA   $18         LDX   #$0B0A         JSL   $E10000;;lb3    fgetenv                        ;check for a domain errorlb3      PEA   $03         LDX   #$090A         JSL   $E10000         txa         and   #$0100         beq   lb4         lda   #EDOM         sta   >errnolb4      ldx   #^t1                     ;return a pointer to the result         lda   #t1         plb         rtl		ENDP******************************************************************  acos - return arccosin(x)**  Inputs:*        stack - extended number**  Outputs:*        X-A - addr of the result******************************************************************		EXPORT	acos     acos     PROC	;using MathCommon;;  Intialization;         phb                            ;place the number in a work area         plx         ply         phk         plb         pla         sta   t1         pla         sta   t1+2         pla         sta   t1+4         pla         sta   t1+6         pla         sta   t1+8         phy         phx;;  acos(t1) := 2*atan(sqrt((1-t1)/(1+t1)));;;       move  one,t2,#10               ;t2 := 1	;          LDA   #10-1         LDX   #one         LDY   #t2         MVN   one,t2;;       ph4   #t1                      ;t2 := t2+t1	;          PEA   +(t1)>>16         PEA   t1;;       ph4   #t2	;          PEA   +(t2)>>16         PEA   t2;;       faddx         PEA   $0000         LDX   #$090A         JSL   $E10000;;       ph4   #one                     ;t1 := t1-1	;          PEA   +(one)>>16         PEA   one;;       ph4   #t1	;          PEA   +(t1)>>16         PEA   t1;;       fsubx         PEA   $0002         LDX   #$090A         JSL   $E10000         lda   t1+8                     ;t1 := -t1         eor   #$8000         sta   t1+8;;       ph4   #t2                      ;t1 := t1/t2	;          PEA   +(t2)>>16         PEA   t2;;       ph4   #t1	;          PEA   +(t1)>>16         PEA   t1;;       fdivx         PEA   $0006         LDX   #$090A         JSL   $E10000         lda   #t1                      ;t1 := sqrt(t1)         ldx   #^t1         phx         pha         phx         pha;;       fsqrtx         PEA   $0012         LDX   #$090A         JSL   $E10000;;       fatanx                         ;t1 := atan(t1)         PEA   $18         LDX   #$0B0A         JSL   $E10000;;       ph4   #two                     ;t1 := t1*2	;          PEA   +(two)>>16         PEA   two;;       ph4   #t1	;          PEA   +(t1)>>16         PEA   t1;;       fmulx         PEA   $0004         LDX   #$090A         JSL   $E10000;;       fgetenv                        ;check for a domain error         PEA   $03         LDX   #$090A         JSL   $E10000         txa         and   #$0100         beq   lb1         lda   #EDOM         sta   >errnolb1      ldx   #^t1                     ;return a pointer to the result         lda   #t1         plb         rtl		ENDP******************************************************************  atan - return arctan(x)**  Inputs:*        stack - extended number**  Outputs:*        X-A - addr of the result******************************************************************		EXPORT	atan     atan     PROC	;using MathCommon         phb                            ;place the number in a work area         plx         ply         phk         plb         pla         sta   t1         pla         sta   t1+2         pla         sta   t1+4         pla         sta   t1+6         pla         sta   t1+8         phy         phx;;       ph4   #t1                      ;compute the arc tangent	;          PEA   +(t1)>>16         PEA   t1;;       fatanx         PEA   $18         LDX   #$0B0A         JSL   $E10000         ldx   #^t1                     ;return a pointer to the result         lda   #t1         plb         rtl		ENDP******************************************************************  atan2 - return arctangent(y,x) scaled to -pi..pi**  Inputs:*        stack - extended numbers**  Outputs:*        X-A - addr of the result******************************************************************		EXPORT	atan2    atan2    PROC	;using MathCommon         phb                            ;place the numbers in the work areas         plx         ply         phk         plb         pla         sta   t1         pla         sta   t1+2         pla         sta   t1+4         pla         sta   t1+6         pla         sta   t1+8         pla         sta   t2         pla         sta   t2+2         pla         sta   t2+4         pla         sta   t2+6         pla         sta   t2+8         phy         phx;;  do special processing for x=0;         lda   t2+8                     ;branch if x <> 0         and   #$7FFF         ora   t2+6         ora   t2+4         ora   t2+2         ora   t2         bne   lb2         lda   t1+8                     ;if y = 0, report a range error         and   #$7FFF         ora   t1+6         ora   t1+4         ora   t1+2         ora   t1         bne   lb1         lda   #ERANGE         sta   >errno         brl   lb5lb1      lda   t1+8                     ;return pi/2 with the sign of t1         and   #$8000         ora   piover2+8         sta   t1+8;;       move  piover2,t1,#8	;          LDA   #8-1         LDX   #piover2         LDY   #t1         MVN   piover2,t1         bra   lb5;;  handle cases where x <> 0;lb2      lda   t2+8                     ;save the sign of t2 in sign         and   #$8000         sta   sign         lda   t2+8                     ;t2 := abs(t2)         and   #$7FFF         sta   t2+8;;       ph4   #t2                      ;t1 := t1/t2	;          PEA   +(t2)>>16         PEA   t2;;       ph4   #t1	;          PEA   +(t1)>>16         PEA   t1;;       fdivx         PEA   $0006         LDX   #$090A         JSL   $E10000;;       ph4   #t1                      ;t1 := arctan(t1)	;          PEA   +(t1)>>16         PEA   t1;;       fatanx         PEA   $18         LDX   #$0B0A         JSL   $E10000         lda   sign                     ;if t2 was less than zero then         beq   lb5;;       ph4   #pi	;          PEA   +(pi)>>16         PEA   pi;;       ph4   #t1	;          PEA   +(t1)>>16         PEA   t1         lda   t1+8                     ;  if t1 < 0 then         bpl   lb3;;       faddx                          ;    t1 := t1+pi         PEA   $0000         LDX   #$090A         JSL   $E10000         bra   lb4;;lb3    fsubx                          ;  else t1 := t1-pilb3      PEA   $0002         LDX   #$090A         JSL   $E10000lb4      lda   t1+8                     ;  t1 := -t1         eor   #$8000         sta   t1+8lb5      ldx   #^t1                     ;return a pointer to the result         lda   #t1         plb         rtl		ENDP******************************************************************  ceil - round up**  Inputs:*        stack - extended number**  Outputs:*        X-A - addr of the result******************************************************************		EXPORT	ceil     ceil     PROC	;using MathCommon         phb                            ;place the number in a work area         plx         ply         phk         plb         pla         sta   t1         pla         sta   t1+2         pla         sta   t1+4         pla         sta   t1+6         pla         sta   t1+8         phy         phx;;       fgetenv                        ;set the rounding direction to round up         PEA   $03         LDX   #$090A         JSL   $E10000         phx         txa         and   #$3FFF         ora   #$4000         pha;;       fsetenv         PEA   $01         LDX   #$090A         JSL   $E10000;;       ph4   #t1	;          PEA   +(t1)>>16         PEA   t1;;       frintx                         ;round the number         PEA   $0014         LDX   #$090A         JSL   $E10000;;       fsetenv                        ;restore the environment         PEA   $01         LDX   #$090A         JSL   $E10000         ldx   #^t1                     ;return a pointer to the result         lda   #t1         plb         rtl		ENDP******************************************************************  cos - return cos(x)**  Inputs:*        stack - extended number**  Outputs:*        X-A - addr of the result******************************************************************		EXPORT	cos      cos      PROC	;using MathCommon         phb                            ;place the number in a work area         plx         ply         phk         plb         pla         sta   t1         pla         sta   t1+2         pla         sta   t1+4         pla         sta   t1+6         pla         sta   t1+8         phy         phx;;       ph4   #t1                      ;compute the cosine	;          PEA   +(t1)>>16         PEA   t1;;       fcosx         PEA   $1C         LDX   #$0B0A         JSL   $E10000         ldx   #^t1                     ;return a pointer to the result         lda   #t1         plb         rtl		ENDP******************************************************************  cosh - return hyperbolic cosine(x)**  Inputs:*        stack - extended number**  Outputs:*        X-A - addr of the result******************************************************************		EXPORT	cosh     cosh     PROC	;using MathCommon;;  Intialization;         phb                            ;place the number in a work area         plx         ply         phk         plb         pla         sta   t1         pla         sta   t1+2         pla         sta   t1+4         pla         sta   t1+6         pla         and   #$7FFF                   ;(take the absolute value now)         sta   t1+8         phy         phx;;  cosh(t1) := (0.5*exp(abs(t1)) + 0.25/(0.5*exp(abs(t1)));;;       ph4   #t1                      ;t1 := exp(abs(t1))	;          PEA   +(t1)>>16         PEA   t1;;       fexpx         PEA   $08         LDX   #$0B0A         JSL   $E10000;;       fgetenv                        ;check for a range error         PEA   $03         LDX   #$090A         JSL   $E10000         txa         and   #$0500         beq   lb1         lda   #ERANGE         sta   >errno         bra   lb2;;lb1    ph4   #half                    ;t1 := t1*0.5lb1	;          PEA   +(half)>>16         PEA   half;;       ph4   #t1	;          PEA   +(t1)>>16         PEA   t1;;       fmulx         PEA   $0004         LDX   #$090A         JSL   $E10000;;       move  quarter,t2,#10           ;t2 := 0.25	;          LDA   #10-1         LDX   #quarter         LDY   #t2         MVN   quarter,t2;;       ph4   #t1                      ;t2 := t2/t1	;          PEA   +(t1)>>16         PEA   t1;;       ph4   #t2	;          PEA   +(t2)>>16         PEA   t2;;       fdivx         PEA   $0006         LDX   #$090A         JSL   $E10000;;       ph4   #t2                      ;t1 := t1+t2	;          PEA   +(t2)>>16         PEA   t2;;       ph4   #t1	;          PEA   +(t1)>>16         PEA   t1;;       faddx         PEA   $0000         LDX   #$090A         JSL   $E10000lb2      ldx   #^t1                     ;return a pointer to the result         lda   #t1         plb         rtl		ENDP******************************************************************  exp - return exp(x)**  Inputs:*        stack - extended number**  Outputs:*        X-A - addr of the result******************************************************************		EXPORT	exp      exp      PROC	;using MathCommon         phb                            ;place the number in a work area         plx         ply         phk         plb         pla         sta   t1         pla         sta   t1+2         pla         sta   t1+4         pla         sta   t1+6         pla         sta   t1+8         phy         phx;;       ph4   #t1                      ;compute the exponent	;          PEA   +(t1)>>16         PEA   t1;;       fexpx         PEA   $08         LDX   #$0B0A         JSL   $E10000;;       fgetenv                        ;check for a range error         PEA   $03         LDX   #$090A         JSL   $E10000         txa         and   #$0500         beq   lb1         lda   #ERANGE         sta   >errnolb1      ldx   #^t1                     ;return a pointer to the result         lda   #t1         plb         rtl		ENDP******************************************************************  fabs - absolute value of an extended ;number**  Inputs:*        stack - extended number**  Outputs:*        X-A - addr of the result******************************************************************		EXPORT	fabs     fabs     PROC	;using MathCommon         phb         plx         ply         phk         plb         pla         sta   t1         pla         sta   t1+2         pla         sta   t1+4         pla         sta   t1+6         pla         and   #$7FFF         sta   t1+8         phy         phx         plb         ldx   #^t1         lda   #t1         rtl		ENDP******************************************************************  floor - round down**  Inputs:*        stack - extended number**  Outputs:*        X-A - addr of the result******************************************************************		EXPORT	floor    floor    PROC	;using MathCommon         phb                            ;place the number in a work area         plx         ply         phk         plb         pla         sta   t1         pla         sta   t1+2         pla         sta   t1+4         pla         sta   t1+6         pla         sta   t1+8         phy         phx         plb;;       fgetenv                        ;set the rounding direction to round down         PEA   $03         LDX   #$090A         JSL   $E10000         phx         txa         and   #$3FFF         ora   #$8000         pha;;       fsetenv         PEA   $01         LDX   #$090A         JSL   $E10000;;       ph4   #t1	;          PEA   +(t1)>>16         PEA   t1;;       frintx                         ;round the number         PEA   $0014         LDX   #$090A         JSL   $E10000;;       fsetenv                        ;restore the environment         PEA   $01         LDX   #$090A         JSL   $E10000         ldx   #^t1                     ;return a pointer to the result         lda   #t1         rtl		ENDP******************************************************************  fmod - return the floating point remainder**  Inputs:*        stack - extended number**  Outputs:*        X-A - addr of the result******************************************************************		EXPORT	fmod     fmod     PROC	;using MathCommon         phb                            ;place the numbers in the work areas         plx         ply         phk         plb         pla         sta   t1         pla         sta   t1+2         pla         sta   t1+4         pla         sta   t1+6         pla         sta   t1+8         pla         sta   t2         pla         sta   t2+2         pla         sta   t2+4         pla         sta   t2+6         pla         sta   t2+8         phy         phx         lda   t2+8                     ;if t2 = 0 then         and   #$7FFF         ora   t2+6         ora   t2+4         ora   t2+2         ora   t2;;       jeq   lb1                      ;  return t1         BNE   *+5         BRL   lb1;;       fgetenv                        ;set the rounding direction to round down         PEA   $03         LDX   #$090A         JSL   $E10000         phx         txa         and   #$3FFF         ora   #$8000         pha;;       fsetenv         PEA   $01         LDX   #$090A         JSL   $E10000         lda   t1+8                     ;get and save the sign of t1, setting t1         and   #$8000                   ;  to abs(t1)         sta   sign         asl   t1+8         lsr   t1+8;;       move  t1,t3,#10                ;t3 := t1/t2	;          LDA   #10-1         LDX   #t1         LDY   #t3         MVN   t1,t3;;       ph4   #t2	;          PEA   +(t2)>>16         PEA   t2;;       ph4   #t3	;          PEA   +(t3)>>16         PEA   t3;;       fdivx         PEA   $0006         LDX   #$090A         JSL   $E10000;;       ph4   #t3                      ;t3 := round(t3)	;          PEA   +(t3)>>16         PEA   t3;;       frintx         PEA   $0014         LDX   #$090A         JSL   $E10000;;       ph4   #t2                      ;t3 = t3*t2	;          PEA   +(t2)>>16         PEA   t2;;       ph4   #t3	;          PEA   +(t3)>>16         PEA   t3;;       fmulx         PEA   $0004         LDX   #$090A         JSL   $E10000;;       ph4   #t3                      ;t1 = t1-t3	;          PEA   +(t3)>>16         PEA   t3;;       ph4   #t1	;          PEA   +(t1)>>16         PEA   t1;;       fsubx         PEA   $0002         LDX   #$090A         JSL   $E10000         lda   t1+8                     ;restore the sign of t1         ora   sign         sta   t1+8;;       fsetenv                        ;restore the environment         PEA   $01         LDX   #$090A         JSL   $E10000lb1      ldx   #^t1                     ;return a pointer to the result         lda   #t1         plb         rtl		ENDP******************************************************************  frexp - split a number into a fracrion and exponent**  Inputs:*        x - number*        nptr - pointer to location to save integer**  Outputs:*        returns the address of the fraction******************************************************************		EXPORT	frexp    frexp    PROC	;using MathCommon;;       csubroutine (10:val,4:nptr),0	; val      equ   0+4+0nptr     equ   10+4+0         tsc         phd         tcd         phb         phk         plb         lda   val+8                    ;get the exponent         and   #$7FFF         bne   lb1                      ;handle zero         sta   [nptr]         bra   lb2lb1      sec         sbc   #$3FFE         sta   [nptr]         lda   val+8                    ;set the fraction range         and   #$8000         ora   #$3FFE         sta   val+8lb2      ldx   #8                       ;set up to return the resultlb3      lda   val,X         sta   t1,X         dex         dex         bpl   lb3;;       lla   nptr,t1	;          LDA   #t1         STA   nptr         LDA   #^t1         STA   2+nptr         plb;;       creturn 4:nptr	;          ldx   nptr+2         ldy   nptr         lda   0+2         sta   0+14+2         lda   0+1         sta   0+14+1         pld         tsc         clc         adc   #0+14         tcs         tya         rtl		ENDP******************************************************************  ldexp - raise a number to an integer ;power of 2**  Inputs:*        x - number*        n - integer power of 2**  Outputs:*        returns the address of the result******************************************************************		EXPORT	ldexp    ldexp    PROC	;using MathCommon;;       csubroutine (10:val,2:n),0	; val      equ   0+4+0n        equ   10+4+0         tsc         phd         tcd         phb         phk         plb         lda   val+8                    ;separate the sign from the exponent         and   #$8000         sta   sign         clc                            ;add the value to the exponent         lda   val+8         and   #$7FFF         adc   n         bvs   err         cmp   #$7FFF                   ;check for a range error         blt   lb1err      lda   #ERANGE         sta   >errno         bra   lb2lb1      ora   sign                     ;replace the sign         sta   val+8                    ;save the exponentlb2      ldx   #8                       ;set up to return the resultlb3      lda   val,X         sta   t1,X         dex         dex         bpl   lb3;;       lla   val,t1	;          LDA   #t1         STA   val         LDA   #^t1         STA   2+val         plb;;       creturn 4:val	;          ldx   val+2         ldy   val         lda   0+2         sta   0+12+2         lda   0+1         sta   0+12+1         pld         tsc         clc         adc   #0+12         tcs         tya         rtl		ENDP******************************************************************  log - return ln(x)**  Inputs:*        stack - extended number**  Outputs:*        X-A - addr of the result******************************************************************		EXPORT	log      log      PROC	;using MathCommon         phb                            ;place the number in a work area         plx         ply         phk         plb         pla         sta   t1         pla         sta   t1+2         pla         sta   t1+4         pla         sta   t1+6         pla         sta   t1+8         phy         phx;;       ph4   #t1                      ;compute ln(x)	;          PEA   +(t1)>>16         PEA   t1;;       flnx         PEA   $00         LDX   #$0B0A         JSL   $E10000;;       fgetenv                        ;check for a domain error         PEA   $03         LDX   #$090A         JSL   $E10000         txa         and   #$0100         beq   lb1         lda   #EDOM         sta   >errnolb1      ldx   #^t1                     ;return a pointer to the result         lda   #t1         plb         rtl		ENDP******************************************************************  log10 - return log(x)**  Inputs:*        stack - extended number**  Outputs:*        X-A - addr of the result******************************************************************		EXPORT	log10    log10    PROC	;using MathCommon         phb                            ;place the number in a work area         plx         ply         phk         plb         pla         sta   t1         pla         sta   t1+2         pla         sta   t1+4         pla         sta   t1+6         pla         sta   t1+8         phy         phx;;       ph4   #t1                      ;compute ln(x)	;          PEA   +(t1)>>16         PEA   t1;;       flnx         PEA   $00         LDX   #$0B0A         JSL   $E10000;;       fgetenv                        ;check for a domain error         PEA   $03         LDX   #$090A         JSL   $E10000         txa         and   #$0100         beq   lb1         lda   #EDOM         sta   >errno;;lb1    ph4   #ln10e                   ;convert from ln base e to log base 10lb1	;          PEA   +(ln10e)>>16         PEA   ln10e;;       ph4   #t1	;          PEA   +(t1)>>16         PEA   t1;;       fmulx         PEA   $0004         LDX   #$090A         JSL   $E10000         ldx   #^t1                     ;return a pointer to the result         lda   #t1         plb         rtlln10e	DC.X	"0.43429448190325182765"		ENDP******************************************************************  modf - split a number into whole and ;fraction parts**  Inputs:*        x - number*        nptr - ptr to place to store integer part**  Outputs:*        returns the address of the result******************************************************************		EXPORT	modf     modf     PROC	;using MathCommon;;       csubroutine (10:val,4:nptr),0	; val      equ   0+4+0nptr     equ   10+4+0         tsc         phd         tcd         phb         phk         plb;;       fgetenv                        ;set the rounding direction to round         PEA   $03         LDX   #$090A         JSL   $E10000         phx                            ; towards 0         txa         ora   #$C000         pha;;       fsetenv         PEA   $01         LDX   #$090A         JSL   $E10000         ldx   #8                       ;t1 := vallb1      lda   val,X                    ;t2 := val         sta   t1,X         sta   t2,X         dex         dex         bpl   lb1;;       ph4   #t2                      ;t2 := round(t2)	;          PEA   +(t2)>>16         PEA   t2;;       frintx         PEA   $0014         LDX   #$090A         JSL   $E10000;;       fsetenv                        ;restore the environment         PEA   $01         LDX   #$090A         JSL   $E10000;;       ph4   #t2                      ;t1 := t1-t2	;          PEA   +(t2)>>16         PEA   t2;;       ph4   #t1	;          PEA   +(t1)>>16         PEA   t1;;       fsubx         PEA   $0002         LDX   #$090A         JSL   $E10000;;       ph4   #t2                      ;convert t2 to an integer	;          PEA   +(t2)>>16         PEA   t2;;       ph4   #t3	;          PEA   +(t3)>>16         PEA   t3;;       fx2i         PEA   $0410         LDX   #$090A         JSL   $E10000;;       fgetenv                        ;check for a range error         PEA   $03         LDX   #$090A         JSL   $E10000         txa         and   #$0D00         beq   lb2         lda   #ERANGE         sta   >errnolb2      lda   t3                       ;return the integer part         sta   [nptr];;       lla   nptr,t1                  ;set up to return the result	;          LDA   #t1         STA   nptr         LDA   #^t1         STA   2+nptr         plb;;       creturn 4:nptr	;          ldx   nptr+2         ldy   nptr         lda   0+2         sta   0+14+2         lda   0+1         sta   0+14+1         pld         tsc         clc         adc   #0+14         tcs         tya         rtl		ENDP******************************************************************  pow - return x ** y**  Inputs:*        stack - extended numbers**  Outputs:*        X-A - addr of the result******************************************************************		EXPORT	pow      pow      PROC	;using MathCommon         phb                            ;place the numbers in the work areas         plx         ply         phk         plb         pla         sta   t1         pla         sta   t1+2         pla         sta   t1+4         pla         sta   t1+6         pla         sta   t1+8         pla         sta   t2         pla         sta   t2+2         pla         sta   t2+4         pla         sta   t2+6         pla         sta   t2+8         phy         phx;;       ph4   #t2                      ;t1 := t1 ** t2	;          PEA   +(t2)>>16         PEA   t2;;       ph4   #t1	;          PEA   +(t1)>>16         PEA   t1;;       fxpwry         PEA   $12         LDX   #$0B0A         JSL   $E10000;;       fgetenv                        ;check for a range error         PEA   $03         LDX   #$090A         JSL   $E10000         txa         and   #$0D00         beq   lb1         lda   #ERANGE         sta   >errnolb1      ldx   #^t1                     ;return a pointer to the result         lda   #t1         plb         rtl		ENDP******************************************************************  sin - return sin(x)**  Inputs:*        stack - extended number**  Outputs:*        X-A - addr of the result******************************************************************		EXPORT	sin      sin      PROC	;using MathCommon         phb                            ;place the number in a work area         plx         ply         phk         plb         pla         sta   t1         pla         sta   t1+2         pla         sta   t1+4         pla         sta   t1+6         pla         sta   t1+8         phy         phx;;       ph4   #t1                      ;compute the sine	;          PEA   +(t1)>>16         PEA   t1;;       fsinx         PEA   $1A         LDX   #$0B0A         JSL   $E10000         ldx   #^t1                     ;return a pointer to the result         lda   #t1         plb         rtl		ENDP******************************************************************  sinh - return hyperbolic sine(x)**  Inputs:*        stack - extended number**  Outputs:*        X-A - addr of the result******************************************************************		EXPORT	sinh     sinh     PROC	;using MathCommon;;  Intialization;         phb                            ;place the number in a work area         plx         ply         phk         plb         pla         sta   t1         pla         sta   t1+2         pla         sta   t1+4         pla         sta   t1+6         pla         sta   t1+8         phy         phx;;  if abs(t1) >= 2^-33 then t1 :=  0.5*(exp1(t1)+exp1(t1)/(1+exp1(t1)));         lda   t1+8                     ;branch if the value is less than 2^-33         and   #$7FFF         cmp   #$3FDE;;       jlt   lb2         BGE   *+5         BRL   lb2         tay                            ;sign := sign of t1         lda   t1+8                     ;t1 := abs(t1)         and   #$8000         sta   sign         sty   t1+8;;       ph4   #t1                      ;t1 := exp1(t1)	;          PEA   +(t1)>>16         PEA   t1;;       fexp1x         PEA   $0C         LDX   #$0B0A         JSL   $E10000;;       fgetenv                        ;check for a range error         PEA   $03         LDX   #$090A         JSL   $E10000         txa         and   #$0500         beq   lb1         lda   #ERANGE         sta   >errno         brl   lb2lb1      lda   t1                       ;t2 := t1         sta   t2                       ;t3 := t1         sta   t3         lda   t1+2         sta   t2+2         sta   t3+2         lda   t1+4         sta   t2+4         sta   t3+4         lda   t1+6         sta   t2+6         sta   t3+6         lda   t1+8         sta   t2+8         sta   t3+8;;       ph4   #one                     ;t3 := t3+1	;          PEA   +(one)>>16         PEA   one;;       ph4   #t3	;          PEA   +(t3)>>16         PEA   t3;;       faddx         PEA   $0000         LDX   #$090A         JSL   $E10000;;       ph4   #t3                      ;t2 := t2/t3	;          PEA   +(t3)>>16         PEA   t3;;       ph4   #t2	;          PEA   +(t2)>>16         PEA   t2;;       fdivx         PEA   $0006         LDX   #$090A         JSL   $E10000;;       ph4   #t2                      ;t1 := t1+t2	;          PEA   +(t2)>>16         PEA   t2;;       ph4   #t1	;          PEA   +(t1)>>16         PEA   t1;;       faddx         PEA   $0000         LDX   #$090A         JSL   $E10000;;       ph4   #half                    ;t1 := t1*0.5	;          PEA   +(half)>>16         PEA   half;;       ph4   #t1	;          PEA   +(t1)>>16         PEA   t1;;       fmulx         PEA   $0004         LDX   #$090A         JSL   $E10000         lda   sign                     ;t1 := t1*sign         ora   t1+8         sta   t1+8lb2      ldx   #^t1                     ;return a pointer to the result         lda   #t1         plb         rtl		ENDP******************************************************************  sqrt - return sqrt(x)**  Inputs:*        stack - extended number**  Outputs:*        X-A - addr of the result******************************************************************		EXPORT	sqrt     sqrt     PROC	;using MathCommon         phb                            ;place the number in a work area         plx         ply         phk         plb         pla         sta   t1         pla         sta   t1+2         pla         sta   t1+4         pla         sta   t1+6         pla         sta   t1+8         phy         phx;;       ph4   #t1                      ;compute the square root	;          PEA   +(t1)>>16         PEA   t1;;       fsqrtx         PEA   $0012         LDX   #$090A         JSL   $E10000;;       fgetenv                        ;check for a range error         PEA   $03         LDX   #$090A         JSL   $E10000         txa         and   #$0500         beq   lb1         lda   #ERANGE         sta   >errnolb1      ldx   #^t1                     ;return a pointer to the result         lda   #t1         plb         rtl		ENDP******************************************************************  tan - return tan(x)**  Inputs:*        stack - extended number**  Outputs:*        X-A - addr of the result******************************************************************		EXPORT	tan      tan      PROC	;using MathCommon         phb                            ;place the number in a work area         plx         ply         phk         plb         pla         sta   t1         pla         sta   t1+2         pla         sta   t1+4         pla         sta   t1+6         pla         sta   t1+8         phy         phx;;       ph4   #t1                      ;compute the tangent	;          PEA   +(t1)>>16         PEA   t1;;       ftanx         PEA   $1E         LDX   #$0B0A         JSL   $E10000;;       fgetenv                        ;check for a range error         PEA   $03         LDX   #$090A         JSL   $E10000         txa         and   #$0D00         beq   lb1         lda   #ERANGE         sta   >errnolb1      ldx   #^t1                     ;return a pointer to the result         lda   #t1         plb         rtl		ENDP******************************************************************  tanh - return hyperbolic tangent(x)**  Inputs:*        stack - extended number**  Outputs:*        X-A - addr of the result******************************************************************		EXPORT	tanh     tanh     PROC	;using MathCommon;;  Intialization;         phb                            ;place the number in a work area         plx         ply         phk         plb         pla         sta   t1         pla         sta   t1+2         pla         sta   t1+4         pla         sta   t1+6         pla         sta   t1+8         phy         phx;;  if abs(t1) >= 2^-33 then t1 :=  -exp1(-2*t1)/(2+exp1(-2*t1));         lda   t1+8                     ;branch if the value is less than 2^-33         and   #$7FFF         cmp   #$3FDE;;       jlt   lb2         BGE   *+5         BRL   lb2         tay                            ;sign := sign of t1         lda   t1+8                     ;t1 := abs(t1)         and   #$8000         sta   sign         sty   t1+8;;       ph4   #two                     ;t1 := t1*2	;          PEA   +(two)>>16         PEA   two;;       ph4   #t1	;          PEA   +(t1)>>16         PEA   t1;;       fmulx         PEA   $0004         LDX   #$090A         JSL   $E10000         lda   t1+8                     ;t1 := -t1         eor   #$8000         sta   t1+8;;       ph4   #t1                      ;t1 := exp1(t1)	;          PEA   +(t1)>>16         PEA   t1;;       fexp1x         PEA   $0C         LDX   #$0B0A         JSL   $E10000;;       fgetenv                        ;check for a range error         PEA   $03         LDX   #$090A         JSL   $E10000         txa         and   #$0500         beq   lb1         lda   #ERANGE         sta   >errno         bra   lb2;;lb1    move  two,t2,#10               ;t2 := 2lb1	;          LDA   #10-1         LDX   #two         LDY   #t2         MVN   two,t2;;       ph4   #t1                      ;t2 := t2+t1	;          PEA   +(t1)>>16         PEA   t1;;       ph4   #t2	;          PEA   +(t2)>>16         PEA   t2;;       faddx         PEA   $0000         LDX   #$090A         JSL   $E10000;;       ph4   #t2                      ;t1 := t1/t2	;          PEA   +(t2)>>16         PEA   t2;;       ph4   #t1	;          PEA   +(t1)>>16         PEA   t1;;       fdivx         PEA   $0006         LDX   #$090A         JSL   $E10000         lda   t1+8                     ;apply sign to t1         and   #$7FFF         ora   sign         sta   t1+8lb2      ldx   #^t1                     ;return a pointer to the result         lda   #t1         plb         rtl		ENDP		END