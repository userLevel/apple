{$keep 'cvt'}{---------------------------------------------------------------}{								}{  Prepare ORCA/M expanded listing files for input to		}{  AsmCvtIIGS.							}{								}{  Mike Westerfield						}{  Copyrught 1994						}{  Byte Works, Inc.						}{								}{---------------------------------------------------------------}program cvt (input, output);type   IEString = STRING;   IEStringPtr = ^IEString;   IEStringVec = ARRAY [0..8191] OF IEStringPtr;   IEStringVecPtr = ^IEStringVec;var   inName: string;			{input file name}					{from IntEnv.p}					{-------------}   {$PUSH}   {$J+}   ArgC: LONGINT;   ArgV: IEStringVecPtr;   {$POP}   function GetCommandLine: boolean;   { Get command line inputs					}   {								}   { Returns: False for a command line error, else True		}   begin {GetCommandLine}   if ArgC = 2 then begin      inName := argv^[1]^;      GetCommandLine := true;      end {if}   else begin      writeln('Form: cvt <file name>');      GetCommandLine := false;      end; {else}   end; {GetCommandLine}   procedure ProcessFile;   { process the file						}   const      maxLine = 255;			{max length of a line}         type      lineString = string[maxLine];	{line string}   var      f: text;				{input file}      line: lineString;			{current input line}      nextLine: lineString;		{next input line}                  procedure ProcessLine (line: lineString; nextIsMacro: boolean);            { process one line					}      {								}      { parameters:						}      {    line - line to process				}      {    nextIsMacro - is the next line from an expanded	}      {		macro?						}            var         thisIsMacro: boolean;		{is this line from a macro expansino?}                     procedure AddCommentChar;	 	 { Add a comment character before column 41		}	 	 begin {AddCommentChar}	 if length(line) > 40 then	    if line[40] = ' ' then	       insert(';', line, 41);	 end; {AddCommentChar}	 	 	 procedure DeleteBinaryStuff;	 	 { Remove the non-source stuff from the start of the	}	 { line							}	 	 begin {DeleteBinaryStuff}	 delete(line, 1, 23);	 end; {DeleteBinaryStuff}	 	 	 procedure MakeComment;	 	 { Change the current line into a comment		}	 	 var	    p: integer;			{position of double-blank in line}	 	 begin {MakeComment}	 insert(';;', line, 1);	 p := pos('  ', line);	 if p <> 0 then	    delete(line, p, 1);	 p := pos('  ', line);	 if p <> 0 then	    delete(line, p, 1);	 end; {MakeComment}	 	 	 procedure RemoveSpaces;	 	 { Remove trailing whitespace				}	 	 begin {RemoveSpaces}	 while (length(line) <> 0) and (line[length(line)] = ' ') do	    delete(line, length(line), 1);	 end; {RemoveSpaces}	 	 	 procedure ReTab;	 	 { Make sure fields align to correct tab stops		}	 	 var	    i: integer;			{loop/index variable}	    p: integer;			{field position}	 	 	    function FindOpcode: integer;	    	    { Find the first char of the opcode field		}	    	    var	       p: integer;		{field position}	    	    begin {FindOpcode}	    p := 1;	    while (line[p] <> ' ') and (p < length(line)) do	       p := p + 1;	    while (line[p] = ' ') and (p < length(line)) do	       p := p + 1;	    if p = length(line) then	       p := maxint;	    FindOpcode := p;	    end; {FindOpcode}	 	 	    function FindOperand: integer;	    	    { Find the first char of the operand field		}	    	    var	       p: integer;		{field position}	    	    begin {FindOperand}	    p := 1;	    while (line[p] <> ' ') and (p < length(line)) do	       p := p + 1;	    while (line[p] = ' ') and (p < length(line)) do	       p := p + 1;	    while (line[p] <> ' ') and (p < length(line)) do	       p := p + 1;	    while (line[p] = ' ') and (p < length(line)) do	       p := p + 1;	    if p = length(line) then	       p := maxint;	    FindOperand := p;	    end; {FindOperand}	 	 	 begin {ReTab}	 if not (line[1] in ['!', ';', '*']) then begin	    p := FindOpcode;	    for i := p to 9 do	       Insert(' ', line, i);	    p := FindOperand;	    for i := p to 15 do	       Insert(' ', line, i);	    end; {if}	 end; {ReTab}                  begin {ProcessLine}      {remember if this is from a macro expansion}      thisIsMacro := line[23] = '+';            {get rid of the non-source stuff from the ORCA listing}      DeleteBinaryStuff;            {make sure macro expansion lines use correct tab stopc}      if thisIsMacro then         ReTab;            {if this is a macro invocation, change it to a comment}      if nextIsMacro and (not thisIsMacro) then         MakeComment;            {remove trailing spaces}      RemoveSpaces;      {Add a comment character in col 41}      AddCommentChar;            {check for macros within an expansion}      if (line[10] = '~') and (line[1] <> ';') and thisIsMacro then         MakeComment;            {write the line}      writeln(line);      end; {ProcessLine}         begin {ProcessFile}   reset(f, inName);   readln(f, nextLine);   while not eof(f) do begin      line := nextLine;      readln(f, nextLine);      ProcessLine(line, nextLine[23] = '+');      end; {while}   ProcessLine(nextLine, false);   end; {ProcessFile}beginif GetCommandLine then   ProcessFile;end.