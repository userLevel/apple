{\rtf1\mac\ansicpg10000\uc1 \deff0\deflang1033\deflangfe1033{\upr{\fonttbl{\f0\fnil\fcharset256\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fnil\fcharset256\fprq2{\*\panose 020b0604020202020204}Arial;}{\f2\fmodern\fcharset77\fprq1{\*\panose 02070309020205020404}Courier New;}{\f3\fnil\fcharset2\fprq2{\*\panose 02000500000000000000}Symbol;}{\f4\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Times;}{\f5\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Helvetica;}{\f6\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Courier;}{\f7\fnil\fcharset256\fprq2{\*\panose 020b0503030404040204}Geneva;}{\f8\froman\fcharset77\fprq2{\*\panose 00000000000000000000}Tms Rmn;}{\f9\fswiss\fcharset77\fprq2{\*\panose 00000000000000000000}Helv;}{\f10\froman\fcharset77\fprq2{\*\panose 00000000000000000000}MS Serif;}{\f11\fswiss\fcharset77\fprq2{\*\panose 00000000000000000000}MS Sans Serif;}{\f12\fnil\fcharset256\fprq2{\*\panose 02020502060305060204}New York;}{\f13\fswiss\fcharset77\fprq2{\*\panose 00000000000000000000}System;}{\f14\fnil\fcharset2\fprq2{\*\panose 05020102010804080708}Wingdings;}{\f15\froman\fcharset256\fprq1{\*\panose 00000000000000000000}FE Roman font face;}{\f16\fmodern\fcharset256\fprq1{\*\panose 00000000000000000000}FE Modern font face;}{\f17\froman\fcharset256\fprq1{\*\panose 00000000000000000000}FE Truetype Roman font face;}{\f18\fmodern\fcharset256\fprq1{\*\panose 00000000000000000000}FE Truetype Modern font face;}{\f19\froman\fcharset77\fprq2{\*\panose 00000000000000000000}Century;}}{\*\ud{\fonttbl{\f0\fnil\fcharset256\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fnil\fcharset256\fprq2{\*\panose 020b0604020202020204}Arial;}{\f2\fmodern\fcharset77\fprq1{\*\panose 02070309020205020404}Courier New;}{\f3\fnil\fcharset2\fprq2{\*\panose 02000500000000000000}Symbol;}{\f4\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Times;}{\f5\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Helvetica;}{\f6\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Courier;}{\f7\fnil\fcharset256\fprq2{\*\panose 020b0503030404040204}Geneva;}{\f8\froman\fcharset77\fprq2{\*\panose 00000000000000000000}Tms Rmn;}{\f9\fswiss\fcharset77\fprq2{\*\panose 00000000000000000000}Helv;}{\f10\froman\fcharset77\fprq2{\*\panose 00000000000000000000}MS Serif;}{\f11\fswiss\fcharset77\fprq2{\*\panose 00000000000000000000}MS Sans Serif;}{\f12\fnil\fcharset256\fprq2{\*\panose 02020502060305060204}New York;}{\f13\fswiss\fcharset77\fprq2{\*\panose 00000000000000000000}System;}{\f14\fnil\fcharset2\fprq2{\*\panose 05020102010804080708}Wingdings;}{\f15\froman\fcharset256\fprq1{\*\panose 00000000000000000000}FE Roman font face;}{\f16\fmodern\fcharset256\fprq1{\*\panose 00000000000000000000}FE Modern font face;}{\f17\froman\fcharset256\fprq1{\*\panose 00000000000000000000}FE Truetype Roman font face;}{\f18\fmodern\fcharset256\fprq1{\*\panose 00000000000000000000}FE Truetype Modern font face;}{\f19\froman\fcharset77\fprq2{\*\panose 00000000000000000000}Century;}}}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\widctlpar\adjustright \f4\cgrid \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}{\s15\li2880\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid \sbasedon0 \snext0 toc 5;}{\s16\li2160\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid \sbasedon0 \snext0 toc 4;}{\s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid \sbasedon0 \snext0 toc 3;}{\s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid \sbasedon0 \snext0 toc 2;}{\s19\sb200\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid \sbasedon0 \snext0 toc 1;}{\s20\li720\widctlpar\adjustright \f4\cgrid \sbasedon0 \snext0 index 3;}{\s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid \sbasedon0 \snext0 index 2;}{\s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid \sbasedon0 \snext0 index 1;}{\s23\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \f4\cgrid \sbasedon0 \snext23 footer;}{\s24\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \f4\cgrid \sbasedon0 \snext24 header;}{\s25\fi360\sb40\widctlpar\adjustright \f4\cgrid \sbasedon0 \snext25 text;}{\s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid \sbasedon25 \snext26 Header 1;}{\s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid \sbasedon25 \snext27 Header 2;}{\s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid \sbasedon25 \snext28 Header 3;}{\s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid \sbasedon25 \snext29 Command Prototype;}{\s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid \sbasedon29 \snext30 Command Summary;}{\s31\fi360\widctlpar\adjustright \f6\fs20\cgrid \sbasedon25 \snext31 code;}{\s32\fi360\sb160\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \adjustright \f4\cgrid \sbasedon25 \snext32 table header;}{\s33\sb120\sa40\widctlpar\adjustright \f4\ul\cgrid \sbasedon25 \snext33 Snippet;}{\s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid \sbasedon25 \snext34 Header 4;}{\s35\sb260\sa140\keepn\widctlpar\adjustright \f4\cgrid \sbasedon34 \snext35 Header 5;}{\s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid \sbasedon25 \snext36 Editor Command;}{\s37\sb160\sa80\keepn\widctlpar\adjustright \b\f6\cgrid \sbasedon29 \snext37 Shell Command Prototype;}}{\*\revtbl {Unknown;}}{\info{\title GSoft Manual}{\author Mike Westerfield}{\operator Mike Westerfield}{\creatim\yr2000\mo10\dy10\hr15\min21}{\revtim\yr2000\mo10\dy10\hr15\min21}{\version2}{\edmins1}{\nofpages64}{\nofwords94757}{\nofchars540120}{\*\company Byte Works, Inc.}{\nofcharsws663305}{\vern99}}\paperw20160\paperh12240\margl1080\margr11160\margt1080\margb1080 \facingp\widowctrl\ftnbj\aenddoc\hyphhotz0\sprstsp\otblrul\brkfrm\sprstsm\truncex\nolead\msmcap\lytprtmet\hyphcaps0\viewkind1\viewscale100 \fet0\sectd \lndscpsxn\pgnrestart\pgnlcrm\linex0\endnhere\titlepg\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s25\qc\sb40\widctlpar\adjustright \f4\cgrid {\b\fs72 \par \par }{\b\i\fs48 GSoft}{\b\fs36\up6 \u8482\'aa}{\b\i\fs48  BASIC 1.0\par }{\i\outl\shad\fs28 A BASIC Interpreter \par for the\par Apple II}{\i\outl\shad GS\par }{\par \par \par \par \par \par \par \par \par \par \par \par }{\b\fs28 Mike Westerfield\par }{\par \par \par \par }{\fs28 Byte Works}{\fs20\up6 \u174\'a8}{\fs28 , Inc.\par }\pard \s25\qc\widctlpar\adjustright {\fs20 8000 Wagon Mound Dr. NW\par Albuquerque, NM  87120-2845\par }\pard \s25\qc\sb80\widctlpar\adjustright {\fs20 Voice (505) 898-8183\par FAX (505) 898-4092\par E-Mail MikeW50@AOL.COM\par }\pard \s25\fi360\sb80\widctlpar\adjustright {\fs20 \sect }\sectd \lndscpsxn\sbkodd\pgnlcrm\linex0\endnhere\sectdefaultcl {\footerl \pard\plain \s23\widctlpar\adjustright \f4\cgrid {\f5\fs20 \chpgn }{\f5\fs20 \par }}{\footerr \pard\plain \s23\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab }{\f5\fs20 \chpgn }{\f5\fs20 \par }}\pard\plain \s25\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par \par \par \par \par \par }\pard \s25\qc\sb40\widctlpar\adjustright {Credits\par }\pard \s25\sb40\widctlpar\adjustright {\fs20 \par \par }\pard \s25\li2880\sb40\widctlpar\adjustright {\fs20 GSoft\~BASIC Interpreter\par \tab Mike Westerfield\par \par Documentation\par \tab Mike Westerfield\par \par Beta Testers\par \tab Jeff Blakeney\par \tab Richard N. Cain\par \tab Gareth Jones\par \tab Glen Gunselman\par \tab Charles Hartley\par \tab Eric Shepherd\par \tab Timothy Tobin\par }\pard \s25\sb40\widctlpar\adjustright {\fs20 \par \par \par \par \par \par \par \par \par }\pard \s25\qc\sb40\widctlpar\adjustright {\fs20 Copyright 1998\par By The Byte Works, Inc.\par All Rights Reserved\par \par }\pard\plain \qc\widctlpar\tx450\tx720\adjustright \f4\cgrid {\fs18 Master Set 1.0.0.0\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \page }{\b\fs20 Limited Warranty}{\fs20  - Subject to the below stated limitations, Byte Works, Inc. hereby warrants that the programs contained in this unit will load and run on the standard manufacturer\rquote s configuration for the computer listed for a period of ninety (90) days from date of purchase. Except for such warranty, this product is supplied on an \ldblquote as is\rdblquote  basis without warranty as to merchantability or its fitness for any particular purpose. The limits of warranty extend only to the original purchaser.\par Neither Byte Works, Inc. nor the authors of this program are liable or responsible to the purchaser and/or user for loss or damage caused, or alleged to be caused, directly or indirectly by this software and its attendant documentation, including (but not limited to) interruption of service, loss of business, or anticipatory profits.\par To obtain the warranty offered, the enclosed purchaser registration card must be completed and returned to the Byte Works, Inc. within ten (10) days of purchase.\par }{\b\fs20 Important Notice}{\fs20  - This is a fully copyrighted work and as such is protected under copyright laws of the United States of America. According to these laws, consumers of copywritten material may make copies for their personal use only. Duplication for any other purpose whatsoever would constitute infringement of copyright laws and the offender would be liable to civil damages of up to $50,000 in addition to actual damages, plus criminal penalties of up to one year imprisonment and/or a $10,000 fine.\par This product is sold for use on a single computer at a single location. Contact the publisher for information regarding licensing for use at multiple-workstation or multiple-computer installations.\par }{\b\fs20 \par }{\fs20 GSoft\~BASIC is a trademark of the Byte Works, Inc.\par The Byte Works is a registered trademark of the Byte Works, Inc.\par Apple and GS/OS are registered trademarks of Apple Computer, Inc.\par \par }\pard \s25\qc\fi360\sb40\widctlpar\adjustright {\fs20 Program, Documentation and Design\par Copyright 1998\par The Byte Works, Inc.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \sect }\sectd \lndscpsxn\sbkodd\pgnlcrm\linex0\endnhere\titlepg\sectdefaultcl {\headerl \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 Table of Contents\par }}{\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Table of Contents\par }}{\footerf \pard\plain \s23\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab }{\f5\fs20 \chpgn }{\f5\fs20 \par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Table of Contents\par }\pard\plain \s19\sb200\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {\field{\*\fldinst { TOC \\f  }}{\fldrslt {Chapter 1 \endash  Introducing GSoft\~BASIC\tab 1\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {About the Manual\tab 1\par Other Books and Reference Materials\tab 2\par }\pard\plain \s19\sb200\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Chapter 2 \endash  Getting Started\tab 5\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Setting Up GSoft\~BASIC\tab 5\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Backups\tab 5\par Registration\tab 5\par System Requirements\tab 5\par Running GSoft\~BASIC\tab 6\par Using GSoft\~BASIC from Floppy Disks\tab 6\par Installing GSoft\~BASIC on a Hard Disk\tab 7\par }\pard\plain \s16\li2160\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {GSoft\~BASIC\tab 7\par GSoft\~BASIC for ORCA\tab 7\par GSoft\~BASIC for ORCA and Finder\tab 8\par .PRINTER Driver\tab 8\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {The Three Worlds of GSoft\~BASIC\tab 8\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {The GSoft\~BASIC Shell\tab 8\par Using GSoft\~BASIC from the ORCA Shell\tab 9\par Creating GSoft\~BASIC Programs that Run From the Finder\tab 9\par }\pard\plain \s19\sb200\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Chapter 3 \endash  Programming on the Apple\~IIGS\tab 11\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Text Programs\tab 11\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Console Control Codes\tab 16\par Stand-Alone Programs\tab 16\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Graphics Programs\tab 17\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Your First Graphics Program\tab 17\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Programming on the Desktop\tab 18\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Learning the Toolbox\tab 18\par Hardware Requirements\tab 19\par }\pard\plain \s19\sb200\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Chapter 4 \endash  GSoft\~BASIC Utilities\tab 21\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Printing With the .PRINTER Driver\tab 21\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Installing .PRINTER\tab 21\par Configuring .PRINTER\tab 22\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {MakeRuntime\tab 24\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {What MakeRuntime Does\tab 25\par Things That Can Go Wrong\tab 25\par Including Libraries with GSoft\~BASIC Programs\tab 26\par Licensing\tab 26\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {CompileTool\tab 27\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {What CompileTool Does\tab 27\par Command Line Interface\tab 27\par The Syntax of Tool Interface Files\tab 28\par }\pard\plain \s16\li2160\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Structure of a Tool Interface File\tab 28\par BNF For Tool Interface Files\tab 32\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Summary of Differences from GSoft\~BASIC\tab 33\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {ORCA Shell GSoft\~BASIC\tab 34\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Using GSoft\~BASIC from the ORCA Shell\tab 34\par The DeToke Utility\tab 35\par Installing GSoft\~BASIC in the ORCA Shell\tab 36\par }\pard\plain \s19\sb200\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Chapter 5 - The Command Processor\tab 39\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {The Line Editor\tab 39\par File Names\tab 40\par Types of Files Used by GSoft\~BASIC\tab 41\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Source Files\tab 41\par }\pard\plain \s16\li2160\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {GSoft\~BASIC Tokenized Files\tab 41\par Text Files and Source Files\tab 41\par Applesoft\~BASIC Files\tab 42\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Entering BASIC Programs\tab 42\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {The Active Program\tab 42\par Entering Programs From the Command Line\tab 43\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Executing BASIC Commands\tab 43\par Command Reference\tab 44\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Bye\tab 44\par Catalog\tab 44\par CAT\tab 44\par Copy\tab 46\par Create\tab 47\par DEBUG\tab 47\par Del\tab 47\par Delete\tab 47\par Edit\tab 48\par List\tab 48\par Load\tab 49\par Lock\tab 49\par Move\tab 49\par New\tab 50\par Prefix\tab 50\par PR\tab 50\par Rename\tab 51\par Renumber\tab 51\par Run\tab 54\par Save\tab 55\par SSave\tab 55\par TSave\tab 55\par Unlock\tab 55\par }\pard\plain \s19\sb200\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Chapter 6 \endash  The Text Editor\tab 57\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {How Text Editors Work With GSoft\~BASIC Tokenized Files\tab 57\par Modes\tab 58\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Insert\tab 58\par Escape\tab 59\par Auto Indent\tab 59\par Select Text\tab 59\par Hidden Characters\tab 60\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Macros\tab 60\par Using Editor Dialogs\tab 62\par Using the Mouse\tab 64\par Command Descriptions\tab 65\par Setting Editor Defaults\tab 77\par }\pard\plain \s19\sb200\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Chapter 7 \endash  Program Symbols\tab 79\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Identifiers\tab 79\par Reserved Words\tab 80\par Reserved Symbols\tab 80\par Constants\tab 81\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Decimal Integers\tab 81\par Hexadecimal Integers\tab 81\par Real Numbers\tab 82\par String Constants\tab 82\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {White Space\tab 83\par Comments\tab 83\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {!\tab 83\par REM\tab 83\par }\pard\plain \s19\sb200\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Chapter 8 \endash  Types of Data\tab 85\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Integers\tab 85\par Reals\tab 85\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Infinity\tab 86\par NaN\tab 86\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Strings\tab 87\par Pointers\tab 87\par }\pard\plain \s19\sb200\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Chapter 9 \endash  BASIC Programs\tab 89\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {The Anatomy of a BASIC Program\tab 89\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Subroutines\tab 89\par Line Numbers\tab 89\par Multiple Statements on One Line\tab 90\par }\pard\plain \s19\sb200\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Chapter 10 \endash  Declaring Variables and Types\tab 91\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {What Is a Type?\tab 91\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {A Short History of Types in BASIC\tab 91\par The Kinds of Types\tab 91\par }\pard\plain \s16\li2160\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Simple Types\tab 91\par Arrays\tab 92\par Records\tab 93\par Pointers\tab 93\par Named Types\tab 94\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Type Compatibility\tab 95\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Numeric Type Compatibility\tab 95\par Strings\tab 97\par Records\tab 97\par Pointers\tab 98\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Default Types\tab 98\par Declaring Types and Variables\tab 100\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {DIM\tab 100\par }\pard\plain \s16\li2160\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Dimensioning Arrays\tab 100\par Assigning a Type With AS\tab 101\par Using Default Types With DIM\tab 102\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {TYPE-END TYPE\tab 103\par }\pard\plain \s16\li2160\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Declaring Record Types\tab 103\par How Records Are Stored In Memory\tab 103\par Variant Records\tab 105\par Using the Record Type In The Record (Linked Lists)\tab 107\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {TYPE-AS\tab 108\par }\pard\plain \s19\sb200\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Chapter 11 \endash  Expressions and Assignments\tab 111\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Expressions\tab 111\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Kinds of Expressions\tab 111\par }\pard\plain \s16\li2160\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Mathematical Expressions\tab 111\par Logical Expressions\tab 111\par Pointer Expressions\tab 112\par String Expressions\tab 112\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Evaluating Expressions\tab 113\par }\pard\plain \s16\li2160\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Operator Precedence\tab 113\par Binary Conversions\tab 114\par Unary Conversions\tab 115\par }\pard\plain \s15\li2880\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Converting DOUBLE to SINGLE\tab 115\par Converting DOUBLE to LONG\tab 116\par Converting DOUBLE to INTEGER\tab 116\par Converting SINGLE to DOUBLE\tab 116\par Converting SINGLE to LONG\tab 116\par Converting SINGLE to INTEGER\tab 116\par Converting LONG to DOUBLE\tab 117\par Converting LONG to SINGLE\tab 117\par Converting LONG to INTEGER\tab 117\par Converting INTEGER to DOUBLE\tab 117\par Converting INTEGER to SINGLE\tab 117\par Converting INTEGER to LONG\tab 117\par Converting BYTE to Any Other Type\tab 117\par Converting Any Other Type to BYTE\tab 117\par }\pard\plain \s16\li2160\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Addition\tab 118\par Subtraction\tab 119\par Multiplication\tab 120\par Division\tab 121\par Exponentiation\tab 122\par AND\tab 123\par OR\tab 123\par Comparison Operators\tab 123\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Terms\tab 125\par }\pard\plain \s16\li2160\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Constants\tab 125\par Unary Math Operations\tab 125\par NOT\tab 126\par Array Subscripts\tab 126\par Using BASIC Functions\tab 127\par Using FUNCTION Functions\tab 127\par Using DEF FN Functions\tab 127\par The Address Operator\tab 128\par Type Casting\tab 128\par Dereferencing Pointers\tab 129\par Accessing Record Fields\tab 130\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {L-Values\tab 130\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {The Assignment Statement\tab 131\par Mathematical Functions\tab 133\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {ABS\tab 133\par ATN\tab 133\par CDBL\tab 134\par CINT\tab 135\par CLNG\tab 135\par COS\tab 136\par CSNG\tab 137\par EXP\tab 137\par INT\tab 137\par LOG\tab 138\par RND\tab 138\par SGN\tab 139\par SIN\tab 139\par SQR\tab 140\par TAN\tab 140\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {String Functions\tab 140\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {ASC\tab 140\par CHR$\tab 141\par FRE\tab 141\par LEFT$\tab 141\par LEN\tab 142\par MID$\tab 142\par RIGHT$\tab 143\par STR$\tab 143\par VAL\tab 143\par }\pard\plain \s19\sb200\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Chapter 12 \endash  Control Statements\tab 145\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Looping\tab 145\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {DO-LOOP\tab 145\par FOR-NEXT\tab 147\par WHILE-WEND\tab 150\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Making Decisions\tab 151\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {IF-THEN\tab 151\par IF-GOTO\tab 151\par IF-END IF\tab 151\par SELECT CASE\tab 153\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Jumping Around\tab 155\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {GOTO\tab 155\par ON-GOTO\tab 156\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Handling Errors\tab 156\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {ERROR\tab 156\par ONERR GOTO\tab 157\par ERL\tab 158\par ERR\tab 158\par RESUME\tab 158\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Stopping and Starting a Program\tab 159\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {BREAK\tab 159\par END\tab 160\par CONT\tab 160\par STOP\tab 161\par WAIT\tab 161\par }\pard\plain \s19\sb200\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Chapter 13 \endash  Input and Output\tab 163\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Printing Text\tab 163\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {PRINT\tab 163\par }\pard\plain \s16\li2160\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Using ? As a Typing Shortcut\tab 164\par Printing Strings\tab 164\par Printing BYTE, INTEGER and LONG Values\tab 164\par Printing SINGLE and DOUBLE Values\tab 165\par Pointers and Records\tab 166\par Printing Multiple Expressions With Commas and Semicolons\tab 166\par Controlling Spaces Using SPC and TAB\tab 167\par Controlling New Lines With Semicolons\tab 168\par Printing Blank Lines\tab 169\par Printing To Disk Files\tab 169\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {PRINT USING\tab 169\par }\pard\plain \s16\li2160\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Formatting Numbers\tab 170\par The Decimal Point\tab 170\par Adding Commas\tab 171\par Controlling Positive and Negative Signs\tab 171\par Dollar Signs\tab 172\par Filling Spaces in Numbers\tab 172\par Formatting Numbers In Scientific Notation\tab 173\par Formatting Strings\tab 173\par Mixing Text and Format Models\tab 174\par Printing Format Characters as Text\tab 174\par Too Many and Too Few Format Models\tab 175\par Printing To Disk Files\tab 175\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {SPEED\tab 175\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Choosing Character Types\tab 176\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {INVERSE\tab 177\par MOUSETEXT\tab 177\par NORMAL\tab 178\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Reading Text\tab 178\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {INPUT\tab 178\par }\pard\plain \s16\li2160\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Reading from Disk Files\tab 178\par Prompts\tab 179\par Multiple Inputs\tab 180\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {LINE INPUT\tab 181\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Positioning the Cursor\tab 182\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {CSRLIN\tab 182\par HOME\tab 183\par HTAB\tab 183\par POS\tab 183\par VTAB\tab 184\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Imbedding Data In The Program\tab 184\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {DATA\tab 184\par READ\tab 185\par RESTORE\tab 185\par }\pard\plain \s19\sb200\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Chapter 14 \endash  Disk Files\tab 187\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {File Names\tab 187\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {ProDOS and HFS Names\tab 187\par Other File Systems\tab 188\par Devices\tab 188\par Path Names\tab 188\par The Default Prefix\tab 189\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Printing\tab 190\par The GS/OS Option\tab 190\par File Numbers\tab 191\par File Input and Output Examples\tab 191\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Line Oriented Text Files\tab 191\par Binary Files\tab 192\par Backtracking in Files\tab 195\par Reading An Entire File\tab 198\par Random Access Files\tab 199\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Opening and Closing Files\tab 200\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {CLOSE\tab 200\par OPEN\tab 200\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Reading and Writing Files\tab 202\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {EOF\tab 202\par GET\tab 202\par LOC\tab 202\par LOF\tab 202\par PUT\tab 203\par SEEK\tab 203\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Dealing With Directories and Files\tab 203\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {CHDIR\tab 203\par CURDIR$\tab 204\par DIR$\tab 204\par KILL\tab 205\par RMDIR\tab 205\par MKDIR\tab 205\par NAME\tab 205\par }\pard\plain \s19\sb200\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Chapter 15 \endash  Graphics\tab 207\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Applesoft\~BASIC Graphics\tab 207\par Graphics Commands\tab 207\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {HCOLOR=\tab 207\par HGR\tab 208\par HPLOT\tab 209\par TEXT\tab 210\par }\pard\plain \s19\sb200\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Chapter 16 \endash  Utility Statements\tab 211\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Memory Handling\tab 211\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {ALLOCATE\tab 211\par DISPOSE\tab 213\par NIL\tab 213\par SETMEM\tab 213\par SIZEOF\tab 214\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Peeks and Pokes\tab 214\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {PEEK\tab 215\par POKE\tab 215\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Clearing the Workspace\tab 216\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {CLEAR\tab 216\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {GSoft Version Number\tab 216\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {VERSION\tab 216\par }\pard\plain \s19\sb200\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Chapter 17 \endash  Subroutines\tab 219\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {GOSUB Subroutines\tab 219\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {GOSUB\tab 219\par ON-GOSUB\tab 220\par POP\tab 221\par RETURN\tab 221\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {DEF FN Functions\tab 221\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {DEF FN\tab 221\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Subroutines and Functions\tab 223\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {SUB and FUNCTION Parameter Lists\tab 223\par }\pard\plain \s16\li2160\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Passing Parameters by Reference and Value\tab 227\par Using Parameters\tab 228\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Local Variables and Types\tab 228\par Recursion with SUB and FUNCTION\tab 229\par CALL\tab 230\par FUNCTION\tab 230\par SUB\tab 231\par }\pard\plain \s19\sb200\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Chapter 18 \endash  Standard Libraries\tab 233\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {The Game Paddle Library\tab 233\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {GTBootInit\tab 233\par GTStartup\tab 233\par GTShutDown\tab 234\par GTVersion\tab 234\par GTStatus\tab 234\par GTGetSwitch\tab 234\par GTClearAnnunciator\tab 234\par GTSetAnnunciator\tab 234\par GTGetPaddle\tab 234\par Using the Game Paddle Library\tab 235\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {The Time Library\tab 235\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {TTBootInit\tab 235\par TTStartup\tab 235\par TTShutDown\tab 236\par TTVersion\tab 236\par TTStatus\tab 236\par DateString\tab 236\par TimeString\tab 236\par Time\tab 237\par Using the Time Library\tab 238\par }\pard\plain \s19\sb200\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Chapter 19 \endash  Tool Interface\tab 239\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {The Toolbox Interface\tab 239\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Using the Toolbox\tab 239\par The GSoft\~BASIC Toolbox Interface\tab 240\par Using Apple\rquote s Documentation\tab 241\par GS/OS and the ORCA Shell Calls\tab 244\par The Role of User Tools\tab 244\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Tool and GS/OS Errors\tab 244\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {TOOLERROR\tab 244\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Loading and Unloading Libraries\tab 245\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {LOADLIBRARY\tab 245\par UNLOADLIBRARY\tab 245\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {TOOL and GSOS Tokens\tab 245\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {GSOS\tab 245\par TOOL\tab 246\par LIBRARY\tab 246\par }\pard\plain \s19\sb200\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Appendix A \endash  Error Messages\tab 247\par Appendix B \endash  Console Control Codes\tab 267\par Appendix C \endash  Character Sets\tab 269\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {The ASCII Character Set\tab 269\par Text Screen Codes\tab 270\par Toolbox Character Codes\tab 270\par }\pard\plain \s19\sb200\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Appendix D \endash  Writing User Tools for GSoft\~BASIC\tab 273\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {The Role Of User Tools\tab 273\par Writing User Tools\tab 273\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Apple\~IIGS Toolbox Reference Volume 2\tab 273\par Avoiding Tool Number Conflicts\tab 273\par The GSoft\~BASIC Interface\tab 274\par Installing the Game Paddle Library\tab 274\par Sample Source\tab 275\par }\pard\plain \s19\sb200\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Appendix E \endash  Converting Applesoft\~BASIC Programs to GSoft\~BASIC\tab 277\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Applesoft\~BASIC Peeks, Pokes and Calls\tab 277\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Low Resolution Graphics and Text Screen Access\tab 283\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Commands in GSoft\~BASIC That Are Not In Applesoft\~BASIC\tab 284\par Commands in Applesoft\~BASIC That Are Not In GSoft\~BASIC\tab 284\par Commands That Are Different in Applesoft\~BASIC and GSoft\~BASIC\tab 285\par Other Differences\tab 286\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Available Memory\tab 286\par Disk Input and Output\tab 286\par Line Numbers\tab 287\par Numbers\tab 287\par }\pard\plain \s19\sb200\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Appendix F \endash  Implementation Details\tab 289\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Memory Use\tab 289\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Program Buffer\tab 289\par Variable Buffer\tab 289\par Dynamic Memory\tab 290\par Other Memory Locations\tab 290\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Tokenized Files\tab 291\par }\pard\plain \s17\li1440\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {The Organization of Tokenized Programs\tab 291\par Line Number Schemes\tab 292\par BASIC Tokens\tab 292\par Example of a Tokenized Program\tab 294\par }\pard\plain \s19\sb200\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Appendix G \endash  Quick Reference to the Shell\tab 295\par Appendix H \endash  Quick Reference to GSoft\~BASIC\tab 299\par }\pard\plain \s18\li720\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Statements\tab 299\par Functions\tab 313\par }\pard\plain \s19\sb200\widctlpar\tqr\tx7920\adjustright \f4\fs20\cgrid {Index\tab 321\par }\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {\sect }\sectd \lndscpsxn\sbkodd\pgnrestart\linex0\endnhere\titlepg\sectdefaultcl {\headerl \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 User's Guide\par }}{\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Chapter 1: Introducing GSoft\~BASIC\par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Chapter 1 \endash  Introducing GSoft\~BASIC}{\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\v\f4\fs36\cgrid {\tc {\v Chapter 1 \endash  Introducing GSoft\~BASIC\tcl1}}}{\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Welcome to GSoft\~BASIC! GSoft\~BASIC is a complete programming environment for writing programs on the Apple\~II}{\fs18 GS}{\fs20 . You get a simple, easy to use BASIC interpreter that is, in many important ways, one of the most sophisticated implementations of BASIC ever produced. There is a second version of the interpreter that executes from the popular ORCA programming environment, perfect for toolbox}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 toolbox}}}{\fs20  programming or for people who want a more complete (although harder to learn) programming environment. And, of course, there is a utility that creates GSoft\~BASIC applications that will run from the Finder, even on computers where GSoft\~BASIC is not installed.\par While the GSoft\~BASIC environment was deliberately kept simple, it\rquote s still a cut above the old Applesoft\~BASIC environment. After all, GSoft\~BASIC is designed to run on the Apple\~II}{\fs18 GS}{\fs20 , not an Apple\~II with as little as 16K of RAM and 12K of ROM. We had room to add many nice features not found in Applesoft\~BASIC, like a full screen editor.\par GSoft\~BASIC is the only Apple\~II}{\fs18 GS}{\fs20  BASIC\emdash for that matter, the only BASIC we\rquote re aware of on any platform\emdash that gives full, natural access to the toolbox. The reason is simple: Toolbox programming requires records and pointers. Some modern BASICs support records, but none we are aware of support pointers with the natural grace of C or Pascal. GSoft\~BASIC does.\par After purchasing a new program, you would probably like to sit right down at your computer and try it out. We encourage you to do just that, and in fact, this manual is designed to help you. Before getting started, though, we would like to take some time to suggest how you should approach learning to use GSoft\~BASIC.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 About the Manual}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 About the Manual\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 This manual is your guide to GSoft\~BASIC. To make it easy for you to learn about the system, this manual has been divided into three major sections. The first part is called the }{\i\fs20 User\rquote s Guide}{\fs20 . It is a tutorial introduction to the development environment, showing you how to create BASIC programs using GSoft\~BASIC. The second part is called the }{\i\fs20 Environment Reference Manual}{\fs20 . It is a working reference to provide you with in-depth information about the development environment you will use to create GSoft\~BASIC programs. Part three is the }{\i\fs20 Language Reference Manual}{\fs20 . It contains information about the GSoft\~BASIC programming language.\par Regardless of your programming background, we recommend reading all of this chapter and the next, along with any portions of Chapter 3 that interest you. You should skim the major headings for the remainder of the book so you know what information is available, and approximately where to find it. Spend some time browsing as you do this; you\rquote ll find many commands and features that you probably wouldn\rquote t anticipate in a BASIC.\par While this manual will teach you how to use GSoft\~BASIC to write and test programs, it is not a programming tutorial. It is primarily a reference manual, giving you a comprehensive guide to GSoft\~BASIC in a format that makes it easy to look up specific information. Basic concepts about programming in GSoft\~BASIC are necessary to create useful, efficient programs. If you are already familiar with programming in some other language, especially another dialect of BASIC, this reference manual is probably all you will need to begin writing your own programs. If you are new to BASIC, you can start with our }{\i\fs20 Learn to Program in GSoft\~BASIC}{\fs20  course, which is written specifically for GSoft\~BASIC. You\rquote ll find more details about this course, and several other books that may be of interest, at the end of this chapter.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Other Books and Reference Materials}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Other Books and Reference Materials\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 This section lists a lot of books, but don\rquote t be intimidated by the list. You don\rquote t actually need any of them to use GSoft\~BASIC, and very few people will ever use all of them. This list is here to give you some ideas for further exploration, not as a list of required books!\par If you are new to BASIC, you will need to supplement this manual with a good beginner\rquote s book on the BASIC programming language. A companion course is available from the Byte Works that teaches you the BASIC language and some basic techniques for programming. The book is called }{\i\fs20 Learn to Program in GSoft\~BASIC}{\fs20 , and it has one distinct advantage over any other BASIC programming book: it is written specifically for GSoft\~BASIC running on an Apple\~II}{\fs18 GS}{\fs20 .\par Unlike C and Pascal, there is no widely accepted language standard or a common core set of extensions to a standard language for BASIC. That makes using general BASIC programming books tricky, but not impossible. In general, books that are not written for a specific dialect of BASIC should be fairly easy to use with GSoft\~BASIC. You\rquote ll find many such books in your local library or through on-line bookstores, or by special order from local bookstores. The recent trend for books on bookstore shelves is towards specific implementations of BASIC, though. Most of these books are not suitable for use with GSoft\~BASIC.\par If you would like to learn to write Apple\~II}{\fs18 GS}{\fs20  toolbox programs with windows and pull down menus, we suggest }{\i\fs20 Toolbox Programming in GSoft\~BASIC}{\fs20 , which is a complete introduction to the world of toolbox programming.}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 toolbox\:learning}}}{\fs20  You will eventually need a copy of the Apple\~II}{\fs18 GS}{\fs20  Toolbox Reference, volumes 1 through 3, and }{\i\fs20 Programmer\rquote s Reference for System 6.0.1}{\fs20 , but these aren\rquote t needed right away. These books do not teach you about the toolbox, but they are essential references for advanced toolbox programming. Depending on the kind of programming you are doing, you may also need other reference books. The common ones are listed below. You will also need some way to create resource forks. One way is Apple\rquote s Rez compiler, which ships with all ORCA languages and with }{\i\fs20 Toolbox Programming in GSoft\~BASIC.}{\fs20 \par \par }\pard \s25\sb40\keepn\widctlpar\adjustright {\fs20\ul Learn to Program in GSoft\~BASIC\par }{\fs20 Mike Westerfield\par Byte Works, Inc., Albuquerque, New Mexico\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 As this manual is prepared, this book has not been released, but is planned. It will be based on an existing introductory programming course in programming which has been used by thousands of people to learn Pascal and C.\par This introductory BASIC programming course is written specifically for GSoft\~BASIC running on an Apple\~II}{\fs18 GS}{\fs20 . It contains hundreds of complete programs as examples, as well as problems with solutions.\par \par }\pard \s25\sb40\keepn\widctlpar\adjustright {\fs20\ul Toolbox Programming in GSoft\~BASIC\par }{\fs20 Mike Westerfield\par Byte Works, Inc., Albuquerque, New Mexico\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 As this manual is prepared, this book has not been released, but is planned. It will be based on an existing introductory programming course in programming which has been used by thousands of people to learn toolbox programming in Pascal and C.\par This is the only self-paced course available for programming the Apple\~II}{\fs18 GS}{\fs20  toolbox. Unlike the toolbox reference manuals, this is a course that teaches you how to write programs, not a catalog of the various toolbox calls available on the Apple\~II}{\fs18 GS}{\fs20 . It includes four disks filled with toolbox source code, as well as an abridged toolbox reference manual, so you won\rquote t have to buy all of the toolbox reference manuals right away. It also comes with Apple\rquote s Rez compiler and the full version of the ORCA shell.}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 toolbox\:learning}}}{\fs20 \par \par }\pard \s25\sb40\keepn\widctlpar\adjustright {\fs20\ul Celestial BASIC: Astronomy On Your Computer\par }{\fs20 Eric Burgess\par Sybex, Berkeley, CA, 1982\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 This is one of my favorite programming books of all time. If you\rquote re at all interested in astronomy, it\rquote s worth the effort to find a copy of this classic book. It has a great collection of simple BASIC programs that perform a wide variety of calculations, like planet positions, moon phases, dates for Easter, and so forth.\par \par }\pard \s25\sb40\keepn\widctlpar\adjustright {\fs20\ul BASIC Computer Games\par }{\fs20 David H. Ahl, Ed.\par Workman Publishing, New York, 1978\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 An amazingly diverse collection of short BASIC games. This old book is worth chasing down, too.\par \par }\pard \s25\sb40\keepn\widctlpar\adjustright {\fs20\ul Technical Introduction to the Apple\~II}{\fs18\ul GS}{\fs20\ul \par }{\fs20 Apple Computer\par Addison-Wesley Publishing Company, Inc., Reading, Massachusetts\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 A good basic reference source for the Apple\~II}{\fs18 GS}{\fs20 .\par \par }\pard \s25\sb40\keepn\widctlpar\adjustright {\fs20\ul Apple\~II}{\fs18\ul GS }{\fs20\ul Hardware Reference\par Apple\~II}{\fs18\ul GS }{\fs20\ul Firmware Reference\par }{\fs20 Apple Computer\par Addison-Wesley Publishing Company, Inc. Reading, Massachusetts\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 These manuals provide information on how the Apple\~II}{\fs18 GS }{\fs20 works.\par \par }\pard \s25\sb40\keepn\widctlpar\adjustright {\fs20\ul Apple\~II}{\fs18\ul GS }{\fs20\ul Toolbox Reference: Volume I\par Apple\~II}{\fs18\ul GS }{\fs20\ul Toolbox Reference: Volume II\par Apple\~II}{\fs18\ul GS }{\fs20\ul Toolbox Reference: Volume III\par }{\fs20 Apple Computer\par Addison-Wesley Publishing Company, Inc., Reading, Massachusetts\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 These volumes provide essential information on how the tools work\emdash the parameters you need to set up and pass, the calls that are available, etc. You must have these books to use the Apple\~II}{\fs18 GS }{\fs20 toolbox effectively.}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 toolbox}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 toolbox\:reference manuals}}}{\fs20 \par \par }\pard \s25\sb40\keepn\widctlpar\adjustright {\fs20\ul Programmer\rquote s Reference for System 6.0.1\par }{\fs20 Apple Computer\par Byte Works, Inc., Albuquerque, New Mexico\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The first three volumes of the toolbox reference manual cover the Apple\~II}{\fs18 GS}{\fs20  toolbox up through System\~5. This book covers the new features added to the toolbox and GS/OS in System\~6.}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 toolbox}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GS/OS}}}{\v\fs20 .0;}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 System 6.0}}}{\fs20 \par \par }\pard \s25\sb40\keepn\widctlpar\adjustright {\fs20\ul Apple\~II}{\fs18\ul GS}{\fs20\ul  GS/OS}{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\ul\cgrid {\xe {\v\fs20\ul }{\v\fs20\ul GS/OS}}}{\fs20\ul  Reference\par }{\fs20 Apple Computer\par Addison-Wesley Publishing Company, Inc., Reading, Massachusetts\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 This manual provides information on the underlying disk operating system. You will need this reference if you want to bypass GSoft\~BASIC\rquote s build-in file handling commands. You might want to do that for greater efficiency, more control, or to access file and disk handling features that are not built into GSoft\~BASIC.\par \par }\pard \s25\sb40\keepn\widctlpar\adjustright {\fs20\ul ORCA/M}{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\ul\cgrid {\xe {\v\fs20\ul }{\v\fs20\ul ORCA/M}}}{\fs20\ul : A Macro Assembler for the Apple\~II}{\fs18\ul GS}{\fs20\ul \par }{\fs20 Mike Westerfield and Phil Montoya\par Byte Works, Inc., Albuquerque, NM\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 ORCA/M is the standard macro assembler for the Apple\~II}{\fs18 GS}{\fs20 . While you cannot mix other languages directly with GSoft\~BASIC, you can call user tools, known as libraries, from GSoft\~BASIC. ORCA/M is the ideal choice for writing user tools.}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 assembly language}}}{\fs20 \par }\pard\plain \s26\sb40\widctlpar\adjustright \b\f4\fs36\cgrid {\sect }\sectd \lndscpsxn\sbkodd\linex0\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Chapter 2: Getting Started\par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Chapter 2 \endash  Getting Started}{\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\v\f4\fs36\cgrid {\tc {\v Chapter 2 \endash  Getting Started\tcl1}}}{\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 This chapter describes the three major components of GSoft\~BASIC, helping you decide which environment you want to use. It also describes installing and starting GSoft\~BASIC.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Setting Up GSoft\~BASIC}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Setting Up GSoft\~BASIC\tcl2}}}{\fs48 \par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Backups}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Backups\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 As with any program, the first step you should take is to make a backup copy of the original disks. To do this, you will need two blank disks and a copy program\emdash Apple\rquote s Finder will do the job, or you can use any other copy program if you have a personal favorite. If you are unfamiliar with copying disks, refer to the documentation that came with your computer.\par As always, copies are for your personal use only. Using the copies for any purpose besides backing up your program is a violation of federal copyright laws. If you will be using GSoft\~BASIC in a classroom or work situation where more than one copy is needed, please contact the Byte Works, Inc. for details on our licensing policies.}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 backing up the disks}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 copying disks}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 site license}}}{\fs20 \par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Registration}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Registration\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 From time to time, we make improvements to GSoft\~BASIC. You should return your registration card}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 registration card}}}{\fs20  so we can notify you when the software is improved. We also notify our customers when we release new products, often offering substantial discounts to those who already have one of our programs.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 System Requirements}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 System Requirements\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 memory\:requirements}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 system\:requirements}}}{\fs20 To use GSoft\~BASIC, you will need an Apple\~II}{\fs18 GS}{\fs20  with at least 1.125M of memory for ROM 3 machines, or 1.25M of memory with ROM 1 machines. You can actually run GSoft\~BASIC with less memory, but we don\rquote t recommend less.\par You will also need at least two disk drives, and at least one of those must be a 3.5\rdblquote  disk drive. To use all of the features and utilities included with GSoft\~BASIC, you will need a second 800K floppy disk drive or a hard drive with 1.5M of free space.\par The MakeRuntime utility requires System\~6.0 or System\~6.0.1. GSoft\~BASIC itself can be used with System\~5.0.4, although we recommend System\~6.0.1. Programs written in GSoft\~BASIC require System 5.0.4 or better, although they obviously need a later operating system if the program itself makes calls that only exist in the later O/S.\par GSoft\~BASIC supports color monitors, printers and accelerator cards, but does not require them.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Running GSoft\~BASIC}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Running GSoft\~BASIC\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 shell\:GSoft\~BASIC}}}{\fs20 You do not need to do any initialization to use GSoft\~BASIC. After booting your computer, insert the disk labeled }{\i\fs20 GSoft\~BASIC }{\fs20 in your 3.5\rdblquote  disk drive and run GSoft.Sys16. After a few moments you will be in the GSoft\~BASIC shell, ready to write programs. If you\rquote re already familiar with Applesoft\~BASIC}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 Applesoft\~BASIC}}}{\fs20 , you\rquote ll be able to write programs immediately\emdash but be sure and scan the manual, because there\rquote s a lot more to GSoft\~BASIC!\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Using GSoft\~BASIC from Floppy Disks}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Using GSoft\~BASIC from Floppy Disks\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\*\bkmkstart bk0}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 floppy disk}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 disk\:floppy}}}{\fs20 If you\rquote re a bare-bones minimalist, you can actually run GSoft\~BASIC from a single 3.5\rdblquote  floppy disk. Here\rquote s what you need to do:\par \par }\pard \s25\fi-360\li720\sb40\widctlpar\adjustright {\fs20 \bullet \tab Make a copy of the system disk that you use now to boot your computer.\par \bullet \tab Erase the Finder, ProDOS 8, the tools, control panels and fonts from this copy. The specific files to delete from the System 6.0.1 boot disk are shown below; this list will be slightly different for other version of the operating system. For directories, leave the directory intact, but delete the contents.\par \par }\pard\plain \s31\li1080\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 Finder\par P8\par CDevs:\par desk.accs:ControlPanel\par Tools:\par }\pard \s31\li1080\widctlpar\adjustright {\fs18 Fonts:\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\fi-360\li720\sb40\widctlpar\adjustright {\fs20 \bullet \tab Copy GSoft.Sys16 from the }{\i\fs20 GSoft\~BASIC}{\fs20  disk to your boot disk.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par This gives you a disk that will boot directly into GSoft\~BASIC. It leaves plenty of room for your programs.\par You\rquote ll probably want to copy the full screen editor to your disk, too. It\rquote s not essential\emdash you can enter programs with line numbers without it\emdash but a full screen editor is almost too nice to consider doing without. To add the full screen editor, copy the folder named Shell and all its contents to your boot disk.\par Finally, you might want to copy the file GSoftTools.gst from the }{\i\fs20 GSoft\~BASIC }{\fs20 disk. This gives you access to the Apple\~II}{\fs18 GS}{\fs20  toolbox. You may not want to write toolbox programs, but QuickDraw\~II is nice even for simple graphics programs.\par The disk you\rquote ve just built is a perfect system for writing short programs. If you added the tool interface file, GSoftTools.gst, you can work through }{\i\fs20 Learn to Program in GSoft\~BASIC}{\fs20  with this disk.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Installing GSoft\~BASIC on a Hard Disk}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Installing GSoft\~BASIC on a Hard Disk\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 hard disk}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 disk\:hard}}}{\fs20 If you have a hard disk, you should install GSoft\~BASIC on your hard disk. It will run faster, and you won\rquote t have to look for utilities on the second disk.\par Start by running the Installer from the }{\i\fs20 GSoft\~BASIC }{\fs20 disk. There are four installer scripts:\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 GSoft\~BASIC}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 GSoft\~BASIC\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 shell\:GSoft\~BASIC}}}{\fs20 Use this option if you do not have any other ORCA languages. This installs all of GSoft\~BASIC and the utilities that are not designed to run under the ORCA shell.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 GSoft\~BASIC for ORCA}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 GSoft\~BASIC for ORCA\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Many people already own an ORCA programming language or another product that includes an ORCA compatible shell. While GSoft\~BASIC does not come with a copy of the ORCA shell, you can install it in an ORCA compatible shell if you already have one.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ORCA\:installing GSoft\~BASIC}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 shell\:ORCA}}}{\fs20 Use this option if you have any ORCA language with a version number of 2.0 or greater. This option installs all of the GSoft\~BASIC utilities designed to run under the ORCA shell.\par Installing GSoft BASIC changes your SysCmnd and SysTabs files. These files are commonly customized as you add languages and utilities. The files supplied with GSoft BASIC contain appropriate command and tab settings for ORCA/M, ORCA/Pascal, ORCA/C, ORCA/Modula-1 and ORCA/Integer BASIC, as well as GSoft BASIC. Including command and tab settings for languages you do not own does not cause problems, but installing this file could wipe out any custom changes you have made. If you have made changes, make a copy of your SysCmnd and SysTabs file before installing GSoft BASIC. After Installing GSoft BASIC, replace your original files, then make the following changes by hand.\par  Add these lines to your ORCA:Shell:SysCmnd file, placing them in alphabetical order compared to the existing entries:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 BASIC           *L      260             GSoft\~BASIC\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 COMPILETOOL     U                       GSoft\~BASIC Tool Compiler\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 tabs}}}{\fs20 You\rquote ll also need a new tab line in the ORCA:Shell:SysTabs file. Each language uses three lines. The easiest way to create the three lines for GSoft\~BASIC is to start by copying the three existing lines for language 4. Because the last line is long, it will look like four lines on the screen. The lines you need to copy will look like this:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 4\par 10011001\par 000000001000000010000000100000001000000010000000100000001000000010000000\par 100000001000000010000000100000001000000010000000100000001000000010000000\par 100000001000000010000000100000001000000010000000100000001000000010000000\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 100000001000002\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par After copying these lines, paste them in your SysTabs file at the proper location for language number 260. The language number is the first line of the three line set, or 4 in the sample you see above. Change the language number to 260 and save the file.\par If you are using an older version of ORCA, the second line may have fewer characters on the second line\emdash 10011001 in the example. You can use the shorter version you see in your existing SysTabs file or add all of the characters you see in the example; it won\rquote t matter at all to the existing editor.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 GSoft\~BASIC for ORCA and Finder}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 GSoft\~BASIC for ORCA and Finder\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 Finder\:creating programs for}}}{\fs20 This option installs both of the versions of GSoft\~BASIC described above. Use this option if you want to use GSoft\~BASIC from the Finder and from the ORCA shell.\par GSoft.Sys16, the version of GSoft\~BASIC that runs from the Finder, is installed in the ORCA folder. This saves a little space, since the editor, samples, and some utilities are not installed twice. You should still modify the SysCmnd and SysTabs files as described above.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 .PRINTER Driver}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 .PRINTER Driver\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\v\fs20 .PRINTER;}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 devices\:.PRINTER}}}{\v\fs20 .PRINTER driver;}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 printers\:.PRINTER driver}}}{\fs20 This installs the .PRINTER driver, a GS/OS driver and accompanying Init, CDev and CDA that allows you to print to any standard text printer from GSoft\~BASIC. Install this driver for all versions of GSoft\~BASIC. See Chapter 4 for a description of the driver.\par {\*\bkmkend bk0}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 installing GSoft\~BASIC}{\rxe bk0}}}{\v\fs20 \par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 The Three Worlds of GSoft\~BASIC}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 The Three Worlds of GSoft\~BASIC\tcl2}}}{\fs48 \par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 The GSoft\~BASIC Shell}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 The GSoft\~BASIC Shell\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 shell\:GSoft\~BASIC}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 Finder\:running GSoft\~BASIC from}}}{\fs20 This manual describes using GSoft\~BASIC from the GSoft\~BASIC shell, a complete, self contained programming environment that launches directly from the Finder. It\rquote s essentially the classic Applesoft\~BASIC}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 Applesoft\~BASIC}}}{\fs20  programming environment on steroids. Most of the familiar old commands are there, along with some nice new ones, like the full screen editor.\par Incidentally, shell}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 shell}}}{\fs20  is the name for a program that lets you type commands like CATALOG, then carries them out.\par This is a great programming environment for hacking out quick solutions to problems, learning to program, and writing mid-sized text and graphics programs. It starts to fall a little short if you decide to write desktop programs, mostly because you need some way to create resource forks, and you can\rquote t do that from within the GSoft\~BASIC shell.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Using GSoft\~BASIC from the ORCA Shell}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Using GSoft\~BASIC from the ORCA Shell\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 shell\:ORCA}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ORCA shell}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 resources}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 Rez}}}{\fs20 The ORCA programming languages ship with a much more advanced shell. There are three advantages of this shell over the GSoft\~BASIC shell. First, the ORCA shell supports Apple\rquote s Rez compiler, which is one way to create resource forks for desktop programs. The second advantage is that the ORCA shell doesn\rquote t reformat your programs like the GSoft\~BASIC shell. (Some people may not consider that an advantage!) The program is saved in an ORCA SRC file, which saves the source code as ASCII characters; these source files are left in exactly the format you type them. Finally, if your program needs user tools, you can develop the user tool and the GSoft\~BASIC application from the ORCA shell.\par There are several disadvantages, though. First, the ORCA shell is larger, so it needs more RAM}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 RAM}}}{\fs20  and disk space. It\rquote s also harder to learn to use, mostly because of the sheer number of commands and features. GSoft\~BASIC programs start slower, because programs are stored as plain ASCII files}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ASCII files}}}{\fs20 , which must be converted to GSoft\~BASIC files before they can be executed. This conversion process more than doubles the amount of memory required, too.\par On balance, we recommend using the GSoft\~BASIC shell for most GSoft\~BASIC programming. Switch to the ORCA shell for extremely large programs, toolbox}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 toolbox}}}{\fs20  programs, or programs that need user tools.\par The ORCA shell ships with ORCA/M, ORCA/C, ORCA/Pascal, ORCA/Modula-2 and }{\i\fs20 Toolbox Programming in GSoft\~BASIC}{\fs20 .\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Creating GSoft\~BASIC Programs that Run From the Finder}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Creating GSoft\~BASIC Programs that Run From the Finder\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 Finder\:creating programs for}}}{\fs20 You may run most, if not all, of your programs directly from the GSoft\~BASIC shell, and never feel the need to launch them directly from the Finder. The MakeRuntime utility lets you convert the program to a form that will launch from the Finder, though.\par Converting the program to run from the Finder adds about 90K to the size of the disk file. The RAM}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 RAM}}}{\fs20  used to run the program actually drops, but it\rquote s not a significant difference. These programs can also run on computers where GSoft\~BASIC is not installed.\par Programs converted to run from the Finder can\rquote t be changed. You need to write and change programs from within one of the two programming environments described above.\par }\pard\plain \s26\sb40\widctlpar\adjustright \b\f4\fs36\cgrid {\sect }\sectd \lndscpsxn\sbkodd\linex0\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Chapter 3: Programming on the Apple\~II}{\f5\fs18 GS}{\f5\fs20 \par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Chapter 3 \endash  Programming on the Apple\~II}{\fs28 GS}{\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 }{\v Chapter 3 \endash  Programming on the Apple\~II}{\v\fs28 GS}{\v \tcl1}}}{\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The Apple\~II}{\fs18 GS}{\fs20  is a very flexible machine. With it, you can write programs in a traditional text environment, in a high-resolution graphics environment, or in a Macintosh-style desktop environment. GSoft\~BASIC lets you write programs for all of these environments.\par In this chapter, we will look at each of the programming environments in turn, examining how you use GSoft\~BASIC to write programs, what tools and libraries are available, and what your programs can do in each of the environments. This chapter assumes you are typing and running the programs as you go.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Text Programs}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Text Programs\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GSoft\~BASIC\:Finder version}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 text programming}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 text screen}}}{\fs20 Text programs are by far the easiest kind of programs to write. As an example, we\rquote ll create a simple text program to show how many payments will be needed to pay off a loan for any given interest rate, loan amount, and payment. The variables are placed at the top of the program as constants, so there is no input.\par This is actually the first time we have created a program from scratch in this manual, so we will go over the steps involved fairly carefully. If you aren\rquote t in the GSoft\~BASIC programming environment, start it now by launching GSoft.Sys16 from the Finder. You\rquote ll see a header and a \} character followed by the cursor; from here you can enter various commands. The commands are described in Chapter 5, but we\rquote ll go over all of the ones you will use as we write the program.\par Start by typing EDIT and pressing the return key. This puts you into the GSoft\~BASIC full screen editor. Type in the program shown below. The basic commands in the editor are pretty similar to most Apple\~II}{\fs18 GS}{\fs20  text based editors, so you may not have any trouble using it. If you need to look up a specific editor command, glance through Chapter 6. Be sure and give Command-? a try\emdash this displays an on-line help screen with common commands.\par Spacing and letter case generally aren\rquote t too critical. GSoft\~BASIC will reformat the program and convert identifiers to uppercase when you exit the editor. Also, all of the lines that start with an exclamation point are comments; you can skip them if you\rquote d like. The same is true of the DIM statements which end with a colon and an exclamation point. The colon lets you add a new statement to the same physical line, something this program uses to describe how the variables are used. You can leave off everything from the colon to the end of the line.\par With those exceptions, though, be sure to type the program exactly as you see it, especially if you are new to programming. BASIC is flexible when it reads your program. but until you know what changes are allowed, stick with formatting that you know works!\par Although the point of this example is to show you how to type in a program from scratch, it\rquote s only fair to point out that the following example is also on the GSoft disk in the folder :GSoft:Samples:Text.Samples directory. If you have installed GSoft BASIC on a hard disk, the file is in the Text.Samples folder there, too.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\pard\plain \s31\fi360\keepn\widctlpar\adjustright \v\f6\fs18\cgrid {\xe {\v\fs18 }{\v\fs18 samples\:Finance}}}{\fs18 ! ------------------------------------------------\par !\par !  Finance\par !\par !  This program prints the balance on an\par !  account for monthly payments, along with the\par !  total amount paid so far.\par !\par ! ------------------------------------------------\par !\par LOANAMOUNT = 10000.0:! amount of the loan\par PAYMENT = 600.0:! monthly payment\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 INTEREST = 15:! yearly interest (as %)\par !\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 DIM BALANCE:! amount left to pay\par DIM MONTHLYINTEREST:! multiplier for interest\par DIM PAID:! total amount paid\par DIM MONTH AS INTEGER :! month number\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 DIM USE$:! format string\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 !\par ! set up the initial values\par !\par BALANCE = LOANAMOUNT\par PAID = 0\par MONTH = 0\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 MONTHLYINTEREST = 1.0 + INTEREST / 1200.0\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 !\par ! write out the conditions\par !\par PRINT USING "Payment schedule for a loan of $$####.##";LOANAMOUNT\par PRINT USING "with monthly payments of $$##.## at an";PAYMENT\par PRINT USING "interest rate of #%.";INTEREST\par PRINT\par PRINT "    month  balance    amount paid"\par PRINT "    -----  -------    -----------"\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 USE$ = " ############## $$#########.## $$#########.##"\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 !\par ! check for payments that are too small\par !\par IF BALANCE * MONTHLYINTEREST - BALANCE >= PAYMENT THEN\par }\pard \s31\fi360\widctlpar\adjustright {\fs18   PRINT "The payment is too small!"\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 ELSE\par   WHILE BALANCE > 0\par     ! add in the interest\par     BALANCE = BALANCE * MONTHLYINTEREST\par     ! make a payment\par     IF BALANCE > PAYMENT THEN\par       BALANCE = BALANCE - PAYMENT\par       PAID = PAID + PAYMENT\par     ELSE\par       PAID = PAID + BALANCE\par       BALANCE = 0\par     END IF\par     ! update the month number\par     MONTH = MONTH + 1\par     ! write the new statistics\par     PRINT USING USE$;MONTH, BALANCE, PAID\par   WEND\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END IF\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 saving programs}}}{\fs20 Once the program is typed in, you should save it to disk. You may think you saved it when you left the editor; after all, the editor asked you if you wanted to save the changes. You only saved the working copy GSoft\~BASIC used, though\emdash there is no permanent copy on disk.\par There are three different save commands; you choose one based on whether you want to save the program in the natural format for GSoft\~BASIC, as a text file, or in the natural format for compiled programming languages. As a general rule, it\rquote s best to save the program in GSoft\~BASIC\rquote s preferred format using the SAVE command. To save your program in the same folder as GSoft\~BASIC itself, type\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 SAVE Finance\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 Of course, you can use whatever file name you prefer. If your disk is a ProDOS format disk, file names must start with a letter, and can contain up to 15 characters. The remaining characters can be letters, numbers or periods.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 If you\rquote d like to explore these commands in more depth, start with Chapter 5. The three save commands are SAVE, TSAVE and SSAVE. You\rquote ll also find details about the file formats in }{\i\fs20 Types of Files Used by GSoft\~BASIC}{\fs20 , near the beginning of the chapter. }{\i\fs20 File Names}{\fs20  in Chapter 14 goes into detail about valid file names. These chapters also discuss navigation through the directory structure of a typical disk, as well as how to type full and partial path names. You can safely skip all of those details until later, saving your programs in the same directory as GSoft\~BASIC, but even if you don\rquote t look into these topics now, it\rquote s good to know where the information is when you do need it.\par With the program safely on a disk, protected from all but the most severe accident, it\rquote s time to run your program. Type:\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 RUN\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 If you typed everything correctly, you\rquote ll see the results scroll across the screen. With the figures shown, some of the information will scroll off of the screen; you can change the interest rate, the size of the payment, or the amount of the loan to see the top lines.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 If you didn\rquote t type everything correctly you\rquote ll see some form of error message. Type EDIT to get back to the editor, make any necessary changes, leave the editor, then try the program again. Remember to SAVE occasionally to guard against disaster.\par One of the classic interactive computer games of all time will serve as our second example, giving us a chance to explore text input and accessing the Apple\~II}{\fs18 GS}{\fs20  toolbox. In this simple game, the computer will pick a distance to a target, and you pick a firing angle for a cannon. The computer then lets you know if you hit the target, or if you missed and by how much.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\pard\plain \s31\fi360\keepn\widctlpar\adjustright \v\f6\fs18\cgrid {\xe {\v\fs18 }{\v\fs18 samples\:Artillery}}}{\fs18 ! ------------------------------------------------\par !\par !  Artillery\par !\par !  This classic interactive text game lets you\par !  pick the angle of your artillery gun in\par !  an attempt to knock out the enemy position.\par !  The computer picks a secret distance. When\par !  you fire, you will be told how much you\par !  missed by, and must fire again. The object\par !  is to hit the target with the fewest shells.\par !\par ! ------------------------------------------------\par !\par BLASTRADIUS = 50.0:! maximum distance from target for a hit\par DTR = 0.01745329:! convert from degrees to radians\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 VELOCITY = 434.6:! muzzle velocity\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 !\par ! choose a distance to the target\par !\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 DISTANCE = RND (1) * 5900.0\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 !\par ! not done yet...\par !\par DONE = 0\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 TRIES = 1\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 !\par ! shoot 'til we hit it\par !\par DO\par   !\par   ! get the firing angle\par   !\par }\pard \s31\fi360\widctlpar\adjustright {\fs18   INPUT "Firing angle: ";ANGLE\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18   !\par   ! compute the muzzle velocity in x, y\par   !\par   ANGLE = ANGLE * DTR\par   VX = COS (ANGLE) * VELOCITY\par }\pard \s31\fi360\widctlpar\adjustright {\fs18   VY = SIN (ANGLE) * VELOCITY\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18   !\par   ! find the time of flight \par   ! (velocity = acceleration * flightTime, two trips)\par   !\par }\pard \s31\fi360\widctlpar\adjustright {\fs18   FLIGHTTIME = 2.0 * VY / 32.0\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18   !\par   ! find the distance \par   ! (distance = velocity * flightTime) \par   !\par }\pard \s31\fi360\widctlpar\adjustright {\fs18   X = VX * FLIGHTTIME\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18   !\par   ! see what happened...\par   !\par   IF ABS (DISTANCE - X) < BLASTRADIUS THEN\par     DONE = 1\par }\pard \s31\fi360\widctlpar\adjustright {\fs18     PRINT "A hit, after ";TRIES;\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18     IF TRIES = 1 THEN\par       PRINT " try!"\par     ELSE\par       PRINT " tries!"\par }\pard \s31\fi360\widctlpar\adjustright {\fs18     END IF\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18     SELECT CASE TRIES\par       CASE 1\par         PRINT "(A lucky shot...)"\par       CASE 2\par         PRINT "Phenomenal shooting!"\par       CASE 3\par         PRINT "Good shooting."\par       CASE ELSE\par         PRINT "Practice makes perfect - try again."\par }\pard \s31\fi360\widctlpar\adjustright {\fs18     END SELECT\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18   ELSE IF DISTANCE > X THEN\par }\pard \s31\fi360\widctlpar\adjustright {\fs18     PRINT USING "You were short by # feet.";DISTANCE - X\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18   ELSE\par     PRINT USING "You were over by # feet.";X - DISTANCE\par }\pard \s31\fi360\widctlpar\adjustright {\fs18   END IF\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18   TRIES = TRIES + 1\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 LOOP WHILE NOT DONE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par When you run the program, you will see a prompt for the firing angle followed by a white box. This white box is the cursor used by interactive text programs. It lets you know that input is expected by the program. If you make a mistake, you can use the delete key to back space over your input. In fact, you can use all of the line editing commands available when you are typing lines in the GSoft\~BASIC shell. These commands are summarized in Chapter 5, }{\i\fs20 The}{\fs20  }{\i\fs20 Line Editor}{\fs20 .\par If you get stuck in the middle of the program, or just get bored with it, you can stop the program by holding down the control key and pressing C or by holding down the command key (the one with the clover shape) and pressing the period key.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Console Control Codes}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Console Control Codes\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 console device}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 standard output}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 output}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 text screen}}}{\fs20 When you are writing text programs that will execute on a text screen, one of the things you should know about are the console control codes. These are special characters that, when written to the standard text output device, cause specific actions to be taken. Using console control codes, you can beep the speaker, move the cursor, or even turn the cursor off. The console control codes are covered in Appendix B.\par Keep in mind that these console control codes only work with the text screen. You can write text to a variety of places, such as printers, the graphics screen, or disk files, but the console control codes only work with the text display device. There is more than one console, too. }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 shell\:GSoft\~BASIC}}}{\fs20 The codes shown in Appendix B apply to the console driver built into GSoft\~BASIC. }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 shell\:ORCA}}}{\fs20 If you are running GSoft\~BASIC from the ORCA shell, or from some other ORCA compatible shell, you should refer to the documentation for that shell to find out which console it uses and what control codes are available.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Stand-Alone Programs}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Stand-Alone Programs\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 So far, our examples have executed from GSoft\~BASIC\rquote s shell, or perhaps you installed GSoft\~BASIC in the ORCA shell and executed it from there. Either way, the program can\rquote t be used by someone who does not own GSoft\~BASIC.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 Finder\:creating programs for}}}{\fs20 There is a third version of GSoft\~BASIC that is designed to run from the Finder, but it isn\rquote t one you can use to write programs. Instead, you use the MakeRuntime utility, described in the next chapter, to create an application you can run from the Finder using a program you\rquote ve already written. Of course, these programs can also run from other program launchers, as long as they can run programs designed to run from Apple\rquote s Finder.\par You might think that you have to write a program with pull down menus, windows, and the whole toolbox interface before it can run from the Finder, but that simply isn\rquote t true. GSoft\~BASIC runs from the Finder, after all, and it uses a text interface. The fact is, you can run any GSoft\~BASIC program from the Finder after attaching the run-time module to the program with MakeRuntime. The Artillery program you just typed in is a great program to try this with.\par There is one, and only one, problem you have to keep in mind when converting text programs to run under the Finder. In a text environment like GSoft\~BASIC\rquote s shell, you generally end a text program by simply letting it finish, just like our Finance program did. That works well in a text environment, but not from the Finder. As soon as the program finishes, it returns to the Finder, and you can\rquote t see the text screen anymore! If a program presents information and quits, like the Finance example, be sure to use a statement like\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 INPUT "Press the RETURN key to return to the Finder."; A$\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 at the end of the program.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Graphics Programs}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Graphics Programs\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A large subset of programs need to display graphics information of some kind, but aren\rquote t necessarily worth the effort of writing a complete desktop program. These include simple fractal programs, programs to display graphs, slide show programs, and so forth. In this book, these programs are called graphics programs.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Your First Graphics Program}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Your First Graphics Program\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 graphics environment}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 HGR statement}}}{\fs20 Writing a graphics program with GSoft\~BASIC is really quite easy. In general, all you have to do is switch to the graphics display with the HGR statement and issue QuickDraw\~II}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 QuickDraw\~II}}}{\fs20  commands. QuickDraw\~II is the largest and most commonly used tool in the Apple II}{\fs18 GS}{\fs20  toolbox}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 toolbox}}}{\fs20 , so it\rquote s also a good place to get started along the road to writing desktop programs. For extremely simple tasks, like drawing fractals or plotting graphs, you might even be able to get by with the commands built into GSoft\~BASIC. They are described in Chapter 15.\par If you want to use the extended graphics commands available in QuickDraw\~II, you will need a copy of }{\i\fs20 Apple\~II}{\i\fs18 GS}{\i\fs20  Toolbox Reference , Volume 2}{\fs20 . This book was written by Apple Computer, and is published by Addison Wesley; reprints are available from the Byte Works, Inc. While the toolbox reference manual is a reference, and thus not an easy book to read, it is essential that you have a copy to answer your specific questions about the toolbox. This section shows a couple of examples so you know how to create graphics programs using GSoft\~BASIC, but there is a lot more to QuickDraw\~II than you see here.\par Our first QuickDraw II sample, which draws spirals on the graphics screen, shows the commands MOVETO, which initializes the place where QuickDraw\~II will start drawing from (called the pen location), and LINETO, which draws a line from the current pen location to the specified spot, moving the pen location in the process.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 HGR\par THETA = 0.0\par R = 100.0\par MOVETO (320, 100)\par WHILE R > 0.0\par   THETA = THETA + 3.1415926535 / 20.0\par   LINETO (CINT (COS (THETA) * R * 1.6) + 160, CINT (SIN (THETA) * R) + 100)\par   R = R - 0.15\par WEND\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 GET S$\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par Save the program as Spiral, then run it. Keep in mind that the program waits for you to press a key after it finishes; this gives you a chance to stare at the pretty picture before it goes away.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Programming on the Desktop}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Programming on the Desktop\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Most people we talk to want to write programs that use Apple\rquote s desktop interface. These programs are the ones with }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 menu bar}}}{\fs20 menu bars, multiple windows}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 windows}}}{\fs20 , and the friendly user interface popularized by the Macintosh computer. If you fall into that group of people, this section will tell you how to get started.\par Anyone who tells you that writing desktop programs is easy, or can be learned by reading a few short paragraphs, or even a chapter or two of a book, is probably a descendent of someone who sold snake oil to your grandmother to cure her arthritis. It just isn\rquote t so. Learning the Apple\~II}{\fs18 GS}{\fs20  toolbox well enough to write commercial-quality programs is every bit as hard as learning a new programming language. In effect, that\rquote s exactly what you will be doing. The Apple\~II}{\fs18 GS}{\fs20  Toolbox Reference Manuals come in four large volumes. Most of the pages are devoted to brief descriptions of the tool calls\emdash about one call per page. It takes time to learn about all of those calls. Fortunately, you don\rquote t have to know about each and every call to write desktop programs.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Learning the Toolbox}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Learning the Toolbox\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 toolbox\:learning}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 As we mentioned, learning to write desktop programs takes about the same amount of time and effort as learning to program in BASIC. If you don\rquote t already know how to program in BASIC, learn BASIC first! Concentrate on text and graphics programs until you have mastered the language, and only then move on to desktop programming.\par This doesn\rquote t mean that you need to know everything there is to know about BASIC, but you should feel comfortable writing programs that are a few hundred lines long, and you should understand how to use records and pointers, since the toolbox makes heavy use of these features. There is a companion course for GSoft\~BASIC called }{\i\fs20 Learn to Program in GSoft\~BASIC}{\fs20 . It teaches you BASIC and some fundamental concepts like sorting, linked lists, and dealing with files. It\rquote s written specifically for this language and the Apple\~II}{\fs18 GS}{\fs20 ; it\rquote s a great place to start. If you would like more information about this course, contact the Byte Works, Inc.\par The toolbox itself is very large. The }{\i\fs20 Apple\~II}{\i\fs18 GS}{\i\fs20  Toolbox Reference Manual}{\fs20  is a three volume set that is basically a catalog of the hundreds of tool calls available to you. These three volumes cover the tools up through System 5.0; the additions in System 6.0 and 6.0.1 are covered in }{\i\fs20 Programmer\rquote s Reference for System 6.0.1}{\fs20 , available from the Byte Works. This four-volume set is an essential reference when you are writing your own toolbox programs. If your file input and output needs are advanced, you may also need to add }{\i\fs20 Apple\~II}{\i\fs18 GS}{\i\fs20  GS/OS}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\i\v\fs20 GS/OS}}}{\i\fs20  Reference}{\fs20 , available as a reprint from the Byte Works, Inc. A lot of people have tried to write toolbox programs without these manuals. I can\rquote t name a single one that succeeded.\par A lot of people have been critical of the toolbox reference manuals because they do not teach you to write toolbox programs, but that\rquote s a lot like being critical of the Oxford English Dictionary because it doesn\rquote t teach you how to write a book. The toolbox reference manuals are a detailed, technical description of the toolbox, not a course teaching you how to use the tools. }{\i\fs20 Toolbox Programming in GSoft\~BASIC}{\fs20  does teach you the toolbox, though. This self-paced course also includes an abridged toolbox reference manual, so you can learn to use the toolbox before you spend a lot of money buying the four volume toolbox reference manual. This course is also available from the Byte Works, Inc.\par All of this is not meant to frighten you away. Anyone who can learn a programming language can learn to write desktop programs. Unfortunately, too many people approach desktop programming with the attitude, fostered by some books and magazine articles, that they can learn to write desktop programs in an evening, or at most a weekend. This leads to frustration and usually failure. If you approach desktop programming knowing it will take some time, but willing to invest that time, you will succeed.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Hardware Requirements}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Hardware Requirements\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Most programming languages use individual tool interface files, one per tool; these interface files are often plain typed text. This takes a lot of room, and as a result, you really need a hard drive to write toolbox}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 toolbox}}}{\fs20  programs with those languages. GSoft\~BASIC is different. You can write toolbox programs on any computer with two 800K floppy disk drives\emdash text programs are easy to write on a computer with just one 800K floppy disk drive. We still recommend a hard drive, though. It makes your computer boot faster, and gives you lots of workspace.\par The biggest problem with toolbox programming using GSoft\~BASIC is that you need some way to create resource forks. One way to do this is with Apple\rquote s resource compiler, which ships with all of the ORCA languages and with }{\i\fs20 Toolbox Programming in GSoft\~BASIC}{\fs20 . The big problem with Apple\rquote s resource compiler is that it requires the ORCA shell, so you\rquote re forced to use this larger, more complicated programming environment. It also comes with }{\i\fs20 Toolbox Programming in GSoft\~BASIC}{\fs20 .\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 memory\:requirements}}}{\fs20 The other thing you will need to write any large program is more than 1.25M of memory. You can squeak by with 1.25M of memory for small toolbox programs, but you\rquote ll run into memory problems before long. We recommend 2M or more of memory for toolbox programming.\par \sect }\sectd \lndscpsxn\sbkodd\linex0\endnhere\titlepg\sectdefaultcl {\headerl \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 Environment Reference Manual\par }}{\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Chapter 4: GSoft\~BASIC Utilities\par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Chapter 4 \endash  GSoft\~BASIC Utilities}{\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\v\f4\fs36\cgrid {\tc {\v Chapter 4 \endash  GSoft\~BASIC Utilities\tcl1}}}{\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 This chapter describes the various utilities and support tools that come with GSoft\~BASIC. You'll probably never use some of these utilities, while others will be useful from almost your first program.\par The .PRINTER driver is used both by BASIC itself and by the programming environment to print program listings and other pages that only contain text. You may want to look at the information about the .PRINTER driver right away.\par MakeRuntime is a utility you\rquote ll probably use eventually. It takes a BASIC program and converts it into an executable program that launches directly from the Finder, even on computers where GSoft\~BASIC is not installed. You can safely skip it until you have a program you want to convert.\par Most people will never use CompileTool, which is an advanced programmer utility used to create tool interface files for tools and user tools; and only people who already own another ORCA language can use the ORCA Shell version of GSoft\~BASIC. Skip these sections entirely if they do not apply to you.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Printing With the .PRINTER Driver}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Printing With the .PRINTER Driver\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\v\fs20 .PRINTER;}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 devices\:.PRINTER}}}{\v\fs20 {\*\bkmkstart bk1}.PRINTER driver;\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The operating system on the Apple\~II}{\fs18 GS}{\fs20  gives you a number of ways to write to a printer, but none of them can be used with standard file write commands, which is the way you would write text to a printer on many other computers. On the other hand, GS/OS}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GS/OS}}}{\fs20  does allow the installation of custom drivers, and you can use GS/OS file output commands to write to a custom driver. Our solution to the problem of providing easy to use text output to a printer is to add a custom driver called .PRINTER.\par There are two ways to use the .PRINTER driver from GSoft\~BASIC. You can print directly from your BASIC programs by opening .PRINTER as a file and writing text; this method is described in detail in }{\i\fs20 Printing}{\fs20 , found in Chapter 14. You can also list files to the printer with the PR command, described in Chapter 5. This section describes how to install and configure the printer driver for your particular printer.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Installing .PRINTER}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Installing .PRINTER\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 installer}}}{\fs20 .PRINTER is a RAM based driver, so it must be installed on your boot disk before you can use the driver. There is an installer script on the GSoft\~BASIC install disk that will copy the correct file for you.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Configuring .PRINTER}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Configuring .PRINTER\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 printers\:configuration}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 All printers are not created equal, so any printer driver must come with some method to configure the driver. By default, our printer driver is designed to handle a serial printer installed in slot 1. It prints a maximum of 80 characters on one line, after which it will force a new line, and put any remaining characters on the new line. After printing 60 lines a form feed is issued to advance the paper to the start of a new page. When a new line is needed, the driver prints a single carriage return character ($0D). If any of these options are unsuitable for your printer, you can change them using either a CDev or a CDA. Both of these programs produce a configuration file called PInit.Options, which will be placed in your System directory, so you need to be sure your boot disk is in a drive and not write protected when you configure your printer. This file is read by an init called TextPrinterInit at boot time to configure the text printer driver, which is itself a GS/OS}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GS/OS}}}{\fs20  driver called TextPrinter.\par The figures show the screens you will see when you use the .PRINTER CDev from Apple\rquote s Control panel or when you select the .PRINTER CDA from the CDA menu. The options that you can select are the same for both configuration programs; these are described below.\par \par }\pard\plain \qj\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\fs20 {\pict{\*\picprop\shplid1025{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex50\picscaley49\piccropl0\piccropr0\piccropt0\piccropb0\picw354\pich296\picwgoal7080\pichgoal5920\macpict\bliptag-178648873\blipupi72{\*\blipuid f55a08d7892449757e335e313872a595}214e00000000012801621101a00082a0008e01000a0000000002d0028098002e0000000000e701680000000000e701620000000000e70162000102d30008007fe3ff00e0f30008007fe3ff00e0f300080060e3000060f300080060e3000060f300080060e3000060f300080060e3000060f300150060f900003cfc0005700f80000007f7000060f300150060f900003cfc0005700f80000007f7000060f300170060f9000b660000300000300cc0000003f7000060f300170060f9000b660000300000300cc0000003f7000060f300190060f9000d603c7c7c6c78300cc7cf87830780f9000060f300190060f9000d603c7c7c6c78300cc7cf87830780f9000060f300180060f9000c6066663070cc300f8cccccc30cf8000060f300180060f9000c6066663070cc300f8cccccc30cf8000060f300190060f9000d6066663060cc300c0ccccfc30780f9000060f300190060f9000d6066663060cc300c0ccccfc30780f9000060f300180060f900fe660a3660cc300c0ccccc0300c0f9000060f300180060f900fe660a3660cc300c0ccccc0300c0f9000060f300190060f9000d3c3c661c6078780c07ccc7878780f9000060f300190060f9000d3c3c661c6078780c07ccc7878780f9000060f300080060e3000060f300080060e3000060f300080060e3000060f300080060e3000060f30008007fe3ff00e0f30008007fe3ff00e0f300080060e3000060f300080060e3000060f300080060e3000060f300080060e3000060f3000d016007f3ff00f8f3000060f3000d016007f3ff00f8f3000060f30010016006f6000318000018f3000060f30010016006f6000318000018f3000060f30010016006f6000318018018f3000060f30010016006f6000318018018f3000060f30010016006f6000318066018f3000060f30010016006f6000318066018f3000060f3000d016006f600fd18f3000060f3000d016006f600fd18f3000060f30010016006f6000318600618f3000060f30010016006f6000318600618f3000060f30010016006f6000319f81f98f3000060f30010016006f6000319f81f98f3000060f30014016006fd000306000020fe00fd18f3000060f30014016006fd000306000020fe00fd18f3000060f30016016006fd00031e000208fe00fd18010007e8ff01800016016006fd00031e000208fe00fd18010007e8ff01800017016006fd000366004082fe00fd18010006e9000201800017016006fd000366004082fe00fd18010006e900020180001a016006fe00040186104082fe0005181ff8180006e900020180001a016006fe00040186104082fe0005181ff8180006e900020180002c1a6006000007fe060410208000001800001800067e7fff3fffffe0fcfe00020f800cfd00001ffcff02f980002c1a6006000007fe060410208000001800001800067e7fff3fffffe0fcfe00020f800cfd00001ffcff02f980002915600600001806060410208000001ffffff80006006003fd0008300000600cc0000030f900020180002915600600001806060410208000001ffffff80006006003fd0008300000600cc0000030f900020180002d25600600001806060410208000001aaaaab800067e60033fffffe03078ccf80ccd9c7c7c3c6c1ffcff02f980002d25600600001806060410208000001aaaaab800067e60033fffffe03078ccf80ccd9c7c7c3c6c1ffcff02f980002b15600600001806060410208000001aaaaab80006006003fd000a30cc78600f8e0c66306670fb00020180002b15600600001806060410208000001aaaaab80006006003fd000a30cc78600f8e0c66306670fb00020180002d1d6006000007fe060410208000001aaaaab8001e7e60033fffffe030fc3060fe0c0466307e601ffcff02f980002d1d6006000007fe060410208000001aaaaab8001e7e60033fffffe030fc3060fe0c0466307e601ffcff02f980002b016006fe00040186104082fe00081aaaaab800f6006003fd000330c0786cfe0c0366366060fb00020180002b016006fe00040186104082fe00081aaaaab800f6006003fd000330c0786cfe0c0366366060fb00020180002c016006fd000366004082fe00181aaaaab801ce7e7fff3fffffe03078cc380c0c1e661c3c601ffcff02f980002c016006fd000366004082fe00181aaaaab801ce7e7fff3fffffe03078cc380c0c1e661c3c601ffcff02f9800019016006fd00031e000208fe00051aaaaab803bee9000201800019016006fd00031e000208fe00051aaaaab803bee9000201800019016006fd000306000020fe00051aaaaab80776e9000201800019016006fd000306000020fe00051aaaaab80776e9000201800011016006f600051aaaaab80777e8ff01800011016006f600051aaaaab80777e8ff01800012016006f600051aaaaab80766e9000201800012016006f600051aaaaab80766e9000201800018016006f600051aaaaab80776fc00feff00e0f2000201800018016006f600051aaaaab80776fc00feff00e0f2000201800019016006f600051aaaaab80766fc0003c0000060f2000201800019016006f600051aaaaab80766fc0003c0000060f2000201800019016006f600051aaaaab80776fc0003c0000060f2000201800019016006f600051aaaaab80776fc0003c0000060f2000201800021016006fe00001efe000003fe00051aaaaab80776fc0003c001e060f2000201800021016006fe00001efe000003fe00051aaaaab80776fc0003c001e060f2000201800023016006fe000033fe000003fe000e1aaaaab803be03c3800000c003307ef2000201800023016006fe000033fe000003fe000e1aaaaab803be03c3800000c003307ef2000201800023016006fe0004301e333e1ffe000e1aaaaab801ce0661800300c000307ef2000201800023016006fe0004301e333e1ffe000e1aaaaab801ce0661800300c000307ef2000201800021016006fe00001efd33fe000e1aaaaab800f6060183c7c0c000607ef2000201800021016006fe00001efd33fe000e1aaaaab800f6060183c7c0c000607ef2000201800021016006fe000003fd33fe000e1aaaaab8001e03c1866300c000c07ef2000201800021016006fe000003fd33fe000e1aaaaab8001e03c1866300c000c07ef200020180001f016006fe00fc33fe000e1aaaaab800060061866300c001807ef200020180001f016006fe00fc33fe000e1aaaaab800060061866300c001807ef2000201800023016006fe00041e1e1f331ffe000e1aaaaab800060661866360c003f07ef2000201800023016006fe00041e1e1f331ffe000e1aaaaab800060661866360c003f07ef200020180001b016006f6000e1aaaaab8000603c3c3c1c0c000007ef200020180001b016006f6000e1aaaaab8000603c3c3c1c0c000007ef2000201800019016006f600051aaaaab80006fc0003c000007ef2000201800019016006f600051aaaaab80006fc0003c000007ef2000201800018016006f600051aaaaab80006fc00feff00fef2000201800018016006f600051aaaaab80006fc00feff00fef2000201800019016006f600051aaaaab80006fc000307fffffef2000201800019016006f600051aaaaab80006fc000307fffffef2000201800012016006f600051aaaaab80006e9000201800012016006f600051aaaaab80006e9000201800018016006fe00fe550050fd00051aaaaab80006e9000201800018016006fe00fe550050fd00051aaaaab80006e9000201800018016006fe00fe550054fd00051aaaaab80006e9000201800018016006fe00fe550054fd00051aaaaab80006e9000201800016016006fe00fd55fd00051aaaaab80006e9000201800016016006fe00fd55fd00051aaaaab80006e9000201800020016006fe00fd550040fe00051aaaaab8000ef300003ffdff00e0fd000201800020016006fe00fd550040fe00051aaaaab8000ef300003ffdff00e0fd000201800020016006fe00fd550040fe00051aaaaab8003ef3000030fd000060fd000201800020016006fe00fd550040fe00051aaaaab8003ef3000030fd000060fd000201800023016006fe00fd550040fe00071aaaaab800760603f50005303c1e000060fd000201800023016006fe00fd550040fe00071aaaaab800760603f50005303c1e000060fd000201800022016006fe00fd550040fe00061aaaaab8006606f40005306026000060fd000201800022016006fe00fd550040fe00061aaaaab8006606f40005306026000060fd00020180002c016006fe00fd550040fe00191aaaaab8007606071f0f0f01f0f1b03e1f1f1e00307c66000060fd00020180002c016006fe00fd550040fe00191aaaaab8007606071f0f0f01f0f1b03e1f1f1e00307c66000060fd00020180002b016006fe00fd550040fe000e1aaaaab800660603199998019999c0fd330600306666000060fd00020180002b016006fe00fd550040fe000e1aaaaab800660603199998019999c0fd330600306666000060fd00020180002c016006fe00fd550040fe000e1aaaaab800760603199f8f0199f980fe33073f00306666000060fd00020180002c016006fe00fd550040fe000e1aaaaab800760603199f8f0199f980fe33073f00306666000060fd00020180002c016006fe00fd550040fe00191aaaaab8006606031998018199818033331f3000306664000060fd00020180002c016006fe00fd550040fe00191aaaaab8006606031998018199818033331f3000306664000060fd00020180002b046006000015fc55fe00191aaaaab8007607e7998f0f01f0f1803e1f231e00303c78000060fd00020180002b046006000015fc55fe00191aaaaab8007607e7998f0f01f0f1803e1f231e00303c78000060fd000201800029046006000015fc55085000001aaaaab8003efc00090180000030001e000030fd000060fd000201800029046006000015fc55085000001aaaaab8003efc00090180000030001e000030fd000060fd000201800020046006000015fc55085000001aaaaab8000ef300003ffdff00e0fd000201800020046006000015fc55085000001aaaaab8000ef300003ffdff00e0fd000201800018046006000015fc55085000001aaaaab80006e9000201800018046006000015fc55085000001aaaaab80006e9000201800018046006000015fc55085000001aaaaab80006e9000201800018046006000015fc55085000001aaaaab80006e9000201800017046006000015fc55fe00051aaaaab80006e9000201800017046006000015fc55fe00051aaaaab80006e9000201800017046006000015fc55fe00051aaaaab80006e9000201800017046006000015fc55fe00051aaaaab80006e9000201800017046006000015fc55fe00051aaaaab80006e9000201800017046006000015fc55fe00051aaaaab80006e9000201800019016006f600051aaaaab80006f1000003fdff05fe000001800019016006f600051aaaaab80006f1000003fdff05fe000001800019016006f600051aaaaab80006f1000003fd000506000001800019016006f600051aaaaab80006f1000003fd00050600000180002a0260063ffe000203e003fd00091aaaaab8000603c00380fa00010383fe000a03000180000600000180002a0260063ffe000203e003fd00091aaaaab8000603c00380fa00010383fe000a03000180000600000180002b1660060c000018033000000c00001aaaaab8000606600180fa00010180fe000a03000780000600000180002b1660060c000018033000000c00001aaaaab8000606600180fa00010180fe000a03000780000600000180002f2d60060c1e333e0333671f1f0f1b1aaaaab800060603c1866fe3e1e03e1e3601871f0f0003000180000600000180002f2d60060c1e333e0333671f1f0f1b1aaaaab800060603c1866fe3e1e03e1e3601871f0f0003000180000600000180002f1160060c331e1803e383198c199c1aaaaab800fe061861866db3330033333801831999800307e180000600000180002f1160060c331e1803e383198c199c1aaaaab800fe061861866db3330033333801831999800307e180000600000180002f0560060c3f0c18fe0308198c1f981aaaaab800fe061861866db331e0333f300183199f8003000180000600000180002f0560060c3f0c18fe0308198c1f981aaaaab800fe061861866db331e0333f300183199f8003000180000600000180002f0560060c301e1bfe0324198d98181aaaaab80006066661866db33030333030018319980003000180000600000180002f0560060c301e1bfe0324198d98181aaaaab80006066661866db33030333030018319980003000180000600000180002f1360060c1e330e03030799870f181aaaaab8000603fec316edb331e03e1e3003c7998f00030007e0000600000180002f1360060c1e330e03030799870f181aaaaab8000603fec316edb331e03e1e3003c7998f00030007e0000600000180001d016006f600051aaaaab80006f9000030fa000003fd00050600000180001d016006f600051aaaaab80006f9000030fa000003fd000506000001800019016006f600051aaaaab80006f1000003fdff05fe000001800019016006f600051aaaaab80006f1000003fdff05fe000001800012016006f600051ffffff80006e9000201800012016006f600051ffffff80006e9000201800012016006f600051e0000780006e9000201800012016006f600051e0000780006e9000201800017016006fd000103fffc00051e0000780006e9000201800017016006fd000103fffc00051e0000780006e900020180001f016006fd0002fe01fcfd00051e0000780006f800001ff6ff05c000000180001f016006fd0002fe01fcfd00051e0000780006f800001ff6ff05c0000001800021016006fe00040780500780fe00051e0000780006f8000018f60005c0000001800021016006fe00040780500780fe00051e0000780006f8000018f60005c0000001800021016006fe00041800500060fe00051e0000780006f8000018f60005c0000001800021016006fe00041800500060fe00051e0000780006f8000018f60005c0000001800029016006fe00046000000618fe00051e0000780006f8001118000cf800380000e0018000c0000001800029016006fe00046000000618fe00051e0000780006f8001118000cf800380000e0018000c000000180002f016006fe0004e00780181cfe00091e000078000607c00380fe0013607c180018cc0060000060c0c000fc00000180002f016006fe0004e00780181cfe00091e000078000607c00380fe0013607c180018cc0060000060c0c000fc00000180002f0960060000018007806006fe00201e0000780006066001800300006060180030cc78f8f99861f06000fc00000180002f0960060000018007806006fe00201e0000780006066001800300006060180030cc78f8f99861f06000fc00000180002f0960060000038001e18007fe00201e00007800060663c183c7c3c06060180060cccc61999860c03000fc00000180002f0960060000038001e18007fe00201e00007800060663c183c7c3c06060180060cccc61999860c03000fc00000180002f2d60060000060001e600018000001e0000780006066661866306606078180030ccfc61999860c06000fc00000180002f2d60060000060001e600018000001e0000780006066661866306606078180030ccfc61999860c06000fc00000180002f2d600600000650007800518000001e00007800060667e187e307e06060180018ccc061999860d8c000fc00000180002f2d600600000650007800518000001e00007800060667e187e307e06060180018ccc061999860d8c000fc00000180002f2d600600000650007800518000001e000078000606660186036600606018000cf87860f8f8f0718000fc00000180002f2d600600000650007800518000001e000078000606660186036600606018000cf87860f8f8f0718000fc000001800026046006000006fd000a018000001e000078000607fec305c1c3c07e6018f60005fc000001800026046006000006fd000a018000001e000078000607fec305c1c3c07e6018f60005fc00000180002105600600000380fe000007fe00051e0000780006f8000018f60005fc00000180002105600600000380fe000007fe00051e0000780006f8000018f60005fc00000180002105600600000180fe000006fe00051e0000780006f800001ff6ff05fc00000180002105600600000180fe000006fe00051e0000780006f800001ff6ff05fc00000180001f016006fe000080fe00001cfe00051e0000780006f700f6ff05fc00000180001f016006fe000080fe00001cfe00051e0000780006f700f6ff05fc00000180001a016006fe000060fe000018fe00051e0000780006e900020180001a016006fe000060fe000018fe00051e0000780006e900020180001a016006fe00041800500060fe00051e0000780006e900020180001a016006fe00041800500060fe00051e0000780006e9000201800022016006fe00040780500780fe00051e0000780006fb00001ff6ff0080fc000201800022016006fe00040780500780fe00051e0000780006fb00001ff6ff0080fc000201800021016006fd0002fe01fcfd00051e0000780006fb000018f700010180fc000201800021016006fd0002fe01fcfd00051e0000780006fb000018f700010180fc000201800020016006fd000103fffc00051e0000780006fb000018f700010180fc000201800020016006fd000103fffc00051e0000780006fb000018f700010180fc000201800022016006f600051ffffff80006fb000c18000cf800380000e001800180fc000201800022016006f600051ffffff80006fb000c18000cf800380000e001800180fc000201800025016006f600071ffffff8000603c0fe600d7c180018cc0060000060c0c001f8fc000201800025016006f600071ffffff8000603c0fe600d7c180018cc0060000060c0c001f8fc000201800029016006fe000203f180fc000618000018000606fc600c180030cc78f8f99861f06001f8fc000201800029016006fe000203f180fc000618000018000606fc600c180030cc78f8f99861f06001f8fc000201800029016006fd0000c0fb0018181ff81800060663e3e06060180060cccc61999860c03001f8fc000201800029016006fd0000c0fb0018181ff81800060663e3e06060180060cccc61999860c03001f8fc00020180002a016006fd0003c39fc3c0fe00fd18140006066666606078180030ccfc61999860c06001f8fc00020180002a016006fd0003c39fc3c0fe00fd18140006066666606078180030ccfc61999860c06001f8fc00020180002a016006fd0003c19b6660fe00fd1804000607e666fe600c180018ccc061999860d8c001f8fc00020180002a016006fd0003c19b6660fe00fd1804000607e666fe600c180018ccc061999860d8c001f8fc00020180002a016006fd0003c19b67e0fe00fd18040006066666fe600c18000cf87860f8f8f0718001f8fc00020180002a016006fd0003c19b67e0fe00fd18040006066666fe600c18000cf87860f8f8f0718001f8fc000201800024016006fd0002c19b66fd000c19f81f9800060663e3e07e6018f7000101f8fc000201800024016006fd0002c19b66fd000c19f81f9800060663e3e07e6018f7000101f8fc000201800022016006fd0003c3db63c0fe0005186006180006fb000018f7000101f8fc000201800022016006fd0003c3db63c0fe0005186006180006fb000018f7000101f8fc000201800018016006f600fd18010006fb00001ff6ff00f8fc000201800018016006f600fd18010006fb00001ff6ff00f8fc000201800018016006f60005180660180006fa00f6ff00f8fc000201800018016006f60005180660180006fa00f6ff00f8fc000201800098002e00e700000128016800e700000128016200e7000001280162000112016006f60005180180180006e9000201800012016006f60005180180180006e9000201800012016006f60005180000180006e9000201800012016006f60005180000180006e9000201800015016007f3ff02f80006f600fcff00e0fa000201800015016007f3ff02f80006f600fcff00e0fa0002018000140060f0000006f60000c0fd000060fa0002018000140060f0000006f60000c0fd000060fa0002018000140060f0000006f60000c0fd000060fa0002018000140060f0000006f60000c0fd000060fa000201800015007ff0ff00fef60005c00330000060fa000201800015007ff0ff00fef60005c00330000060fa000201800019ef00020607e0fc00090823c7c0c0033000007efa000201800019ef00020607e0fc00090823c7c0c0033000007efa000201800019ef0002060180fc00090c666660c00331e1e07efa000201800019ef0002060180fc00090c666660c00331e1e07efa00020180001bef001106018666cf8078f80ee60660c001e333007efa00020180001bef001106018666cf8078f80ee60660c001e333007efa00020180001bef0011060186670cc0cccc0fe3c7c0c000c3f1e07efa00020180001bef0011060186670cc0cccc0fe3c7c0c000c3f1e07efa00020180001bef0011060186660cc0cccc0d606660c000c300307efa00020180001bef0011060186660cc0cccc0d606660c000c300307efa00020180001bef0011060186660cc0cccc0c666660c000c1e1e07efa00020180001bef0011060186660cc0cccc0c666660c000c1e1e07efa00020180001aef000c060183e60cc078cc0c63c7c0c0fd00007efa00020180001aef000c060183e60cc078cc0c63c7c0c0fd00007efa000201800012ef000006f60000c0fd00007efa000201800012ef000006f60000c0fd00007efa000201800010ef000006f600fcff00fefa000201800010ef000006f600fcff00fefa000201800012ef000006f6000007fdff00fefa000201800012ef000006f6000007fdff00fefa00020180000aef000006e900020180000aef000006e900020180000aef000006e900020180000aef000006e900020180000aef000006e900020180000aef000006e900020180000eef000006f6000003f5ff02c180000eef000006f6000003f5ff02c180000fef000006f600010308f60002c180000fef000006f600010308f60002c1800017ef000d0603c0030000f000018000000308f60002c1800017ef000d0603c0030000f000018000000308f60002c1800016ef0007060180000c0198c0fd00010308f60002c1800016ef0007060180000c0198c0fd00010308f60002c1800017ef000d060187c71f0181f1b38f87c00308f60002c1800017ef000d060187c71f0181f1b38f87c00308f60002c1800017ef000d060186630c00f0c1c18cccc00308f60002c1800017ef000d060186630c00f0c1c18cccc00308f60002c1800017ef000d060186630c0018c1818cccc00308f60002c1800017ef000d060186630c0018c1818cccc00308f60002c1800017ef000d060186630d8198d9818cc7c00308f60002c1800017ef000d060186630d8198d9818cc7c00308f60002c1800017ef000d0603c6678700f07183ccc8c00308f60002c1800017ef000d0603c6678700f07183ccc8c00308f60002c1800011ef000006f8000307800308f60002c1800011ef000006f8000307800308f60002c180000eef000006f6000003f5ff02c180000eef000006f6000003f5ff02c180000aef000006e900020180000aef000006e9000201800009ef000007e8ff01800009ef000007e8ff01800002d300a0008fa00083ff}\tab }{\fs20 {\pict{\*\picprop\shplid1026{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex50\picscaley50\piccropl0\piccropr0\piccropt0\piccropb0\picw388\pich328\picwgoal7760\pichgoal6560\macpict\bliptag-754937582\blipupi72{\*\blipuid d3009112b3cda63b5ebf15d2d160b5b7}1831ffffffff014701831101a10064000c574f5244ffffffff0147018301000affffffff01470183980032000000000146018800000001014601830000000001460182000107007fd2ff01e00007007fd2ff01e000070060d200016000070060d200016000280560001f9f8798fedf03801f8003fd00040f80000703fd00090300c0000003001f000cf500016000280560001f9f8798fedf03801f8003fd00040f80000703fd00090300c0000003001f000cf500016000260b600018d8c318c31818c018c0fc000418c0000d80fd000003fd0004070031801cf500016000260b600018d8c318c31818c018c0fc000418c0000d80fd000003fd0004070031801cf5000160002a23600018d8c31cc31818c018dbc718cf9bc0180f9f8c070f98c6f3e7e1c3e7e0030033800cf5000160002a23600018d8c31cc31818c018dbc718cf9bc0180f9f8c070f98c6f3e7e1c3e7e0030033800cf5000160002a2360001f9f831ac31f9f8018dc0318d8dc001818d8df8318d8c7003300c63630030035800cf5000160002a2360001f9f831ac31f9f8018dc0318d8dc001818d8df8318d8c7003300c63630030035800cf5000160002a236000181b0319c3181b0018d80318dfd8001818d8cc0318d8c603f300c63630030039800cf5000160002a236000181b0319c3181b0018d80318dfd8001818d8cc0318d8c603f300c63630030039800cf5000160002a23600018198318c318198018d8030d98180018d8d8cc030fd9c6063330c63630030031800cf5000160002a23600018198318c318198018d8030d98180018d8d8cc030fd9c6063330c63630030031800cf5000160002a23600c1818c798c31fd8c01f9807870fd8000f8f98cc0780cec603f1e1e3e63007831f061ef5000160002a23600c1818c798c31fd8c01f9807870fd8000f8f98cc0780cec603f1e1e3e63007831f061ef5000160000c0060ec00010f80e9000160000c0060ec00010f80e90001600007007fd2ff01e00007007fd2ff01e000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d20001600010096000c03078fff3ffe003db0001600010096000c03078fff3ffe003db0001600010096000c0273cfff3ffe007db0001600010096000c0273cfff3ffe007db00016000100960018027fcf0607ce003db00016000100960018027fcf0607ce003db000160001009601980307ce733ffe003db000160001009601980307ce733ffe003db000160001009600f003f3ce733fce003db000160001009600f003f3ce733fce003db000160001009600600273ce7333fe003db000160001009600600273ce7333fe003db00016000110a600600307870787fe00780dc00016000110a600600307870787fe00780dc000160000e036000003ffdff00e0da000160000e036000003ffdff00e0da0001600011046000c01803f3000203cf80e70001600011046000c01803f3000203cf80e70001600010036000c018f200020e18c0e70001600010036000c018f200020e18c0e7000160001c0d60018018071f8f8f801f8f9bc01ffe8f0483001819c0e7000160001c0d60018018071f8f8f801f8f9bc01ffe8f0483001819c0e7000160001c15601980180318d8d80018d8dc0018c0d8d8c0001f9ac0e7000160001c15601980180318d8d80018d8dc0018c0d8d8c0001f9ac0e7000160001c15600f00180318dfcf8018dfd80018cfd8dfc30018dcc0e7000160001c15600f00180318dfcf8018dfd80018cfd8dfc30018dcc0e7000160001c15600600180318d800c01f9818001f98cfd8000018d8c0e7000160001c15600600180318d800c01f9818001f98cfd8000018d8c0e7000160001c156006001fc798cfcf80180fd800180fc0cfc0000f8f80e7000160001c156006001fc798cfcf80180fd800180fc0cfc0000f8f80e700016000120060f9000018fe000318000f80e200016000120060f9000018fe000318000f80e20001600022056000c00f8007f800010703fd000d019f9f8718c000c0070000070c0cf40001600022056000c00f8007f800010703fd000d019f9f8718c000c0070000070c0cf40001600021056000c018c003f8000003fc000d0318d8cd9dc000c00d8000030c06f40001600021056000c018c003f8000003fc000d0318d8cd9dc000c00d8000030c06f4000160002922600180180f8318dddf8f801f8f9bc003071f8f83000618d8d8dac00fcf8c0f98c31f83f4000160002922600180180f8318dddf8f801f8f9bc003071f8f83000618d8d8dac00fcf8c0f98c31f83f4000160002a236019801818c318dad8d80018d8dc00030318d8c0000c1f9f98dac018d8df80d8c30c0180f5000160002a236019801818c318dad8d80018d8dc00030318d8c0000c1f9f98dac018d8df80d8c30c0180f5000160002922600f001818c318dad8cf8018dfd800030318dfc3000618db1fd8c018dfcc0fd8c30c03f4000160002922600f001818c318dad8cf8018dfd800030318dfc3000618db1fd8c018dfcc0fd8c30c03f400016000292260060018d8c319dad8c0c01f981800030318d800000318d998d8c018d80c18d9c30cc6f400016000292260060018d8c319dad8c0c01f981800030318d800000318d998d8c018d80c18d9c30cc6f40001600029226006000f8f878ed8d8cf80180fd800078798cfc000019f98d8d8c00fcfcc0fcec7878cf40001600029226006000f8f878ed8d8cf80180fd800078798cfc000019f98d8d8c00fcfcc0fcec7878cf4000160000b0060f7000018dd000160000b0060f7000018dd000160000d066000c00700c0c0d800016000280c6000c00700c0c0181fc000070cfe00110f9f8000019f9f8718c000c0070000070c0cf300016000280c6000c00d80c0c0181fc000070cfe00110f9f8000019f9f8718c000c0070000070c0cf300016000280c6000c00d80c0c0181800000d8cfe001118d8c0000318d8cd9dc000c00d8000030c06f300016000280c60018018cfcfc0181800000d8cfe001118d8c0000318d8cd9dc000c00d8000030c06f300016000282160018018cfcfc01818000f8c1f8f9bc01818c3000618d8d8dac00fcf8c0f98c31f83f300016000282160198018d8d8c01818000f8c1f8f9bc01818c3000618d8d8dac00fcf8c0f98c31f83f300016000292260198018d8d8c0181f8000df8c18dc00181f80000c1f9f98dac018d8df80d8c30c0180f4000160002922600f001fd8d8c0181f8000df8c18dc00181f80000c1f9f98dac018d8df80d8c30c0180f4000160002821600f001fd8d8c01818000fcc0c1fd800181b03000618db1fd8c018dfcc0fd8c30c03f300016000282160060018d8d8c01818000fcc0c1fd800181b03000618db1fd8c018dfcc0fd8c30c03f300016000282160060018d8d8c018180018cc0cd8180018d980000318d998d8c018d80c18d9c30cc6f300016000282160060018cfcfc018180018cc0cd8180018d980000318d998d8c018d80c18d9c30cc6f300016000282160060018cfcfc01fd8000fcc078fd8000f98c000019f98d8d8c00fcfcc0fcec7878cf300016000250060fb001a1fd8000fcc078fd8000f98c000019f98d8d8c00fcfcc0fcec7878cf300016000070060d20001600031156000c01f8007000c0000070300000c00181fc000070cfe00110f9f8000019f9f8718c000c0070000070c0cfc0001600031156000c01f8007000c0000070300000c00181fc000070cfe00110f9f8000019f9f8718c000c0070000070c0cfc0001600031156000c018c003000c00000d8000000c00181800000d8cfe001118d8c0000318d8cd9dc000c00d8000030c06fc0001600031156000c018c003000c00000d8000000c00181800000d8cfe001118d8c0000318d8cd9dc000c00d8000030c06fc00016000312a60018018cf830f9f8f800c071bcf9f801818000f8c1f8f9bc01818c3000618d8d8dac00fcf8c0f98c31f83fc00016000312a60018018cf830f9f8f800c071bcf9f801818000f8c1f8f9bc01818c3000618d8d8dac00fcf8c0f98c31f83fc00016000322b60198018d8c318cc18c01f831c180c00181f8000df8c18dc00181f80000c1f9f98dac018d8df80d8c30c0180fd00016000322b60198018d8c318cc18c01f831c180c00181f8000df8c18dc00181f80000c1f9f98dac018d8df80d8c30c0180fd00016000312a600f0018dfc31fcc1fc00c03180f8c001818000fcc0c1fd800181b03000618db1fd8c018dfcc0fd8c30c03fc00016000312a600f0018dfc31fcc1fc00c03180f8c001818000fcc0c1fd800181b03000618db1fd8c018dfcc0fd8c30c03fc00016000312a60060018d803180cd8000c031800ccc018180018cc0cd8180018d980000318d998d8c018d80c18d9c30cc6fc00016000312a60060018d803180cd8000c031800ccc018180018cc0cd8180018d980000318d998d8c018d80c18d9c30cc6fc00016000312a6006001f8fc78fc78fc00c07980f87801fd8000fcc078fd8000f98c000019f98d8d8c00fcfcc0fcec7878cfc00016000312a6006001f8f878fc78fc00c07980f87801fd8000fcc078fd8000f98c000019f98d8d8c00fcfcc0fcec7878cfc00016000070060d200016000070060d20001600012046000c01fc0fb000318cf9f80e00001600015046000c01fc0fb000618cf9f800018c0e30001600014036000c003fa00061dd8d8c00018c0e30001600014036000c003fa00061dd8d8c00018c0e30001600018116001800318dbdf800f9f801ad818c30018c0e3000160001a136001800318dbdf800f9f801ad818c3000d8f8f80e5000160001a136019800318dc18c018d8c01acf9f80000d8f8f80e50001600019126019800318dc18c018d8c01acf9f80000318d8e4000160001912600f000318d818c018d8c018c0d8c3000318d8e4000160001a13600f000318d818c018d8c018c0d8c300031fcf80e5000160001a136006000319d818c018d8c018d8d8c000031fcf80e5000160001a136006000319d818c018d8c018d8d8c000031800c0e5000160001a13600600030ed818c00f98c018cf9f8000031800c0e5000160001a13600600030ed818c00f98c018cf9f8000030fcf80e5000160000e0060f20003030fcf80e500016000070060d200016000120b6000c00780030c00000c0003dd000160001b0b6000c00780030c00000c0003fd00010180fe00000ce70001600019096000c00300000c00000cfb00010180fe00000ce70001600018096000c00300000c00000cfb000003fd000006e7000160001b10600180031f871f800f9f9bc71f8f830003fd000006e7000160001c15600180031f871f800f9f9bc71f8f8300061f8f9f8f83e7000160001c156019800318c30c00180c1c0318d8c000061f8f9f8f83e7000160001d116019800318c30c00180c1c0318d8c0000c18fed801c180e8000160001d11600f000318c30c000f8c180318d8c3000c18fed801c180e8000160001c15600f000318c30c000f8c180318d8c3000618d8d8dfc3e7000160001c156006000318c30cc000ccd80318cfc0000618d8d8dfc3e7000160001c116006000318c30cc000ccd80318cfc0000318fed80006e7000160001c116006000798c787800f87980798c0c0000318fed80006e7000160001c156006000798c787800f87980798c0c0000198cf98cfcce700016000130060f500080f80000198cf98cfcce7000160000c0060f500010f80e000016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d200016000070060d2000160000b0060d80000c0fc000160000b0060d80000c0fc000160002e0060fd00120f800700000c00000300030003000300000fc0fe00040700001fc0fe00010f80fc0000c0fc000160002e0060fd00120f800700000c00000300030003000300000fc0fe00040700001fc0fe00010f80fc0000c0fc000160002c0060fd001118c00300000c000006000180030007800018fd000303000018fd000118c0fc0000c0fc000160002c0060fd001118c00300000c000006000180030007800018fd000303000018fd000118c0fc0000c0fc00016000300060fd0025180f830f8fdf83000c0000c003000fc000180f9f8fcf830300180f8fc000180f98cf830004c0fc00016000300060fd0025180f830f8fdf83000c0000c003000fc000180f9f8fcf830300180f8fc000180f98cf830004c0fc00016000300060fd00250f98c318d80c00001fe01fe01b601b60001800d8d818c300001f981800000f80d8d8c0000cc0fc00016000300060fd00250f98c318d80c00001fe01fe01b601b60001800d8d818c300001f981800000f80d8d8c0000cc0fc000160002f0060fc001adfc31fd80c03000c0000c00fc0030000180fd8d81fc30300180f98fe0006cfd8dfc3001fc0fc000160002f0060fc001adfc31fd80c03000c0000c00fc0030000180fd8d81fc30300180f98fe0006cfd8dfc3001fc0fc000160002f0060fd002418d80318180cc0000600018007800300001818d8d8180300001800d8000018d8cd9800000cfb000160002f0060fd002418d80318180cc0000600018007800300001818d8d8180300001800d8000018d8cd9800000cfb000160002f0060fd00240f8fc78fcfc780000300030003000300000fcfd8cfcfc780001fcf8fc0000f8fc70fc00004fb000160002f0060fd00240f8fc78fcfc780000300030003000300000fcfd8cfcfc780001fcf8fc0000f8fc70fc00004fb00016000070060d200016000070060d20001600007007fd2ff01e00007007fd2ff01e000ff}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard\plain \s32\fi-1800\li2160\sb160\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx2520\adjustright \f4\cgrid {\fs20 Option\tab Description\par }\pard\plain \s25\fi-1800\li2160\sb40\widctlpar\tx2520\adjustright \f4\cgrid {\fs20 Slot\tab }{\pard\plain \s25\fi-1800\li2160\sb40\widctlpar\tx2520\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 printers\:slot}}}{\fs20 This entry is the physical slot where your printer is located.\par Lines per page\tab }{\pard\plain \s25\fi-1800\li2160\sb40\widctlpar\tx2520\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 printers\:lines per page}}}{\fs20 This entry is a single number, telling the printer driver how many lines appear on a sheet of paper. Most printers print 66 lines on a normal letter-size sheet of paper; it is traditional to print on 60 of those lines and leave the top and bottom 3 lines blank to form a margin. When the printer driver finishes printing the number of lines you specify, it issues a form-feed character ($0C), which causes most printers to skip to the top of a new page.\par \tab \tab If you set this value to 0, the printer driver will never issue a form-feed character.\par Columns per line\tab }{\pard\plain \s25\fi-1800\li2160\sb40\widctlpar\tx2520\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 printers\:characters per line}}}{\fs20 This option is a single number telling the printer driver how many columns are on a sheet of paper. Most printers print 80 columns on a normal letter-size sheet of paper. If you use a value of -1, the printer driver will never split a line. (Using the CDA configuration program, the value before 0 shows up as BRAM default; you can use the normal control panel printer configuration page to set the line length to unlimited.) What your printer does with a line that is too long is something you will have to determine by trial and error.\par Delete LF\tab }{\pard\plain \s25\fi-1800\li2160\sb40\widctlpar\tx2520\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 printers\:extra blank lines}}}{\pard\plain \s25\fi-1800\li2160\sb40\widctlpar\tx2520\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 printers\:lines overwritten}}}{\fs20 Some printers need a carriage-return line-feed character sequence to get to the start of a new line, while others only need a carriage-return. Some programs write a carriage-return line-feed combination, while others only write a carriage-return. (GSoft\~BASIC writes a simple carriage-return.) This option lets you tell the printer driver to strip a line-feed character if it comes right after a carriage-return character, blocking extra line-feed characters coming in from programs that print both characters.\par \tab \tab You can select three options here: Yes, No, or BRAM Default. The Yes option strips extra line-feeds, while the No option does not. The BRAM Default option tells the printer driver to use whatever value is in the BRAM; this is the same value you would have selected using the printer configuration program in the control panel.\par Add LF\tab }{\pard\plain \s25\fi-1800\li2160\sb40\widctlpar\tx2520\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 return characters}}}{\fs20 Some printers need a carriage-return line-feed character sequence to get to the start of a new line, while others only need a carriage-return. This option lets you tell the printer driver to add a line-feed character after any carriage-return character that is printed.\par \tab \tab You can select three options here: Yes, No, or BRAM Default. The Yes option adds a line-feeds, while the No option does not. The BRAM Default option tells the printer driver to use whatever value is in the BRAM; this is the same value you would have selected using the printer configuration program in the control panel.\par Turn on MSB\tab This line is a flag indicating whether the printer driver should set the most significant bit when writing characters to the printer. If this value is Yes the printer driver will set the most significant bit on all characters before sending the characters to the printer. If this value is No, the most significant bit will be cleared before the character is sent to the printer.\par Init string\tab }{\pard\plain \s25\fi-1800\li2160\sb40\widctlpar\tx2520\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 printers\:control characters}}}{\pard\plain \s25\fi-1800\li2160\sb40\widctlpar\tx2520\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 printers\:initialization}}}{\fs20 This option sets a printer initialization string. This string is sent to the printer when the driver is used for the first time. With most printers and interface cards there is some special code you can use to tell the printer that the characters that follow are special control codes. These codes are often used to control the character density, number of lines per page, font, and so forth. This initialization string, sent to the printer by the .PRINTER driver the first time the printer is used, is the traditional way of setting up your favorite defaults.\par \tab \tab You will find many cases when you will need to send a control character to the printer as part of this initialization string. To do that using the CDev configuration program precede the character with a tilde (~) character. For example, an escape character is actually a control-[, so you could use ~[ to send an escape character to the printer. The printer driver does not do any error checking when you use the ~ character, it simply subtracts $40 from the ASCII code for the character that follows the ~ character and sends the result to the printer. For example, g is not a control character, but ~g would still send a value, $27, to the printer. Just type the control character in the normal way from the CDA configuration program; it will show up as an inverse character on the display.\par \tab \tab The manual that comes with your printer should have a list of the control codes you can use to configure the printer.\par }\pard\plain \qj\fi360\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The .PRINTER driver is a copyrighted program. As an owner of GSoft\~BASIC, you may include .PRINTER with any program you distribute that is written in GSoft\~BASIC, so long as our copyright information is not removed. There is no licensing fee.\par }\pard\plain \qj\fi360\widctlpar\adjustright \f4\cgrid {\v\fs20 .PRINTER driver;{\*\bkmkend bk1}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 printers\:.PRINTER driver\bxe }{\rxe bk1}}}{\v\fs20 \par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 MakeRuntime}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 MakeRuntime\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 MakeRuntime utility\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The MakeRuntime utility is a very simple program that creates a version of your GSoft\~BASIC program that doesn\rquote t need GSoft\~BASIC to run.\par As you develop a program, whether you use the GSoft\~BASIC shell or the ORCA shell, you use GSoft\~BASIC itself, perhaps some compiled tool interface files, and perhaps some user tools. GSoft\~BASIC is a copyrighted program which you cannot upload or give away, but you may want to distribute your program. The MakeRuntime utility makes this possible. It places your GSoft\~BASIC program, a special version of the GSoft\~BASIC interpreter known as the GSoft\~BASIC Runtime Module, and any tool or library interfaces your program uses into a single executable file. This file is an S16 program, suitable for execution from Apple\rquote s Finder or any other program launcher that launches S16 programs.\par The process is so simple that MakeRuntime may be confusing at first because there are so few options! When you run MakeRuntime from the Finder you will see a standard Apple\~II}{\fs18 GS}{\fs20  open dialog. Select any GSoft\~BASIC program, either a tokenized file like the ones you normally create with the GSoft\~BASIC shell or an ORCA source file, and open the file. After the program loads you will see a standard Apple\~II}{\fs18 GS}{\fs20  save dialog. Type the program name, pick the destination folder, and press Save. After a few moments you\rquote ll have a GSoft\~BASIC program you can run from the Finder. Once the program is saved you\rquote ll get another open dialog, giving you a chance to convert another program. This process continues until you press Cancel.\par Once you\rquote ve pressed Cancel, you\rquote re in a very simple desktop application. You can convert more programs by selecting Make Runtime from the File menu, use desk accessories, check the version of MakeRuntime from the About box, or quit the program.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 What MakeRuntime Does}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 What MakeRuntime Does\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 MakeRuntime creates an S16 program that can be executed from pretty much any program launcher. There are several pieces that go into this completed application file.\par The first piece is your GSoft\~BASIC program itself. If it starts out as an ASCII file, it is tokenized. The tokenized source file is placed in the resource fork of the completed application file. This is stored as resource type $7FFF, resource ID $00000001.\par Your program might make use of tool calls; GS/OS calls; calls to the Talking Tools tool set; or calls to user tools, also known as libraries. MakeRuntime scans your program, creating a catalog of all of the interfaces needed, then writes a single special interface file to the resource fork. This is an abbreviated version of the complete header files contained in the various .gst files. This abbreviated version only contains the interfaces used by your program, and only contains the parts of the interfaces your program needs when it runs. These are stored as resource type $7FFF, resource ID $00000002.\par Your program might use resources of it\rquote s own. Any resources used by your program are copied from your program\rquote s resource fork to the resource fork of the application file. Since the GSoft\~BASIC program is stored in the resource fork as resource type $7FFF, ID $00000001; and the tool interfaces are stored in resource type $7FFF, ID $00000002, you should avoid that combination for any of your own resources. In general, avoid using any resource with a resource ID of $7FFF in your GSoft\~BASIC programs.\par The last piece that your program needs is GSoft\~BASIC itself, or at least enough of GSoft\~BASIC to execute your program. MakeRuntime adds a special version of GSoft\~BASIC known as the GSoft\~BASIC Runtime Module to the data fork of your application file. The original copy of the GSoft\~BASIC Runtime Module is imbedded in MakeRuntime itself; it is copied to each of your application files.\par The finished file will run from the Finder. If your program worked from the GSoft\~BASIC shell or from the ORCA shell it should also work from the Finder\emdash there are no additional requirements.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Things That Can Go Wrong}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Things That Can Go Wrong\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 There are a few things that can go wrong as you convert your GSoft\~BASIC program with MakeRuntime. Most of these are the obvious problems that can go wrong with any program\emdash out of memory errors, disk full errors, or disk input or output errors. All of these are rare, they are flagged by appropriate error messages, and as an experienced computer user, you already know what to do about them.\par There is one error that is unique to MakeRuntime, though. If your program needs tool interface files, MakeRuntime needs to find the originals. It looks in the same folders as GSoft\~BASIC, examining the ORCA libraries folder, the folder containing MakeRuntime, and the folder containing your GSoft\~BASIC program. You need to make sure the .gst files used by your program are in at least one of these locations when you use MakeRuntime. The easiest way to do this is to leave MakeRuntime in the same folder as GSoft.Sys16 if you are using the GSoft\~BASIC shell, or the same folder as ORCA.Sys16 of you are using the ORCA shell. Also, if you are using the ORCA shell, be sure you run MakeRuntime from the ORCA shell and not the Finder\emdash that way the ORCA libraries prefix is properly set when MakeRuntime executes.\par MakeRuntime will display an error dialog with the message \ldblquote Interface for tool $00, call $00 not found\rdblquote  if it can\rquote t find a tool, user tool or GS/OS interface for a call used in your program. The $00 fields are filled in with the appropriate tool or GS/OS call numbers, and the message changes slightly to identify GS/OS calls and user tools. That\rquote s your cue that you need to make sure all of the interface files are available. The error message even tells you which tool interface is missing, although you have to identify the missing .gst file by tool number, not by the file name. After all, MakeRuntime couldn\rquote t find the file, to it doesn\rquote t know the name of the file.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Including Libraries with GSoft\~BASIC Programs}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Including Libraries with GSoft\~BASIC Programs\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 If your program makes calls to a library (also called a user tool), those libraries are required for your program to function. If you distribute your program, be sure to send the library files with the program. For example, if your program makes calls to the Game Paddle Tool, you must include the file UserTool001 from the *:System:Tools: folder, and if your program makes calls to the Time Tool, you must include the file UserTool002. Tell the people who use the program that these files must be placed in the Tools folder of their System folder, and that the disk must be available when your program runs; better yet, send along an installer that puts all of the files in the correct location.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Licensing}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Licensing\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 copyright}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 licensing}}}{\fs20 The libraries contained in UserTool001 and UserTool002, as well as the GSoft\~BASIC Runtime Module, are Copyright 1998 by the Byte Works, Inc. As an owner of GSoft\~BASIC, the Byte Works, Inc. grants you a royalty free license to distribute these two libraries and programs that have the GSoft\~BASIC Runtime Module attached, so long as the GSoft\~BASIC Runtime Module is not modified in any way. The source code for the two libraries is included with GSoft\~BASIC; you may distribute modified versions of these libraries so long as the Byte Works, Inc. copyright information is not removed.\par As a condition of this royalty free license, any documentation, disks, or about boxes where copyright information is normally displayed should bear the statement\par \par }\pard \s25\qc\sb40\widctlpar\adjustright {\fs20 Portions copyright 1998, Byte Works, Inc. All rights reserved.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par This royalty free license is limited to these two files and the GSoft\~BASIC Runtime Module. No other files or documentation may be distributed in any way without the express written permission of the Byte Works, Inc.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 CompileTool}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 CompileTool\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\*\bkmkstart bk4}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 toolbox\:see also CompileTool}{\txe }}}{\*\bkmkstart bk5}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 user tools\:see also CompileTool}{\txe }}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 libraries\:see also CompileTool}{\txe }}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 libraries\:see also user tools}{\txe }}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 user tools\:see also libraries}{\txe }}}{\fs20 Before describing this utility, there are two caveats.\par First, the average BASIC programmer does not need to use or understand CompileTool. It is used by relatively advanced programmers who need to create interface files for user tools, or who have some reason to modify the tool interface files that ship with GSoft\~BASIC.\par Second, and partly due to the first, this section is written for advanced programmers. Most of this manual is written with the beginning or intermediate programmer in mind. The writer worked hard to make it easy to read, accessible, and to provide lots of examples. This section is written for the advanced programmer. An advanced programmer writing user tools already has a pretty good idea what this section is all about, and can guess many of the details. Unlike a beginning or intermediate programmer, an advanced programmer needs a concise technical description that is easy to scan for details, and that\rquote s how the description of CompileTool is written. If you are a beginning or intermediate programmer and you really need to use CompileTool, expect to spend a little more time reading the material carefully and experimenting than you need for a comparable number of pages in the rest of this book.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 What CompileTool Does}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 What CompileTool Does\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 GSoft\~BASIC programs can make tool calls, so they need to know what tool calls are available, what parameters to pass, and how to pass those parameters. The function of a tool interface file is to describe the tools to a language so it knows how to make those tool calls. Tool interface files serve this purpose; they are typed just like programs.\par One of the most time consuming parts of compiling a program in C or Pascal that uses tool calls is processing the tool interface files. Rather than force GSoft\~BASIC to process these text interface files each time it starts, we use CompileTool to predigest the interface files, writing them in a form that GSoft\~BASIC can load very quickly. CompileTool writes a compiled tool interface file with a file type of $5E and an auxiliary file type of $8007.\par For details on how GSoft\~BASIC searches for the tool interface files, see }{\i\fs20 The GSoft\~BASIC Toolbox Interface}{\fs20  in Chapter 19.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Command Line Interface}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Command Line Interface\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 user tools\:interface files}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 assembly language}}}{\fs20 CompileTool runs from the ORCA shell. It might seem odd to create a utility for GSoft\~BASIC that can't run from the Finder or from the GSoft\~BASIC shell, but the reason is straight-forward. The only common use for this tool is to create interface files for user tools. You can't create a user tool from an interpreted language like GSoft\~BASIC; it must be done from some other language, usually assembly language. A programmer writing a user tool will probably want to create the interfaces in the same environment as the user tool itself, so CompileTool was designed to work from the ORCA shell, where the assemblers and compilers work.\par The syntax for CompileTool is:\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 COMPILETOOL [-L] [-P] [-V] filename\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:flags}}}{\fs20 The flags can be coded in any order. They are:\par \par }\pard\plain \s32\li360\ri1440\sb160\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx1080\adjustright \f4\cgrid {\fs20 flag\tab use\par }\pard\plain \s25\li360\ri1440\sb40\widctlpar\tx1080\adjustright \f4\cgrid {\fs20 L\tab Writes the tool interface file to standard out as the file is compiled.\par P\tab Writes progress information as the file is compiled.\par V\tab Writes the version number and copyright message.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }{\f6\fs18 filename}{\fs20  is the name of the text tool interface file. }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:SRC}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:TXT}}}{\fs20 It can be a TXT or SRC file, and if it is an SRC file, the language stamp does not matter. By convention, the name of a tool interface file ends in .int, but this is not required.\par The output file name is based on }{\f6\fs18 filename}{\fs20 . If there is a dot in the file name, the last dot and everything after it is removed, then .gst (GSoft Tool) is added to the name. For example,\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 COMPILETOOL GSoftTools.int\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\pard\plain \s25\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:DVU}}}{\pard\plain \s25\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:file types}}}{\fs20 will create an output file named GSoftTools.gst. The output file has a file type of $5E, which prints as DVU in catalog commands. The auxiliary file type is $8007.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 CompileTool writes any error messages to the console beneath the line that caused the error, with a pointer to the offending token.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 The Syntax of Tool Interface Files}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 The Syntax of Tool Interface Files\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 This section describes the syntax for tool interface files. The first section gives an overview that describes the various parts of the tool interface file. It assumes you already know GSoft\~BASIC. Next is a concise summary of the syntax, presented as modified BNF syntax charts. The last section describes the differences between tool interface files and GSoft\~BASIC programs.\par Examples are always helpful. The tool interface file GSoftTools.int, located in :GSoft.Extras:Libraries:GSoftBASIC and the corresponding folder on your hard drive if you have installed GSoft BASIC, is the tool interface file for Apple's tools, GS/OS}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GS/OS}}}{\fs20 , the }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 shell\:ORCA}}}{\fs20 ORCA shell, and Talking Tools}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 Talking Tools}}}{\fs20 . Refer to that file for extensive examples.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Structure of a Tool Interface File}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Structure of a Tool Interface File\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Tool interface files are a series of constant, type and tool declarations. Comments may be added at any point in the tool interface file.\par }\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \f4\cgrid {\fs20 Comments\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:comments}}}{\fs20 Comments start with the semicolon character and extend to the end of the current line.\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 const maxint = 32767 ; maximum positive integer\par }\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \f4\cgrid {\fs20 Identifiers and Types\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:identifiers}}}{\fs20 Identifiers start with a letter or underscore, which may be followed by other letters, digits, or underscore characters\emdash but unlike BASIC, you cannot include a type character. Types are always given explicitly by a type statement, not assumed from a type character appended to the identifier.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:type characters}}}{\fs20 While CompileTool does not use type characters as part of the identifier, they do still have a use. Type characters can be used as a substitute for a type name anywhere the type name is allowed. For example, these declarations are completely equivalent:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 type char as byte\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 type char as ~\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par The type characters and their equivalent type generally match GSoft\~BASIC, but there is one addition. The complete list of available types is\par \par }\pard\plain \s32\li360\ri4680\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx1800\adjustright \f4\cgrid {\fs18 type\tab character}{\pard\plain \s32\li360\ri4680\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx1800\adjustright \v\f4\fs18\cgrid {\xe {\v\fs18 }{\v\fs18 CompileTool\:base types}}}{\fs18 \par }\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \f4\cgrid {\fs18 BYTE}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs18\cgrid {\xe {\v\fs18 }{\v\fs18 BYTE}}}{\fs18 \tab ~}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs18\cgrid {\xe {\v\fs18 ~}}}{\fs18 \par INTEGER}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs18\cgrid {\xe {\v\fs18 }{\v\fs18 INTEGER}}}{\fs18 \tab %}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs18\cgrid {\xe {\v\fs18 %}}}{\fs18 \par LONG}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs18\cgrid {\xe {\v\fs18 }{\v\fs18 LONG}}}{\fs18 \tab &}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs18\cgrid {\xe {\v\fs18 &}}}{\fs18 \par SINGLE}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs18\cgrid {\xe {\v\fs18 }{\v\fs18 SINGLE}}}{\fs18 \tab !}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs18\cgrid {\xe {\v\fs18 !}}}{\fs18 \par DOUBLE}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs18\cgrid {\xe {\v\fs18 }{\v\fs18 DOUBLE}}}{\fs18 \tab #}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs18\cgrid {\xe {\v\fs18 }{\txe }}}{\fs18 \par STRING}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs18\cgrid {\xe {\v\fs18 }{\v\fs18 STRING}}}{\fs18 \tab $}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs18\cgrid {\xe {\v\fs18 $}}}{\fs18 \par }\pard \s25\li360\ri4680\sb40\widctlpar\tx1800\adjustright {\fs18 UNIV\tab ?}{\pard\plain \s25\li360\ri4680\sb40\widctlpar\tx1800\adjustright \v\f4\fs18\cgrid {\xe {\v\fs18 ?}}}{\fs18 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:UNIV}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 UNIV\:see CompileTool}{\txe }}}{\fs20 UNIV is a new type, used to indicate a four byte typeless value. A UNIV record field or parameter is type compatible with any four byte value, including LONG; SINGLE; any pointer; any four byte record; and even a string, which is treated as a pointer to the first character of the string. INTEGER and BYTE values can also be assigned to UNIV record fields and passed as UNIV parameters; they are converted to LONG values.\par }\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \f4\cgrid {\fs20 Constants\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:constants}}}{\fs20 Constants assign a fixed value to a name. INTEGER and LONG constants are supported; SINGLE, DOUBLE and STRING constants are not. Identifiers declared as constants can be used both in the tool interface file and in GSoft\~BASIC programs, and have the same affect as typing the number itself.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:hexadecimal constants}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 hexadecimal}}}{\fs20 Hexadecimal constants are allowed, both in CONST declarations and in expressions throughout the tool compiler. As in GSoft\~BASIC, a hexadecimal constant with five or more digits is a LONG value, while a constant with four or fewer digits is an INTEGER.}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 $}}}{\fs20 \par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 const keyboard = $00C000 ; This value is 49152; it is a LONG\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 const keyboard2 = $C000  ; This value is -16384; it is an INTEGER\par }\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \f4\cgrid {\fs20 Named Types\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:named types}}}{\fs20 There are two kinds of type declarations. The first assigns a name to a simple type or a pointer to a simple type.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:arrays}}}{\fs20 Unlike GSoft\~BASIC, array types are allowed\emdash but in the tool compiler, arrays are limited to a single subscript.\par This series of declarations from the GSoftTools.int file show how these rules apply in actual type declarations.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 type char as byte\par type pString(256) as char\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 type pStringPtr as pointer to pString\par }\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \f4\cgrid {\fs20 Records\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:records}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:arrays}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 records}}}{\fs20 Record types generally work like they do in GSoft\~BASIC. You can substitute type characters for type names, and arrays are limited to a single subscript. With those exceptions, record types are compatible.\par }\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \f4\cgrid {\fs20 Tool Declarations\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:TOOL}}}{\fs20 Tool declarations are essentially the first line of a SUB or FUNCTION with a tool number added in front of the declaration. Here's an example from the GSoftTools.int file:\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 Tool $04, $63 SUB      PaintArc ((Rect), %, %)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:tool numbers}}}{\fs20 The tool declaration starts with the reserved word TOOL, and is followed by two values separated by a comma. The first is the tool number; QuickDraw\~II is tool number 4. The second number is the tool call number. When the tool is called from the GSoft\~BASIC program, GSoft\~BASIC will place any required parameters on the stack and do a JSL to $E10000, the main tool entry vector.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:type characters}}}{\fs20 Three of the four differences between GSoft\~BASIC declarations and tool interface files are immediately apparent in this example. The first has already been mentioned; type characters can be substituted for type names, so % can be used instead of the longer INTEGER.\par {\*\bkmkstart bk2}Names are not needed for tool parameters, since there is no body of the subroutine where the names can be put to use. As a result, parameter names are neither required nor allowed. AS is not needed to separate the parameter name from the type, so it is also omitted.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:reference parameters}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:value parameters}}}{\fs20 The third major difference is the way pass by value and pass by reference is handled. In BASIC, the calling expression determines whether a value is passed by value or by reference. If the types are identical and the calling expression passes an l-value, the parameter is passed by value; if the types are not identical, or the calling expression uses any form of an expression, the parameter is passed by reference. The same parameter can be passed by value on one call, and by reference on another. Toolbox calls don't work that way. Parameters passed by reference must always be passed as a pointer to the value, while parameters passed by value must always be placed on the calling stack as a value. As a result, tool declarations must have a way of describing whether a parameter is passed by reference or by value in the declaration itself. Parentheses around the parameter type indicate a }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parameters\:pass by reference}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parentheses}}}{\fs20 parameter is passed by reference; GSoft\~BASIC will always place the address of a value on the stack. }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parameters\:pass by value}}}{\fs20 Parameter types that are not surrounded by parentheses are always passed by value, even if the call uses an l-value with an exactly matching type for the parameter.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:record parameters}}}{\fs20 There are two special cases. Records passed by value are still passed by placing a pointer to the first byte of the record on the stack, unless the record contains exactly four bytes. In that case, the record value is pushed on the calling stack. This behavior mimics the way Apple wrote the existing toolbox calls. }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:string parameters}}}{\fs20 Strings are passed as a pointer to the first character of a null terminated string. Procedures in user tools }{\i\fs20 must not}{\fs20  change the length of the string.{\*\bkmkend bk2}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:parameters}{\rxe bk2}}}{\fs20 \par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:functions}}}{\fs20 The last difference between tool interface file declarations and GSoft\~BASIC has to do with FUNCTION declarations. You must specify the return type of a FUNCTION explicitly, as in\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TOOL $04, $52 FUNCTION NotEmptyRect ((Rect)) as Boolean\par }\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \f4\cgrid {\fs20 User Tool Declarations\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:USERTOOL}}}{\fs20 User tool declarations follow the same rules as tool declarations, but start with USERTOOL rather than TOOL. When GSoft\~BASIC calls a user tool, it does a JSL to $E10008, the main entry vector for user tools.\par }\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \f4\cgrid {\fs20 GS/OS}{\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GS/OS}}}{\fs20  Declarations\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:GSOS}}}{\fs20 GS/OS declarations also follow the same rules as tool declarations. GS/OS declarations start with the word GSOS instead of TOOL. GS/OS call numbers are two bytes long; the least significant byte is listed first, followed by the most significant byte. For example, the call number for OpenGS is $2010; the declaration looks like this:\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 GSOS $10, $20 SUB      OpenGS ((openOSDCB))\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par GSoft\~BASIC expects that all GS/OS calls will pass a single parameter by reference, and enforces that restriction. The parameter is pushed onto the stack and the call is made by a JSL to the GS/OS entry vector at $E100A8.\par }\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \f4\cgrid {\fs20 ORCA Shell Declarations\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:ORCA Shell}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 shell\:ORCA}}}{\fs20 The ORCA shell shares the GS/OS entry point and calling conventions. ORCA shell calls are declared as if the ORCA shell is an extension to GS/OS.\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 GSOS $49, $01 SUB      InitWildcardGS ((initWildcardDCBGS))\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 BNF For Tool Interface Files}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 BNF For Tool Interface Files\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 {\*\bkmkstart bk3}The complete BNF for tool interface files is shown below. The individual statements are listed in alphabetical order. The grammar starts at tool-interface.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:comments}}}{\fs20 Comments start with the semicolon character and extend to the end of the physical line. The semicolon was used instead of the exclamation point because the exclamation point is also used as the type character for SINGLE values.\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 array-subscript ::= '(' integer ')'\par \par as-type ::= [ POINTER TO ] type-name\par \par const-declaration ::= CONST identifier '=' [ '-' ] integer\par \par decimal-integer ::= [ '0'..'9' ]+\par \par field-declaration ::= identifier [ array-subscript ] AS as-type\par \par gsos-declaration ::= GSOS tool-number sub-or-function\par \par hexadecimal-integer ::= '$' [ 'A'..'F' | 'a'..'f' | '0'..'9' ]+\par \par identifier ::= letter [ letter | '0'..'9' ]*\par \par integer ::= hexadecimal-integer | decimal-integer\par \par letter ::= 'a'..'z' | 'A'..'Z' | '_'\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 record-type ::=\par    TYPE identifier\par    [ record-variant | field-declaration ]*\par }\pard \s31\fi360\widctlpar\adjustright {\fs18    END TYPE\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 parameter ::=\par      '(' as-type ')'\par }\pard \s31\fi360\widctlpar\adjustright {\fs18    | as-type\par \par parameter-list ::= '(' parameter [ ',' parameter ]* ')'\par \par record-variant ::= CASE ( identifier | integer )\par \par simple-type ::= TYPE identifier [ array-subscript ] AS as-type\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 sub-or-function ::=\par      SUB identifier parameter-list\par }\pard \s31\fi360\widctlpar\adjustright {\fs18    | FUNCTION identifier parameter-list AS as-type\par \par tool-declaration ::= TOOL tool-number sub-or-function\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 tool-interface ::= [\par      type-declaration\par    | const-declaration\par    | tool-declaration\par    | usertool-declaration\par }\pard \s31\fi360\widctlpar\adjustright {\fs18    | gsos-declaration ]*\par \par tool-number ::= integer ',' integer\par \par type-character ::= '~' | '%' | '&' | '!' | '#' | '$' | '?'\par \par type-declaration ::= simple-type | record-type\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 type-name ::= BYTE | INTEGER | LONG | SINGLE | DOUBLE | STRING \par }\pard \s31\fi360\widctlpar\adjustright {\fs18    | UNIV | identifier | type-character\par \par usertool-declaration ::= USERTOOL tool-number sub-or-function\par {\*\bkmkend bk3}}{\pard\plain \s31\fi360\widctlpar\adjustright \v\f6\fs18\cgrid {\xe {\v\fs18 }{\v\fs18 CompileTool\:BNF}{\rxe bk3}}}{\fs18 \par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Summary of Differences from GSoft\~BASIC}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Summary of Differences from GSoft\~BASIC\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The toolbox interfaces are defined for use in GSoft\~BASIC, so it makes sense that toolbox interfaces look a lot like BASIC. Actually, though, the two serve different purposes, and despite obvious similarities, they are difference languages. This section outlines the differences between GSoft\~BASIC and tool interface files, serving as a quick reference for programmers familiar with both.\par Other than the obvious difference that a tool file has declarations but no executing statements, the differences are:\par \par }\pard \s25\fi-360\li720\sb40\widctlpar\adjustright {\fs20 \bullet \tab }{\pard\plain \s25\fi-360\li720\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:constants}}}{\pard\plain \s25\fi-360\li720\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 floating-point}}}{\fs20 Strings and floating-point values are not allowed in tool interface files.\par \bullet \tab }{\pard\plain \s25\fi-360\li720\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:comments}}}{\fs20 Comments start with the semicolon character in tool interface files, and with REM or an exclamation point in GSoft\~BASIC programs. Comments can start on the same line as a declaration in a tool interface file, but must start on a fresh line or after a colon continuation character in GSoft\~BASIC.\par \bullet \tab }{\pard\plain \s25\fi-360\li720\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:arrays}}}{\fs20 Arrays in tool interface files are limited to one subscript.\par \bullet \tab }{\pard\plain \s25\fi-360\li720\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:arrays}}}{\fs20 Array types are allowed in tool interface files, but not in GSoft\~BASIC programs.\par \bullet \tab }{\pard\plain \s25\fi-360\li720\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:identifiers}}}{\pard\plain \s25\fi-360\li720\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:type characters}}}{\fs20 Types are not assumed based on the name of a variable in tool interface files, as they are in GSoft\~BASIC programs. Type characters are not allowed as part of a name in tool interface files.\par \bullet \tab }{\pard\plain \s25\fi-360\li720\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:type characters}}}{\fs20 Type characters can be substituted for type names in tool interface files; % has the same meaning as INTEGER.\par \bullet \tab }{\pard\plain \s25\fi-360\li720\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:UNIV}}}{\fs20 The UNIV type, a four byte type compatible with any other four byte entity, is allowed in tool interface files, but not in GSoft\~BASIC programs.\par \bullet \tab }{\pard\plain \s25\fi-360\li720\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:TOOL}}}{\pard\plain \s25\fi-360\li720\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:USERTOOL}}}{\pard\plain \s25\fi-360\li720\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:GSOS}}}{\fs20 TOOL, USERTOOL or GSOS precedes procedure declarations in a tool interface file. These are followed by the tool number and tool call number, or the GS/OS call number split into two bytes.\par \bullet \tab }{\pard\plain \s25\fi-360\li720\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:parameters}}}{\fs20 Parameters are given as a type in tool interface files, and as a parameter name optionally followed by a type in GSoft\~BASIC programs.\par \bullet \tab }{\pard\plain \s25\fi-360\li720\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:reference parameters}}}{\pard\plain \s25\fi-360\li720\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:parameters}}}{\pard\plain \s25\fi-360\li720\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:value parameters}}}{\fs20 Parameters passed by reference are enclosed in parentheses in tool interface files. In GSoft\~BASIC programs, the way the parameter is passed by the caller determines if it is passed by reference or by value.\par \bullet \tab }{\pard\plain \s25\fi-360\li720\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool\:functions}}}{\fs20 Function return types are required in tool interface files; function return types are assumed from the function name if the return type is not given in GSoft\~BASIC programs.\par {\*\bkmkend bk4}}{\pard\plain \s25\fi-360\li720\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 toolbox\:interface files}{\rxe bk4}}}{\*\bkmkend bk5}{\pard\plain \s25\fi-360\li720\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool}{\rxe bk5}}}{\v\fs20 \par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 ORCA Shell GSoft\~BASIC}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 ORCA Shell GSoft\~BASIC\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 shell\:ORCA}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ORCA shell}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The ORCA shell version of GSoft\~BASIC installs and runs from any ORCA\~2.0 or later shell, or from environments like GNO and APW\~2.0 or greater that are compatible with the ORCA shell. Once installed, GSoft\~BASIC works almost exactly like any other ORCA language.\par The ORCA shell ships with ORCA/M, ORCA/Pascal, ORCA/C, ORCA/Modula-2 and }{\i\fs20 Toolbox Programming in GSoft BASIC}{\fs20 . It is documented in those books, so that documentation is not duplicated here. The remainder of this section describes the unique features of GSoft\~BASIC when used from the ORCA shell, what the installer does, and documents a utility that converts GSoft\~BASIC tokenized files to SRC files you can use from the ORCA shell.\par For a discussion of the advantages and disadvantages of the ORCA shell version of GSoft\~BASIC as compared to the version that is described in this manual, see }{\i\fs20 The Three Worlds of GSoft\~BASIC}{\fs20  in Chapter\~2.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Using GSoft\~BASIC from the ORCA Shell}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Using GSoft\~BASIC from the ORCA Shell\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 With GSoft\~BASIC installed in the ORCA shell, you can enter BASIC programs with the ORCA editor just as you do for any other language. Be sure to set the language type for the file to BASIC, either by typing BASIC just before you edit a new file, or by using the ORCA shell\rquote s CHANGE command to set the language type of an existing file.\par Once you have created a program, use the RUN command to execute it. For example, if you have created a file named Hello.bas, you would execute the program with the command\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 run hello.bas\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par Since GSoft\~BASIC is an interpreter, there are no separate compile, link and execute steps. You use the RUN command each time you want to execute the program.\par While it isn\rquote t required, we recommend appending .bas to the end of all GSoft\~BASIC source files. This convention conforms to the naming conventions used in the ORCA shell, allowing dot prefixes for partial compiles and multi-lingual compiles if a GSoft\~BASIC compatible compiler is ever made available.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 The DeToke Utility}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 The DeToke Utility\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Most programs written with GSoft\~BASIC are saved as tokenized BASIC programs. The ORCA editor can\rquote t read these files. The DeToke utility gives you an easy way to convert the tokenized files used by the GSoft\~BASIC shell to the source files used by the ORCA shell. It is designed so it is fairly easy to convert large numbers of files with a single command.\par The DeToke utility accepts one or more input files. Each name can include wild cards, in which case all matching files are converted. Since the utility is designed to convert large numbers of files at once, accepting many source files, it forms its own output file name. The output file name is formed by stripping any suffix from the original file (a suffix starts with the last period in the name and continues to the end of the name), then appending .bas to the source file name. If the resulting name would exceed 15 characters, it is shortened.\par For example, if there are two tokenized BASIC files with these names\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 prog.tok\par longprogramname\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 in your folder and you convert them to source files using the command\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 detoke =prog=\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 the output files will be\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 prog.bas\par longprogram.bas\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par Since DeToke is designed to convert large numbers of files in a single pass, it does not complain when one of the input files is not a tokenized GSoft\~BASIC program. In fact, you can safely convert all of the programs in a folder that contains GSoft\~BASIC programs mixed with other files using the command\par \par detoke =\par \par There are two command line flags, each of which must be used before the first file name. They may be used in any order, so long as they precede the file names.\par The -v flag prints version and copyright information. Use this flag if you need to check the version number for the DeToke utility.\par The -p flag prints progress information. Use this flag if you would like a list of the files DeToke examines. This list shows which files were converted and which were skipped because they were not GSoft\~BASIC tokenized source files.\par For example, to see the copyright information and get a complete list of the files processed, you could use the command\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 detoke -v -p =\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Installing GSoft\~BASIC in the ORCA Shell}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Installing GSoft\~BASIC in the ORCA Shell\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 You should normally install GSoft\~BASIC using the installer that comes with it. This process is described in }{\i\fs20 Installing GSoft\~BASIC on a Hard Disk}{\fs20  in Chapter\~1. This detailed description of the installation process is here for those of you that want all the details, those who may be installing GSoft\~BASIC in an ORCA compatible shell, and those who want to customize the installation.\par Assuming you already have the ORCA shell installed and working, there are several other files you will want to install or modify to use GSoft\~BASIC. In all cases these descriptions assume you have installed ORCA in a folder named ORCA, and give partial path names based on that folder.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 :GSoft.Extras:Languages:BASIC\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 This is the GSoft\~BASIC interpreter itself. It must be installed in the languages folder. In a typical installation of ORCA, this will be in the ORCA:Languages: folder.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 :GSoft:Shell:SysCmnd\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The SysCmnd file is a catalog of all of the commands, languages and utilities in your installation of ORCA. You will need to add two lines to this file, which is located at ORCA:Shell:SysCmnd. These lines should be inserted in alphabetical order. Use the same spacing you see in the existing commands in the file.\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 BASIC           *L      260            GSoft BASIC\par DETOKE          *U                     GSoft BASIC tokenized file converter\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 :GSoft:Shell:SysTabs\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The SysTabs file contains default tab lines and default editor settings for each programming language installed in the ORCA shell. You should insert the following lines in the file, located at ORCA:Shell:SysTabs.\par Proper order is important. Each language uses three lines, although line wrapping may make it look like there are more that three lines, as it does in this manual. The third line contains the tab stops, and must be a single line, unbroken by line feeds. The first line contains the language number, and it is important that the three line sets of information be in numerical order by language number.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 260\par 10011001\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 000000100000001000000010000000100000001000000010000000100000001000000010000000100000001000000010000000100000001000000010000000100000001000000010000000100000001000000010000000100000001000000010000000100000001000000010000000100000001000000010000000100000002\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par You can customize these lines so the editor suits your personal preferences. See }{\i\fs20 Setting Editor Defaults}{\fs20  in Chapter\~6 for details.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 :GSoft.Extras:Libraries:GSoftDefs:\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 GSoft\~BASIC comes with several tool interface files. The exact number of files may change in the future, so the best policy is to copy all of the files you find in this folder on the GSoft\~BASIC disk into the ORCA:Libraries:GSoftDefs folder.\par As this manual is written, the files we ship with GSoft\~BASIC are:\par \par }\pard \s25\fi-1440\li1800\sb40\widctlpar\adjustright {\fs20 GSoftTools.gst\tab This file contains the interfaces for Apple\rquote s toolbox calls, GS/OS, the ORCA shell, and Talking\~Tools. All of these are discussed in detail in various parts of this manual; see the index for details.\par User001.gst\tab This is the interface for the Game Paddle Library, a custom library supplied with GSoft\~BASIC that supports game paddles and joysticks.\par User002.gst\tab This is the interface for the Time Library, a custom library supplied with GSoft\~BASIC that supplies time and date manipulation subroutines.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par GSoft\~BASIC will work without these files, but you won\rquote t be able to use the tools and libraries they represent unless the files are installed.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 :GSoft.Extras:System:Tools:\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 GSoft\~BASIC libraries are implemented as user tools. As this manual is written, there are two of them, but this number may increase. As with the tool interface files, the best policy is to copy all of the files you find in the GSoft.Extras:System:Tools folder into the corresponding file on your boot disk, *:System:Tools.\par The two files that ship with GSoft\~BASIC are:\par \par }\pard \s25\fi-1440\li1800\sb40\widctlpar\adjustright {\fs20 UserTool001\tab This is the executable code for the Game Paddle Library. This file must be present if your programs use any of the game paddle procedures.\par UserTool002\tab This is the executable code for the Time Library. This file must be present if your programs use any of the Time Library procedures.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par Keep in mind that these files are also needed by anyone who is running your programs. We grant a royalty free license to distribute these files with any program written in GSoft\~BASIC, but it is up to you to make sure they are included with your program!\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 :GSoft.Extras:Utilities:DeToke\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The DeToke utility, described earlier in this chapter, is used to convert GSoft\~BASIC tokenized files to ORCA SRC files. It should be installed in ORCA:Utilities, and the changes described for the SysTabs file must also be made.\par This utility is not required by GSoft\~BASIC, and it also doesn\rquote t depend on GSoft\~BASIC. Without it, though, you will have to use the GSoft\~BASIC shell to convert tokenized files to a format you can use from the ORCA shell.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 :GSoft.Extras:Utilities:Help:DeToke\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The help file for the DeToke utility should be installed in ORCA:Utilities:Help.\par \sect }\sectd \lndscpsxn\sbkodd\linex0\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Chapter 5: The Command Processor\par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Chapter 5 - The Command Processor}{\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\v\f4\fs36\cgrid {\tc {\v Chapter 5 - The Command Processor\tcl1}}}{\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\*\bkmkstart bk6}{\*\bkmkstart bk7}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GSoft\~BASIC\:Finder version}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 Finder\:running GSoft\~BASIC from}}}{\fs20 There are three versions of GSoft\~BASIC, two of which can be used to write programs. One of these runs from any ORCA compatible shell, and one runs directly from the Finder. This chapter describes the commands used with the Finder version of GSoft\~BASIC.\par In general you can think of this version of GSoft\~BASIC as a souped up implementation of the Applesoft\~BASIC programming environment. It has some powerful new commands, but the commands you learned with Applesoft\~BASIC generally work just like they always did.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GSoft\~BASIC\:run time}}}{\fs20 The third version of GSoft\~BASIC is used to run programs directly from the Finder. You can\rquote t write programs with this version, just run them. The program used to create these GSoft\~BASIC programs is called MakeRuntime. It is covered in Chapter 4, }{\i\fs20 GSoft\~BASIC Utilities}{\fs20 .\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 The Line Editor}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 The Line Editor\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 line editor}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 command line editor}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editing the command line}}}{\fs20 When you enter the Finder version of GSoft\~BASIC, you\rquote re in a text based shell. This shell lets you type commands like CATALOG to catalog a disk or EDIT to use the full screen editor to edit a file. It also lets you enter programs directly from the keyboard if you are willing to use line numbers.\par In addition to the obvious keys used to type characters, there are several editing commands available as you type a line. Some allow you to position the cursor in the middle of the line. It doesn\rquote t matter if the cursor is at the end of the line or not\emdash when you press }{\outl\fs18 RETURN}{\fs20  or }{\outl\fs18 ENTER}{\fs20 , the entire line is processed.\par The editing keys are:\par \par }\pard\plain \s32\fi-1800\li2160\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \adjustright \f4\cgrid {\fs20 key\tab action\par }\pard\plain \s25\fi-1800\li2160\sb40\keepn\widctlpar\adjustright \f4\cgrid {\outl\fs18 LEFT-ARROW}{\fs20 \tab The cursor will move to the left. If the cursor is already in the first character position on the line, the key is ignored.\par }{\outl\fs18 RIGHT-ARROW}{\fs20 \tab The cursor will move to the right. If the cursor is already positioned just to the right of the last typed character (which may be a space), the key is ignored.\par }{\outl\fs18 delete}{\fs20 \tab Deletes the character to the left of the cursor, moving the cursor left. If the cursor starts in the first character position on the line, the key is ignored.\par }{\outl\fs18 return}{\fs20  or }{\outl\fs18 enter}{\fs20 \tab Executes the typed command.\par }{\outl\fs18 esc}{\fs20  or }{\outl\fs18 clear}{\fs20 \tab Deletes all characters in the line.\par }{\outl\fs18 \u-3\'f0}{\fs20 X or }{\outl\fs18 \u-3\'f0}{\fs20 x\tab Deletes all characters in the line. These keys are generally used for the cut command on the Apple\~II}{\fs18 GS}{\fs20 . The closest equivalent in the line editor is deleting all of the characters.\par }{\outl\fs18 \u-3\'f0}{\fs20 Z or }{\outl\fs18 \u-3\'f0}{\fs20 z\tab Deletes all characters in the line. These keys are generally used for the undo command on the Apple\~II}{\fs18 GS}{\fs20 . The closest equivalent in the line editor is deleting all of the characters.\par }{\outl\fs18 \u-3\'f0}{\fs20 F or }{\outl\fs18 \u-3\'f0}{\fs20 f\tab Deletes the character under the cursor, moving the remaining characters in the line left one position. The key is ignored if the cursor is just past the last typed character.\par }{\outl\fs18 \u-3\'f0}{\fs20 Y or }{\outl\fs18 \u-3\'f0}{\fs20 y\tab Deletes characters from the cursor to the end of the line.\par }{\outl\fs18 \u-3\'f0}{\fs20 > or }{\outl\fs18 \u-3\'f0}{\fs20 .\tab The cursor moves to the end of the line, just past the last typed character. New characters will appear at the end of the line.\par }{\outl\fs18 \u-3\'f0}{\fs20 < or }{\outl\fs18 \u-3\'f0}{\fs20 ,\tab The cursor moves to the first position in the line.\par }{\outl\fs18 \u-3\'f0LEFT-ARROW}{\fs20 \tab The cursor moves left one word.\par }{\outl\fs18 \u-3\'f0RIGHT-ARROW}{\fs20 \tab The cursor moves right one word.\par }\pard \s25\fi-1800\li2160\sb40\widctlpar\adjustright {\outl\fs18 \u-3\'f0}{\fs20 E or }{\outl\fs18 \u-3\'f0}{\fs20 e\tab Toggles the insert mode. If the cursor is in insert mode, new characters are inserted, pushing existing characters from the cursor to the end of the line right one position. In overstrike mode, typed characters replace the character under the cursor. The default is overstrike mode.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 File Names}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 File Names\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Many of the commands described later in this chapter use file names. File names in GSoft\~BASIC follow standard GS/OS}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GS/OS}}}{\fs20  conventions.\par File names are discussed in detail in }{\i\fs20 File Names}{\fs20 , found in Chapter 14.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Types of Files Used by GSoft\~BASIC}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Types of Files Used by GSoft\~BASIC\tcl2}}}{\fs28 \par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Source Files}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Source Files\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 source files\:see file types}{\txe }}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 program files\:see file types}{\txe }}}{\fs20 GSoft\~BASIC can read four file types and write three different types of files as BASIC programs. Both the LOAD command and EDIT command will load any of the four supported file types as the active program}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 active program}}}{\fs20 . There are three versions of the save command, SAVE, SSAVE and TSAVE, used to save the program in the workspace in one of the three supported file types.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 GSoft\~BASIC Tokenized Files}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 GSoft\~BASIC Tokenized Files\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:TOK}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The most natural way for GSoft\~BASIC to deal with a file is the same way the file is stored in memory: as a tokenized file.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:type}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:auxiliary type}}}{\fs20 Tokenized files have a file type of $AF and an auxiliary file type of $0104. In some utilities, you will see the file type listed as TOK, for tokenized source files.\par The disadvantage to tokenized source files is that they can only be read by GSoft\~BASIC itself. On the other hand, they are shorter than an equivalent text file, load faster, and save faster.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SAVE shell command}}}{\fs20 The SAVE command saves a GSoft\~BASIC program as a TOK file. Use this command when you intend to use the Finder version of GSoft\~BASIC described in this chapter.\par The format for tokenized source files is described in detail in Appendix F, }{\i\fs20 Implementation Details}{\fs20 .\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Text Files and Source Files}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Text Files and Source Files\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 text files\bxe }}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 text files\:see also file types}{\txe }}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ASCII character set}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ASCII files}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 language stamp}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:TXT}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:SRC}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 return characters}}}{\fs20 There are two supported file types that are essentially the same inside. Both store the file as ASCII characters, with carriage return characters (CHR$(13)) at the end of each line.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:type}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:auxiliary type}}}{\fs20 The first of these file types is the generic Apple\~II}{\fs18 GS}{\fs20  text file. Text files have a file type of $04. The auxiliary file type is not used by most programs. In most utilities, you will see this file type listed as TXT. Text files can be read and written by practically any Apple\~II program that edits text in any form.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:type}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:auxiliary type}}}{\fs20 The second file type is the SRC file, used in programming environments like ORCA. SRC files have the same internal format as TXT files, but use the auxiliary file type to indicate which language should be used to process a file. GSoft\~BASIC can read any source file, and will attempt to tokenize what it reads as a BASIC program. It writes SRC files with a file type of $B0, listed as SRC by most utilities that show a file type, and with an auxiliary file type of $0104. Programming environments like ORCA that support multiple languages will display BASIC for the auxiliary file type.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 TSAVE shell command}}}{\fs20 The TSAVE command saves a GSoft\~BASIC program as a TXT file. Use TXT files when you need to read the program with some other text processing utility, or when you want to convert a GSoft\~BASIC program to Applesoft\~BASIC}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 Applesoft\~BASIC}}}{\fs20 .\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SSAVE shell command}}}{\fs20 The SSAVE command saves a GSoft\~BASIC program as an SRC file with an auxiliary file type of $0104. Use this command if you want to save a program in a format that can be used by the shell version of GSoft\~BASIC. See }{\i\fs20 The Three Worlds of GSoft\~BASIC}{\fs20  in Chapter 2 for an in depth look at how the shell version of GSoft\~BASIC uses SRC files.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Applesoft\~BASIC Files}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Applesoft\~BASIC Files\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 Applesoft\~BASIC\bxe }}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:BAS}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 GSoft\~BASIC can read Applesoft\~BASIC programs, but cannot write them directly.\par GSoft\~BASIC is similar to Applesoft\~BASIC, but it is not a true superset of Applesoft\~BASIC. Applesoft\~BASIC is tied directly to the eight bit Apple\~II architecture in several important ways that could not be ported to the sixteen bit environment of the Apple\~II}{\fs18 GS}{\fs20  using GS/OS. In addition, GSoft\~BASIC has many commands that are not supported in Applesoft\~BASIC, and some, like DEF FN, that have important new features.\par At the same time, a natural use for GSoft\~BASIC is porting older eight bit programs to the faster, more powerful world of GS/OS. That\rquote s why GSoft\~BASIC lets you load Applesoft\~BASIC programs. If features are found that don\rquote t exist under GSoft\~BASIC, or that are suspect, the old line is flagged with a comment that tells you to examine the line for possible changes. The actual comment varies with the command, but you can find them all by searching the file for the characters >>>. That\rquote s easy to do from the GSoft\~BASIC text editor. See the EDIT command, below, for details.\par The same problem exists in reverse. Applesoft\~BASIC}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 Applesoft\~BASIC}}}{\fs20  can\rquote t detect conflicts with GSoft\~BASIC if the file is saved as a tokenized Applesoft\~BASIC file, so you don\rquote t have that option. You can save a GSoft\~BASIC program as a TXT file, though, and import it to Applesoft\~BASIC. That gives Applesoft\~BASIC a chance to scan the file, making sure it understands all of the commands.\par See Appendix E for more details on compatibility between Applesoft\~BASIC and GSoft\~BASIC.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Entering BASIC Programs}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Entering BASIC Programs\tcl2}}}{\fs28 \par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 The Active Program}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 The Active Program\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 active program}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 program buffer}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 workspace}}}{\fs20 GSoft\~BASIC always has one program that is the active, or current, program. This program is stored in an area of memory referred to in this manual as the workspace or program buffer.\par Only one program is active at a time. This is the program that is edited, executed, saved and so forth. You can delete this program, emptying the workspace, with the NEW command. You can also load a new program into the workspace using the LOAD command, by using the EDIT command with a file name, or by entering a completely new program.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Entering Programs From the Command Line}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Entering Programs From the Command Line\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 line numbers}}}{\fs20 Any line that starts with a number is treated as a new GSoft\~BASIC program line, and is entered in the current program. The line is inserted in the program in numeric order, replacing any existing line with the same line number.\par For example, the commands\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 NEW\par 10 FOR I = 1 TO 10\par 20 PRINT J\par 30 NEXT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 20 PRINT I\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 create the program\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 10 FOR I = 1 TO 10\par 20 PRINT I\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 30 NEXT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par While this is a comfortable way to hack out short programs, the full screen editor you invoke with the EDIT command is generally a better way to create and edit programs. It also doesn\rquote t require line numbers.\par Typing a line number with nothing after it deletes an existing line with the same line number. If no matching line is found, the program doesn\rquote t change. For example, typing\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 20\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 changes the sample program to\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 10 FOR I = 1 TO 10\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 30 NEXT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par There is a restriction on this feature. Line numbers are optional in GSoft\~BASIC. If the current program has even one line that does not have a line number, you can\rquote t enter new lines directly from the command line.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Executing BASIC Commands}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Executing BASIC Commands\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 immediate execution}}}{\fs20 If you type a line that does not start with a line number and is not one of the commands listed in the Command Reference, below, GSoft\~BASIC tries to execute the command as if it were a line in a BASIC program.\par There are many uses for this feature, but one of the most powerful is debugging. After stopping a program with STOP, you can interrogate the values of variables, or even change their values. The program can be restarted with CONT.\par Of course, the other common use for this feature is to experiment with commands, or even do useful work with one-liners. After all,\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PRINT $0201\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 is a pretty convenient hexadecimal to decimal converter!\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Command Reference}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Command Reference\tcl2}}}{\fs28 \par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Bye}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Bye\tcl3}}}{\fs24 \par }\pard\plain \s37\sb160\sa80\keepn\widctlpar\adjustright \b\f6\cgrid {\fs20 BYE\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 BYE shell command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Exits GSoft\~BASIC.\par If you have edited the program in the workspace since the last time the program was saved, you will get a prompt asking if you are sure you want to exit GSoft\~BASIC.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Catalog}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Catalog\tcl3}}}{\fs24 \par }\pard\plain \s37\sb160\sa80\keepn\widctlpar\adjustright \b\f6\cgrid {\fs20 CAT [ pathname ]\par }\pard \s37\sa80\keepn\widctlpar\adjustright {\fs20 CATALOG [ pathname ]\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CATALOG shell command\bxe }}}{\v\fs20 \par }{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CAT shell command\bxe }}}{\v\fs20 \par }{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 CAT\tcl3}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 directories\:files in}}}{\fs20 Catalogs a directory.\par If no path name is given, the current directory is cataloged. If given, the path name can be a full or partial path name, the name of a volume, or the name of a device.\par The abbreviation CAT can be used instead of the full name of CATALOG. They do exactly the same thing.\par The files are listed, along with information about the files, in a tabular format. The listing of files starts with a header labeling the columns. The names used in the header, along with the meaning for the items in that column, are:\par \par }\pard\plain \s32\fi-1080\li1440\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \adjustright \f4\cgrid {\fs20 name\tab meaning\par }\pard\plain \s25\fi-1080\li1440\sb40\keepn\widctlpar\adjustright \f4\cgrid {\fs20 Name\tab }{\pard\plain \s25\fi-1080\li1440\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:names}}}{\pard\plain \s25\fi-1080\li1440\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file names}}}{\fs20 The file name for the file.\par Type\tab }{\pard\plain \s25\fi-1080\li1440\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:type}}}{\fs20 The type of the file. This is shown as a three letter type identifier. The types that are of interest to GSoft\~BASIC programmers are shown later in the description of CATALOG.\par Blocks\tab }{\pard\plain \s25\fi-1080\li1440\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:size}}}{\fs20 The number of blocks used by the file. This shows how much disk space is used by the file, not the number of bytes used by the file in memory. Each disk block uses 512 bytes on the disk, which is one-half of a kilobyte.\par Modified\tab }{\pard\plain \s25\fi-1080\li1440\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:dates}}}{\fs20 The last date and time the file was changed.\par Created\tab The date and time the file was created.\par Access\tab }{\pard\plain \s25\fi-1080\li1440\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:access privileges}}}{\fs20 The access flags for the file. See the description of access flags later in this section for details.\par }\pard \s25\fi-1080\li1440\sb40\widctlpar\adjustright {\fs20 Subtype\tab }{\pard\plain \s25\fi-1080\li1440\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:auxiliary type}}}{\fs20 The auxiliary file type for the file. This is shown as a hexadecimal value.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par File types are stored as a single byte, but it makes more sense to see them as a three letter abbreviation. The table below shows the three letter designation used by the various file types that are used in GSoft\~BASIC. See }{\i\fs20 File Type Notes}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\i\v\fs20 File Type Notes}}}{\fs20 , a technical note written by Apple Computer and published by Byte Works, for a complete list of file types and information about the internal format of many of the file types.\par \par }\pard\plain \s32\fi-2160\li2520\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx1440\adjustright \f4\cgrid {\fs20 Name\tab Hex\tab Use\par }\pard\plain \s25\fi-2160\li2520\sb40\keepn\widctlpar\tx1440\adjustright \f4\cgrid {\fs20 TXT\tab $04\tab }{\pard\plain \s25\fi-2160\li2520\sb40\keepn\widctlpar\tx1440\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:TXT}}}{\pard\plain \s25\fi-2160\li2520\sb40\keepn\widctlpar\tx1440\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:type}}}{\pard\plain \s25\fi-2160\li2520\sb40\keepn\widctlpar\tx1440\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ASCII files}}}{\pard\plain \s25\fi-2160\li2520\sb40\keepn\widctlpar\tx1440\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 text files}}}{\fs20 ASCII Text. See }{\i\fs20 Text Files and Source Files}{\fs20 , earlier in this chapter.\par BIN\tab $06\tab }{\pard\plain \s25\fi-2160\li2520\sb40\keepn\widctlpar\tx1440\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:BIN}}}{\pard\plain \s25\fi-2160\li2520\sb40\keepn\widctlpar\tx1440\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 binary files}}}{\fs20 Binary files, often used as input and output by GSoft\~BASIC. See }{\i\fs20 Binary Files}{\fs20  in Chapter 14.\par DIR\tab $0F\tab }{\pard\plain \s25\fi-2160\li2520\sb40\keepn\widctlpar\tx1440\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:DIR}}}{\fs20 Directories, which contain other files and directories. See CREATE and PREFIX, later in this chapter; and MKDIR and CHDIR in Chapter 14.\par DVU\tab $5E\tab }{\pard\plain \s25\fi-2160\li2520\sb40\keepn\widctlpar\tx1440\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:DVU}}}{\fs20 Development Utilities, which contain information used by programming tools. The format varies widely, depending on which tool created the file. GSoft\~BASIC tool interface files have this file type, along with an auxiliary file type of $8007.\par TOK\tab $AF\tab GSoft\~BASIC tokenized source file.\par SRC\tab $B0\tab }{\pard\plain \s25\fi-2160\li2520\sb40\keepn\widctlpar\tx1440\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:SRC}}}{\fs20 Program source file. See }{\i\fs20 Text Files and Source Files}{\fs20 , earlier in this chapter.\par S16\tab $B3\tab }{\pard\plain \s25\fi-2160\li2520\sb40\keepn\widctlpar\tx1440\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:S16}}}{\fs20 Programs that can be launched from the Finder or executed immediately upon booting the computer. See }{\i\fs20 Creating GSoft\~BASIC Programs that Run From the Finder}{\fs20  in Chapter 2.\par }\pard \s25\fi-2160\li2520\sb40\widctlpar\tx1440\adjustright {\fs20 BAS\tab $FC\tab }{\pard\plain \s25\fi-2160\li2520\sb40\widctlpar\tx1440\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:BAS}}}{\fs20 Applesoft\~BASIC}{\pard\plain \s25\fi-2160\li2520\sb40\widctlpar\tx1440\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 Applesoft\~BASIC}}}{\fs20  source file. See }{\i\fs20 Applesoft\~BASIC Files}{\fs20 , earlier in this chapter.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par Access flags indicate how a file can be used. They are listed as an uppercase letter if the privilege is set, and a space if it is not.\par You can enable and disable some of these flags with LOCK and UNLOCK, described later in this chapter.\par The various access flags and their meanings are:\par \par }\pard\plain \s32\fi-1080\li1440\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \adjustright \f4\cgrid {\fs20 flag\tab meaning\par }\pard\plain \s25\fi-1080\li1440\sb40\keepn\widctlpar\adjustright \f4\cgrid {\fs20 D\tab }{\pard\plain \s25\fi-1080\li1440\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:access privileges}}}{\fs20 Delete. When set, the file can be deleted. You can clear this flag with LOCK, and set it with UNLOCK.\par N\tab Rename. When set, the file can be renamed. You can clear this flag with LOCK, and set it with UNLOCK.\par B\tab Backup. When set, the file has not been saved by a backup utility since the last time it was modified.\par W\tab Write. When set, the file can be changed. You can clear this flag with LOCK, and set it with UNLOCK.\par }\pard \s25\fi-1080\li1440\sb40\widctlpar\adjustright {\fs20 R\tab Read. When set, the file can be read.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par You can pause in the middle of a long list of files by pressing the space bar. Press the space bar again to continue. Use }{\outl\fs18 esc}{\fs20  or }{\outl\fs18 \u-3\'f0}{\fs20 . to abort the list of files.\par After all of the files are listed, the CATALOG command prints a trailer that tells how many blocks on the disk are used, how many are free, and the total number of blocks on the disk.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Copy}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Copy\tcl3}}}{\fs24 \par }\pard\plain \s37\sb160\sa80\keepn\widctlpar\adjustright \b\f6\cgrid {\fs20 COPY from to\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 COPY shell command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:copying}}}{\fs20 Copy a file from one location to another.\par You can use full or partial path names for either file. For example,\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 COPY :MYDISK:MYPROGRAMS:PROGRAM PROGRAM\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 copies the file PROGRAM from the directory :MYDISK:MYPROGRAM to the current directory. A full path name can also be used as the destination.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 If the source file name and destination file name are the same, as in the example above, you can omit the last file name. The command\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 COPY :MYDISK:MYPROGRAMS:PROGRAM\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 does exactly the same thing as the first example.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Create}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Create\tcl3}}}{\fs24 \par }\pard\plain \s37\sb160\sa80\keepn\widctlpar\adjustright \b\f6\cgrid {\fs20 CREATE pathname\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CREATE shell command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 directories\:copying}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 directories\:see also files}{\txe }}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 folders\:see directories}{\txe }}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 path names\:see directories}{\txe }}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:see also directories}{\txe }}}{\fs20 Creates a new directory.\par You can create a directory with a full or partial path name. The most common way to create a directory is in the current directory, though. The command\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 CREATE NewFolder\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 creates a new directory called NewFolder in the current directory.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 DEBUG}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 DEBUG\tcl3}}}{\fs24 \par }\pard\plain \s37\sb160\sa80\keepn\widctlpar\adjustright \b\f6\cgrid {\fs20 DEBUG [ linenumber | filename ]\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DEBUG shell command\bxe }}}{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 debugger}}}{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ORCA/Debugger}}}{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 Splat!}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Runs a program, with the same options as the RUN command. The difference is that DEBUG enters an ORCA compatible debugger (like ORCA/Debugger or Splat!), breaking on the first line executed.\par Once inside the debugger, you can step or trace through the GSoft\~BASIC program, examine variables, and carry out any other activity the debugger supports.\par }{\b\fs20 Do not use this command}{\fs20  unless an ORCA compatible debugger is installed! ORCA compatible debuggers work by intercepting the 65816}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 65816}}}{\fs20  COP instruction. There is no way for GSoft\~BASIC to tell if a debugger is installed or not, so it will issue the COP instruction whether or not a debugger is actually present. If there is no debugger installed, this causes the computer to crash. While this does no actual harm, the only way to recover is to reboot.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Del}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Del\tcl3}}}{\fs24 \par }\pard\plain \s37\sb160\sa80\keepn\widctlpar\adjustright \b\f6\cgrid {\fs20 DEL start [ ',' end ]\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DEL shell command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Delete a single line or a range of lines.\par The DEL command cannot be used with programs that do not use line numbers on every line.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Delete}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Delete\tcl3}}}{\fs24 \par }\pard\plain \s37\sb160\sa80\keepn\widctlpar\adjustright \b\f6\cgrid {\fs20 DELETE filename\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DELETE shell command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:deleting}}}{\fs20 Deletes the named file. The file name can be a file name, partial path name, or full path name.\par The file can be a directory. After checking to be sure the user really wants to delete the directory and its contents, all files in the directory and the directory itself are deleted.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Edit}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Edit\tcl3}}}{\fs24 \par }\pard\plain \s37\sb160\sa80\keepn\widctlpar\adjustright \b\f6\cgrid {\fs20 EDIT [ filename ]\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 EDIT shell command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Enters an ORCA compatible editor, displaying the program in memory. If a file name is given, the file is loaded and edited exactly as if the commands\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 LOAD filename\par EDIT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 were used.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The editor should be installed in a directory named Shell. This directory should be in the same directory as the GSoft\~BASIC application. Placing GSoft\~BASIC in the same directory with ORCA.Sys16 in an existing ORCA/M environment will satisfy all editor requirements for both GSoft\~BASIC and the ORCA shell.\par See Chapter 6 for a complete description of the full screen editor that comes with GSoft\~BASIC.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 List}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 List\tcl3}}}{\fs24 \par }\pard\plain \s37\sb160\sa80\keepn\widctlpar\adjustright \b\f6\cgrid {\fs20 LIST [ line-number [ ',' [ line-number ] ] ]\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LIST shell command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Lists the entire program, a single line, or a range of lines. See PR for a way to print the file to a printer.\par To list the entire program use the LIST command with no parameters. You can use this version of the LIST command with programs that do not use line numbers.\par You can pause in the middle of a long listing by pressing the space bar. Press the space bar again to continue. Use }{\outl\fs18 esc}{\fs20  or }{\outl\fs18 \u-3\'f0}{\fs20 . to abort the listing.\par If you use a single line number, LIST lists that line from the program. If there is no line with the given line number, LIST does nothing.\par If you use two line numbers separated by a comma, LIST lists all of the lines whose line number is greater than or equal to the first number, and less than or equal to the second. If there are no lines in the given range, LIST does nothing.\par For example,\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 LIST 100, 400\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 lists all of the lines from line 100 to line 400.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 You can omit the first line number, in which case LIST lists all of the lines whose line number is less than or equal to the second parameter. For example,\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 LIST , 400\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 lists all of the lines from the start of the program to line 400. Omitting the second number, but including the comma, lists all of the lines greater than or equal to the first line number. For example,\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 LIST 100,\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 lists all of the lines from line 100 to the end of the program.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 You can use LIST to list programs that do not have line numbers on each line, but the entire program is always listed. In general, you should use the full screen editor to view programs that do not use line numbers on each line.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Load}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Load\tcl3}}}{\fs24 \par }\pard\plain \s37\sb160\sa80\keepn\widctlpar\adjustright \b\f6\cgrid {\fs20 LOAD filename\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LOAD shell command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Load a program from disk.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:SRC}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:TXT}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:BAS}}}{\fs20 The program may be a GSoft\~BASIC tokenized file, a TXT file, a BASIC SRC file or an Applesoft\~BASIC}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 Applesoft\~BASIC}}}{\fs20  file.\par If the file is a TXT or SRC file, it is handled almost as if the NEW command was used, then each of the lines in the file was typed in turn. The single difference is that lines with no line number are accepted.\par Applesoft\~BASIC programs are loaded and converted to GSoft\~BASIC programs, with comment lines added after any line that may cause a problem in GSoft\~BASIC or GS/OS. Search for the characters >>>, which appear at the start of all of these comments.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Lock}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Lock\tcl3}}}{\fs24 \par }\pard\plain \s37\sb160\sa80\keepn\widctlpar\adjustright \b\f6\cgrid {\fs20 LOCK filename\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LOCK shell command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:access privileges}}}{\fs20 Locks a file. Locked files cannot be renamed, deleted, or written to.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Move}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Move\tcl3}}}{\fs24 \par }\pard\plain \s37\sb160\sa80\keepn\widctlpar\adjustright \b\f6\cgrid {\fs20 MOVE from to\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 MOVE shell command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:moving}}}{\fs20 Move a file from one location to another.\par Move works exactly like a COPY command followed by a DELETE command that deletes the original file.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 New}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 New\tcl3}}}{\fs24 \par }\pard\plain \s37\sb160\sa80\keepn\widctlpar\adjustright \b\f6\cgrid {\fs20 NEW\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 NEW shell command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The program in the workspace is deleted.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Prefix}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Prefix\tcl3}}}{\fs24 \par }\pard\plain \s37\sb160\sa80\keepn\widctlpar\adjustright \b\f6\cgrid {\fs20 PREFIX [ pathname ]\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 PREFIX shell command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 directories\:changing}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 directories\:default}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 prefix\:see directory}{\txe }}}{\fs20 Changes the default prefix (GS/OS prefix number 8) to the given path name.\par If no prefix is given, the current value for the prefix is shown.\par There is one special name. A path name consisting of two periods, as in\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PREFIX ..\par }\pard\plain \s25\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par moves up one directory level. For example, assuming disks and folders with the appropriate names exist, the commands\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PREFIX :MyDisk:GSoft:Samples\par PREFIX ..\par PREFIX\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 prints the current prefix, which is\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 :MyDisk:Gsoft:\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par You can use CATALOG after PREFIX if you aren\rquote t sure that you arrived at the proper spot.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 PR}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 PR\tcl3}}}{\fs24 \par }\pard\plain \s37\sb160\sa80\keepn\widctlpar\adjustright \b\f6\cgrid {\fs20 PR [ line-number [ ',' [ line-number ] ] ]\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 PR shell command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The PR command works exactly like LIST, but the program listing is sent to the printer instead of the text screen. The .PRINTER driver described in Chapter 4 must be installed for this command to work.\par See LIST for a description of the parameters.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Rename}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Rename\tcl3}}}{\fs24 \par }\pard\plain \s37\sb160\sa80\keepn\widctlpar\adjustright \b\f6\cgrid {\fs20 RENAME old new\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 RENAME shell command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:renaming}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:letter case}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:names}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file names}}}{\fs20 Rename a file.\par You can use full or partial path names, but RENAME will not move a file, so any path names used must match.\par RENAME can be used to change the case of a file name. For example, if a file is named MYPROG, but you would like to see MyProg when you catalog a disk, use the command\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 RENAME MyProg MyProg\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 The letter case of the first name doesn\rquote t matter, since it is only used to find the file to rename, and file name matching is case insensitive. The case of the second name is used for the new file name. It is preserved, showing up when you catalog the directory containing the file.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Renumber}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Renumber\tcl3}}}{\fs24 \par }\pard\plain \s37\sb160\sa80\keepn\widctlpar\adjustright \b\f6\cgrid {\fs20 RENUMBER first ',' step [ ',' start [ ',' end ] ]\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 RENUMBER shell command\bxe }}}{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 line numbers\:RENUMBER shell command}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Renumber a program.\par The parameters identify the lines to renumber and the way to renumber the file.\par \par }\pard\plain \s32\fi-1440\li1800\ri2880\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \adjustright \f4\cgrid {\fs20 parameter\tab meaning\par }\pard\plain \s25\fi-1440\li1800\ri2880\sb40\keepn\widctlpar\adjustright \f4\cgrid {\f6\fs20 first}{\fs20 \tab First line number to use.\par }\pard \s25\fi-1440\li1800\ri2880\keepn\widctlpar\adjustright {\f6\fs20 step}{\fs20 \tab Increment between new line numbers.\par }{\f6\fs20 start}{\fs20 \tab First line to renumber.\par }\pard \s25\fi-1440\li1800\ri2880\widctlpar\adjustright {\f6\fs20 end}{\fs20 \tab Last line to renumber.\par }\pard \s25\fi360\widctlpar\adjustright {\fs20 \par RENUMBER is generally used to update the line numbers in a program that has been edited, inserting many lines in one part of the program. You could run out of available line numbers in the part of the program you are editing, or you might want to renumber the program for aesthetic reasons. For a more esoteric example, consider the short program\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\pard\plain \s31\fi360\keepn\widctlpar\adjustright \v\f6\fs18\cgrid {\xe {\v\fs18 }{\v\fs18 samples\:Sieve}}}{\fs18  1000 DIM FLAGS%(8190)\par  2000 PRINT "10 iterations"\par  2010 FOR ITER = 1 TO 10\par  2020   COUNT = 0\par  2030   FOR I = 0 TO 8190\par  2040     FLAGS%(I) = 1\par  2050   NEXT I\par  2060   FOR I = 0 TO 8190\par  2070     IF NOT FLAGS%(I) THEN 2160\par  2080     PRIME = I + I + 3\par  2090     PRINT PRIME\par  2100     K = I + PRIME\par  2110     IF K > 8190 GOTO 2150\par  2120     FLAGS%(K) = 0\par  2130     K = K + PRIME\par  2140     GOTO 2110\par  2150     COUNT = COUNT + 1\par  2160   NEXT I\par  2165 NEXT ITER\par }\pard \s31\fi360\widctlpar\adjustright {\fs18  2170 PRINT COUNT;" primes"\par }\pard\plain \s25\fi360\widctlpar\tx1440\adjustright \f4\cgrid {\fs20 \par }\pard \s25\widctlpar\adjustright {\fs20 This is a classic benchmark for computers. It finds all of the prime numbers from 3 to 8190. This particular version will run from either Applesoft\~BASIC}{\pard\plain \s25\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 Applesoft\~BASIC}}}{\fs20  or GSoft\~BASIC. Traditionally, line 2090 is removed before timing the program.\par }\pard \s25\fi360\widctlpar\adjustright {\fs20 The amount of time it takes to handle a long line number is actually longer than the time it takes to handle a short one. Renumbering the program with the command\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 RENUMBER 1, 1\par }\pard\plain \s25\fi360\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\widctlpar\adjustright {\fs20 created a compacted program whose first line number is 1, with line numbers that increment by 1. Here\rquote s the renumbered program:\par }\pard \s25\fi360\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18     1 DIM FLAGS%(8190)\par     2 PRINT "10 iterations"\par     3 FOR ITER = 1 TO 10\par     4   COUNT = 0\par     5   FOR I = 0 TO 8190\par     6     FLAGS%(I) = 1\par }\pard \s31\fi360\widctlpar\adjustright {\fs18     7   NEXT I\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18     8   FOR I = 0 TO 8190\par     9     IF NOT FLAGS%(I) THEN 17\par    10     PRIME = I + I + 3\par    11     K = I + PRIME\par    12     IF K > 8190 GOTO 16\par    13     FLAGS%(K) = 0\par    14     K = K + PRIME\par    15     GOTO 12\par    16     COUNT = COUNT + 1\par }\pard \s31\fi360\widctlpar\adjustright {\fs18    17   NEXT I\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18    18 NEXT ITER\par }\pard \s31\fi360\widctlpar\adjustright {\fs18    19 PRINT COUNT;" primes"\par }\pard\plain \s25\fi360\widctlpar\adjustright \f4\cgrid {\fs20 \par This program actually runs about 2% faster than the original. That\rquote s not a very big improvement, but it does show how RENUMBER works!\par You can get an even bigger savings by converting the program completely to GSoft\~BASIC, taking advantage of all its features. Here\rquote s the same program fully converted to GSoft\~BASIC.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM FLAGS%(8190)\par PRINT "10 iterations"\par FOR ITER% = 1 TO 10\par   COUNT% = 0\par   FOR I% = 0 TO 8190\par     FLAGS%(I%) = 1\par   NEXT I%\par   FOR I% = 0 TO 8190\par     IF FLAGS%(I%) THEN\par       PRIME% = I% + I% + 3\par       K% = I% + PRIME%\par       WHILE K% <= 8190\par         FLAGS%(K%) = 0\par         K% = K% + PRIME%\par       WEND\par       COUNT% = COUNT% + 1\par     END IF\par   NEXT I%\par NEXT ITER%\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PRINT COUNT%;" primes"\par }\pard\plain \s25\fi360\widctlpar\adjustright \f4\cgrid {\fs20 \par This program runs about 14% faster than the original. The biggest saving comes from using integers throughout the program rather than floating-point numbers.\par Just for comparison, the original program runs in about 2/3 the time it takes the same program to run under Applesoft\~BASIC. The fully converted program runs in about 57% of the time\emdash almost twice as fast as Applesoft\~BASIC.\par There is one possible error you can encounter with the RENUMBER command. If the last renumbered line is larger than the first subsequent line that is not renumbered, or if RENUMBER would create a line number greater than 65535, the renumber command fails. It prints an error message and refuses to renumber the program. You can generate this error from the original prime number sample with the command\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 RENUMBER 2000, 100, 2000, 2100\par }\pard\plain \s25\fi360\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\widctlpar\adjustright {\fs20 This command attempts to renumber the lines from 2000 to 2100 beginning with line number 2000 and incrementing by 100. If this command were carried out, line 2100 would be renumbered as line 3000. Since the line right after the original line 2100 is numbered 2110, this command would create a program with overlapping lines, so the command aborts rather than demolishing your program.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 This command may be used with programs that contain lines without line numbers, but you cannot use start and end line numbers unless the entire program is numbered. In short, if the program doesn\rquote t start with all lines numbered, you have to renumber the entire program. Also, RENUMBER will not renumber line number }{\i\fs20 uses}{\fs20  correctly if the program has duplicate line numbers. For example, the program\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18       GOTO 100\par       DATA 10\par   100 READ J\par       FOR I = 1 TO J\par         CALL P\par       NEXT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18       END\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18       SUB P\par       GOTO 100\par       DATA I, II, III\par   100 FOR I = 1 TO 3\par         READ J$\par         PRINT J$\par       NEXT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18       END\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 should not be renumbered. It is a legal GSoft\~BASIC program, and will work correctly as shown. When the program is renumbered, though, the two line numbers will be changed, but the line numbers used in the GOTO statements will both point to the same line. Before renumbering a program like this one, remove duplicate line numbers manually. You don\rquote t have to insure that the line numbers are in order, but you do need to insure that all line numbers are unique before you renumber a program.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Of course, in this particular example, the program would work if you left the GOTO statements and line numbers out.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Run}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Run\tcl3}}}{\fs24 \par }\pard\plain \s37\sb160\sa80\keepn\widctlpar\adjustright \b\f6\cgrid {\fs20 RUN [ line-number | filename ]\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 RUN shell command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Run a program.\par If a number is supplied as a parameter, program execution starts at that line.\par If a file name is supplied as a parameter, the file is loaded and executed. The file may be a GSoft\~BASIC tokenized file, a TXT file, a BASIC SRC file or an Applesoft\~BASIC file.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DEF FN statement}}}{\fs20 The RUN command clears the variable space before the program begins execution. Any old values, types and DEF FN declarations are erased. If you would like to execute the program without erasing existing values, use the GOTO statement to jump into the program at a specific spot.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Save}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Save\tcl3}}}{\fs24 \par }\pard\plain \s37\sb160\sa80\keepn\widctlpar\adjustright \b\f6\cgrid {\fs20 SAVE filename\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SAVE shell command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 saving programs}}}{\fs20 Save a program to disk as a GSoft\~BASIC tokenized file.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:TOK}}}{\fs20 The resulting file can be executed from the shell version of GSoft\~BASIC, and it can be used as input to the MakeRuntime utility.\par See Appendix F for details about the file format.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 SSave}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 SSave\tcl3}}}{\fs24 \par }\pard\plain \s37\sb160\sa80\keepn\widctlpar\adjustright \b\f6\cgrid {\fs20 SSAVE filename\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SSAVE shell command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 saving programs}}}{\fs20 Save a program to disk as an ORCA SRC file.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:SRC}}}{\fs20 The file has a file type of $B0 (shown as SRC by the CATALOG command) and an auxiliary file type of $0104. See }{\i\fs20 Text Files and Source Files}{\fs20 , earlier in this chapter, for a discussion of this file type.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 TSave}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 TSave\tcl3}}}{\fs24 \par }\pard\plain \s37\sb160\sa80\keepn\widctlpar\adjustright \b\f6\cgrid {\fs20 TSAVE filename\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 TSAVE shell command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 saving programs}}}{\fs20 Save a program to disk as a generic ASCII text file.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:TXT}}}{\fs20 The file has a file type of $04 (shown as TXT by the CATALOG command). See }{\i\fs20 Text Files and Source Files}{\fs20 , earlier in this chapter, for a discussion of this file type.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Unlock}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Unlock\tcl3}}}{\fs24 \par }\pard\plain \s37\sb160\sa80\keepn\widctlpar\adjustright \b\f6\cgrid {\fs20 UNLOCK filename\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 UNLOCK shell command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:access privileges}}}{\fs20 Unlocks a file locked with the LOCK command. Locked files cannot be renamed, deleted, or written to.\par {\*\bkmkend bk6}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GSoft\~BASIC\:shell version\bxe }{\rxe bk6}}}{\*\bkmkend bk7}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 shell\:GSoft\~BASIC\bxe }{\rxe bk7}}}{\v\fs20 \par }{\fs20 \sect }\sectd \lndscpsxn\sbkodd\linex0\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Chapter 6: The Text Editor\par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Chapter 6 \endash  The Text Editor}{\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\v\f4\fs36\cgrid {\tc {\v Chapter 6 \endash  The Text Editor\tcl1}}}{\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 GSoft\~BASIC\rquote s EDIT command opens the current program using any ORCA compatible editor. This chapter describes the ORCA editor, which ships with GSoft\~BASIC. The ORCA editor allows you to write and edit source and text files.\par The first section describes briefly how the ORCA editor works with GSoft\~BASIC interpreted files. The second section in this chapter, \ldblquote Modes,\rdblquote  describes the different modes in which the editor can operate. The third section, \ldblquote Macros,\rdblquote  describes how to create and use editor macros, which allow you to execute a string of editor commands with a single keystroke. The fourth section, \ldblquote Using Editor Dialogs,\rdblquote  gives a general overview of how the mouse and keyboard are used to manipulate dialogs. The next section, \ldblquote Commands,\rdblquote  describes each editor command and gives the key or key combination assigned to the command. The last section, \ldblquote Setting Editor Defaults,\rdblquote  describes how to set the defaults for editor modes and tab settings for each language.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 How Text Editors Work With GSoft\~BASIC Tokenized Files}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 How Text Editors Work With GSoft\~BASIC Tokenized Files\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 When you use GSoft\~BASIC\rquote s environment to write and execute programs, the program you are working on is stored in a tokenized form. Tokenizing a program is a process that converts common words, like PRINT, into single byte quantities. As a result, the program is much smaller than a standard text representation of the file, and it runs faster than would be possible if the program was not tokenized. The space savings are actually dramatic\emdash tokenized files are generally smaller than a compiled version of the same program. GSoft\~BASIC\rquote s SAVE command saves the file in this tokenized form, too.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 tokens}}}{\fs20 These tokens are converted back to text whenever you list or edit a program. Editing a program with any editor becomes a multi-step process. First GSoft\~BASIC converts the tokenized file to ASCII text. This text is actually saved in a scratch file called SysBASICTemp; this file is stored in the current default directory. It\rquote s this scratch file that the ORCA editor actually edits. You will see this name at the bottom of your edit screen. After you finish editing the file, the editor saves the results back to the scratch file, and GSoft\~BASIC loads the result just as if you used the LOAD command.\par All of this is fairly transparent, but it explains two points you should keep in mind.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 pretty printing}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 identifiers}}}{\fs20 First, the file you type is converted to tokens. In the process, all identifiers are converted to uppercase letters and extra spaces are removed. When the program is converted from tokenized form to ASCII text spaces are inserted to make the program more readable. You don\rquote t have any control over this process. If you are picky about the way you format a program, this can be annoying\emdash the only alternative is to use a standard ORCA compatible programming environment, installing GSoft\~BASIC as a standard language. On the other hand, since GSoft\~BASIC will format your program in a reasonable way, it frees you from keeping the text pretty as you type it in the editor. No matter how sloppy your spacing and indenting might be, GSoft\~BASIC will clean it up.\par The second point is that you can edit other text files while in the editor. The ORCA editor doesn\rquote t know how to edit a tokenized BASIC file, but it can load any files you save using the TSAVE command}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 TSAVE shell command}}}{\fs20 . If you have BASIC subroutines that you want to use in different programs, save them with the TSAVE command so you can load them into the editor while you are editing your program.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Modes}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Modes\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The behavior of the ORCA editor depends on the settings of several modes, as follows:\par \par }\pard \s25\fi360\sb40\keepn\widctlpar\adjustright {\fs20 \bullet \tab Insert.\par \bullet \tab Escape.\par \bullet \tab Auto Indent.\par \bullet \tab Text Selection.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \bullet \tab Hidden Characters.\par \par Most of these modes have two possible states; you can toggle between the states while in the editor. The default for these modes can be changed by changing flags in the SysTabs file; this is described later in this chapter, in the section }{\i\fs20 Setting Editor Defaults}{\fs20 . All of these modes are described in this section.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Insert}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Insert\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:over strike mode\bxe }}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:insert mode\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 When you first start the editor, it is in over strike mode; in this mode the characters you type replace any characters the cursor is on. In insert mode, any characters you type are inserted at the left of the cursor; the character the cursor is on and any characters to the right of the cursor are moved to the right.\par }\pard \s25\fi360\sb40\keepn\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:line length\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The maximum number of characters the ORCA editor will display on a single line is 255 characters, and this length can be reduced by appropriate settings in the tab line. If you insert enough characters to create a line longer than 255 characters, the line is wrapped and displayed as more than one line. Keep in mind that most languages limit the number of characters on a single source line to 255 characters, and may ignore any extra characters or treat them as if they were on a new line.\par To enter or leave the insert mode, type }{\outl\fs18 \u-3\'f0}{\fs20 E. When you are in insert mode, the cursor will be an underscore character that alternates with the character in the file. In over strike mode, the cursor is a blinking box that changes the underlying character between an inverse character (black on white) and a normal character (white on black).\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Escape}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Escape\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:escape mode\bxe }}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:repeat counts\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 When you press the }{\outl\fs18 ESC}{\fs20  key, the editor enters the escape mode. For the most part, the escape mode works like the normal edit mode. The principle difference is that the number keys allow you to enter repeat counts, rather than entering numbers into the file. After entering a repeat count, a command will execute that number of times.\par }\pard \s25\fi360\sb40\keepn\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:insert blank lines command}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 For example, the }{\outl\fs18 \u-3\'f0}{\fs20 B command inserts a blank line in the file. If you would like to enter fifty blank lines, you would enter the escape mode, type 50}{\outl\fs18 \u-3\'f0}{\fs20 B, and leave the escape mode by typing the }{\outl\fs18 ESC}{\fs20  key a second time.\par }\pard \s25\fi360\sb40\keepn\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:escape mode}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:open Apple key}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 In the normal editor mode, }{\outl\fs18 \u-3\'f0}{\fs20  followed by a number key moves to various places in the file. In escape mode, the }{\outl\fs18 \u-3\'f0}{\fs20  key modifier allows you to type numbers.\par }\pard \s25\fi360\sb40\keepn\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:control underscore key\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The only other difference between the two modes is the way }{\outl\fs18 CTRL}{\fs20 _ works. This key is used primarily in macros. If you are in the editor mode, }{\outl\fs18 CTRL}{\fs20 _ places you in escape mode. If you are in escape mode, it does nothing. In edit mode, }{\outl\fs18 \u-3\'f0CTRL}{\fs20 _ does nothing; in escape mode, it returns you to edit mode. This lets you quickly get into the mode you need to be in at the start of an editor macro, regardless of the mode you are in when the macro is executed.\par The remainder of this chapter describes the standard edit mode.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Auto Indent}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Auto Indent\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:auto-indent mode\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 You can set the editor so that }{\outl\fs18 RETURN}{\fs20  moves the cursor to the first column of the next line, or so that it follows indentations already set in the text. If the editor is set to put the cursor on column 1 when you press }{\outl\fs18 RETURN}{\fs20  then changing this mode causes the editor to put the cursor on the first non-space character in the next line; if the line is blank, then the cursor is placed under the first non-space character in the first non-blank line above the cursor. The first mode is generally best for line-oriented languages, like assembly language. The second is handy for block-structured languages like GSoft\~BASIC.\par To change the return mode, type }{\outl\fs18 \u-3\'f0RETURN}{\fs20 .\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Select Text}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Select Text\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:select mode\:by line\bxe }}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:select mode\:by character\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 You can use the mouse or the keyboard to select text in the ORCA editor. This section deals with the keyboard selection mechanism; see }{\i\fs20 Using the Mouse}{\fs20 , later in this chapter, for information about selecting text with the mouse.\par The Cut, Copy, Delete and Block Shift commands require that you first select a block of text. The ORCA editor has two modes for selecting text: line-oriented and character-oriented selects. As you move the cursor in line-oriented select mode, text or code is marked a line at a time. In the character-oriented select mode, you can start and end the marked block at any character. Line-oriented select mode is the default for assembly language; for text files and most high-level languages, character-oriented select mode is the default.\par While in either select mode, the following cursor-movement commands are active:\par \par }\pard \s25\fi360\sb40\keepn\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:bottom of screen command}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:top of screen command}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:cursor down command}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:cursor up command}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:start of line command}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:screen move commands}}}{\v\fs20 \par }{\fs20 \bullet \tab bottom of screen\par }\pard \s25\fi360\keepn\widctlpar\adjustright {\fs20 \bullet \tab top of screen\par \bullet \tab cursor down\par \bullet \tab cursor up\par \bullet \tab start of line\par }\pard \s25\fi360\widctlpar\adjustright {\fs20 \bullet \tab screen moves\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par In addition, while in character-oriented select mode, the following cursor-movement commands are active:\par \par }\pard \s25\fi360\sb40\keepn\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:select mode\:by character}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:cursor left command}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:cursor right command}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:tab command}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:tab left command}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:word right command}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:word left command}}}{\v\fs20 \par }{\fs20 \bullet \tab cursor left\par }\pard \s25\fi360\keepn\widctlpar\adjustright {\fs20 \bullet \tab cursor right\par \bullet \tab end of line\par \bullet \tab tab\par \bullet \tab tab left\par \bullet \tab word right\par }\pard \s25\fi360\widctlpar\adjustright {\fs20 \bullet \tab word left\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard \s25\fi360\sb40\keepn\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:RETURN key}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:ESCAPE key}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 As you move the cursor, the text between the original cursor position and the final cursor position is marked (in inverse characters). Press }{\outl\fs18 RETURN}{\fs20  to complete the selection of text. Press the }{\outl\fs18 ESC}{\fs20  key to abort the operation, leave select mode, and return to normal editing.\par To switch between character-oriented and line-oriented selection while in the editor, type }{\outl\fs18 CTRL\u-3\'f0}{\fs20 x.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Hidden Characters}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Hidden Characters\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:tabs}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:hidden characters}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 tabs}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 return characters}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 hidden characters}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 There are cases where line wrapping or tab fields may be confusing. Is there really a new line, or was the line wrapped? Do those eight blanks represent eight spaces, a tab, or some combination of spaces and tabs? To answer these questions, the editor has an alternate display mode that shows hidden characters. To enter this mode, type }{\outl\fs18 \u-3\'f0}{\fs20 =; you leave the mode the same way. While you are in the hidden character mode, end of line characters are displayed as the mouse text return character. Tabs are displayed as a right arrow where the tab character is located, followed by spaces until the next tab stop.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Macros}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Macros\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:macros\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 You can define up to 26 macros for the ORCA editor, one for each letter on the keyboard. A macro allows you to substitute a single keystroke for up to 128 predefined keystrokes. A macro can contain both editor commands and text, and can call other macros.\par }\pard \s25\fi360\sb40\keepn\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:create macros command}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:arrow keys}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:end macro definition command}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 To create a macro, press }{\outl\fs18 \u-3\'f0ESC}{\fs20 . The current macro definitions for A to J appear on the screen. The }{\outl\fs18 LEFT-ARROW}{\fs20  and }{\outl\fs18 RIGHT-ARROW}{\fs20  keys can be used to switch between the three pages of macro definitions. To replace a definition, press the key that corresponds to that macro, then type in the new macro definition. You must be able to see a macro to replace it - use the left and right arrow keys to get the correct page. Press }{\outl\fs18 OPTION}{\fs20  }{\outl\fs18 ESC}{\fs20  to terminate the macro definition. You can include }{\outl\fs18 CTRL}{\i\fs20 key}{\fs20  combinations, }{\outl\fs18 \u-3\'f0}{\fs20 key combinations, }{\outl\fs18 OPTION}{\i\fs20 key}{\fs20  combinations, and the }{\outl\fs18 RETURN}{\fs20 , }{\outl\fs18 ENTER}{\fs20 , }{\outl\fs18 ESC}{\fs20 , and arrow keys. The following conventions are used to display keystrokes in macros:\par \par }\pard \s25\fi360\sb40\keepn\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:macro keystrokes\bxe }}}{\v\fs20 \par }\pard\plain \s32\li360\ri1440\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx2520\adjustright \f4\cgrid {\fs20 Key\tab What You See\par }\pard\plain \s25\li360\ri1440\sb40\keepn\widctlpar\tx2520\adjustright \f4\cgrid {\outl\fs18 CTRL}{\i\fs20 key}{\fs20 \tab The uppercase character key is shown in inverse.\par }{\outl\fs18 \u-3\'f0}{\i\fs20 key}{\fs20 \tab An inverse A followed by key (for example, AK)\par }{\outl\fs18 OPTION}{\i\fs20 key}{\fs20 \tab An inverse B followed by key (for example, BK)\par }{\outl\fs18 ESC}{\fs20 \tab An inverse left bracket (}{\outl\fs18 CTRL}{\fs20  [).\par }{\outl\fs18 RETURN}{\fs20 \tab An inverse M (}{\outl\fs18 CTRL}{\fs20  M).\par }{\outl\fs18 ENTER}{\fs20 \tab An inverse J (}{\outl\fs18 CTRL }{\fs20 J).\par }{\outl\fs18 UP-ARROW}{\fs20 \tab An inverse K (}{\outl\fs18 CTRL }{\fs20 K).\par }{\outl\fs18 DOWN-ARROW}{\fs20 \tab An inverse J (}{\outl\fs18 CTRL }{\fs20 J).\par }{\outl\fs18 LEFT-ARROW}{\fs20 \tab An inverse H (}{\outl\fs18 CTRL }{\fs20 H).\par }{\outl\fs18 RIGHT-ARROW}{\fs20 \tab An inverse U (}{\outl\fs18 CTRL }{\fs20 U).\par }\pard \s25\li360\ri1440\sb40\widctlpar\tx2520\adjustright {\outl\fs18 DELETE}{\fs20 \tab A block\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par Each }{\outl\fs18 \u-3\'f0}{\i\fs20 key}{\fs20  combination or }{\outl\fs18 OPTION}{\i\fs20 key}{\fs20  combination counts as two keystrokes in a macro definition. Although an }{\outl\fs18 \u-3\'f0}{\i\fs20 key}{\fs20  combination looks (in the macro definition) like a }{\outl\fs18 CTRL}{\fs20  A followed by }{\i\fs20 key}{\fs20 , and an }{\outl\fs18 OPTION}{\i\fs20 key}{\fs20  combination looks like a }{\outl\fs18 CTRL }{\fs20 B followed by }{\i\fs20 key}{\fs20 , you cannot enter }{\outl\fs18 CTRL }{\fs20 A when you want an }{\outl\fs18 \u-3\'f0}{\fs20  or }{\outl\fs18 CTRL }{\fs20 B when you want an }{\outl\fs18 OPTION}{\fs20  key.\par }\pard \s25\fi360\sb40\keepn\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:deleting characters in macros}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:end macro definition command}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 If you make a mistake typing a macro definition you can back up with option-}{\outl\fs18 DELETE}{\fs20 . If you wish to retype the macro definition, press }{\outl\fs18 OPTION}{\fs20  }{\outl\fs18 ESC}{\fs20  to terminate the definition, press the letter key for the macro you want to define, and begin over. When you are finished entering macros, press }{\outl\fs18 OPTION}{\fs20  }{\outl\fs18 ESC}{\fs20  to terminate the last option definition, then press }{\outl\fs18 OPTION}{\fs20  to end macro entry. If you have entered any new macro definitions, a dialog will appear asking if you want to save the macros to disk; select OK to save the new macro definitions, and Cancel to return to the editor. If you select Cancel, the macros you have entered will remain in effect until you leave the editor.\par }\pard \s25\fi360\sb40\keepn\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:exit macro creation command}}}{\v\fs20 \par }{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SYSEMAC file}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Macros are saved on disk in the file SYSEMAC in the shell prefix}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 shell prefix}}}{\fs20 . If you are using the GSoft\~BASIC environment, the shell prefix is located in the same directory as GSoft.SYS16.\par }\pard \s25\fi360\sb40\keepn\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:executing macros\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 To execute a macro, hold down }{\outl\fs18 OPTION}{\fs20  and press the key corresponding to that macro.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Using Editor Dialogs}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Using Editor Dialogs\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The text editor makes use of a number of dialogs for operations like entering search strings, selecting a file to open, and informing you of error conditions. The way you select options, enter text, and execute commands in these dialogs is the same for all of them.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:dialogs}}}{\fs20 Figure 6.1 shows the Search and Replace dialog, one of the most comprehensive of all of the editor\rquote s dialogs, and one that happens to illustrate many of the controls used in dialogs.\par \par }\pard \s25\qc\fi360\sb40\keepn\widctlpar\adjustright {\fs20 {\pict{\*\picprop\shplid1027{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex49\picscaley50\piccropl0\piccropr0\piccropt0\piccropb0\picw522\pich238\picwgoal10440\pichgoal4760\macpict\bliptag-1431515892\blipupi72{\*\blipuid aaaccd0cdf546a15cdf9958021211444}10760000000000ee020a1101a00082a0008e01000a0000000002d0024098004200000000002f021000000000002f020a00000000002f020a000102bf0007001fc2ff01fe0007001fc2ff01fe00070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c2000101801403600003e0fe0006060000030000c0cf000101801403600003e0fe0006060000030000c0cf00010180110360000630fe000306000003cc00010180110360000630fe000306000003cc00010180171060000603e3e6f3f7c003e7e6f1c7e3e0c0d200010180171060000603e3e6f3f7c003e7e6f1c7e3e0c0d200010180160f600003e6303706063006030700c63630d100010180160f600003e6303706063006030700c63630d100010180171060000037f3f606063003e30600c63630c0d200010180171060000037f3f606063003e30600c63630c0d200010180160f60000636063606063000333600c633f0d100010180160f60000636063606063000333600c633f0d100010180160f600003e3f3f603f63003e1e601e63030d100010180160f600003e3f3f603f63003e1e601e63030d1000101800f0060f4000203e007d4ff03f80001800f0060f4000203e007d4ff03f80001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600007c6ff03f80001800b02600007c6ff03f8000180070060c200010180070060c200010180980042002f0000005e0210002f0000005e020a002f0000005e020a0001070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c2000101801406600007e00001c0fd0003030000c0d0000101801406600007e00001c0fd0003030000c0d0000101801106600006300000c0fd000003cd000101801106600006300000c0fd000003cd00010180181160000633e7e0c3e3f3e003e7e6f1c7e3e0c0d300010180181160000633e7e0c3e3f3e003e7e6f1c7e3e0c0d3000101801710600007e63630c036063006030700c63630d2000101801710600007e63630c036063006030700c63630d2000101801811600006c7f630c3f607f003e30600c63630c0d3000101801811600006c7f630c3f607f003e30600c63630c0d30001018017106000066607e0c636060000333600c633f0d20001018017106000066607e0c636060000333600c633f0d200010180171060000633f601e3f3f3f003e1e601e63030d200010180171060000633f601e3f3f3f003e1e601e63030d200010180130060fe000006f7000203e007d5ff03f8000180130060fe000006f7000203e007d5ff03f80001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600007c6ff03f80001800b02600007c6ff03f8000180070060c200010180980042005e0000008d0210005e0000008d020a005e0000008d020a0001070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c2000101800a016007c5f703f00001800a016007c5f703f0000180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180150060fd00054180063600c3ec000101c0e300010180150060fd00054180063600c3ec000101c0e300010180140060fd0005838006360003eb0000c0e300010180140060fd0005838006360003eb0000c0e300010180280060fe001d0361800637c1c7e3e003e7e3e3f3e003f3e777e3e6f3e3e003e3f633e0c0e300010180280060fe001d0361800637c1c7e3e003e7e3e3f3e003f3e777e3e6f3e3e003e3f633e0c0e300010180280060fe001d06118006b630c30630060630360630060636b630370636000636363030c0e300010180280060fe001d04118006b630c30630060630360630060636b630370636000636363030c0e300010180280060fe001d04218006b630c307f003e633f607f0060636b633f607f3e007f63633f0c0e300010180280060fe001d04218006b630c307f003e633f607f0060636b633f607f3e007f63633f0c0e300010180280060fe001d042180077630c336000037e6360600060636b7e6360600300603f67630c0e300010180280060fe001d042180077630c336000037e6360600060636b7e6360600300603f67630c0e300010180280060fe001d0293c0063631e1e3f003e603f3f3f003f3e63603f603f3e003f033b3f1e0e300010180280060fe001d0293c0063631e1e3f003e603f3f3f003f3e63603f603f3e003f033b3f1e0e300010180180060fe00010360f9000006fa000006fa000030e000010180180060fe00010360f9000006fa000006fa000030e000010180140060fd000343e003e0f90002c300c0d500010180140060fd000343e003e0f90002c300c0d500010180980042008d000000bc0210008d000000bc020a008d000000bc020a0001120060fd000386300630f9000003d300010180120060fd000386300630f9000003d3000101801c0060fe00110360300603e3e3e003e3e7e3e1c7e1c633e0d7000101801c0060fe00110360300603e3e3e003e3e7e3e1c7e1c633e0d7000101801c0060fe00110610e006003606300606363600c300c63630d7000101801c0060fe00110410e006003606300606363600c300c63630d7000101801c0060fe00110423800603f3e7f003e7f633e0c300c637f0d7000101801c0060fe00110423800603f3e7f003e7f633e0c300c637f0d7000101801b0060fe001004260006363036000036063030c330c366d6000101801b0060fe001004260006363036000036063030c330c366d6000101801b0060fe000b0297f003e3f3e3f003e3f633fde101c3f0d7000101801b0060fe000b0297f003e3f3e3f003e3f633fde101c3f0d7000101800c0060fe00010360c7000101800c0060fe00010360c700010180150060fd000647f006360001c0fc000030d300010180150060fd000647f006360001c0fc000030d300010180150060fd0006803006360000c0fc000030d300010180150060fd0006803006360000c0fc000030d300010180180060fe000d0360600637c3e0c3e00633e6f3f0d300010180180060fe000d0360600637c3e0c3e00633e6f3f0d300010180180060fe000d0610e006b63630c6300636370630d300010180180060fe000d0410e006b63630c6300636370630d300010180180060fe000d04203006b63630c7f006b6360630d300010180180060fe000d04203006b63630c7f006b6360630d300010180180060fe000d04263007763630c60006b6360630d300010180180060fe000d04263007763630c60006b6360630d300010180180060fe000d0293e0063633e1e3f00773e603f0d300010180180060fe000d0293e0063633e1e3f00773e603f0d3000101800c0060fe00010360c7000101800c0060fe00010360c700010180170060fd000640e007e00001c0fd000201c1c0d400010180170060fd000640e007e00001c0fd000201c1c0d400010180160060fd000681e006300000c0fc0001c0c0d400010180160060fd000681e006300000c0fc0001c0c0d400010180190060fe000e0363600633e7e0c3e3f3e003e0c0c0d400010180190060fe000e0363600633e7e0c3e3f3e003e0c0c0d400010180190060fe000e06166007e63630c03606300030c0c0d400010180190060fe000e04166007e63630c03606300030c0c0d400010180190060fe000e0427f006c7f630c3f607f003f0c0c0d400010180190060fe000e0427f006c7f630c3f607f003f0c0c0d400010180190060fe000e042060066607e0c63606000630c0c0d400010180190060fe000e042060066607e0c63606000630c0c0d400010180190060fe000e0290600633f601e3f3f3f003f1e1e0d400010180190060fe000e0290600633f601e3f3f3f003f1e1e0d400010180100060fe00010360fe000006cb00010180100060fe00010360fe000006cb00010180070060c20001018098004200bc000000eb021000bc000000eb020a00bc000000eb020a0001070060c200010180070060c200010180070060c200010180070060c200010180070060c2000101800a016007c5f703f00001800a016007c5f703f0000180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c2000101801c096000081ffffe3ffffff8fe000343e00c0ffeff01fe38d7000101801c096000081ffffe3ffffff8fe000343e00c0ffeff01fe38d7000101801a09600009cfffff3ffffff8fe0002863009fcff0038d7000101801a09600009cfffff3ffffff8fe0002863009fcff0038d7000101801c15600009cc181f3c1c0c18000003667009fc181c0c1f38d7000101801c15600009cc181f3c1c0c18000003667009fc181c0c1f38d7000101801c1560000819c9cf3fc9f9c800000616b009ffc9c9f9cf38d7000101801c1560000819c9cf3fc9f9c800000416b009ffc9c9f9cf38d7000101801c156000093809cf3c09f808000004273009fc09c9f80f38d7000101801c156000093809cf3c09f808000004273009fc09c9f80f38d7000101801c1560000999f81f39c9f9f8000004263009f9c9c9f9ff38d7000101801c1560000999f81f39c9f9f8000004263009f9c9c9f9ff38d7000101801c15600009cc09fe1c0c0c0800000293e00c0c09cc0c0e18d7000101801c15600009cc09fe1c0c0c0800000293e00c0c09cc0c0e18d700010180190460000ffff9fdff06f800000360000ffcff00f8d700010180190460000ffff9fdff06f800000360000ffcff00f8d700010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c20001018098004200eb000000ee021000eb000000ee020a00eb000000ee020a000107001fc2ff01fe0007001fc2ff01fe0002bf00a0008fa00083ff}}{\fs20 \par \par }\pard \s25\qc\fi360\sb40\widctlpar\adjustright {\fs20 Figure 6.1\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:edit line items}}}{\fs20 The first item in this dialog is an edit line control that lets you enter a string. When the dialog first appears, the cursor is at the beginning of this line. You can use any of the line editing commands from throughout the ORCA programming environment to enter and edit a string in this edit line control; these line editing commands are summarized in the table below.\par \par }\pard\plain \s32\fi-1800\li2160\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \adjustright \f4\cgrid {\fs20 command\tab command name and effect\par }\pard\plain \s25\fi-1800\li2160\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi-1800\li2160\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:edit line controls}}}{\v\fs20 \par }{\outl\fs18 LEFT-ARROW}{\fs20 \tab }{\b\fs20 cursor left}{\fs20  - The cursor will move to the left.\par }{\outl\fs18 RIGHT-ARROW}{\fs20 \tab }{\b\fs20 cursor right}{\fs20  - The cursor will move to the right. \par }{\outl\fs18 \u-3\'f0}{\fs20 > or }{\outl\fs18 \u-3\'f0}{\fs20 .\tab }{\b\fs20 end of line}{\fs20  - The cursor will move to the right-hand end of the string.\par }{\outl\fs18 \u-3\'f0}{\fs20 < or }{\outl\fs18 \u-3\'f0}{\fs20 ,\tab }{\b\fs20 start of line}{\fs20  - The cursor will move to the left-hand end of the string.\par }{\outl\fs18 \u-3\'f0}{\fs20 Y or }{\outl\fs18 CTRL}{\fs20 Y\tab }{\b\fs20 delete to end of line}{\fs20  - Deletes characters from the cursor to the end of the line.\par }{\outl\fs18 \u-3\'f0}{\fs20 Z or }{\outl\fs18 CTRL}{\fs20 Z\tab }{\b\fs20 undo}{\fs20  - Resets the string to the starting string.\par }{\outl\fs18 ESC}{\fs20  or }{\outl\fs18 CTRL}{\fs20 X\tab }{\b\fs20 exit}{\fs20  - Stops string entry, leaving the dialog without changing the default string or executing the command.\par }{\outl\fs18 \u-3\'f0}{\fs20 E or }{\outl\fs18 CTRL}{\fs20 E\tab }{\b\fs20 toggle insert mode}{\fs20  - Switches between insert and over strike mode. The dialog starts out in the same mode as the editor, but switching the mode in the dialog does not change the mode in the editor.\par }\pard \s25\fi-1800\li2160\sb40\widctlpar\adjustright {\outl\fs18 DELETE}{\fs20 \tab }{\b\fs20 delete character left}{\fs20  - Deletes the character to the left of the cursor, moving the cursor left.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:tabs}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 tabs}}}{\fs20 The Search and Replace dialog has two edit line items; you can move between them using the }{\outl\fs18 TAB}{\fs20  key. You may also need to enter a tab character in a string, either to search specifically for a string that contains an imbedded tab character, or to place a tab character in a string that will replace the string once it is found. To enter a tab character in an edit line string, use }{\outl\fs18 \u-3\'f0TAB}{\fs20 . While only one space will appear in the edit line control, this space does represent a tab character.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:check boxes}}}{\fs20 Four options appear below the edit line controls. Each of these options is preceded by an }{\outl\fs18 \u-3\'f0}{\fs20  character and a number. Pressing }{\outl\fs18 \u-3\'f0}{\fs20 x, where x is the number, selects the option, and causes a check mark to appear to the left of the option. Repeating the operation deselects the option, removing the check mark. You can also select and deselect options by using the mouse to position the cursor over the item, anywhere on the line from the }{\outl\fs18 \u-3\'f0}{\fs20  character to the last character in the label, and clicking.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:buttons}}}{\fs20 At the bottom of the dialog is a pair of buttons; some dialogs have more than two, while some have only one. These buttons cause some action to occur. In general, all but one of these buttons will have an }{\outl\fs18 \u-3\'f0}{\fs20  character and a number to the left of the button. You can select a button in one of several ways: by clicking on the button with the mouse, by pressing the }{\outl\fs18 RETURN}{\fs20  key (for the default button, which is the one without an }{\outl\fs18 \u-3\'f0}{\fs20  character), by pressing }{\outl\fs18 \u-3\'f0}{\fs20 x, or by pressing the first letter of the label on the button. (For dialogs with an edit line item, the last option is not available.)\par Once an action is selected by pressing a button, the dialog will vanish and the action will be carried out.\par \par }\pard \s25\qc\fi360\sb40\keepn\widctlpar\adjustright {\fs20 {\pict{\*\picprop\shplid1028{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex50\picscaley50\piccropl0\piccropr0\piccropt0\piccropb0\picw417\pich208\picwgoal8340\pichgoal4160\macpict\bliptag1990922539\blipupi72{\*\blipuid 76ab112bdded95807d2f27afb14cc83c}0fa80000000000d001a11101a00082a0008e01000a0000000002d0024098003600000000003a01a800000000003a01a100000000003a01a1000102cb0008001fcfff00fcff0008001fcfff00fcff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff001203600003e0fc000307f0c1c0db000003ff001203600003e0fc000307f0c1c0db000003ff00120360000630fc0003060000c0db000003ff00120360000630fc0003060000c0db000003ff00150d60000637e3e7e003e00601c0c3e0dc000003ff00150d60000637e3e7e003e00601c0c3e0dc000003ff001502600006fe360730003007e0c0c630dc000003ff001502600006fe360730003007e0c0c630dc000003ff00150d6000063637f63003f00600c0c7f0dc000003ff00150d6000063637f63003f00600c0c7f0dc000003ff00140c60000637e6063006300600c0c6db000003ff00140c60000637e6063006300600c0c6db000003ff00150d600003e603f63003f00601e1e3f0dc000003ff00150d600003e603f63003f00601e1e3f0dc000003ff000b0360000006d2000003ff000b0360000006d2000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff001810600000063007e0c006000c600fe0038060df000003ff001810600000063007e0c006000c600fe0038060df000003ff001810600000077006300006000ee00c00018060df000003ff001810600000077006300006000ee00c00018060df000003ff001a12600000c6b63631c3e6318d6c6c07c187e7cde0e1000003ff001a12600000c6b63631c3e6318d6c6c07c187e7cde0e1000003ff00191160000006b63630c606600d6c6fcc618c6c6ee0000003ff00191160000006b63630c606600d6c6fcc618c6c6ee0000003ff001911600000c6363630c3e7c18c6c6c0c618c6fece0000003ff001911600000c6363630c3e7c18c6c6c0c618c6fece0000003ff0019116000000633f630c036600c67ec0c618c6c0ce0000003ff0019116000000633f630c036600c67ec0c618c6c0ce0000003ff001911600000063037e1e3e6300c606c07c3c7e7ece0000003ff001911600000063037e1e3e6300c606c07c3c7e7ece0000003ff00120060fe000103e0fc000107c0db000003ff00980036003a0000007401a8003a0000007401a1003a0000007401a10001120060fe000103e0fc000107c0db000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff000e02600007ddff00f8f6000003ff000e02600007ddff00f8f6000003ff002002600018fe0005080f3e3fff3fe7ff09f8c6004180081f3ff9f8fe000003ff002002600018fe0005080f3e3fff3fe7ff09f8c6004180081f3ff9f8fe000003ff002002600018fe000509ffff3ffe3fe7ff09fbf600838009cffff9f8fe000003ff002002600018fe000509ffff3ffe3fe7ff09fbf600838009cffff9f8fe000003ff002002600018fe000509fe3f3c1f3fe7ff09fede03618009ce3c19c8fe000003ff002002600018fe000509fe3f3c1f3fe7ff09fede03618009ce3c19c8fe000003ff002002600018fe0005081f3f39cf3fe7ff09fcce06118009cf39f998fe000003ff002002600018fe0005081f3f39cf3fe7ff09fcce04118009cf39f998fe000003ff002002600018fe000509ff3f380f3fe7ff09f8c604218009cf3c1838fe000003ff002002600018fe000509ff3f380f3fe7ff09f8c604218009cf3c1838fe000003ff002002600018fe000509ff3f39ff3fe7ff09f8c604218009cf3fc998fe000003ff002002600018fe000509ff3f39ff3fe7ff09f8c604218009cf3fc998fe000003ff002002600018fe000509fe1e1c0e1fe7ff09f8c60293c0081e1c19c8fe000003ff002002600018fe000509fe1e1c0e1fe7ff09f8c60293c0081e1c19c8fe000003ff001b02600018fe00000fe2ff05f8c60360000ffeff00f8fe000003ff001b02600018fe00000fe2ff05f8c60360000ffeff00f8fe000003ff001702600018fe000407f001c030e600011806f6000003ff001702600018fe000407f001c030e600011806f6000003ff00170a60001803f000060000c030e600011806f6000003ff00170a60001803f000060000c030e600011806f6000003ff00190c600018061fe00603e0c3f3e6f0e800011806f6000003ff00190c600018061fe00603e0c3f3e6f0e800011806f6000003ff00180b60001806003007e630c63637e700011806f6000003ff00180b60001806003007e630c63637e700011806f6000003ff00180b600018060030060630c637f6e700011806f6000003ff00180b600018060030060630c637f6e700011806f6000003ff00180b600018060030060630c63606e700011806f6000003ff00180b600018060030060630c63606e700011806f6000003ff00180b60001807fff00603e1e3f3f6e700011806f6000003ff00180b60001807fff00603e1e3f3f6e700011806f6000003ff000f02600018de00011806f6000003ff000f02600018de00011806f6000003ff001702600018de00091aae0043e00c1ffffff8fe000003ff001702600018de00091d560043e00c1ffffff8fe000003ff001702600018de00091aae00863009cffffff8fe000003ff001702600018de00091d5600863009cffffff8fe000003ff001702600018de00091aae03603009c81c1818fe000003ff001702600018de00091d5603603009c81c1818fe000003ff001702600018de00051aae0610e009fec900c8fe000003ff001702600018de00051d560410e009fec900c8fe000003ff001702600018de00091aae04238009c9c809c8fe000003ff009800360074000000ae01a80074000000ae01a10074000000ae01a100011702600018de00091d5604238009c9c809c8fe000003ff001702600018de00091aae04260009c819f9c8fe000003ff001702600018de00091d5604260009c819f9c8fe000003ff001702600018de00091aae0297f00c19fc09c8fe000003ff001702600018de00091d560297f00c19fc09c8fe000003ff001702600018de00091aae0360000ff9fffff8fe000003ff001702600018de00091d560360000ff9fffff8fe000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff001702600018de000d1aae0047f00c1e3ffffff8000003ff001702600018de000d1d560047f00c1e3ffffff8000003ff001702600018de000d1aae00803009cf3ffffff8000003ff001702600018de000d1d5600803009cf3ffffff8000003ff001702600018de000d1aae03606009ff3c1c1c18000003ff001702600018de000d1d5603606009ff3c1c1c18000003ff001702600018de000d1aae0610e009ff39c9f9c8000003ff001702600018de000d1d560410e009ff39c9f9c8000003ff001702600018de000d1aae04203009ff39cc1808000003ff001702600018de000d1d5604203009ff39cc1808000003ff001702600018de000d1aae04263009cf39cfc9f8000003ff001702600018de000d1d5604263009cf39cfc9f8000003ff001702600018de00061aae0293e00c1efe1c0308000003ff001702600018de00061d560293e00c1efe1c0308000003ff001602600018de00051aae0360000ffdff03f8000003ff001602600018de00051d560360000ffdff03f8000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff001602600018de000618c60040e00607fdff021c0003ff001602600018de000618c60040e00607fdff021c0003ff001502600018de000518c60081e004fcff029c0003ff0098003600ae000000d001a800ae000000d001a100ae000000d001a100011502600018de000518c60081e004fcff029c0003ff001702600018de000d18c603636004fe0c0e060f9c0003ff001702600018de000d18c603636004fe0c0e060f9c0003ff001702600018de000d18c606166004ffe4e4fce79c0003ff001702600018de000d18c604166004ffe4e4fce79c0003ff001702600018de000d1cce0427f004fe04e4fc079c0003ff001702600018de000d1cce0427f004fe04e4fc079c0003ff001702600018de000d1ede04206004fce4e4fcff9c0003ff001702600018de000d1ede04206004fce4e4fcff9c0003ff001702600018de000d1bf6029060060604e606070c0003ff001702600018de000d1bf6029060060604e606070c0003ff001502600018de000518c603600007fcff02fc0003ff001502600018de000518c603600007fcff02fc0003ff000e02600007ddff00f8f6000003ff000e02600007ddff00f8f6000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff0008001fcfff00fcff0008001fcfff00fcff0002cb00a0008fa00083ff}}{\fs20 \par \par }\pard \s25\qc\fi360\sb40\widctlpar\adjustright {\fs20 Figure 6.2\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:list controls}}}{\fs20 Figure 6.2 shows the Open dialog. This dialog contains a list control, used to display a list of files and directories.\par You can scroll through the list by clicking on the arrows with the mouse, dragging the thumb with the mouse (the thumb is the space in the gray area between the up and down arrows), clicking in the gray area above or below the thumb, or by using the up and down arrow keys.\par If there are any files in the list, one will always be selected. For commands like Open that require a file name you will be able to select any file in the list; for commands like New that present the file list so you know what file names are already in use, only directories can be selected. You can change which file is selected by clicking on another file or by using the up or down arrow keys. If you click on the selected name while a directory is selected, the directory is opened. If you click on a selected file name, the file is opened.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Using the Mouse}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Using the Mouse\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:mouse}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 mouse}}}{\fs20 All of the features of the editor can be used without a mouse, but the mouse can also be used for a number of functions. If you prefer not to use a mouse, simply ignore it. You can even disconnect the mouse, and the ORCA editor will perform perfectly as a keyboard-based editor.\par The most common use for the mouse is moving the cursor and selecting text. To position the cursor anywhere on the screen, move the mouse. As soon as the mouse is moved, an arrow will appear on the screen; position this arrow where you would like to position the cursor and click.\par Several editor commands require you to select some text. You can select the text before using the command by clicking to start a selection, then dragging the mouse while holding down the button while you move to the other end of the selection. Unlike keyboard selection, mouse selections are always done in character select mode. You can also select words by double-clicking to start the selection, or lines by triple clicking to start the selection. Finally, if you drag the mouse off of the screen while selecting text, the editor will start to scroll one line at a time.\par The mouse can also be used to select dialog buttons, change dialog options, and scroll list items in a dialog. See }{\i\fs20 Using Editor Dialogs}{\fs20  in this chapter for details.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Command Descriptions}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Command Descriptions\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 This section describes the functions that can be performed with editor commands. The key assignments for each command are shown with the command description.\par Screen-movement descriptions in this manual are based on the direction the display screen moves through the file, not the direction the lines appear to move on the screen. For example, if a command description says that the screen scrolls down one line, it means that the lines on the screen move up one line, and the next line in the file becomes the bottom line on the screen.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 CTRL}{\fs20 @\tab }{\b\fs20 About}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:about command\bxe }}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:version\bxe }}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 version\:editor}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Shows the current version number and copyright for the editor. Press any key or click the mouse button to get rid of the About dialog.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 CTRL}{\fs20 G\tab }{\b\fs20 Beep the Speaker}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:beep the speaker command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The ASCII control character BEL ($07) is sent to the output device. Normally, this causes the speaker to beep.\par \par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 \u-3\'f0}{\fs20 , or }{\outl\fs18 \u-3\'f0}{\fs20 <\tab }{\b\fs20 Beginning of Line}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:beginning of line command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The cursor is placed in column one of the current line.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 \u-3\'f0DOWN-ARROW\tab }{\b\fs20 Bottom of Screen / Page Down}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:bottom of screen command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The cursor moves to the last visible line on the screen, preserving the cursor\rquote s horizontal position. If the cursor is already at the bottom of the screen, the screen scrolls down twenty-two lines.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 CTRL}{\fs20 C or }{\outl\fs18 \u-3\'f0}{\fs20 C\tab }{\b\fs20 Copy}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:copy command\bxe }}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SYSTEMP file}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 work prefix}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:paste command}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 When you execute the Copy command, the editor enters select mode, as discussed in the section }{\i\fs20 Select Text}{\fs20  in this chapter. Use cursor-movement or screen-scroll commands to mark a block of text (all other commands are ignored), then press }{\outl\fs18 RETURN}{\fs20 . The selected text is written to the file SYSTEMP in the work prefix. (To cancel the Copy operation without writing the block to SYSTEMP, press }{\outl\fs18 ESC}{\fs20  instead of }{\outl\fs18 RETURN}{\fs20 .) Use the Paste command to place the copied material at another position in the file.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 CTRL}{\fs20 W or }{\outl\fs18 \u-3\'f0}{\fs20 W\tab }{\b\fs20 Close}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:close command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Closes the active file. If the file has been changed since the last update, a dialog will appear, giving you a chance to abort the close, save the changes, or close the file without saving the changes. If the active file is the only open file, the editor exits after closing the file; if there are other open files, the editor selects the next file to become the active file.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 DOWN-ARROW}{\fs20 \tab }{\b\fs20 Cursor Down}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:cursor down command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The cursor is moved down one line, preserving its horizontal position. If it is on the last line of the screen, the screen scrolls down one line.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 LEFT-ARROW}{\fs20 \tab }{\b\fs20 Cursor Left}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:cursor left command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The cursor is moved left one column. If it is in column one, the command is ignored.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 RIGHT-ARROW}{\fs20 \tab }{\b\fs20 Cursor Right}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:cursor right command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The cursor is moved right one column. If it is on the end-of-line marker (usually column 80), the command is ignored.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 UP-ARROW}{\fs20 \tab }{\b\fs20 Cursor Up}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:cursor up command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The cursor is moved up one line, preserving its horizontal position. If it is on the first line of the screen, the screen scrolls up one line. If the cursor is on the first line of the file, the command is ignored.\par \par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 CTRL}{\fs20 X or }{\outl\fs18 \u-3\'f0}{\fs20 X\tab }{\b\fs20 Cut}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:cut command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 When you execute the Cut command, the editor enters select mode, as discussed in the section }{\i\fs20 Select Text}{\fs20  in this chapter. Use cursor-movement or screen-scroll commands to mark a block of text (all other commands are ignored), then press }{\outl\fs18 RETURN}{\fs20 . The selected text is written to the file SYSTEMP in the work prefix, and deleted from the file. (To cancel the Cut operation without cutting the block from the file, press }{\outl\fs18 ESC}{\fs20  instead of }{\outl\fs18 RETURN}{\fs20 ). Use the Paste command to place the cut text at another location in the file.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 \u-3\'f0ESC}{\fs20 \tab }{\b\fs20 Define Macros}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:define macros command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The editor enters the macro definition mode. Press }{\outl\fs18 OPTION}{\fs20  }{\outl\fs18 ESC}{\fs20  to terminate a definition, and }{\outl\fs18 OPTION}{\fs20  to terminate macro definition mode. The macro definition process is described in the section }{\i\fs20 Macros}{\fs20  in this chapter.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 \u-3\'f0DELETE}{\fs20 \tab }{\b\fs20 Delete}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:delete command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 When you execute the delete command, the editor enters select mode, as discussed in the section }{\i\fs20 Select Text}{\fs20  in this chapter. Use any of the cursor movement or screen-scroll commands to mark a block of text (all other commands are ignored), then press }{\outl\fs18 RETURN}{\fs20 . The selected text is deleted from the file. (To cancel the delete operation without deleting the block from the file, press }{\outl\fs18 ESC}{\fs20  instead of }{\outl\fs18 RETURN}{\fs20 .)\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 CTRL}{\fs20 F or }{\outl\fs18 \u-3\'f0}{\fs20 F\tab }{\b\fs20 Delete Character\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:delete character command\bxe }}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:undo delete buffer}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:undo command}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The character that the cursor is on is deleted and put in the Undo buffer (see the description of the Undo command). Characters to the right of the cursor are moved one column to the left to fill in the gap.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 DELETE}{\fs20  or }{\outl\fs18 CTRL}{\fs20 D\tab }{\b\fs20 Delete Character Left}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:delete character left command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The character to the left of the cursor is deleted, and the character that the cursor is on, as well as the rest of the line to the right of the cursor, are moved 1 column to the left to fill in the gap. If the cursor is in column one and the over strike mode is active, no action is taken. If the cursor is in column one and the insert mode is active, then the line the cursor is on is appended to the line above and the cursor remains on the character it was on before the delete. Deleted characters are put in the undo buffer.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 \u-3\'f0}{\fs20 T or }{\outl\fs18 CTRL}{\fs20 T\tab }{\b\fs20 Delete Line}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:delete line command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The line that the cursor is on is deleted, and the following lines are moved up one line to fill in the space. The deleted line is put in the Undo buffer (see the description of the Undo command).\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 CTRL}{\fs20 Y or }{\outl\fs18 \u-3\'f0}{\fs20 Y\tab }{\b\fs20 Delete to EOL}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:delete to end of line command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The character that the cursor is on, and all those to the right of the cursor to the end of the line, are deleted and put in the Undo buffer (see the description of the Undo command).\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 \u-3\'f0}{\fs20 G\tab }{\b\fs20 Delete Word}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:delete word command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 When you execute the delete word command, the cursor is moved to the beginning of the word it is on, then delete character commands are executed for as long as the cursor is on a non-space character, then for as long as the cursor is on a space. This command thus deletes the word plus all spaces up to the beginning of the next word. If the cursor is on a space, that space and all following spaces are deleted, up to the start of the next word. All deleted characters, including spaces, are put in the Undo buffer (see the description of the Undo command).\par \par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 \u-3\'f0}{\fs20 . or }{\outl\fs18 \u-3\'f0}{\fs20 >\tab }{\b\fs20 End of Line\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:end of line command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 If the last column on the line is not blank, the cursor moves to the last column. If the last column is blank, then the cursor moves to the right of the last non-space character in the line. If the entire line is blank, the cursor is placed in column one.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 \u-3\'f0}{\fs20 ? or }{\outl\fs18 \u-3\'f0}{\fs20 /\tab }{\b\fs20 Help\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:help command\bxe }}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SYSHELP file}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 shell prefix}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Displays the help file, which contains a short summary of editor commands. Use }{\outl\fs18 ESC}{\fs20  to return to the file being edited.\par The help file is a text file called SYSHELP, found in the shell prefix. Since it is a text file, you can modify it as desired.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 \u-3\'f0}{\fs20 B or }{\outl\fs18 CTRL}{\fs20 B\tab }{\b\fs20 Insert Line\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:insert line command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 A blank line is inserted at the cursor position, and the line the cursor was on and the lines below it are scrolled down to make room. The cursor remains in the same horizontal position on the screen.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 \u-3\'f0SPACEBAR}{\fs20 \tab }{\b\fs20 Insert Space\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:insert space command\bxe }}}{\v\fs20 \par }{\fs20 A space is inserted at the cursor position. Characters from the cursor to the end of the line are moved right to make room. Any character in column 255 on the line is lost. The cursor remains in the same position on the screen. Note that the Insert Space command can extend a line past the end-of-line marker.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 CTRL}{\fs20 N or }{\outl\fs18 \u-3\'f0}{\fs20 N\tab }{\b\fs20 New\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:new command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 A dialog like the one shown in Figure\~6.3 appears. You need to enter a name for the new file. After entering a name, the editor will open an empty file using one of the ten available file buffers. The file\rquote s location on disk will be determined by the directory showing in the dialog\rquote s list box.\par While the New command requires selecting a file name, no file is actually created until you save the file with the Save command.\par \par }\pard \s25\qc\fi360\sb40\keepn\widctlpar\adjustright {\fs20 {\pict{\*\picprop\shplid1029{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex50\picscaley50\piccropl0\piccropr0\piccropt0\piccropb0\picw415\pich262\picwgoal8300\pichgoal5240\macpict\bliptag216033400\blipupi72{\*\blipuid 0ce06878b640b85fd7259633d8998b3d}117200000001010601a01101a00082a03039a0008e01000a0000000002d0024098003400000000003b01a000000001003b01a000000001003b01a0000106001fcfff00fc06001fcfff00fc060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003120c60000630000007f0c1c0000630db000003120c60000630000007f0c1c0000630db000003120c600006300000060000c0000630db000003120c600006300000060000c0000630db000003150f60000733e6300601c0c3e00733e773e0de000003150f60000733e6300601c0c3e00733e773e0de000003150f600007f6363007e0c0c63007f036b630de000003150f600007f6363007e0c0c63007f036b630de000003150f60000677f6300600c0c7f00673f6b7f0de000003150f60000677f6b00600c0c7f00673f6b7f0de000003140e6000063606b00600c0c600063636b6dd000003140e6000063606b00600c0c600063636b6dd000003150f60000633f3e00601e1e3f00633f633f0de000003150f60000633f3e00601e1e3f00633f633f0de000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf0000031610600000063007e0c006000c600fe0038060df0000031610600000063007e0c006000c600fe0038060df0000031610600000077006300006000ee00c00018060df0000031610600000077006300006000ee00c00018060df0000031812600000c6b63631c3e6318d6c6c07c187e7cde0e10000031812600000c6b63631c3e6318d6c6c07c187e7cde0e1000003171160000006b63630c606600d6c6fcc618c6c6ee0000003171160000006b63630c606600d6c6fcc618c6c6ee00000031711600000c6363630c3e7c18c6c6c0c618c6fece0000003980034003b0000007601a0003b0001007601a0003b0001007601a000011711600000c6363630c3e7c18c6c6c0c618c6fece000000317116000000633f630c036600c67ec0c618c6c0ce000000317116000000633f630c036600c67ec0c618c6c0ce00000031711600000063037e1e3e6300c606c07c3c7e7ece00000031711600000063037e1e3e6300c606c07c3c7e7ece0000003100060fe000103e0fc000107c0db000003100060fe000103e0fc000107c0db000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf0000030c02600007ddff00f8f60000030c02600007ddff00f8f60000031e02600018fe000507f0c1c000c0e7000918c6004180081f3ff9f8fe0000031e02600018fe000507f0c1c000c0e7000918c6004180081f3ff9f8fe0000031e02600018fe0005060000c001c0e700091bf600838009cffff9f8fe0000031e02600018fe0005060000c001c0e700091bf600838009cffff9f8fe0000031e02600018fe00050601c0c3e0c0e700091ede03618009ce3c19c8fe0000031e02600018fe00050601c0c3e0c0e700091ede03618009ce3c19c8fe0000031e02600018fe000507e0c0c630c0e700091cce06118009cf39f998fe0000031e02600018fe000507e0c0c630c0e700091cce04118009cf39f998fe0000031e02600018fe00050600c0c7f0c0e7000918c604218009cf3c1838fe0000031e02600018fe00050600c0c7f0c0e7000918c604218009cf3c1838fe0000031e02600018fe00050600c0c600c0e7000918c604218009cf3fc998fe0000031e02600018fe00050600c0c600c0e7000918c604218009cf3fc998fe0000031e02600018fe00050601e1e3f1e0e7000918c60293c0081e1c19c8fe0000031e02600018fe00050601e1e3f1e0e7000918c60293c0081e1c19c8fe0000031502600018de000518c60360000ffeff00f8fe0000031502600018de000518c60360000ffeff00f8fe0000031502600018fe0004080ffe3fcfe6ff01f806f60000031502600018fe0004080ffe3fcfe6ff01f806f6000003150a60001803f00009ffff3fcfe6ff01f806f6000003150a60001803f00009ffff3fcfe6ff01f806f6000003170c600018061fe009fc1f3c0c190fe8ff01f806f6000003170c600018061fe009fc1f3c0c190fe8ff01f806f6000003160b6000180600300819cf39c9c8e7ff01f806f6000003160b6000180600300819cf39c9c8e7ff01f806f6000003160b60001806003009f9cf39c809e7ff01f806f6000003160b60001806003009f9cf39c809e7ff01f806f6000003160b60001806003009f9cf39c9f9e7ff01f806f6000003160b60001806003009f9cf39c9f9e7ff01f806f6000003160b60001807fff009fc1e1c0c09e7ff01f806f6000003160b60001807fff009fc1e1c0c09e7ff01f806f60000031102600018fe00000fe2ff01f806f60000031102600018fe00000fe2ff01f806f60000031502600018de00091aae0043e00c1ffffff8fe0000031502600018de00091d560043e00c1ffffff8fe0000031502600018de00091aae00863009cffffff8fe0000031502600018de00091d5600863009cffffff8fe0000039800340076000000b101a00076000100b101a00076000100b101a000011502600018de00091aae03603009c81c1818fe0000031502600018de00091d5603603009c81c1818fe0000031502600018de00051aae0610e009fec900c8fe0000031502600018de00051d560410e009fec900c8fe0000031502600018de00091aae04238009c9c809c8fe0000031502600018de00091d5604238009c9c809c8fe0000031502600018de00091aae04260009c819f9c8fe0000031502600018de00091d5604260009c819f9c8fe0000031502600018de00091aae0297f00c19fc09c8fe0000031502600018de00091d560297f00c19fc09c8fe0000031502600018de00091aae0360000ff9fffff8fe0000031502600018de00091d560360000ff9fffff8fe0000030d02600018de00011aaef60000030d02600018de00011d56f60000030d02600018de00011aaef60000030d02600018de00011d56f60000030d02600018de00011aaef60000030d02600018de00011d56f60000030d02600018de00011aaef60000030d02600018de00011d56f60000030d02600018de00011aaef60000030d02600018de00011d56f60000030d02600018de00011aaef60000030d02600018de00011d56f60000030d02600018de00011aaef60000030d02600018de00011d56f60000030d02600018de00011aaef60000030d02600018de00011d56f60000031502600018de000d1aae0047f00c1e3ffffff80000031502600018de000d1d560047f00c1e3ffffff80000031502600018de000d1aae00803009cf3ffffff80000031502600018de000d1d5600803009cf3ffffff80000031502600018de000d1aae03606009ff3c1c1c180000031502600018de000d1d5603606009ff3c1c1c180000031502600018de000d1aae0610e009ff39c9f9c80000031502600018de000d1d560410e009ff39c9f9c80000031502600018de000d1aae04203009ff39cc18080000031502600018de000d1d5604203009ff39cc18080000031502600018de000d1aae04263009cf39cfc9f80000031502600018de000d1d5604263009cf39cfc9f80000031502600018de00061aae0293e00c1efe1c03080000031502600018de00061d560293e00c1efe1c03080000031402600018de00051aae0360000ffdff03f80000031402600018de00051d560360000ffdff03f80000030d02600018de00011aaef60000030d02600018de00011d56f60000030d02600018de00011aaef60000030d02600018de00011d56f60000030d02600018de00011aaef60000030d02600018de00011d56f60000030d02600018de00011aaef60000030d02600018de00011d56f60000030d02600018de00011aaef60000030d02600018de00011d56f60000030d02600018de00011aaef60000030d02600018de00011d56f60000030d02600018de00011aaef60000030d02600018de00011d56f60000030d02600018de00011aaef600000398003400b1000000ec01a000b1000100ec01a000b1000100ec01a000010d02600018de00011d56f60000031402600018de000618c60040e00607fdff021c00031402600018de000618c60040e00607fdff021c00031302600018de000518c60081e004fcff029c00031302600018de000518c60081e004fcff029c00031502600018de000d18c603636004fe0c0e060f9c00031502600018de000d18c603636004fe0c0e060f9c00031502600018de000d18c606166004ffe4e4fce79c00031502600018de000d18c604166004ffe4e4fce79c00031502600018de000d1cce0427f004fe04e4fc079c00031502600018de000d1cce0427f004fe04e4fc079c00031502600018de000d1ede04206004fce4e4fcff9c00031502600018de000d1ede04206004fce4e4fcff9c00031502600018de000d1bf6029060060604e606070c00031502600018de000d1bf6029060060604e606070c00031302600018de000518c603600007fcff02fc00031302600018de000518c603600007fcff02fc00030c02600007ddff00f8f60000030c02600007ddff00f8f6000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf0000031808600007f0c1c0000630e1000647f00c1ffffff8fe0000031808600007f0c1c0000630e1000647f00c1ffffff8fe00000318086000060000c0000630e10006860009cffffff8fe00000318086000060000c0000630e10006860009cffffff8fe0000031c0b60000601c0c3e00733e773e0e500070367e009fc19cc18fe0000031c0b60000601c0c3e00733e773e0e500070367e009fc19cc18fe0000031c0b600007e0c0c63007f036b630e500070610300c1fc9c9c8fe0000031c0b600007e0c0c63007f036b630e500070410300c1fc9c9c8fe0000031c0b60000600c0c7f00673f6b7f0e500070420300fcc09c808fe0000031c0b60000600c0c7f00673f6b7f0e500070420300fcc09c808fe0000031b0a60000600c0c600063636b6e4000704263009c9cc99f8fe0000031b0a60000600c0c600063636b6e4000704263009c9cc99f8fe0000031c0b60000601e1e3f00633f633f0e500070293e00c1c0e3c08fe0000031c0b60000601e1e3f00633f633f0e500070293e00c1c0e3c08fe000003160060f7000007e6ff04fc0360000ffeff00f8fe000003160060f7000007e6ff04fc0360000ffeff00f8fe0000030c02600018dd000003f60000030c02600018dd000003f60000030c02600018dd000003f60000030c02600018dd000003f60000030c02600018dd000003f60000030c02600018dd000003f60000030c02600018dd000003f60000030c02600018dd000003f60000030c02600018dd000003f60000030c02600018dd000003f600000398003400ec0000010601a000ec0001010601a000ec0001010601a000010c02600018dd000003f60000030c02600018dd000003f60000030c02600018dd000003f60000030c02600018dd000003f60000030c02600018dd000003f60000030c02600018dd000003f60000030c02600007ddff00fcf60000030c02600007ddff00fcf6000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf000003060060cf00000306001fcfff00fc06001fcfff00fca0008fa00083ff}}{\fs20 \par \par }\pard \s25\qc\fi360\sb40\widctlpar\adjustright {\fs20 Figure 6.3\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 CTRL}{\fs20 O or }{\outl\fs18 \u-3\'f0}{\fs20 O\tab }{\b\fs20 Open\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:open command\bxe }}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:multiple files}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The editor can edit up to ten files at one time. When the open command is used, the editor moves to the first available file buffer, then brings up the dialog shown in Figure 6.4. If there are no empty file buffers, the editor beeps, and the command is aborted.\par \par }\pard \s25\qc\fi360\sb40\keepn\widctlpar\adjustright {\fs20 {\pict{\*\picprop\shplid1030{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex50\picscaley50\piccropl0\piccropr0\piccropt0\piccropb0\picw417\pich208\picwgoal8340\pichgoal4160\macpict\bliptag1990922539\blipupi72{\*\blipuid 76ab112bdded95807d2f27afb14cc83c}0fa80000000000d001a11101a00082a0008e01000a0000000002d0024098003600000000003a01a800000000003a01a100000000003a01a1000102cb0008001fcfff00fcff0008001fcfff00fcff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff001203600003e0fc000307f0c1c0db000003ff001203600003e0fc000307f0c1c0db000003ff00120360000630fc0003060000c0db000003ff00120360000630fc0003060000c0db000003ff00150d60000637e3e7e003e00601c0c3e0dc000003ff00150d60000637e3e7e003e00601c0c3e0dc000003ff001502600006fe360730003007e0c0c630dc000003ff001502600006fe360730003007e0c0c630dc000003ff00150d6000063637f63003f00600c0c7f0dc000003ff00150d6000063637f63003f00600c0c7f0dc000003ff00140c60000637e6063006300600c0c6db000003ff00140c60000637e6063006300600c0c6db000003ff00150d600003e603f63003f00601e1e3f0dc000003ff00150d600003e603f63003f00601e1e3f0dc000003ff000b0360000006d2000003ff000b0360000006d2000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff001810600000063007e0c006000c600fe0038060df000003ff001810600000063007e0c006000c600fe0038060df000003ff001810600000077006300006000ee00c00018060df000003ff001810600000077006300006000ee00c00018060df000003ff001a12600000c6b63631c3e6318d6c6c07c187e7cde0e1000003ff001a12600000c6b63631c3e6318d6c6c07c187e7cde0e1000003ff00191160000006b63630c606600d6c6fcc618c6c6ee0000003ff00191160000006b63630c606600d6c6fcc618c6c6ee0000003ff001911600000c6363630c3e7c18c6c6c0c618c6fece0000003ff001911600000c6363630c3e7c18c6c6c0c618c6fece0000003ff0019116000000633f630c036600c67ec0c618c6c0ce0000003ff0019116000000633f630c036600c67ec0c618c6c0ce0000003ff001911600000063037e1e3e6300c606c07c3c7e7ece0000003ff001911600000063037e1e3e6300c606c07c3c7e7ece0000003ff00120060fe000103e0fc000107c0db000003ff00980036003a0000007401a8003a0000007401a1003a0000007401a10001120060fe000103e0fc000107c0db000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff000e02600007ddff00f8f6000003ff000e02600007ddff00f8f6000003ff002002600018fe0005080f3e3fff3fe7ff09f8c6004180081f3ff9f8fe000003ff002002600018fe0005080f3e3fff3fe7ff09f8c6004180081f3ff9f8fe000003ff002002600018fe000509ffff3ffe3fe7ff09fbf600838009cffff9f8fe000003ff002002600018fe000509ffff3ffe3fe7ff09fbf600838009cffff9f8fe000003ff002002600018fe000509fe3f3c1f3fe7ff09fede03618009ce3c19c8fe000003ff002002600018fe000509fe3f3c1f3fe7ff09fede03618009ce3c19c8fe000003ff002002600018fe0005081f3f39cf3fe7ff09fcce06118009cf39f998fe000003ff002002600018fe0005081f3f39cf3fe7ff09fcce04118009cf39f998fe000003ff002002600018fe000509ff3f380f3fe7ff09f8c604218009cf3c1838fe000003ff002002600018fe000509ff3f380f3fe7ff09f8c604218009cf3c1838fe000003ff002002600018fe000509ff3f39ff3fe7ff09f8c604218009cf3fc998fe000003ff002002600018fe000509ff3f39ff3fe7ff09f8c604218009cf3fc998fe000003ff002002600018fe000509fe1e1c0e1fe7ff09f8c60293c0081e1c19c8fe000003ff002002600018fe000509fe1e1c0e1fe7ff09f8c60293c0081e1c19c8fe000003ff001b02600018fe00000fe2ff05f8c60360000ffeff00f8fe000003ff001b02600018fe00000fe2ff05f8c60360000ffeff00f8fe000003ff001702600018fe000407f001c030e600011806f6000003ff001702600018fe000407f001c030e600011806f6000003ff00170a60001803f000060000c030e600011806f6000003ff00170a60001803f000060000c030e600011806f6000003ff00190c600018061fe00603e0c3f3e6f0e800011806f6000003ff00190c600018061fe00603e0c3f3e6f0e800011806f6000003ff00180b60001806003007e630c63637e700011806f6000003ff00180b60001806003007e630c63637e700011806f6000003ff00180b600018060030060630c637f6e700011806f6000003ff00180b600018060030060630c637f6e700011806f6000003ff00180b600018060030060630c63606e700011806f6000003ff00180b600018060030060630c63606e700011806f6000003ff00180b60001807fff00603e1e3f3f6e700011806f6000003ff00180b60001807fff00603e1e3f3f6e700011806f6000003ff000f02600018de00011806f6000003ff000f02600018de00011806f6000003ff001702600018de00091aae0043e00c1ffffff8fe000003ff001702600018de00091d560043e00c1ffffff8fe000003ff001702600018de00091aae00863009cffffff8fe000003ff001702600018de00091d5600863009cffffff8fe000003ff001702600018de00091aae03603009c81c1818fe000003ff001702600018de00091d5603603009c81c1818fe000003ff001702600018de00051aae0610e009fec900c8fe000003ff001702600018de00051d560410e009fec900c8fe000003ff001702600018de00091aae04238009c9c809c8fe000003ff009800360074000000ae01a80074000000ae01a10074000000ae01a100011702600018de00091d5604238009c9c809c8fe000003ff001702600018de00091aae04260009c819f9c8fe000003ff001702600018de00091d5604260009c819f9c8fe000003ff001702600018de00091aae0297f00c19fc09c8fe000003ff001702600018de00091d560297f00c19fc09c8fe000003ff001702600018de00091aae0360000ff9fffff8fe000003ff001702600018de00091d560360000ff9fffff8fe000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff001702600018de000d1aae0047f00c1e3ffffff8000003ff001702600018de000d1d560047f00c1e3ffffff8000003ff001702600018de000d1aae00803009cf3ffffff8000003ff001702600018de000d1d5600803009cf3ffffff8000003ff001702600018de000d1aae03606009ff3c1c1c18000003ff001702600018de000d1d5603606009ff3c1c1c18000003ff001702600018de000d1aae0610e009ff39c9f9c8000003ff001702600018de000d1d560410e009ff39c9f9c8000003ff001702600018de000d1aae04203009ff39cc1808000003ff001702600018de000d1d5604203009ff39cc1808000003ff001702600018de000d1aae04263009cf39cfc9f8000003ff001702600018de000d1d5604263009cf39cfc9f8000003ff001702600018de00061aae0293e00c1efe1c0308000003ff001702600018de00061d560293e00c1efe1c0308000003ff001602600018de00051aae0360000ffdff03f8000003ff001602600018de00051d560360000ffdff03f8000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff001602600018de000618c60040e00607fdff021c0003ff001602600018de000618c60040e00607fdff021c0003ff001502600018de000518c60081e004fcff029c0003ff0098003600ae000000d001a800ae000000d001a100ae000000d001a100011502600018de000518c60081e004fcff029c0003ff001702600018de000d18c603636004fe0c0e060f9c0003ff001702600018de000d18c603636004fe0c0e060f9c0003ff001702600018de000d18c606166004ffe4e4fce79c0003ff001702600018de000d18c604166004ffe4e4fce79c0003ff001702600018de000d1cce0427f004fe04e4fc079c0003ff001702600018de000d1cce0427f004fe04e4fc079c0003ff001702600018de000d1ede04206004fce4e4fcff9c0003ff001702600018de000d1ede04206004fce4e4fcff9c0003ff001702600018de000d1bf6029060060604e606070c0003ff001702600018de000d1bf6029060060604e606070c0003ff001502600018de000518c603600007fcff02fc0003ff001502600018de000518c603600007fcff02fc0003ff000e02600007ddff00f8f6000003ff000e02600007ddff00f8f6000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff0008001fcfff00fcff0008001fcfff00fcff0002cb00a0008fa00083ff}}{\fs20 \par \par }\pard \s25\qc\fi360\sb40\widctlpar\adjustright {\fs20 Figure 6.4\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par Selecting Disk brings up a second dialog that shows a list of the disks available. Selecting one changes the list of files to a list of the files on the selected disk.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:TXT}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:SRC}}}{\fs20 When you use the open button, if the selected file in the file list is a TXT or SRC file, the file is opened. GSoft\~BASIC tokenized files saved with the SAVE command}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SAVE shell command}}}{\fs20  cannot be opened with the open command, but GSoft\~BASIC files saved with the SSAVE command}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SSAVE shell command}}}{\fs20  are SRC files, and those saved with the TSAVE command}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 TSAVE shell command}}}{\fs20  are TXT files, and both TXT and SRC files can be opened. If a directory is selected, the directory is opened, and the file list changes to show the files inside the directory. You can also open a file by first selecting a file, then clicking on it with the mouse.\par If a directory is open, the close button closes the directory, showing the list of files that contains the directory. You can also close a directory by clicking on the path name shown above the file list. If the file list was created from the root volume of a disk, the close button does nothing.\par The cancel button leaves the open dialog without opening a file.\par For information on how to use the various controls in the dialog, see }{\i\fs20 Using Editor Dialogs}{\fs20  in this chapter.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 CTRL}{\fs20 V or }{\outl\fs18 \u-3\'f0}{\fs20 V\tab }{\b\fs20 Paste\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:paste command\bxe }}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SYSTEMP file}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 work prefix}}}{\v\fs20 \par }{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:select mode\:by character}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:select mode\:by character}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The contents of the SYSTEMP file are copied to the current cursor position. If the editor is in line-oriented select mode the line the cursor is on and all subsequent lines are moved down to make room for the new material. If the editor is in character-oriented select mode the material is copied at the cursor column. If enough characters are inserted to make the line longer than 255 characters, the excess characters are lost.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 CTRL}{\fs20 Q or }{\outl\fs18 \u-3\'f0}{\fs20 Q\tab }{\b\fs20 Quit\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:quit command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The quit command leaves the editor. If any file has been changed since the last time it was saved to disk, each of the files, in turn, will be made the active file, and the following dialog will appear:\par \par }\pard \s25\qc\fi360\sb40\keepn\widctlpar\adjustright {\fs20 {\pict{\*\picprop\shplid1031{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex50\picscaley50\piccropl0\piccropr0\piccropt0\piccropb0\picw231\pich84\picwgoal4620\pichgoal1680\macpict\bliptag1830675910\blipupi72{\*\blipuid 6d1de5c6b9fc7f2c7bf96705af84eab1}052000000000005400e71101a00082a0008e01000a0000000002d0024098001e00000000005400e800000000005400e700000000005400e7000102e30007001fe6ff01f00007001fe6ff01f000070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00140360000f80fe00010f98fc00010f80f500010c00140360000f80fe00010f98fc00010f80f500010c001403600018c0fe000118d8fc000118c0f500010c001403600018c0fe000118d8fc000118c0f500010c00160f6000180f98cf80181f0f9f8000000180f500010c00160a6000180f98cf80181f0f9ffe8f018180f500010c00150e60000f80d8d8c01818c0d8cf8f8f83f400010c00140960000f80d8d8c01818c0fdd80003f400010c001409600000cfd8dfc01818cffdd80003f400010c00150e600000cfd8dfc01818cfd8d8dfcf83f400010c001407600018d8cd980018fdd802dfcf80f400010c001507600018d8cd980018fed803cfd800c0f400010c00150e60000f8fc70fc00f98cfd8cfd800c3f400010c00150e60000f8fc70fc00f98cfd8c0cfcf83f400010c000d0060f60002cfcf80f400010c000c0060f700010f80f200010c000c0060f700010f80f200010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c001f06600000e73ffff0fe000a8300139ff0000087c0181ffeff05fc7000000c001f06600000e73ffff0fe000a8300139ff0000087c0181ffeff05fc7000000c001e13600000e73ffff00000010700139ff000010c6013fdff05fe7000000c001e13600000e73ffff00000010700139ff000010c6013fdff05fe7000000c001f1d600000f2783830000006c3001198300006c06013f83038183e7000000c001f1d600000f2783830000006c3001198300006c06013f83038183e7000000c001f1d600004fcf393f000000c2300101390000c21c013ff9393f39e7000000c001f1d600004fcf393f00000082300101390000821c013ff9393f39e7000000c001f1d60000cfcf0183000000843001313900008470013f81393f01e7000000c001f1d60000cfcf0183000000843001313900008470013f81393f01e7000000c001f1d60001ffcf3ff90000008430013939000084c0013f39393f3fe7000000c001f1d60001ffcf3ff90000008430013939000084c0013f39393f3fe7000000c001f1d60000c3cf81830000005278013983000052fe018181398181c3000000c001f1d60000c3cf81830000005278013983000052fe018181398181c3000000c001d136000043ffffff0000006c0001ffff00006c0001ffcff04f000000c001d136000043ffffff0000006c0001ffff00006c0001ffcff04f000000c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c00070060e600010c0007001fe6ff01f00007001fe6ff01f00002e300a0008fa00083ff}}{\fs20 \par \par }\pard \s25\qc\fi360\sb40\widctlpar\adjustright {\fs20 Figure 6.5\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par If you select Yes, the file is saved just as if the Save command had been used. If you select No, the file is closed without saving any changes that have been made. Selecting Cancel leaves you in the editor with the active file still open, but if several files had been opened, some of them may have been closed before the Cancel operation took affect.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 CTRL}{\fs20 R or }{\outl\fs18 \u-3\'f0}{\fs20 R\tab }{\b\fs20 Remove Blanks\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:remove blanks command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 If the cursor is on a blank line, that line and all subsequent blank lines up to the next non-blank line are removed. If the cursor is not on a blank line, the command is ignored.\par \par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\fs20 1 to 32767\tab }{\b\fs20 Repeat Count\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:repeat counts\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 When in escape mode, you can enter a repeat count (any number from 1 to 32767) immediately before a command, and the command is repeated as many times as you specify (or as many times as is possible, whichever comes first). Escape mode is described in the section }{\i\fs20 Modes}{\fs20  in this chapter.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 RETURN}{\fs20 \tab }{\b\fs20 Return\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:RETURN key\bxe }}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:auto-indent mode}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The }{\outl\fs18 RETURN}{\fs20  key works in one of two ways, depending on the setting of the auto-indent mode toggle: 1) to move the cursor to column one of the next line; or 2) to place the cursor on the first non-space character in the next line, or, if the line is blank, beneath the first non-space character in the first non-blank line on the screen above the cursor. If the cursor is on the last line on the screen, the screen scrolls down one line.\par If the editor is in insert mode, the }{\outl\fs18 RETURN}{\fs20  key will also split the line at the cursor position.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 CTRL}{\fs20 A or }{\outl\fs18 \u-3\'f0}{\fs20 A\tab }{\b\fs20 Save As\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:save as command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The Save As command lets you change the name of the active file, saving it to a new file name or to the same name in a new file directory. When you use this command, this dialog will appear:\par \par }\pard \s25\qc\fi360\sb40\keepn\widctlpar\adjustright {\fs20 {\pict{\*\picprop\shplid1032{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex50\picscaley50\piccropl0\piccropr0\piccropt0\piccropb0\picw417\pich264\picwgoal8340\pichgoal5280\macpict\bliptag1383067446\blipupi72{\*\blipuid 526fef36b94839b56321b6374aeff36f}132100000000010801a11101a00082a0008e01000a0000000002d0024098003600000000003a01a800000000003a01a100000000003a01a1000102cb0008001fcfff00fcff0008001fcfff00fcff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff000b03600003e0d2000003ff000b03600003e0d2000003ff000b0360000630d2000003ff000b0360000630d2000003ff00110960000603e633e003e3e0d8000003ff00110960000603e633e003e3e0d8000003ff001008600003e03636300036d7000003ff001008600003e03636300036d7000003ff00110960000033f637f003f3e0d8000003ff00110960000033f637f003f3e0d8000003ff00110960000636336600063030d8000003ff00110960000636336600063030d8000003ff001109600003e3f1c3f003f3e0d8000003ff001109600003e3f1c3f003f3e0d8000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff001810600000063007e0c006000c600fe0038060df000003ff001810600000063007e0c006000c600fe0038060df000003ff001810600000077006300006000ee00c00018060df000003ff001810600000077006300006000ee00c00018060df000003ff001a12600000c6b63631c3e6318d6c6c07c187e7cde0e1000003ff001a12600000c6b63631c3e6318d6c6c07c187e7cde0e1000003ff00191160000006b63630c606600d6c6fcc618c6c6ee0000003ff00980036003a0000007401a8003a0000007401a1003a0000007401a10001191160000006b63630c606600d6c6fcc618c6c6ee0000003ff001911600000c6363630c3e7c18c6c6c0c618c6fece0000003ff001911600000c6363630c3e7c18c6c6c0c618c6fece0000003ff0019116000000633f630c036600c67ec0c618c6c0ce0000003ff0019116000000633f630c036600c67ec0c618c6c0ce0000003ff001911600000063037e1e3e6300c606c07c3c7e7ece0000003ff001911600000063037e1e3e6300c606c07c3c7e7ece0000003ff00120060fe000103e0fc000107c0db000003ff00120060fe000103e0fc000107c0db000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff000e02600007ddff00f8f6000003ff000e02600007ddff00f8f6000003ff002002600018fe000507f0c1c000c0e7000918c6004180081f3ff9f8fe000003ff002002600018fe000507f0c1c000c0e7000918c6004180081f3ff9f8fe000003ff002002600018fe0005060000c001c0e700091bf600838009cffff9f8fe000003ff002002600018fe0005060000c001c0e700091bf600838009cffff9f8fe000003ff002002600018fe00050601c0c3e0c0e700091ede03618009ce3c19c8fe000003ff002002600018fe00050601c0c3e0c0e700091ede03618009ce3c19c8fe000003ff002002600018fe000507e0c0c630c0e700091cce06118009cf39f998fe000003ff002002600018fe000507e0c0c630c0e700091cce04118009cf39f998fe000003ff002002600018fe00050600c0c7f0c0e7000918c604218009cf3c1838fe000003ff002002600018fe00050600c0c7f0c0e7000918c604218009cf3c1838fe000003ff002002600018fe00050600c0c600c0e7000918c604218009cf3fc998fe000003ff002002600018fe00050600c0c600c0e7000918c604218009cf3fc998fe000003ff002002600018fe00050601e1e3f1e0e7000918c60293c0081e1c19c8fe000003ff002002600018fe00050601e1e3f1e0e7000918c60293c0081e1c19c8fe000003ff001702600018de000518c60360000ffeff00f8fe000003ff001702600018de000518c60360000ffeff00f8fe000003ff001702600018fe0004080ffe3fcfe6ff01f806f6000003ff001702600018fe0004080ffe3fcfe6ff01f806f6000003ff00170a60001803f00009ffff3fcfe6ff01f806f6000003ff00170a60001803f00009ffff3fcfe6ff01f806f6000003ff00190c600018061fe009fc1f3c0c190fe8ff01f806f6000003ff00190c600018061fe009fc1f3c0c190fe8ff01f806f6000003ff00180b6000180600300819cf39c9c8e7ff01f806f6000003ff00180b6000180600300819cf39c9c8e7ff01f806f6000003ff00180b60001806003009f9cf39c809e7ff01f806f6000003ff00180b60001806003009f9cf39c809e7ff01f806f6000003ff00180b60001806003009f9cf39c9f9e7ff01f806f6000003ff00180b60001806003009f9cf39c9f9e7ff01f806f6000003ff00180b60001807fff009fc1e1c0c09e7ff01f806f6000003ff00180b60001807fff009fc1e1c0c09e7ff01f806f6000003ff001302600018fe00000fe2ff01f806f6000003ff001302600018fe00000fe2ff01f806f6000003ff001702600018de00091aae0043e00c1ffffff8fe000003ff009800360074000000ae01a80074000000ae01a10074000000ae01a100011702600018de00091d560043e00c1ffffff8fe000003ff001702600018de00091aae00863009cffffff8fe000003ff001702600018de00091d5600863009cffffff8fe000003ff001702600018de00091aae03603009c81c1818fe000003ff001702600018de00091d5603603009c81c1818fe000003ff001702600018de00051aae0610e009fec900c8fe000003ff001702600018de00051d560410e009fec900c8fe000003ff001702600018de00091aae04238009c9c809c8fe000003ff001702600018de00091d5604238009c9c809c8fe000003ff001702600018de00091aae04260009c819f9c8fe000003ff001702600018de00091d5604260009c819f9c8fe000003ff001702600018de00091aae0297f00c19fc09c8fe000003ff001702600018de00091d560297f00c19fc09c8fe000003ff001702600018de00091aae0360000ff9fffff8fe000003ff001702600018de00091d560360000ff9fffff8fe000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff001702600018de000d1aae0047f00c1e3ffffff8000003ff001702600018de000d1d560047f00c1e3ffffff8000003ff001702600018de000d1aae00803009cf3ffffff8000003ff001702600018de000d1d5600803009cf3ffffff8000003ff001702600018de000d1aae03606009ff3c1c1c18000003ff001702600018de000d1d5603606009ff3c1c1c18000003ff001702600018de000d1aae0610e009ff39c9f9c8000003ff001702600018de000d1d560410e009ff39c9f9c8000003ff001702600018de000d1aae04203009ff39cc1808000003ff001702600018de000d1d5604203009ff39cc1808000003ff001702600018de000d1aae04263009cf39cfc9f8000003ff001702600018de000d1d5604263009cf39cfc9f8000003ff001702600018de00061aae0293e00c1efe1c0308000003ff001702600018de00061d560293e00c1efe1c0308000003ff001602600018de00051aae0360000ffdff03f8000003ff001602600018de00051d560360000ffdff03f8000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff0098003600ae000000e801a800ae000000e801a100ae000000e801a100010f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff000f02600018de00011aaef6000003ff000f02600018de00011d56f6000003ff001602600018de000618c60040e00607fdff021c0003ff001602600018de000618c60040e00607fdff021c0003ff001502600018de000518c60081e004fcff029c0003ff001502600018de000518c60081e004fcff029c0003ff001702600018de000d18c603636004fe0c0e060f9c0003ff001702600018de000d18c603636004fe0c0e060f9c0003ff001702600018de000d18c606166004ffe4e4fce79c0003ff001702600018de000d18c604166004ffe4e4fce79c0003ff001702600018de000d1cce0427f004fe04e4fc079c0003ff001702600018de000d1cce0427f004fe04e4fc079c0003ff001702600018de000d1ede04206004fce4e4fcff9c0003ff001702600018de000d1ede04206004fce4e4fcff9c0003ff001702600018de000d1bf6029060060604e606070c0003ff001702600018de000d1bf6029060060604e606070c0003ff001502600018de000518c603600007fcff02fc0003ff001502600018de000518c603600007fcff02fc0003ff000e02600007ddff00f8f6000003ff000e02600007ddff00f8f6000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff001a08600007f0c1c0000630e1000647f00c1ffffff8fe000003ff001a08600007f0c1c0000630e1000647f00c1ffffff8fe000003ff001a086000060000c0000630e10006860009cffffff8fe000003ff001a086000060000c0000630e10006860009cffffff8fe000003ff001e0b60000601c0c3e00733e773e0e500070367e009fc19cc18fe000003ff001e0b60000601c0c3e00733e773e0e500070367e009fc19cc18fe000003ff001e0b600007e0c0c63007f036b630e500070610300c1fc9c9c8fe000003ff001e0b600007e0c0c63007f036b630e500070410300c1fc9c9c8fe000003ff001e0b60000600c0c7f00673f6b7f0e500070420300fcc09c808fe000003ff001e0b60000600c0c7f00673f6b7f0e500070420300fcc09c808fe000003ff001d0a60000600c0c600063636b6e4000704263009c9cc99f8fe000003ff001d0a60000600c0c600063636b6e4000704263009c9cc99f8fe000003ff001e0b60000601e1e3f00633f633f0e500070293e00c1c0e3c08fe000003ff001e0b60000601e1e3f00633f633f0e500070293e00c1c0e3c08fe000003ff00180060f7000007e6ff04fc0360000ffeff00f8fe000003ff00180060f7000007e6ff04fc0360000ffeff00f8fe000003ff000e02600018dd000003f6000003ff000e02600018dd000003f6000003ff000e02600018dd000003f6000003ff000e02600018dd000003f6000003ff000e02600018dd000003f6000003ff0098003600e80000010801a800e80000010801a100e80000010801a100010e02600018dd000003f6000003ff000e02600018dd000003f6000003ff000e02600018dd000003f6000003ff000e02600018dd000003f6000003ff000e02600018dd000003f6000003ff000e02600018dd000003f6000003ff000e02600018dd000003f6000003ff000e02600018dd000003f6000003ff000e02600018dd000003f6000003ff000e02600018dd000003f6000003ff000e02600018dd000003f6000003ff000e02600007ddff00fcf6000003ff000e02600007ddff00fcf6000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff00080060cf000003ff0008001fcfff00fcff0008001fcfff00fcff0002cb00a0008fa00083ff}}{\fs20 \par \par }\pard \s25\qc\fi360\sb40\widctlpar\adjustright {\fs20 Figure 6.6\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par Selecting Disk brings up a second dialog that shows a list of the disks available. Selecting one changes the list of files to a list of the files on the selected disk.\par When you use the Open button, the selected directory is opened. While using this command, you cannot select any files from the list; only directories can be selected.\par If a directory is open, the close button closes the directory, showing the list of files that contains the directory. You can also close a directory by clicking on the path name shown above the file list. If the file list was created from the root volume of a disk, the close button does nothing.\par The cancel button leaves the open dialog without opening a file.\par The Save button saves the file, using the file name shown in the edit line item labeled \ldblquote File Name.\rdblquote  You can also save the file by pressing the }{\outl\fs18 RETURN}{\fs20  key.\par For information on how to use the various controls in the dialog, see }{\i\fs20 Using Editor Dialogs}{\fs20  in this chapter.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 CTRL}{\fs20 S or }{\outl\fs18 \u-3\'f0}{\fs20 S\tab }{\b\fs20 Save\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:save command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The active file (the one you can see) is saved to disk.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 \u-3\'f0}{\fs20 -1 to }{\outl\fs18 \u-3\'f0}{\fs20 -9\tab }{\b\fs20 Screen Moves\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:moving through a file\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The file is divided by the editor into 8 approximately equal sections. The screen-move commands move the file to a boundary between one of these sections. The command }{\outl\fs18 \u-3\'f0}{\fs20 1 jumps to the first character in the file, and }{\outl\fs18 \u-3\'f0}{\fs20 9 jumps to the last character in the file. The other seven }{\outl\fs18 \u-3\'f0}{\fs20 n commands cause screen jumps to evenly spaced intermediate points in the file.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 \u-3\'f0}{\fs20 \}\tab }{\b\fs20 Scroll Down One Line\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:scroll down one line command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The editor moves down one line in the file, causing all of the lines on the screen to move up one line. The cursor remains in the same position on the screen. Scrolling can continue past the last line in the file.\par \par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 \u-3\'f0}{\fs20 ]\tab }{\b\fs20 Scroll Down One Page\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:scroll down one page command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The screen scrolls down twenty-two lines. Scrolling can continue past the last line in the file.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 \u-3\'f0}{\fs20 \{\tab }{\b\fs20 Scroll Up One Line\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:scroll up one line\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The editor moves up one line in the file, causing all of the lines on the screen to move down one line. The cursor remains in the same position on the screen. If the first line of the file is already displayed on the screen, the command is ignored.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 \u-3\'f0}{\fs20 [\tab }{\b\fs20 Scroll Up One Page\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:scroll up one page command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The screen scrolls up twenty-two lines. If the top line on the screen is less than one screen\rquote s height from the beginning of the file, the screen scrolls to the beginning of the file.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 \u-3\'f0}{\fs20 L\tab }{\b\fs20 Search Down\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:search down command\bxe }}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 case sensitivity}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 tabs}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 This command allows you to search through a file for a character or string of characters. When you execute this command, this dialog appears:\par \par }\pard \s25\qc\fi360\sb40\keepn\widctlpar\adjustright {\fs20 {\pict{\*\picprop\shplid1033{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex50\picscaley48\piccropl0\piccropr0\piccropt0\piccropb0\picw522\pich174\picwgoal10440\pichgoal3480\macpict\bliptag-998183356\blipupi72{\*\blipuid c480ee441428365ad0fea5b85187189b}0bd80000000000ae020a1101a00082a0008e01000a0000000002d0024098004200000000002f021000000000002f020a00000000002f020a000102bf0007001fc2ff01fe0007001fc2ff01fe00070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c2000101801403600003e0fe0006060000030000c0cf000101801403600003e0fe0006060000030000c0cf00010180110360000630fe000306000003cc00010180110360000630fe000306000003cc00010180171060000603e3e6f3f7c003e7e6f1c7e3e0c0d200010180171060000603e3e6f3f7c003e7e6f1c7e3e0c0d200010180160f600003e6303706063006030700c63630d100010180160f600003e6303706063006030700c63630d100010180171060000037f3f606063003e30600c63630c0d200010180171060000037f3f606063003e30600c63630c0d200010180160f60000636063606063000333600c633f0d100010180160f60000636063606063000333600c633f0d100010180160f600003e3f3f603f63003e1e601e63030d100010180160f600003e3f3f603f63003e1e601e63030d1000101800f0060f4000203e007d4ff03f80001800f0060f4000203e007d4ff03f80001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600007c6ff03f80001800b02600007c6ff03f8000180070060c200010180070060c200010180980042002f0000005e0210002f0000005e020a002f0000005e020a0001070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c2000101800a016007c5f703f00001800a016007c5f703f0000180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180150060fd00054180063600c3ec000101c0e300010180150060fd00054180063600c3ec000101c0e300010180140060fd0005838006360003eb0000c0e300010180140060fd0005838006360003eb0000c0e300010180280060fe001d0361800637c1c7e3e003e7e3e3f3e003f3e777e3e6f3e3e003e3f633e0c0e300010180280060fe001d0361800637c1c7e3e003e7e3e3f3e003f3e777e3e6f3e3e003e3f633e0c0e300010180280060fe001d06118006b630c30630060630360630060636b630370636000636363030c0e300010180280060fe001d04118006b630c30630060630360630060636b630370636000636363030c0e300010180280060fe001d04218006b630c307f003e633f607f0060636b633f607f3e007f63633f0c0e300010180280060fe001d04218006b630c307f003e633f607f0060636b633f607f3e007f63633f0c0e300010180280060fe001d042180077630c336000037e6360600060636b7e6360600300603f67630c0e300010180280060fe001d042180077630c336000037e6360600060636b7e6360600300603f67630c0e300010180280060fe001d0293c0063631e1e3f003e603f3f3f003f3e63603f603f3e003f033b3f1e0e300010180280060fe001d0293c0063631e1e3f003e603f3f3f003f3e63603f603f3e003f033b3f1e0e300010180180060fe00010360f9000006fa000006fa000030e000010180180060fe00010360f9000006fa000006fa000030e000010180140060fd000343e003e0f90002c300c0d500010180140060fd000343e003e0f90002c300c0d500010180120060fd000386300630f9000003d300010180980042005e0000008d0210005e0000008d020a005e0000008d020a0001120060fd000386300630f9000003d3000101801c0060fe00110360300603e3e3e003e3e7e3e1c7e1c633e0d7000101801c0060fe00110360300603e3e3e003e3e7e3e1c7e1c633e0d7000101801c0060fe00110610e006003606300606363600c300c63630d7000101801c0060fe00110410e006003606300606363600c300c63630d7000101801c0060fe00110423800603f3e7f003e7f633e0c300c637f0d7000101801c0060fe00110423800603f3e7f003e7f633e0c300c637f0d7000101801b0060fe001004260006363036000036063030c330c366d6000101801b0060fe001004260006363036000036063030c330c366d6000101801b0060fe000b0297f003e3f3e3f003e3f633fde101c3f0d7000101801b0060fe000b0297f003e3f3e3f003e3f633fde101c3f0d7000101800c0060fe00010360c7000101800c0060fe00010360c700010180150060fd000647f006360001c0fc000030d300010180150060fd000647f006360001c0fc000030d300010180150060fd0006803006360000c0fc000030d300010180150060fd0006803006360000c0fc000030d300010180180060fe000d0360600637c3e0c3e00633e6f3f0d300010180180060fe000d0360600637c3e0c3e00633e6f3f0d300010180180060fe000d0610e006b63630c6300636370630d300010180180060fe000d0410e006b63630c6300636370630d300010180180060fe000d04203006b63630c7f006b6360630d300010180180060fe000d04203006b63630c7f006b6360630d300010180180060fe000d04263007763630c60006b6360630d300010180180060fe000d04263007763630c60006b6360630d300010180180060fe000d0293e0063633e1e3f00773e603f0d300010180180060fe000d0293e0063633e1e3f00773e603f0d3000101800c0060fe00010360c7000101800c0060fe00010360c700010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c2000101800a016007c5f703f00001800a016007c5f703f0000180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c20001018019066000080f3fffc8fe000343e00c0ffeff01fe38d40001018019066000080f3fffc8fe000343e00c0ffeff01fe38d400010180980042008d000000ae0210008d000000ae020a008d000000ae020a00011702600009feff00c8fe0002863009fcff0038d4000101801702600009feff00c8fe0002863009fcff0038d4000101801912600009fe381c08000003667009fc181c0c1f38d4000101801912600009fe381c08000003667009fc181c0c1f38d40001018019126000083f39c9c800000616b009ffc9c9f9cf38d40001018019126000083f39c9c800000416b009ffc9c9f9cf38d4000101801912600009ff39c9c8000004273009fc09c9f80f38d4000101801912600009ff39c9c8000004273009fc09c9f80f38d4000101801912600009ff39c9c8000004263009f9c9c9f9ff38d4000101801912600009ff39c9c8000004263009f9c9c9f9ff38d4000101801912600009fe19cc0800000293e00c0c09cc0c0e18d4000101801912600009fe19cc0800000293e00c0c09cc0c0e18d400010180170260000ffeff06f800000360000ffcff00f8d400010180170260000ffeff06f800000360000ffcff00f8d400010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c20001018007001fc2ff01fe0007001fc2ff01fe0002bf00a0008fa00083ff}}{\fs20 \par \par }\pard \s25\qc\fi360\sb40\widctlpar\adjustright {\fs20 Figure 6.7\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par If you have previously entered a search string, the previous string appears after the prompt as a default. Type in the string for which you wish to search, and press }{\outl\fs18 RETURN}{\fs20 . The cursor will be moved to the first character of the first occurrence of the search string after the old cursor position. If there are no occurrences of the search string between the old cursor position and the end of the file, an alert will show up stating that the string was not found; pressing any key will get rid of the alert.\par By default, string searches are case insensitive, must be an exact match in terms of blanks and tabs, and will match any target string in the file, even if it is a subset of a larger word. All of these defaults can be changed, so we will look at what they mean in terms of how changing the defaults affects the way string searches work.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 tabs}}}{\v\fs20 \par }{\fs20 When you look at a line like\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 100    PRINT "Hello, world."\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 without using the hidden characters mode, it is impossible to tell if the spaces between the various fields are caused by a series of space characters, two tabs, or perhaps even a space character or two followed by a tab. This is an important distinction, since searching for 100<space><space><space><space>PRINT won\rquote t find the line if the 100 and PRINT are actually separated by a tab character, and searching for 100<tab>PRINT won\rquote t find the line if the fields are separated by three spaces. }{\pard\plain \s25\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 white space}}}{\fs20 If you select the \ldblquote white space compares equal\rdblquote  option, though, the editor will find any string where 100 and PRINT are separated by any combination of spaces and tabs, whether you use spaces, tabs, or some combination in the search string you type.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 By default, if you search for print, the editor will also find PRINT, since string searches are case insensitive. Selecting the \ldblquote case sensitive\rdblquote  option makes the string search case sensitive, so that the capitalization becomes significant. With this option turned on, searching for PRINT would not find print.\par Sometimes when you search for a string, you want to find any occurrence of the string, even if it is imbedded in some larger word. For example, if you are scanning your program for places where it handles spaces, you might enter a string like \ldblquote space\rdblquote . You would want the editor to find the word whitespace, though, and normally it would. If you are trying to scan through a source file looking for all of the places where you used the variable i, though, you don\rquote t want the editor to stop four times on the word Mississippi. In that case, you can select the \ldblquote whole word\rdblquote  option, and the editor will only stop if it finds the letter i, and there is no other letter, number, or underscore character on either side of the letter. These rules match the way languages deal with identifiers, so you can use this option to search for specific variable names \endash  even a short, common one like i.\par This command searches from the cursor position towards the end of the file. For a similar command that searches back towards the start of the file, see the Search Up command.\par For a complete description of how to use the mouse or keyboard to set options and move through the dialog, see the section }{\i\fs20 Using Editor Dialogs }{\fs20 in this chapter.\par Once a search string has been entered, you may want to search for another occurrence of the same string. ORCA ships with two built-in editor macros that can do this with a single keystroke, without bringing up the dialog. To search forward, use the option-L macro; to search back, use the option-K macro.\par \par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 \u-3\'f0}{\fs20 K\tab }{\b\fs20 Search Up\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:search up command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 This command operates exactly like Search Down, except that the editor looks for the search string starting at the cursor and proceeding toward the beginning of the file. The search stops at the beginning of the file; to search between the current cursor location and the end of the file, use the Search Down command.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 \u-3\'f0}{\fs20 J\tab }{\b\fs20 Search and Replace Down\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:search and replace down command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 This command allows you to search through a file for a character or string of characters, and to replace the search string with a replacement string. When you execute this command, the following dialog will appear on the screen:\par \par }\pard \s25\qc\fi360\sb40\keepn\widctlpar\adjustright {\fs20 {\pict{\*\picprop\shplid1034{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex49\picscaley50\piccropl0\piccropr0\piccropt0\piccropb0\picw522\pich238\picwgoal10440\pichgoal4760\macpict\bliptag-1431515892\blipupi72{\*\blipuid aaaccd0cdf546a15cdf9958021211444}10760000000000ee020a1101a00082a0008e01000a0000000002d0024098004200000000002f021000000000002f020a00000000002f020a000102bf0007001fc2ff01fe0007001fc2ff01fe00070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c2000101801403600003e0fe0006060000030000c0cf000101801403600003e0fe0006060000030000c0cf00010180110360000630fe000306000003cc00010180110360000630fe000306000003cc00010180171060000603e3e6f3f7c003e7e6f1c7e3e0c0d200010180171060000603e3e6f3f7c003e7e6f1c7e3e0c0d200010180160f600003e6303706063006030700c63630d100010180160f600003e6303706063006030700c63630d100010180171060000037f3f606063003e30600c63630c0d200010180171060000037f3f606063003e30600c63630c0d200010180160f60000636063606063000333600c633f0d100010180160f60000636063606063000333600c633f0d100010180160f600003e3f3f603f63003e1e601e63030d100010180160f600003e3f3f603f63003e1e601e63030d1000101800f0060f4000203e007d4ff03f80001800f0060f4000203e007d4ff03f80001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600007c6ff03f80001800b02600007c6ff03f8000180070060c200010180070060c200010180980042002f0000005e0210002f0000005e020a002f0000005e020a0001070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c2000101801406600007e00001c0fd0003030000c0d0000101801406600007e00001c0fd0003030000c0d0000101801106600006300000c0fd000003cd000101801106600006300000c0fd000003cd00010180181160000633e7e0c3e3f3e003e7e6f1c7e3e0c0d300010180181160000633e7e0c3e3f3e003e7e6f1c7e3e0c0d3000101801710600007e63630c036063006030700c63630d2000101801710600007e63630c036063006030700c63630d2000101801811600006c7f630c3f607f003e30600c63630c0d3000101801811600006c7f630c3f607f003e30600c63630c0d30001018017106000066607e0c636060000333600c633f0d20001018017106000066607e0c636060000333600c633f0d200010180171060000633f601e3f3f3f003e1e601e63030d200010180171060000633f601e3f3f3f003e1e601e63030d200010180130060fe000006f7000203e007d5ff03f8000180130060fe000006f7000203e007d5ff03f80001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600018c60003060001800b02600007c6ff03f80001800b02600007c6ff03f8000180070060c200010180980042005e0000008d0210005e0000008d020a005e0000008d020a0001070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c2000101800a016007c5f703f00001800a016007c5f703f0000180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180150060fd00054180063600c3ec000101c0e300010180150060fd00054180063600c3ec000101c0e300010180140060fd0005838006360003eb0000c0e300010180140060fd0005838006360003eb0000c0e300010180280060fe001d0361800637c1c7e3e003e7e3e3f3e003f3e777e3e6f3e3e003e3f633e0c0e300010180280060fe001d0361800637c1c7e3e003e7e3e3f3e003f3e777e3e6f3e3e003e3f633e0c0e300010180280060fe001d06118006b630c30630060630360630060636b630370636000636363030c0e300010180280060fe001d04118006b630c30630060630360630060636b630370636000636363030c0e300010180280060fe001d04218006b630c307f003e633f607f0060636b633f607f3e007f63633f0c0e300010180280060fe001d04218006b630c307f003e633f607f0060636b633f607f3e007f63633f0c0e300010180280060fe001d042180077630c336000037e6360600060636b7e6360600300603f67630c0e300010180280060fe001d042180077630c336000037e6360600060636b7e6360600300603f67630c0e300010180280060fe001d0293c0063631e1e3f003e603f3f3f003f3e63603f603f3e003f033b3f1e0e300010180280060fe001d0293c0063631e1e3f003e603f3f3f003f3e63603f603f3e003f033b3f1e0e300010180180060fe00010360f9000006fa000006fa000030e000010180180060fe00010360f9000006fa000006fa000030e000010180140060fd000343e003e0f90002c300c0d500010180140060fd000343e003e0f90002c300c0d500010180980042008d000000bc0210008d000000bc020a008d000000bc020a0001120060fd000386300630f9000003d300010180120060fd000386300630f9000003d3000101801c0060fe00110360300603e3e3e003e3e7e3e1c7e1c633e0d7000101801c0060fe00110360300603e3e3e003e3e7e3e1c7e1c633e0d7000101801c0060fe00110610e006003606300606363600c300c63630d7000101801c0060fe00110410e006003606300606363600c300c63630d7000101801c0060fe00110423800603f3e7f003e7f633e0c300c637f0d7000101801c0060fe00110423800603f3e7f003e7f633e0c300c637f0d7000101801b0060fe001004260006363036000036063030c330c366d6000101801b0060fe001004260006363036000036063030c330c366d6000101801b0060fe000b0297f003e3f3e3f003e3f633fde101c3f0d7000101801b0060fe000b0297f003e3f3e3f003e3f633fde101c3f0d7000101800c0060fe00010360c7000101800c0060fe00010360c700010180150060fd000647f006360001c0fc000030d300010180150060fd000647f006360001c0fc000030d300010180150060fd0006803006360000c0fc000030d300010180150060fd0006803006360000c0fc000030d300010180180060fe000d0360600637c3e0c3e00633e6f3f0d300010180180060fe000d0360600637c3e0c3e00633e6f3f0d300010180180060fe000d0610e006b63630c6300636370630d300010180180060fe000d0410e006b63630c6300636370630d300010180180060fe000d04203006b63630c7f006b6360630d300010180180060fe000d04203006b63630c7f006b6360630d300010180180060fe000d04263007763630c60006b6360630d300010180180060fe000d04263007763630c60006b6360630d300010180180060fe000d0293e0063633e1e3f00773e603f0d300010180180060fe000d0293e0063633e1e3f00773e603f0d3000101800c0060fe00010360c7000101800c0060fe00010360c700010180170060fd000640e007e00001c0fd000201c1c0d400010180170060fd000640e007e00001c0fd000201c1c0d400010180160060fd000681e006300000c0fc0001c0c0d400010180160060fd000681e006300000c0fc0001c0c0d400010180190060fe000e0363600633e7e0c3e3f3e003e0c0c0d400010180190060fe000e0363600633e7e0c3e3f3e003e0c0c0d400010180190060fe000e06166007e63630c03606300030c0c0d400010180190060fe000e04166007e63630c03606300030c0c0d400010180190060fe000e0427f006c7f630c3f607f003f0c0c0d400010180190060fe000e0427f006c7f630c3f607f003f0c0c0d400010180190060fe000e042060066607e0c63606000630c0c0d400010180190060fe000e042060066607e0c63606000630c0c0d400010180190060fe000e0290600633f601e3f3f3f003f1e1e0d400010180190060fe000e0290600633f601e3f3f3f003f1e1e0d400010180100060fe00010360fe000006cb00010180100060fe00010360fe000006cb00010180070060c20001018098004200bc000000eb021000bc000000eb020a00bc000000eb020a0001070060c200010180070060c200010180070060c200010180070060c200010180070060c2000101800a016007c5f703f00001800a016007c5f703f0000180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c2000101801c096000081ffffe3ffffff8fe000343e00c0ffeff01fe38d7000101801c096000081ffffe3ffffff8fe000343e00c0ffeff01fe38d7000101801a09600009cfffff3ffffff8fe0002863009fcff0038d7000101801a09600009cfffff3ffffff8fe0002863009fcff0038d7000101801c15600009cc181f3c1c0c18000003667009fc181c0c1f38d7000101801c15600009cc181f3c1c0c18000003667009fc181c0c1f38d7000101801c1560000819c9cf3fc9f9c800000616b009ffc9c9f9cf38d7000101801c1560000819c9cf3fc9f9c800000416b009ffc9c9f9cf38d7000101801c156000093809cf3c09f808000004273009fc09c9f80f38d7000101801c156000093809cf3c09f808000004273009fc09c9f80f38d7000101801c1560000999f81f39c9f9f8000004263009f9c9c9f9ff38d7000101801c1560000999f81f39c9f9f8000004263009f9c9c9f9ff38d7000101801c15600009cc09fe1c0c0c0800000293e00c0c09cc0c0e18d7000101801c15600009cc09fe1c0c0c0800000293e00c0c09cc0c0e18d700010180190460000ffff9fdff06f800000360000ffcff00f8d700010180190460000ffff9fdff06f800000360000ffcff00f8d700010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c200010180070060c20001018098004200eb000000ee021000eb000000ee020a00eb000000ee020a000107001fc2ff01fe0007001fc2ff01fe0002bf00a0008fa00083ff}}{\fs20 \par \par }\pard \s25\qc\fi360\sb40\widctlpar\adjustright {\fs20 Figure 6.8\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par The search string, the first three options, and the buttons work just as they do for string searches; for a description of these, see the Search Down command. The replace string is the target string that will replace the search string each time it is found. By default, when you use this command, each time the search string is found in the file you will see this dialog:\par \par }\pard \s25\qc\fi360\sb40\keepn\widctlpar\adjustright {\fs20 {\pict{\*\picprop\shplid1035{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex50\picscaley48\piccropl0\piccropr0\piccropt0\piccropb0\picw294\pich84\picwgoal5880\pichgoal1680\macpict\bliptag-1051516100\blipupi72{\*\blipuid c153233cf432f61985fd11443439c450}063900000000005401261101a00082a0008e01000a0000000002d00240980026000000000053012800000000005301260000000000530126000102db0007001fdeff01e00007001fdeff01e000070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de000118001b0560001f800007fc0005030c18000d8cfd00020c1b1ff5000118001b0560001f800007fc0005030c18000d8cfd00020c1b1ff5000118001b05600018c00003fb00040c18000d8cfd00030c1b3180f6000118001b05600018c00003fb00040c18000d8cfd00030c1b3180f6000118001e17600018cf9f830f8fcf8018c71f9f000d9f8f9bcf8f9f9b03f5000118001e17600018cf9f830f8fcf8018c71f9f000d9f8f9bcf8f9f9b03f5000118001e1760001f98d8c300d818c018c30c18c0000c00dc18d8cc0006f5000118001e1760001f98d8c300d818c018c30c18c0000c00dc18d8cc0006f5000118001e1760001b1fd8c30fd81fc01ac30c18c0000c0fd818dfcc0006f5000118001e1760001b1fd8c30fd81fc01ac30c18c0000c0fd818dfcc0006f5000118001d16600019981f8318d818001ac30cd8c0000cd8d80fd80cc0f4000118001d16600019981f8318d818001ac30cd8c0000cd8d80fd80cc0f4000118001e17600018cfd8078fcfcfc01dc78798c000078fd800cfc78006f5000118001e17600018cfd8078fcfcfc01dc78798c000078fd800cfc78006f500011800100060fe000018f300010f80f200011800100060fe000018f300010f80f200011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de000118000e036000003ffbff00e0e8000118002706600000e07ffff8feff00e0fe000e0106003067fcffc00000010f80303ffeff05f8e0000018002706600000e07ffff8feff00e0fe000e0106003067fcffc00000010f80303ffeff05f8e0000018002606600000e73ffffcfeff00e0fe000d020e002727ffffc000000218c027fdff05fce0000018002606600000e73ffffcfeff00e0fe000d020e002727ffffc000000218c027fdff05fce000001800270a600000e730607cf0703060fe00170d860027e738c0c000000d80c027f06070307ce000001800270a600000e730607cf0703060fe00170d860027e738c0c000000d80c027f06070307ce000001800270a600004e067273cff27e720fe001718460030667cce40000018438027ff2727e73ce000001800270a600004e067273cff27e720fe001710460030667cce40000010438027ff2727e73ce000001800270a60000ce4e0273cf027e020fe00171086003f20fcce400000108e0027f02727e03ce000001800270a60000ce4e0273cf027e020fe00171086003f20fcce400000108e0027f02727e03ce000001800270a60001fe667e07ce727e7e0fe001710860027267cc0c0000010980027e72727e7fce000001800270a60001fe667e07ce727e7e0fe001710860027267cc0c0000010980027e72727e7fce000001800270a60000c273027f870303020fe00170a4f003067384fc000000a5fc03030273030386000001800270a60000c273027f870303020fe00170a4f003067384fc000000a5fc0303027303038600000180024056000043fffe7fdff00e0fe000d0d80003fffffcfc000000d80003ffcff04e00000180024056000043fffe7fdff00e0fe000d0d80003fffffcfc000000d80003ffcff04e000001800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de00011800070060de0001180007001fdeff01e00007001fdeff01e000980026005300000054012800530000005401260053000000540126000102db00a0008fa00083ff}}{\fs20 \par \par }\pard \s25\qc\fi360\sb40\widctlpar\adjustright {\fs20 Figure 6.9\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par If you select the Replace option, the search string is replaced by the replace string, and the editor scans forward for the next occurrence of the search string. Choosing Skip causes the editor to skip ahead to the next occurrence of the search string without replacing the occurrence that is displayed. Cancel stops the search and replace process.\par If you use the \ldblquote replace all\rdblquote  option, the editor starts at the top of the file and replaces each and every occurrence of the search string with the target string. On large files, this can take quite a bit of time. To stop the process, press }{\outl\fs18 \u-3\'f0}{\fs20 . (open-apple period). While the search and replace is going on, you can see a spinner at the bottom right corner of the screen, showing you that the editor is still alive and well.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 \u-3\'f0}{\fs20 H\tab }{\b\fs20 Search and Replace Up\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:search and replace up command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 This command operates exactly like Search and Replace Down, except that the editor looks for the search string starting at the cursor and proceeding toward the beginning of the file. The search stops at the beginning of the file; to search between the current cursor location and the end of the file, use the Search and Replace Down command. If you use the \ldblquote replace all\rdblquote  option, this command works exactly the same way the Search and Replace Down command does when it uses the same option.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\fs20 option--\tab }{\b\fs20 Select File\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:select file command\bxe }}}{\v\fs20 .}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:multiple files.}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The editor can edit up to ten files at one time. When you use this command, a dialog appears showing the names of the ten files in memory. You can then move to one of the files by pressing option-n, where n is one of the file numbers. You can exit the dialog without switching files by pressing }{\outl\fs18 ESC}{\fs20  or }{\outl\fs18 RETURN}{\fs20 .\par See also the Switch Files command.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\fs20 option-}{\outl\fs18 TAB}{\fs20 \tab }{\b\fs20 Set and Clear Tabs\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:set/clear tab stops command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 If there is a tab stop in the same column as the cursor, it is cleared; if there is no tab stop in the cursor column, one is set.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\fs20 option-[\tab }{\b\fs20 Shift Left\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:shift left command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 If this command is issued when no text is selected, you enter the text selection mode. Pressing }{\outl\fs18 RETURN}{\fs20  leaves text selection mode.\par At any time while text is selected, using the command shifts all of the selected text left one character. This is done by scanning the text, one line at a time, and removing a space right before the first character on each line that is not a space or tab. If the character to be removed is a tab character, it is first replaced by an equivalent number of spaces. If there are no spaces or tabs at the start of the line, the line is skipped.\par If a large amount of text is selected, this command may take a lot of time. While the editor is working, you will see a spinner at the bottom right of the screen; this lets you know the editor is still processing text. You can stop the operation by pressing }{\outl\fs18 \u-3\'f0}{\fs20 ., but this will leave the selected text partially shifted.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\fs20 option-]\tab }{\b\fs20 Shift Right\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:shift right command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 If this command is issued when no text is selected, you enter the text selection mode. Pressing }{\outl\fs18 RETURN}{\fs20  leaves text selection mode.\par At any time while text is selected, using the command shifts all of the selected text right one character. This is done by scanning the text, one line at a time, and adding a space right before the first character on each line that is not a space or tab. If this leaves the non-space character on a tab stop, the spaces are collected and replaced with a tab character. If a blank line is encountered, no action is taken.\par If a large amount of text is selected, this command may take a lot of time. While the editor is working, you will see a spinner at the bottom right of the screen; this lets you know the editor is still processing text. You can stop the operation by pressing }{\outl\fs18 \u-3\'f0}{\fs20 ., but this will leave the selected text partially shifted.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\fs20 option-n\tab }{\b\fs20 Switch Files\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:switch files command\bxe }}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:multiple files}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The editor can edit up to ten files at one time. Each of these files is numbered, starting from 0 and proceeding to 9. The numbers are assigned as the files are opened from the command line. To move from one file to the next, press option-n, where n is a numeric key.\par When you switch files, the original file is not changed in any way. When you return to the file, the cursor and display will be in the same place, the undo buffer will still be active, and so forth. The only actions that are not particular to a specific file buffer are those involving the clipboard \endash  Cut, Copy and Paste all use the same clipboard, so you can move chunks of text from one file to another.\par See also the Select File command.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 TAB}{\fs20 \tab }{\b\fs20 Tab\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:tab command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 In insert mode, or when in over strike mode and the next tab stop is past the last character in the line, this command inserts a tab character in the source file and moves to the end of the tab field. If you are in the over strike mode and the next tab stop is not past the last character on the line, the Tab command works like a cursor movement command, moving the cursor forward to the next tab stop.\par Some languages and utilities do not work well (or at all) with tab stops. If you are using one of these languages, you can tell the editor to insert spaces instead of tab characters; see the section }{\i\fs20 Setting Editor Defaults}{\fs20 , later in this chapter, to find out how this is done.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 \u-3\'f0TAB}{\fs20 \tab }{\b\fs20 Tab Left\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:tab left command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The cursor is moved to the previous tab stop, or to the beginning of the line if there are no more tab stops to the left of the cursor. This command does not enter any characters in the file.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 \u-3\'f0RETURN}{\fs20 \tab }{\b\fs20 Toggle Auto Indent Mode\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:set/clear auto-indent mode command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 If the editor is set to put the cursor on column one when you press }{\outl\fs18 RETURN}{\fs20 , it is changed to put the cursor on the first non-space character; if set to the first non-space character, it is changed to put the cursor on column one. Auto-indent mode is described in the section }{\i\fs20 Modes}{\fs20  in this chapter.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 ESC}{\fs20 \tab }{\b\fs20 Toggle Escape Mode\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:set/clear escape mode command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 If the editor is in the edit mode, it is put in escape mode; if it is in escape mode, it is put in edit mode. When you are in escape mode, pressing any character not specifically assigned to an escape-mode command returns you to edit mode. Escape and edit modes are described in the section }{\i\fs20 Modes}{\fs20  in this chapter.\par When in escape mode, }{\outl\fs18 \u-3\'f0CTRL}{\fs20 _ will return you to edit mode. In edit mode the command has no effect. From edit mode, }{\outl\fs18 CTRL}{\fs20 _ will place you in escape mode, but the command has no effect in escape mode. These commands are most useful in an editor macro, where you do not know what mode you are in on entry.\par \par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 CTRL}{\fs20 E or }{\outl\fs18 \u-3\'f0}{\fs20 E\tab }{\b\fs20 Toggle Insert Mode\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:set/clear insert mode command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 If insert mode is active, the editor is changed to over strike mode. If over strike mode is active, the editor is changed to insert mode. Insert and over strike modes are described in the section }{\i\fs20 Modes}{\fs20  in this chapter.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 CTRL\u-3\'f0}{\fs20 X\tab }{\b\fs20 Toggle Select Mode\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:set/clear select mode command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 If the editor is set to select text for the Cut, Copy, and Delete commands in units of one line, it is changed to use individual characters instead; if it is set to character-oriented selects, it is toggled to use whole lines. See the section }{\i\fs20 Modes}{\fs20  in this chapter for more information on select mode.\par \par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 \u-3\'f0UP-ARROW}{\fs20 \tab }{\b\fs20 Top of Screen / Page Up\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:top of screen command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The cursor moves to the first visible line on the screen, preserving the cursor\rquote s horizontal position. If the cursor is already at the top of the screen, the screen scrolls up twenty-two lines. If the cursor is at the top of the screen and less than twenty-two lines from the beginning of the file, then the screen scrolls to the beginning of the file.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 CTRL}{\fs20 Z or }{\outl\fs18 \u-3\'f0}{\fs20 Z\tab }{\b\fs20 Undo Delete\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:undo delete command\bxe }}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:undo delete buffer}}}{\v\fs20 \par }{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:delete character command}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:delete character left command}}}{\v\fs20 \par }{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:delete line command}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:delete to end of line command}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:delete word command}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The last operation that changed the text in the current edit file is reversed, leaving the edit file in the previous state. Saving the file empties the undo buffer, so you cannot undo changes made before the last time the file was saved.\par The undo operation acts like a stack, so once the last operation is undone, you can undo the one before that, and so on, right back to the point where the file was loaded or the point where the file was saved the last time.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 \u-3\'f0LEFT-ARROW}{\fs20 \tab }{\b\fs20 Word Left\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:word left command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The cursor is moved to the beginning of the next non-blank sequence of characters to the left of its current position. If there are no more words on the line, the cursor is moved to the last word in the previous line or, if it is blank, to the last word in the first non-blank line preceding the cursor.\par }\pard\plain \s36\sb160\sa40\keepn\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\outl\fs18 \u-3\'f0RIGHT-ARROW}{\fs20 \tab }{\b\fs20 Word Right\par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:word right command\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The cursor is moved to the start of the next non-blank sequence of characters to the right of its current position. If there are no more words on the line, the cursor is moved to the first word in the next non-blank line.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Setting Editor Defaults}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Setting Editor Defaults\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:setting defaults\bxe }}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SysTabs file}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:customizing\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 When you start the ORCA editor, it reads the file named SysTabs (located in the shell prefix}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 shell prefix}}}{\fs20 ), which contains the default settings for tab stops, return mode, insert mode, tab mode, and select mode. The SysTabs file is an ASCII text file that you can edit with the ORCA editor.\par Each language recognized by ORCA is assigned a language number. The SysTabs file has three lines associated with each language:\par \par }\pard \s25\fi360\sb40\keepn\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 language numbers}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:modes}}}{\v\fs20 \par }{\fs20 1.\tab The language number.\par 2.\tab The default settings for the various modes.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 3.\tab The default tab and end-of-line-mark settings.\par \par The first line of each set of lines in the SysTabs file specifies the language that the next two lines apply to. ORCA languages can have numbers from 0 to 32767 (decimal). The language number must start in the first column; leading zeros are permitted and are not significant, but leading spaces are not allowed.\par The second line of each set of lines in the SysTabs file sets the defaults for various editor modes, as follows:\par \par }\pard \s25\fi360\sb40\keepn\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:auto-indent mode}}}{\v\fs20 \par }\pard \s25\fi-360\li720\sb40\widctlpar\adjustright {\fs20 1.\tab If the first column contains a zero, pressing }{\outl\fs18 RETURN}{\fs20  in the editor causes the cursor to go to column one in the next line; if it\rquote s a one, pressing }{\outl\fs18 RETURN}{\fs20  sends the cursor to the first non-space character in the next line (or, if the line is blank, beneath the first non-space character in the first non-blank line on the screen above the cursor).\par }\pard \s25\fi-360\li720\sb40\keepn\widctlpar\adjustright {\pard\plain \s25\fi-360\li720\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:select mode}}}{\v\fs20 \par }\pard \s25\fi-360\li720\sb40\widctlpar\adjustright {\fs20 2.\tab If the second character is zero, the editor is set to line-oriented selects; if one, it is set to character-oriented selects.\par 3.\tab This flag is not used by the current version of the ORCA editor. It should be set to 0.\par 4.\tab The fourth character is used by the ORCA/Desktop editor, and is used to set the default cursor mode. A zero will cause the editor to start in over strike mode; a one causes the editor to start in insert mode.\par }\pard \s25\fi-360\li720\sb40\keepn\widctlpar\adjustright {\pard\plain \s25\fi-360\li720\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:tab mode}}}{\pard\plain \s25\fi-360\li720\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 tabs}}}{\v\fs20 \par }\pard \s25\fi-360\li720\sb40\widctlpar\adjustright {\fs20 5.\tab If the fifth character is a 1, the editor inserts a tab character in the source file when the Tab command is used to tab to a tab stop. If the character is a 0, the editor inserts an appropriate number of spaces, instead.\par }\pard \s25\fi-360\li720\sb40\keepn\widctlpar\adjustright {\pard\plain \s25\fi-360\li720\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:over strike mode}}}{\v\fs20 \par }\pard \s25\fi-360\li720\sb40\widctlpar\adjustright {\fs20 6.\tab If the sixth character is a 0, the editor will start in over strike mode; if it is a 1, the editor starts in insert mode. Using a separate flag for the text based editor (this one) and the desktop editor (see the fourth flag) lets you enter one mode in the desktop editor, and a different mode in the text based editor.\par 7.\tab The seventh character is used by the ORCA/Desktop editor to indicate if a file uses the old or new style of imbedded debug character. GSoft\~BASIC doesn\rquote t use either one.\par }\pard \s25\fi-360\li720\sb40\keepn\widctlpar\adjustright {\pard\plain \s25\fi-360\li720\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:resource fork}}}{\pard\plain \s25\fi-360\li720\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:cursor position}}}{\pard\plain \s25\fi-360\li720\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 editor\:tabs}}}{\v\fs20 \par }\pard \s25\fi-360\li720\sb40\widctlpar\adjustright {\fs20 8.\tab If the eighth character is a 0, the editor saves the cursor position, tab stops and these flags.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par The third line of each set of lines in the SysTabs file sets default tab stops. There are 255 zeros and ones, representing the 255 character positions available on the edit line. The ones indicate the positions of the tab stops. A two in any column of this line sets the end of the line; if the characters extend past this marker, the line is wrapped. The column containing the two then replaces the default end-of-line column (the default right margin) when the editor is set to that language.\par For example, the following lines define the defaults for GSoft\~BASIC:\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 260\par 10011001\par 000000100000001000000010000000100000001000000010000000100000001000000010000000100000001000000010000000100000001000000010000000100000001000000010000000100000001000000010000000100000001000000010000000100000001000000010000000100000001000000010000000100000002\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par The last line continues on for a total of 255 characters, so it is too long to show on one line in this manual.\par If no defaults are specified for a language (that is, there are no lines in the SysTabs file for that language), then the editor assumes the following defaults:\par \par \bullet \tab }{\outl\fs18 RETURN}{\fs20  sends the cursor to column one.\par \bullet \tab Line-oriented selects.\par \bullet \tab Word wrapping starts in column 80.\par \bullet \tab There is a tab stop every eighth column.\par \bullet \tab The editor starts in over strike mode.\par \bullet \tab Tab characters are inserted to create tabbed text.\par \par Note that you can change tabs and editing modes while in the editor.\par \sect }\sectd \lndscpsxn\sbkodd\linex0\endnhere\titlepg\sectdefaultcl {\headerl \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 Language Reference Manual\par }}{\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Chapter 7: Program Symbols\par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Chapter 7 \endash  Program Symbols}{\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\v\f4\fs36\cgrid {\tc {\v Chapter 7 \endash  Program Symbols\tcl1}}}{\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 tokens\bxe }}}{\*\bkmkstart bk8}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 constants}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 lines}}}{\fs20 BASIC programs are made up of a series of program symbols called tokens. Tokens are the words used to write a program. They consist of identifiers, symbols, and constants. These tokens form lines, which are also a fundamental part of the BASIC language\emdash some commands, like SUB, must appear at the start of a line; most commands are restricted to appearing on a single line; and some commands cannot have anything following them on a line.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Identifiers}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Identifiers\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 identifiers\bxe }}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 case sensitivity}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 identifiers\:case sensitivity}}}{\fs20 Identifiers in BASIC start with an alphabetic character or underscore and are followed by zero or more alphabetic characters, numeric characters, or underscores. The last character in the identifier is an optional type character. BASIC is a case insensitive language, which means that the identifiers matrix and Matrix are the same identifier.\par Because GSoft\~BASIC is interpreted, the program is converted to a more efficient internal storage format than plain ASCII text. In the process, all identifiers are converted to uppercase letters. There is nothing preventing you from maintaining the program as a text file, especially if you use the version of GSoft\~BASIC that runs from the ORCA shell, but there is no way to stop this conversion to uppercase letters.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 identifiers\:length}}}{\fs20 GSoft\~BASIC imposes a limit of 255 characters on the length of any single identifier.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DIM statement}}}{\fs20 Type characters indicate the default data type for the identifier. If no type character is used, the default type is single-precision real. You can override the default type using the DIM statement.\par The type character, if it appears at all, becomes a part of the identifier. For example, R and R! both default to a data type of single-precision real, but they are different identifiers, and cannot be used interchangeably.\par The type characters and their equivalent BASIC data types are shown in the table blow. The internal formats for the data types are described in detail in the next chapter.\par \par }\pard\plain \s32\li360\ri4680\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx1800\adjustright \f4\cgrid {\fs20 Character\tab Type\par }\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \f4\cgrid {\fs20 ~}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ~}}}{\fs20 \tab BYTE}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 BYTE}}}{\fs20 \par %}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 %}}}{\fs20 \tab INTEGER}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 INTEGER}}}{\fs20 \par &}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 &}}}{\fs20 \tab LONG}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 LONG}}}{\fs20 \par !}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 !}}}{\fs20 \tab SINGLE}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 SINGLE}}}{\fs20 \par #}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 #}}}{\fs20 \tab DOUBLE}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 DOUBLE}}}{\fs20 \par }\pard \s25\li360\ri4680\sb40\widctlpar\tx1800\adjustright {\fs20 $}{\pard\plain \s25\li360\ri4680\sb40\widctlpar\tx1800\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 $}}}{\fs20 \tab STRING}{\pard\plain \s25\li360\ri4680\sb40\widctlpar\tx1800\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 STRING}}}{\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par Some examples of legal BASIC identifiers are shown below. They each represent a different identifier.\par \par }\pard \s25\li720\sb40\keepn\widctlpar\tx1980\tx3240\tx4500\tx5760\tx7020\adjustright {\fs20 MAIN\tab ARRAY\tab my_var\tab S$\tab I%\tab B~\par }\pard \s25\li720\sb40\widctlpar\tx1980\tx3240\tx4500\tx5760\tx7020\adjustright {\fs20 _subroutine\tab X1\tab _\tab D#\tab L&\tab R!\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Reserved Words}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Reserved Words\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 reserved words\bxe }}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 constants\:string}}}{\fs20 Reserved words are identifiers that have special meaning in BASIC. A reserved word can only be used for the meaning that BASIC assigns to it, except that reserved words can appear in comments}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 comments}}}{\fs20  or string constants. The reserved words in BASIC are shown below.\par \par }\pard \s25\sb40\widctlpar\tx360\tx1620\tx2880\tx4140\tx5400\tx6660\adjustright {\f6\fs20 \tab ABS\tab ALLOCATE\tab AND\tab APPEND\tab AS\tab ASC\tab \tab AT\tab ATN\tab BINARY\tab BREAK\tab BYTE\tab CALL\tab CASE\tab CDBL\tab CHDIR\tab CHR$\tab CINT\tab CLEAR\tab CLNG\tab CLOSE\tab CONT\tab COS\tab CSRLIN\tab CSNG\tab CURDIR$\tab DATA\tab DEF\tab DIM\tab DIR$\tab DISPOSE\tab DO\tab DOUBLE\tab ELSE\tab END\tab EOF\tab ERL\tab \tab ERR\tab ERROR\tab EXP\tab FN\tab FOR\tab FRE\tab FUNCTION\tab GET\tab GOSUB\tab GOTO\tab GSOS\tab HCOLOR=\tab HGR\tab HOME\tab HPLOT\tab HTAB\tab IF\tab INPUT\tab INT\tab INTEGER\tab INVERSE\tab KILL\tab LEFT$\tab LEN\tab \tab LET\tab LINE\tab LOADLIBRARY\tab LOC\tab LOF\tab \tab LOG\tab LONG\tab LOOP\tab MID$\tab MKDIR\tab MOUSETEXT\tab NAME\tab NEXT\tab NIL\tab NORMAL\tab NOT\tab ON\tab \tab ONERR\tab OPEN\tab OR\tab OUTPUT\tab PEEK\tab POINTER\tab POKE\tab POP\tab POS\tab PRINT\tab PUT\tab RANDOM\tab READ\tab REM\tab RESTORE\tab RESUME\tab RETURN\tab RIGHT$\tab RMDIR\tab RND\tab SEEK\tab SELECT\tab SETMEM\tab SGN\tab \tab SIN\tab SINGLE\tab SIZEOF\tab SPC\tab SPEED=\tab SQR\tab \tab STEP\tab STOP\tab STR$\tab STRING\tab SUB\tab TAB\tab \tab TAN\tab TCP \tab TEXT\tab THEN\tab TO\tab TOOL\tab TOOLERROR\tab TYPE\tab UNLOADLIBRARY\tab UNTIL\tab LIBRARY\tab USING\tab VAL\tab VTAB\tab WAIT\tab WEND\tab WHILE\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Reserved Symbols}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Reserved Symbols\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 reserved symbols\bxe }}}{\fs20 Reserved symbols are the punctuation of the BASIC language. Reserved symbols are used as mathematical operators, for forming array subscripts and parameter lists, for separating statements, and so forth. With some restrictions, reserved symbols can also be used in comments}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 comments}}}{\fs20  and }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 constants\:string}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 strings\:constants}}}{\fs20 string constants. See the sections below for details.\par The reserved symbols in BASIC are:\par \par }\pard \s25\sb40\keep\widctlpar\tx720\tx1980\tx3240\tx4500\tx5760\tx7020\adjustright {\f6\fs20 \tab !}{\pard\plain \s25\sb40\keep\widctlpar\tx720\tx1980\tx3240\tx4500\tx5760\tx7020\adjustright \v\f6\fs20\cgrid {\xe {\v\f6\fs20 }{\v\f6\fs20 !}}}{\f6\fs20 \tab :}{\pard\plain \s25\sb40\keep\widctlpar\tx720\tx1980\tx3240\tx4500\tx5760\tx7020\adjustright \v\f6\fs20\cgrid {\xe {\v\f6\fs20 }{\v\f6\fs20 \:}}}{\f6\fs20 \tab +}{\pard\plain \s25\sb40\keep\widctlpar\tx720\tx1980\tx3240\tx4500\tx5760\tx7020\adjustright \v\f6\fs20\cgrid {\xe {\v\f6\fs20 }{\v\f6\fs20 +}}}{\f6\fs20 \tab -}{\pard\plain \s25\sb40\keep\widctlpar\tx720\tx1980\tx3240\tx4500\tx5760\tx7020\adjustright \v\f6\fs20\cgrid {\xe {\v\f6\fs20 }{\v\f6\fs20 -}}}{\f6\fs20 \tab *}{\pard\plain \s25\sb40\keep\widctlpar\tx720\tx1980\tx3240\tx4500\tx5760\tx7020\adjustright \v\f6\fs20\cgrid {\xe {\v\f6\fs20 }{\v\f6\fs20 *}}}{\f6\fs20 \tab /}{\pard\plain \s25\sb40\keep\widctlpar\tx720\tx1980\tx3240\tx4500\tx5760\tx7020\adjustright \v\f6\fs20\cgrid {\xe {\v\f6\fs20 }{\v\f6\fs20 /}}}{\f6\fs20  \tab <}{\pard\plain \s25\sb40\keep\widctlpar\tx720\tx1980\tx3240\tx4500\tx5760\tx7020\adjustright \v\f6\fs20\cgrid {\xe {\v\f6\fs20 }{\v\f6\fs20 <}}}{\f6\fs20 \tab >}{\pard\plain \s25\sb40\keep\widctlpar\tx720\tx1980\tx3240\tx4500\tx5760\tx7020\adjustright \v\f6\fs20\cgrid {\xe {\v\f6\fs20 }{\v\f6\fs20 >}}}{\f6\fs20 \tab =}{\pard\plain \s25\sb40\keep\widctlpar\tx720\tx1980\tx3240\tx4500\tx5760\tx7020\adjustright \v\f6\fs20\cgrid {\xe {\v\f6\fs20 }{\v\f6\fs20 =}}}{\f6\fs20 \tab @}{\pard\plain \s25\sb40\keep\widctlpar\tx720\tx1980\tx3240\tx4500\tx5760\tx7020\adjustright \v\f6\fs20\cgrid {\xe {\v\f6\fs20 }{\v\f6\fs20 @}}}{\f6\fs20 \tab (}{\pard\plain \s25\sb40\keep\widctlpar\tx720\tx1980\tx3240\tx4500\tx5760\tx7020\adjustright \v\f6\fs20\cgrid {\xe {\v\f6\fs20 }{\v\f6\fs20 (}}}{\f6\fs20 \tab )}{\pard\plain \s25\sb40\keep\widctlpar\tx720\tx1980\tx3240\tx4500\tx5760\tx7020\adjustright \v\f6\fs20\cgrid {\xe {\v\f6\fs20 }{\v\f6\fs20 )}}}{\f6\fs20  \tab #}{\pard\plain \s25\sb40\keep\widctlpar\tx720\tx1980\tx3240\tx4500\tx5760\tx7020\adjustright \v\f6\fs20\cgrid {\xe {\v\f6\fs20 }{\v\f6\fs20 #}}}{\f6\fs20 \tab ,}{\pard\plain \s25\sb40\keep\widctlpar\tx720\tx1980\tx3240\tx4500\tx5760\tx7020\adjustright \v\f6\fs20\cgrid {\xe {\v\f6\fs20 ,}}}{\f6\fs20 \par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Constants}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Constants\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Constants are used to place numbers and strings into the source code of the program. Each kind of constant has its own unique format, so they are discussed separately.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Decimal Integers}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Decimal Integers\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Decimal integers come in two sizes, referred to as integer and long integer.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 integers\:constants}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 constants\:integer}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 INTEGER\bxe }}}{\fs20 Integers consist of one to five digits. The number represented must range from 0 to 32767. You may use a leading - character to form a negative number, although the - character and the number are technically two separate tokens. In practice, this technical distinction is not important.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 long integers\:constants}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 constants\:long integer}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LONG\bxe }}}{\fs20 If the number exceeds 32767, the number becomes a long integer. Long integer constants can range from 32768 to 2147483647.\par The table below shows some examples of legal decimal constants.\par \par }\pard \s25\sb40\widctlpar\tx720\tx1980\tx3240\tx4500\tx5760\tx7020\adjustright {\f6\fs20 \tab 0\tab 58\tab 32767\tab 32768\tab 400000\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Hexadecimal Integers}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Hexadecimal Integers\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 integers\:constants}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 constants\:hexadecimal}}}{\fs20 Hexadecimal numbers are integers represented in base sixteen, rather than the more familiar base ten. Hexadecimal numbers are made up of the digits 0 to 9 and the letters a to f or A to F. In BASIC, hexadecimal}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 hexadecimal}}}{\fs20  numbers are distinguished from decimal numbers by a leading $}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 $}}}{\fs20  character.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 long integers\:constants}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 constants\:long integer}}}{\fs20 As with decimal integers, hexadecimal integers can be long or short. Any hexadecimal constant with 5 or more digits\emdash even if those digits are zero\emdash is a long integer constant. Hexadecimal constants with four or less digits are integer constants.\par Integers and long integers are stored in two\rquote s complement notation, so hexadecimal constants can be negative. Any value with the most significant bit set is a negative number.\par If you are not familiar with hexadecimal notation and two\rquote s complement notation you can find out more in most assembly language books and many general computer science books.\par The table below shows some legal hexadecimal constants, along with their decimal equivalent and the kind of integer created.\par }\pard\plain \s32\li720\ri2880\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx2160\tx3600\adjustright \f4\cgrid {\fs20 hexadecimal\tab decimal\tab size\par }\pard\plain \s25\li720\ri2880\sb40\keepn\widctlpar\tx2160\tx3600\adjustright \f4\cgrid {\fs20 $0\tab 0\tab integer\par $00000\tab 0\tab long\par $000A\tab 10\tab integer\par $0010\tab 16\tab integer\par $8000\tab -32768\tab integer\par $08000\tab 32768\tab long\par $7FFF\tab 32767\tab integer\par $7FFFFFFF\tab 2147483647\tab long\par }\pard \s25\li720\ri2880\sb40\widctlpar\tx2160\tx3600\adjustright {\fs20 $FFFF\tab -1\tab integer\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Real Numbers}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Real Numbers\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 floating-point\:constants}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 constants\:floating-point}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SINGLE\bxe }}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DOUBLE\bxe }}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 exponent}}}{\fs20 Floating-point constants are used to represent numbers that do not have an integral value, or that cannot be represented using an integer because they are too large or too small. The general format is a sequence of digits, followed by a decimal point, followed by another sequence of digits, and an exponent, as in\par \par 3.14159e-14\par \par The exponent can start with either an uppercase E, or a lowercase e, as shown.\par The format for floating-point constants can vary quite a bit from this general form. You can leave out the digit sequence before or after the decimal point, as in 1.e10 or .1e10. In fact, you can leave off the exponent, too, as in 1. or .1. You must have either an exponent or a decimal point, but if you specify an exponent, you can omit the decimal point, as in 12e40.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 String Constants}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 String Constants\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 STRING\bxe }}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 strings\:constants\bxe }}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 constants\:strings}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ASCII character set}}}{\fs20 String constants consist of any sequence of characters except the end of line or the quote character, enclosed in quote characters.\par Internally, strings are represented as a sequence of bytes, one for each character in the string, followed by a terminating null byte. }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 null character}}}{\fs20 (A null byte has a value of zero.) The value of each byte is the ordinal value for the character, as specified by the ASCII character set, described in Appendix C.\par Here are some legal string constants:\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 "Hello, world."\par ""\par " "\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 White Space}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 White Space\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 white space}}}{\fs20 White space characters consist of the characters created by the space bar and tab key.\par White space characters can appear between any two tokens, but may not be used between the characters of a token. The interpreter strips whitespace characters from your program as it converts it to internal, tokenized form, and prints white space characters between tokens when you list or edit the program. You have no control over where these whitespace characters are placed, other than maintaining a copy of your program as an ASCII file.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Comments}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Comments\tcl2}}}{\fs28 \par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 ! any-ascii-characters\par REM any-ascii-characters\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 !\tcl3}}}{\v\fs20 \par }{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 REM\tcl3}}}{\v\fs20 \par }{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 REM statement\bxe }}}{\v\fs20 \par }{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 !\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 comments\bxe }}}{\fs20 Technically, comments in BASIC are a statement that is executed at run time. The statement skips to the start of the next line, ignoring any characters that appear after the comment command. GSoft\~BASIC allows absolutely any character to appear between the comment character and the end of the line, although the editor effectively limits the allowed characters to those available on the keyboard.\par There are two distinct comment commands in GSoft\~BASIC. REM is an almost universal comment command in implementations of BASIC. The ! character is less common, but not unusual. Both of these work the same way, and are equivalent in all respects.{\*\bkmkend bk8}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 tokens}{\rxe bk8}}}{\fs20 \par \sect }\sectd \lndscpsxn\sbkodd\linex0\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Chapter 8: Types of Data\par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Chapter 8 \endash  Types of Data}{\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\v\f4\fs36\cgrid {\tc {\v Chapter 8 \endash  Types of Data\tcl1}}}{\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 types}}}{\fs20 This chapter describes those BASIC data types which are built into the language. The next chapter covers derived and user-defined data types.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 assembly language}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 data formats}}}{\fs20 Some of the information in this chapter deals with the way information is stored internally in the memory of the computer. This information is provided for very advanced programmers who need to write assembly language subroutines that will deal with BASIC data, or who need to do strange and dangerous tricks with the data to work with the machine at the hardware level. You do not need to understand this information to use GSoft\~BASIC for normal BASIC programming. If it does not make sense to you, or if you will not be using the information, simply ignore it.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Integers}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Integers\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 integers}}}{\fs20 GSoft\~BASIC supports three different types of integers, BYTE, INTEGER and LONG.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 BYTE}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 identifiers}}}{\fs20 Integers defined as BYTE are the smallest. BYTE values require one byte of storage. The allowed values range from 0 to 255. By default, identifiers ending with the character ~}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ~}}}{\fs20  are defined as BYTE integers.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 INTEGER}}}{\fs20 INTEGER variables require two bytes of storage. INTEGER values can range from -32768 to 32767. By default, identifiers ending with the character %}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 %}}}{\fs20  are defined as INTEGER variables.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LONG}}}{\fs20 Integers defined as LONG require four bytes of storage. LONG values range from -2147483648 to 2147483647. By default, identifiers ending with the character &}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 &}}}{\fs20  are defined as LONG variables.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 integers\:storage}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 long integers\:storage}}}{\fs20 Internally, all integers are represented as binary values. Negative integers are represented as two\rquote s complement numbers. All of the integers that occupy more than one byte of storage are stored with the least significant byte first, proceeding to the most significant byte. This is the natural byte order for the 65816}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 65816}}}{\fs20  processor used in the Apple II}{\fs18 GS}{\fs20 .\par It is likely that there will be versions of GSoft\~BASIC for other platforms, and many, including the Macintosh, use a different byte order for integer values. If you write programs that make assumptions about the byte order for integers, your program will not execute properly on some other computers.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Reals}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Reals\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SANE}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 floating-point}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 floating-point\:see also SINGLE}{\txe }}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 floating-point\:see also DOUBLE}{\txe }}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 Innovative Systems}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 exponent}}}{\fs20 GSoft\~BASIC supports two storage formats for real numbers.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SINGLE}}}{\fs20 SINGLE numbers are stored in the IEEE floating point number format, with the least significant byte first. They require four bytes of storage. SINGLE values are accurate to seven decimal digits, and allow exponents with a range of about 1e-38 to 1e38. By default, identifiers}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 identifiers}}}{\fs20  ending with the character !}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 !}}}{\fs20  or without a type character are defined as SINGLE variables.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DOUBLE}}}{\fs20 DOUBLE numbers require eight bytes of storage each. They are stored least significant byte first, using the IEEE floating point format. They are accurate to fifteen decimal digits, and allow exponent ranges from 1e-308 to 1e308. By default, identifiers ending with the character #}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 #}}}{\fs20  are defined as DOUBLE variables.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Infinity}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Infinity\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The IEEE number format supports infinity}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 infinity\bxe }}}{\fs20 . This is a specially coded value that indicates the number is too large to represent. It is signed, so you can have either positive infinity or negative infinity. The value prints as inf}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 inf\bxe }}}{\fs20  or -inf, depending on the sign.\par All numeric operations in GSoft\~BASIC support this number, and do reasonable things with it based on the mathematical concept of infinity. For example, adding any number to infinity is still infinity, while dividing a number by infinity gives zero.\par In some cases, your calculations may actually work fine, even if an intermediate result is infinity. In other cases, detecting a value of infinity is simply an indication that you need to tune your algorithms or switch from SINGLE to DOUBLE.\par If your program treats a numeric overflow as an error, you can check for the overflow by comparing the result with infinity. The code snippet shows one way to create a value to compare with, and handles both negative and positive infinity. This particular example generates a run time error when the number X is infinity. Unless intercepted by an ONERR GOTO error handler, ERROR}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ERROR statement}}}{\fs20  25 will generate an error message that prints \ldblquote Illegal quantity error.\rdblquote \par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 INF = 1E50\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 IF ABS(X) = INF THEN ERROR 25\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 NaN}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 NaN\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The IEEE number format supports an error number that prints as NaN}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 NaN\bxe }}}{\fs20 ; this stands for \ldblquote not a number.\rdblquote  It is generated whenever a numeric result is simply not valid. An example is taking the square root of a negative number.\par All numeric operations in GSoft\~BASIC support this number. In general, it propagates through the calculation, so that all of the values that are based on NaN are also NaN. For example, adding any number to NaN results in NaN.\par In most cases, NaN indicates an error condition, but the fact that it doesn\rquote t trigger an immediate halt to the program or force you to write a tricky ONERR GOTO handler gives you more options for handling the error gracefully in your program.\par For those cases where you want to stop the program when NaN is detected, the code snippet shows how to test for the condition and flag a run time error. Unless intercepted by an ONERR GOTO error handler, ERROR}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ERROR statement}}}{\fs20  19 will generate an error message that prints \ldblquote Illegal quantity error.\rdblquote \par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 NAN = SQR (-1)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 IF X = NAN THEN ERROR 25\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Strings}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Strings\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 STRING}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ASCII character set}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 garbage collection}}}{\fs20 Strings are stored internally as a sequence of ASCII characters terminated by a null character. The null character is a character with an ordinal value of 0.\par Unlike all other variable types, strings are stored in a special buffer to allow their length to change without using large amounts of memory. A string variable is actually a four byte pointer into a dynamic string heap. When a string value changes, the old value is abandoned and a new string is allocated at the bottom of the string heap. If the heap grows to fill all available memory, garbage collection is performed, squashing all strings together to recover unused space.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 toolbox\:string parameters}}}{\fs20 A side effect of this storage method is that you cannot change the length of a string from a toolbox subroutine. You can return a string; GSoft\~BASIC allocates space for the value you return in the string buffer in the normal way. You can also safely change the characters in a string as long as the length of the string does not change.\par By default, identifiers}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 identifiers}}}{\fs20  ending with the character $}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 $}}}{\fs20  are defined as STRING variables.\par See SETMEM for a way to change the size of the variable buffer used by strings. See FRE for a way to determine the amount of free space available in this buffer, as well as for a way to force garbage collection so it does not occur at inopportune times.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Pointers}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Pointers\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 pointers}}}{\fs20 Pointers are represented internally as four-byte unsigned numbers, with the least significant byte stored first. A value of zero is used to represent a null pointer. Using type casting, pointers can be treated as long integers in mathematical equations with no loss of precision.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 byte}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 memory\:see also pointers}{\txe }}}{\fs20 The memory of the Apple\~II}{\fs18 GS}{\fs20  is divided into units of 8 bits called bytes. Each of these bytes has a unique address, represented as a number between 0 and 16777215. If you convert any valid pointer to an integer using CLNG}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CLNG}}}{\fs20 , the result will be a number from 1 to 16777215. Zero is reserved as a special pointer called NULL}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 NULL}}}{\fs20 , which is defined as not pointing to anything.\par These bytes are grouped into larger chunks to represent the familiar data types used by BASIC. An INTEGER value occupies two adjacent bytes. LONG, pointer and SINGLE values each use four adjacent bytes, and DOUBLE values use eight bytes. The number of bytes used by a string varies; strings use one byte per character in the string, plus a single byte to mark the end of the string.\par When you create a variable, the proper number of bytes are set aside for its use. Setting the variable changes the value of the bytes set aside for that variable value. Using the address operator}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 address operator}}}{\fs20 , @}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 @}}}{\fs20 , you can get a pointer to the variable. Using CLNG, you can convert this pointer to the integer value representing the address of the first byte of storage used for the value. You can use type casting}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 type casting}}}{\fs20  to convert from an integer to a pointer.\par While there is no memory location beyond 16777215 ($00FFFFFF) on an Apple\~II}{\fs18 GS}{\fs20 , pointer values can technically go up to 4294967295, so long as they are reduced to a legitimate memory address before being used. In fact, most Apple\~II}{\fs18 GS }{\fs20 computers don\rquote t have 16777216 ($01000000) bytes of memory, and even if they do, it\rquote s not all RAM}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 RAM}}}{\fs20 . The memory space of the Apple\~II}{\fs18 GS }{\fs20 is actually divided into three distinct kinds. Random Access Memory (RAM) is the kind you\rquote ll generally be using with pointers. RAM starts at byte 0 and extends sequentially. For an Apple\~II}{\fs18 GS }{\fs20 with 4 megabytes of RAM, the valid addresses would be 0 to 4194303 ($003FFFFF). Read Only Memory (ROM) starts as byte 16777215 ($00FFFFFF) and extends down; how far depends on the model of your computer. Sprinkled here and there are some exceptions to this general scheme, mostly in the form of memory mapped I/O. Memory mapped I/O are bytes that appear to a program to be normal memory, but are in fact connected to hardware in a special way. A classic example is the Apple\~II}{\fs18 GS }{\fs20 keyboard}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 keyboard}}}{\fs20 , which causes values for the characters typed to appear at memory location 49152 ($0000C000).\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 memory}}}{\fs20 For more information about the memory organization of the Apple\~II}{\fs18 GS }{\fs20 , see }{\i\fs20 Apple\~II}{\i\fs18 GS}{\i\fs20  Firmware Reference}{\fs20  and }{\i\fs20 Apple\~II}{\i\fs18 GS}{\i\fs20  Hardware Reference, Second Edition}{\fs20 . Both of these books are available as reprints from the Byte Works.\par \sect }\sectd \lndscpsxn\sbkodd\linex0\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Chapter 9: BASIC Programs\par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Chapter 9 \endash  BASIC Programs}{\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\v\f4\fs36\cgrid {\tc {\v Chapter 9 \endash  BASIC Programs\tcl1}}}{\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 The Anatomy of a BASIC Program}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 The Anatomy of a BASIC Program\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 BASIC programs are made up of a series of lines, each of which can have zero or more BASIC statements. Blank lines are allowed, and multiple statements can appear on the same line if the statements are separated by a colon character, with a few exceptions noted in the descriptions of individual statements.\par The program begins execution with the first line, continuing sequentially unless the normal flow of execution is changed by one of the statements that is encountered.\par Here is a simple BASIC program that prints a string to the screen.\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 \tab PRINT "Hello, world."\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Subroutines}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Subroutines\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 FUNCTION statement}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SUB statement}}}{\fs20 BASIC programs can contain subroutines and functions, declared with the SUB and FUNCTION statement. Subroutines and functions are referred to as procedures in situations where either one is allowed. These procedures appear after the main program, one after the other. While it is possible to type lines between these subroutines, they are never executed.\par The main program always appears first, and execution always starts there. The main program can call subroutines, which can in turn call other subroutines.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Line Numbers}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Line Numbers\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 line numbers\bxe }}}{\fs20 Lines start with an optional line number. The line number is an integer in the range 1 to 65535 appearing at the beginning of the line.\par There are two fundamentally different ways to use line numbers, and in some important ways they are incompatible.\par Traditional BASIC programs require a line number on each program line. If you are importing an Applesoft\~BASIC program, or if you are using the line editor in the GSoft\~BASIC shell, this may still be a convenient way to organize your program. Using this model, a line number must appear at the start of every line. The line numbers must be unique, and they are forced to be sequential. If you load an ASCII program with line numbers that are out of order, they are sorted as they are loaded. If a duplicate line number appears, the newer line replaces the original line with the same number.\par Like most BASICs implemented after the early 1980\rquote s, GSoft\~BASIC does not require line numbers. If any line does not use a line number, the second model kicks in. Line numbers are still available, but they are usually not used unless you need a destination for a branching statement, such as GOTO or ONERR. Line numbers do not have to be sequential, and in fact, they don\rquote t even have to be unique. It\rquote s common to see the same line number used in various subroutines within a program. Since there is no requirement that the line numbers be unique, you can copy a subroutine from one program and paste it into another without worrying about conflicts between the line numbers.\par Line numbers appearing in the same subroutine or in the program should be unique within that part of the program, although the interpreter does not enforce this restriction. For example, the subroutine\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 \tab SUB Duplicate\par 10\tab PRINT "Start"\par \tab GOTO 10\par 10\tab PRINT "Done"\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 \tab END\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 will not generate an error, although it will perform an infinite loop. When duplicate line numbers appear in the same part of a program, the first is always found and subsequent numbers are invisible to the interpreter.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Multiple Statements on One Line}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Multiple Statements on One Line\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 \:}}}{\fs20 Normally, each BASIC statement appears on a separate line in the program. In most cases, it is technically possible to place more than one statement on a line if you separate the statements with the : character. For example, the line\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 IF A < B THEN C = A : A = B : B = C\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 uses this feature to execute three separate statements instead of one when A is less than B. In GSoft\~BASIC, it would be more common to use a block IF statement to do the same thing, like this:\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 IF A < B THEN\par    C = A\par    A = B\par    B = C\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END IF\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par This may look a bit peculiar to the Applesoft\~BASIC programmer, but most people find programs written this way to be easier to read after they get used to the format.\par \sect }\sectd \lndscpsxn\sbkodd\linex0\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Chapter 10: Declaring Variables and Types\par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Chapter 10 \endash  Declaring Variables and Types}{\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\v\f4\fs36\cgrid {\tc {\v Chapter 10 \endash  Declaring Variables and Types\tcl1}}}{\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 What Is a Type?}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 What Is a Type?\tcl2}}}{\fs28 \par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 A Short History of Types in BASIC}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 A Short History of Types in BASIC\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 {\*\bkmkstart bk17}BASIC was originally intended as a simpler version of FORTRAN}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 FORTRAN}}}{\fs20 , and was targeted at scientists and engineers who needed to write short programs. The original implementations of BASIC supported a wide variety of mathematical operations, including built-in matrix}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 matrix}}}{\fs20  mathematics operations. Other than simple numbers and strings, about the only data type was the array, which doubled as a matrix.\par Matrix operations were dropped as BASIC made the move from the science and engineering community to personal computers in the late 70\rquote s and early 80\rquote s. By that time, computer scientists were embracing languages like ALGOL, which supported records}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 records}}}{\fs20  and pointers}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 pointers}}}{\fs20 . Microsoft}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 Microsoft}}}{\fs20  eventually installed records in its BASIC interpreters, which pretty much made them a standard, but until the advent of GSoft\~BASIC, no commercially available BASICs we are aware of supported both pointers and records in the same fluid way that they are implemented in Pascal and C.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 The Kinds of Types}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 The Kinds of Types\tcl3}}}{\fs24 \par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Simple Types}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Simple Types\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 At the simplest level, a type is a kind of value that can be stored in a variable. GSoft\~BASIC supports six simple types. The name of each type is itself a type, and can be used as a type in DIM and TYPE statements.}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 TYPE statement}}}{\fs20  The six simple types are:\par \par }\pard \s25\fi-1080\li1440\sb40\widctlpar\adjustright {\fs20 BYTE}{\pard\plain \s25\fi-1080\li1440\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 BYTE}}}{\fs20 \tab A single integer byte with the range 0 to 255.\par INTEGER}{\pard\plain \s25\fi-1080\li1440\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 INTEGER}}}{\fs20 \tab A two byte signed integer with a range of -32768 to 32767.\par LONG}{\pard\plain \s25\fi-1080\li1440\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LONG}}}{\fs20 \tab A four byte signed integer with a range of -2147483648 to 2147483647.\par }{\pard\plain \s25\fi-1080\li1440\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 exponent}}}{\fs20 SINGLE}{\pard\plain \s25\fi-1080\li1440\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SINGLE}}}{\fs20 \tab A four byte single-precision floating-point number with exponents of approximately 1E-38 to 1E38.\par DOUBLE}{\pard\plain \s25\fi-1080\li1440\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DOUBLE}}}{\fs20 \tab An eight byte double-precision floating-point number with exponents of approximately 1E-308 to 1E308.\par STRING}{\pard\plain \s25\fi-1080\li1440\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 STRING}}}{\fs20 \tab Strings are sequences of up to 32767 characters. Each string requires one byte of storage per character, plus an overhead of five bytes. One of the five bytes of overhead is used to mark the end of the string; it is a zero value that appears after the last character. The other four bytes are a pointer to the first character of the string; this is the value actually stored in the string variable.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Arrays}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Arrays\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 {\*\bkmkstart bk9}Arrays are sequences of the same type of variable. A particular variable is selected using a subscript, which is a numeric value that specifies which of the various variables should be used. The first value in each array has a subscript of 0; subsequent values are numbered sequentially.\par BASIC supports multiply subscripted arrays, too. Multiple subscripts are separated by commas. Here is an example that shows the creation and initialization of a unit matrix with 5 columns and 5 rows.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM A(4, 4)\par FOR I% = 0 TO 4\par   FOR J% = 0 TO 4\par     A(I%, J%) = 0.0\par   NEXT\par   A(I%, I%) = 1.0\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 memory\:array storage}}}{\fs20 BASIC followed the lead of FORTRAN when it picked the order that values are stored in memory, and unfortunately, some BASIC programs take advantage of this order. Naturally enough, in an array with a single subscript, the 0th element comes first, followed by the 1st element, the 2nd element, and so on. In an array with multiple subscripts, the leftmost index increases the fastest. For the 5 by 5 matrix shown in the code snippet, the memory order for the array elements is\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 \tab A(0,0)\tab A(1,0)\tab A(2,0)\tab A(3,0)\tab A(4,0)\tab A(0,1)\tab A(1,1)\tab A(2,1)\tab ...\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par In the vast majority of cases, the base type for an array is one of the number types, but GSoft\~BASIC also allows arrays of strings, arrays of records}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 records}}}{\fs20 , and arrays of pointers}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 pointers}}}{\fs20 .\par GSoft\~BASIC imposes two practical limitations on arrays. The first is a limit on the range of a subscript; subscripts cannot be larger than 32767, and as was mentioned before, the smallest subscript is 0. There is also a limit on the total size of each array. The maximum size of all of the data in an array cannot exceed 65536 bytes. This is a limit on the size of any single array, not on the total size of all arrays. If there is enough memory in the computer, and you have used SETMEM to make the variable space large enough, you can easily create several arrays, each of which is 65536 bytes long.\par You can calculate the number of bytes used by an array by multiplying the size of one element of the array in bytes by the number of elements in each subscript. For example, the array in the code snippet uses 100 bytes; 4 bytes for each SINGLE value multiplied by 5 rows multiplied by 5 columns. Arrays of strings use 4 bytes per string entry, so an array of strings cannot hold more than 16384 strings. The remaining memory used by the string, which includes one byte per character plus an extra byte to mark the end of the string, comes from another location in memory, and doesn\rquote t count against the total size of the array.\par There is no limit on the number of subscripts other than the obvious limit imposed by restricting arrays to 65536 bytes.\par {\*\bkmkend bk9}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 arrays\bxe }{\rxe bk9}}}{\v\fs20 \par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Records}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Records\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\*\bkmkstart bk10}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 field}}}{\fs20 Records are collections of variables that are generally not the same type. Each value in the record is called a field; fields can be simple types, arrays, pointers, or other records.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 memory\:records}}}{\fs20 No single record can exceed 65536 bytes. As with arrays, this is a limit on the size of a single record, not the total memory used by all records. If there is enough free memory, and SETMEM has been used to reserve enough of it for use by variables, you can create several records whose total size is far larger than 65536 bytes.\par You can calculate the number of bytes used by a record by adding the sizes of each field. One ADDRESS record like the one in the code snippet requires 20 bytes; four for each of the four strings and four more for the LONG zip code. The MAILLIST array uses 10,000 bytes, so it is still well within the 65536 byte limit for a single array.\par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TYPE ADDRESS\par   NAME$\par   STREET$\par   CITY$\par   STATE$\par   ZIP&\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END TYPE\par DIM MAILLIST AS ADDRESS(500)\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 MAILLIST(0).NAME$ = "Albert Einstein"\par MAILLIST(0).STREET$ = "1 Light Way"\par MAILLIST(0).CITY$ = "Forever"\par MAILLIST(0).STATE$ = "Relative"\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 MAILLIST(0).ZIP& = 300000000\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\*\bkmkend bk10}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 records}{\rxe bk10}}}{\v\fs20 \par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Pointers}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Pointers\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 {\*\bkmkstart bk11}A pointer is not a type by itself. A pointer always points to some specific type of value; the complete type is POINTER TO followed by whatever type it points to. For example, to specify a type that is a pointer to an integer value, you use the type POINTER TO INTEGER.\par Each pointer requires four bytes of storage. Since one or more pointers can point to the same thing, and they can point either to variables in the traditional variable space or to areas outside of the memory normally used by GSoft\~BASIC, they don't generally require any more storage than the four bytes for the pointer itself\emdash the memory for the value the pointer points to is already accounted for by the variable it points to, or was allocated from outside of GSoft\~BASIC\rquote s memory space using ALLOCATE.}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ALLOCATE statement}}}{\fs20 \par A pointer can point to a simple type, a record, or another pointer. A pointer cannot point to an array, but it can point to an element of an array. In most practical cases, pointing to the first value in an array amounts to the same thing as pointing to the array itself.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 linked lists}}}{\fs20 The snippet shows a simplified version of a typical use for pointers. Several records are created by allocating the memory directly with ALLOCATE. These records are chained together by creating a pointer within each record that points to the next record in a sequence. In a way, this has the same effect as creating an array, but unlike an array, the number of things in a linked list like the one in the example is not fixed. The list can grow to fill all of available memory if need be, but if less memory is needed, it only occupies the actual amount of memory that is required to hold all of the entries in the list.\par In the snippet, the values are printed and disposed of, freeing the memory for other uses. That\rquote s another important difference between linked lists and arrays}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 arrays}}}{\fs20 : If the program is finished with the list, the memory can be reused without stopping the program or erasing all of the other variables, too.\par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TYPE NUMBER\par   AFTER AS POINTER TO NUMBER\par   VALUE AS INTEGER\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END TYPE\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 DIM NUMBERS AS POINTER TO NUMBER\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 DIM TEMP AS POINTER TO NUMBER\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 FOR I% = 1 TO 10\par   ALLOCATE (TEMP)\par   IF TEMP <> NIL THEN\par     TEMP^.AFTER = NUMBERS\par     TEMP^.VALUE = I%\par     NUMBERS = TEMP\par   END IF\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 WHILE NUMBERS <> NIL\par   TEMP = NUMBERS\par   NUMBERS = TEMP^.AFTER\par   PRINT TEMP^.VALUE\par   DISPOSE (TEMP)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 WEND\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\*\bkmkend bk11}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 pointers}{\rxe bk11}}}{\v\fs20 \par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Named Types}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Named Types\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 named types}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 records}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The last kind of type is a named type. Named types are types you create using the TYPE statement.}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 TYPE statement}}}{\fs20  Each record is a named type, and you can create other named types by giving the name and the expanded form of the type, like this:\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TYPE IPTR AS POINTER TO INTEGER\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 The name IPTR is now a type, just like SINGLE. It can be used to declare variables the same way SINGLE is used.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 There are two typical reasons to create a name for a type this way. The first is essentially a typing shortcut and an aid to understanding the program. By using the type name, rather than the expanded form of the type, your program is shorter and sometimes easier to follow.\par The second reason to create a name for a type is type casting. The name of any pointer type can be used as a function. The argument to the function is any pointer type, and the value returned by the function is a pointer to the same byte of memory, but with the named type.\par See }{\i\fs20 Type Casting}{\fs20  in Chapter 11 for a more in depth description of type casting.\par See the next section, }{\i\fs20 Type Compatibility}{\fs20 , for a more complete discussion of when and why type casting is necessary.\par See the description of the TYPE statement, later in this chapter, for a detailed discussion of the mechanics of defining a type.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Type Compatibility}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Type Compatibility\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\*\bkmkstart bk12}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parameters\:type compatibility}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 With the plethora of new types available in GSoft\~BASIC, it\rquote s important to understand when two types are compatible. If two types are compatible, their values can be used interchangeably: a value can be assigned to a variable or passed as a parameter if their types are compatible, and two values can be compared if their types are compatible.\par There are actually two shades of type compatibility. Two values are type compatible if they are completely interchangeable. Two values are assignment compatible if one value can be assigned to a variable of the other type, or when the value can be passed as a parameter. Since BASIC automatically converts numbers of one type to another, assignment compatibility}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 assignment compatibility}}}{\fs20  is not as restrictive as type compatibility. This distinction between assignment compatibility and type compatibility is only important for numbers and pointers to numbers.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Numeric Type Compatibility}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Numeric Type Compatibility\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 All of the numeric types are assignment compatible with each other: you can freely mix numbers of different types. For two numbers to be type compatible, though, the numbers must be exactly the same kind.\par There are four situations where the difference between type compatibility and assignment compatibility is important.\par First, some of the automatic type conversions can lead to a loss of precision. If you assign 1.9 to an integer variable, the value that is stored is 1. The same is true when you use the SINGLE value 1.9 as an array subscript: the number is first converted to an integer value 1, and the integer result is used to determine the array element to select. This can lead to strange results if roundoff error causes a value to be slightly less than the expected integer. For example, try this:\par \par }\pard \s25\fi360\sb40\keepn\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 arrays}}}{\v\fs20 \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 FOR I = 0 TO 10\par   A(I) = I\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par I = 4 / 3\par I = I * 3\par PRINT A(I)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par Obviously, the program should print 4. Actually, it prints 3. The reason is that 4 / 3 isn\rquote t stored as exactly one and one-third, it\rquote s stored as approximately 1.333333. When multiplied by 3, the result is approximately 3.999999, and when truncated, the index used to access the array is 3, not 4.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 floating-point}}}{\fs20 In general, your program will be both faster and less prone to bugs of this kind if you always use integer or long integer values when calculating an array subscript. If you must use floating-point subscript values, add 0.5 to the subscript to eliminate the possibility of this kind of roundoff error.\par The second place the difference between type compatibility and assignment compatibility is important is when the numeric values involved cannot be converted. For example, assigning the SINGLE value 3E5 to an INTEGER variable causes a run-time error, since an INTEGER cannot hold values larger than 32767.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parameters\:type compatibility}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parameters\:pass by reference}}}{\fs20 The third place this difference is important is when you are passing parameters to subroutines. Whenever you pass a named variable as a subroutine parameter, the variable is passed by reference. \ldblquote Passed by reference\rdblquote  means the subroutine can alter the variable\rquote s value directly. For example,\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 I = 4\par CALL CHANGE (I)\par PRINT I\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 SUB CHANGE (X)\par X = X * 2\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SUB\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 prints the value 8; the subroutine changed the value of the original variable that was passed as a parameter. This only happens when a variable is passed, though. If you pass the result of any expression, even an expression as simple as preceding the variable by a +}{\pard\plain \s25\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 +}}}{\fs20  operator or enclosing it in parentheses}{\pard\plain \s25\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parentheses}}}{\fs20 , }{\pard\plain \s25\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parameters\:pass by value}}}{\fs20 the parameter is passed by value. When a parameter is passed by value, the subroutine cannot change the original variable. The subtle change of adding parentheses, like this:\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 I = 4\par CALL CHANGE ((I))\par PRINT I\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 SUB CHANGE (X)\par X = X * 2\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SUB\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 causes the program to print 4, rather than 8.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The reason this change is important for type compatibility is that variables that are passed by reference must match the type of the parameter exactly\emdash no conversion of any kind is done. If a subroutine expects an INTEGER parameter, you cannot pass a SINGLE variable by reference. You can pass a SINGLE constant, or you can turn the SINGLE value into an expression that is passed by value by enclosing the variable name in parentheses, but the variable name itself cannot be passed.\par The last situation where the difference between type compatibility and assignment compatibility is important is for pointers to numbers. Two pointers to numeric types are compatible only if the underlying numeric type is exactly the same.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Strings}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Strings\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 strings}}}{\fs20 Strings are always compatible with each other. Strings are not compatible with any other type.\par Strings can be converted to numbers, and numbers can be converted to strings, using the STR$ and VAL functions.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Records}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Records\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 records}}}{\fs20 Record values are compatible with each other if both record variables are defined from the same base type. Different names can be involved, so long as the underlying type is the same, but if the record types are different, the values are not compatible, even if the fields of each record are the same.\par To explore how this works, we\rquote ll use these type and variable declarations.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TYPE POINT\par   X\par   Y\par   Z\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END TYPE\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 TYPE VECTOR\par   X\par   Y\par   Z\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END TYPE\par TYPE XYZ AS POINT\par DIM P AS POINT\par DIM POINTS(5) AS POINT\par DIM PP AS POINTER TO POINT\par DIM V AS VECTOR\par DIM ALPHA AS XYZ\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par With these types in place, the value P is compatible with POINTS(3) and PP^, since all three refer to the same base type, POINT. P is also type compatible with ALPHA; even though ALPHA is defined as a record whose type is XYZ, XYZ is itself defined as a POINT. P is not type compatible with V, though. Even though POINT and VECTOR have the same number of fields, and the fields are the same type\emdash indeed, they even have the same names in this example\emdash POINT and VECTOR are distinct record types.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Pointers}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Pointers\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 pointers}}}{\fs20 Two pointers are type compatible if they point to values that are compatible. In the case of pointers to numbers, the underlying number must be exactly the same type; a pointer to an INTEGER is not type compatible with a pointer to a BYTE.\par You can use type casting to convert pointers from one type to another, as well as to convert a number to a pointer. See }{\i\fs20 Type Casting}{\fs20  in Chapter 11 for details.\par Pointers can be converted to numbers using the function CLNG.\par {\*\bkmkend bk12}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 type compatibility}{\rxe bk12}}}{\v\fs20 \par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Default Types}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Default Types\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DIM statement}}}{\fs20 There are two ways to create a named variable in BASIC. The most direct way is with the DIM statement. The DIM statement is traditionally used to dimension arrays, but it can also be used to create a variable with any type you like. For example, the DIM statement\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM I AS INTEGER\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 creates a new variable called I, and makes this variable an INTEGER.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The most common way to create a new variable, though, is to simply use it. BASIC guarantees that the value will be created and initialized to 0 or an empty string, as appropriate. This doesn\rquote t really matter in most cases, since a variable is almost always assigned an initial value the first time it is used.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 identifiers}}}{\fs20 There needs to be some way to assign a type to a new variable, though. BASIC uses a special set of characters that can appear at the end of any identifier. If the variable is declared by using it in an expression, this trailing character determines the variable\rquote s type.\par For example, % is used for integers. The program\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 FOR I% = 1 TO 10\par   PRINT I%\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 creates the variable I% when the FOR loop starts. Since the last character in the variable\rquote s name is %, this variable is an INTEGER.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Here\rquote s a complete list of the type characters}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 type characters}}}{\fs20  in GSoft\~BASIC.\par \par }\pard\plain \s32\li360\ri4680\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx1800\adjustright \f4\cgrid {\fs20 Character\tab Type\par }\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \f4\cgrid {\fs20 ~}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ~}}}{\fs20 \tab BYTE}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 BYTE}}}{\fs20 \par %}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 %}}}{\fs20 \tab INTEGER}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 INTEGER}}}{\fs20 \par &}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 &}}}{\fs20 \tab LONG}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 LONG}}}{\fs20 \par !}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 !}}}{\fs20 \tab SINGLE}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 SINGLE}}}{\fs20 \par #}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 #}}}{\fs20 \tab DOUBLE}{\pard\plain \s25\li360\ri4680\sb40\keepn\widctlpar\tx1800\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 DOUBLE}}}{\fs20 \par }\pard \s25\li360\ri4680\sb40\widctlpar\tx1800\adjustright {\fs20 $}{\pard\plain \s25\li360\ri4680\sb40\widctlpar\tx1800\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 $}}}{\fs20 \tab STRING}{\pard\plain \s25\li360\ri4680\sb40\widctlpar\tx1800\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 STRING}}}{\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par Variables that don\rquote t have a type character are declared as SINGLE.\par If the type character is used, it becomes a part of the variable name. Using the variable without the type character will create a completely different variable. This short program creates two distinct variables, as the PRINT statement proves when you run the program.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM I AS INTEGER\par I% = 4\par I = 5\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PRINT I%, I\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 identifiers}}}{\fs20 While a type character at the end of an identifier becomes a part of the variable name, type characters cannot be used anywhere else in the variable name. Only one is allowed, and that one type character, if it is used at all, must be the last character in the variable\rquote s name.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DIM statement}}}{\fs20 If a variable is created by the DIM statement, the type you give in the DIM statement overrides any type character, or the absence of a type character. In the example just shown, the variable I would have been a SINGLE variable if the DIM statement was not in the program, since variables without a type character default to SINGLE. In this case, though, the variable I is an INTEGER variable. It\rquote s just as possible to create a variable called I% that holds a SINGLE value using the same idea, but of course anyone who does this for anything but a prank deserves to have their fingers smacked with a ruler. Any BASIC programmer will assume that a variable with a trailing % character is an INTEGER; making it something else could cause confusion.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 arrays}}}{\fs20 Arrays can also be defined by using the array, rather than with the DIM statement. The number of subscripts matches the number used in the expression where the array first appears. The maximum subscript is always 10. For example, encountering the statement\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 A(1, 1) = 11\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 without first encountering a DIM statement creates an array of SINGLE values. The array has two subscripts, and each can range from 0 to 10, so there are 121 SINGLE values in the array.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Arrays and non-arrays are distinct, so you can have an array and a non-array variable with the same name. This isn\rquote t generally a good idea, but it is possible. Arrays are not distinct, though. For example, you can\rquote t create two arrays with the same name, even if they have a different number of subscripts.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Declaring Types and Variables}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Declaring Types and Variables\tcl2}}}{\fs28 \par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 DIM identifier [ subscript ] [ AS type ] [ ',' identifier [ subscript ] [ AS type ] ]*\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 DIM\tcl3}}}{\v\fs20 \par }{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DIM statement\bxe }}}{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 AS}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The DIM statement is used to create a variable. Variables can be created by simply using them in a BASIC expression, but there are two situations where you need more control over how the variable is created than you get when you simply use a variable. In addition, many programmers find that dimensioning each and every variable is a good way to document what variables are used in a program and how they are used\emdash a comment just before or after the DIM statement is very handy for remembering how a program\rquote s data structures are used.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Dimensioning Arrays}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Dimensioning Arrays\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 {\*\bkmkstart bk13}The first situation where you need control over how a variable is created is dimensioning an array. This is the most common use for DIM, and it\rquote s also the traditional use that gives the statement its name. To dimension an array, give the name of the array with the maximum value for each subscript. For example,\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM V(5), A(5, 5)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 dimensions two arrays. The first is an array with six SINGLE values, subscripted from 0 to 5. The second array has two subscripts, each ranging from 0 to 5. The full array contains 36 SINGLE values.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 As with any variable, you can use type characters to specify the type of the elements in the array. For example,\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM A#(7, 7)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 creates an array of 64 DOUBLE values. See }{\i\fs20 Default Types}{\fs20 , earlier in this chapter, for a complete discussion of type characters. You can also specify a specific type using AS; this is covered in }{\i\fs20 Assigning a Type With AS}{\fs20 , right after this section.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 floating-point}}}{\fs20 In most situations it makes more sense to use an INTEGER}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 INTEGER}}}{\fs20  value for array subscripts, but it is possible to use any numeric value. Values are always converted to INTEGER before being used as a subscript. For floating-point values, the value is truncated, so a subscript of 3.999 is treated as the INTEGER value 3. The potential problems of this sort of round-off error are the main reason floating-point values should not normally be used for array subscripts. Calculating the array subscript also takes much longer using floating-point arithmetic; in some programs the speed difference can be dramatic.\par In most cases DIM statements appear right at the start of a program or subroutine, and the subscripts are constant values. These normal use rules come about because it makes sense to organize programs with the DIM statements at the beginning, and in most cases the size of an array is fixed. There are situations where it makes sense to use an expression for the size of an array, though, and occasionally it even makes sense to imbed the DIM statement in the program.\par For example, here\rquote s an array that uses the value stored in I% to determine the size of the array. This value might be read from a disk file just before reading the numbers for the array, or it might be entered by the person using the program.\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM SPEED(I%)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par Here\rquote s an example that uses one of two sizes for several arrays, depending on how much memory is available.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 IF FRE(0) > 64*1024 THEN\par   DIM NAME$(BIG%)\par   DIM ADDRESS$(BIG%)\par   DIM CITY$(BIG%)\par   DIM STATE$(BIG%)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18   DIM ZIP&(BIG%)\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 ELSE\par   DIM NAME$(SMALL%)\par   DIM ADDRESS$(SMALL%)\par   DIM CITY$(SMALL%)\par   DIM STATE$(SMALL%)\par   DIM ZIP&(SMALL%)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END IF\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par The lowest allowed subscript in any array is 0, and the largest allowed subscript is 32767. The maximum size for a single array is 65536 bytes. See }{\i\fs20 Arrays}{\fs20 , earlier in this chapter, for a more complete discussion of these limits.\par {\*\bkmkend bk13}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 arrays}{\rxe bk13}}}{\v\fs20 \par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Assigning a Type With AS}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Assigning a Type With AS\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The AS}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 AS}}}{\fs20  clause is used to assign a type to a variable. AS is followed by the name of a type. This can be something as simple as the name of a default type or as complex as the name of a record.\par For example,\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM I AS INTEGER, J AS INTEGER, K AS INTEGER\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 creates three INTEGER variables that don\rquote t need % as the last character of the variable name. You can use this idea with any of the built-in types. The built-in types are BYTE}{\pard\plain \s25\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 BYTE}}}{\fs20 , INTEGER}{\pard\plain \s25\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 INTEGER}}}{\fs20 , LONG}{\pard\plain \s25\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LONG}}}{\fs20 , SINGLE}{\pard\plain \s25\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SINGLE}}}{\fs20 , DOUBLE}{\pard\plain \s25\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DOUBLE}}}{\fs20  and STRING}{\pard\plain \s25\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 STRING}}}{\fs20 . See }{\i\fs20 Default Types}{\fs20 , earlier in this chapter, for a complete discussion of these types.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 While it rarely if ever makes sense to do so, you can use the AS clause to override the type of a variable. For example,\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM COST$ AS SINGLE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 creates a variable named COST$; this would normally be a string, but because of the AS clause, the variable is SINGLE.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 A less mundane use of the AS clause is to create a record variable. Record types are created with the TYPE statement.}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 TYPE statement}}}{\fs20  For example,\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TYPE CUBE\par   TOP\par   BOTTOM\par   LEFT\par   RIGHT\par   FRONT\par   BACK\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END TYPE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 creates a record type whose type name is CUBE. Each CUBE record contains six SINGLE fields. The DIM statement\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM C AS CUBE, CUBES(10) AS CUBE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 creates two variables. C is a CUBE record variable, while CUBES is an array of 11 CUBE records.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Type names aren\rquote t always so simple. You can use POINTER}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 POINTER}}}{\fs20  TO before any type name to create a pointer to a value. For example,\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM CP AS POINTER TO CUBE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 creates a pointer variable named CP. This pointer points to a CUBE record. You can allocate a cube record using ALLOCATE, or point CP to an existing CUBE record with the address operator, like this:\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 CP = @CUBES(4)\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Using Default Types With DIM}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Using Default Types With DIM\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The last use of the DIM statement is to create a variable using its normal default type. This is entirely optional, since BASIC will create the variable for you and initialize it to zero the first time it is used in the subroutine or program, but this is a convenient way to create a dictionary of your variables and describe how they are used in the program.\par The statements\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM I%: REM Loop/index variable\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 DIM INTEREST: REM Annual interest rate\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 create two variables, the INTEGER variable I% and the SINGLE variable INTEREST, and give a clue as to how these variables are used in the program.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 TYPE identifier\par }\pard \s30\fi-360\li360\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20   [ ( field-name [ AS type ] )\par     | ( CASE [ expression ] ) ]+\par END TYPE\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 TYPE-END TYPE\tcl3}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 TYPE statement\bxe }}}{\fs20 {\*\bkmkstart bk16}The TYPE statement has two major forms. The form described in this section is used to create record types. The other form, described right after this one, is used to assign a name to a simple type or pointer.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Declaring Record Types}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Declaring Record Types\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 arrays}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 field}}}{\fs20 A record contains one or more values, just like an array. Unlike an array, the values in a record do not have to be the same type. Each of these values is called a field, and each has its own name and its own type, just like a variable that is not a field in a record.\par The field declarations appear between the TYPE and END TYPE statements. Each field declaration looks exactly like a variable defined in a DIM statement, but without the DIM. Just as with a DIM statement, you can declare fields using an AS clause, using default types, or using array subscripts.\par Here\rquote s a classic example of a record. Each record contains an address.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TYPE ADDRESS\par   NAME$\par   STREET$\par   CITY$ : STATE$ : ZIP&\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END TYPE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par This particular record has five fields, four strings and a LONG zip code. It\rquote s customary to put each field on a separate line, but this example shows how to put multiple fields on one line.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 How Records Are Stored In Memory}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 How Records Are Stored In Memory\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 memory\:records}}}{\fs20 Knowing how records are stored in memory is important for some kinds of programming, especially toolbox programming. In toolbox programming and other situations where a GSoft\~BASIC program is communicating with another program or device, it\rquote s often necessary to lay out a record that will occupy bytes in memory in a very specific way. Knowing how records are stored is also key to understanding how values can be overlaid in memory using variant records}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 variant records}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 records\:variant}}}{\fs20 .\par To explore how records are stored in memory, we\rquote ll use these contrived record types, which show an example of each kind of variable that can appear in a record.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TYPE POINT\par   H AS INTEGER\par   V AS INTEGER\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END TYPE\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 TYPE ALLKINDS\par   B AS BYTE\par   I AS INTEGER\par   L AS LONG\par   S AS SINGLE\par   D AS DOUBLE\par   STR AS STRING\par   A(3) AS INTEGER\par   P AS POINT\par   PTR AS POINTER TO INTEGER\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END TYPE\par \par DIM R AS ALLKINDS\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 field}}}{\fs20 Each field in a record occupies one or more bytes in memory. The amount of memory and exact storage method is discussed more completely in the various sections that describe the data types. For our purpose in this section, it is enough to know that a BYTE value requires one byte, an INTEGER uses two bytes, LONG and SINGLE values and pointers to any value require four bytes, and DOUBLE values require eight bytes. Strings are a special case. The string value is stored in a special memory pool; the string variable, which is what is stored in the record, requires four bytes of memory, so for this discussion we treat all strings as if they require four bytes of memory.\par Fields within a record are stored sequentially. The record POINT consists of two INTEGER values, so each record variable of type POINT needs four bytes of memory. The field H will occupy the first two bytes of the record, and the field V will occupy the last two bytes in the record variable. The usual way to describe the position of the fields is to say that H is zero bytes past the start of the record, or that it has a displacement of zero, while V has a displacement of two bytes.\par The variable R is a record of type ALLKINDS. It uses 39 bytes of memory, laid out like this:\par \par }\pard\plain \s32\li360\ri3240\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tqr\tx2520\tx3600\adjustright \f4\cgrid {\fs20 Displacement\tab Size\tab Field Name\par }\pard\plain \s25\li360\ri3240\sb40\keepn\widctlpar\tqr\tx1440\tqr\tx2520\tx3600\adjustright \f4\cgrid {\fs20 \tab 0\tab 1\tab B\par \tab 1\tab 2\tab I\par \tab 3\tab 4\tab L\par \tab 7\tab 4\tab S\par \tab 11\tab 8\tab D\par \tab 19\tab 4\tab STR\par \tab 23\tab 8\tab A\par }\pard \s25\li360\ri3240\sb40\widctlpar\tqr\tx1440\tqr\tx2520\tx3600\adjustright {\fs20 \tab 31\tab 4\tab P\par \tab 35\tab 4\tab PTR\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Variant Records}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Variant Records\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\*\bkmkstart bk14}{\*\bkmkstart bk15}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 memory\:variant records}}}{\fs20 A variant record is used to treat memory in different ways, setting up variables that occupy the same memory. A simple example is the toolbox rectangle record, RECT. Rectangles require four integer values, one each for the top, bottom, left and right edges of the rectangle. Due to some schizophrenic naming, there are three different naming schemes for rectangle records on the Apple\~II}{\fs18 GS}{\fs20 \emdash the names used on the Macintosh, a method that treats a rectangle as two corner points, and the one most people use, which names the edges H1, H2, V1 and V2. Here\rquote s how this record is declared:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TYPE RECT\par   CASE NORMAL\par     V1 AS INTEGER\par     H1 AS INTEGER\par     V2 AS INTEGER\par }\pard \s31\fi360\widctlpar\adjustright {\fs18     H2 AS INTEGER\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18   CASE MAC\par     TOP AS INTEGER\par     LEFT AS INTEGER\par     BOTTOM AS INTEGER\par }\pard \s31\fi360\widctlpar\adjustright {\fs18     RIGHT AS INTEGER\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18   CASE POINTS\par     TOPLEFT AS POINT\par     BOTRIGHT AS POINT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END TYPE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par The CASE}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CASE}}}{\fs20  clause causes the displacement counter to start over. The expression that appears after CASE is for your benefit, not BASIC\rquote s. It serves as a comment, telling what the variant part is used for. You can leave it off, or make it the same as a variable you use to keep track of the variant parts within a record.\par In this simple example the result is a record with three different names for each of the integers that are stored in the record. For example,\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM R AS RECT\par R.V1 = 4\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PRINT R.TOP\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 prints 4, since R.V1 and R.TOP are different names for the same value. Here\rquote s a table that shows the names for each of the offsets in a RECT record.\par }\pard\plain \s32\li360\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tqr\tx2520\tx3600\tx4680\tx5760\adjustright \f4\cgrid {\fs18 Displacement\tab Size\tab Field Names\par }\pard\plain \s25\li360\sb40\keepn\widctlpar\tqr\tx1440\tqr\tx2520\tx3600\tx4680\tx5760\adjustright \f4\cgrid {\fs18 \tab 0\tab 2\tab V1\tab TOP\tab TOPLEFT.V\par \tab 2\tab 2\tab H1\tab LEFT\tab TOPLEFT.H\par \tab 4\tab 2\tab V2\tab BOTTOM\tab BOTRIGHT.V\par }\pard \s25\li360\sb40\widctlpar\tqr\tx1440\tqr\tx2520\tx3600\tx4680\tx5760\adjustright {\fs18 \tab 6\tab 2\tab H2\tab RIGHT\tab BOTRIGHT.H\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par The CASE}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CASE}}}{\fs20  clause is a marker that divides the various parts of the record from each other. Each of the parts is called a variant part. All variables from the first CASE to the next, or until the END TYPE for the last CASE clause, form a variant part, which is overlaid on all of the other variant parts. They don\rquote t have to be the same length; the total length of the record is determined by the longest CASE clause. For example, in the record\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TYPE SIZE\par   CASE ONE\par     I AS INTEGER\par   CASE TWO\par     S AS SINGLE\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END TYPE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 the record will be four bytes long. The first variant part is a single two byte INTEGER, while the second is a four byte SINGLE. Each variable will need four bytes so it can hold the longest possible variant part.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Another use of variant records is to treat the same value two different ways. For example, let\rquote s assume you need to split a four byte LONG value into two INTEGER values. That\rquote s a real problem in a surprising number of situations. Here\rquote s a variant record that can be used to do it.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TYPE CONVERT\par   CASE LONGWORD\par }\pard \s31\fi360\widctlpar\adjustright {\fs18     L&\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18   CASE WORD\par     I1%\par     I2%\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END TYPE\par DIM C AS CONVERT\par !\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 L& = $00020001\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PRINT C.I1%, C.I2%\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par The first integer in the record overlays the first two bytes of the long integer value, which is the least significant integer on an Apple\~II}{\fs18 GS}{\fs20 ; the second integer overlays the most significant integer. The program demonstrates this concept by stuffing a hexadecimal value into the long integer value. The hexadecimal constant makes it easy to see that the least significant two bytes of the long value should be 1, while the most significant two bytes should be 2. The program shows this is true by printing the values.\par You can also place variables before the first CASE}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CASE}}}{\fs20  clause. Variables that appear before the first CASE are not overlaid at all; they appear in all versions of the record. A great example is a control record, used to describe the characteristics of a control in a window. All controls have a field for the rectangle that surrounds the control, so this field needs to be available for all records. Only a scroll bar has a thumb rectangle, though, and it doesn\rquote t need a key equivalent like some of the other controls. Rather than waste space by reserving memory for a key equivalent in a scroll bar or for a thumb rectangle in a button, Apple\rquote s engineers used a variant record to lay out controls. Leaving out the dozens of other fields, the three we discussed look like this in the type declaration for a control record.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TYPE CTLREC\par   CTLRECT AS RECT\par   CASE BTNORCHECK\par     KEYEQUIV AS KEYEQUIVREC\par   CASE SCROLL\par     THUMBRECT AS RECT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END TYPE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 In this record, CTLRECT has a displacement of zero. Rectangles use 8 bytes of memory, so both KEYEQUIV and THUMBRECT have offsets of 8.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\*\bkmkend bk14}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 variant records}{\rxe bk14}}}{\*\bkmkend bk15}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 records\:variant}{\rxe bk15}}}{\v\fs20 \par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Using the Record Type In The Record (Linked Lists)}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Using the Record Type In The Record (Linked Lists)\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 linked lists}}}{\fs20 A type must be declared before it can be used, but the type name is already declared as the fields are being created. This means that the name of the record type can be used when creating a field within the same record\emdash but only when you are declaring a pointer to the type. We\rquote ll discuss the reason for this restriction after looking at a concrete example of a record type name used inside the same record.\par The short program below shows a linked list, which is the classic reason to use a record\rquote s name when declaring a field in the record. A linked list is a record with at least one field that is a pointer to another record of the same kind. Linked lists are frequently used in database applications, since they can adapt to a widely varying amount of memory. Linked lists are also used extensively in the Apple\~II}{\fs18 GS}{\fs20  toolbox. For example, window records have a pointer to another window record. When you open a new window, the Window Manager creates a new window record. Each window has a pointer to the next window. The Window Manager has a single pointer to the first open window, and scans the list to deal with all of the windows that are open. This is a powerful combination: The Window Manager can handle any number of windows, so long as you have enough memory, but it never uses more memory than it needs for the actual number of windows that are open. An array doesn\rquote t have either of these advantages.\par In the example below, NUMBER is a record type that holds an INTEGER value. AFTER is a field within NUMBER that points to the next record in the linked list. The program builds the linked list by allocating memory for each record using ALLOCATE, then filling in the values. NUMBERS is a pointer to the first record in the linked list; the program can find all of the other records by tracing through the pointers to subsequent records.}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ALLOCATE statement}}}{\fs20 \par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TYPE NUMBER\par   AFTER AS POINTER TO NUMBER\par   VALUE AS INTEGER\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END TYPE\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 DIM NUMBERS AS POINTER TO NUMBER\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 DIM TEMP AS POINTER TO NUMBER\par !\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 FOR I% = 1 TO 10\par   ALLOCATE (TEMP)\par   IF TEMP <> NIL THEN\par     TEMP^.AFTER = NUMBERS\par     TEMP^.VALUE = I%\par     NUMBERS = TEMP\par   END IF\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 WHILE NUMBERS <> NIL\par   TEMP = NUMBERS\par   NUMBERS = TEMP^.AFTER\par   PRINT TEMP^.VALUE\par   DISPOSE (TEMP)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 WEND\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par If you\rquote ve never dealt with pointers and linked lists, this will seem rather strange, but if you plan to do anything resembling database programming or toolbox programming, you\rquote ll eventually get very comfortable with linked lists. For an introduction to linked lists, see }{\i\fs20 Learn to Program in GSoft\~BASIC}{\fs20 , a companion course that teaches general programming techniques using GSoft\~BASIC.\par Thinking about how records are stored in memory should make it easy to see why a record\rquote s name can only be used as a pointer inside that same record. Something like this:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TYPE NUMBER\par   N AS NUMBER\par   I AS INTEGER\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END TYPE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 just wouldn\rquote t make sense. For one thing, BASIC has no idea how many bytes to reserve for the record variable N, since the record hasn\rquote t been completed yet. For another, it\rquote s not really clear even after you look at the entire record just how it should look in memory. After all, the field N has a NUMBER record inside it, and that NUMBER record has another field N, which has another NUMBER record, and so on.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 A pointer to the record doesn\rquote t share those problems. A pointer always uses four bytes of memory, so BASIC knows exactly how many bytes to set aside for the field.\par {\*\bkmkend bk16}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 records}{\rxe bk16}}}{\v\fs20 \par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 TYPE identifier AS type\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 TYPE-AS\tcl3}}}{\v\fs20 \par }{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 TYPE statement\bxe }}}{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 AS}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The TYPE statement has two major forms. The form described in this section is used to assign a name to a simple type or pointer. The other form, described right before this one, is used to create record types.\par This form of the TYPE statement creates a new named type. There are two common reasons to do this: organization and naming pointer types.\par It\rquote s common to declare a record and use pointers to the record. You\rquote ll see this throughout the Apple\~II}{\fs18 GS}{\fs20  toolbox, where windows, controls, menus, menu bars, points and rectangles are frequently dealt with via a pointer to the value. When a pointer to a particular kind of value is used in many places, it makes sense to create a type for the pointer itself. For example, the toolbox defines a rectangle pointer like this:\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TYPE RECTPTR AS POINTER TO RECT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 With this type in place, you can create a pointer to a rectangle with the DIM statement using this type name.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM RP AS RECTPTR\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par Strictly speaking, this doesn\rquote t create a new type, it just attaches a name to a frequently used type. For example, if we create a completely separate pointer to a rectangle, like\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TYPE RPTR AS POINTER TO RECT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 and another variable using this second type,\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM RP2 AS RPTR\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 or even a variable that doesn\rquote t use either type, as in\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM RP3 AS POINTER TO RECT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 all of the variables are compatible. You can assign one to the other, or pass any of them as a parameter to a subroutine that expects a pointer to a rectangle.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The second common reason to create a named type is for organization. If you\rquote re creating a program that deals with the physical quantities speed and mass, you could define all of your variables as SINGLE.\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM SPEED1, SPEED2, MASS1, MASS2\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 That would work well, and it\rquote s what you will find in most programs that deal with speed and mass. An alternative is to create new types for speed and mass, like this:\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TYPE SPEEDTYPE AS SINGLE\par TYPE MASSTYPE AS SINGLE\par DIM SPEED1 AS SPEEDTYPE, SPEED2 AS SPEEDTYPE\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 DIM MASS1 AS MASSTYPE, MASS2 AS MASSTYPE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par At first it probably seems brain-dead to add all that typing to the program. Let\rquote s assume, though, that the entire program has several thousand lines of code, and declares dozens of values that are speeds or masses in various subroutines throughout the program. If you suddenly discover that you need DOUBLE values for masses because your program needs more than seven significant digits, you\rquote re stuck searching through the entire program line by line for all the locations that need to be changed. If you organized the program with types, though, you only need to change one line:\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TYPE MASSTYPE AS DOUBLE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par The method you choose often depends on the size of programs you write and how many times the program is likely to be changed, but organizing a program with types is a powerful way to make it easy to change.\par {\*\bkmkend bk17}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 types}{\rxe bk17}}}{\v\fs20 \par }{\fs20 \sect }\sectd \lndscpsxn\sbkodd\linex0\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Chapter 11: Expressions and Assignments\par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Chapter 11 \endash  Expressions and Assignments}{\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\v\f4\fs36\cgrid {\tc {\v Chapter 11 \endash  Expressions and Assignments\tcl1}}}{\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Expressions}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Expressions\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 {\*\bkmkstart bk24}BASIC works on values, manipulating, storing, and retrieving information stored in the bytes of your computer\rquote s RAM and on various external storage devices. Almost all of the statements in BASIC that accept a value as a parameter allow you to use an expression. An expression can be something as simple as the number 1, or as complicated as a complex mathematical formula taking information from a disk, pointers to records, and arrays. This chapter describes how expressions work.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Kinds of Expressions}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Kinds of Expressions\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 There are four different kinds of expressions in BASIC. They can be intermixed, and putting them together follows the same underlying rules, so all four are described here as a group. The difference between them lies simply in the result they produce.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Mathematical Expressions}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Mathematical Expressions\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 expression\:mathematical}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 mathematical expression}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Most BASIC commands and statements work on numbers. A mathematical expression is any expression that results in a number, whether that number is an INTEGER}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 INTEGER}}}{\fs20 , LONG}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LONG}}}{\fs20 , SINGLE}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SINGLE}}}{\fs20  or DOUBLE}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DOUBLE}}}{\fs20  value.\par When you see the term }{\b\fs20 expression}{\fs20  in the model for a BASIC statement, it generally means that the expression is a mathematical expression. In a few cases, like the LET statement, it can also mean that the expression can be a mathematical expression, pointer expression or a string expression. Those cases are usually obvious. After all, you need to be able to assign values to string variables, just as you assign values to numerical variables, so LET must support string expressions as well as mathematical expressions. Just as obviously, you can\rquote t take the square root of a string, so the expression accepted by SQR must be a mathematical expression. In any case, the description of the command will point out what kinds of expressions are valid by telling you what the operation is and by explicitly stating when strings or pointers are allowed.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Logical Expressions}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Logical Expressions\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 expression\:logical}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 logical expression}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Some commands test to see if a condition is true or false. The IF statement is the classic example. The condition is called a logical expression.\par At one level, logical expressions are exactly the same as mathematical expressions. Both are calculated the same way. Both result in a number. The difference is not how they are created, but how they are used.\par While the result of a logical expression is a number, what is needed is a logical value}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 logical value}}}{\fs20 \emdash either true}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 true}}}{\fs20  or false}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 false}}}{\fs20 . To make this jump, BASIC treats any number whose value is zero as false, and any other value as true.\par Operations that return a logical value, like the OR operation, always return 0 for false and 1 for true. While it is not technically required, most implementations of BASIC seem to follow this rule. In GSoft\~BASIC, the number is always returned as an INTEGER. In most situations this doesn\rquote t make much difference, but operations on integers are a bit faster than operations on other kinds of numbers.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 floating-point}}}{\fs20 There is one place where conversion of numbers can lead to some unexpected results. Be careful of floating-point values used as logical values. The value 0.01, for example, is not a zero, so by itself it has a logical value of true. If you save the value in an integer, though, it converts to zero, changing the result to false. This causes the following program to print TRUE the first time, and FALSE the second, even though strict logic requires both values to be the same.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 L = 0.1\par L% = L\par PRINT_LOGICAL(L OR 0)\par PRINT_LOGICAL(L% OR 0)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 SUB PRINT_LOGICAL (L)\par IF L THEN\par   PRINT "TRUE"\par ELSE\par   PRINT "FALSE"\par END IF\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SUB\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Pointer Expressions}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Pointer Expressions\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 expression\:pointer}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 pointer expression}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 pointers}}}{\fs20 GSoft\~BASIC is rare. Unlike older implementations of BASIC, GSoft\~BASIC handles pointers smoothly, just like C and Pascal.\par Pointers are values that point to the location where another value is stored. Pointer expressions return a pointer to some other value.\par Variables have a type. For example, I% is a variable whose type is INTEGER. Pointers have a type, too, but the type can vary. A pointer points to something, and the type of the pointer is POINTER TO whatever the other type happens to be. Two pointers are interchangeable if they point to the same kind of value, but cannot be assigned or compared if they point to different kinds of values. You can, however, change the type of a pointer using type casting, discussed later in this chapter.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 String Expressions}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 String Expressions\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 expression\:string}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 strings\:expressions}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 String expressions return strings, as the name implies. Generally the string is the result of a function, like LEFT$, but the math operation +}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 +}}}{\fs20  also works on strings, combining them to form a longer string.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Evaluating Expressions}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Evaluating Expressions\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 To help us analyze how expressions are constructed, we\rquote ll divide the discussion into two categories. This section will discuss the various operations that accept two numbers or strings and return a single number or string. These are technically known as binary operators}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 binary operators}}}{\fs20 . In the next section, we\rquote ll discuss term}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 term}}}{\fs20 s, which are numbers, variables, and operations that work on a single value and return a single result. As we\rquote ll see, you can always think of a term as a single value, and these values can be combined with the operations in this section two at a time.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Operator Precedence}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Operator Precedence\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 expression\:operator precedence}}}{\fs20 When you write a mathematical formula, you expect that some operations are performed before others. For example, if you see\par \par 1 + 2 x 3\par \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 you expect the result to be 7, because multiplication is always done before addition. The technical term for this choice of order is operator precedence}{\pard\plain \s25\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 operator precedence}}}{\fs20 . Operations with a higher precedence are always done before those with a lower precedence.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The following table shows operator precedence for all of the operations in BASIC, both the binary operations (those that take two arguments, like addition and division) described in this section and the unary operations (those that take a single argument, like NOT) described with terms. The operations at the top of the table have a higher precedence, and are always performed first.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 comparison operators}}}{\fs20 When operations have the same precedence, the operation is always done in left-to-right order. Normally this doesn\rquote t matter, but in some numerically sensitive equations it can make a difference.\par }\pard\plain \s32\li360\ri3240\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx1080\tx1800\tx2520\tx3240\tx3960\adjustright \f4\cgrid {\fs20 Operations By Precedence\par }\pard\plain \s25\li360\ri3240\sb40\keepn\widctlpar\tx1080\tx1800\tx2520\tx3240\tx3960\adjustright \f4\cgrid {\fs20 .}{\pard\plain \s25\li360\ri3240\sb40\keepn\widctlpar\tx1080\tx1800\tx2520\tx3240\tx3960\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 .}}}{\fs14\up6 1}{\fs20 \tab ^}{\pard\plain \s25\li360\ri3240\sb40\keepn\widctlpar\tx1080\tx1800\tx2520\tx3240\tx3960\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ^}}}{\fs14\up6 2}{\fs20 \tab ^.}{\fs14\up6 3}{\fs20 \tab (}{\pard\plain \s25\li360\ri3240\sb40\keepn\widctlpar\tx1080\tx1800\tx2520\tx3240\tx3960\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 (}}}{\fs20 )}{\pard\plain \s25\li360\ri3240\sb40\keepn\widctlpar\tx1080\tx1800\tx2520\tx3240\tx3960\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 )}}}{\fs14\up6 4}{\fs20 \par @}{\pard\plain \s25\li360\ri3240\sb40\keepn\widctlpar\tx1080\tx1800\tx2520\tx3240\tx3960\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 @}}}{\fs20 \par +}{\pard\plain \s25\li360\ri3240\sb40\keepn\widctlpar\tx1080\tx1800\tx2520\tx3240\tx3960\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 +}}}{\fs14\up6 5}{\fs20 \tab -}{\pard\plain \s25\li360\ri3240\sb40\keepn\widctlpar\tx1080\tx1800\tx2520\tx3240\tx3960\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 -}}}{\fs14\up6 5}{\fs20 \tab NOT}{\pard\plain \s25\li360\ri3240\sb40\keepn\widctlpar\tx1080\tx1800\tx2520\tx3240\tx3960\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 NOT}}}{\fs20 \par ^}{\fs14\up6 6}{\fs20 \par *}{\pard\plain \s25\li360\ri3240\sb40\keepn\widctlpar\tx1080\tx1800\tx2520\tx3240\tx3960\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 *}}}{\fs20 \tab /}{\pard\plain \s25\li360\ri3240\sb40\keepn\widctlpar\tx1080\tx1800\tx2520\tx3240\tx3960\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 /}}}{\fs20 \par +\tab -\par =}{\pard\plain \s25\li360\ri3240\sb40\keepn\widctlpar\tx1080\tx1800\tx2520\tx3240\tx3960\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 =}}}{\fs20 \tab <}{\pard\plain \s25\li360\ri3240\sb40\keepn\widctlpar\tx1080\tx1800\tx2520\tx3240\tx3960\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 <}}}{\fs20 \tab >}{\pard\plain \s25\li360\ri3240\sb40\keepn\widctlpar\tx1080\tx1800\tx2520\tx3240\tx3960\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 >}}}{\fs20 \tab <=}{\pard\plain \s25\li360\ri3240\sb40\keepn\widctlpar\tx1080\tx1800\tx2520\tx3240\tx3960\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 <=}}}{\fs20 \tab >=}{\pard\plain \s25\li360\ri3240\sb40\keepn\widctlpar\tx1080\tx1800\tx2520\tx3240\tx3960\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 >=}}}{\fs20 \tab <>}{\pard\plain \s25\li360\ri3240\sb40\keepn\widctlpar\tx1080\tx1800\tx2520\tx3240\tx3960\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 <>}}}{\fs20 \par AND}{\pard\plain \s25\li360\ri3240\sb40\keepn\widctlpar\tx1080\tx1800\tx2520\tx3240\tx3960\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 AND}}}{\fs20 \par OR}{\pard\plain \s25\li360\ri3240\sb40\keepn\widctlpar\tx1080\tx1800\tx2520\tx3240\tx3960\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 OR}}}{\fs20 \par }\pard \s25\fi360\sb40\keepn\widctlpar\adjustright {\fs20 \par }\pard \s25\fi-360\li720\sb40\keepn\widctlpar\adjustright {\fs20\ul Notes for the operator precedence table:\par }{\fs14\up6 1}{\fs20 \tab Used to access fields in a record.\par }{\fs14\up6 2}{\fs20 \tab Used to dereference a pointer, returning the value pointed to rather than the value of the pointer.\par }{\fs14\up6 3}{\fs20 \tab Used to access the field of a record that is pointed to by a pointer.\par }{\fs14\up6 4}{\fs20 \tab In this table, the parentheses}{\pard\plain \s25\fi-360\li720\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parentheses}}}{\fs20  indicate accessing an array.\par }{\fs14\up6 5}{\fs20 \tab These are the unary versions of the operations. For example, -X uses the unary subtraction operation.\par }\pard \s25\fi-360\li720\sb40\widctlpar\adjustright {\fs14\up6 6}{\fs20 \tab This is the exponentiation}{\pard\plain \s25\fi-360\li720\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 exponentiation}}}{\fs20  operation. 2^3 is 2*2*2, or 8.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par You can use parentheses}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parentheses}}}{\fs20  to change the order of operations. For example,\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PRINT 1 + 2 * 3\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 prints 7, but\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PRINT (1 + 2) * 3\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 prints 9.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Binary Conversions}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Binary Conversions\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\*\bkmkstart bk18}{\*\bkmkstart bk19}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 expression\:conversions in}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 GSoft\~BASIC supports five different kinds of numbers: BYTE, INTEGER}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 INTEGER}}}{\fs20 , LONG}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LONG}}}{\fs20 , SINGLE}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SINGLE}}}{\fs20  and DOUBLE}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DOUBLE}}}{\fs20 . Binary conversions are the rules used to perform operations on different kinds of numbers. These rules tell you both what the result will be, and in some cases how the calculation is performed.\par Most of the time these differences are not important. BASIC converts numbers back and forth as needed without causing much trouble. There are a few situations where the difference is important, though. Understanding them could save you hours of staring at a program that }{\i\fs20 ought}{\fs20  to work, but just doesn\rquote t seem to give you the answer you expect.\par Unless otherwise noted, when two numbers of the same kind are used with a binary operation, the result is a number of the same kind, too. For example, if you add two integers, as in I% + J%, the result is also an integer.\par The one universal exception is BYTE}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 BYTE}}}{\fs20 . GSoft\~BASIC treats BYTE variables as a special case of INTEGER that uses less storage. Operations involving BYTE values always work as if the values were INTEGER.\par When you mix two different kinds of number in the same operation, the numbers are }{\i\fs20 first}{\fs20  converted to the same number type, then the operation is performed. For example, R * I%, where R is a SINGLE number, is carried out by converting I% to a SINGLE value, then doing the multiplication. The result is SINGLE.\par The following table shows how binary conversions are carried out. Since BYTE numbers are always converted to INTEGER, they are not shown in the table. The rightmost column shows both the number format the values are converted to before the calculation is performed and the kind of number the operation returns.\par }\pard\plain \s32\li360\ri2520\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx1980\tx3780\adjustright \f4\cgrid {\fs20 If one value is\u8230\'c9\tab and the other is\u8230\'c9\tab the calculation is\u8230\'c9\par }\pard\plain \s25\li360\ri2520\sb40\keepn\widctlpar\tx1980\tx3780\adjustright \f4\cgrid {\fs20 DOUBLE\tab SINGLE\tab DOUBLE\par DOUBLE\tab LONG\tab DOUBLE\par DOUBLE\tab INTEGER\tab DOUBLE\par SINGLE\tab LONG\tab SINGLE\par SINGLE\tab INTEGER\tab SINGLE\par }\pard \s25\li360\ri2520\sb40\widctlpar\tx1980\tx3780\adjustright {\fs20 LONG\tab INTEGER\tab LONG\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\*\bkmkend bk18}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 binary conversions}{\rxe bk18}}}{\v\fs20 \par {\*\bkmkend bk19}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 conversions\:binary}{\rxe bk19}}}{\v\fs20 \par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Unary Conversions}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Unary Conversions\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 {\*\bkmkstart bk20}{\*\bkmkstart bk21}There are many places in GSoft\~BASIC where a number is converted from one type to another. For example, this happens during binary conversions, described above. Unary conversions are also made when you assign a number that is one type to a variable of another type using a LET statement, or when you pass a value as a parameter.}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parameters\:unary conversions}}}{\fs20  You can also force a unary conversion using the functions CINT, CLNG, CSNG and CDBL. In all of these cases, the conversion from one number type to another is done in exactly the same way. This section describes how these conversions are performed.\par }\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \f4\cgrid {\fs20 Converting DOUBLE to SINGLE}{\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\tc {\v\fs20 Converting DOUBLE to SINGLE\tcl5}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DOUBLE}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SINGLE}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Converting a DOUBLE value to a SINGLE value results in a loss of precision in the number, which drops from about 16 decimal digits to about 7 decimal digits. In some cases, this loss is completely transparent. Both formats can represent the number 4.5 with complete accuracy, so converting the DOUBLE value 4.5 to the SINGLE value 4.5 doesn\rquote t loose any accuracy at all. On the other hand, converting the DOUBLE value 4.500000001 to SINGLE will result in the number 4.5.\par DOUBLE values also support a larger exponent range than SINGLE values. The exponent range for SINGLE is about 1E-38 to 1E38. If the DOUBLE number is too close to zero to represent with the smallest available SINGLE exponent, the result is 0.0. If the DOUBLE value is too large to represent with the largest available SINGLE exponent, the result is infinity or negative infinity, which prints as inf and -inf, respectively.\par }\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \f4\cgrid {\fs20 Converting DOUBLE to LONG}{\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\tc {\v\fs20 Converting DOUBLE to LONG\tcl5}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DOUBLE}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LONG}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The value is first converted to an integer by rounding down to the largest integer that is less than or equal to the original value. Some typical values are:\par }\pard\plain \s32\li360\ri5580\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tqr\tx2340\adjustright \f4\cgrid {\fs20 DOUBLE\tab LONG\par }\pard\plain \s25\li360\ri5580\sb40\keepn\widctlpar\tqr\tx2340\adjustright \f4\cgrid {\fs20 -100.6\tab -101\par -99.2\tab -100\par -0.1\tab -1\par 0.1\tab 0\par 3.3\tab 3\par }\pard \s25\li360\ri5580\sb40\widctlpar\tqr\tx2340\adjustright {\fs20 3.99\tab 3\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par The maximum range for LONG values is -2147483648 to 2147483647. After truncating, if the double value is outside this range, the program stops with a run time error.\par }\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \f4\cgrid {\fs20 Converting DOUBLE to INTEGER}{\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\tc {\v\fs20 Converting DOUBLE to INTEGER\tcl5}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DOUBLE}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 INTEGER}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The rules for converting DOUBLE to INTEGER are essentially the same as for converting DOUBLE to LONG. The only difference is that INTEGER values have a smaller range than LONG values, so overflows that result in a run time error can occur with numbers that are valid for LONG. The valid range for INTEGER values is -32768 to 32767; if the truncated DOUBLE value is outside this range, a run time error stops the program.\par }\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \f4\cgrid {\fs20 Converting SINGLE to DOUBLE}{\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\tc {\v\fs20 Converting SINGLE to DOUBLE\tcl5}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SINGLE}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DOUBLE}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Converting SINGLE to DOUBLE always works, and there is no loss of precision.\par }\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \f4\cgrid {\fs20 Converting SINGLE to LONG}{\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\tc {\v\fs20 Converting SINGLE to LONG\tcl5}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SINGLE}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LONG}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Converting a SINGLE value to a LONG value follows the same rules as converting a DOUBLE value to a LONG value.\par }\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \f4\cgrid {\fs20 Converting SINGLE to INTEGER}{\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\tc {\v\fs20 Converting SINGLE to INTEGER\tcl5}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SINGLE}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 INTEGER}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Converting a SINGLE value to an INTEGER value follows the same rules as converting a DOUBLE value to an INTEGER value.\par }\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \f4\cgrid {\fs20 Converting LONG to DOUBLE}{\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\tc {\v\fs20 Converting LONG to DOUBLE\tcl5}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LONG}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DOUBLE}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 All LONG values can be represented with no loss of precision by a DOUBLE value. The conversion always works, with no possible error or loss of precision.\par }\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \f4\cgrid {\fs20 Converting LONG to SINGLE}{\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\tc {\v\fs20 Converting LONG to SINGLE\tcl5}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LONG}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SINGLE}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Converting a LONG value to a SINGLE value always works, with no possibility of an error, but there can be a loss of precision. The mantissa}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 mantissa}}}{\fs20  of a SINGLE value uses 24 bits, which gives about 7 significant decimal digits. LONG values larger than 16777216 or smaller than -16777216 cannot be stored without loss of precision in a SINGLE value. The least significant bits are lost.\par If you decide to verify this range, be sure to convert the SINGLE value back to LONG before printing it. Only the first seven significant digits of SINGLE values are normally printed, and you need to see eight digits to verify there was no loss of precision.\par }\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \f4\cgrid {\fs20 Converting LONG to INTEGER}{\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\tc {\v\fs20 Converting LONG to INTEGER\tcl5}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LONG}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 INTEGER}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Converting a LONG value to an INTEGER value works for any value in the range -32768 to 32767. A LONG value outside this range triggers a run time error.\par }\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \f4\cgrid {\fs20 Converting INTEGER to DOUBLE}{\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\tc {\v\fs20 Converting INTEGER to DOUBLE\tcl5}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 INTEGER}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DOUBLE}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 All INTEGER values can be represented with no loss of precision by a DOUBLE value. The conversion always works, with no possible error or loss of precision.\par }\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \f4\cgrid {\fs20 Converting INTEGER to SINGLE}{\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\tc {\v\fs20 Converting INTEGER to SINGLE\tcl5}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 INTEGER}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SINGLE}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 All INTEGER values can be represented with no loss of precision by a SINGLE value. The conversion always works, with no possible error or loss of precision.\par }\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \f4\cgrid {\fs20 Converting INTEGER to LONG}{\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\tc {\v\fs20 Converting INTEGER to LONG\tcl5}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 INTEGER}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LONG}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 All INTEGER values can be represented with no loss of precision by a LONG value. The conversion always works, with no possible error or loss of precision.\par }\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \f4\cgrid {\fs20 Converting BYTE to Any Other Type}{\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\tc {\v\fs20 Converting BYTE to Any Other Type\tcl5}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 BYTE}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 BYTE values are always converted to INTEGER values before any operation is performed. The result is always an integer in the range 0 to 255.\par }\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \f4\cgrid {\fs20 Converting Any Other Type to BYTE}{\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 BYTE}}}{\pard\plain \s35\sb260\sa140\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\tc {\v\fs20 Converting Any Other Type to .i.BYTE\tcl5}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Conversion of any value to a BYTE always starts by converting the value to an INTEGER. If the original value is outside the range -32768 to 32767, the conversion triggers a run time error.\par Once the value has been reduced to an INTEGER, the least significant 8 bits of the two\rquote s complement integer value are used. If the value is in the range 0 to 255, the result is exact. If the value is outside that range, the result seems strange unless you are familiar with the way integers are stored. If you would like to explore how integers are stored, refer to any assembly language programming book, or any general computer science text that discusses two\rquote s complement notation.\par For positive numbers the value that results is the same as you would get from the expression\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 I% - 256 * INT (I% / 256)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 For negative numbers the value is the same as the result of this expression:\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 65536 + I% - 256 * INT ((65536 + I%) / 256)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\*\bkmkend bk20}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 unary conversions}{\rxe bk20}}}{\v\fs20 \par {\*\bkmkend bk21}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 conversions\:unary}{\rxe bk21}}}{\v\fs20 \par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Addition}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Addition\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The symbol for addition}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 addition}}}{\fs20  is +}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 +}}}{\fs20 .\par Addition works on both numbers and strings, and can be used in one way with pointers. String and pointer addition are discussed later in this section.\par When you add two numbers, the addition operation returns the sum of the two numbers. For example, 1 + 1 returns 2.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 INTEGER}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 floating-point}}}{\fs20 If you are adding integers, and the result is larger than 32767 or smaller than -32768, the result cannot be an integer value. GSoft\~BASIC quietly detects the overflow}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 overflow}}}{\fs20  and converts the result to a SINGLE number. For example, 30 + 30 returns the integer 60, but 30000 + 30000 returns the floating-point number 60000.0. The same thing happens with LONG}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LONG}}}{\fs20  values, although the range is somewhat larger. LONG values can range from -2147483648 to 2147483647. If the result of an addition of long integers falls outside this range, the values are quietly converted to DOUBLE.\par SINGLE}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SINGLE}}}{\fs20  and DOUBLE}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DOUBLE}}}{\fs20  values can overflow, too. If the result of an addition is too close to zero to represent, the value returned will be 0.0. If the value is too large or too small to represent, the result will be infinity or negative infinity. Infinity prints as inf. All of the various math operations in GSoft\~BASIC know how to handle infinity in a reasonable way. Adding infinity}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 infinity}}}{\fs20  to any other value except negative infinity gives infinity, and adding negative infinity to any value except positive infinity gives negative infinity. Adding infinity to negative infinity results in a value called \ldblquote not a number,\rdblquote  which prints as NaN}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 NaN}}}{\fs20 . This is handled reasonably, too. NaN added to any other value still returns NaN.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 strings\:concatenation}}}{\fs20 Addition also works on strings. When you add two strings, the second is tacked onto the end of the first. For example,\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PRINT "Hello, " + "world."\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 prints the string \ldblquote Hello, world.\rdblquote \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 pointers\:math}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 floating-point}}}{\fs20 Addition works on pointers, but in a limited way. You can add an integer value to a pointer, but you cannot add two pointers, nor can you add a pointer to an integer. Floating-point values can be used instead of integers; they will be converted to an integer by truncating before the addition takes place.\par Adding an integer to a pointer causes the pointer to point a specific number of items further in memory. For example, let\rquote s assume we are adding 1 to the integer pointer IP, and that IP originally points to the memory location 100000. Adding 1 to IP causes IP to point to the integer after the original integer. Since each integer requires two bytes of memory, IP + 1 will be an integer pointer that points to memory location 100002. Adding 4 to a SINGLE pointer that originally points to 100000 gives a SINGLE pointer that points to memory location 100016, four SINGLE values later in memory.\par Adding a negative value to a pointer is supported, too. It is treated like a pointer subtraction. See }{\i\fs20 Subtraction}{\fs20 , below, for a complete discussion.\par A classic example uses pointers to access the values in an array. This short program fills an array using pointer addition, then prints the values using standard array notation.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM IP AS POINTER TO INTEGER\par DIM A(10) AS INTEGER\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 IP = @A(0)\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 FOR I% = 0 TO 10\par   IP^ = I%\par   IP = IP + 1\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 FOR I% = 0 TO 10\par   PRINT A(I%)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Subtraction}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Subtraction\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The symbol for subtraction}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 subtraction}}}{\fs20  is -}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 -}}}{\fs20 .\par Subtraction works with numbers, and in a limited sense, with pointers. Pointers are discussed at the end of this section.\par When you subtract two numbers, the result is the number on the left minus the number on the right. For example, 4 - 10 returns -6.\par Just as with addition, overflow}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 overflow}}}{\fs20 s do not cause errors. If subtracting one INTEGER}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 INTEGER}}}{\fs20  from another results in a value that cannot be an INTEGER, the original numbers are converted to SINGLE and the operation is performed again. If two LONG}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LONG}}}{\fs20  values result in an overflow, the operation is performed again after the two numbers are converted to DOUBLE.\par Just as with addition, subtraction of SINGLE}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SINGLE}}}{\fs20  or DOUBLE}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DOUBLE}}}{\fs20  values that result in a number too close to zero to represent returns 0.0, while results too large or too small to represent return infinity}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 infinity}}}{\fs20  or negative infinity.\par The table below shows how infinity and NaN}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 NaN}}}{\fs20  behave for subtraction. NaN stands for \ldblquote not a number,\rdblquote  and indicates that the result of an operation is not a valid real number. \ldblquote Any value\rdblquote  refers to any number, including infinity or NaN, that is not listed explicitly in the table.\par \par }\pard\plain \s32\li360\ri3780\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx1620\tx2880\adjustright \f4\cgrid {\fs20 This\u8230\'c9\tab minus this\u8230\'c9\tab gives this\u8230\'c9\par }\pard\plain \s25\li360\ri3780\sb40\keepn\widctlpar\tx1620\tx2880\adjustright \f4\cgrid {\fs20 NaN\tab any value\tab NaN\par any value\tab NaN\tab NaN\par inf\tab inf\tab NaN\par -inf\tab inf\tab -inf\par inf\tab -inf\tab inf\par -inf\tab -inf\tab NaN\par inf\tab any value\tab inf\par any value\tab inf\tab -inf\par -inf\tab any value\tab -inf\par }\pard \s25\li360\ri3780\sb40\widctlpar\tx1620\tx2880\adjustright {\fs20 any value\tab -inf\tab inf\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 pointers\:math}}}{\fs20 Subtraction works on pointers, but in a limited way. You can subtract an integer value from a pointer, but you cannot subtract two pointers, nor can you subtract a pointer from an integer. Floating-point values can be used instead of integers; they will be converted to an integer by truncating before the subtraction takes place.\par Subtracting an integer from a pointer causes the pointer to point to a specific number of items earlier in memory. For example, let\rquote s assume we are subtracting 1 from the integer pointer IP, and that IP originally points to the memory location 100000. Subtracting 1 from IP causes IP to point to the integer before the original integer. Since each integer requires two bytes of memory, IP - 1 will be an integer pointer that points to memory location 99998. Subtracting 4 from a SINGLE pointer that originally points to 100000 gives a SINGLE pointer that points to memory location 99984, four SINGLE values earlier in memory.\par Subtracting a negative value from a pointer is supported, too. It is treated like a pointer addition. See }{\i\fs20 Addition}{\fs20 , above, for a complete discussion.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Multiplication}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Multiplication\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The symbol for multiplication}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 multiplication}}}{\fs20  is *}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 *}}}{\fs20 .\par Multiplying two numbers returns their product. For example, 4 * 5 returns 20.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 overflow}}}{\fs20 If the product of two INTEGER}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 INTEGER}}}{\fs20  numbers is outside the range -32768 to 32767, the values are converted to SINGLE before the multiplication is performed, and the result is SINGLE. If the product of two LONG}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LONG}}}{\fs20  numbers is outside the range -2147483648 to 2147483647, the values are converted to DOUBLE before the multiplication is performed, and the result is DOUBLE.\par If the product of two SINGLE}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SINGLE}}}{\fs20  or two DOUBLE}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DOUBLE}}}{\fs20  values is too close to zero to represent, the result is 0.0. If the values are too large or too small to represent, the result is infinity}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 infinity}}}{\fs20  or negative infinity. These print as inf and -inf.\par The table below shows how infinity and NaN}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 NaN}}}{\fs20  behave for multiplication. NaN stands for \ldblquote not a number,\rdblquote  and indicates that the result of an operation is not a valid real number. \ldblquote Any value\rdblquote  refers to any number, including infinity or NaN, that is not listed explicitly in the table.\par }\pard\plain \s32\li360\ri2160\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx2160\tx3960\adjustright \f4\cgrid {\fs20 This\u8230\'c9\tab times this\u8230\'c9\tab gives this\u8230\'c9\par }\pard\plain \s25\li360\ri2160\sb40\keepn\widctlpar\tx2160\tx3960\adjustright \f4\cgrid {\fs20 NaN\tab any value\tab NaN\par any value\tab NaN\tab NaN\par inf\tab any positive value\tab inf\par inf\tab any negative value\tab -inf\par inf\tab 0\tab NaN\par any positive value\tab inf\tab inf\par any negative value\tab inf\tab -inf\par 0\tab inf\tab NaN\par -inf\tab any positive value\tab -inf\par -inf\tab any negative value\tab inf\par -inf\tab 0\tab NaN\par any positive value\tab -inf\tab -inf\par any negative value\tab -inf\tab inf\par }\pard \s25\li360\ri2160\sb40\widctlpar\tx2160\tx3960\adjustright {\fs20 0\tab -inf\tab NaN\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Division}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Division\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The symbol for division}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 division}}}{\fs20  is /}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 /}}}{\fs20 .\par Division divides the number to the left of the operator by the number to the right. For example, 4.8 / 1.5 returns 3.2.\par Division always returns a SINGLE or DOUBLE value. After binary conversions, if the operands are INTEGER}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 INTEGER}}}{\fs20  or LONG}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LONG}}}{\fs20 , the values are converted to SINGLE and the result is SINGLE.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 overflow}}}{\fs20 If the result is too close to zero to represent, the result is 0.0. If the values are too large or too small to represent, the result is infinity}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 infinity}}}{\fs20  or negative infinity. These print as inf and -inf.\par The table below shows how infinity and NaN}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 NaN}}}{\fs20  behave for division. NaN stands for \ldblquote not a number,\rdblquote  and indicates that the result of an operation is not a valid real number. \ldblquote Any value\rdblquote  refers to any number, including infinity or NaN, that is not listed explicitly in the table.\par }\pard\plain \s32\li360\ri2160\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx2160\tx3960\adjustright \f4\cgrid {\fs20 This\u8230\'c9\tab divided by this\u8230\'c9\tab gives this\u8230\'c9\par }\pard\plain \s25\li360\ri2160\sb40\keepn\widctlpar\tx2160\tx3960\adjustright \f4\cgrid {\fs20 NaN\tab any value\tab NaN\par any value\tab NaN\tab NaN\par any positive value\tab 0\tab inf\par any negative value\tab 0\tab -inf\par inf\tab any positive value\tab inf\par inf\tab any negative value\tab -inf\par -inf\tab any positive value\tab -inf\par -inf\tab any negative value\tab inf\par any value\tab inf\tab 0.0\par any value\tab -inf\tab 0.0\par }\pard \s25\li360\ri2160\sb40\widctlpar\tx2160\tx3960\adjustright {\fs20 inf (+ or -)\tab inf (+ or -)\tab NaN\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Exponentiation}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Exponentiation\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 power\:see exponent}{\txe }}}{\fs20 The symbol for exponentiation}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 exponentiation}}}{\fs20  is the carrot character, ^}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ^}}}{\fs20 .\par Exponentiation raises the number to the left of the operator to the power of the number to the right. For example, 3 ^ 4 is 3 * 3 * 3 * 3, or 81.\par Exponentiation always returns a SINGLE or DOUBLE value. After binary conversions, if the operands are INTEGER}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 INTEGER}}}{\fs20  or LONG}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LONG}}}{\fs20 , the values are converted to SINGLE and the result is SINGLE.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 overflow}}}{\fs20 If the result is too close to zero to represent, the result is 0.0. If the values are too large or too small to represent, the result is infinity}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 infinity}}}{\fs20  or negative infinity. These print as inf and -inf.\par While it is mathematically valid for integer powers, the exponentiation operator in GSoft\~BASIC will not raise a negative number to any power. Raising a negative number to any power always results in NaN}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 NaN}}}{\fs20  (not a number), which indicates that the result of an operation is not a valid real number. The reason for this restriction has to do with the way exponentiation is implemented for floating-point numbers. The exponentiation operation a ^ b is equivalent to EXP (B * LOG ( A )).\par The table below shows how infinity and NaN behave for exponentiation. \ldblquote Any value\rdblquote  refers to any number, including infinity or NaN, that is not listed explicitly in the table.\par }\pard\plain \s32\li360\ri2160\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx2160\tx3960\adjustright \f4\cgrid {\fs20 This\u8230\'c9\tab raised to the power\u8230\'c9\tab gives this\u8230\'c9\par }\pard\plain \s25\li360\ri2160\sb40\keepn\widctlpar\tx2160\tx3960\adjustright \f4\cgrid {\fs20 NaN\tab any value\tab NaN\par any value\tab NaN\tab NaN\par any negative value\tab any value\tab NaN\par inf (+ or -)\tab any value\tab NaN\par any value\tab inf\tab inf\par }\pard \s25\li360\ri2160\sb40\widctlpar\tx2160\tx3960\adjustright {\fs20 any value\tab -inf\tab 0.0\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 AND}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 AND\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 logical AND}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The AND}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 AND}}}{\fs20  operator logically combines two arguments, returning false (an INTEGER 0) if either of the arguments is 0, and true (an INTEGER 1) if both of the arguments are not zero. Both infinity}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 infinity}}}{\fs20  and NaN}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 NaN}}}{\fs20  (not a number, indicating a result that is not a valid number) are treated as true.\par AND is generally used with other logical arguments. For example, to check to see if the value A lies between LOW and HIGH, you could use the test\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 IF LOW < A AND A < HIGH THEN CALL PROCESS(A)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 This condition first tests to see if LOW is less than A, then checks to see if A is less than HIGH. If both conditions are true, AND returns true and the subroutine PROCESS is called. If either condition is not true, AND returns false, and subroutine PROCESS is not called.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 OR}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 OR\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 logical OR}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The OR}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 OR}}}{\fs20  operator logically combines two arguments, returning false (an INTEGER 0) if both of the arguments are 0, and true (an INTEGER 1) if either of the arguments are not zero. Both infinity}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 infinity}}}{\fs20  and NaN}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 NaN}}}{\fs20  (not a number, indicating a result that is not a valid number) are treated as true.\par OR is generally used with other logical arguments. For example, to check to see if a character is either an uppercase or lowercase alphabetic character, you could use this test:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 A$ = LEFT$(LINE$, 1, 1)\par IF A$ >= "A" AND A$ <= "Z" OR A$ >= "a" AND A$ <= "z" THEN\par   GETWORD(LINE$)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END IF\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 This condition first tests to see if A$ is an uppercase character (A$ >= "A" AND A$ <= "Z"), then checks to see if A$ is a lowercase letter (A$ >= "a" AND A$ <= "z"). If either of these tests is true, the result of the OR operation is true, and GETWORD is executed. If both conditions are false, the first letter of LINE$ is not an alphabetic character, and GETWORD is not called.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Comparison Operators}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Comparison Operators\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 comparison operators}}}{\fs20 Comparison operators are used to compare two values. They return true (an INTEGER 1) if the comparison is true, and false (an INTEGER 0) if the comparison is not true. You can compare numbers, pointers or strings.\par For example, 4.9 < 5 is true, so the result is an integer 1. \ldblquote Fred\rdblquote  >= \ldblquote Sam\rdblquote  is not true, so the result is an integer 0.\par There are six comparison operators. The symbol, what the operation does, some examples and the result of the compare are shown in the table below.\par }\pard\plain \s32\li360\ri2520\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx1440\tx3240\tx4680\adjustright \f4\cgrid {\fs20 Symbol\tab Operation\tab Example\tab Result\par }\pard\plain \s25\li360\ri2520\sb40\keepn\widctlpar\tx1440\tx3240\tx4680\adjustright \f4\cgrid {\fs20 <}{\pard\plain \s25\li360\ri2520\sb40\keepn\widctlpar\tx1440\tx3240\tx4680\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 <}}}{\fs20 \tab less than}{\pard\plain \s25\li360\ri2520\sb40\keepn\widctlpar\tx1440\tx3240\tx4680\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 less than}}}{\fs20 \tab -3 < 6\tab 1\par \tab \tab 6.1 < 6.1\tab 0\par \tab \tab 9 < 6\tab 0\par <=}{\pard\plain \s25\li360\ri2520\sb40\keepn\widctlpar\tx1440\tx3240\tx4680\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 <=}}}{\fs20 \tab less than or equal}{\pard\plain \s25\li360\ri2520\sb40\keepn\widctlpar\tx1440\tx3240\tx4680\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 less than or equal}}}{\fs20 \tab -4 <= 4\tab 1\par \tab \tab 7 <= 7\tab 1\par \tab \tab 43 <= 16\tab 0\par >}{\pard\plain \s25\li360\ri2520\sb40\keepn\widctlpar\tx1440\tx3240\tx4680\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 >}}}{\fs20 \tab greater than}{\pard\plain \s25\li360\ri2520\sb40\keepn\widctlpar\tx1440\tx3240\tx4680\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 greater than}}}{\fs20 \tab 2 > 7\tab 0\par \tab \tab -10 > -10\tab 0\par \tab \tab -10 > -20\tab 1\par >=}{\pard\plain \s25\li360\ri2520\sb40\keepn\widctlpar\tx1440\tx3240\tx4680\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 >=}}}{\fs20 \tab greater than or equal}{\pard\plain \s25\li360\ri2520\sb40\keepn\widctlpar\tx1440\tx3240\tx4680\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 greater than or equal}}}{\fs20 \tab 2 >= 8\tab 0\par \tab \tab 3.14 >= 3.14\tab 1\par \tab \tab 6.1 >= 6.0\tab 1\par =}{\pard\plain \s25\li360\ri2520\sb40\keepn\widctlpar\tx1440\tx3240\tx4680\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 =}}}{\fs20 \tab equal}{\pard\plain \s25\li360\ri2520\sb40\keepn\widctlpar\tx1440\tx3240\tx4680\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 equal}}}{\fs20 \tab 9 = 9\tab 1\par \tab \tab 9 = -9\tab 0\par <>}{\pard\plain \s25\li360\ri2520\sb40\keepn\widctlpar\tx1440\tx3240\tx4680\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 <>}}}{\fs20 \tab not equal}{\pard\plain \s25\li360\ri2520\sb40\keepn\widctlpar\tx1440\tx3240\tx4680\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 not equal}}}{\fs20 \tab 3 <> 3\tab 0\par }\pard \s25\li360\ri2520\sb40\widctlpar\tx1440\tx3240\tx4680\adjustright {\fs20 \tab \tab 4 <> 3\tab 1\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par Some BASICs allow the multi-character comparison operators with the characters in any order. For example, >< is allowed instead of <>. Spaces are also allowed between the characters. GSoft\~BASIC supports these conventions, but you should generally use the standard form for the operations shown in the table.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 strings}}}{\fs20 Numbers are compared using normal rules for arithmetic. Strings, on the other hand, are compared more or less by alphabetical order. For example, \ldblquote Fred\rdblquote  is less than \ldblquote Sam\rdblquote . There are some surprises, though, because the characters are compared using their ASCII character}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ASCII character set}}}{\fs20  orders. Uppercase letters are always less than lowercase letters, so \ldblquote fred\rdblquote  is greater than \ldblquote Sam\rdblquote . The ASCII character chart also includes characters other than alphabetical characters. The ASCII character chart is shown in Appendix C.\par If the first letter of a string matches, the compare continues with the next letter. For example, \ldblquote Sam\rdblquote  is less than \ldblquote Susan\rdblquote . If all of the characters match, but the strings have different lengths, the longer string is greater than the shorter string. This means that \ldblquote Fred\rdblquote  is less than \ldblquote Frederick\rdblquote .\par Of course, if all of the characters match and the strings are the same length, the strings are equal.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 pointers\:comparing}}}{\fs20 Pointers are compared by comparing their relative locations in memory. An accurate way of thinking of pointer compares is to think of comparing P1 and P2 as a two step process: first, the pointers are converted to long integers, then the resulting integers are compared. For example,\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 IF P1 < P2 THEN\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 behaves exactly like\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 IF CLNG(P1) < CLNG(P2) THEN\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Terms}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Terms\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 {\*\bkmkstart bk23}The first part of this chapter dealt with expressions from the standpoint of traditional mathematical operations like addition, comparisons, and parentheses}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parentheses}}}{\fs20 , just as these operations are generally used in algebra. In algebra, these operations use numbers or variables as arguments. For example,\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 4 + Y\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 is a perfectly reasonable statement in algebra, and it\rquote s perfectly acceptable in BASIC, too.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 In BASIC, the numbers that are used by the mathematical operations covered earlier in this chapter are called terms, and they can be many things besides just numbers or variables. In each case, though, the term is fully evaluated, giving a resultant number or string, before any of the operations discussed earlier is performed.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Constants}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Constants\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 constants}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Constants include numbers and strings. Numbers can be integers, long integers, single-precision floating-point or double-precision floating-point. Integers and long integers can be written in either standard decimal form or using hexadecimal notation.\par Chapter 7 describes the format and limitations for numeric and string constants.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Unary Math Operations}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Unary Math Operations\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 You can use a -}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 -}}}{\fs20  operation before any term. This operation doesn\rquote t require a number to the left. In affect, the BASIC term\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 -V\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 works as if you typed\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 0 - V\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par When it is used this way, the - operation is technically referred to as unary subtraction}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 unary subtraction}}}{\v\fs20 subtraction:unary;}{\fs20  to distinguish it from the similar subtraction operator.\par You\rquote ll generally use this operation to indicate a negative constant or to change the sign of a variable, as in\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 X = -4\par Y = -X\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 but it\rquote s perfectly legal to use the operation in the middle of an expression. For example, it is legal to write\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 Z = X - -4\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 The effect is exactly the same as\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 Z = X + 4\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par Eliminating the extra operation by using + rather than two - operators saves a small amount of space and time. Still, there are rare cases where the program makes more sense if the natural operations are left in place, and if clarity is more important than a byte of space and a little speed, it might make sense to use the unary subtraction operator in the middle of an expression.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 unary addition}}}{\v\fs20 addition:unary;}{\fs20 There is also a unary operation for +}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 +}}}{\fs20 . It rarely makes sense to use it in a program, since it doesn\rquote t actually do anything but occupy space and time.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 NOT}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 NOT\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 logical NOT}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 NOT}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 NOT}}}{\fs20  is the unary negation}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 unary negation}}}{\fs20  operation for logical values. BASIC uses numbers for logical values, assigning false the value of 0 and treating any number other than 0 as true. The NOT operation returns true if its operand is false, and false if the operand is true. From a strictly mathematical standpoint, NOT returns the INTEGER 0 if the operand is nonzero, and it returns the INTEGER 1 if the operand is zero.\par In practice, NOT is usually used with logical operations or variables used to store logical values. A common example uses a variable DONE% to indicate if a loop has completed its work. The loop continues until DONE% is true.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DONE% = 0\par WHILE NOT DONE%\par   HANDLEEVENT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 WEND\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Array Subscripts}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Array Subscripts\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 arrays\:subscripts}}}{\fs20 Elements of an array are selected by enclosing the array subscripts in parentheses}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parentheses}}}{\fs20  after the array name. The subscripts are expressions, and can contain functions and other array elements. In all cases, the subscripts are evaluated first, in left to right order, then the corresponding element of the array is extracted.\par If an array has more than one subscript, the subscripts are separated by commas.\par Here is an example of arrays in an expression that computes the length of a multidimensional vector.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 LENGTH = 0.0;\par FOR I% = 1 TO DIMENSIONS\par   LENGTH = LENGTH + VECTOR(I%)*VECTOR(I%)\par NEXT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 LENGTH = SQR(LENGTH)\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Using BASIC Functions}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Using BASIC Functions\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 functions\:built in}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 built in functions}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 functions\:see also FUNCTION statement}{\txe }}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 functions\:see also tools}{\txe }}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 functions\:see also DEF FN}{\txe }}}{\fs20 BASIC has many built in functions. These functions return either a number or string. Most of the functions are described later in this chapter, broken down into sections based on whether they deal primarily with strings or numbers. The functions ERR and ERL, used in error handling, are described in Chapter 12.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parameters\:built-in functions}}}{\fs20 Most functions require one or more arguments, called parameters. For example, the SQR function returns the square root of another number. Taking the square root of 4 is written like this:\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 SQR (4)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 The parameter is 4.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 This entire sequence is a single term. The parameter is an expression, and it can include anything you see in any other expression, including calls to other BASIC functions. The parameters are evaluated first, then the function is called, and finally the value returned by the function is used in the expression.\par In some rare cases, the actual order in which the parameters are evaluated can affect the way the program operates. It\rquote s generally best to rethink the program so this doesn\rquote t happen. For the rare cases where it matters, GSoft\~BASIC evaluates parameters in left to right order.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Using FUNCTION Functions}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Using FUNCTION Functions\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Like most modern BASICs, GSoft\~BASIC supports multi-line functions. Chapter 17 tells how to create these functions, and gives examples of how they are used.\par Functions defined with the FUNCTION statement}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 FUNCTION statement}}}{\fs20  behave just like built in BASIC functions in an expression.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Using DEF FN Functions}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Using DEF FN Functions\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 FN\:see DEF FN}{\txe }}}{\fs20 DEF FN}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DEF FN statement}}}{\fs20  functions are a simple way to create a function that only requires one line. Chapter 17 describes creation of DEF FN functions, and gives examples of how they are used.\par In an expression, a DEF FN function looks almost like a built in BASIC function. The big difference is that the name is preceded by FN. For example, if you create a DEF FN function called LENGTH to return the length of a line, an expression that uses the function might look like this:\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 L = FN LENGTH (X, Y)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par As with built-in BASIC functions, DEF FN functions are treated as a single term. }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parameters\:DEF FN}}}{\fs20 The parameters are evaluated first in left to right order, then the function is evaluated, and finally the returned value is used in the expression.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 The Address Operator}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 The Address Operator\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The symbol for the address operator}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 address operator}}}{\fs20  is @}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 @}}}{\fs20 .\par The address operator returns a pointer to a storage location. This pointer is generally used to set the value of a pointer. For example, if you need to use a pointer to index into an array, you could set a pointer to point to the first entry of the array using the address operator like this:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM IP AS POINTER TO INTEGER\par DIM A(20) AS INTEGER\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 IP = @A(0)\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 FOR I% = 0 TO 20\par   IP^ = I%\par   IP = IP + 1\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 FOR I% = 20 TO 0 STEP -1\par   PRINT A(I%)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par The variable storage location can be any l-value. Loosely, an l-value is any term that you could assign a value to. L-values are described in detail later in this chapter.\par The type for the pointer is \ldblquote POINTER TO type,\rdblquote  where type is the type of the value whose address is taken. In the example above, the type of the pointer returned by @A(0) is POINTER TO INTEGER. This value could be assigned to any pointer to an integer, but not to pointers to other types. For example, the following code is not legal.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM IP AS POINTER TO INTEGER\par DIM A(3) AS SINGLE\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 IP = @A(3) : REM This is an illegal operation.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Type Casting}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Type Casting\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 {\*\bkmkstart bk22}There are some situations, particularly when dealing with pointers to toolbox records, where the type of the pointer returned by the address operator}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 address operator}}}{\fs20  or stored in some variable doesn\rquote t match the type of the pointer needed, yet the value is still the one needed. Type casting is used in this case. A type cast looks like a function call, but the name that appears where the function name would be is the name of a type, and the function argument is a pointer value. The value returned is a pointer to the same memory location, but with the new type. Putting this to work with the example from the address operator, you could turn the illegal assignment into a legal one like this:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TYPE IPTR AS POINTER TO INTEGER\par DIM IP AS IPTR\par DIM A(3) AS SINGLE\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 IP = IPTR(@A(0))\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 floating-point}}}{\fs20 Type casting can also be used to convert numbers to pointers. Floating-point values are truncated to yield a long integer result, and integer values are extended to long integer values. The result is treated as a pointer. A classic example is accessing the keyboard}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 keyboard}}}{\fs20 . Rather than using PEEK and POKE statements, you can read the Apple\~II}{\fs18 GS}{\fs20  keyboard using pointers like this:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\pard\plain \s31\fi360\keepn\widctlpar\adjustright \v\f6\fs18\cgrid {\xe {\v\fs18 }{\v\fs18 samples\:Keyboard}}}{\fs18 PRINT KEY\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 FUNCTION KEY AS STRING\par TYPE BYTEPTR AS POINTER TO BYTE\par DIM KEYBOARD AS BYTEPTR\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 DIM STROBE AS BYTEPTR\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 KEYBOARD = BYTEPTR($00C000)\par STROBE = BYTEPTR($00C010)\par WHILE KEYBOARD^ < 128\par   ! Wait for a keypress\par WEND\par KEY = CHR$ (KEYBOARD^ - 128)\par STROBE^ = 0\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END FUNCTION\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par Type casting is only supported for converting numeric values to pointers and for converting one pointer type to another pointer type. See CLNG for a way to convert a pointer to a number.\par {\*\bkmkend bk22}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 type casting}{\rxe bk22}}}{\v\fs20 \par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Dereferencing Pointers}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Dereferencing Pointers\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 pointers\:dereferencing}}}{\fs20 In most cases, when a pointer is used in an expression, it\rquote s not the pointer value that\rquote s needed, but the value the pointer points to. To get the value of the pointer, use the name of the pointer. To get the value the pointer points to, use the name of the pointer followed by the ^}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ^}}}{\fs20  character.\par For example, to assign the address of a value to a pointer, you want to change the pointer itself. In this case, you use the pointer name without the ^ character. To change the value the pointer points to, the ^ character is added, as this short example shows.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM IP AS POINTER TO INTEGER\par IP = @I%\par IP^ = 4\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PRINT I%\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Accessing Record Fields}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Accessing Record Fields\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 records}}}{\fs20 The .}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 .}}}{\fs20  operator is used to extract a field}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 field}}}{\fs20  from a record. It appears after the name of the record, and before the name of the field.\par The field can be an array, pointer, or another record. In that case, the field is extracted from the record first, then the array subscript, pointer dereference, or subsequent field dereference is handled. The record itself can also be a pointer or an array. In that case, the array access or pointer dereference appears immediately after the record name, just before the . operator.\par Here are some examples of legal field accessing. These have no particular use; they are just intended to show how the pointer dereference operator is used in conjunction with array and pointer operators.\par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TYPE POINT3D\par   X\par   Y\par   Z\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END TYPE\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 TYPE CUBE\par   CORNER1 AS POINT3D\par   CORNER2 AS POINT3D\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END TYPE\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 TYPE PPTR AS POINTER TO POINT3D\par DIM P AS POINT3D\par DIM PP AS PPTR\par DIM POINTS(5) AS POINT3D\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 DIM C AS CUBE\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 P.X = 1.2\par PPTR = @P\par PPTR^.Y = PPTR^.X * 2.0\par P.Z = P.X * P.Y\par POINTS(0) = P\par POINTS(1).Y = POINTS(0).Y\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 C.CORNER1.X = 3.5\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\*\bkmkend bk23}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 term}{\rxe bk23}}}{\v\fs20 \par {\*\bkmkend bk24}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 expression}{\rxe bk24}}}{\v\fs20 \par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 L-Values}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 L-Values\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 {\*\bkmkstart bk25}In a few places in this manual, you will see a reference to something called an l-value. This is a rather descriptive term borrowed from the C language. It means any expression that can appear on the left side of an equal sign in a LET statement. In practice, it\rquote s any expression that gives the location of a value in memory.\par The remainder of this section gives a very technical description of just what is and is not an l-value. Whether you wade through this description to get a full understanding of l-values or not, keep in mind that the concept is simpler than the description. An l-value is any expression that gives a place where a value is stored in memory.\par L-Values are required for the location to store a value with a LET statement, for some kinds of parameters passed to subroutines and procedures, and as arguments for the address operator}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 address operator}}}{\fs20  (@}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 @}}}{\fs20 ).\par The simplest l-value is the name of a variable. Constants, such as 4.5, are not l-values. Think of it this way: you can store 7.1 in the variable X, but you can\rquote t store 7.1 in the number 4.5.\par Arrays are a series of l-values, and an element of an array is an l-value. For example, A(X) is an l-value.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 records}}}{\fs20 Fields in a record are l-values. For the record P in\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TYPE POINT\par   X AS SINGLE\par   Y AS SINGLE\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END TYPE\par DIM P AS POINT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 P.X is an l-value. So is P itself\emdash you can store one record into another, as long as they have the same record type.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Both a pointer and the value it points to are l-values. Building on the point record, PPTR in\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM PPTR AS POINTER TO POINT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 is an l-value; you can store a pointer value in a pointer.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 You can also build l-values from combinations of these operators. PPTR^.X is also an l-value, since both pointers and fields from a record are l-values.\par All other expression operations are not l-values. Even something as innocent as enclosing a value in parentheses, using a type cast, or putting a + operation in front of an l-value yields an expression that is not an l-value. For example,\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 LET +X% = 4 : ! Illegal!\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 is not a legal BASIC statement, since the expression to the left of the = operator in a LET statement must be an l-value.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\*\bkmkend bk25}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 l-values}{\rxe bk25}}}{\v\fs20 \par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 The Assignment Statement}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 The Assignment Statement\tcl2}}}{\fs28 \par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 [ LET ] l-value '=' expression\par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LET statement\bxe }}}{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 assignment statement}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The expression to the right of the = operation is evaluated and stored in the location given by the l-value.\par LET is optional, and is almost always omitted from BASIC programs. It has been part of the language since the original implementation, though, and has been kept by virtually every implementation so old programs will still work.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 floating-point}}}{\fs20 If the expression yields a number of any kind, and the l-value is a different kind of number, the number is converted to the proper type before it is stored. If the expression is a floating-point value and the l-value is an INTEGER or LONG value, the number is truncated to the largest integer that is less than or equal to the value of the expression. For example, after\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 I% = 3.9\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PRINT I%\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 prints 3.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 If you assign a value to an INTEGER or LONG that is too long for the variable, a math error is generated. For example,\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 R = 40000.0\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 I% = R\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 generates an error.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 If you assign a DOUBLE to a SINGLE, and the DOUBLE value is too large to be represented as a SINGLE, the result is infinity. The lines\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 D# = 1D40\par D = D#\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PRINT D#, D\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 prints\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 1.0000000E40     inf\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 records}}}{\fs20 In addition to simple numeric values, you can also assign strings, pointers and records. The types must match exactly, though. You can't assign a numeric value to any of these values, nor can you assign one to another.\par For example, while you can assign a string to another string, you cannot assign the number 4.5 to a string (or vice versa).\par For pointers and records, the type must match, too. To assign one pointer to another, both pointers must point to the same thing (or you must use a type cast). To assign one record to another, both records must be the same kind of record.\par The snippet shows a few examples that you can experiment with to see how this works.\par }\pard\plain \s33\sb120\sa40\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM P AS POINT, R AS POINT\par P.H = 3\par P.V = 6\par R = P\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PRINT R.H, R.V\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 S$ = "Hello, world."\par H$ = LEFT$(S$, 5)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PRINT H$\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 DIM SP AS POINTER TO STRING, SP2 AS POINTER TO STRING\par SP = @S$\par SP2 = SP\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PRINT SP2^\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Mathematical Functions}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Mathematical Functions\tcl2}}}{\fs28 \par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 {\*\bkmkstart bk28}{\*\bkmkstart bk29}ABS '(' expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 ABS\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ABS function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns the absolute value}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 absolute value}}}{\fs20  of the argument.\par The argument must be a numeric type. The type of the result is the same as the type of the argument. For example, if the argument is SINGLE, the result is SINGLE; if the argument is INTEGER, so is the result.\par The absolute value is the same as the argument if the argument is zero or positive, and the negative of the argument if the argument is negative. For example, ABS(4) is 4, and so is ABS(-4).\par The absolute value of negative infinity}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 infinity}}}{\fs20  is infinity. The absolute value of NaN}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 NaN}}}{\fs20  is NaN.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 ATN '(' expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 ATN\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ATN function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns the arc tangent}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 arc tangent}}}{\fs20  of the argument. The angle is returned in radians.\par If the argument is DOUBLE, the result is also DOUBLE. For SINGLE, LONG and INTEGER arguments, the result is SINGLE.\par The arc tangent is the number whose tangent is the same as the argument. For any particular argument, there are actually an infinite number of answers. For example, the tangent of \u960\'b9/4 (roughly 0.785398) is 1, so the arc tangent of 1.0 is approximately 0.785398. As with any angle, though, adding 2\u960\'b9 to the angle gives an equivalent angle.\par }\pard \s25\sb40\widctlpar\posxr\dxfrtext180\dfrmtxtx180\dfrmtxty180\adjustright {\fs20 {\pict{\*\picprop\shplid1036{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex100\picscaley100\piccropl0\piccropr0\piccropt0\piccropb0\picw158\pich87\picwgoal3160\pichgoal1740\macpict\bliptag-2084679599\blipupi72{\*\blipuid 83be5051fe7b95c89611ff91d33085f5}0112ffffffff0056009d1101a0008201000affffffff0056009d22000100530054200049000b0049009b60001c0026007700810037002371001e002800730033007d00280073002f007d0031007a00330078002800732200300079010122004900532cd4a10096000c01000000020000000000000001000a0008007b001800922c000900030647656e6576610300030d000c2e0004000001002b7c1404582c2059a00097a10096000c01000000020000000000000001000a002a0084003b008b2c000900170653796d626f6c0300172b09230171a00097a10096000c01000000020000000000000001000a001b0000002c004f2800280001017103000329060b203d2041544e28592f5829a00097a00083ff}}{\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The result of the ATN function is the angle between the X axis and a line from the origin and a point in the X-Y plane. The value of the argument is the Y coordinate of the point divided by the X coordinate.\par The ATN function always returns a result between 0.0 and \u960\'b9/2 for positive arguments, and 0.0 and -\u960\'b9/2 for negative values. It can\rquote t tell if a positive number should be a point where both X and Y are positive, or a reflected angle where both X and Y are negative. Both coordinates are needed to return a value from 0 to 2\u960\'b9; the code snippet does double duty by showing a function that returns the arc tangent over the entire range of angles from 0 to 2\u960\'b9, as well as showing the ATN function in action.\par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\pard\plain \s31\fi360\keepn\widctlpar\adjustright \v\f6\fs18\cgrid {\xe {\v\fs18 }{\v\fs18 samples\:ATN2}}}{\fs18 FUNCTION ATN2(X, Y) AS SINGLE\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PI = 3.1415927\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 IF X = 0 THEN\par   IF Y >= 0 THEN\par     ATN2 = PI / 2.0\par   ELSE\par     ATN2 = - PI / 2.0\par }\pard \s31\fi360\widctlpar\adjustright {\fs18   END IF\par ELSE\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18   A = ATN ( ABS (Y / X))\par   IF X >= 0 THEN\par     IF Y >= 0 THEN\par       ATN2 = A\par     ELSE\par       ATN2 = 2.0 * PI - A\par }\pard \s31\fi360\widctlpar\adjustright {\fs18     END IF\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18   ELSE\par     IF Y >= 0 THEN\par       ATN2 = PI - A\par     ELSE\par       ATN2 = PI + A\par     END IF\par }\pard \s31\fi360\widctlpar\adjustright {\fs18   END IF\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 END IF\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END FUNCTION\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CDBL '(' expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 CDBL\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CDBL function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Converts any numeric argument or pointer argument to a DOUBLE}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DOUBLE}}}{\fs20  value.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 floating-point}}}{\fs20 CDBL is generally used in an expression to force the calculation to be performed using double-precision floating-point operations. For example, if you are about to multiply two real values, and would like to maintain as many significant digits as possible, you could use CDBL to force one of the arguments to DOUBLE before doing the multiply, like this:\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PRODUCT# = CDBL(X) * Y\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 This gives a different result from the statement\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PRODUCT# = X * Y\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 Without CDBL, the calculation is performed using a single-precision multiply, truncating the result to approximately 7 significant decimal digits. This result is extended to a double-precision value. Using CDBL, X is extended to double-precision immediately. This also forces Y to double-precision\emdash see }{\i\fs20 Binary Conversions}{\fs20 , earlier in this chapter, for the complete explanation of why. The multiplication produces a result that has about 14 significant decimal digits.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 At first glance, it might seem like these extra digits have no meaning. In fact, there are many numerically sensitive algorithms that depend on exactly this kind of extra precision at just the right point in the calculation. And the extra digits are real in at least one sense\emdash computer based multiplication always doubles the number of significant digits, but these are generally discarded before you see the result.\par You don\rquote t need this function when assigning a value to a DOUBLE variable. Conversion between numeric types is generally automatic. CDBL is only needed for extraordinary situations like the one described, where the precision of a number must be changed within a calculation.\par CDBL can also be used to convert a pointer to an equivalent numeric value, but it generally isn't used this way. A round-off error converting the floating-point value back to a pointer could easily end up in a pointer value that is off by one byte from the expected value. In most cases, it makes more sense to use CLNG to convert a pointer to a number, and to use integer expressions to manipulate pointer values.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CINT '(' expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 CINT\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CINT function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Converts any numeric argument or pointer argument to an INTEGER}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 INTEGER}}}{\fs20  value.\par CINT is frequently used in calculations that will end up producing an integer, but use intermediate floating-point values. For example, to calculate a new position for a graph, you might use an equation like\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 H% = H1% + D * SIN(THETA)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 Using CINT, you can force the SINGLE result to an INTEGER value immediately, like this:\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 H% = H1% + CINT(D * SIN(THETA))\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 The result is the same, but integer addition is much faster than floating-point addition. Forcing the SINGLE value to an integer allows the use of the faster integer addition.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 When the argument is a floating-point number, CINT truncates the value to convert to an integer. The result is the largest integer that is less than or equal to the floating-point value. For example, CINT(4.6) gives 4, while CINT(-4.6) gives -5.\par Converting a number that is too large to an integer gives an error. The valid range for integers is -32768 to 32767.\par CINT can also be used to convert a pointer to an equivalent integer value, but it generally isn't used this way. Pointers can, and usually do, have values much larger than 32767, which is the largest value an integer can hold. In most cases, it makes more sense to use CLNG to convert a pointer to a number.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CLNG '(' expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 CLNG\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CLNG function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Converts any numeric argument or pointer argument to a LONG}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LONG}}}{\fs20  value.\par CLNG is sometimes used to convert INTEGER values to LONG, extending the precision of a calculation. You might do this to avoid the automatic conversion to SINGLE that occurs when an integer operation overflows. For example, in the expression\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 I = 30000\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 L& = I + I\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 you know the integer value will overflow. In this case, BASIC will try the integer operation first. When it overflows, both arguments will be converted to SINGLE, an operation that takes a great deal more computer time than a LONG addition, then a SINGLE addition is performed. The SINGLE addition takes still more time. Finally, the result is converted to a LONG, which takes even more time.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 It is vastly more efficient in terms of execution time to force the calculation to be performed as a LONG addition by converting both arguments to LONG right away. You can do this with CLNG:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 I = 30000\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 L& = CLNG(I) + I\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par CLNG can also be used to convert floating-point arguments to LONG for faster calculations that involve both LONG and floating-point values. See CINT for an example based on this idea.\par When the argument is a floating-point number, CLNG truncates the value to convert to an integer. The result is the largest integer that is less than or equal to the floating-point value. For example, CLNG(4.6) gives 4, while CLNG(-4.6) gives -5.\par Converting a number that is too large to fit into a long integer gives an error. The valid range for long integers is -2147483648 to 2147483647.\par CLNG is also used to convert pointers}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 pointers\:math}}}{\fs20  to numbers. A long value is large enough to hold any legal pointer value, so you can safely convert the pointer to a number, manipulate the number, and perhaps convert back to a pointer using a type cast.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 COS '(' expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 COS\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 COS function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns the cosine}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 cosine}}}{\fs20  of the argument. The argument is expressed in radians.\par If the argument is DOUBLE, the result is also DOUBLE. For SINGLE, LONG and INTEGER arguments, the result is SINGLE.\par The COS function is not accurate for very large angles. By very large angles, we mean angles larger than about 1300 radians for SINGLE arguments, and 2E8 radians for DOUBLE arguments, although the accuracy drops off gradually as the angle increases. For this reason, it is best to keep angles between -2\u960\'b9 and 2\u960\'b9 whenever possible. For very large arguments, COS always returns 0.0.\par Refer to any book that covers trigonometry for a discussion of the cosine.\par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 X = LENGTH * COS(THETA)\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CSNG '(' expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 CSNG\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CSNG function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Converts any numeric argument or pointer argument to a SINGLE}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SINGLE}}}{\fs20  value.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 floating-point}}}{\fs20 See CDBL and CINT for some thoughts on when this function might be useful. Keep in mind that SINGLE math operations take significantly less time than their DOUBLE counterparts, so reducing a DOUBLE value to SINGLE at an appropriate place in an equation can often speed a program up significantly, in some cases with little or no loss of precision.\par CSNG can also be used to convert a pointer to an equivalent numeric value, but it generally isn't used this way. A round-off error converting the floating-point value back to a pointer could easily end up in a pointer value that is off by one byte from the expected value. In most cases, it makes more sense to use CLNG to convert a pointer to a number, and to use integer expressions to manipulate pointer values.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 EXP '(' expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 EXP\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 EXP function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns the natural exponent}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 exponent}}}{\fs20  of the argument.\par If the argument is DOUBLE, the result is also DOUBLE. For SINGLE, LONG and INTEGER arguments, the result is SINGLE.\par The natural exponent is the result of raising e to a power. The number known as e is approximately 2.71828. The exponent is also the inverse of the natural logarithm, LOG. For values that are valid for both functions, EXP(LOG(X)) always returns X.\par The EXP function is frequently used to manipulate powers, such as interest rates. For example, if you earn 4% per year on a passbook savings account for 10 years, the value of your initial investment M is given by\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 V = M * EXP(10.0 * LOG(1.04))\par }\pard\plain \s33\sb120\sa40\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 FUNCTION POWER10 (X)\par ! Returns 10 raised to a power.\par POWER10 = EXP(X * LOG(10.0))\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END FUNCTION\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 INT '(' expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 'INT'\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 INT function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns the largest integer value that is less than or equal to the argument.\par For INTEGER and LONG arguments, INT returns the argument. The value returned is still an INTEGER for INTEGER arguments, and LONG for LONG arguments.\par For SINGLE and DOUBLE arguments, the value returned is still SINGLE or DOUBLE, but any fraction part is lost. The value returned is the largest integer that is less than or equal to the argument.\par The table shows some results for various floating-point arguments.\par }\pard\plain \s32\li360\ri5040\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tqr\tx2880\adjustright \f4\cgrid {\fs20 expression\tab result\par }\pard\plain \s31\li360\ri5040\keepn\widctlpar\tqr\tx2880\adjustright \f6\fs20\cgrid {\fs18 INT(5.4)\tab 5.0\par INT(3.99)\tab 3.0\par INT(-0.1)\tab -1.0\par }\pard \s31\li360\ri5040\widctlpar\tqr\tx2880\adjustright {\fs18 INT(-10.9)\tab -11.0\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 LOG '(' expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 LOG\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LOG function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns the natural logarithm}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 logarithm}}}{\fs20  of the argument.\par If the argument is DOUBLE, the result is also DOUBLE. For SINGLE, LONG and INTEGER arguments, the result is SINGLE.\par The natural logarithm}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 natural logarithm}}}{\fs20  is not defined for zero or negative arguments. If the argument is less than or equal to zero, LOG returns NaN.\par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 FUNCTION LOG10 (X)\par ! Returns the base 10 logarithm of X\par LOG10 = LOG (X) / LOG (10.0)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END FUNCTION\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 RND '(' expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 RND\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 RND function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 {\*\bkmkstart bk26}RND returns a pseudo-random number greater than or equal to zero and less than 1.0. The value returned is always SINGLE.\par While the rest of this discussion refers to the values RND returns as random numbers, they really aren\rquote t random. Pseudo-random numbers is the technical term that refers to functions like RND, which return sequences of numbers with no apparent pattern. Of course, there is a pattern\emdash but it\rquote s a pattern that can\rquote t be detected by a series of tests for randomness. The result is a series of numbers that can be used for tasks like shuffling a deck of cards, and that will produce results as good as shuffling by hand.\par Each time RND returns a value, the value is computed using a formula, and is based on the last value returned. The original value determines the sequence of numbers you get. This original value is called the seed. There is a way to specify the seed for RND, which we\rquote ll look at in a moment. In most cases, though, you should let RND pick its own seed. It bases the seed on the current date and time.\par There are three ways to call RND. If the argument is a positive value, RND returns a random number. Subsequent calls return other seemingly unrelated random numbers.\par If you call RND with an argument of zero, it returns the same value it returned on the previous call. This is a useful shortcut when you need to use the same random value in several places in an equation.\par If you call RND with a negative argument, the argument is used as a new seed for the random number generator. After producing a series of numbers, calling RND with the same negative argument will cause RND to regenerate the same sequence of numbers. This is a very useful feature when you are debugging a program that uses RND: By temporarily placing a line like\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 R = RND(-1.0)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 at the start of the program, it will always generate the same series of numbers, making bugs easier to reproduce.\par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 ! Print 10 random numbers\par FOR I = 1 TO 10\par   PRINT RND(1.0)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 ! Print 10 different random numbers based on our seed.\par PRINT RND(-1.0)\par FOR I = 1 TO 9\par   PRINT RND(1.0)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 ! Print the same 10 random numbers again.\par PRINT RND(-1.0)\par FOR I = 1 TO 9\par   PRINT RND(1.0)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\*\bkmkend bk26}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 random numbers}{\rxe bk26}}}{\v\fs20 \par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SGN '(' expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 SGN\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SGN function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns -1, 0 or 1, depending on the argument. If the argument is zero, SGN returns 0. If the argument is less than zero, SGN returns -1. If the argument is greater than zero, SGN returns 1.\par The type of the result is the same as the type of the argument. For example, if the argument is SINGLE, the result is SINGLE; if the argument is INTEGER, so is the result.\par }\pard\plain \s33\sb120\sa40\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 ! Jump to various spots based on the sign of the number\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 ON 2 + SGN(X) GOTO 10, 20, 30\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SIN '(' expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 SIN\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SIN function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns the sine}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 sine}}}{\fs20  of the argument. The argument is expressed in radians.\par If the argument is DOUBLE, the result is also DOUBLE. For SINGLE, LONG and INTEGER arguments, the result is SINGLE.\par The SIN function is not accurate for very large angles. By very large angles, we mean angles larger than about 1300 radians for SINGLE arguments, and 2E8 radians for DOUBLE arguments, although the accuracy drops off gradually as the angle increases. For this reason, it is best to keep angles between -2\u960\'b9 and 2\u960\'b9 whenever possible. For very large arguments, SIN always returns 0.0.\par Refer to any book that covers trigonometry for a discussion of the sine.\par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 Y = LENGTH * SIN(THETA)\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SQR '(' expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 SQR\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SQR function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns the square root}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 square root}}}{\fs20  of the argument.\par If the argument is DOUBLE, the result is also DOUBLE. For SINGLE, LONG and INTEGER arguments, the result is SINGLE.\par The square root of a number is the number that, multiplied by itself, gives the argument. For example, the square root of 4 is 2, since 2 * 2 is 4.\par The square root function is not defined for negative numbers, and returns NaN}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 NaN}}}{\fs20  if the argument is negative.\par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 HYPOTENUSE = SQR(X * X + Y * Y)\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 TAN '(' expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 TAN\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 TAN function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns the tangent}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 tangent}}}{\fs20  of an angle. The argument is expressed in radians.\par If the argument is DOUBLE, the result is also DOUBLE. For SINGLE, LONG and INTEGER arguments, the result is SINGLE.\par The TAN function is not accurate for very large angles. By very large angles, we mean angles larger than about 1300 radians for SINGLE arguments, and 2E8 radians for DOUBLE arguments, although the accuracy drops off gradually as the angle increases. For this reason, it is best to keep angles between -2\u960\'b9 and 2\u960\'b9 whenever possible. For very large arguments, TAN always returns NaN.\par The tangent tends toward infinity}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 infinity}}}{\fs20  as the argument approaches \u960\'b9/2. If the argument gets too close to \u960\'b9/2, TAN returns inf. If the argument gets too close to -\u960\'b9/2, the result will be -inf.\par Refer to any book that covers trigonometry for a discussion of the tangent.\par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 ALTITUDE = BASE_LINE * TAN(THETA)\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 String Functions}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 String Functions\tcl2}}}{\fs28 \par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 {\*\bkmkstart bk27}ASC '(' string-expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 ASC\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ASC function\bxe }}}{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ASCII character set}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns the ASCII value for the first character in the string. If there are no characters in the string, ASC returns 0.\par Characters are represented internally as a number. For example, the character A is stored as the number 65. The ASC function returns this number.\par See Appendix C for a complete list of the ASCII character set, as well as the extended Apple character set.\par See also CHR$, which returns the ASCII character corresponding to a given number.\par }\pard\plain \s33\sb120\sa40\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\pard\plain \s31\fi360\keepn\widctlpar\adjustright \v\f6\fs18\cgrid {\xe {\v\fs18 }{\v\fs18 samples\:TOUPPER}}}{\fs18 FUNCTION TOUPPER (S$) AS STRING\par ! Return the string as uppercase letters\par S2$ = ""\par WHILE LEN(S$) > 0\par   C$ = LEFT$(S$, 1)\par   S$ = RIGHT$(S$, LEN(S$) - 1)\par   IF (C$ >= "a") AND (C$ <= "z") THEN\par     C$ = CHR$ ( ASC ("A") + ASC (C$) - ASC ("a"))\par   END IF\par   S2$ = S2$ + C$\par WEND\par TOUPPER = S2$\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END FUNCTION\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CHR$ '(' expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 CHR$\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CHR$ function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns the ASCII character for a given number. The character is returned as a string of length 1.\par The expression value is evaluated and converted to an INTEGER by truncation. See }{\i\fs20 Unary Conversions}{\fs20 , earlier in this chapter, for a detailed description of this process.\par Characters are represented internally as a number. For example, the character A is stored as the number 65. Given the ASCII number, CHR$ returns the character.\par The character value for 0 is used internally to mark the end of a string. CHR$(0) returns a string of length 0.\par See Appendix C for a complete list of the ASCII character set}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ASCII character set}}}{\fs20 , as well as the extended Apple character set.\par See also ASC, which returns the ASCII number for the first character of a string. There is also a code sample showing CHR$ and ASC used together.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 FRE '(' expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 FRE\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 FRE function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Forces string garbage collection}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 garbage collection}}}{\fs20 , then returns the number of bytes of free space available for strings, variables and local variable space for subroutines. The number of bytes of free space are returned as a long integer.\par The expression value should be zero to allow for possible expansion, but is actually ignored.\par FRE can be used to determine the amount of memory available in a program, but is more often used to force garbage collection.\par See Appendix F for a complete discussion of GSoft\~BASIC\rquote s memory use and for a description of garbage collection.\par See also SETMEM. SETMEM is used to change the amount of space available for variables.\par }\pard\plain \s33\sb120\sa40\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 RAM& = FRE(0)\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 LEFT$ '(' string-expression ',' expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 LEFT$\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LEFT$ function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns the leftmost characters in a string.\par The second parameter is evaluated and converted to an INTEGER by truncation. See }{\i\fs20 Unary Conversions}{\fs20 , earlier in this chapter, for a detailed description of this process. If this value is negative or larger than the number of characters in the string that is passed as the first parameter, LEFT$ returns the string. If this value is positive and less than the number of characters in the string, the specified number of characters is returned, beginning with the first character of the string.\par One use of LEFT$ is to peel characters from a string, processing them one by one. See the code snippet for ASC for an example.\par }\pard\plain \s33\sb120\sa40\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 ! Remove the first word from S$.\par I% = 1\par WHILE (I% < LEN(S$)) AND (MID$(S$, I%, 1) <> " ")\par   I% = I% + 1\par WEND\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 W$ = LEFT$(S$, I% - 1)\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 LEN '(' string-expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 LEN\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LEN function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns the number of characters in a string. The terminating null character that marks the end of the string is not a part of the string, and is not counted by LEN. The number of characters is returned as an INTEGER.\par GSoft\~BASIC uses the character CHR$(0) to mark the end of a string. If you intentionally imbed this character in a string, LEN will return the number of characters appearing before this character.\par }\pard\plain \s33\sb120\sa40\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 L% = LEN(S$)\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 MID$ '(' string-expression ',' expression ',' expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 MID$\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 MID$ function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns characters from any position in a string.\par The last two expressions give the index of the first character to return, counting from one, and the number of characters to return, respectively. Both of these values are converted to INTEGER by truncating before being used. See }{\i\fs20 Unary Conversions}{\fs20 , earlier in this chapter, for a detailed description of this process.\par For example,\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 MID$ ("Hello, world.", 8, 5)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 returns the string "world".\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 If the index is larger than the number of characters in the string, MID$ returns the empty string. For example, \par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 MID$ ("Hello, world.", 14, 5)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 returns the string "", a string with no characters.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 If the number of characters from the index to the end of the string is smaller than the number of characters specified by the last parameter, all available characters from the index character to the end of the string are returned. For example,\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 MID$ ("Hello, world.", 8, 20)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 returns the string "world.".\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 RIGHT$ '(' string-expression ',' expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 RIGHT$\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 RIGHT$ function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns the rightmost characters in a string.\par The second parameter is evaluated and converted to an INTEGER by truncation. See }{\i\fs20 Unary Conversions}{\fs20 , earlier in this chapter, for a detailed description of this process. If this value is negative or larger than the number of characters in the string that is passed as the first parameter, RIGHT$ returns the string. If this value is less than the number of characters in the string, the specified number of characters is returned from the end of the string.\par For example,\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 RIGHT$("Testing, 1, 2, 3", 7)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 returns the string "1, 2, 3", while\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 RIGHT$("Testing, 1, 2, 3", 50)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 returns the entire input string.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 One use of RIGHT$ is to return what\rquote s left of a string after one character or a sequence of characters has been peeled off of the start of the string. See the code snippet for ASC for an example.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 STR$ '(' expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 STR$\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 STR$ function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\keepn\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 strings\:converting numbers to}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 STR$ accepts any number and returns the number as a string. The format matches the format the PRINT statement uses to print strings.\par The actual value returned depends to some extent on the type of the number. For example, the SINGLE value returned by STR$(1000000000.0) will be returned as the string "1.000000E9", while the same value returned as a LONG, as in STR$(CLNG(1000000000.0)) returns the string "1000000000".\par See PRINT for a description of the formatting rules.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 VAL '(' string-expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 VAL\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 VAL function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\keepn\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 strings\:converting to numbers}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 exponent}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 VAL accepts any string and returns the equivalent number.\par VAL examines the string beginning with the first character. It forms the largest possible string that is a valid number, then converts this value to a DOUBLE value. Leading signs, decimal points and exponents are allowed, but no leading or imbedded spaces can be used. The exponent character can be E, e, D or d. Allowing D or d for the exponent character is consistent with the syntax for double-precision constants in the program, although it makes no difference in the VAL function, since all results are double-precision.\par If there are no characters in the string, or if the first character cannot be a part of a number, VAL returns 0.0.\par }\pard\plain \s32\li360\ri3960\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx2160\adjustright \f4\cgrid {\fs20 This function...\tab ...returns this number.\par }\pard\plain \s25\li360\ri3960\sb40\keepn\widctlpar\tx2160\adjustright \f4\cgrid {\f6\fs18 VAL("4")}{\fs20 \tab 4.0\par }{\f6\fs18 VAL("-1e45")}{\fs20 \tab -1E45\par }{\f6\fs18 VAL("1d2")}{\fs20 \tab 100.0\par }{\f6\fs18 VAL("  4")}{\fs20 \tab 0.0\par }\pard \s25\li360\ri3960\sb40\widctlpar\tx2160\adjustright {\f6\fs18 VAL("7th")}{\fs20 \tab 7.0\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\*\bkmkend bk27}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 strings}{\rxe bk27}}}{\*\bkmkend bk28}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 functions\:built in}{\rxe bk28}}}{\*\bkmkend bk29}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 built in functions}{\rxe bk29}}}{\v\fs20 \par }{\fs20 \sect }\sectd \lndscpsxn\sbkodd\linex0\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Chapter 12: Control Statements\par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Chapter 12 \endash  Control Statements}{\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\v\f4\fs36\cgrid {\tc {\v Chapter 12 \endash  Control Statements\tcl1}}}{\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 This chapter describes the statements that control the order statements are executed, and in some cases, whether a statement is executed or not.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Looping}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Looping\tcl2}}}{\fs28 \par }\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 DO [ WHILE expression | UNTIL expression ]\par }\pard \s29\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20    [ statement ]*\par }\pard \s29\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20 LOOP [ WHILE expression | UNTIL expression ]\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 DO-LOOP\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DO statement\bxe }}}{\v\fs20 \par }{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LOOP statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 DO-LOOP loops are a powerful looping construct that you can use any time you need to perform an action multiple times, but the number of times you need to loop can\rquote t be calculated in advance. It is typically used to loop while some condition is true.\par The DO-LOOP structure is a very flexible loop statement that replaces several simpler statements in other programming languages, adding capability at the same time. In fact, the WHILE-WEND loop is a special case of the DO-LOOP loop. This flexibly comes at a price, though: It\rquote s tough to grasp how the statement works until you think it through carefully.\par To understand this loop, we\rquote ll examine its four simplest parts first, then see how they can be combined.\par The first form of the DO-LOOP is equivalent to the WHILE-WEND. Using the same example from the description of WHILE-WEND, the DO version looks like this:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DO WHILE NOT EOF (1)\par   INPUT #1, A$\par   PRINT A$\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 LOOP\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par This loop starts by checking a condition to see if it is true; in this case, we\rquote re checking to see if the end of a file has been reached. If the condition is true\emdash if the end of file has not been reached\emdash the statements between DO and LOOP are executed, then the condition is tested again. This process repeats until the end of file is reached, at which time the loop is finished and the statement after LOOP is executed.\par In this example, we looped while we were not at the end of the file. It\rquote s a bit more natural to think of this loop as looping until we get to the end of the file, and that\rquote s how the second version of this loop works. In BASIC, this condition looks like this:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DO UNTIL EOF (1)\par   INPUT #1, A$\par   PRINT A$\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 LOOP\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par The main advantage of this form of the DO statement is the natural way the condition is expressed. Leaving out the NOT makes the statement easier to read and easier to think about. There is also a very slight speed improvement, and the program is shorter by one byte, but these considerations are minor compared to making the statement easier to read and understand: Programs that are easy to read and understand are easier to write, easier to debug, and easier to modify than programs that are written in an unnatural way.\par In this situation, we needed to test the condition before the loop started; after all, it is possible that the file might be empty, so we start off at the end of the file, and never want to execute the contents of the loop. There are also situations where you know the loop must be executed at least once. Many times these situations arise when the value to be tested doesn\rquote t even exist until the loop executes at least one time. In these situations, the test needs to be performed after the statements in the body of the loop have executed once. That\rquote s exactly what the next two versions of this loop do.\par A classic example is the event loop in a desktop program. Desktop programs start by clearing the event queue. They then loop, waiting until something interesting happens, handling these events as they occur. The event loop terminates when the program is complete\emdash signaled by some subroutine setting an exit variable to true.\par A desktop program event loop might look something like this:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DONE = 0\par DO\par   GETEVENT\par   HANDLEEVENT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 LOOP UNTIL DONE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par At some point, the person using the program will do something like pulling down the File menu and selecting Quit. The subroutine that handles this event cleans up any open windows, then sets DONE to some nonzero value and returns. The loop finishes, and the program quits.\par As with the DO statement with the condition at the top, you can use WHILE to reverse the sense of the loop. The loop would do exactly the same thing if you coded it as\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DONE = 0\par DO\par   GETEVENT\par   HANDLEEVENT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 LOOP WHILE NOT DONE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par It is possible to use a condition both at the top and bottom of a loop. For example, you could write a loop to cheer Karen up like this:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DO UNTIL KAREN.FEELING$ = "HAPPY"\par   THROWPARTY\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 LOOP UNTIL BROKE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par This loop starts off checking to see if Karen is happy. If so, nothing is done. If Karen is not happy, the body of the loop executes. Once it executes, we check to see if there is any money left. If not, the loop is finished. If there is money left, control returns to the top of the loop, where we check to see how Karen is doing. The process repeats until Karen is happy or we go broke.\par While this is legal, it\rquote s usually easier to understand a loop that keeps all of the conditions together. This loop does pretty much the same thing as the first one.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DO UNTIL (KAREN.FEELING$ = "HAPPY") OR BROKE\par   THROWPARTY\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 LOOP\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par The difference is that we check to see if we\rquote re broke first\emdash probably a good idea in this case. If you really have two conditions, and one must be tested before the loop starts, but the other can\rquote t be, splitting them up can make a program shorter and more efficient. If the conditions can be put together, though, it\rquote s a good idea to do so.\par It is very poor form, but technically legal, to jump into or out of a DO loop. It is not legal, and will cause an error, to jump into a DO loop in such a way that the DO statement is not encountered before the LOOP statement. It is also illegal to jump out of a DO loop without completing it; this leaves incomplete DO statements in an internal stack, and will generate an error when you exit the program. It can also cause the stack to overflow, generating a different message.\par You can nest DO statements and other loop statements up to 10 levels deep. This is not a limit on the total number of looping statements, just on how many can be nested inside other loop statements. See the description of the FOR loop for an example of nested loops.\par }\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 FOR identifier '=' expression TO expression [ STEP expression ]\par }\pard \s29\keepn\widctlpar\adjustright {\fs20    [ statement ]*\par }\pard \s29\sa80\keepn\widctlpar\adjustright {\fs20 NEXT [ identifier ] [ ',' identifier ]*\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 FOR-NEXT\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 FOR statement\bxe }}}{\v\fs20 \par }{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 NEXT statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The FOR-NEXT statement is used to loop over a series of statements a fixed number of times. If you need to loop over a series of statements, but can\rquote t calculate in advance how many times you will need to loop, use the DO-LOOP or WHILE-WEND statement.\par A typical FOR-NEXT statement would print all of the numbers from 1 to 10, like this:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 FOR I = 1 TO 10\par   PRINT I\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par The statement begins by assigning 1 to the loop control variable I. All of the statements up to the NEXT statement are then executed. While this example only shows one statement, there are typically many statements between the FOR and NEXT statements.\par As you can see, the loop control variable can be used inside the loop. While it is legal to change the value of the loop control statement inside the FOR loop, it\rquote s generally not a good idea to do so. Changing the loop control variable can create subtle and difficult to locate bugs.\par When the NEXT statement is reached, the loop control value is incremented by 1. If the new value is less than or equal to the second expression, 10 in our example, the statements between FOR and NEXT are executed again. This process repeats until the loop control variable\rquote s value is larger than 10; at that point, execution continues with the statement immediately after the NEXT statement.\par While the FOR loop requires the stop and start values to be known in advance, they do not have to be fixed constants like those in the first example. For example, assume you need to change all of the characters in a string to uppercase letters. With an appropriately defined function called TOUPPER somewhere else in your program, you could use a FOR loop to change the string, like this:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 R$ = ""\par FOR I% = 1 TO LEN(S$)\par   R$ = R$ + TOUPPER (MID$ (S$, I%, 1))\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 S$ = R$\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par A subtle point about expressions in the start and stop value is that they are calculated once, as the loop starts, and the values saved until the FOR loop completes. This has two practical implications. The first is that the program will not be faster if you calculate the values before you use them in the FOR statement. The LEN function is a perfect example: compared to other instructions, this function takes a fair amount of time. Since the LEN function is only called once, and the result stored, there is no speed gain from calculating the value in advance.\par The second implication is just as important. If you change the length of the string in the loop, LEN is not recalculated. A loop that changes the value as the loop progresses is a perfect example of a loop whose stop value cannot be calculated in advance. The FOR loop would not work properly, but a loop using DO-LOOP would handle the varying string length correctly.\par In the examples so far, the loop control variable is incremented by 1 each time through the loop. It is possible to tell the FOR loop to step by some other increment using the optional STEP clause. A classic example is drawing a circle using trigonometric functions. This loop steps around the circle using radians, dividing the circle into 360 one degree lines.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 SUB CIRCLE(RADIUS, XCENTER, YCENTER)\par PI = 3.1415926535\par X% = XCENTER + RADIUS\par Y% = YCENTER\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 MOVETO (X%, Y%)\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 FOR ANGLE = 0 TO 2 * PI STEP PI / 180\par   X% = XCENTER + RADIUS * COS(ANGLE)\par   Y% = YCENTER + RADIUS * SIN(ANGLE)\par   LINETO (X%, Y%)\par NEXT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SUB\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par STEP values can be calculated, like the start and stop values. STEP values can also be negative, which reverses the direction of the loop. For example, this loop will count down from 10, rather than up.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 FOR I = 10 TO 1 STEP -1\par   PRINT I\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par You can optionally include the loop control value on the NEXT statement. This provides a quick check; if the loop control variables don\rquote t match, the program stops with an error. You can also put more than one loop control variable on the next statement, separating them with commas. In fact, you can simply use the comma to indicate that the NEXT statement applies to more than one loop control variable.\par The examples below are all legal, and show the various ways you can code the NEXT statement.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 ! Matrix addition: C = A + B\par FOR I% = 1 TO 10\par   FOR J% = 1 TO 10\par     C(I%, J%) = A(I%, J%) + B(I%, J%)\par   NEXT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 FOR I% = 1 TO 10\par   FOR J% = 1 TO 10\par     C(I%, J%) = A(I%, J%) + B(I%, J%)\par   NEXT J%\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT I%\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 FOR I% = 1 TO 10\par   FOR J% = 1 TO 10\par     C(I%, J%) = A(I%, J%) + B(I%, J%)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT J%, I%\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 FOR I% = 1 TO 10\par   FOR J% = 1 TO 10\par     C(I%, J%) = A(I%, J%) + B(I%, J%)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT ,\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par The FOR loop control variable can be any numeric type, including BYTE, INTEGER, LONG, SINGLE or DOUBLE. It must be a single value, though, not an element of an array.\par When you exit a FOR loop, the value of the FOR loop control variable is guaranteed to be the first value that would fail the loop termination test. For example, in the array addition above, both I% and J% will be 11 when the loops finish.\par It is very poor form, but technically legal, to jump into or out of a FOR loop with a GOTO statement. It is not legal, and will cause an error, to jump into a FOR loop in such a way that the FOR statement is not encountered before the NEXT statement. It is also illegal to jump out of a FOR loop without completing it; this leaves incomplete FOR statements in an internal stack, and will generate an error when you exit the program. It can also cause the stack to overflow, generating a different message.\par You can nest FOR statements and other loop statements up to 10 levels deep. This is not a limit on the total number of looping statements, just on how many can be nested inside other loop statements. The array addition example showed a FOR loop inside another LOOP; these were nested 2 levels deep.\par }\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 WHILE expression\par }\pard \s29\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20    [ statement ]*\par }\pard \s29\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20 WEND\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 WHILE-WEND\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 WHILE statement\bxe }}}{\v\fs20 \par }{\pard\plain \s25\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 WEND statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The WHILE-WEND loop is a simpler, more efficient version of a DO-LOOP that loops until a condition is met. It is typically used when you need to loop over a series of statements, but don\rquote t know in advance how many times you will need to loop. When the number of times you need to loop is known, use the FOR-NEXT statement.\par The expression must result in a numeric value. If the result is not zero, execution continues with the first statement past the WHILE statement. Once WEND is reached, the process repeats. If the expression result is zero, the loop is skipped. In this case, execution continues with the statement just past WEND.\par It is very poor form, but technically legal, to jump into or out of an executing WHILE loop. It is not legal, and will cause an error, to jump into a WHILE loop in such a way that the WHILE statement is not encountered before the WEND statement. It is also illegal to jump out of a WHILE loop without completing it; this leaves incomplete WHILE statements in an internal stack, and will generate an error when you exit the program. It can also cause the stack to overflow, generating a different message.\par You can nest WHILE statements and other loop statements up to 10 levels deep. This is not a limit on the total number of looping statements, just on how many can be nested inside other loop statements. See the description of the FOR loop for an example of nested loops.\par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\pard\plain \s31\fi360\keepn\widctlpar\adjustright \v\f6\fs18\cgrid {\xe {\v\fs18 }{\v\fs18 samples\:Print Text File}}}{\fs18 !---------------------------------------------------------------\par !\par ! PrintFile - Print a text file\par !\par ! Parameters:\par !    name - name of the file to print\par !\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 !---------------------------------------------------------------\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 SUB PRINTFILE (NAME$)\par OPEN NAME$ FOR INPUT AS #1\par WHILE NOT EOF (1)\par   INPUT #1, A$\par   PRINT A$\par WEND\par CLOSE #1\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SUB\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Making Decisions}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Making Decisions\tcl2}}}{\fs28 \par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 IF expression THEN statement\par IF expression GOTO line-number\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20 IF expression THEN\par }\pard \s29\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20 [ ELSE IF expression ]*\par [ ELSE ]\par }\pard \s29\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20 END IF\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 IF-THEN\tcl3}}}{\v\fs20 \par }{\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 IF-GOTO\tcl3}}}{\v\fs20 \par }{\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 IF-END IF\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 IF statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The IF statement is used to execute other statements when a specific condition exists. One form of the IF statement also allows you to check a series of conditions, selecting the appropriate alternative.\par BASIC has evolved over the years, leaving us with two rather different variations of the IF statement. The classic BASIC IF statement is contained completely on a single line. The expression right after IF is evaluated. It must result in a number. If this number is zero, execution continues with the line after the IF statement. If the result of the expression is anything except zero, the statement after THEN is executed.\par Here\rquote s an example of the classic IF statement in action:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 LIFE_FORCE = LIFE_FORCE - SWORD_HIT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 IF LIFE_FORCE <= 0 THEN CALL PLAYER_DIED\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par One of the interesting features of the classic IF statement is that it executes everything from THEN to the end of the line, even if there are multiple statements. You could put this to use to implement the classic shell sort.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DO\par   SWAP = 0\par   FOR I% = 1 TO ARRAY_SIZE - 1\par     IF A(I%) < A(I% + 1) THEN T = A(I%) : A(I%) = A(I% + 1) : A(I% + 1) = T : SWAP = 1\par   NEXT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 LOOP WHILE SWAP\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par Before structured programming statements like the DO-LOOP and IF-THEN-ELSE statements were added to BASIC, it was very common to see statements like\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18    10 IF A < B THEN GOTO 40\par    20 C = B\par    30 GOTO 50\par    40 C = A\par }\pard \s31\fi360\widctlpar\adjustright {\fs18    50 REM\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par It was so common, in fact, that a shorthand was invented. When you have an IF statement with THEN GOTO, you can omit the THEN, as in\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18    10 IF A < B GOTO 40\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 This form of the if statement isn\rquote t used much anymore, though. Its been replaced by the block IF statement, which can span multiple lines. Recoding this example with the block IF statement gets rid of the line numbers and makes the program considerably easier to follow.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 IF A < B THEN\par   C = B\par ELSE\par   C = A\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END IF\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par This form of the IF statement allows multiple statements between the IF and ELSE, and again between the ELSE and END IF. In fact, you can even imbed other IF statements.\par The ELSE clause is optional. As in this example, it is used when you need to do one thing if the condition is true, and another if the condition is not true. If you don\rquote t need to do anything when the condition is false, you can leave the ELSE out entirely.\par The last important option is the ELSE IF statement, used when the IF statement must choose between several alternatives. Here\rquote s an example that changes the direction of a ball when it hits the side of the screen. X represents the ball\rquote s position, and VX the speed. The same statements would appear right after these to handle the vertical direction.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 X = X + VX\par IF X <= 0 THEN\par   VX = -VX\par   IF X < 0 THEN X = -X\par ELSE IF X >= 320 THEN\par   VX = -VX\par   IF X > 320 THEN X = 640 - X\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END IF\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par You can use more than one ELSE IF clause, stringing them out to handle as many different variations on a possibility as you like. You can also mix ELSE IF with ELSE, but if you do, the ELSE clause must appear after all ELSE IF causes. When multiple ELSE IF clauses are used, the program tests them in order. When one matches, the statements between it and the next ELSE IF, ELSE or END IF are executed, and all remaining ELSE IF and ELSE clauses are skipped.\par It\rquote s possible to use the ELSE IF clause to do different things based on the value of a variable, such as this color complement example.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 IF COLOR = RED THEN\par   COLOR = GREEN\par ELSE IF COLOR = ORANGE THEN\par   COLOR = BLUE\par ELSE IF COLOR = YELLOW THEN\par   COLOR = VIOLET\par ELSE IF COLOR = GREEN THEN\par   COLOR = RED\par ELSE IF COLOR = BLUE THEN\par   COLOR = ORANGE\par ELSE\par   COLOR = VIOLET\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END IF\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par When you see a series of ELSE IF statements like this that compare the same value over and over to various possibilities, though, it\rquote s time to consider the SELECT CASE statement.\par }\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SELECT CASE expression\par }\pard \s29\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20 [ CASE case-range [ ',' case-range ]* ]*\par [ CASE ELSE ]\par }\pard \s29\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20 END SELECT\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 SELECT CASE\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SELECT statement\bxe }}}{\v\fs20 \par }{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CASE statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The SELECT CASE statement is used when you want to do one of several different things, making the choice based on a single value. For example, to change a color to its complementary color, you could use\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 SELECT CASE COLOR\par   CASE RED\par     COLOR = GREEN\par   CASE ORANGE\par     COLOR = BLUE\par   CASE YELLOW\par     COLOR = VIOLET\par   CASE GREEN\par     COLOR = RED\par   CASE BLUE\par     COLOR = ORANGE\par   CASE VIOLET\par     COLOR = YELLOW\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SELECT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par The expression after SELECT CASE is evaluated one time, then compared to a succession of values. As soon as a match is found, the statements following the matching CASE are executed. There can be more than one statement after each CASE statement, even though our example only shows a single statement after each CASE. Once the statements are executed, control passes to the statement after END SELECT.\par If no matching statements are found, control skips to the statement after END SELECT without executing any of the imbedded statements. If you need a catch-all case, use the CASE ELSE clause, like this:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 FOR I = I TO 10\par   PRINT I\par   SELECT CASE I\par     CASE 1: PRINT "st"\par     CASE 2: PRINT "nd"\par     CASE 3: PRINT "rd"\par     CASE ELSE: PRINT "th"\par   END SELECT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par This example also shows a compact and easy to read way to code a SELECT CASE when all of the actions fit on a single line. It is much easier to scan this SELECT CASE statement for a particular situation to see how it is handled than it is to scan the more verbose form of the first example. When multiple statements appear after each CASE, though, it is usually easier to read the program if the statements following the CASE appear on separate lines.\par If you need to execute the same series of statements for several alternate values, separate the values with commas, like this:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 SELECT CASE MID$(A$, 1, 1)\par   CASE "A", "E", "I", "O", "U"\par     PRINT "vowel"\par   CASE "W", "Y"\par     PRINT "sometimes vowel"\par   CASE ELSE\par     PRINT "consonant"\par }\pard \s31\fi360\widctlpar\adjustright {\fs18   END SELECT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par You can also compare a value to a range of values. This is particularly useful with strings and floating-point numbers.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 SELECT CASE WAVELENGTH\par   CASE 0.0 TO 1E-11: PRINT "Gamma rays"\par   CASE 1E-11 TO 1E-9: PRINT "X-rays"\par   CASE 1E-9 TO 4E-7: PRINT "Ultraviolet"\par   CASE 4E-7 TO 7E-7: PRINT "Light"\par   CASE 7E-7 TO 1E-5: PRINT "Infrared"\par   CASE 1E-5 TO 100: PRINT "Short wave radio"\par   CASE 100 TO 1E4: PRINT "Radio"\par   CASE 1E4 TO 1E38: PRINT "Long wave radio"\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SELECT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par If you are used to languages like C and Pascal, that last example deserves a second look. Unlike most languages, BASIC can handle floating-point and strings, and due to the fact that it supports ranges, it handles them quite well. As with single values, you can code several ranges, or even ranges mixed with discrete values, on a single CASE statement. Multiple values are separated by commas.\par It is possible, and with ranges even likely, that more than one CASE clause will match the value from the SELECT CASE statement. The CASE clauses are examined in the order they appear in the program. The statements after the first matching CASE clause are executed; statements after subsequent CASE clauses are not executed, and in fact, the conditions are not even tested. Once a matching CASE clause is found and the statements executed, control jumps immediately to the statement after END SELECT without examining any other possibilities.\par Because of this, it is important that the CASE ELSE clause appear after all CASE clauses, just before the END SELECT statement.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Jumping Around}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Jumping Around\tcl2}}}{\fs28 \par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 GOTO line-number\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 GOTO\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GOTO statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The GOTO statement is used to jump immediately to another line in the program.\par While there is nothing fundamentally wrong with the GOTO statement, its overuse can lead to programs that are almost impossible to read or debug. As structured programming became popular, the zealous attacks of the structured programmers led to the nickname of GOTO-less programming for structured programming. This isn't entirely accurate; structured programs occasionally use the GOTO statement for error handling and other abort situations. Still, the GOTO statement should be avoided unless it results in a dramatic increase in performance.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18       GOTO 40\par       DATA 1.65235, 30.656, 5.6665, 3.1556\par       ...\par       DATA 1.45564, 28.667, 4.4453, 3.1327\par }\pard \s31\fi360\widctlpar\adjustright {\fs18    40 !\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 ON expression GOTO line-number [ ',' line-number ]*\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 ON-GOTO\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ON-GOTO statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The ON-GOTO statement uses an index to jump to one of several locations in a program. In modern BASICs, it has largely been replaced by the SELECT CASE statement, which is considerably easier to read and debug.\par The expression is evaluated, then truncated to an integer. Counting from one, one of the line numbers is selected from the list of line numbers immediately after GOTO, and the program jumps to that line. If there are no matching line numbers, execution continues with the line after the ON-GOTO statement.\par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18       ON ERROR_NUMBER GOTO 10, 20, 30\par       PRINT "Unknown error"\par       GOTO 40\par    10 PRINT "I don't know how to "; VERB$\par       GOTO 40\par    20 PRINT "You can't go "; DIRECTION$; " from here."\par       GOTO 40\par    30 PRINT "You are too weak to move"\par }\pard \s31\fi360\widctlpar\adjustright {\fs18    40 REM\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Handling Errors}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Handling Errors\tcl2}}}{\fs28 \par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 ERROR expression\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 ERROR\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ERROR statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The ERROR statement is used to trigger a run time error. The parameter is the number of the error to trigger. See Appendix A for a complete list of error numbers and the corresponding messages.\par If there is an ONERR GOTO error handler active when ERROR is used, control passes to the ONERR GOTO error handler. From there, the ERR statement can be used to read the error number.\par The principal use for the ERROR statement is in ONERR GOTO error handlers. It allows you to pass any error your error handler is not designed to handle back to BASIC. See the description of ONERR GOTO for an example that shows how to use ERROR effectively in an ONERR GOTO error handler. Pay special attention to the fact that\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 ONERR GOTO 0\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 should be used before ERROR statements that appear inside an ONERR GOTO error handler. If you don\rquote t turn ONERR GOTO handling off before using ERROR, it will jump right back to the ONERR GOTO handler, generally causing an infinite loop.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 ONERR GOTO line-number\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 ONERR GOTO\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ONERR GOTO statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 When BASIC encounters any condition this manual calls an error, the normal reaction is to stop the program and print an error message. ONERR GOTO gives you a way to intercept these errors, handle them, and continue with the program.\par ONERR GOTO doesn't do much when it is executed. In fact, all that happens is that the line number is recorded. If an error never occurs, nothing is ever done with the line number. If an error occurs, though, execution immediately jumps to the line you specified. From there, you can detect what error occurred using the ERR statement, and where it occurred using ERL. If it's something you want to handle, you can deal with the error, then pop back to the line where the error occurred using RESUME.\par The ONERR GOTO statement can appear anywhere in the program, but the line number where the error is handled must appear in the main program, not in a SUB or FUNCTION.\par You can use more than one ONERR GOTO statement in the program. If an error occurs, execution continues with the line number specified by the most recently executed ONERR GOTO statement.\par Using a line number of 0 turns off ONERR GOTO error handling.\par The snippet shows a short program that deliberately generates an error by assigning a value that is too large to be an integer. This error is trapped and corrected by the error handler at line 99. The next error is one the error handler is not designed to handle, though, so it uses the ERROR statement to flag the error in the normal way.\par Pay special attention to the line:\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 ONERR GOTO 0\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 in the error handler. Using a line number of 0 turns ONERR GOTO error handling off. This must be done before using ERROR to flag the error. If the original error handler is still in effect when ERROR is encountered, the program will jump right back to the start of the error handler, causing an infinite loop.}{\pard\plain \s25\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ERROR statement}}}{\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 \par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18       ONERR GOTO 99\par       X = 40000\par       I% = X\par       PRINT I%\par       NEXT I%\par       END\par \par    99 IF ERR = 19 THEN\par         X = 32767\par         RESUME\par       END IF\par       ONERR GOTO 0\par }\pard \s31\fi360\widctlpar\adjustright {\fs18       ERROR ERR\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 {\*\bkmkstart bk30}{\*\bkmkstart bk31}ERL\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 ERL\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ERL function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 line numbers}}}{\fs20 The ERL function is used in ONERR GOTO error handlers. When BASIC triggers an error, or when your program uses the ERROR statement to force an error, BASIC records the line number where the error occurred. ERL returns that line number.\par If the statement where the error occurred did not have a line number, ERL returns 0.\par The value returned by ERL is not defined before an error has been triggered.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 ERR\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 ERR\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ERR function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The ERR function is used in ONERR GOTO error handlers. When BASIC triggers an error, or when your program uses the ERROR statement to force an error, the error number is recorded. ERR returns that error number.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ERROR statement}}}{\fs20 In the case of the ERROR statement, the error number returned by ERR is the same as the parameter for the ERROR statement.\par Appendix A lists the error numbers that can be triggered directly by BASIC.\par The value returned by ERR is not defined before an error has been triggered.\par See ONERR GOTO for an example of an ONERR GOTO error handler that uses the ERR function to determine if the error that occurred is one the error handler can deal with.\par }\pard \s25\fi360\sb40\keepn\widctlpar\adjustright {\*\bkmkend bk30}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 functions\:built in}{\rxe bk30}}}{\*\bkmkend bk31}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 built in functions}{\rxe bk31}}}{\v\fs20 \par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 RESUME\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 RESUME\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 RESUME statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The RESUME statement is used in an ONERR GOTO error handler to pass control back to the statement where the error occurred. Execution begins at the start of the line where the error occurred, not at the statement imbedded in that line. For example, in the line\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 IF I > 0 THEN J% = I\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 if I has the value 40000, the statement generates an generates an error because I is larger than 32767, which is the largest value J% can hold. RESUME does not start with the assignment J% = I; the program resumes with the IF statement.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 If the error occurs in a subroutine or function, RESUME restores control at the call in the main program, not in the subroutine itself.\par See ONERR GOTO for an example of an error handler that uses RESUME to recover from an error.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Stopping and Starting a Program}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Stopping and Starting a Program\tcl2}}}{\fs28 \par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Using CTRL-C and Command-. To Stop a Program\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CTRL-C}}}{\v\fs20 .;}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 Command-.}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 stopping a program}}}{\fs20 You can stop a program at any time by holding down the control key and pressing C, or by holding down the Command key (they key with the open apple) and pressing the period key. This has exactly the same effect as executing a STOP statement\emdash the program can be restarted with CONT, and you can examine and change the values of variables.\par While you can use these keys to stop a program during an INPUT statement, the program won't stop until after you press the return key to complete the input. All of the characters you type except the CTRL-C or Command-. are processed in the normal way. The INPUT statement processes the text you type, assigns the values to variables, and then the program stops.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Using CTRL-S To Pause a Program\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CTRL-S}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 pausing a program}}}{\fs20 You can pause a program at any time by holding down the control key and pressing S. The program freezes until you press any other key.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 BREAK\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 BREAK\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 BREAK statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Use the BREAK statement to trigger any ORCA compatible debugger}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 debugger}}}{\fs20 , such as PRIZM}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 PRIZM}}}{\fs20 , ORCA/Debugger}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ORCA/Debugger}}}{\fs20  or Splat!}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 Splat!}}}{\fs20 \par When this statement is encountered, a COP instruction is executed. This can do one of two things. If you have an ORCA compatible debugger installed, this will trigger the debugger. It will display your GSoft\~BASIC program, starting with the line containing the BREAK. Depending on the capabilities of the debugger, you will be able to step, trace, watch or change variables, examine RAM, and so forth. When you tell the debugger to return control to the executing program, your GSoft\~BASIC program will continue to execute normally.\par }{\b\fs20 Do not use this command}{\fs20  unless an ORCA compatible debugger is installed! ORCA compatible debuggers work by intercepting the 65816}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 65816}}}{\fs20  COP instruction. There is no way for GSoft\~BASIC to tell if a debugger is installed or not, so it will issue the COP instruction whether or not a debugger is actually present. If there is no debugger installed, this causes the computer to crash. While this does no actual harm, the only way to recover is to reboot.\par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 ! Try this program to see how your debugger reacts to GSoft\~BASIC\par BREAK\par SUM = 0\par FOR I = 1 to 10\par   SUM = SUM + I\par NEXT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PRINT SUM\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 END\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 END\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 END statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 END is used to stop the program. The most common use is just before the first SUB or FUNCTION statement.\par END can actually be used anywhere in the program. It stops execution, leaving intact all of the variables and even the various internal stacks that track FOR loops, subroutines and the like. This makes it possible to use the END statement as a quiet version of the STOP statement. By comparison, the END statement simply stops execution, while the STOP statement prints a message telling you the STOP statement was issued, and if there was a line number, which line the STOP statement appeared on.\par END is also the first token in several special token pairs. The snippet shows two examples, END IF and END FUNCTION. See IF, SELECT CASE, FUNCTION, SUB and TYPE for descriptions of END used with another token.\par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 ! Print a table of vector lengths\par PRINT "", 1, 2, 3, 4\par FOR Y = 1 TO 4\par   PRINT Y, ;\par   FOR X = 1 TO 4\par     IF X = 4 THEN\par       PRINT VECTOR_LENGTH(X, Y)\par     ELSE\par       PRINT VECTOR_LENGTH(X, Y), ;\par     END IF\par   NEXT X\par NEXT Y\par END\par \par FUNCTION VECTOR_LENGTH(X, Y)\par VECTOR_LENGTH = SQR (X * X + Y * Y)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END FUNCTION\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CONT\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 CONT\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CONT statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 CONT tells GSoft\~BASIC to continue execution after a STOP or END. It is used from the GSoft\~BASIC command line, not inside a program.\par After stopping a program with STOP or END, and perhaps after examining or even changing a few variables, you can use CONT to restart the program. So long as no lines have been changed, CONT picks up execution right after the STOP or END, continuing on as if nothing happened.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 STOP\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 STOP\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 STOP statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 stopping a program}}}{\fs20 STOP is used as a simple debugging command. STOP stops the program, printing a message that includes the line number where the STOP statement is located\emdash assuming, of course, that the line has a line number. You can examine variables, change the values of variables, and list lines. Once you have finished examining the state of the program, use CONT to continue execution.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 WAIT expression ',' expression\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 WAIT\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 WAIT statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 WAIT is used to test bits in the computer\rquote s memory. It waits until one of several bits are set, then continues execution. In practice, WAIT is generally used to interact with hardware, watching various special memory locations that appear to the computer to be normal RAM, but are in fact set by hardware ports.\par The remainder of this discussion assumes you know how bits are stored in bytes as two\rquote s complement numbers. If you do not understand how this is done, refer to a book on assembly language programming or basic computer technology for a quick course in binary mathematics.\par One example that exists on every Apple\~II}{\fs18 GS}{\fs20  is the keyboard}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 keyboard}}}{\fs20 . When you press a key, the most significant bit of the memory location $00C000 is set to 1, and the ASCII value for the keyboard character pressed is placed in the other 7 bits of the same byte. After noticing that there is a key available and retrieving the value, you clear the keyboard value for the next character by storing any value to the location $00C010. The snippet shows a subroutine that takes advantage of these facts, reading a key without allowing GSoft\~BASIC\rquote s standard input commands to get in the way and interpret any information.\par The first expression is the memory}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 memory}}}{\fs20  location to examine. The second expression is a bit mask. This value is logically anded with the 8 bit byte at the memory location given by the first expression. If the result is not zero\emdash that is, if any of the memory bits were also set\emdash the WAIT statement proceeds to the next line. If none of the bits are set, WAIT cycles again, waiting indefinitely until one of the bits turns to 1.\par Memory locations start at 0 and are numbered sequentially to $00FFFFFF (16,777,215 decimal). Your computer\rquote s RAM}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 RAM}}}{\fs20  occupies sequential memory addresses starting at zero and continuing until the RAM is exhausted, while the built-in ROM occupies the memory from $00FFFFFF down. Some of these memory locations have special uses; for example, $00C000 to $00CFFF is used for memory mapped input and output to devices like the keyboard and the cards plugged into various slots in your computer, and $E12000 to $E19FFF is the graphics display. For the Apple\~II}{\fs18 GS}{\fs20  computer, the actual memory locations and how they are used is documented in }{\i\fs20 Apple\~II}{\i\fs18 GS}{\i\fs20  Firmware Reference}{\fs20  and }{\i\fs20 Apple\~II}{\i\fs18 GS }{\i\fs20 Hardware Reference, Second Edition}{\fs20 . Both of these books are available as reprints from the Byte Works. For hardware devices that are not built in, if the documentation exists at all, it probably came with the hardware itself.\par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 !---------------------------------------------------------------\par !\par ! GetKey - read a key directly from the keyboard\par !\par ! Returns: Key read\par !\par ! Notes: This subroutine does not work if the Event Manager is\par !    active.\par !\par !---------------------------------------------------------------\par \par FUNCTION GETKEY AS STRING\par WAIT $00C000, $80\par GETKEY = CHR$ ( PEEK ($00C000) - $80)\par POKE $00C010, 0\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END FUNCTION\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \sect }\sectd \lndscpsxn\sbkodd\linex0\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Chapter 13: Input and Output\par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Chapter 13 \endash  Input and Output}{\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\v\f4\fs36\cgrid {\tc {\v Chapter 13 \endash  Input and Output\tcl1}}}{\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 There are many kinds of input and output on a modern computer. BASIC has built-in commands to deal with two of these: disk input and output and input from the keyboard}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 keyboard}}}{\fs20  with output to the computer\rquote s monitor. BASIC also has a set of commands to read data imbedded in the program itself. While you could argue that reading data from the program isn\rquote t really input, the commands look and work a lot like the other input commands, and are lumped in with them here.\par There is a lot of overlap between commands that read the keyboard and write to the console, and commands that read and write disk files. At the same time, these are very different operations. This chapter covers commands that are generally used with the keyboard and monitor, as well as the commands that read data imbedded in the program. The next chapter covers commands that are generally used to read and write disk files.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Printing Text}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Printing Text\tcl2}}}{\fs28 \par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 PRINT [ '#' expression ]\par       [ expression\par         | SPC '(' expression ')'\par         | TAB '(' expression ')'\par         | ';'\par         | ',' ]*\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 PRINT\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 PRINT statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The PRINT statement is used to write text to the monitor and to text disk files. It has two major forms. The simplest to use is covered in this section; it\rquote s easy to understand, but doesn\rquote t give a lot of control over how numbers are formatted. PRINT USING gives a great deal of control over how numbers are formatted, but it is a bit harder to understand and use. PRINT USING is covered in the next section.\par The PRINT statement writes a line of text to the screen. It normally moves the position for the next character, called the cursor position, to a new line after it prints the values in the expressions. The short program\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PRINT "Hello, world."\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PRINT 1990 + 8\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 writes these two lines to the text screen:\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 Hello, world.\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 1998\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Using ? As a Typing Shortcut}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Using ? As a Typing Shortcut\tcl4}}}{\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ? statement}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 PRINT is a frequently used command, especially in the immediate execution mode, where you can use BASIC as a calculator. Rather than typing the entire word, you can use a shortcut and type ?. For example,\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 ?4+5\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 prints 9. It is completely equivalent to\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PRINT 4 + 5\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 and in fact that's what you will see if you use the line in a program and then list or edit the program.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Printing Strings}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Printing Strings\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 String output is relatively simple. All of the characters in the string are printed, one after the other, to the text screen or disk file.\par Keep in mind that string expressions work, too. The line\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PRINT LEFT$("Hello, world.", 5)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 prints\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 Hello\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Printing BYTE, INTEGER and LONG Values}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Printing BYTE, INTEGER and LONG Values\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 BYTE}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 INTEGER}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LONG}}}{\fs20 Any expression that evaluates to one of these integer number formats prints the result as decimal digits with no leading zeros or spaces. If the number is less that zero, it is printed with a leading - character.\par The table shows several examples. The PRINT statement in the first column prints the line shown in the second column.\par }\pard\plain \s32\li360\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx5400\adjustright \f4\cgrid {\fs20 PRINT Statement\tab Output Line\par }\pard\plain \s31\fi360\keepn\widctlpar\tx5400\adjustright \f6\fs20\cgrid {\fs18 PRINT 320\tab 320\par PRINT 0\tab 0\par PRINT 4000 - 5000\tab -1000\par PRINT CINT (45.67)\tab 45\par PRINT CLNG(40)\tab 40\par PRINT $E12000\tab 14753792\par }\pard \s31\fi360\widctlpar\tx5400\adjustright {\fs18 PRINT -2147483647 - 1\tab -2147483648\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Printing SINGLE and DOUBLE Values}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Printing SINGLE and DOUBLE Values\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 floating-point}}}{\fs20 Floating-point numbers print three different ways, depending on the value of the number.\par The most common representation for a floating-point number displays a whole number, a decimal point, and the decimal fraction. Negative numbers are preceded by the - character. For example, \u960\'b9 to seven significant digits is written 3.141593. This is the format used for SINGLE and DOUBLE values whose absolute value is greater than or equal to 0.01 and smaller than 1E8 for SINGLE values, or 1D13 for DOUBLE values. Numbers whose absolute value is smaller than 0.01, and SINGLE numbers whose absolute value is greater than or equal to 1E8, or DOUBLE numbers whose absolute value is greater than or equal to 1D13, print in scientific notation.\par SINGLE values are precise to slightly more than seven significant decimal digits, so that is the number of digits that print. If there are more than seven significant digits the number is rounded to seven significant digits before printing. Any trailing zeros appearing after the decimal point are removed; if all of the digits appearing after the decimal point are zero, the decimal point is also removed. Numbers smaller than 1.0 always print with a leading zero. After following these rules, whatever is left of the number is printed.\par DOUBLE values are precise to slightly more than 13 decimal digits, so they print thirteen significant digits. The same rules are used for removing trailing zeros after the decimal point, and for removing the decimal point itself if there are no non-zero digits after the decimal point.\par Scientific notation is used for numbers that are very close to zero and very far away from zero. In scientific notation, the number is multiplied or divided by 10 until the absolute value is greater than or equal to 1.0 and less than 10.0. This portion of the number is called the mantissa}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 mantissa}}}{\fs20 . For SINGLE numbers, seven significant digits are printed; for DOUBLE numbers, eight significant digits are printed. Unlike numbers in standard form, the decimal point and all trailing zeros are printed, even if all of the digits to the right of the decimal point are zero. }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 exponent}}}{\fs20 The mantissa is followed by the letter E and the exponent for the number. Raising 10 to the power of the exponent and multiplying the result by the mantissa gives the actual number. For example, 1000000000 prints as 1.000000E9, while 0.001 prints as 1.000000E-3.\par The table shows several examples. The PRINT statement in the first column prints the line shown in the second column.\par }\pard\plain \s32\li360\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx5400\adjustright \f4\cgrid {\fs20 PRINT Statement\tab Output Line\par }\pard\plain \s31\fi360\keepn\widctlpar\tx5400\adjustright \f6\fs20\cgrid {\fs18 PRINT .00123456789\tab 1.234568E-3\par PRINT .0123456789\tab 0.01234568\par PRINT .123456789\tab 0.1234568\par PRINT 1.23456789\tab 1.234568\par PRINT 12.3456789\tab 12.34568\par PRINT 12345.6789\tab 12345.68\par PRINT 123456.789\tab 123456.8\par PRINT 1234567.89\tab 123456.8\par PRINT 1234567.89\tab 1234568\par PRINT 12345678.9\tab 12345680\par PRINT 123456789.0\tab 123456E8\par PRINT 1.23456789123456789D-3\tab 1.2345679E-3\par PRINT 1.23456789123456789D-2\tab 0.01234567891234\par PRINT 1.23456789123456789D-1\tab 0.1234567891234\par PRINT 1.23456789123456789D0\tab 1.234567891234\par PRINT 1.23456789123456789D12\tab 12345678912.34\par PRINT 1.23456789123456789D13\tab 1.2345679E13\par PRINT 1.001\tab 1.001\par PRINT 1.000001\tab 1.000001\par PRINT 1.0000001\tab 1\par PRINT 1.0000007\tab 1.000001\par PRINT -10000 * 10000\tab -1.000000E8\par }\pard \s31\fi360\widctlpar\tx5400\adjustright {\fs18 PRINT EXP(1)\tab 2.718282\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Pointers and Records}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Pointers and Records\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 records}}}{\fs20 The PRINT statement can print numbers or strings, but not pointers or records. Of course, you can print the value the pointer points to if it is a number or string, and you can also print fields from a record.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Printing Multiple Expressions With Commas and Semicolons}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Printing Multiple Expressions With Commas and Semicolons\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 You can print more than one number or string using a single PRINT statement by separating the expressions with commas or semicolons.\par Semicolons simply separate the expressions. The expressions are crammed together with no intervening spaces. A good example of semicolons in action is\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PRINT "The circumference of a circle whose diameter is "; R; " is "; PI * R; "."\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 If R is 3 and PI is 3.1415926, this statement prints\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 The circumference of a circle whose diameter is 3 is 9.424778.\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 tabs}}}{\fs20 Commas tab the next item to the next tab position. Tabs appear in each column divisible by 16. The leftmost column is numbered 1. Commas give you a simple way to quickly create tables, like this table that prints the sine for each angle from 1 to 20 degrees.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DTR = 3.1415926 / 180.0\par FOR A = 1 TO 20\par   PRINT A, SIN (A * DTR)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par These tables are created by printing the correct number of spaces to the screen, not by using tab characters. This means the PRINT statement will work correctly with any output device that uses a monospaced font, including printers.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 text screen}}}{\fs20 The 16 character columns formed by comma tabbing on the default text screen divide the 80 column screen into five equal columns. If you print a line that extends past column 64, then use a comma, the next column starts in column 1 of the next line. }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 printers\:formatting}}}{\fs20 To keep screen and printer output as similar as possible, this tabbing method is also used in disk files and any other printed output.\par You can use more than one comma in a row to skip multiple columns. For that matter, you can use multiple semicolons, too, or even mix commas and semicolons.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Controlling Spaces Using SPC and TAB}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Controlling Spaces Using SPC and TAB\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 SPC and TAB are special functions you can use inside a PRINT statement. They are only valid in a PRINT statement. Each returns a string with a varying number of spaces.\par SPC takes a single parameter, which it evaluates and converts to INTEGER. If the result is negative, it is replaced by 0. SPC returns a string with the resulting number of spaces. This short example shows how SPC can be used to create a table of numbers that are right justified in any desired field size. WIDTH% is the width of the columns.\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 WIDTH% = 12\par DTR = 3.1415926 / 180.0 : ! Converts degrees to radians.\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 H1$ = "Angle"\par H2$ = "Cosine"\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PRINT SPC (WIDTH% - LEN (H1$));H1$; SPC (WIDTH% - LEN (H2$));H2$\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 H1$ = "-----"\par H2$ = "------"\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PRINT SPC (WIDTH% - LEN (H1$));H1$; SPC (WIDTH% - LEN (H2$));H2$\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 FOR A = 0 TO 10\par   V1$ = STR$ (A)\par   V2$ = STR$ ( COS (A * DTR))\par   PRINT SPC (WIDTH% - LEN (V1$));V1$; SPC (WIDTH% - LEN (V2$));V2$\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 tabs}}}{\fs20 TAB also returns a string with some number of spaces. Tab evaluates the parameter, then subtracts the column number where the next character will be printed, counting columns from 1. If the result is negative, it is replaced with zero. TAB returns a string with the specified number of spaces. The effect is that TAB inserts spaces so the next character you print will appear in the column you specify.\par Here\rquote s the same program you just saw, but this time the second column is left justified using TAB.\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 WIDTH% = 12\par DTR = 3.1415926 / 180.0 : ! Converts degrees to radians.\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 H1$ = "Angle"\par H2$ = "Cosine"\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PRINT SPC (WIDTH% - LEN (H1$));H1$; TAB (WIDTH% + 4);H2$\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 H1$ = "-----"\par H2$ = "------"\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PRINT SPC (WIDTH% - LEN (H1$));H1$; TAB (WIDTH% + 4);H2$\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 FOR A = 0 TO 10\par   V1$ = STR$ (A)\par   V2$ = STR$ ( COS (A * DTR))\par   PRINT SPC (WIDTH% - LEN (V1$));V1$; TAB (WIDTH% + 4);V2$\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Controlling New Lines With Semicolons}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Controlling New Lines With Semicolons\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 In all of the examples shown so far, PRINT always starts at the beginning of a fresh line, and always finishes by moving to the start of a new line. You can prevent this behavior by ending the PRINT statement with a semicolon. This leaves the cursor at the end of the line you were printing, rather than skipping to a fresh line. The next PRINT statement, or any other statement that sends characters to the output device, picks up where the PRINT statement left off.\par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM A$(5)\par A$(0) = "red"\par A$(1) = "orange"\par A$(2) = "yellow"\par A$(3) = "green"\par A$(4) = "blue"\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 A$(5) = "violet"\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 FOR I% = 1 TO 6\par   PRINT "The ";I%;\par   SELECT CASE I%\par     CASE 1\par }\pard \s31\fi360\widctlpar\adjustright {\fs18       PRINT "st";\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18     CASE 2\par }\pard \s31\fi360\widctlpar\adjustright {\fs18       PRINT "nd";\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18     CASE 3\par }\pard \s31\fi360\widctlpar\adjustright {\fs18       PRINT "rd";\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18     CASE ELSE\par       PRINT "th";\par }\pard \s31\fi360\widctlpar\adjustright {\fs18   END SELECT\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18   PRINT " color in the rainbow is ";A$(I% - 1);"."\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Printing Blank Lines}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Printing Blank Lines\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A PRINT statement with no parameters at all skips to the start of a new, fresh output line. If the cursor starts at the beginning of a line, this prints a blank line. If the cursor is on a line that already contains characters, perhaps because a semicolon appeared at the end of the last PRINT statement, the PRINT statement with no parameters finishes the current line, setting the cursor so the next printed character will appear at the start of the next line.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Printing To Disk Files}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Printing To Disk Files\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 If the first thing after the PRINT statement is a #}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 #}}}{\fs20  character, the printed text will go to a disk file rather than the text screen. The # character is followed by an INTEGER expression; this value must match one of the files currently open for output. See OPEN in the next chapter to see how to open a file for output.\par Each character that would have been written to the text screen is written to the disk file instead. Whenever the PRINT statement would have skipped to the start of a fresh line, the character CHR$(13) is written to the disk file. This is the standard end of line character used for all text files and program source files on the Apple\~II}{\fs18 GS}{\fs20 .\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 PRINT [ '#' expression ] USING format-string ';' expression [ ( ',' | ';' ) expression ]* ( ',' | ';' )\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 PRINT USING\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 PRINT USING statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 There are two forms of the PRINT statement. The PRINT USING statement gives accurate control over exactly how values will be displayed on the screen. The standard PRINT statement, described above, doesn\rquote t give much control over the output, but it is much easier to use than PRINT USING.\par Every PRINT USING statement has a format string right after USING. This format string contains normal text plus format models, which are sequences of special characters that describe how a value should be printed. The normal text is printed just as it appears; the format models are replaced by one of the values that follow the semicolon that appears after the format string. If there is more than one expression, you can separate the expressions with either commas or semicolons; unlike PRINT. With the PRINT statement, the comma and semicolon serve different purposes, but with PRINT USING, both punctuation marks simply separate expressions.\par You can use a semicolon or comma after all of the expressions to indicate that a carriage return should not be printed. As with the semicolon used with the simple PRINT statement, this causes the next characters printed by a PRINT statement or an INPUT prompt to appear on the same line, right after the last character printed by the PRINT USING statement.\par There is a wide variety of format models available. The sections that follow start with the most basic format model for a number, #}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 #}}}{\fs20 , and gradually add the other characters that can be mixed with the # character to control the way numbers are formatted. After covering the format models used with numbers, the string format models are explained. Each section ends with a list of examples that show a format model as a format string, a value, and the characters that are printed. To keep things simple, these examples only show one format model per line, and don\rquote t use expressions, but multiple format models can be used in a single format string, and other characters can be used, too. The examples all use a vertical bar just before and just after the format model. These bars are not required, or even common, in real format strings; they are included here so you can clearly see spaces and what happens when a value is too large for the format model.\par Examples of real format strings that mix text and multiple format models appear at the end of the description of the PRINT USING statement.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Formatting Numbers}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Formatting Numbers\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 One or more # characters set up a format model for a number. The number of # characters used determines the minimum width of the output field. If the number doesn\rquote t need all of the output field, spaces are printed before the number; if there isn\rquote t enough room for the number, the entire value is still written.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 floating-point}}}{\fs20 If the value is a floating-point number, the number is rounded to the closest integer value. This doesn\rquote t convert the value to an INTEGER, it simply rounds the floating-point number to the closest whole number.\par }\pard\plain \s32\li360\ri1080\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx2520\tx4680\adjustright \f4\cgrid {\fs20 Format Model\tab Value\tab Prints\par }\pard\plain \s31\li360\ri1080\keepn\widctlpar\tx2520\tx4680\adjustright \f6\fs20\cgrid {\fs18 "|##|"\tab 1\tab | 1|\par "|##|"\tab 12\tab |12|\par "|##|"\tab 123\tab |123|\par "|###|"\tab -3\tab | -3|\par "|###|"\tab 45.67\tab | 46|\par }\pard \s31\li360\ri1080\widctlpar\tx2520\tx4680\adjustright {\fs18 "|###|"\tab 0.25\tab |  0|\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 The Decimal Point}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 The Decimal Point\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Replacing one of the # characters in a numeric format model with a period turns the output from an integer to a fixed point output. The classic use for this format model is to print a dollar amount with exactly two digits to the right of the decimal point.\par If a number is too large to represent in the available space, it prints as # characters.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 floating-point}}}{\fs20 SINGLE numbers are precise to slightly more than seven significant digits, and DOUBLE numbers are significant to more than 13 significant digits. If you provide space for more significant digits than are available, you will get something, but the extra digits are artifacts of the number conversion, not valid values. This is shown in the last example in the table, which gets the eighth digit right\emdash more by accident than design\emdash but the ninth significant digit is clearly more than the available precision for a SINGLE value.\par }\pard\plain \s32\li360\ri1080\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx2520\tx4680\adjustright \f4\cgrid {\fs20 Format Model\tab Value\tab Prints\par }\pard\plain \s31\li360\ri1080\keepn\widctlpar\tx2520\tx4680\adjustright \f6\fs20\cgrid {\fs18 "|##.##|"\tab 1\tab | 1.00|\par "|##.##|"\tab 12\tab |12.00|\par "|##.##|"\tab 123\tab |##.##|\par "|##.#|"\tab -3.4\tab |-3.4|\par "|##.#|"\tab -23.4\tab |##.#|\par "|##.##|"\tab 45.678\tab |45.68|\par "|##.##|"\tab 9.999\tab |10.00|\par "|##.##|"\tab 0.0049\tab | 0.00|\par }\pard \s31\li360\ri1080\widctlpar\tx2520\tx4680\adjustright {\fs18 "|###.######|"\tab 123.456789\tab |123.456780|\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Adding Commas}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Adding Commas\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Replacing one or more of the # characters (except the first one!) with a comma causes the number to be printed with a comma between every three digits of the whole number part, counting left from the decimal place. While it isn\rquote t required, it makes sense to put the commas in the same positions they will print. This makes the format model easier to read.\par Substituting a comma for a # character does not extend the number of characters available to print values, so be sure you leave enough room for the number\rquote s significant digits and for the comma characters. If you need to print eight significant digits, as shown in the first example of the table, you will need a total of ten characters in the format model\emdash eight for the numeric digits, and two for commas. As the second example shows, the number of commas is not the issue. The issue is how many commas the PRINT USING statement will need to insert to represent the value.\par }\pard\plain \s32\li360\ri1080\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx2520\tx4680\adjustright \f4\cgrid {\fs20 Format Model\tab Value\tab Prints\par }\pard\plain \s31\li360\ri1080\keepn\widctlpar\tx2520\tx4680\adjustright \f6\fs20\cgrid {\fs18 "|##,###,###|"\tab 1e6\tab | 1,000,000|\par "|#,########|"\tab 1e6\tab | 1,000,000|\par "|##,###,###.##|"\tab 1.2345678912D7\tab |12,345,678.91|\par }\pard \s31\li360\ri1080\widctlpar\tx2520\tx4680\adjustright {\fs18 "|##,###.####|"\tab 1234.5678D0\tab | 1,234.5678|\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Controlling Positive and Negative Signs}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Controlling Positive and Negative Signs\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 By default, if a number is positive no sign is printed, and if a number is negative a - character is printed before the first digit. You can change this behavior two ways.\par First, you can indicate that both +}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 +}}}{\fs20  and - characters should be used for the sign by substituting a + character for the first # character. The number will always be preceded by a sign.\par The second option is to replace the last # character with a + character or - character. If you use a - character, the last character will be a - for negative numbers and a space for positive numbers. If you use a + character, the last character will still be - for negative numbers, but it will be + for positive numbers.\par Leading - signs are not used in format models. A - character appearing before a format model is treated like any other character that is not used in a format model: It is simply printed.\par }\pard\plain \s32\li360\ri1080\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx2520\tx4680\adjustright \f4\cgrid {\fs20 Format Model\tab Value\tab Prints\par }\pard\plain \s31\li360\ri1080\keepn\widctlpar\tx2520\tx4680\adjustright \f6\fs20\cgrid {\fs18 "|####.##|"\tab -1.23\tab |  -1.23|\par "|+###.##|"\tab -1.23\tab |  -1.23|\par "|+###.##|"\tab 1.23\tab |  +1.23|\par "|###.##-|"\tab -1.23\tab |  1.23-|\par "|###.##-|"\tab 1.23\tab |  1.23 |\par "|###.##+|"\tab -1.23\tab |  1.23-|\par }\pard \s31\li360\ri1080\widctlpar\tx2520\tx4680\adjustright {\fs18 "|###.##+|"\tab 1.23\tab |  1.23+|\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Dollar Signs}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Dollar Signs\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 $}}}{\fs20 Replacing the first # character with a $ character causes a $ to be printed before the number and all leading spaces. Replacing the first two # characters with two $ characters causes a single $ character to be printed right before the first digit.\par If you are using both a leading + sign and a leading $ or $$, you can put them in any order, so long as they all come before the first # character.\par }\pard\plain \s32\li360\ri1080\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx2520\tx4680\adjustright \f4\cgrid {\fs20 Format Model\tab Value\tab Prints\par }\pard\plain \s31\li360\ri1080\keepn\widctlpar\tx2520\tx4680\adjustright \f6\fs20\cgrid {\fs18 "|$###.##|"\tab -1.23\tab |$ -1.23|\par "|$###.##|"\tab 1.23\tab |$  1.23|\par "|$+##.##|"\tab -1.23\tab |$ -1.23|\par "|+$##.##|"\tab 1.23\tab |$ +1.23|\par "|$$##.##|"\tab 1.23\tab |  $1.23|\par "|$$##.##|"\tab -1.23\tab | -$1.23|\par "|$$+#.##|"\tab 1.23\tab | +$1.23|\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Filling Spaces in Numbers}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Filling Spaces in Numbers\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 If the format model leaves more space to the left of the decimal point than is needed, the extra space is filled with blanks. In some applications, such as writing checks, it\rquote s a good idea to fill in any spaces so someone else doesn\rquote t fill them in for you later!\par Replacing the first # character with an *}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 *}}}{\fs20  prints an * in the first space. Replacing the first two # characters with ** prints an * in all leading spaces.\par You can mix * characters, $ characters and + or - characters in any order, so long as they all appear before the first # character, and so long as pairs of * or $ characters appear as a pair. In all cases, dollar signs, positive signs and negative signs are placed in the available space just as they always were, and * characters fill any remaining spaces.\par }\pard\plain \s32\li360\ri1080\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx2520\tx4680\adjustright \f4\cgrid {\fs20 Format Model\tab Value\tab Prints\par }\pard\plain \s31\li360\ri1080\keepn\widctlpar\tx2520\tx4680\adjustright \f6\fs20\cgrid {\fs18 "|*###.##|"\tab -1.23\tab |* -1.23|\par "|*###.##|"\tab 1.23\tab |*  1.23|\par "|**##.##|"\tab -1.23\tab |**-1.23|\par "|**##.##|"\tab 1.23\tab |***1.23|\par "|**$#.##|"\tab -1.23\tab |$*-1.23|\par "|$**#.##|"\tab 1.23\tab |$**1.23|\par "|$+**.##|"\tab -1.23\tab |$*-1.23|\par "|+$**.##|"\tab 1.23\tab |$*+1.23|\par "|$$**.##|"\tab 1.23\tab |**$1.23|\par "|$$**.##|"\tab -1.23\tab |*-$1.23|\par "|$$+**.##|"\tab 1.23\tab |**+$1.23|\par }\pard \s31\li360\ri1080\widctlpar\tx2520\tx4680\adjustright {\fs18 "|$$-**.##|"\tab -1.23\tab |-**$1.23|\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Formatting Numbers In Scientific Notation}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Formatting Numbers In Scientific Notation\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 exponent}}}{\fs20 Following any number format with ^}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ^}}}{\fs20  prints the number in scientific notation. The exponent prints as the letter e, a +}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 +}}}{\fs20  or - sign, and the numeric exponent. Use four ^ characters to hold any SINGLE exponent, and five to hold any DOUBLE exponent. The format model ##.######^^^^ will print all significant digits of any SINGLE number, along with the sign and exponent. The format model ##.############^^^^^ does the same for DOUBLE values.\par A minimum of three characters are needed to print a one digit exponent; one character for the \ldblquote e\rdblquote , one for the sign, and one for the digit. Because of this minimum size, you must use at least three ^ characters to get scientific notation.\par }\pard\plain \s32\li360\ri1080\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx2520\tx4680\adjustright \f4\cgrid {\fs20 Format Model\tab Value\tab Prints\par }\pard\plain \s31\li360\ri1080\keepn\widctlpar\tx2520\tx4680\adjustright \f6\fs20\cgrid {\fs18 "|##.###^^^|"\tab 1\tab | 1.000e+0|\par "|##.###^^^|"\tab -0.1234\tab |-1.234e-1|\par }\pard \s31\li360\ri1080\widctlpar\tx2520\tx4680\adjustright {\fs18 "|+#.######^^^^|"\tab 123.45678\tab |+1.234568e+02|\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Formatting Strings}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Formatting Strings\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 There are three format models for strings. The &}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 &}}}{\fs20  character prints an entire string, printing all characters, regardless of the size of the string. The !}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 !}}}{\fs20  character prints the first letter of a string. Two backslash characters with any number of intervening spaces prints as many of the characters as will fit. The backslashes count, so a backslash, two spaces and a backslash prints the first four characters from a string. If the format model is wider than the string, the string is printed, then blanks are printed to fill the available space.\par }\pard\plain \s32\li360\ri1080\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx2520\tx4680\adjustright \f4\cgrid {\fs20 Format Model\tab Value\tab Prints\par }\pard\plain \s31\li360\ri1080\keepn\widctlpar\tx2520\tx4680\adjustright \f6\fs20\cgrid {\fs18 "|&|"\tab "testing"\tab |testing|\par "|!|"\tab "testing"\tab |t|\par "|\\\\|"\tab "testing"\tab |te|\par "|\\ \\|"\tab "testing"\tab |tes|\par "|\\  \\|"\tab "testing"\tab |test|\par "|\\     \\|"\tab "testing"\tab |testing|\par "|\\      \\|"\tab "testing"\tab |testing |\par }\pard \s31\li360\ri1080\widctlpar\tx2520\tx4680\adjustright {\fs18 "|\\       \\|"\tab "testing"\tab |testing  |\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Mixing Text and Format Models}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Mixing Text and Format Models\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 All of the examples so far show mixing of text and format models, but only to show where the value being printed started and stopped, making it clear where spaces were printed. In actual programs it\rquote s common to see a format string with more than one format model, and to see significant text mixed in with the format models.\par For example, the program\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PV = 100\par Y = 7\par I = 10\par FV = PV * EXP (Y * LOG (1 + I / 100))\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PRINT USING "$$##.## compounded for # years at #% interest returns $$##.##."; PV, Y, I, FV\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 prints\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 $100.00 compounded for 7 years at 10% interest returns $194.87.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Printing Format Characters as Text}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Printing Format Characters as Text\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 You may need to print one of the special format characters from the format string. To prevent PRINT USING from using a character as a format character, precede it with the underscore character. To print an underscore, place two underscore characters in the format string.\par For example,\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PRINT USING "_\\#_\\"; 45\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 prints\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 \\45\\\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 even though a backslash character is usually used as a fixed length string format model.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Too Many and Too Few Format Models}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Too Many and Too Few Format Models\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 If there are fewer values than format models, printing stops when the first extra format model is found. For example,\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PRINT USING "|#|#|#|"; 1, 2\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 prints\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 |1|2|\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par Too many values for the available format models reuses the format model. This is actually a useful feature, allowing you to create multi-column tables with a single format model. The line\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PRINT USING "|#|"; 1, 2, 3\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 prints\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 |1||2||3|\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par The only problem with a format model that will cause the program to stop with an error is providing a string to a number specifier or providing a number to a string format model.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Printing To Disk Files}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Printing To Disk Files\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Using # followed by a number between PRINT and USING redirects the text that would normally be printed to a disk file. The value that follows # must match one of the files currently open for output. See OPEN in the next chapter to see how to open a file for output.\par Each character that would have been written to the text screen is written to the disk file instead. The character CHR$(13) is written to the disk file at the end of each line. This is the standard end of line character used for all text files and program source files on the Apple\~II}{\fs18 GS}{\fs20 .\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SPEED expression\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 SPEED\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SPEED statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 SPEED causes a slight pause right after each character is written to the screen. The expression tells how long this pause should be.\par A speed of 255 writes characters as rapidly as possible; this is the default. A value of 0 introduces a long delay after each character is written. Intermediate values cause progressively longer or shorter delays. Values outside of the range 0 to 255 will cause an \ldblquote Illegal Quantity\rdblquote  error.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 text screen}}}{\fs20 Keep in mind that the speed applies to every character printed to the text screen, regardless of the source, not just to PRINT and PRINT USING statements.\par }\pard\plain \s33\sb120\sa40\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 SPEED 255\par PRINT "Wow! This is slow!"\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 SPEED 0\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Choosing Character Types}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Choosing Character Types\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The ASCII character set}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ASCII character set}}}{\fs20  you normally use to display characters uses 96 printable characters, numbered 32 to 127. Printing characters with an ordinal value from 0 to 31 sometimes causes something to happen, depending on the console driver, but it never results in a character being displayed on the screen. (See Appendix B, }{\i\fs20 Console Control Codes}{\fs20 , for a description of what actually happens for these characters.)\par The display hardware that paints characters on your monitor has 256 character images. That leaves room for 160 characters other than the ASCII character set. When Apple\rquote s engineers designed the Apple\~II}{\fs18 GS}{\fs20  ROMs, they made use of those extra characters to give you a complete inverse ASCII character set, printing black on white rather than the standard white on black, as well as for 32 extra images called mousetext characters that don\rquote t look like any normal printing character. That\rquote s where their creativity ran out, though. There are still 32 available characters, but rather than creating 32 new images, Apple\rquote s engineers repeated the uppercase letters and a few special characters that appear near them in the ASCII character chart.\par The commands described in this section give you access to all of these characters.\par Here\rquote s a short program that displays all of the characters in your computer\rquote s character generator, along with the output from a standard Apple\~II}{\fs18 GS}{\fs20 .\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 ! Clear the screen\par HOME\par FOR I = 0 TO 16\par   PRINT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 ! Set up the line addresses\par DIM L(15)\par L(0) = 1024\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 L(8) = 1064\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 FOR I = 1 TO 7\par   L(I) = L(0) + I * 128\par   L(I + 8) = L(8) + I * 128\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 ! Display the characters\par FOR R = 0 TO 15\par   FOR C = 0 TO 15\par     POKE L(R) + C, R + C * 16\par   NEXT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\qc\fi360\sb40\keepn\widctlpar\adjustright {\fs20 {\pict{\*\picprop\shplid1037{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex67\picscaley66\piccropl0\piccropr0\piccropt0\piccropb0\picw227\pich266\picwgoal4540\pichgoal5320\macpict\bliptag2061862417\blipupi72{\*\blipuid 7ae586119477b1a97fa14465add16d82}1f1a00000000010a00e31101a00082a03039a0008e01000a0000000002e8025398001e00000000010a00e800000000010a00e300000000010a00e3000107007fe6ff01e00005e5ff01e00005e5ff01e00005e5ff01e00005e5ff01e0001f10f9cfef3f80fe73ffbffb3f90fe03fe3ff0feff098ffe3ff0ffefffffe0001f10f9cfef3f80fe73ffbffb3f90fe03fe3ff0feff098ffe3ff0ffefffffe0001f1dfa2fe8bf80fe8bff7ff9ff88fe03fddff77fffff77fddff77ff7ffffe0001f1dfa2fe8bf80fe8bff7ff9ff88fe03fddff77fffff77fddff77ff7ffffe0001f1dfaafe8bf80fe9bfc9ff8ff84fef3fd5ff77fffff67fd5ff77ffbff0fe0001f1dfaafe8bf80fe9bfc9ff8ff84fef3fd5ff77fffff67fd5ff77ffbff0fe0001f10faefef3f80feabf80fe07f80fe8bfd1ff0feff0357fd1ff0feff0277e0001f10faefef3f80feabf80fe07f80fe8bfd1ff0feff0357fd1ff0feff0277e0001f10facfe83f80fecbf81ff8ff80fe8bfd3ff7feff0337fd3ff7feff0277e0001f10facfe83f80fecbf81ff8ff80fe8bfd3ff7feff0337fd3ff7feff0277e0001f10fa0fe83f80fe8bf81ff9ff80fef3fdfff7feff0377fdfff7feff020fe0001f10fa0fe83f80fe8bf81ff9ff80fef3fdfff7feff0377fdfff7feff020fe0001f10f9efe83f80fe73fc0ffbff80fe83fe1ff7feff038ffe1ff7feff027fe0001f10f9efe83f80fe73fc0ffbff80fe83fe1ff7feff038ffe1ff7feff027fe000150df80fe03f80fe03fc9fe43f80fe83f4ff027fe000150df80fe03f80fe03fc9fe43f80fe83f4ff027fe0001e17f88fe73f88fe23ffbfffbf80fe03ff7ff8fff7ffdfff7ff8fdff01e0001e17f88fe73f88fe23ffbfffbf80fe03ff7ff8fff7ffdfff7ff8fdff01e0001f18f94fe8bf88fe63ff7ffdbf80fe03febff77ff7ff9ffebff77ffeff01e0001f18f94fe8bf88fe63ff7ffdbf80fe03febff77ff7ff9ffebff77ffeff01e0001f1dfa2fe8bf88fe23fc9ffdff9cfe7bfddff77ff7ffdffddff77fe3ff87e0001f1dfa2fe8bf88fe23fc9ffdff9cfe7bfddff77ff7ffdffddff77fe3ff87e0001f1dfa2fe8bf88fe23fbefe03f82fe8bfddff77ff7ffdffddff77ffdff77e0001f1dfa2fe8bf88fe23fbefe03f82fe8bfddff77ff7ffdffddff77ffdff77e0001f1dfbefeabf88fe23fbdff07f9efe8bfc1ff57ff7ffdffc1ff57fe1ff77e0001f1dfbefeabf88fe23fbdff07f9efe8bfc1ff57ff7ffdffc1ff57fe1ff77e0001f10fa2fe93f80fe23fbdff8ffa2fe7bfddff6feff09dffddff6ffddff87e0001f10fa2fe93f80fe23fbdff8ffa2fe7bfddff6feff09dffddff6ffddff87e0001f1dfa2fe6bf88fe73fd6ffdbf9efe0bfddff97ff7ff8ffddff97fe1fff7e0001f1dfa2fe6bf88fe73fd6ffdbf9efe0bfddff97ff7ff8ffddff97fe1fff7e000150df80fe03f80fe03fc9fffbf80fe0bf4ff02f7e000150df80fe03f80fe03fc9fffbf80fe0bf4ff02f7e0001f06fbcfef3f94fe73feff13bfa0fe03fc3ff0ffebff8ffc3ff0ffdfffffe0001f06fbcfef3f94fe73feff13bfa0fe03fc3ff0ffebff8ffc3ff0ffdfffffe0001f1dfa2fe8bf94fe8bfffffdbfa0fe03fddff77febff77fddff77fdfffffe0001f1dfa2fe8bf94fe8bfffffdbfa0fe03fddff77febff77fddff77fdfffffe0001f1dfa2fe8bf94fe0bfdfff8ffbcfebbfddff77febfff7fddff77fc3ff47e0001f1dfa2fe8bf94fe0bfdfff8ffbcfebbfddff77febfff7fddff77fc3ff47e0001f10fbcfef3f80fe33fcfff07fa2fec3fc3ff0feff09cffc3ff0ffddff3fe0001f10fbcfef3f80fe33fcfff07fa2fec3fc3ff0feff09cffc3ff0ffddff3fe0001f10fa2fea3f80fe43fc7fe03fa2fe83fddff5feff09bffddff5ffddff7fe0001f10fa2fea3f80fe43fc7fe03fa2fe83fddff5feff09bffddff5ffddff7fe0001f10fa2fe93f80fe83fc3ffdffa2fe83fddff6feff097ffddff6ffddff7fe0001f10fa2fe93f80fe83fc3ffdffa2fe83fddff6feff097ffddff6ffddff7fe0001f1dfbcfe8bf80fefbfc9ffdbfbcfe83fc3ff77fffff07fc3ff77fc3ff7fe0001f1dfbcfe8bf80fefbfc9ffdbfbcfe83fc3ff77fffff07fc3ff77fc3ff7fe000140df80fe03f80fe03fdefffbf80fe03f3ff01e000140df80fe03f80fe03fdefffbf80fe03f3ff01e0001e17f9cfe73f94fefbf80fffff80fe03fe3ff8ffebff07fe3ff8fdff01e0001e17f9cfe73f94fefbf80fffff80fe03fe3ff8ffebff07fe3ff8fdff01e0001f18fa2fe8bf94fe0bfddfffff80fe03fddff77febfff7fddff77ffeff01e0001f18fa2fe8bf94fe0bfddfffff80fe03fddff77febfff7fddff77ffeff01e0001f1dfa0fe83fbefe13febfffff9efe7bfdfff7ffc1ffeffdfff7ffe1ff87e0001f1dfa0fe83fbefe13febfffff9efe7bfdfff7ffc1ffeffdfff7ffe1ff87e0001f1dfa0fe73f94fe33ff7fe03fa0fe83fdfff8ffebffcffdfff8ffdfff7fe0001f1dfa0fe73f94fe33ff7fe03fa0fe83fdfff8ffebffcffdfff8ffdfff7fe0001f1dfa0fe0bfbefe0bff7fffffa0fe73fdffff7fc1fff7fdffff7fdfff8fe0001f1dfa0fe0bfbefe0bff7fffffa0fe73fdffff7fc1fff7fdffff7fdfff8fe0001f1dfa2fe8bf94fe8bfebfffffa0fe0bfddff77febff77fddff77fdffff7e0001f1dfa2fe8bf94fe8bfebfffffa0fe0bfddff77febff77fddff77fdffff7e0001f1df9cfe73f94fe73fd5fffff9efef3fe3ff8ffebff8ffe3ff8ffe1ff0fe0001f1df9cfe73f94fe73fd5fffff9efef3fe3ff8ffebff8ffe3ff8ffe1ff0fe000140df80fe03f80fe03f80fffff80fe03f3ff01e000140df80fe03f80fe03f80fffff80fe03f3ff01e0001f1dfbcfefbf88fe13ffffefff82fe43fc3ff07ff7ffeffc3ff07ffdffbfe0001f1dfbcfefbf88fe13ffffefff82fe43fc3ff07ff7ffeffc3ff07ffdffbfe0001f1dfa2fe23f9efe33ffefefff82fe43fddffdffe1ffcffddffdfffdffbfe0001f1dfa2fe23f9efe33ffefefff82fe43fddffdffe1ffcffddffdfffdffbfe0001f1dfa2fe23fa8fe53ffdfefff9efef3fddffdffd7ffaffddffdffe1ff0fe0001f1dfa2fe23fa8fe53ffdfefff9efef3fddffdffd7ffaffddffdffe1ff0fe0001f1dfa2fe23f9cfe93fbbfefffa2fe43fddffdffe3ff6ffddffdffddffbfe0001f1dfa2fe23f9cfe93fbbfefffa2fe43fddffdffe3ff6ffddffdffddffbfe0001f1dfa2fe23f8afefbfd7fefffa2fe43fddffdfff5ff07fddffdffddffbfe0001f1dfa2fe23f8afefbfd7fefffa2fe43fddffdfff5ff07fddffdffddffbfe0001f1dfa2fe23fbcfe13feffefffa2fe4bfddffdffc3ffeffddffdffddffb7e0001f1dfa2fe23fbcfe13feffefffa2fe4bfddffdffc3ffeffddffdffddffb7e0001f1dfbcfe23f88fe13feffefff9efe33fc3ffdfff7ffeffc3ffdffe1ffcfe0001f1dfbcfe23f88fe13feffefff9efe33fc3ffdfff7ffeffc3ffdffe1ffcfe000140df80fe03f80fe03ffffe03f80fe03f3ff01e000140df80fe03f80fe03ffffe03f80fe03f3ff01e0001f18fbefe8bfb0fefbf80ffdff80fe03fc1ff77fcfff07fc1ff77ffeff01e0001f18fbefe8bfb0fefbf80ffdff80fe03fc1ff77fcfff07fc1ff77ffeff01e0001f18fa0fe8bfb2fe83f81ffeff80fe03fdfff77fcdff7ffdfff77ffeff01e0001f18fa0fe8bfb2fe83f81ffeff80fe03fdfff77fcdff7ffdfff77ffeff01e0001f1dfa0fe8bf84fef3f82fff7f9cfe8bfdfff77ffbff0ffdfff77fe3ff77e0001f1dfa0fe8bf84fef3f82fff7f9cfe8bfdfff77ffbff0ffdfff77fe3ff77e0001f1dfbcfe8bf88fe0bfc4fe03fa2fe8bfc3ff77ff7fff7fc3ff77fddff77e0001f1dfbcfe8bf88fe0bfc4fe03fa2fe8bfc3ff77ff7fff7fc3ff77fddff77e0001f1dfa0fe8bf90fe0bfa8fff7fbefe8bfdfff77feffff7fdfff77fc1ff77e0001f1dfa0fe8bf90fe0bfa8fff7fbefe8bfdfff77feffff7fdfff77fc1ff77e0001f1dfa0fe8bfa6fe8bf90ffeffa0fe9bfdfff77fd9ff77fdfff77fdfff67e0001f1dfa0fe8bfa6fe8bf90ffeffa0fe9bfdfff77fd9ff77fdfff77fdfff67e0001f1dfbefe73f86fe73f90ffdff9efe6bfc1ff8fff9ff8ffc1ff8ffe1ff97e0001f1dfbefe73f86fe73f90ffdff9efe6bfc1ff8fff9ff8ffc1ff8ffe1ff97e000140df80fe03f80fe03f80fffff80fe03f3ff01e000140df80fe03f80fe03f80fffff80fe03f3ff01e0001f1dfbefe8bf90fe3bf81ff57f8cfe03fc1ff77fefffc7fc1ff77ff3ffffe0001f1dfbefe8bf90fe3bf81ff57f8cfe03fc1ff77fefffc7fc1ff77ff3ffffe0001f1dfa0fe8bfa8fe43f81feabf92fe03fdfff77fd7ffbffdfff77fedffffe0001f1dfa0fe8bfa8fe43f81feabf92fe03fdfff77fd7ffbffdfff77fedffffe0001f1dfa0fe8bfa8fe83f81ff57f90fe8bfdfff77fd7ff7ffdfff77fefff77e0001f1dfa0fe8bfa8fe83f81ff57f90fe8bfdfff77fd7ff7ffdfff77fefff77e0001f1dfbcfe8bf90fef3f91feabfbcfe8bfc3ff77fefff0ffc3ff77fc3ff77e0001f1dfbcfe8bf90fef3f91feabfbcfe8bfc3ff77fefff0ffc3ff77fc3ff77e0001f1dfa0fe8bfaafe8bfb1ff57f90fe8bfdfff77fd5ff77fdfff77fefff77e0001f1dfa0fe8bfaafe8bfb1ff57f90fe8bfdfff77fd5ff77fdfff77fefff77e0001f1dfa0fe53fa4fe8bffffeabf90fe53fdfffaffdbff77fdfffaffefffafe0001f1dfa0fe53fa4fe8bffffeabf90fe53fdfffaffdbff77fdfffaffefffafe0001f1dfa0fe23f9afe73fb0ff57f90fe23fdfffdffe5ff8ffdfffdffefffdfe0001f1dfa0fe23f9afe73fb0ff57f90fe23fdfffdffe5ff8ffdfffdffefffdfe000140df80fe03f80fe03f90feabf80fe03f3ff01e000140df80fe03f80fe03f90feabf80fe03f3ff01e0001f18f9efe8bf88fefbf80feabf80fe03fe1ff77ff7ff07fe1ff77ffeff01e0001f18f9efe8bf88fefbf80feabf80fe03fe1ff77ff7ff07fe1ff77ffeff01e0001f18fa0fe8bf88fe0bfffff57f80fe03fdfff77ff7fff7fdfff77ffeff01e0001f18fa0fe8bf88fe0bfffff57f80fe03fdfff77ff7fff7fdfff77ffeff01e0001f1dfa0fe8bf88fe13f80feabf9cfe8bfdfff77ff7ffeffdfff77fe3ff77e0001f1dfa0fe8bf88fe13f80feabf9cfe8bfdfff77ff7ffeffdfff77fe3ff77e0001f1dfa0feabf80fe23fffff57fa2fe8bfdfff57fffffdffdfff57fddff77e0001f1dfa0feabf80fe23fffff57fa2fe8bfdfff57fffffdffdfff57fddff77e0001f1dfa6feabf80fe43f80feabfa2feabfd9ff57fffffbffd9ff57fddff57e0001f1dfa6feabf80fe43f80feabfa2feabfd9ff57fffffbffd9ff57fddff57e0001f1dfa2fedbf80fe43fffff57f9efeabfddff27fffffbffddff27fe1ff57e0001f1dfa2fedbf80fe43fffff57f9efeabfddff27fffffbffddff27fe1ff57e0001f1df9efe8bf80fe43ffffeabf82fedbfe1ff77fffffbffe1ff77ffdff27e0001f1df9efe8bf80fe43ffffeabf82fedbfe1ff77fffffbffe1ff77ffdff27e000170df80fe03f80fe03f80ff57f9cfe03f6ff04e3ffffe000170df80fe03f80fe03f80ff57f9cfe03f6ff04e3ffffe0001f1dfa2fe8bf88fe73ff7fffffa0fe03fddff77ff7ff8ffddff77fdfffffe0001f1dfa2fe8bf88fe73ff7fffffa0fe03fddff77ff7ff8ffddff77fdfffffe0001f1dfa2fe8bf90fe8bfefff07fa0fe03fddff77fefff77fddff77fdfffffe0001f1dfa2fe8bf90fe8bfefff07fa0fe03fddff77fefff77fddff77fdfffffe0001f1dfa2fe53fa0fe8bfdffefbfbcfe8bfddffaffdfff77fddffaffc3ff77e0001f1dfa2fe53fa0fe8bfdffefbfbcfe8bfddffaffdfff77fddffaffc3ff77e0001f1dfbefe23fa0fe73f80fefffa2fe53fc1ffdffdfff8ffc1ffdffddffafe0001f1dfbefe23fa0fe73f80fefffa2fe53fc1ffdffdfff8ffc1ffdffddffafe0001f1dfa2fe53fa0fe8bfdffefffa2fe23fddffaffdfff77fddffaffddffdfe0001f1dfa2fe53fa0fe8bfdffefffa2fe23fddffaffdfff77fddffaffddffdfe0001f1dfa2fe8bf90fe8bfeffefffa2fe53fddff77fefff77fddff77fddffafe0001f1dfa2fe8bf90fe8bfeffefffa2fe53fddff77fefff77fddff77fddffafe0001f1dfa2fe8bf88fe73ff7fe03fa2fe8bfddff77ff7ff8ffddff77fddff77e0001f1dfa2fe8bf88fe73ff7fe03fa2fe8bfddff77ff7ff8ffddff77fddff77e0001306f80fe03f80fe03fdff0280fe03f3ff01e0001306f80fe03f80fe03fdff0280fe03f3ff01e0001e06f9cfe8bf88fe73fdff1288fe03fe3ff77ff7ff8ffe3ff77ff7ffffe0001e06f9cfe8bf88fe73fdff1288fe03fe3ff77ff7ff8ffe3ff77ff7ffffe0001e06f88fe8bf84fe8bfdff0d80fe03ff7ff77ffbff77ff7ff77ffeff01e0001e06f88fe8bf84fe8bfdff0d80fe03ff7ff77ffbff77ff7ff77ffeff01e0001f1df88fe53f82fe8bffffe07f98fe8bff7ffafffdff77ff7ffaffe7ff77e0001f1df88fe53f82fe8bffffe07f98fe8bff7ffafffdff77ff7ffaffe7ff77e0001f06f88fe23f82fe7bfeff13bf88fe8bff7ffdfffdff87ff7ffdfff7ff77e0001f06f88fe23f82fe7bfeff13bf88fe8bff7ffdfffdff87ff7ffdfff7ff77e0001f06f88fe23f82fe0bfeff13bf88fe8bff7ffdfffdfff7ff7ffdfff7ff77e0001f06f88fe23f82fe0bfeff13bf88fe8bff7ffdfffdfff7ff7ffdfff7ff77e0001f06f88fe23f84fe13feff13bf88fe7bff7ffdfffbffefff7ffdfff7ff87e0001f06f88fe23f84fe13feff13bf88fe7bff7ffdfffbffefff7ffdfff7ff87e0001f1df9cfe23f88fee3ffffe03f9cfe0bfe3ffdfff7ff1ffe3ffdffe3fff7e0001f1df9cfe23f88fee3ffffe03f9cfe0bfe3ffdfff7ff1ffe3ffdffe3fff7e000150df80fe03f80fe03fd5fffff80fe73f4ff028fe000150df80fe03f80fe03fd5fffff80fe73f4ff028fe0001f12f82fefbf88fe03ff7fffbf84fe03ffdff07ff7feff07dff07ffbffffe0001f12f82fefbf88fe03ff7fffbf84fe03ffdff07ff7feff07dff07ffbffffe0001f12f82fe0bfaafe03ff7fffbf80fe03ffdfff7fd5feff02dfff7ffeff01e0001f12f82fe0bfaafe03ff7fffbf80fe03ffdfff7fd5feff02dfff7ffeff01e0001f1df82fe13f9cfe23ff7fffbf8cfefbffdffeffe3ffdfffdffefff3ff07e0001f1df82fe13f9cfe23ff7fffbf8cfefbffdffeffe3ffdfffdffefff3ff07e0001f12f82fe23f88fe03ff7fffbf84fe13ffdffdfff7feff07dffdfffbffefe0001f12f82fe23f88fe03ff7fffbf84fe13ffdffdfff7feff07dffdfffbffefe0001f1df82fe43f9cfe23fb6fffbf84fe23ffdffbffe3ffdfffdffbfffbffdfe0001f1df82fe43f9cfe23fb6fffbf84fe23ffdffbffe3ffdfffdffbfffbffdfe0001f1dfa2fe83faafe03fd5fffbf84fe43fddff7ffd5fffffddff7fffbffbfe0001f1dfa2fe83faafe03fd5fffbf84fe43fddff7ffd5fffffddff7fffbffbfe0001f1df9cfefbf88fe03fe3fffbfa4fefbfe3ff07ff7fffffe3ff07fdbff07e0001f1df9cfefbf88fe03fe3fffbfa4fefbfe3ff07ff7fffffe3ff07fdbff07e000170df80fe03f80fe03ff7fffbf98fe03f6ff04e7ffffe000170df80fe03f80fe03ff7fffbf98fe03f6ff04e7ffffe0001f11fa2fefbf80fe03ff7ffdffa0fe3bfddff07ffeff08fddff07fdfffc7e0001f11fa2fefbf80fe03ff7ffdffa0fe3bfddff07ffeff08fddff07fdfffc7e0001f1dfa4fec3f88fe03fe3ff8ffa0fe63fdbff3fff7fffffdbff3ffdfff9fe0001f1dfa4fec3f88fe03fe3ff8ffa0fe63fdbff3fff7fffffdbff3ffdfff9fe0001f1dfa8fec3f88fe23fd5ff07fa2fe63fd7ff3fff7ffdffd7ff3ffddff9fe0001f1dfa8fec3f88fe23fd5ff07fa2fe63fd7ff3fff7ffdffd7ff3ffddff9fe0001f1dfb0fec3fbefe03fb6fe03fa4fec3fcfff3ffc1fffffcfff3ffdbff3fe0001f1dfb0fec3fbefe03fb6fe03fa4fec3fcfff3ffc1fffffcfff3ffdbff3fe0001f1dfa8fec3f88fe23ff7ff07fb8fe63fd7ff3fff7ffdffd7ff3ffc7ff9fe0001f1dfa8fec3f88fe23ff7ff07fb8fe63fd7ff3fff7ffdffd7ff3ffc7ff9fe0001f1dfa4fec3f88fe23ff7ff8ffa4fe63fdbff3fff7ffdffdbff3ffdbff9fe0001f1dfa4fec3f88fe23ff7ff8ffa4fe63fdbff3fff7ffdffdbff3ffdbff9fe0001f1dfa2fefbf80fe43ff7ffdffa2fe3bfddff07fffffbffddff07fddffc7e0001f1dfa2fefbf80fe43ff7ffdffa2fe3bfddff07fffffbffddff07fddffc7e000140df80fe03f80fe03ff7fffff80fe03f3ff01e000140df80fe03f80fe03ff7fffff80fe03f3ff01e0001d0efa0fe03f80fe13f80fe03f98fe23fdfcff01effdfeff04e7ffdfe0001d0efa0fe03f80fe13f80fe03f98fe23fdfcff01effdfeff04e7ffdfe0001e06fa0fe83f80fe23fdff0588fe23fdfff7feff09dffdfff7fff7ffdfe0001e06fa0fe83f80fe23fdff0588fe23fdfff7feff09dffdfff7fff7ffdfe0001e06fa0fe43f80fe43fdff0588fe23fdfffbfeff09bffdfffbfff7ffdfe0001e06fa0fe43f80fe43fdff0588fe23fdfffbfeff09bffdfffbfff7ffdfe0001e06fa0fe23f80fe83fdff0588fe23fdfffdfeff097ffdfffdfff7ffdfe0001e06fa0fe23f80fe83fdff0588fe23fdfffdfeff097ffdfffdfff7ffdfe0001e06fa0fe13f88fe43fdff1288fe23fdfffefff7ffbffdfffefff7ffdfe0001e06fa0fe13f88fe43fdff1288fe23fdfffefff7ffbffdfffefff7ffdfe0001e06fa0fe0bf88fe23fdff1288fe23fdffff7ff7ffdffdffff7ff7ffdfe0001e06fa0fe0bf88fe23fdff1288fe23fdffff7ff7ffdffdffff7ff7ffdfe0001e06fbefe03f90fe13fdff129cfe23fc1fffffefffeffc1fffffe3ffdfe0001e06fbefe03f90fe13fdff129cfe23fc1fffffefffeffc1fffffe3ffdfe000150df80fe03f80fe03ffffe03f80fe23f4ff02dfe000150df80fe03f80fe03ffffe03f80fe23f4ff02dfe0001f11fa2fefbf80fe03ffeffaff80fee3fddff07ffeff08fddff07fffff1fe0001f11fa2fefbf80fe03ffeffaff80fee3fddff07ffeff08fddff07fffff1fe0001f11fb6fe1bf80fe03ffeffaff80fe33fc9ffe7ffeff08fc9ffe7fffffcfe0001f11fb6fe1bf80fe03ffeffaff80fe33fc9ffe7ffeff08fc9ffe7fffffcfe0001f1dfaafe1bf80fefbffefe23fb6fe33fd5ffe7fffff07fd5ffe7fc9ffcfe0001f1dfaafe1bf80fefbffefe23fb6fe33fd5ffe7fffff07fd5ffe7fc9ffcfe0001f1dfaafe1bfbefe03feefffffaafe1bfd5ffe7fc1fffffd5ffe7fd5ffe7e0001f1dfaafe1bfbefe03feefffffaafe1bfd5ffe7fc1fffffd5ffe7fd5ffe7e0001f1dfa2fe1bf80fefbfcefe23faafe33fddffe7fffff07fddffe7fd5ffcfe0001f1dfa2fe1bf80fefbfcefe23faafe33fddffe7fffff07fddffe7fd5ffcfe0001f11fa2fe1bf80fe03f80ffaffaafe33fddffe7ffeff08fddffe7fd5ffcfe0001f11fa2fe1bf80fe03f80ffaffaafe33fddffe7ffeff08fddffe7fd5ffcfe0001f11fa2fefbf80fe03fcfffaffa2fee3fddff07ffeff08fddff07fddff1fe0001f11fa2fefbf80fe03fcfffaffa2fee3fddff07ffeff08fddff07fddff1fe0001407f80fe03f80fe03fefeff0280fe03f3ff01e0001407f80fe03f80fe03fefeff0280fe03f3ff01e0001d0ffa2fe03f80fe43f81fe03f80fe6bfddffdff02bffddffdff0297e0001d0ffa2fe03f80fe43f81fe03f80fe6bfddffdff02bffddffdff0297e0001d0ffa2fe03f80fe23f81fffbf80feb3fddffdff02dffddffdff024fe0001d0ffa2fe03f80fe23f81fffbf80feb3fddffdff02dffddffdff024fe0001f10fb2fe23f80fe13f81fffbfbcfe03fcdffdfeff09effcdffdffc3ffffe0001f10fb2fe23f80fe13f81fffbfbcfe03fcdffdfeff09effcdffdffc3ffffe0001f10faafe53f80fe0bf81ff9bfa2fe03fd5ffafeff09f7fd5ffaffddffffe0001f10faafe53f80fe0bf81ff9bfa2fe03fd5ffafeff09f7fd5ffaffddffffe0001f1dfa6fe8bf80fe13f81ff9bfa2fe03fd9ff77fffffeffd9ff77fddffffe0001f1dfa6fe8bf80fe13f81ff9bfa2fe03fd9ff77fffffeffd9ff77fddffffe0001e0ffa2fe03f80fe23f81fffbfa2fe03fddffdff09dffddfffffddffffe0001e0ffa2fe03f80fe23f81fffbfa2fe03fddffdff09dffddfffffddffffe0001f1dfa2fe03f88fe43f81fffbfa2fe03fddffffff7ffbffddfffffddffffe0001f1dfa2fe03f88fe43f81fffbfa2fe03fddffffff7ffbffddfffffddffffe000140df80fe03f80fe03f81fe03f80fe03f3ff01e000140df80fe03f80fe03f81fe03f80fe03f3ff01e0001c0ff9cfe03f80fe73f9bfefff80fe03fe3ffdff028ffe3ffcff01e0001c0ff9cfe03f80fe73f9bfefff80fe03fe3ffdff028ffe3ffcff01e0001e16fa2fe03f82fe8bff3fefff80feabfddffffffdff77fddffdff0257e0001e16fa2fe03f82fe8bff3fefff80feabfddffffffdff77fddffdff0257e0001f1dfa2fe03f84fe13fe3fefff9cfe53fddffffffbffeffddfffffe3ffafe0001f1dfa2fe03f84fe13fe3fefff9cfe53fddffffffbffeffddfffffe3ffafe0001f1dfa2fe03f88fe23fc0fefffa2feabfddffffff7ffdffddfffffddff57e0001f1dfa2fe03f88fe23fc0fefffa2feabfddffffff7ffdffddfffffddff57e0001f1dfa2fe03f90fe23fe3fefffa2fe53fddfffffefffdffddfffffddffafe0001f1dfa2fe03f90fe23fe3fefffa2fe53fddfffffefffdffddfffffddffafe0001f1dfa2fe03fa0fe03ff3fefffa2feabfddfffffdffffffddfffffddff57e0001f1dfa2fe03fa0fe03ff3fefffa2feabfddfffffdffffffddfffffddff57e0001e0ff9cfe03f80fe23ffbfefff9cfe03fe3ffdff09dffe3fffffe3ffffe0001e0ff9cfe03f80fe23ffbfefff9cfe03fe3ffdff09dffe3fffffe3ffffe0001d11f80fffff80fe03f84fefff80fe03ffffe03ffcff01e03ffeff01e0001d11f80fffff80fe03f84fefff80fe03ffffe03ffcff01e03ffeff01e00005e5ff01e00005e5ff01e00005e5ff01e00005e5ff01e00005e5ff01e000a0008fa00083ff}}{\fs20 \par }\pard \s25\qc\fi360\sb80\widctlpar\adjustright {\fs20 The Apple\~II}{\fs18 GS}{\fs20  Printing Characters\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 INVERSE\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 INVERSE\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 INVERSE statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 After using the INVERSE statement, all of the normal printable characters print as black on white rather than white on black.\par To change back to standard characters, use NORMAL.\par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 INVERSE\par FOR I = 32 TO 127\par   PRINT CHR$(I);\par NEXT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NORMAL\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 MOUSETEXT\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 MOUSETEXT\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 MOUSETEXT statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 After using the MOUSETEXT statement, all of the ASCII characters from \ldblquote @\rdblquote  to \ldblquote _\rdblquote , which includes the uppercase alphabetic characters, print as a series of special display characters known as the mousetext character set. These characters have ordinal values ranging from 64 for \ldblquote @\rdblquote  to 95 for \ldblquote _\rdblquote . All other characters print as inverse characters.\par For example, the lines\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 MOUSETEXT\par PRINT "A";\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NORMAL\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 will print the open apple mousetext character on your screen.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The table shows the mousetext characters next to the printing character you use to print the given mousetext character. The snippet displays the entire ASCII character set with MOUSETEXT enabled, which shows all of these characters on your screen, plus the inverse characters you will see if you print other characters with MOUSETEXT enabled.\par }\pard \s25\qc\fi360\sb40\keepn\widctlpar\adjustright {\fs20 {\pict{\*\picprop\shplid1038{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex66\picscaley67\piccropl0\piccropr0\piccropt0\piccropb0\picw208\pich259\picwgoal4160\pichgoal5180\macpict\bliptag1313970051\blipupi72{\*\blipuid 4e519783f202d0e75423334be1367579}0cf800000000010300d01101a00082a0008e01000a0000000002e8025398001a00000000010300d000000000010300d000000000010300d0000102e70002e70002e70002e70002e70002e70002e700170300700040fd0002880080fd0002f00130fd000088fe00170300700040fd0002880080fd0002f00130fd000088fe00170300880080fd00018801fc0002880180fd00038803e000170300880080fd00018801fc0002880180fd00038803e000170300a80360fd00018802fc00028801c0fd000350041000170300a80360fd00018802fc00028801c0fd000350041000180300b807f0fd0002f807f0fd0002f007e0fd000320040000180300b807f0fd0002f807f0fd0002f007e0fd000320040000170300b007e0fd00018802fc00028001c0fd000350040000170300b007e0fd00018802fc00028001c0fd0003500400001703008007e0fd00018801fc0002800180fd0003880400001703008007e0fd00018801fc0002800180fd0003880400001703007803f0fd0002880080fd00018001fc00038807f0001703007803f0fd0002880080fd00018001fc00038807f0000c0300000360f5000106f0f9000c0300000360f5000106f0f90002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e700150300200040fd000070fb0002700010fd000088fe00150300200040fd000070fb0002700010fd000088fe00150300500080fd000020fb0002880090fd000088fe00150300500080fd000020fb0002880090fd000088fe00160300880360fd000020fb0002880080fd00035007e000160300880360fd000020fb0002880080fd00035007e000160300880410fd000020fb00028807f0fd000320001000160300880410fd000020fb00028807f0fd000320001000160300f80420fd000020fb0002a803e0fd000320001000160300f80420fd000020fb0002a803e0fd000320001000160300880420fd000020fb00029001c0fd000320001000160300880420fd000020fb00029001c0fd000320001000160300880290fd000070fb0002680090fd00032007f000160300880290fd000070fb0002680090fd00032007f000100300000360fc000102a0fb000010f900100300000360fc000102a0fb000010f90002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e700160100f0fb0002080080fd0002f00010fd0003f8001000160100f0fb0002080080fd0002f00010fd0003f800100016010088fb0002080080fd0002880090fd00030800100016010088fb0002080080fd0002880090fd0003080010001702008802fc0002080080fd00028801c0fd0003100010001702008802fc0002080080fd00028801c0fd000310001000170200f003fc0002080080fd0002f003e0fd000320001000170200f003fc0002080080fd0002f003e0fd000320001000180300880380fd0002080490fd0002a007f0fd000340001000180300880380fd0002080490fd0002a007f0fd0003400010001803008803c0fd00028802a0fd0002900080fd0003800010001803008803c0fd00028802a0fd0002900080fd000380001000180300f00360fd00027001c0fd0002880090fd0003f8001000180300f00360fd00027001c0fd0002880090fd0003f8001000120300000210fb000080fb000010fb00011000120300000210fb000080fb000010fb0001100002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e7001603007007f0fd0002880080fd000070fb0003f80080001603007007f0fd0002880080fd000070fb0003f8008000160300880220fd00029001c0fd000088fb0003c001c000160300880220fd00029001c0fd000088fb0003c001c000160300800140fd0002a002a0fd000080fb0003c003e000160300800140fd0002a002a0fd000080fb0003c003e000180300800080fd0002c00490fd00027007f0fd0003c007f000180300800080fd0002c00490fd00027007f0fd0003c007f000160300800080fd0002a00080fd000008fb0003c003e000160300800080fd0002a00080fd000008fb0003c003e000160300880140fd0002900080fd000088fb0003c001c000160300880140fd0002900080fd000088fb0003c001c0001603007002a0fd0002880080fd000070fb0003f80080001603007002a0fd0002880080fd000070fb0003f80080000b03000007f0fb000080f2000b03000007f0fb000080f20002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e700140100f0fb00028007f0fd0001f804fb000207f000140100f0fb00028007f0fd0001f804fb000207f000140300880010fd000080fb00012004fc000080fe00140300880010fd000080fb00012004fc000080fe00140300880020fd000080fb00012004fc000040fe00140300880020fd000080fb00012004fc000040fe00140300880440fd000080fb00012004fc000020fe00140300880440fd000080fb00012004fc000020fe00140300880280fd000080fb00012004fc000010fe00140300880280fd000080fb00012004fc000010fe001302008801fc000080fb00012004fc000008fe001302008801fc000080fb00012004fc000008fe000f0200f001fc0000f8fb00012004f8000f0200f001fc0000f8fb00012004f8000bf1000107f0fc000207f0000bf1000107f0fc000207f00002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e700180300f807f0fd0002880010fd0002880080fd0003f8014000180300f807f0fd0002880010fd0002880080fd0003f80140001803008007e0fd0002d80010fd0002880040fd0003180140001803008007e0fd0002d80010fd0002880040fd0003180140001803008007d0fd0002a80010fd0002880020fd0003180770001803008007d0fd0002a80010fd0002880020fd000318077000170300f003b0fd0002a80110fd00028807f0fd000018fe00170300f003b0fd0002a80110fd00028807f0fd000018fe00180300800570fd0002880310fd0002880020fd000318077000180300800570fd0002880310fd0002880020fd0003180770001803008006f0fd00028807f0fd0002880040fd0003180140001803008006f0fd00028807f0fd0002880040fd000318014000170300f806f0fd00018803fc0002700080fd0003f8014000170300f806f0fd00018803fc0002700080fd0003f80140000b03000007f0fc000001f1000b03000007f0fc000001f10002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e700170300f807e0fd00028807e0fd00028802a0fc000207f000170300f807e0fd00028807e0fd00028802a0fc000207f0001603008007e0fd00028807e0fd0002880550fb000110001603008007e0fd00028807e0fd0002880550fb000110001803008007e0fd0002c807e0fd00028802a0fd0003200010001803008007e0fd0002c807e0fd00028802a0fd000320001000180300f006e0fd0002a807e0fd0002880550fd000350019000180300f006e0fd0002a807e0fd0002880550fd0003500190001803008004e0fd00029807e0fd00028802a0fd0003880190001803008004e0fd00029807e0fd00028802a0fd00038801900014010080fb00028807e0fd0002500550fb0001100014010080fb00028807e0fd0002500550fb000110001603008004f0fd00028807e0fd00022002a0fb000110001603008004f0fd00028807e0fd00022002a0fb000110001503000006f0fc000107e0fc00010550fc000207f0001503000006f0fc000107e0fc00010550fc000207f00002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e7001703007807f0fd0002700640fd0002880550fc00020400001703007807f0fd0002700640fd0002880550fc000204000015010080fb00028800c0fd00028802a0fc000204000015010080fb00028800c0fd00028802a0fc00020400001703008007f0fd00028801c0fd0002880550fc00020400001703008007f0fd00028801c0fd0002880550fc000204000015010080fb00028803f0fd0002a802a0fc000204000015010080fb00028803f0fd0002a802a0fc00020400001703009807f0fd00028801c0fd0002a80550fc00020400001703009807f0fd00028801c0fd0002a80550fc000204000015010088fb00028800c0fd0002d802a0fc000204000015010088fb00028800c0fd0002d802a0fc000204000015010078fb0002700040fd0002880550fc000204000015010078fb0002700040fd0002880550fc00020400001703000007f0fc000107b0fc000102a0fe000401fc0400001703000007f0fc000107b0fc000102a0fe000401fc04000002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e70002e700a0008fa00083ff}}{\fs20 \par }\pard \s25\qc\fi360\sb40\widctlpar\adjustright {\fs20 Mousetext Characters\par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 MOUSETEXT\par FOR I = 32 TO 127\par   PRINT CHR$(I);\par NEXT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NORMAL\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 NORMAL\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 NORMAL\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 NORMAL statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Switches to standard ASCII character output. NORMAL is used after MOUSETEXT or INVERSE to switch back to the default character set.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Reading Text}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Reading Text\tcl2}}}{\fs28 \par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 INPUT [ '#' expression ',' ] [ string-expression ';' ] l-value [ ',' l-value ]*\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 'INPUT'\tcl3}}}{\v\fs20 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 INPUT statement\bxe }}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 INPUT statement\:see also LINE INPUT}{\txe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 INPUT is used to read values from the keyboard}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 keyboard}}}{\fs20  or a disk file. These values can be numbers or strings. Multiple inputs on the same typed line or line from a disk file are separated with commas.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Reading from Disk Files}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Reading from Disk Files\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 INPUT normally reads from the keyboard. To read from a disk file, follow INPUT with the #}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 #}}}{\fs20  character and a value that matches the file number for an open file. For example, the statement\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 INPUT #4, A$\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 reads a string from a disk file.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 See OPEN for details on file numbers.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Prompts}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Prompts\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 INPUT will print a prompt on the screen to indicate it expects input. If you don\rquote t do anything special this prompt character is a question mark. For example, if you use the statement\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 INPUT NAME$\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 INPUT will print a ? character on the screen, then wait for a typed response. You can supply your own prompt string, followed by a semicolon, like this:\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 INPUT "What is your name? "; NAME$\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par You can use string expressions for the prompt, not just string constants. If the first string is followed by a semicolon, it is treated as a prompt and printed. If it is followed by a comma, it is treated like an input variable. In that case, you get the ? prompt and the INPUT statement expects a string value on the input line.\par Here\rquote s a couple of examples to illustrate this subtle point. This first INPUT statement reads two comma separated strings from the keyboard:\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 INPUT A$, NAME$\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par This INPUT statement uses A$ as a prompt, reading one string from the keyboard:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 A$ = "What is your name?"\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 INPUT A$; NAME$\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par Of course, you don\rquote t want ?}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ?}}}{\fs20  characters showing up all over the screen while reading a disk file. If you've specified a file number using the #}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 #}}}{\fs20  parameter INPUT won\rquote t print a default prompt. You can still add your own prompt, perhaps as a debugging aid, and that will still get printed to the text screen.\par If you don\rquote t want a prompt and you\rquote re reading input from the keyboard, code an empty string as the prompt, like this:\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 INPUT ""; NAME$\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Multiple Inputs}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Multiple Inputs\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 You can read several values with a single INPUT statement. For each value you are reading, the INPUT statement scans the text typed from the keyboard, forming a chunk of characters. This chunk of characters starts with the first unread character and extends until a comma or end of line mark is found. All of the characters that are read are converted into a string or a number, depending on the type of the parameter. The resulting value is saved.\par The rules used to convert the text to numbers are the same as the rules used to convert program symbols to numbers. You can put spaces before the first character of the number and after the last, but not between the characters of the number. You can use leading plus or minus signs, decimal points, and exponents.\par Putting this all together, here\rquote s an example that shows how to read three values from a line.\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 INPUT "Enter a point in 3 dimensions: "; X, Y, Z\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 This INPUT statement prints the prompt, then looks for three numbers. The numbers are separated by commas. One acceptable response is\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 45, .098, 2.99E4\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par Several things can go wrong with the input process. The worst is typing more inputs than the program expects. For example, if you use the INPUT statement\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 INPUT "Please enter your name: "; A$\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 and the response is\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 Fred Pennymaker, Jr.\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 the INPUT statement sees two values, one before the comma and one after. This causes the program to stop with a run-time error. You can intercept it with an ONERR-GOTO, but that's a lot of work for such a simple error.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Almost as bad is trying to read a number, but getting input that isn\rquote t a number. For example, if the INPUT statement\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 INPUT A\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 gets the response\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 4ever\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 it will choke, beeping the speaker and printing the error message \ldblquote Number expected: Reenter\rdblquote . The program won\rquote t move on until it gets a valid number.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 If the INPUT statement expects more inputs than it gets, it waits for more input. If the statement\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 INPUT "Please enter your city and state: "; CITY$, STATE$\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 gets the response\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 Indianapolis\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 the program waits for more input. If the person using the program realizes what's happening, and types\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 Indiana\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 the program continues along with no problems. The end of line marker is a perfectly acceptable substitute for a comma. But a blank screen and an apparently frozen program can be fairly confusing for an unsuspecting user of the program.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 All of these problems mean that INPUT is a great command for quickly hacking out a solution to a problem when you are the only person who would use the program, or, at worst, you will be available to help and train the people who will use the program. For programs that will be used more than a few times, though, it's worth the extra work to use LINE INPUT and parse the input yourself.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 LINE INPUT [ '#' expression ',' ] [ string-expression ';' ] l-value [ ',' l-value ]*\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 LINE INPUT\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LINE INPUT statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 LINE INPUT is almost the same command as INPUT. The only difference is that it doesn\rquote t use the comma to mark multiple inputs. It can still use multiple inputs, but each input must be typed on a separate line.\par INPUT is a simple, effective way to get typed responses into a program. It works well if the person using the program understands its limitations. But there are many limitations to the INPUT statement, both in terms of error handling and because you can never use a comma in an input string.\par LINE INPUT solves these problems. For reading lines of text, it can\rquote t be beat. The problems arise when you need to read values from the line\emdash in other words, your application would work better with INPUT, but you need to create a program that will handle bogus typed responses better than INPUT allows.\par In this situation, you can use LINE INPUT to read lines of text, then parse it yourself. This takes a fair amount of work, and the techniques involved vary greatly from application to application. In general, though, keep in mind that the VAL command can convert strings to numbers.\par If your application requires extremely sophisticated parsing, consider compiler books. They deal with the issue of taking a text stream, breaking it into parts, handling errors, and acting on the result in great detail. For most applications, you won\rquote t need all of the techniques you\rquote ll find in a good compiler book, but there is no better place to learn how to handle text.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Positioning the Cursor}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Positioning the Cursor\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 text screen}}}{\fs20 Simple programs that don\rquote t use the desktop environment of the Apple\~II}{\fs18 GS}{\fs20  display information on the text screen. For many programs, it\rquote s a good choice, offering ease of programming in exchange for a less capable user interface. There is an intermediate between the simple printer style input and output that always places new text at the bottom of the screen and the full desktop interface, though. It relies on accurately positioning text information on the screen at specified positions. In fact, by combining the ability to place text anywhere on the screen with the special mousetext character set, you can recreate a good substitute for the desktop environment using the text screen.\par As used in this section, the cursor is the position on the text display where the next printed character will appear. When a program expects input, this location is traditionally marked with a special character of some sort. GSoft\~BASIC uses an inverted box; a flashing character and an underscore character are also common. When this section uses the term cursor, though, it is not implying that the cursor position is marked in any special way, it is simply referring to a screen position.\par The commands in this section deal with detecting the position of the cursor and changing it to a new location. They all treat the text display more or less like a graphics display that uses characters instead of pixels. The top left position on the display is column 1, row 1; the lower right corner is column 80, row 24.\par There are actually three ways to deal with the text screen. The methods described here are very general across platforms that use the BASIC language. While the specific commands often vary from one platform to another, the capabilities you see here are available in almost all implementations of BASIC.\par Another method relies on the console driver used to place characters on the screen. Almost all displays have a driver that places characters on the screen, scrolls text, and allows some other cursor controls. The Apple\~II}{\fs18 GS}{\fs20  is no exception; Appendix B, }{\i\fs20 Console Control Codes}{\fs20 , describes the special characters you can use to control the screen in GSoft\~BASIC.\par Finally, you can resort to placing characters directly on the text display, bypassing all of the console drivers. You can do this with BASIC\rquote s POKE statement, as shown in the example for }{\i\fs20 Choosing Character Types}{\fs20 , earlier in this chapter. You can find the addresses for the screen itself in several places, including }{\i\fs20 The Apple\~II}{\i\fs18 GS}{\i\fs20  Hardware Reference}{\fs20 .\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CSRLIN\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 CSRLIN\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CSRLIN function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns the vertical position, or line number, of the cursor. Lines are numbered starting from 1 at the top of the text display to 24 at the bottom.\par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 SUB MOVEUP\par ! Move up one line, stopping at the top of the screen\par IF CSRLIN > 1 THEN\par   VTAB CSRLIN - 1\par END IF\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SUB\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 HOME\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 HOME\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 HOME statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Clears the screen, displaying spaces in all character positions, and sets the cursor position to the top left corner of the display.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 HTAB expression\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 HTAB\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 HTAB statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 tabs}}}{\fs20 Sets the horizontal cursor position to the given value. This changes the cursor\rquote s column.\par Columns are numbered starting from 1 at the left side of the screen to 80 at the right side. Values outside this range are allowed, as long as they can be converted to an INTEGER. Values less than 1 are treated as 1, while values greater than 80 are treated as 80.\par }\pard\plain \s33\sb120\sa40\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 SUB MOVERIGHT\par ! Move right one column, stopping at the right edge of the screen\par IF POS < 80 THEN\par   HTAB POS + 1\par END IF\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SUB\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 POS [ '(' expression ')' ]\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 POS\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 POS statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns the horizontal position, or column number, of the cursor. Columns are numbered from 1 at the left edge of the screen to 80 at the right edge.\par Some implementations of BASIC require a dummy parameter for POS to function. It doesn\rquote t do anything, but it must be there. GSoft\~BASIC doesn\rquote t require a parameter to POS, but in the interest of making programs easier to move between implementations of BASIC, it allows a parameter. In GSoft\~BASIC, the expression can evaluate to anything at all, and is not used. The value must be an INTEGER in some implementations of BASIC, though, so if you use it at all, use an INTEGER constant.\par }\pard\plain \s33\sb120\sa40\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 SUB MOVELEFT\par ! Move left one column, stopping at the left edge of the screen\par IF POS > 1 THEN\par   HTAB POS - 1\par END IF\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SUB\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 VTAB expression\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 VTAB\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 VTAB statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Sets the vertical cursor position to the given value. This changes the cursor\rquote s line.\par Lines are numbered from 1 at the top of the screen to 24 at the bottom. Values outside this range are allowed, as long as they can be converted to an INTEGER. Values less than 1 are treated as 1, while values greater than 24 are treated as 24.\par }\pard\plain \s33\sb120\sa40\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 SUB MOVEDOWN\par ! Move down one line, stopping at the bottom of the screen\par IF CSRLIN < 24 THEN\par   VTAB CSRLIN + 1\par END IF\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SUB\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Imbedding Data In The Program}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Imbedding Data In The Program\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The statements in this section are used to read data that is imbedded in a program. For example, a program that calculates the positions of planets might encode the orbital parameters for the planets in DATA statements, reading them into arrays using READ.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 DATA any-ascii-characters\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 DATA\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DATA statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 DATA statements provide input for READ statements. The information is stored exactly as you type it, more or less like a comment. This text is scanned by the READ statement using exactly the same rules as for the INPUT statement.\par In general, you will place one or more values in a DATA statement, separating the values with commas.\par DATA statements can hold either strings or numbers. The strings can be enclosed in quote marks, but this isn\rquote t required. Using quote marks preserves leading space characters and the case of characters; without them, leading spaces are removed and lowercase letters are converted to uppercase.\par These sample DATA statements review the rules for coding numbers and strings, which are the same for DATA statements as for lines in BASIC or for INPUT. Any of the DATA statements can be read as a string. The first three lines, which contain two strings each, contain DATA statements that can only be read into a string; attempting to read a non-number into a numeric value will cause an error.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DATA Albany, New York\par DATA Seattle, Washington\par DATA "Santa Fe", "New Mexico"\par DATA 1, $400, -32767\par DATA 1000000, -123456\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 DATA 3.1415, .5, 1e9, -3.4D-6\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 READ l-value [ ',' l-value ]*\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 READ\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 READ statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 READ reads one or more values from DATA statements.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 FUNCTION statement}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SUB statement}}}{\fs20 If READ is in a SUB or FUNCTION, the DATA statement must be in the same SUB or FUNCTION, and if the DATA statement is in the main program, the READ must be there, too. DATA statements in other parts of the program are only visible to a READ in the same part of the program.\par The first READ statement reads the first value from the first DATA statement, placing the value from the DATA statement into the first variable in the READ statement. This process continues, with the READ statement reading data sequentially until all of the parameters have been filled in. The next READ statement picks up where the first left off, reading the next available piece of data from a DATA statement. The number of parameters in each READ and DATA statements don\rquote t have to match. If a READ statement only reads, say, two of the available four pieces of data in a DATA statement, the next READ starts with the third value from the DATA statement. Conversely, if a READ statement reads two values, but only one is left in the current DATA statement, it skips ahead to read another value from the next available DATA statement.\par There are two possible errors, either of which will stop the program with a run time error. You cannot read more data than is available, although you can use RESTORE to start over. You also can\rquote t read a number if the data supplied is not a valid number after removing leading and trailing spaces.\par }\pard\plain \s33\sb120\sa40\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 ! Wavelength data\par DATA "red", "orange", "yellow", "green", "blue", "violet"\par DATA 760, 647, 585, 575, 491, 424, 380\par DIM COLORS$(6)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 DIM WAVELENGTH(6)\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 ! Read the data\par FOR I = 1 TO 6\par   READ COLORS$(I)\par NEXT\par FOR I = 0 TO 6\par   READ WAVELENGTH(I)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 ! Print the table\par PRINT "Color     Wavelength (nm)"\par PRINT "------    ---------------"\par FOR I = 1 TO 6\par   PRINT USING "\\ \\ ### to ###";COLORS$(I), WAVELENGTH(I - 1), WAVELENGTH(I)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 RESTORE\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 RESTORE\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 RESTORE statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 RESTORE resets the pointer used to track which element of a DATA statement will be read next. After RESTORE, the next READ statement reads the first piece of data from the first available DATA statement.\par RESTORE only resents the DATA statement pointer for the procedure in which is appears. For example, if you have DATA statements and READ statements in the main program and use RESTORE in a subroutine, the READ statement in the main program is not affected.\par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DATA 1, 2, 3, 4\par FOR I = 1 TO 4\par   RESTORE\par   FOR J = 1 TO I\par     READ N\par     PRINT N,;\par   NEXT\par   PRINT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \sect }\sectd \lndscpsxn\sbkodd\linex0\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Chapter 14: Disk Files\par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Chapter 14 \endash  Disk Files}{\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\v\f4\fs36\cgrid {\tc {\v Chapter 14 \endash  Disk Files\tcl1}}}{\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 This chapter covers disk access, including commands used to read from and write to disk, commands used to manipulate files on a disk, and commands used to manipulate the directory structure of a disk.\par }\pard \s25\fi360\sb40\keepn\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 INPUT statement}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LINE INPUT statement}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 PRINT statement}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 PRINT USING statement}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Many of the commands normally used to read information from the keyboard}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 keyboard}}}{\fs20  and write information to the computer\rquote s display can also be used to read and write text to disk files. See the previous chapter for information about these commands. The commands described in the last chapter that can also read or write disk files are INPUT, LINE INPUT, PRINT and PRINT USING.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 File Names}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 File Names\tcl2}}}{\fs28 \par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 ProDOS and HFS Names}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 ProDOS and HFS Names\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:names}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 disk names}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 directory names}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file names}}}{\fs20 Files, disks and directories are identified by name. The naming convention is tied to the way information is stored on disk, called the file system. The Apple\~II}{\fs18 GS}{\fs20  supports several file systems, each with different requirements for file names. The two most common file systems used with the Apple\~II}{\fs18 GS}{\fs20  are the ProDOS}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ProDOS}}}{\fs20  file system and the HFS}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 HFS}}}{\fs20  file system.\par ProDOS is the older of the two file systems. It is used on both the Apple\~][ computers using the ProDOS disk operating system and on the Apple\~II}{\fs18 GS}{\fs20  using the ProDOS 16 and the GS/OS}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GS/OS}}}{\fs20  disk operating systems. The boot disk must use the ProDOS file system, and it\rquote s still popular for most other uses because accessing ProDOS disks takes less time than accessing HFS disks.\par ProDOS file names, directory names and volume names are limited to 15 characters. The first character must be an alphabetic character. The remaining characters can be any combination of alphabetic characters, numeric digits and periods. Letter case is preserved on the disk, so a file named \ldblquote bark\rdblquote  will look different than a file named \ldblquote Bark\rdblquote , but the case of the letters is not significant. Whether you use the name \ldblquote Bark\rdblquote  or \ldblquote bark\rdblquote , you will access the same file.\par HFS}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 HFS}}}{\fs20  is the dominant file system for the Macintosh computer. HFS has two distinct advantages over the ProDOS file system. First, ProDOS disks are limited to 32 megabytes, while standard HFS disks can handle up to 2 gigabytes, which is 2048 megabytes. Variants of HFS now available on the Macintosh can handle even larger volumes. The second advantage of HFS is the file names, which are longer and allow more characters than ProDOS. This allows more natural file names.\par HFS file names and directory names are limited to 31 characters; volume names are limited to 27 characters. Any typable ASCII character except the colon is allowed anywhere in the name. (Technically, it is legal to use non-printing characters in an HFS name, but Apple recommends against it.) As with ProDOS, letter case is preserved when the file is created on disk, but it isn\rquote t significant.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Other File Systems}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Other File Systems\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 While ProDOS and HFS format disks are by far the most common on the Apple\~II}{\fs18 GS}{\fs20 , the GS/OS}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GS/OS}}}{\fs20  operating system actually supports several others to some extent, including Microsoft\rquote s DOS}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DOS}}}{\fs20 , Apple\~Pascal}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 Apple\~Pascal}}}{\fs20 , and Apple\~DOS. GSoft\~BASIC uses GS/OS for all file manipulation, and will support any disk format allowed by GS/OS to the extent GS/OS itself supports the file system.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Devices}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Devices\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 devices}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 device names}}}{\fs20 Each device that can be accessed by the GS/OS disk operating system has at least two, and sometimes three, names. Not all devices are disks, either. It\rquote s possible to use disk input and output commands to drive the screen and keyboard, although that would interfere with the way BASIC handles input and output. }{\v\fs20 .PRINTER driver;}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 printers\:.PRINTER driver}}}{\fs20 Printers are handled using file commands; this is described in more detail in the section }{\i\fs20 Printing,}{\fs20  later in this chapter. Serial ports and networks are also handled as if they were files. In fact, by writing your own GS/OS file driver, you can use disk input and output commands to handle input and output to absolutely any kind of device.\par Each device has one name based on the device number assigned when GS/OS starts. This number is dependent on the exact order the device drivers are loaded, and in some cases on which devices are started, whether they have disks inserted, and which disk is inserted. This device name consists of a period, the letter D, and the device number. For example, device 14 is named \ldblquote .D14\rdblquote . Since these numbers can change, Apple recommends against using device names based on the device number in most situations.\par The second device name is assigned by the device driver. Disks generally have names like \ldblquote .DEV14\rdblquote . A critical device name for GSoft\~BASIC programmers is \ldblquote .PRINTER\rdblquote , which allows you to print to a printer.\par Finally, devices like disk drives generally have one or more volumes. Each of these volumes has another name; this is the name you normally think of for the disk itself. In cases where a disk has a single partition, using the device name based on the number, the device name assigned by the device driver, and the volume name are all equivalent in all of the GSoft\~BASIC commands.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Path Names}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Path Names\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 full path names}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 partial path names}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 directory names}}}{\fs20 Files on disk are organized by directories, also called folders. A directory has a name, just like the disk and file. Each directory can hold files and other directories.\par The full path name is a combination of the volume name, any directory names that apply, and the file name. You need the full path name of a file to uniquely identify the file. The full path name starts with a colon, and the various file names, volume names and directory names are separated by colons.}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 \:}}}{\fs20  You can also use a slash character instead of the colon, but all of the GSoft\~BASIC commands return path names with colon characters separating the parts.\par As an example of path names, we\rquote ll assume we have a disk with information about various cities. The information for each city is stored in a file whose name matches the name of the city. Of course, there are situations where two cities have the same name, although they will be in different countries or different states within the same country.\par Consider the case of Manhattan, Kansas. It\rquote s located in the United States, on the continent of North America. We\rquote ll choose the name Earth for the disk itself. On the disk Earth is a directory named NorthAmerica; this in turn contains a directory named UnitedStates, which has a directory named Kansas. The directory Kansas has a file named Manhattan that holds information about that city. The full path name is\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 :Earth:NorthAmerica:UnitedStates:Kansas:Manhattan\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par Another file containing information about another city by the same name might have the path name\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 :Earth:NorthAmerica:UnitedStates:Illinois:Manhattan\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par The directory UnitedStates contains at least two directories, one named Kansas and the other named Illinois. Each of these directories contains a file named Manhattan. The fact that the file name is the same shows why the full path name is often needed to uniquely identify a file.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 The Default Prefix}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 The Default Prefix\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 directories\:default}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 default prefix\:see directories}{\txe }}}{\fs20 In practice, we don\rquote t generally use the full path name. There is a prefix called the default prefix that identifies a specific directory. In the example above, we might identify a file by first setting the default prefix to\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 :Earth:NorthAmerica:UnitedStates:Kansas:\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 and then using the file name\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 Manhattan\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par This makes a lot of sense if we\rquote re going to access several other files from the same directory. For example, if we\rquote re doing a comparison of cities in Kansas, we might also be accessing files named Topeka, KansasCity and Wichita. All of these would be in the same directory as Manhattan. By setting the default prefix to Kansas first, we can use the short file names for the various cities.\par Another way to use the default prefix is to use partial path names}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 partial path names}}}{\fs20 . If you are comparing Manhattan, Kansas to Manhattan, Illinois, you can set the default prefix to\par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 :Earth:NorthAmerica:UnitedStates:\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 and use the partial path names\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 Kansas:Manhattan\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 and\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 Illinois:Manhattan\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 to access information about the two cities. The difference between the partial path name and a file named Manhattan on a disk named Kansas is that the partial path name does not start with a colon.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Printing}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Printing\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\v\fs20 .PRINTER driver;}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 printers\:.PRINTER driver}}}{\fs20 GSoft\~BASIC comes with a GS/OS}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GS/OS}}}{\fs20  device driver called \ldblquote .PRINTER\rdblquote . When this driver is properly installed in your System directory by the installer, you can open .PRINTER as a file and write text information to the file. In a nutshell, that\rquote s how you print.\par The .PRINTER driver is not a sophisticated graphics printer like the ones typically used with desktop programs. That happens to be its main advantage. Since it only handles text, and doesn\rquote t deal with fonts, the .PRINTER driver is simple to install and use. It will work with almost any Apple\~II}{\fs18 GS}{\fs20  printer, too. Any printer that can be used from AppleWorks will work using the .PRINTER driver.\par For the most part, printing works just like printing text to a text file. The only special feature you need to know about is ejecting pages. Printing the character CHR$(12) ejects the current page, starting the next line at the top of a fresh page. Manually ejecting a page from some printers will confuse the printer driver, though, so you should write your programs so they eject pages by printing CHR$(12).\par Here\rquote s a short program that shows just how easy it is to print using disk commands.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 OPEN ".PRINTER" FOR OUTPUT AS #1\par PRINT #1 "Hello, printer."\par PRINT #1 CHR$(12)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 CLOSE #1\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par Various printers respond in different ways to the non-printing characters. }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 tabs}}}{\fs20 Most don\rquote t do anything with tab characters, but GSoft\~BASIC handles text output in such a way that you don\rquote t generally need tab characters. Check with your printer to see exactly what special characters it respects, then use CHR$ to send them to the printer.}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 printers\:control characters}}}{\fs20 \par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 The GS/OS Option}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 The GS/OS Option\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 There are two different ways to deal with files from GSoft\~BASIC. The commands you see described in this manual are fairly common in modern implementations of BASIC. They are relatively easy to use and fairly powerful. You can bypass them entirely, though, using direct calls to the GS/OS}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GS/OS}}}{\fs20  disk operating system. Programs that access GS/OS directly tend to be larger and more complicated than programs that use the GSoft\~BASIC commands, but there are some things you just can\rquote t do from GSoft\~BASIC. For some kinds of programs, disk access is also significantly faster if you use GS/OS commands.\par In general, we recommend using the built-in commands unless you have a compelling reason for calling GS/OS directly. If you need to make GS/OS calls, refer to }{\i\fs20 Apple\~II}{\i\fs18 GS}{\i\fs20  GS/OS Reference}{\fs20 .\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 File Numbers}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 File Numbers\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file numbers}}}{\fs20 Most of the commands that deal with files refer to the file by a number. This number usually appears right after a #}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 #}}}{\fs20  character.\par The file number is a number you pick when you open the file with the OPEN statement. It must be an integer value from 1 to 32767. While almost all of the examples in this section will use the constant 1, this is not a requirement. You can use an expression to calculate the file number, perhaps using a loop like\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 FOR I% = 1 TO 5\par   CLOSE #I%\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 to close several open files.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 File Input and Output Examples}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 File Input and Output Examples\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Rather than inserting short, generally meaningless examples of file input and output throughout the chapter, most of the examples of file input and output are collected here. While the examples tend to be short, they still illustrate the basic techniques used to create, write and read files in GSoft\~BASIC.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Line Oriented Text Files}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Line Oriented Text Files\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 text files}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ASCII files}}}{\fs20 There are two very simple programs below. The first creates a new file and writes a few lines of text. It uses the simple PRINT statement to create the information, but you could also use PRINT USING or PUT to create the file.\par The second program opens the file created by the first and writes the lines to the screen. LINE INPUT isn\rquote t stopped by commas, so it handles all of the lines gracefully. This shows the basic techniques for dealing with any file organized as a series of variable length lines of text.\par EOF is used to test for the end of the file. The program can read any number of lines of text without knowing in advance how many lines are in the file.\par You can open the file from most editors, including the editor you use to edit GSoft\~BASIC programs.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Program That Writes the File\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 ! Create a new file and write some test lines.\par OPEN "temp" FOR OUTPUT AS #1\par PRINT #1, "This is a test."\par PRINT #1, "This is only a test."\par PRINT #1, "If this had been a real program, we would have written something useful."\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 CLOSE #1\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Program That Reads the File\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 ! Read a text file and print its contents.\par OPEN "temp" FOR INPUT AS #1\par WHILE NOT EOF (1)\par   LINE INPUT #1, A$\par   PRINT A$\par WEND\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 CLOSE #1\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Binary Files}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Binary Files\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 binary files}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:BIN}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 floating-point}}}{\fs20 There is a fundamental difference between binary files and text files. In a text file, everything is converted to ASCII characters and saved in text representation. The INTEGER value 100, which normally uses two bytes of memory, is expanded to three one byte characters. The conversion process takes time, generally requires more memory, and can lead to loss of precision if you are reading and writing floating-point values.\par Binary files save information in the same raw internal format used to save the information in the computer\rquote s memory. An INTEGER takes two bytes, regardless of the value. SINGLE values always use four bytes, and there is no loss of precision as the number is written to disk and read back in. Since the number does not need to be converted to and from text, reading and writing the value is much, much faster than reading and writing text files, and since each value has the same length, you have the option of using random access files.\par This program creates a new binary file and writes three SINGLE values to the file.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 OPEN "temp" FOR BINARY AS #1\par DIM A(2)\par A(0) = 1.2\par A(1) = 3.4\par A(2) = 5.6\par FOR I% = 0 TO 2\par   PUT #1, , A(I%)\par NEXT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 CLOSE #1\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 This program reads the file, writing the values to the text screen.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 OPEN "temp" FOR BINARY AS #1\par WHILE NOT EOF (1)\par   GET #1, , A\par   PRINT A\par WEND\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 CLOSE #1\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par Most of the programs in this section are rather short, but here's one very practical program. It reads any file and prints the contents. The contents of the file are printed both as hexadecimal values and, when possible, as ASCII values. You can use this program to examine the various files created by these samples to see exactly how they are stored on disk.\par The sample is also on your GSoft\~BASIC disk in the directory :GSoft:Samples:Text.Samples. If you have installed GSoft BASIC on a hard drive, the file is also in the Samples folder there.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 File Dump Example\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\pard\plain \s31\fi360\keepn\widctlpar\adjustright \v\f6\fs18\cgrid {\xe {\v\fs18 }{\v\fs18 samples\:Hexadecimal File Dump}}}{\fs18 ! ---------------------------------------------------\par !\par ! Dump a file\par !\par ! This program prints the contents of any file in\par ! both hexadecimal and ASCII form.\par !\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 ! ---------------------------------------------------\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 !\par ! Set up the variables\par !\par DIM FILENAME AS STRING\par DIM COUNT AS LONG\par DIM BYTES(15) AS BYTE\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 DIM LINECOUNT AS INTEGER\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 !\par ! Get the name of the file to dump\par !\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 INPUT "File to dump: ";FILENAME\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 !\par ! Open and dump the file\par !\par OPEN FILENAME FOR INPUT AS #1\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 LINECOUNT = 0\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 WHILE NOT EOF (1)\par   GET #1, , BYTES(LINECOUNT)\par   LINECOUNT = LINECOUNT + 1\par   IF LINECOUNT = 16 THEN\par     CALL PRINTLINE(COUNT, BYTES(), LINECOUNT)\par     COUNT = COUNT + 16\par     LINECOUNT = 0\par   END IF\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 WEND\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 IF LINECOUNT <> 0 THEN\par   CALL PRINTLINE(COUNT, BYTES(), LINECOUNT)\par END IF\par CLOSE #1\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 ! ---------------------------------------------------\par !\par ! PRINTLINE - Print one line from the file\par !\par ! Parameters:\par !    count - number of bytes before this line\par !    bytes - line of bytes\par !    lineCount - number of bytes in this line\par !\par ! ---------------------------------------------------\par SUB PRINTLINE(COUNT AS LONG , BYTES() AS BYTE , LINECOUNT AS INTEGER )\par !\par ! Print the file displacement\par !\par CALL PRINTBYTE(COUNT / 256)\par CALL PRINTBYTE(COUNT)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PRINT ":";\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 !\par ! Print the hexadecimal bytes\par !\par FOR GROUP = 0 TO 3\par   PRINT " ";\par   FOR OFFSET = 0 TO 3\par     IF GROUP * 4 + OFFSET < LINECOUNT THEN\par       CALL PRINTBYTE(BYTES(GROUP * 4 + OFFSET))\par     ELSE\par       PRINT "  ";\par     END IF\par   NEXT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 !\par ! Print the line as ASCII text\par !\par PRINT "  '";\par FOR OFFSET = 0 TO 15\par   IF OFFSET < LINECOUNT THEN\par     IF (BYTES(OFFSET) >= 32) AND (BYTES(OFFSET) < 127) THEN\par       PRINT CHR$ (BYTES(OFFSET));\par     ELSE\par       PRINT " ";\par     END IF\par   ELSE\par     PRINT " ";\par   END IF\par NEXT\par PRINT "'"\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SUB\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 ! ---------------------------------------------------\par !\par ! PRINTBYTE - Print one byte\par !\par ! Parameters:\par !    b - byte to print\par !\par ! ---------------------------------------------------\par SUB PRINTBYTE(B AS INTEGER )\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 DIM B1 AS INTEGER\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 !\par B = B - 256 * CINT (B / 256)\par B1 = B / 16\par B = B - B1 * 16\par IF B1 > 9 THEN\par   PRINT CHR$ ( ASC ("A") + B1 - 10);\par ELSE\par   PRINT CHR$ ( ASC ("0") + B1);\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END IF\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 IF B > 9 THEN\par   PRINT CHR$ ( ASC ("A") + B - 10);\par ELSE\par   PRINT CHR$ ( ASC ("0") + B);\par END IF\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SUB\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Backtracking in Files}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Backtracking in Files\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 binary files}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:BIN}}}{\fs20 Many file formats hold a varying amount of information and use a length at the start of the information to tell the program reading the file what to expect. An example is the JPEG graphics format, which uses an integer value to indicate how much graphic information follows. Unfortunately, due to the fact the graphics files are frequently compressed as they are written to disk, you may not know how much graphic data there is until it is written!\par A common way to handle this problem is to record your position in a file, write a dummy length, then write the data. Once the data has been written, you can determine how many bytes were written, then move back in the file and write the length. This common technique illustrates the use of the LOC function to determine where you are in the file, the position parameter of the PUT function to write the length to a specific location in the file, and EOF and SEEK to move to the end of the file to continue writing a new block of information.\par Assuming you have opened file 1 as an output file, your subroutine to write the graphics data can start with the statements\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 P1& = LOC (1)\par L% = 0\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PUT #1, , L%\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 This records the location in the file where the length of the data should be written, then writes a value of 0 to occupy the correct number of bytes for the length. The program will fill this value in later, when it is known.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Your program would continue with the code that actually writes the information, possibly calling subroutines to write some of the data. There is no need to keep track of how many bytes are written. Once all of the information is written, the program records the new file position, backs up and fills in the length of the data, then resets the file position to the position after all of the data, getting ready for any additional output. The code looks like this:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 P2& = LOC (1)\par L% = P2& - P1&\par PUT #1, P1& + 1, L%\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 SEEK #1, LOF (1) + 1\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par The two programs that follow put this idea to work in a simple example. The first program reads numbers you type until you enter 0. These numbers are written to a file that starts with the number of INTEGER values in the file. It then repeats the process, so you end up with a file containing two variable length lists of numbers. The second program reads the file.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Program That Writes the File\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\pard\plain \s31\fi360\keepn\widctlpar\adjustright \v\f6\fs18\cgrid {\xe {\v\fs18 }{\v\fs18 samples\:Binary File I/O 1}}}{\fs18 ! ---------------------------------------------------\par !\par ! Read two variable length lists of integers from the\par ! keyboard and write them to a file.\par !\par ! The user indicates the end of a list by typing 0.\par !\par ! In the file, each list of integers is preceded by\par ! the number of integers in the list.\par !\par ! ---------------------------------------------------\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 !\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 OPEN "temp" FOR BINARY AS #1\par PRINT "Enter any number of integers; enter 0 to end the list."\par CALL ENTERNUMBERS(1)\par PRINT "Enter another list of integers, again using 0 to end the list."\par CALL ENTERNUMBERS(1)\par CLOSE #1\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 ! ---------------------------------------------------\par !\par ! EnterNumbers - enter a variable length list of numbers\par !\par ! Parameters:\par !    file - file number to write the list to\par !\par ! ---------------------------------------------------\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 !\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 SUB ENTERNUMBERS(FILE AS INTEGER )\par DIM OFFSET AS LONG\par DIM ENDOFFSET AS LONG\par DIM COUNT AS INTEGER\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 DIM VALUE AS INTEGER\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 !\par ! Record the file position & reserve space for the length\par !\par OFFSET = LOC (FILE)\par COUNT = 0\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PUT #FILE, , COUNT\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 !\par ! Get the list of integers and write them to the file\par !\par DO\par   INPUT "";VALUE\par   IF VALUE <> 0 THEN PUT #FILE, , VALUE\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 LOOP UNTIL VALUE = 0\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 !\par ! Go back and write the length\par !\par ENDOFFSET = LOC (FILE)\par COUNT = (ENDOFFSET - OFFSET) / SIZEOF ( INTEGER ) - 1\par PUT #FILE, OFFSET + 1, COUNT\par SEEK #FILE, LOF (FILE) + 1\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SUB\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Program That Reads the File\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM COUNT AS INTEGER , I AS INTEGER , VALUE AS INTEGER\par !\par OPEN "temp" FOR BINARY AS #1\par WHILE NOT EOF (1)\par   GET #1, , COUNT\par   PRINT "List of ";COUNT;" numbers:"\par   FOR I = 1 TO COUNT\par     GET #1, , VALUE\par     PRINT USING "######";VALUE\par   NEXT\par WEND\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 CLOSE #1\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Reading An Entire File}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Reading An Entire File\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 binary files}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:BIN}}}{\fs20 Reading a file in small pieces is convenient, but generally slow, especially if you need to manipulate various pieces of a file in a more or less random order. With today\rquote s computers and their large amounts of memory, it\rquote s often practical to read an entire file into memory at once, manipulate the file, and write it back to disk. The LOF command makes this easy by reporting how many bytes or records are in a file.\par The programs below put this idea to work. The first program writes a random number of INTEGER values to a file. The number of integers is between 50 and 99. The second program reads this file into an array whose size is set after the size of the file is known. It then sorts the list of random numbers and writes them back to the file and to the text screen.\par Compare this example to the next one, which uses RANDOM files to do the same thing.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Program That Writes the File\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\pard\plain \s31\fi360\keepn\widctlpar\adjustright \v\f6\fs18\cgrid {\xe {\v\fs18 }{\v\fs18 samples\:Binary File I/O 2}}}{\fs18 OPEN "temp" FOR BINARY AS #1\par FOR I% = 1 TO 50 * (1.0 + RND (1))\par   V% = CINT (10000 * RND (1))\par   PUT #1, , V%\par NEXT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 CLOSE #1\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Program That Reads the File\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM COUNT AS INTEGER\par DIM I AS INTEGER , J AS INTEGER\par DIM V AS INTEGER\par ! Read the file\par OPEN "temp" FOR BINARY AS #1\par COUNT = LOF (1) / 2\par DIM A(COUNT - 1) AS INTEGER\par FOR I = 0 TO COUNT - 1\par   GET #1, , A(I)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 ! Sort the numbers\par FOR I = 0 TO COUNT - 2\par   FOR J = I + 1 TO COUNT - 1\par     IF A(J) < A(I) THEN\par       V = A(I)\par       A(I) = A(J)\par       A(J) = V\par     END IF\par   NEXT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 ! Write the values\par SEEK #1, 1\par FOR I = 0 TO COUNT - 1\par   PUT #1, , A(I)\par   PRINT A(I), ;\par NEXT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 CLOSE #1\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Random Access Files}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Random Access Files\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 random access files}}}{\fs20 Random access files use a fixed record size so a piece of information can be quickly located in the file. A common application is a database, such as a mailing list or recipe file. Our example will use a simple file of integers, performing a disk based sort on the file. Compare this with the previous sample, which does essentially the same thing, but reads the file into memory, sorts it in memory, then writes it back to disk.\par There are advantages and disadvantages to both methods. Reading the entire file into memory is definitely faster, and by using ALLOCATE to grab memory you can handle virtually any file smaller than the available memory on your computer. Some files are bigger than available memory, though, and in some cases you may not want to use all of the available memory even if the file is small enough. For example, a desk accessory shouldn\rquote t grab all of the available memory, since the main application may need it. Your application may have need for other large chunks of memory, too. Some databases are so large that the time required to read the entire file and write it back to disk is also a serious problem. In all situations where the impact of loading the file into memory is inappropriate, random access files work very well.\par The program below works on the same file of random integers produced by the previous example. It reads values from the file using random access, sorting the numbers and writing them back to the file.}{\b\fs20 \par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Random Access Program\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\pard\plain \s31\fi360\keepn\widctlpar\adjustright \v\f6\fs18\cgrid {\xe {\v\fs18 }{\v\fs18 samples\:Random Access File I/O}}}{\fs18 DIM COUNT AS INTEGER\par DIM I AS INTEGER , J AS INTEGER\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 DIM V1 AS INTEGER , V2 AS INTEGER\par !\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 OPEN "temp" FOR RANDOM AS #1 LEN SIZEOF ( INTEGER )\par COUNT = LOF (1)\par FOR I = 1 TO COUNT - 1\par   GET #1, I, V1\par   FOR J = I + 1 TO COUNT\par     GET #1, J, V2\par     IF V2 < V1 THEN\par       PUT #1, I, V2\par       PUT #1, J, V1\par       V1 = V2\par     END IF\par   NEXT\par   PRINT V1, ;\par NEXT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 CLOSE #1\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Opening and Closing Files}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Opening and Closing Files\tcl2}}}{\fs28 \par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CLOSE [ '#' expression ]\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 CLOSE\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CLOSE statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Closes a file previously opened with OPEN.\par If a file number is used, CLOSE closes the specific file specified by the expression. If no file number is used, CLOSE closes all files that have been opened by OPEN. CLOSE with no file number is a quick, easy way to close all open files, especially in a program that may have exited with an error.\par See }{\i\fs20 File Input and Output Examples}{\fs20 , earlier in this chapter, for an example.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 OPEN filename FOR io-kind AS '#' expression [ LEN expression ]\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 OPEN\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 OPEN statement\bxe }}}{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 AS}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 text files}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 random access files}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 binary files}}}{\fs20 Files must be opened before you can use most disk operations. The OPEN statement opens the file, assigning a file number to the file in the process. From the time the file is opened until you are finished with the file, all file commands will use the number you assign to identify the file. Once you are finished with a file, use CLOSE to close the file.\par Files are also opened in one of five specific ways. You can read from a file opened for input, but you can\rquote t write to it, for example. If you open a file for input and need to write to it, you must close the file and open it again.\par }{\f6\fs20 filename}{\fs20  is the name of the file to open. See }{\i\fs20 File Names}{\fs20 , earlier in this chapter, for information about legal file names.\par The file may be opened in any of the following ways by substituting the token shown for the }{\f6\fs20 io-kind}{\fs20  field.\par \par }\pard \s25\fi-1080\li1440\ri360\sb40\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \adjustright {\fs20 token\tab use\par }\pard \s25\fi-1080\li1440\ri360\sb40\widctlpar\adjustright {\f6\fs20 OUTPUT}{\fs20 \tab The file is opened for output. If the file already exists, any old contents are lost.\par }{\f6\fs20 INPUT}{\fs20 \tab The file is opened for input. The file must already exist, but the file type does not matter. Input starts from the beginning of the file.\par }{\f6\fs20 APPEND}{\fs20 \tab The file is opened for output. If the file already exists, the old contents are not lost. New information is written after all of the old information.\par }{\f6\fs20 RANDOM}{\fs20 \tab The file is opened for random access. The LEN field is required; each record written to or read from the file will use that number of bytes.\par }{\f6\fs20 BINARY}{\fs20 \tab The file is opened for input and output. Old information is not lost. New information written immediately after the file is open will overwrite the information at the start of the file.\par \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The value following }{\f6\fs20 #}{\fs20  is used in subsequent file commands to identify the opened file. This value can range from 1 to 32767. No two open files may use the same file number, but once the file is closed, the number is available for use by another OPEN statement. While there are many file numbers available, only 8 files can be open at one time.\par If used, the }{\f6\fs20 LEN}{\fs20  expression gives the internal buffer size used to cache input and output. This field is required for random access files, and matches the length of one random access record. For all other file types, larger values use more RAM but generally result in faster disk input and output, while lower values save RAM but result in slower input and output.\par Opening a file for INPUT or APPEND implies that the file already exists. For all of the other file kinds, the file may exist or may not exist. If it already exists, the old file type is not changed.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:TXT}}}{\fs20 If a file is opened for OUTPUT, and it doesn\rquote t already exist, it will be created as a new file with nothing in the file. The type of the file will be TXT, the generic text file type for the Apple\~II}{\fs18 GS}{\fs20 . Normally you\rquote ll use commands like PRINT to fill this kind of file with text. Pretty much any program that reads text will be able to read the resulting file.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file types\:BIN}}}{\fs20 Opening a file that doesn\rquote t exist for RANDOM or BINARY creates an empty file whose type is BIN. This is the generic Apple\~II}{\fs18 GS}{\fs20  file type for files that contain something other than text. Very few programs will be able to read the resulting file, but you can read and process the file from other GSoft\~BASIC programs.\par See }{\i\fs20 File Input and Output Examples}{\fs20 , earlier in this chapter, for an example.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Reading and Writing Files}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Reading and Writing Files\tcl2}}}{\fs28 \par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 EOF '(' expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 EOF\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 EOF function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:size}}}{\fs20 Returns 0 if there is unread information in a file, and -1 if there is not.\par EOF is used to see if all of the information in a file has been read. You generally test for the end of the file, and if the end of the file has not yet been reached, you read and process more information.\par See }{\i\fs20 Line Oriented Text Files}{\fs20 , earlier in this chapter, for an example.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 GET [ '#' expression ',' [ expression ] ',' ] l-value\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 GET\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GET statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Reads a single value from the keyboard}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 keyboard}}}{\fs20  or a disk file.\par The first expression is the file number, assigned when the file is opened with OPEN.\par The next expression is the location in the file to write the value. For random access files, this is the record number; for all other files, this is a byte number. In both cases, the first value in the file is numbered 1.\par If no file is specified, the variable must be a string. A single character is read from the keyboard, converted to a string, and saved in the variable. If no characters have been typed, GET waits for a key before returning.\par If a file is given, GET reads binary information from the file. While strings are still treated as single characters, any other data type can be read, including integers, real numbers, records or pointers.\par The ability of GET to read records as well as the simple data types makes it a very powerful choice for binary file input. Coupled with PUT, you can quickly write and read records in their internal, binary format. While you are restricted to fixed length record in random access files}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 random access files}}}{\fs20 , there is no such restriction with other file types, so you can read any data written by other programs, too. If all else fails, GET can read the file byte by byte.\par GET is used in several of the examples in }{\i\fs20 File Input and Output Examples}{\fs20 , earlier in this chapter.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 LOC '(' expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 LOC\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LOC function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Random access files use fixed length records. }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 random access files}}}{\fs20 In a random access file, LOC returns the number of the record most recently read or written. Contrast this with all other kinds of files, where LOC returns the number of bytes that have been read or written.\par While LOC can be used for many different purposes, the classic purpose is to record the current position in a file. Combined with SEEK, this lets you write subroutines that can remember a file location and return to it at a later point.\par See }{\i\fs20 Backtracking in Files}{\fs20 , earlier in this chapter, for an example.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 LOF '(' expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 LOF\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LOF function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 random access files}}}{\fs20 Returns the number of records in a random access file, or bytes in any other kind of file.\par See }{\i\fs20 Reading An Entire File}{\fs20 , earlier in this chapter, for an example.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 PUT '#' expression ',' [ expression ] ',' l-value\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 PUT\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 PUT statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 random access files}}}{\fs20 PUT writes values to files. It is usually used for binary or random access files, although technically it can be used with any file type.\par The first expression is the file number, assigned when the file is opened with OPEN.\par The next expression is the location in the file to write the value. For random access files, this is the record number; for all other files, this is a byte number. In both cases, the first value in the file is numbered 1.\par }{\f6\fs20 l-value}{\fs20  is the value to write to the file.\par PUT is used in several of the examples in }{\i\fs20 File Input and Output Examples}{\fs20 , earlier in this chapter.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SEEK '#' expression ',' expression\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 SEEK\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SEEK statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Sets the file so the next read or write occurs at the position indicated by the second expression.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 random access files}}}{\fs20 For random access files, the file is divided into chunks based on the length specified when the file is opened. For all other file types, the file is divided into bytes. In each case, the first chunk is numbered 1, with the remaining chunks numbered sequentially.\par SEEK is used in several of the examples in }{\i\fs20 File Input and Output Examples}{\fs20 , earlier in this chapter.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Dealing With Directories and Files}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Dealing With Directories and Files\tcl2}}}{\fs28 \par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CHDIR pathname\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 CHDIR\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CHDIR statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 directories\:default}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 directories\:changing}}}{\fs20 Change the default prefix to }{\f6\fs20 pathname}{\fs20 .\par Use this command to set the default prefix inside a program. After using this command, you can use partial path names or file names to open or manipulate files.\par See }{\i\fs20 File Names}{\fs20 , earlier in this chapter, for an explanation of file names, path names and the default prefix.\par The snippet shows a subroutine that moves up one level to the directory containing the current directory.\par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\pard\plain \s31\fi360\keepn\widctlpar\adjustright \v\f6\fs18\cgrid {\xe {\v\fs18 }{\v\fs18 samples\:Move Up One Directory}}}{\fs18 SUB PARENT\par D$ = CURDIR$\par SEPARATOR$ = LEFT$ (D$, 1)\par LAST% = 1\par FOR I% = 1 TO LEN (D$) - 1\par   IF MID$ (D$, I%, 1) = SEPARATOR$ THEN LAST% = I%\par NEXT\par CHDIR LEFT$ (D$, LAST%)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SUB\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CURDIR$\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 CURDIR$\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CURDIR$ function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 directories\:default}}}{\fs20 Returns the name of the current directory.\par See }{\i\fs20 File Names}{\fs20 , earlier in this chapter, for an explanation of file names, path names and the current directory.\par See CHDIR for a short sample that shows CURDIR$ in action.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 DIR$ [ '(' file-name ')' ]\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 DIR$\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DIR$ function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 directories}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 file names}}}{\fs20 Returns file names from a directory.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 directories\:files in}}}{\fs20 The first call should specify a parameter. This can be the name of a specific file or the wildcard character \ldblquote *}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 *}}}{\fs20 \rdblquote . Full or partial path names may be used. DIR$ will return the name of the file if there is a file by the given name, or the name of the first file in the directory if the wildcard character is used.\par If the wildcard character is used, subsequent calls may be made without a parameter. These calls return the names of the remaining files in the directory. When all files have been returned, DIR$ returns an empty string.\par This sample program uses DIR$ to identify all of the files in a directory. It changes the names of all of the files to lowercase using the NAME statement. To understand how this works, consider a file named \ldblquote FINANCES\rdblquote . You can use the statements\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 NAME$ = \ldblquote Finances\rdblquote \par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NAME NAME$ AS NAME$\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 to change the file from all uppercase letters to an uppercase letter followed by lowercase letters. }{\pard\plain \s25\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:letter case}}}{\fs20 This works because file names are case insensitive when you look for an existing file, so the name \ldblquote Finances\rdblquote  works perfectly well to open or identify the file \ldblquote FINANCES\rdblquote , but letter case is preserved when a file is created or renamed, so the command does change the case you see when you catalog the disk.\par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\pard\plain \s31\fi360\keepn\widctlpar\adjustright \v\f6\fs18\cgrid {\xe {\v\fs18 }{\v\fs18 samples\:Print Directory}}}{\fs18 NAME$ = DIR$ ("*")\par WHILE NAME$ <> ""\par   NAME2$ = ""\par   WHILE NAME$ <> ""\par     CH$ = LEFT$ (NAME$, 1)\par     NAME$ = RIGHT$ (NAME$, LEN (NAME$) - 1)\par     IF (CH$ >= "A") AND (CH$ <= "Z") THEN\par       CH$ = CHR$ ( ASC (CH$) - ASC ("A") + ASC ("a"))\par     END IF\par     NAME2$ = NAME2$ + CH$\par   WEND\par   NAME NAME2$ AS NAME2$\par   NAME$ = DIR$\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 WEND\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 KILL filename\par }\pard \s29\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20 RMDIR filename\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 KILL\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 KILL statement\bxe }}}{\v\fs20 \par }\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 RMDIR\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 RMDIR statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 directories\:deleting}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:deleting}}}{\fs20 Deletes the file }{\f6\fs20 filename}{\fs20 .\par In some implementations of BASIC, RMDIR is used to delete directories and KILL is used to delete files. There is no distinction between these operations under GS/OS: The same command can delete a directory or a file. GSoft\~BASIC supports both command names, but RMDIR is simply an alias for KILL. Either command can delete a directory or a file.\par The samples in }{\i\fs20 File Input and Output Examples}{\fs20 , earlier in this chapter, create a file called TEMP. You could delete this file from inside your BASIC program with the command\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 KILL "temp"\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 MKDIR pathname\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 MKDIR\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 MKDIR statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 directories\:creating}}}{\fs20 Creates a new directory with the name }{\f6\fs20 pathname}{\fs20 .\par }\pard\plain \s33\sb120\sa40\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 MKDIR "MyDirectory"\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 NAME filename AS filename\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 NAME\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 NAME statement\bxe }}}{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 files\:renaming}}}{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 AS}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Renames the file, directory or disk. The first file name is the original file name, and the second is the new file name.\par As an example, consider the problem of safely writing an important database file. Even if you make the outrageous assumption that your program has no errors, and the equally outrageous assumption that GSoft\~BASIC, the system software, and the various other programs running can never fail, and that the computer itself will never have an error, and that floppy disks can\rquote t fail, there\rquote s always the off chance of a power outage just as you\rquote re beginning to save an all-important database that you\rquote ve spent months creating and hours modifying since the last backup. Murphy\rquote s Law pretty much assures you that the power outage will occur at the worst possible moment, leaving the entire file unusable. One way to solve this problem is to never overwrite the original file until the modified one is safely saved to disk.\par Assuming the original file\rquote s name is in the variable NAME$, and that WRITE writes the data to a new file, returning TRUE if there were no errors writing the file, a safe save looks like this:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 IF WRITE ("temp") THEN\par   KILL NAME$\par   NAME "temp" AS NAME$\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END IF\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 The disadvantage of this kind of save is that the disk must have enough room for both the old and new versions of the file, but the distinct advantage is that a file error of almost any kind while writing the file leaves the original version untouched.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 See DIR$ for an example of this command used to change the letter case of file names.\par \sect }\sectd \lndscpsxn\sbkodd\linex0\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Chapter 15: Graphics\par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Chapter 15 \endash  Graphics}{\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\v\f4\fs36\cgrid {\tc {\v Chapter 15 \endash  Graphics\tcl1}}}{\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Applesoft\~BASIC Graphics}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Applesoft\~BASIC Graphics\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 {\*\bkmkstart bk32}GSoft\~BASIC supports a few of the old Applesoft\~BASIC}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 Applesoft\~BASIC}}}{\fs20  graphics commands. Unlike Applesoft\~BASIC, these commands don\rquote t draw on the old Apple\~II High Resolution Graphics Screen; instead, they draw on the Apple\~II}{\fs18 GS}{\fs20  320 mode graphics}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 320 mode graphics}}}{\fs20  screen. The resolution of the Apple\~II}{\fs18 GS}{\fs20  screen, at 320 pixels wide and 200 pixels high, is very close to the older version, which is 280 by 192, so the rare old program that uses just these commands will port with little or no problem.\par Missing are low resolution graphics}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 low resolution graphics}}}{\fs20  and shape tables}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 shape tables}}}{\fs20 . After polling various people, we decided to leave these old commands out. Leaving them out makes GSoft\~BASIC slightly smaller and faster, and it makes your programs smaller and faster, too, since the old program tokens were available for use by new commands.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 toolbox\:see also QuickDraw\~II}{\txe }}}{\fs20 These graphics commands are closely related to the drawing commands in QuickDraw\~II}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 QuickDraw\~II}}}{\fs20 , the graphics package for the Apple\~II}{\fs18 GS}{\fs20  toolbox. You can safely mix these commands with QuickDraw\~II commands. See }{\i\fs20 Apple\~II}{\i\fs18 GS}{\i\fs20  Toolbox Reference, Volume 2}{\fs20  for a complete description of QuickDraw\~II, or }{\i\fs20 Programming the Apple\~II}{\i\fs18 GS}{\i\fs20  Toolbox in GSoft\~BASIC}{\fs20  for a tutorial introduction to toolbox programming that discusses QuickDraw\~II, among many other tools. Both are available from the Byte Works, Inc.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Graphics Commands}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Graphics Commands\tcl2}}}{\fs28 \par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 HCOLOR= expression\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 HCOLOR=\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 HCOLOR= statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Changes the color used to draw lines with HPLOT. You must use HGR at least once before using HCOLOR=.\par Applesoft\~BASIC supported six colors, more or less. The colors were actually connected, so you could not always use, say, green next to orange.\par GSoft\~BASIC matches these colors as close as practical. It also adds ten new colors, giving you easy access to all sixteen Apple\~II}{\fs18 GS}{\fs20  colors.\par The table below shows the sixteen color numbers you can use with HCOLOR=, along with the colors you would get in Applesoft\~BASIC. The table assumes you are using the default 320 mode color palette, which is what you will be using if you don\rquote t deliberately change the color palette using QuickDraw\~II commands. The snippet shows a short program that displays the actual colors you can use. Press the return key after running the snippet to exit the program.\par }\pard\plain \s32\li360\ri2880\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx1800\tx3240\adjustright \f4\cgrid {\fs20 Number\tab Applesoft Color\tab GSoft\~BASIC Color\par }\pard\plain \s25\li360\ri2880\sb40\keepn\widctlpar\tx1800\tx3240\adjustright \f4\cgrid {\fs20 0\tab black\tab black\par 1\tab green\tab green\par 2\tab violet\tab purple\par 3\tab white\tab white\par 4\tab black\tab dark gray\par 5\tab orange\tab orange\par 6\tab blue\tab blue\par 7\tab white\tab red\par 8\tab \tab beige\par 9\tab \tab yellow\par 10\tab \tab brown\par 11\tab \tab light blue\par 12\tab \tab lilac\par 13\tab \tab Periwinkle blue\par 14\tab \tab light gray\par }\pard \s25\li360\ri2880\sb40\widctlpar\tx1800\tx3240\adjustright {\fs20 15\tab \tab dark green\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 HGR\par FOR COLOR = 0 TO 15\par   HCOLOR= COLOR\par   FOR H = COLOR * 20 TO COLOR * 20 + 20\par     HPLOT H, 0 TO H, 200\par   NEXT\par NEXT\par INPUT A$\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 TEXT\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 HGR\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 HGR\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 HGR statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 HGR turns on the graphics mode and clears the graphics screen to black. You should use HGR before using HPLOT or HCOLOR=.\par HGR also starts QuickDraw\~II}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 QuickDraw\~II}}}{\fs20 , the Apple\~II}{\fs18 GS}{\fs20  toolbox used for drawing. After using HGR you can safely use any QuickDraw\~II drawing commands. Technically, you could also start QuickDraw\~II using toolbox calls and then use HPLOT or HCOLOR=.\par If you use HGR to start QuickDraw\~II, you don\rquote t need to shut the tool down. GSoft\~BASIC will shut down QuickDraw\~II automatically when the program stops. You also don\rquote t have to use TEXT to switch back to the text screen, since GSoft\~BASIC also switches to the text screen after any program stops.\par See HCOLOR= for a sample program that uses HGR.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 HPLOT [ expression ',' expression ] [ TO expression ',' expression ]*\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 HPLOT\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 HPLOT statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 HPLOT draws a line from one location to another. You must use HGR before drawing lines with HPLOT.\par HPLOT draws lines to connect one or more points on the graphics screen. Each of the points is given as a horizontal coordinate followed by a vertical coordinate. Horizontal coordinates start at the left side of the screen with column 0, and continue to column 319 at the right of the screen. The vertical coordinate starts at the top of the screen with 0, and continues to the bottom of the screen, at 199. There is nothing wrong with specifying a point that lies off of the screen, so long as the value lies in the range -32768 to 32767, but only the points that are on the screen will be visible.\par The simplest command draws a single point. The command\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 HPLOT 319, 0\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 draws a point at the top right of the screen. Adding TO followed by a second point draws a line from the first point to the second. The command\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 HPLOT 0, 0 TO 319, 199\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 draws a diagonal line from the top left of the screen to the bottom right. You can add as many points as you like to a single HPLOT command. The command\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 HPLOT 10, 10 TO 20, 10 TO 20, 20 TO 10, 20 TO 10, 10\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 draws a square near the top left of the screen.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The first coordinate can be omitted, as long as at least one TO clause is used. In this case, a line is drawn from the last HPLOT location. For example, the commands\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 HPLOT 10, 10 TO 10, 10\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 HPLOT TO 20, 20\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 are allowed. They are equivalent to\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 HPLOT 10, 10 TO 10, 20 TO 20, 20\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par Use HCOLOR= to set the color before drawing your lines.\par The snippet shows an interference pattern formed by digital pixels overlapping as the lines are drawn. Press the return key after you\rquote ve seen enough of the picture.\par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 HGR\par COLOR = 5\par FOR V = 0 TO 199\par   HCOLOR= COLOR\par   HPLOT 0, 0 TO 319, V\par   IF COLOR = 5 THEN\par     COLOR = 6\par   ELSE\par     COLOR = 5\par   END IF\par NEXT\par INPUT A$\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 TEXT\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 TEXT\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 TEXT\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 TEXT statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Switches from the graphics display brought up by the HGR statement to the text display normally used by GSoft\~BASIC.\par See HCOLOR= or HPLOT for sample programs that use this command.\par {\*\bkmkend bk32}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 graphics}{\rxe bk32}}}{\v\fs20 \par }{\fs20 \sect }\sectd \lndscpsxn\sbkodd\linex0\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Chapter 16: Utility Statements\par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Chapter 16 \endash  Utility Statements}{\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\v\f4\fs36\cgrid {\tc {\v Chapter 16 \endash  Utility Statements\tcl1}}}{\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Memory Handling}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Memory Handling\tcl2}}}{\fs28 \par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 ALLOCATE '(' l-value [ ',' expression ] ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 ALLOCATE\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ALLOCATE statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 memory\:ALLOCATE statement}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 pointers}}}{\fs20 Allocates memory from the computer\rquote s memory. }{\f6\fs20 l-value }{\fs20 is set to a pointer to the allocated memory. }{\f6\fs20 expression}{\fs20  is the number of bytes of memory to reserve. If }{\f6\fs20 expression}{\fs20  is not used, enough memory is reserved for one value of the type l-value.\par Memory allocated by ALLOCATE comes from unallocated memory in the Apple\~II}{\fs18 GS}{\fs20 , not from the memory already set aside for variables and strings. This allows you to allocate large chunks of memory that don\rquote t interfere with the variable space or string pool. It also gives your program access to all of the memory in the Apple\~II}{\fs18 GS}{\fs20 , which allows you to set the memory size for variables and strings fairly low, yet gives you access to more memory if the program needs it\emdash say, to load a large database.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DISPOSE statement}}}{\fs20 Once memory is allocated, it stays allocated until you use DISPOSE to free the memory or until you exit GSoft\~BASIC. Restarting the program with RUN or using CLEAR will erase all variables and strings, but memory allocated with ALLOCATE is still reserved until you actually leave GSoft\~BASIC.\par In most cases ALLOCATE is used to reserve a chunk of memory for a record. The classic example is allocating an element in a linked list. For the type and variable declarations\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TYPE NUMBER\par   AFTER AS POINTER TO NUMBER\par   VALUE AS INTEGER\par END TYPE\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 DIM TEMP AS POINTER TO NUMBER\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 the ALLOCATE statement to allocate one record for the linked list is\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 ALLOCATE (TEMP)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 For a complete sample program that shows linked lists in action, see }{\i\fs20 Using the Record Type In The Record (Linked Lists)}{\fs20  in Chapter 10.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The second, optional parameter to ALLOCATE is generally used for allocating memory for variant records}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 variant records}}}{\fs20  or for allocating large chunks of memory that are manipulated with pointers.\par For a simple example of how the parameter is used with variant records, consider the declarations\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TYPE COLLECTABLE\par   COST\par   DESCRIPTION$\par   CASE COIN\par     YEAR AS LONG\par     DENOMINATION AS INTEGER\par   CASE BEANIE_BABY\par     CONDITION AS INTEGER\par END\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 DIM THING AS POINTER TO COLLECTABLE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par A record holding information about a coin needs 14 bytes, while a record holding information about a Beanie Baby needs 10 bytes. In cases where saving memory is of the utmost importance, you can use this fact to allocate exactly the amount of memory you need for a particular record. For example, to allocate a new record for a Beanie Baby, you would use the statement\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 ALLOCATE (THING, 10)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par There are two potential pitfalls to avoid. First, using a size that is too small can quickly lead to disaster. If you only allocated 8 bytes for the Beanie Baby, then filled in the CONDITION field, you would write over memory that does not belong to this record. The resulting bug may not show up during routine testing, and becomes very hard to track down later. The best insurance against this kind of bug is to collect all of the sizes you use in one location, storing them in variables, and always use the variable when allocating memory. This gives you a single point in the program to change if the record ever changes.\par Using this idea, the ALLOCATE call looks like this. At some point in your program, you set up the size as\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM BBSIZE AS INTEGER\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 BBSIZE = 10\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 Later, the ALLOCATE uses this size:\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 ALLOCATE (THING, BBSIZE)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par The second pitfall is changing the contents of a record. With a statement like\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 ALLOCATE (THING)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 ALLOCATE allocates enough memory to hold the largest variant part, in this case 14 bytes. If you override this value, like we did in the example above, but later change the value in the record and fill in information for a coin, you will again write into memory that has not been reserved for the record.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 DISPOSE '(' l-value ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 DISPOSE\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DISPOSE statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ALLOCATE statement}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 memory\:DISPOSE statement}}}{\fs20 Disposes of memory previously allocated with ALLOCATE.\par It is an error to dispose of memory using a pointer that was not assigned by ALLOCATE or to dispose of the same memory twice. BASIC cannot catch this error. An error of this type may eventually lead to corrupted memory or a crash.\par For a complete sample program that shows DISPOSE used to get rid of a linked list, see }{\i\fs20 Using the Record Type In The Record (Linked Lists)}{\fs20  in Chapter 10. The snippet shows a recursive subroutine that disposes of a binary tree.\par }\pard\plain \s33\sb120\sa40\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TYPE TREE\par   LEFT AS POINTER TO TREE\par   RIGHT AS POINTER TO TREE\par   NAME$\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END TYPE\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 SUB DUMP (T AS TREE)\par IF T^.RIGHT <> NIL THEN CALL DUMP (T^.RIGHT)\par IF T^.LEFT <> NIL THEN CALL DUMP (T^.LEFT)\par DISPOSE (T)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SUB\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 NIL\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 NIL\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 NIL function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 memory\:NIL function}}}{\fs20 Returns a pointer value that is type compatible with all pointers, and that indicates a pointer which is not pointing to any memory location.\par All pointers are initially set to NIL.\par The ordinal value for NIL is 0.\par See the snippet for DISPOSE for an example that uses NIL. NIL is universally used to indicate that a pointer doesn\rquote t point to anything. The recursive subroutine that is disposing of the binary tree tests for NIL so it can stop whenever it gets to a pointer that doesn\rquote t point to another record.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SETMEM '(' expression ',' expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 SETMEM\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SETMEM statement\bxe }}}{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 memory\:SETMEM statement}}}{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 program buffer}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Sets the size of a memory buffer. The first expression is the memory buffer to set; this is 0 for the variable buffer and 1 for the program buffer. The second expression is the new size for the buffer in bytes.\par It is not an error to use something other than 0 or 1 for the first parameter, but if you do the command is ignored. This allows future versions of GSoft\~BASIC to add other buffers whose size can be set with SETMEM, yet the programs will still work with this version of GSoft\~BASIC.\par SETMEM must be used in the main part of a program, not in subroutines or functions. In general, SETMEM should be the first command in the program.\par Memory buffer 0 is used for variables, types, strings, and some record keeping involved in subroutine calls. The default size for this buffer is 64K. If you get out of memory errors when you are not using ALLOCATE, use SETMEM to change the size of the variable buffer. Using SETMEM also deletes any existing variables; in this respect it works exactly like CLEAR.}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ALLOCATE statement}}}{\fs20 \par Memory buffer 1 is used for the program itself. Like the variable buffer, this buffer defaults to 64K bytes. If your program is larger than about 32K, consider setting the buffer to about twice the size of your program. You generally do this from the command line. One way to get an idea of the size of your program is to look at the program on disk with the CATALOG command. CATALOG shows the number of blocks used by the program. On a ProDOS format disk, the memory used by the program will be a little smaller than the number of blocks times 512.\par If you are using the version of GSoft\~BASIC that runs from ORCA, or if you create a stand-alone program with the MakeRuntime utility}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 MakeRuntime utility}}}{\fs20 , the program buffer is set to the actual size of the program. You should not need SETMEM to change the size of the program buffer in these cases, but it is available.\par }\pard\plain \s33\sb120\sa40\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 ! Double the size of the variable buffer, setting it to 128K.\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 SETMEM (0, CLNG (128) * 1024)\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SIZEOF '(' ( type | identifier ) ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 SIZEOF\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SIZEOF function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns the size required to store one value of a given type, or the size used by the variable }{\f6\fs20 identifier}{\fs20 . The size is given in bytes.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ALLOCATE statement}}}{\fs20 SIZEOF is generally used as the LEN parameter to an OPEN statement or as the second parameter to ALLOCATE. For example, to open a file for random access that will hold a record called PERSON, you would use the command\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 OPEN "MailingList" FOR INPUT AS #1 LEN SIZEOF (PERSON)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par If you want to reserve memory to read this entire file into memory at once, you could follow this up with\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 ALLOCATE (PERSON_POINTER, LOF (1) * SIZEOF (PERSON))\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par You can use any type name, including the built-in types. For example, SIZEOF\~(INTEGER) returns 2.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Peeks and Pokes}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Peeks and Pokes\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The commands in this section are used to read and write information directly to specific memory locations. This is generally done for one of two reasons: Either the program needs to read or write to a memory location that is mapped to an external device, or the program has been ported from Applesoft\~BASIC, which relied heavily on PEEKs and POKEs for operations that are commands in GSoft\~BASIC.\par See Appendix E, }{\i\fs20 Converting Applesoft\~BASIC Programs to GSoft\~BASIC}{\fs20 , for some common hardware locations on the Apple\~II}{\fs18 GS}{\fs20 , as well as for a table showing some common Applesoft\~BASIC PEEKs and POKEs and their equivalent GSoft\~BASIC commands.\par For a complete list of the various documented memory locations that you might want to use with PEEK or POKE, see }{\i\fs20 Apple\~II}{\i\fs18 GS}{\i\fs20  Hardware Reference}{\fs20  and }{\i\fs20 Apple\~II}{\i\fs18 GS}{\i\fs20  Firmware Reference}{\fs20 . Reprints of both books are available from the Byte Works. You might also want to use PEEK and POKE to control some hardware cards; see the documentation that comes with the card itself for a list of the appropriate memory locations.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 PEEK '(' expression ')'\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 PEEK\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 PEEK function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 memory\:PEEK function}}}{\fs20 Returns the value of the byte located at the address }{\f6\fs20 expression}{\fs20 .\par The expression can address any memory location, which, in general, requires a LONG value. Memory locations on the Apple\~II}{\fs18 GS}{\fs20  range from 0 to 16777215 ($00FFFFFF hexadecimal). It is best to avoid floating-point values for the expression, since a round-off error could easily cause you to read the wrong value from memory.\par The snippet shows a subroutine that looks to see if a keypress is available. This subroutine should not be used if the Event Manager is active; it looks directly at the keyboard}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 keyboard}}}{\fs20  strobe, which is something the Event Manager also does.\par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 FUNCTION KEYPRESS AS INTEGER\par KEYPRESS = PEEK ($00C000) > 127\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END FUNCTION\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 POKE expression ',' expression\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 POKE\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 POKE statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 memory\:POKE statement}}}{\fs20 The least significant 8 bits of the value in the second expression are stored in the memory location specified by the first expression.\par POKE can address any memory location, which, in general, requires a LONG value. Memory locations on the Apple\~II}{\fs18 GS}{\fs20  range from 0 to 16777215 ($00FFFFFF hexadecimal). It is best to avoid floating-point values for the expression, since a round-off error could easily cause you to write the value to the wrong location in memory.\par The value poked into memory should be in the range 0 to 255, which is all a byte of memory can hold. If the value lies outside this range, it is converted to the range 0 to 255 by converting the second expression to an INTEGER, then using the least significant 8 bits of the result. If you understand the two\rquote s complement representation used to represent integers in memory, it\rquote s easy enough to figure out what the resulting value will be\emdash if you don\rquote t, it\rquote s best to make sure the value being poked is in the expected range.\par The snippet reads a character from the keyboard}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 keyboard}}}{\fs20 . This method should not be used if the Event Manager is being used. GSoft\~BASIC does not normally use the Event Manager, but you can turn it on from your GSoft\~BASIC program.\par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 FUNCTION READKEY AS STRING\par WHILE PEEK ($00C0000) < 128\par WEND\par READKEY = CHR$ (PEEK ($00C0000) - 128)\par POKE $00C010, 0 : ! Clear the key\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END FUNCTION\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Clearing the Workspace}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Clearing the Workspace\tcl2}}}{\fs28 \par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CLEAR\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 CLEAR\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CLEAR statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DIM statement}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 workspace}}}{\fs20 Erases all types, variables and strings. Variables are removed whether they were created with the DIM statement or by being used without encountering a DIM statement.\par This statement is generally used to completely reset a program. This is occasionally handy during debugging or when writing an ONERR GOTO error handler.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 GSoft Version Number}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 GSoft Version Number\tcl2}}}{\fs28 \par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 VERSION\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 VERSION\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 VERSION function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 version number}}}{\fs20 Returns the GSoft\~BASIC version number encoded as a long integer. This long integer can be easily compared to see if the version of GSoft BASIC contains some critical new feature. When properly formatted and printed, this version number will match the version number printed when the GSoft\~BASIC shell starts, as well as the version number shown by the Finder for GSoft.Sys16.\par The GSoft\~BASIC version number consists of five parts. These are:\par \par }\pard \s25\fi-1440\li1800\sb40\widctlpar\adjustright {\fs20 major version\tab This is the major version release number. This number doesn't change very often, and when it does, it indicates major changes. This probably includes a new manual, and may include changes that may some old programs fail under the new version of the language. This number starts at 1.\par minor version\tab This version number changes whenever a new feature is added to GSoft\~BASIC or a change to an existing feature is made that affects the documentation. These changes are generally minor changes. They are typically documented in a release notes file, and do not require a new manual, although an updated manual may be available. This number starts at 0 each time the major version number changes.\par bug version\tab This version number is changed each time GSoft BASIC changes, no matter how minor the change might be. A change in the bug version usually indicates a release that fixes errors or expands limitations in an earlier release. Nothing in the documentation changes, but the changes to the program will be listed in the release notes file that accompanies each release. This number starts at 0 each time the minor version number changes.\par release type\tab The release type is one of four values.\par }\pard \s25\fi-360\li2160\sb40\widctlpar\adjustright {\fs20 0\tab Indicates a commercial release of GSoft\~BASIC. This is the most common value.\par 1\tab Development release. This designation is used for versions that are in the early stages of development. All planned features are not implemented and testing is incomplete. Programming errors are expected in a development release.\par 2\tab Alpha release. An alpha release contains all of the features initially planned for the commercial release, although some of the features may not be in their final form. Most testing is complete, and major bugs are either eliminated or clearly identified.\par 3\tab Beta release. A beta release is a nearly complete commercial release. All planned features are implemented, and no changes to these features is anticipated by the programmers or testers, although subsequent beta testing may identify areas that still need to be changed. All known bugs are eliminated. Formal testing is complete.\par }\pard \s25\fi-1440\li1800\sb40\widctlpar\adjustright {\fs20 release version\tab This indicates the development, alpha or beta release level. It starts at 1 each time the release designation changes.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par The initial release of GSoft\~BASIC, and the one this manual describes, is 1.0.0. VERSION returns the value 10000000.\par A typical use of the VERSION command is to check to see if a particular feature is available. For example, let\rquote s assume you are writing a program using a later version of GSoft\~BASIC, say version 1.1.0, and your program uses a feature that was not implemented in this release. You could start your program by calling this subroutine to make sure the version of GSoft\~BASIC is appropriate.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 FUNCTION CHECK_VERSION AS INTEGER\par IF VERSION >= 10100000\par   CHECK_VERSION = 1\par ELSE\par   PRINT "This program requires GSoft BASIC 1.1.0 or later."\par   INPUT "Press the RETURN key to continue."; A$\par   CHECK_VERSION = 0\par END IF\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END FUNCTION\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par Here is a short program that changes the version number into a string.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PRINT VERSION$\par \par FUNCTION VERSION$ AS STRING\par DIM V AS LONG\par V$ = STR$ ( CLNG ( VERSION / 10000000))\par V = VERSION - CLNG ( VERSION / 10000000) * 10000000\par V$ = V$ + "." + STR$ ( CLNG (V / 100000))\par V = V - CLNG (V / 100000) * 100000\par V$ = V$ + "." + STR$ ( CLNG (V / 1000))\par V = V - CLNG (V / 1000) * 1000\par IF V <> 0 THEN\par   SELECT CASE CLNG (V / 100)\par     CASE 1:V$ = V$ + " D"\par     CASE 2:V$ = V$ + " A"\par     CASE 3:V$ = V$ + " B"\par   END SELECT\par   V$ = V$ + STR$ (V - CLNG (V / 100) * 100)\par END IF\par VERSION$ = V$\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END FUNCTION\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \sect }\sectd \lndscpsxn\sbkodd\linex0\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Chapter 17: Subroutines\par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Chapter 17 \endash  Subroutines}{\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\v\f4\fs36\cgrid {\tc {\v Chapter 17 \endash  Subroutines\tcl1}}}{\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 GOSUB Subroutines}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 GOSUB Subroutines\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Subroutines based on GOSUB are simple to implement and easy to understand. They are also a part of virtually every implementation of BASIC. GOSUB statements do require the use of line numbers, the line number doesn\rquote t tell you as much as a SUB name about what a call does, and in long programs the time required to find the line number can significantly slow down a program that calls lots of subroutines. For these reasons, SUB is generally a better way to handle subroutines in GSoft\~BASIC.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 GOSUB line-number\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 GOSUB\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GOSUB statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Control jumps to the first line whose number matches }{\f6\fs20 line-number}{\fs20 . }{\f6\fs20 line-number}{\fs20  must be an integer constant. When a RETURN statement is encountered, control jumps to the statement after GOSUB. The following program illustrates this by printing 1, 2 and 3 using subroutine calls.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18       I = 1\par       GOSUB 10\par       I = I + 1\par       GOSUB 10\par       I = I + 1\par       GOSUB 10\par }\pard \s31\fi360\widctlpar\adjustright {\fs18       END\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18    10 PRINT I\par }\pard \s31\fi360\widctlpar\adjustright {\fs18       END\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 recursion}}}{\fs20 Subroutines can be nested up to 24 levels deep. Recursion is allowed so long as this limit is not exceeded. Here\rquote s a simple example of a recursive subroutine that calculates a positive integer exponent. The maximum exponent that can be used is 23, as shown, since adding 1 to the exponent would cause a 25th subroutine call.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18       X = 3\par       R = 1\par       E = 23\par       GOSUB 10\par       PRINT R\par }\pard \s31\fi360\widctlpar\adjustright {\fs18       END\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18    10 IF E = 0 THEN RETURN\par       E = E - 1\par       R = R * X\par       GOSUB 10\par }\pard \s31\fi360\widctlpar\adjustright {\fs18       RETURN\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par The variables used in the subroutine are identical to the variables used in the rest of the program, so in\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18       I = 4\par       GOSUB 10\par       PRINT I\par       END\par    10 I = 5\par }\pard \s31\fi360\widctlpar\adjustright {\fs18       RETURN\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 the value printed is 5, not 4.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 If GOSUB is used in a subroutine or function, the destination line must be in the same procedure. If GOSUB is used in the main program, the destination line must also be in the main program.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 ON expression GOSUB line-number [ ',' line-number ]*\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 ON-GOSUB\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ON-GOSUB statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The ON-GOSUB statement is similar to the ON-GOTO statement. It uses an index to jump to one of several locations in a program.\par The expression is evaluated, then truncated to an integer. Counting from one, one of the line numbers is selected from the list of line numbers immediately after GOSUB, and the program does a GOSUB call to that line. If there are no matching line numbers, execution continues with the line after the ON-GOSUB statement.\par Just as with the GOSUB statement, RETURN is used to return from the subroutine call. Control continues with the statement immediately after the ON-GOSUB statement.\par }\pard\plain \s33\sb120\sa40\keepn\widctlpar\adjustright \f4\ul\cgrid {\fs20 Snippet\par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18       FOR I = 1 TO 3\par         ON I GOSUB 10, 20, 30\par       NEXT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18       END\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18    10 PRINT "one"\par }\pard \s31\fi360\widctlpar\adjustright {\fs18       RETURN\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18    20 PRINT "two"\par }\pard \s31\fi360\widctlpar\adjustright {\fs18       RETURN\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18    30 PRINT "three"\par }\pard \s31\fi360\widctlpar\adjustright {\fs18       RETURN\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 POP\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 POP\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 POP statement\bxe }}}{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GOSUB statement}}}{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ON-GOSUB statement}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Removes one GOSUB return address from the stack. In effect, this turns the most recent GOSUB into a GOTO.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 RETURN\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 RETURN\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 RETURN statement\bxe }}}{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GOSUB statement}}}{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ON-GOSUB statement}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns from the most recent GOSUB or ON-GOSUB, transferring control to the statement following the GOSUB statement.\par See GOSUB for examples of RETURN.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 DEF FN Functions}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 DEF FN Functions\tcl2}}}{\fs28 \par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 DEF FN identifier '(' identifier [ ',' identifier ]* ')' '=' expression\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 DEF FN\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DEF FN statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Creates a local function. The function is called using FN followed by the function name and a parameter list.\par The function definition must be encountered before the first time it is used, so\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DEF FN SQUARE(X) = X * X\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PRINT FN SQUARE(2)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 works fine, printing 4, but\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PRINT FN SQUARE(2)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 DEF FN SQUARE(X) = X * X\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 fails.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parameters\:DEF FN}}}{\fs20 Parameters and the value returned by the function can be any numeric or string type. Types are assigned using trailing type characters, as in }{\f6\fs20 A$}{\fs20  for a string. For example,\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DEF FN PATH$(PREFIX$, FILE$) = PREFIX$ + ":" + FILE$\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PRINT FN PATH$(":mydisk:myfolder", "myfile")\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 prints the full path name\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 :mydisk:myfolder:myfile\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par When the function is called using a FN term in an expression, each parameter in the call is evaluated and assigned to the corresponding parameter variable. The expression is then evaluated. The expression must result in a value that is type compatible with the function name. The expression can use constants, parameter variables, other variables that do not have the same name as a parameter, and other functions\emdash but }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 recursion}}}{\fs20 recursive calls are not allowed.\par If the function uses variables that are not parameters, the variables are shared with the program or procedure containing the function. For example\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DEF FN F(X) = X * Y\par Y = 4\par X = 5\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PRINT FN F(2), X\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 prints 8, then 5. The value of Y used by the function comes from the main program, and is set to 4. The value of the parameter X is 2, set when the function is called by the PRINT statement; the parameter X is completely different from the variable X in the program.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Functions created with DEF FN are local to the main program or procedure in which they are created.\par You can redefine a DEF FN function; the latest definition is the one used. Thus\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DEF FN F(X) = X * X\par DEF FN F(X) = X * X * X\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PRINT FN F(2)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 is legal, and prints 8. The first function is replaced by the second. A more common use for this feature is to define the function based on some input parameter. For example,\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 IF SQUARE THEN\par   DEF FN F(X) = X * X\par ELSE\par   DEF FN F(X) = X * X * X\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END IF\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par While this short example is a bit contrived, practical examples are not difficult to come by. For example, you might create several functions for calculating interest, then choose the appropriate function using a condition like the one shown. All of the calculations in the rest of the program would be the same, and there would be no time consuming testing in the program itself to choose the correct interest calculation.\par DEF FN functions are limited to a single line with no control statements. Essentially, the function must be something that could be handled with a LET statement. This disadvantage is offset somewhat by two advantages: DEF FN functions are generally faster than an equivalent function defined with the FUNCTION statement; and you can have more than one function with the same name, choosing the correct one as the program runs or even replacing a function that is in use with a new one by the same name.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Subroutines and Functions}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Subroutines and Functions\tcl2}}}{\fs28 \par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 SUB and FUNCTION Parameter Lists}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 SUB and FUNCTION Parameter Lists\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parameters}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 FUNCTION statement\:parameters}}}{\v\fs20 i.SUB statement:parameters;\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Both SUB subroutines and FUNCTION functions support parameter lists. The rules for parameter lists are the same for both. In this section, subroutines and functions will be referred to as procedures, a name that encompasses both subroutines and functions.\par Parameter lists follow the procedure name, enclosed in parentheses}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parentheses}}}{\fs20 . A parameter list consists of one or more parameter declarations separated by commas. Each parameter declaration is a variable, optionally followed by AS}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 AS}}}{\fs20  and a type. If no type is given explicitly, the type is derived from the name of the variable.\par For example, this function returns the hyperbolic sine of a value. Like all of the procedures in this section, it\rquote s shown with a simple test program, which shows how a parameter is coded when the procedure is called. The examples form very short programs, but they are complete and will run as shown, so you can type them in and try variations to explore how procedures work.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PRINT SINH (2)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 FUNCTION SINH (X)\par SINH = 0.5 * ( EXP (X) - EXP ( - X))\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END FUNCTION\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par The parameter doesn\rquote t have an AS type clause, so the type is assumed from the variable name. Just as with a variable anywhere else in the program, a name with no trailing type character is SINGLE. For that matter, the function itself returns a SINGLE value for the same reason.\par There are two ways to create a similar function that takes a DOUBLE argument and returns a DOUBLE result. The first uses type characters, like this:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PRINT SINH# (2)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 FUNCTION SINH# (X#)\par SINH# = 0.5D0 * ( EXP (X#) - EXP ( - X#))\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END FUNCTION\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par The other method requires a bit more typing, but you don\rquote t have to type # after the name when you use the function. It looks like this:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PRINT SINH (2)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 FUNCTION SINH (X AS DOUBLE) AS DOUBLE\par SINH = 0.5D0 * ( EXP (X) - EXP ( - X))\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END FUNCTION\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par Arrays, records, pointers, strings and all numeric types are allowed as parameters. All of the numeric types and strings work exactly like the example of SINGLE and DOUBLE in the SINH function, above.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 pointers}}}{\fs20 You can declare a pointer parameter two ways. The first is to create a type name in the main part of the program, then use the type name in the parameter list, like this:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TYPE IPTR AS POINTER TO INTEGER\par DIM I AS INTEGER\par DIM IP AS IPTR\par IP = @I\par I = 4\par CALL TEST(IP)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 SUB TEST(P AS IPTR)\par PRINT P^\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SUB\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 The second way to declare a pointer parameter is more direct. It uses the POINTER TO type qualifier, like this:\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM I AS INTEGER\par DIM IP AS POINTER TO INTEGER\par IP = @I\par I = 4\par CALL TEST(IP)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 SUB TEST(P AS POINTER TO INTEGER)\par PRINT P^\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SUB\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parameters\:records as}}}{\fs20 Passing records}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 records}}}{\fs20  is just as straight forward. In the case of a record, the type must be predefined. Types defined in the main part of the program can be used in the parameter list\emdash or in the procedure itself, for that matter. The issue of global and local variables is discussed more completely in the section }{\i\fs20 Local Variables and Types}{\fs20 , below. Here\rquote s a short sample that demonstrates how records are passed.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TYPE POINT3D\par   X:Y:Z\par END TYPE\par DIM P AS POINT3D\par P.X = 1.2\par P.Y = 3.4\par P.Z = 5.6\par CALL PRINTPOINT(P)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 SUB PRINTPOINT(P AS POINT3D)\par PRINT USING "(#.# #.# #.#)";P.X, P.Y, P.Z\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SUB\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 arrays\:as parameters}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parameters\:arrays as}}}{\fs20 The only parameter type that isn\rquote t completely straight forward is an array. There are two problems that contribute to the rather odd way arrays are passed, and one unexpected benefit. The first problem is that BASIC traditionally doesn\rquote t support types, and even GSoft\~BASIC doesn\rquote t support types that are an array of something. Because of this historical limitation, the designers of early implementations of BASIC had to come up with a way of passing arrays that did not depend on types. In addition, you can have an array and a non-array with the same name;\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM A, A(4)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 is perfectly legal. It creates two variables, both named A, but one is a SINGLE variable and the other is an array of five SINGLE values.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 To solve these twin problems, BASIC uses parentheses}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parentheses}}}{\fs20  immediately after the name of the array, both when the procedure is declared and when it is called. Nothing goes inside the parentheses in either case, though. Using A(4) as a parameter when you call a procedure passes the specific SINGLE value at that index, just as printing A(4) prints a specific SINGLE value from the array. Specifying the maximum length of the array in the procedure declaration would have worked, but the designers of BASIC chose not to.\par All of this leads to the rather odd looking empty subscripts you see in the following example of array parameter passing, but it also leads to a powerful benefit. Since there is no maximum subscript in the procedure declaration, we don\rquote t have to limit procedure calls to arrays of a specific length, as the example shows. We can use the same procedure to handle arrays of several sizes. This example uses a single procedure to calculate the length of a vector, but the subroutine can handle vectors in two or three dimensions\emdash or more, for that matter.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM V2(1), V3(2)\par V2(0) = 3\par V2(1) = 4\par V3(0) = 2\par V3(1) = 2\par V3(2) = 2\par PRINT LENGTH(V2(), 2), LENGTH(V3(), 3)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 FUNCTION LENGTH(V(), DIMENSIONS AS INTEGER )\par SQUARES = 0.0\par FOR I% = 0 TO DIMENSIONS - 1\par   SQUARES = SQUARES + V(I%) * V(I%)\par NEXT\par LENGTH = SQR (SQUARES)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END FUNCTION\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par Surprisingly, this flexibility is not accompanied by the danger of an array overflow, as it is in C. If you try to access an illegal array subscript, perhaps because you passed the wrong dimension in the example above, BASIC detects the error and stops the program.\par Multiply subscripted arrays are handled exactly the same way, as the example below shows. This example computes the determinant of a matrix with two or more rows and columns using cofactor reduction. The important point here isn\rquote t whether you know what cofactor reduction is, or even what the determinant of a matrix is. The important point is that the sample shows clearly how a multi-dimensional array is passed as a procedure parameter. It also shows a clever use of BASIC\rquote s ability to handle variable dimensioned arrays, since the procedure calls itself with successively smaller arrays until the 2 by 2 case is reached. This is something that C can\rquote t do. Most Pascal implementations can\rquote t do this, either.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\pard\plain \s31\fi360\keepn\widctlpar\adjustright \v\f6\fs18\cgrid {\xe {\v\fs18 }{\v\fs18 samples\:Array Parameters}}}{\fs18 DIM I AS INTEGER , J AS INTEGER\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 DIM DIMENSIONS AS INTEGER\par !\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 DIMENSIONS = 3\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 DIM A(DIMENSIONS - 1, DIMENSIONS - 1)\par !\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 FOR I = 0 TO DIMENSIONS - 1\par   FOR J = 0 TO DIMENSIONS - 1\par     A(I, J) = 10 * I + J\par   NEXT\par NEXT\par PRINT DETERMINANT(A(), DIMENSIONS)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\pard\plain \s31\fi360\keepn\widctlpar\adjustright \v\f6\fs18\cgrid {\xe {\v\fs18 }{\v\fs18 recursion}}}{\fs18 FUNCTION DETERMINANT(A(), DIMENSIONS AS INTEGER )\par IF DIMENSIONS = 2 THEN\par }\pard \s31\fi360\widctlpar\adjustright {\fs18   DETERMINANT = A(0, 0) * A(1, 1) - A(0, 1) * A(1, 0)\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 ELSE\par   DIM B(DIMENSIONS - 1, DIMENSIONS - 1)\par   DIM I AS INTEGER , J AS INTEGER\par }\pard \s31\fi360\widctlpar\adjustright {\fs18   DIM R AS INTEGER , C AS INTEGER\par   !\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18   SIGN = 1.0\par   SUM = 0.0\par   FOR I = 0 TO DIMENSIONS - 1\par     R = 0\par     FOR J = 0 TO DIMENSIONS - 1\par       IF J <> I THEN\par         FOR C = 1 TO DIMENSIONS - 1\par           B(R, C - 1) = A(J, C)\par         NEXT\par         R = R + 1\par       END IF\par     NEXT\par     SUM = SUM + SIGN * A(I, 0) * DETERMINANT(B(), DIMENSIONS - 1)\par     SIGN =- SIGN\par   NEXT\par   DETERMINANT = SUM\par END IF\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END FUNCTION\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Passing Parameters by Reference and Value}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Passing Parameters by Reference and Value\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 There are two fundamentally different ways to pass a parameter to a subroutine, and GSoft\~BASIC allows them both.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parameters\:pass by reference}}}{\fs20 The first is called pass by reference. When you pass a parameter by reference, changes made inside the subroutine affect the original variable, too. For example, the program\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 I = 4\par J = 5\par CALL DOUBLE(I)\par CALL DOUBLE(J)\par PRINT I, J\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 SUB DOUBLE(X)\par X = X + X\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SUB\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 prints 8 and 10; changes made to the variable X inside the subroutine also change the original variable. Any time you pass the name of a variable as a parameter, you are passing the parameter by reference.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parameters\:pass by value}}}{\fs20 The second way to pass a parameter is by value. When you pass a parameter by value, changes made inside the subroutine have no effect on the original value passed. In BASIC, all expressions, no matter how simple, are passed by value. It\rquote s traditional to enclose a variable in parentheses}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parentheses}}}{\fs20  to pass it by value. Recoding the sample,\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 I = 4\par J = 5\par CALL DOUBLE((I))\par CALL DOUBLE((J))\par PRINT I, J\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 SUB DOUBLE(X)\par X = X + X\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SUB\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 prints 4 and 5.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 There is one subtle point about numeric variables passed as parameters. Forcing BASIC to convert from one type to another is an expression. If you pass, say, an integer variable to a procedure that expects a SINGLE variable, the value is converted. When this happens, the variable is passed by value, never by reference, so\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 I% = 4\par J# = 5\par CALL DOUBLE(I%)\par CALL DOUBLE(J#)\par PRINT I%, J#\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 SUB DOUBLE(X)\par X = X + X\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SUB\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 prints 4 and 5.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 arrays\:as parameters}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parameters\:arrays as}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parameters\:records as}}}{\fs20 Arrays and records must be passed by reference, since they cannot be used in an expression. Variables of all other types can be passed either way.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 Using Parameters}{\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\v\fs20 Using Parameters\tcl4}}}{\fs20 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Inside a procedure, a parameter works just like any other variable. You can use the parameters in expressions, change the value of a parameter, or pass the parameter as a parameter to yet another procedure.\par Space used by parameters vanishes as soon as the procedure returns.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Local Variables and Types}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Local Variables and Types\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 variable scope}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 FUNCTION statement\:variable scope}}}{\v\fs20 i.SUB statement:variable scope;\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Variables declared inside the procedure survive until the procedure returns, but no longer. If the procedure is called again, an entirely new set of variables is allocated. This prevents you from storing values inside a subroutine for later use. For example, the program\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 FOR I = 1 TO 10\par   CALL TEST\par NEXT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 SUB TEST\par J = J + 1\par PRINT J\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SUB\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 looks, at first glance, like it might print the numbers 1 to 10. In fact, it prints 1 ten times. Every time the subroutine TEST returns to the main program, the value J vanishes; each time TEST is called again, a new variable named J is created and initialized to zero.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parameters\:pass by reference}}}{\fs20 Variables from outside the procedure cannot be accessed from inside, although passing parameters by reference does give you a way to change values outside the procedure. The program\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 X = 5\par CALL TEST\par PRINT X\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 SUB TEST\par PRINT X\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SUB\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 prints 0 and 5, not 5 and 5. The variable X from the main program is not available inside the subroutine. Using X in the PRINT statement creates a new variable called X inside the subroutine and initializes it to 0. The PRINT statement prints 0. Upon return to the main program, the variable X that was created inside the subroutine vanishes, so the PRINT statement in the main program prints the original variable called X whose value is 5.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parameters\:types for}}}{\fs20 Types defined in the main program are, however, available in procedures as well as the program, as are types declared in tool interface files. This allows you to use a type declared in the main program as the type of a parameter, and to declare variables that are type compatible with the parameter inside the procedure.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Recursion with SUB and FUNCTION}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Recursion with SUB and FUNCTION\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 recursion}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 FUNCTION statement\:recursion}}}{\v\fs20 i.SUB statement:recursion;\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Recursion is a process where a procedure calls itself. It is usually used to break a problem down into smaller pieces. BASIC supports recursion, as you can see from the many examples throughout the book, including the determinant example from }{\i\fs20 SUB and FUNCTION Parameter Lists}{\fs20 , earlier in this chapter.\par The only limit on recursion depth is the memory available in the variables buffer. Each time you call a procedure, some memory is used to store various values, like the location of the line to return to after the procedure completes. Space is also used for parameters and local variables. If you try to call a procedure and there isn\rquote t enough memory left to store these values, your program will stop with an out of memory error.\par You can use FRE to check the available memory in a recursive subroutine, switching to a non-recursive substitute or handling the error in some other way if memory runs low.\par \par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CALL identifier [ parameter-list ]\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 CALL\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CALL statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Calls a subroutine defined by a SUB statement. See SUB for details, or }{\i\fs20 SUB and FUNCTION Parameter Lists}{\fs20  for several examples.\par }\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 FUNCTION identifier [ parameter-definition-list ] [ AS type ]\par }\pard \s29\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20 [ statement ]*\par }\pard \s29\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20 END FUNCTION\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 FUNCTION\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 FUNCTION statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Defines a function. The FUNCTION definition appears after the BASIC program, mixed with any SUB definition and other FUNCTION definition in any order. The program must not execute a FUNCTION statement, so the program itself should end with an END statement. For example, the program\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PRINT SQUARE (2)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 FUNCTION SQUARE (X)\par SQUARE = X * X\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END FUNCTION\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 works just fine, but leaving the END statement out would cause an error. The program would run, and it would still print 4, but right after the PRINT statement the program would try to execute the FUNCTION declaration, and that would cause an error.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The identifier is the name of the function. This is followed by the parameter list, if any, and the type returned by the function. The statements that appear between the FUNCTION statement and the END FUNCTION statement are executed as if they were a program, then the last value set for the function is returned to the caller.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parameters}}}{\fs20 The parameter list appears after the function name in parentheses}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parentheses}}}{\fs20 . Parameter lists for FUNCTION and SUB procedures follow the same rules. These rules are discussed in }{\i\fs20 SUB and FUNCTION Parameter Lists}{\fs20 , earlier in this chapter.\par Last is the type of the function, coded as AS}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 AS}}}{\fs20  followed by a type name. A function can return any simple type, such as LONG or STRING; and it can return a pointer. }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 records}}}{\fs20 Functions cannot return records or arrays, although they can return pointers to either a record or an array. If no type is given, the type is assumed from the function name, just as it is for a variable name. Following these rules,\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 FUNCTION F (X)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 is a function that returns a SINGLE value.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 FUNCTION F% (X)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 and\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 FUNCTION F (X) AS INTEGER\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 both return an INTEGER value.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The value returned by the function is set by assigning a value to the function name. This can be done more than one time; the last value set is the one returned. If no value is set, 0 is returned for numeric functions, a null string for strings, and a null pointer for pointers.\par A function returns to the main program when the END FUNCTION statement executes.\par See }{\i\fs20 Local Variables and Types}{\fs20  for a discussion of local variables, and }{\i\fs20 Recursion with SUB and FUNCTION}{\fs20  for a discussion of recursion. These sections and }{\i\fs20 SUB and FUNCTION Parameter Lists}{\fs20 , appear earlier in this chapter; all three have extensive examples of functions.\par }\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SUB identifier [ parameter-definition-list ]\par }\pard \s29\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20 [ statement ]*\par }\pard \s29\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20 END SUB\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 SUB\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SUB statement\bxe }}}{\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CALL statement}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Defines a subroutine.\par The SUB definition appears after the BASIC program, mixed with any FUNCTION definitions and other SUB definitions in any order. The program must not execute a SUB statement, so the program itself should end with an END statement. For example, the program\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 CALL HELLO\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END\par \par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 SUB HELLO\par PRINT "Hello, world."\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SUB\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 works just fine, but leaving the END statement out would cause an error. The program would run, and it would still print \ldblquote Hello, world.\rdblquote , but right after the CALL statement the program would try to execute the SUB declaration, and that would cause an error.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The identifier is the name of the subroutine, used when it is called. This is followed by the parameter list, if any. The statements that appear between the SUB statement and the END SUB statement are executed as if they were a program.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parameters}}}{\fs20 The parameter list appears after the subroutine name in parentheses. Parameter lists for FUNCTION and SUB procedures follow the same rules. These rules are discussed in }{\i\fs20 SUB and FUNCTION Parameter Lists}{\fs20 , earlier in this chapter.\par Subroutines are called with the CALL statement. This is followed by the name of the subroutine and any parameters.\par A subroutine returns to the main program when the END SUB statement executes.\par See }{\i\fs20 Local Variables}{\fs20  }{\i\fs20 and Types}{\fs20  for a discussion of local variables, and }{\i\fs20 Recursion with SUB and FUNCTION}{\fs20  for a discussion of recursion. These sections and }{\i\fs20 SUB and FUNCTION Parameter Lists}{\fs20 , appear earlier in this chapter; all three have extensive examples of subroutines.\par \sect }\sectd \lndscpsxn\sbkodd\linex0\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Chapter 18: Standard Libraries\par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Chapter 18 \endash  Standard Libraries}{\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\v\f4\fs36\cgrid {\tc {\v Chapter 18 \endash  Standard Libraries\tcl1}}}{\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 When GSoft BASIC is properly installed, the commands you see in this chapter work just like the commands built into the GSoft\~BASIC language, yet these commands are not a part of GSoft\~BASIC. They are part of the standard libraries package that we expect to implement on all platforms that have the hardware necessary to support these features.\par These libraries are installed for you by the installer that ships with GSoft\~BASIC. See }{\i\fs20 Installing GSoft\~BASIC on a Hard Disk}{\fs20  in Chapter\~2 for more information about the installer. More in-depth information about how libraries are constructed and installed can be found in Appendix D, }{\i\fs20 Writing User Tools for GSoft\~BASIC}{\fs20 . For the most part, the only detail you need to be aware of is that the libraries require user tools that are not built into the GSoft\~BASIC language, so if your programs will be used by people who do not have GSoft\~BASIC, you need to remember to include the user tools with your program. The Byte Works, Inc. grants a royalty free license to include these tools with any program written in GSoft\~BASIC. See }{\i\fs20 Including Libraries with GSoft\~BASIC Programs}{\fs20  in Chapter\~4 for details.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 The Game Paddle Library}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 The Game Paddle Library\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Libraries in GSoft\~BASIC are numbered. The Game Paddle Library is library number 1.\par One capability that is built into Applesoft\~BASIC but not GSoft\~BASIC is a command to read joysticks and game paddles connected to the game paddle port. One of the problems with the game paddle port is that subroutines have to be fine tuned for the processor speed you are actually using. For that reason, commands to read the game paddle port are not built into the language itself.\par The Game Paddle Library does more than read the paddle values like Applesoft\~BASIC\rquote s PDL command, though. It also adds commands to read the four TTL switches on the game paddle port, as well as the ability to set and clear the four TTL annunciators. You can also do this with PEEK and POKE commands, but the Game Paddle Library gives you a cleaner interface.\par Refer to the }{\i\fs20 Apple\~II}{\i\fs18 GS}{\i\fs20  Hardware Reference}{\fs20  for information about the game paddle port itself, including pinout diagrams that you can use to build your own TTL and resistor based devices to connect to the game paddle port.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SUB GTBootInit\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 GTBootInit\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GTBootInit statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 This call is made at boot time. It doesn\rquote t do anything in this library.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SUB GTStartup\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 GTStartup\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GTStartup statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 You should make this call immediately after loading the library with LOADLIBRARY. GTStartup does any required initialization. It doesn\rquote t do anything in the Game Paddle Library, but it\rquote s a good idea to make the startup call for any library you load.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SUB GTShutDown\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 GTShutDown\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GTShutDown statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 You should make this call just before you use UNLOADLIBRARY to unload the Game Paddle Library. GTShutDown does any required clean up. This call doesn\rquote t do anything in the Game Paddle Library, but it\rquote s a good idea to make this call when you are finished with any library.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 FUNCTION GTVersion AS INTEGER\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 GTVersion\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GTVersion function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns the version number for the library. The most significant byte is the major version, and the least significant byte is the minor version. You can print the version number in the common form of major.minor this way:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 VERSION% = GTVERSION\par MAJOR% = VERSION% / 256\par MINOR% = VERSION% - MAJOR% * 256\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PRINT USING "The Game Paddle Library version number is #.#."; MAJOR%, MINOR%\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 FUNCTION GTStatus AS INTEGER\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 GTStatus\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GTStatus function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns true (a value of 1) if the Game Paddle Library has been started with GTStartup and has not yet been shut down, or false (a value of 0) if the Game Paddle Library is not started.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 FUNCTION GTGetSwitch (SWITCH AS INTEGER) AS INTEGER)\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 GTGetSwitch\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GTGetSwitch function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns the current setting of one of the four TTL input switches. The switches are numbered 0 to 3.\par If SWITCH is outside the range 0 to 3, GTGetSwitch sets TOOLERROR to $0101.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SUB GTClearAnnunciator (ANNUNCIATOR AS INTEGER)\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 GTClearAnnunciator\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GTClearAnnunciator statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Clears (turns off) one of the four TTL output annunciators. The annunciators are numbered 0 to 3.\par If ANNUNCIATOR is outside the range 0 to 3, GTClearAnnunciator sets TOOLERROR to $0101.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SUB GTSetAnnunciator (ANNUNCIATOR AS INTEGER)\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 GTSetAnnunciator\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GTSetAnnunciator statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Sets (turns on) one of the four TTL output annunciators. The annunciators are numbered 0 to 3.\par If ANNUNCIATOR is outside the range 0 to 3, GTSetAnnunciator sets TOOLERROR to $0101.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 FUNCTION GTGetPaddle (PADDLE AS INTEGER) AS INTEGER\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 GTGetPaddle\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GTGetPaddle function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Reads one of the four resistor inputs to the game paddle port. The resistor inputs are numbered 0 to 3. A single joystick uses paddle 0 for the X axis and paddle 1 for the Y axis; a system that supports two joysticks will use paddles 2 and 3 for the X and Y axis, respectively. Game paddles are generally numbered, and also use inputs 0 and 1 for the standard configuration of two paddles.\par GTGetPaddle returns a value from 0 to 255, depending on the resistance across the port. Game paddles generally return lower values when turned counterclockwise and higher values when turned clockwise; joysticks generally return lower values when pushed up or left, and higher values when pushed right or down.\par The routines used to read the game paddle port are sensitive to the CPU speed of the computer. The Game Paddle Library is timed for an unaccelerated Apple\~II}{\fs18 GS}{\fs20  running at fast speed (about 2.7 MHz). If you are using an accelerator card, the range of values reported by GTGetPaddle may be too low. Check your accelerator card\emdash some have a configurable switch that slows down momentarily when the game paddle ports are read, allowing timed routines to work correctly. Make sure this setting is enabled.\par If PADDLE is outside the range 0 to 3, GTGetPaddle sets TOOLERROR to $0101.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Using the Game Paddle Library}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Using the Game Paddle Library\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Here\rquote s a short program that shows how to use the Game Paddle Library to read the positions on a joystick or a pair of game paddles. It shows the proper way to initialize and shut down the library.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 LOADLIBRARY 1\par GTSTARTUP\par FOR I = 1 TO 300\par   PRINT GTGETPADDLE (0), GTGETPADDLE (1)\par NEXT\par GTSHUTDOWN\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 UNLOADLIBRARY 1\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 The Time Library}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 The Time Library\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Libraries in GSoft\~BASIC are numbered. The Time Library is library number 2.\par The Time Library provides commands that tell you the current time and date.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SUB TTBootInit\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 TTBootInit\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 TTBootInit statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 This call is made at boot time. It doesn\rquote t do anything in this library.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SUB TTStartup\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 TTStartup\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 TTStartup statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 You should make this call immediately after loading the library with LOADLIBRARY. TTStartup does any required initialization. It doesn\rquote t do anything in the Time Library, but it\rquote s a good idea to make the startup call for any library you load.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SUB TTShutDown\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 TTShutDown\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 TTShutDown statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 You should make this call just before you use UNLOADLIBRARY to unload the Time Library. TTShutDown does any required clean up. This call doesn\rquote t do anything in the Time Library, but it\rquote s a good idea to make this call when you are finished with any library.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 FUNCTION TTVersion AS INTEGER\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 TTVersion\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 TTVersion function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns the version number for the library. The most significant byte is the major version, and the least significant byte is the minor version. You can print the version number in the common form of major.minor this way:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 VERSION% = TTVERSION\par MAJOR% = VERSION% / 256\par MINOR% = VERSION% - MAJOR% * 256\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PRINT USING "The Time Library version number is #.#."; MAJOR%, MINOR%\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 FUNCTION TTStatus AS INTEGER\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 TTStatus\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 TTStatus function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns true (a value of 1) if the Time Library has been started with TTStartup and has not yet been shut down, or false (a value of 0) if the Time Library is not started.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 FUNCTION DateString AS STRING\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 DateString\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DateString function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns the current date as a string.\par The string contains the full month name, the date, a comma, and the four digit year. For example, the command\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PRINT DATESTRING\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 would print\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 July 22, 1998\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 if the date was, in fact, set to July 22, 1998 on the computer\rquote s clock.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 There has been a lot of attention in the press about the Year 2000 bug (also known as the Y2K bug}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 Y2K bug}}}{\fs20 ), when the computer world is apparently scheduled to end. In general, this bug does not exist on the Apple\~II}{\fs18 GS}{\fs20 , although certain applications may contain the bug. While the Apple\~II}{\fs18 GS }{\fs20 clock is limited to a two digit year, the operating system starts the cycle at 1940, returning dates from January 1, 1940 to December 30, 2039. Of course, this means there is a Year 2040 bug on the Apple\~II}{\fs18 GS}{\fs20 , but at this point we can only hope we\rquote re around to care!\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 FUNCTION TimeString AS STRING\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 TimeString\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 TimeString function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns the current time as a string.\par The time is returned as a two-digit hour, a colon, a two digit minute, a colon, and a two digit second. For example, at half past noon, TIMESTRING would return \ldblquote 12:30:00\rdblquote .\par The hour is always formatted with two digits, even if they are zero. For example, 9:00 AM is \ldblquote 09:00:00\rdblquote , and 15 minutes past midnight is \ldblquote 00:15:00\rdblquote . The hour is also returned in 24 hour format, so 1 PM is \ldblquote 13:00:00\rdblquote .\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SUB Time ((timeRecord))\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 Time\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 Time statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns the current date and time in a time record. The record, declared in TimeTool.gst, looks like this:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 type timeRecord\par   year as integer                    ; -32768 to 32767; always 1940 to 2039\par   month as integer                   ; 1 to 12\par   day as integer                     ; 1 to 31\par   hour as integer                    ; 0 to 23\par   minute as integer                  ; 0 to 59\par   second as integer                  ; 0 to 59\par   millisecond as integer             ; 0 to 999; always 0\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 end type\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par When you call TIME, you pass a variable declared as TIMERECORD as the parameter. The record is filled in with the current date and time, as set on the computer\rquote s built-in clock.\par For the most part, these fields are self-explanatory. Only two deserve special comment.\par The year can range over the entire valid range of integers, but this command will never return a value outside of the range 1940 to 2039. As discussed in the description of the DATESTRING function, this means there is no Year 2000 bug. The wide range of years is intended for future expansion, where other time commands that manipulate dates might return values the computer\rquote s clock cannot.\par The millisecond field is not used on the Apple\~II}{\fs18 GS}{\fs20 , since the Apple\~II}{\fs18 GS}{\fs20  clock doesn\rquote t provide the time to that level of accuracy. The field will always be set to 0. It is included for use by more accurate clocks and for use on other computers that GSoft\~BASIC might be ported to.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Using the Time Library}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Using the Time Library\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \f4\cgrid {\fs20 Here\rquote s a short program that shows how to use the Time Library to read the date and time. It shows the proper way to initialize and shut down the library.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 LOADLIBRARY 2\par DIM T AS TIMERECORD\par PRINT "The current time is "; TIMESTRING\par PRINT "The date is "; DATESTRING\par TIME (T)\par PRINT\par PRINT "The year is         ";T.YEAR\par PRINT "The month number is ";T.MONTH\par PRINT "The date is         ";T.DAY\par PRINT "The hour is         ";T.HOUR\par PRINT "The minute is       ";T.MINUTE\par PRINT "The second is       ";T.SECOND\par PRINT "The millisecond is  ";T.MILLISECOND\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 UNLOADLIBRARY 2\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \sect }\sectd \lndscpsxn\sbkodd\linex0\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Chapter 19: Tool Interface\par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Chapter 19 \endash  Tool Interface}{\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\v\f4\fs36\cgrid {\tc {\v Chapter 19 \endash  Tool Interface\tcl1}}}{\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 {\*\bkmkstart bk34}Thanks to its support for records and pointers, GSoft\~BASIC is the first BASIC to offer support for the toolbox that is as natural and complete as the support in other languages, like C, Pascal and Modula-2.\par This chapter describes how the toolbox interface works and how to interpret Apple\rquote s toolbox documentation, written for C and assembly language, for use with GSoft\~BASIC. It also covers calls to GS/OS, the disk operating system of the Apple\~II}{\fs18 GS}{\fs20 .\par This chapter does not document the toolbox or GS/OS, of course. Apple\rquote s documentation of the Apple\~II}{\fs18 GS}{\fs20  toolbox and GS/OS}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GS/OS}}}{\fs20  is in five volumes, totaling over 3500 pages. These books are available as reprints from the Byte Works. The complete set includes these books:\par \par }{\i\fs20 Apple\~II}{\i\fs18 GS}{\i\fs20  Toolbox Reference Volume 1\par Apple\~II}{\i\fs18 GS}{\i\fs20  Toolbox Reference Volume 2\par Apple\~II}{\i\fs18 GS}{\i\fs20  Toolbox Reference Volume 3\par Programmer\rquote s Reference for System 6.0.1\par Apple\~II}{\i\fs18 GS}{\i\fs20  GS/OS Reference\par }{\fs20 \par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 toolbox\:learning}}}{\fs20 This chapter also doesn\rquote t teach toolbox programming, and neither do the reference books mentioned above. We offer a self-study course in toolbox and GS/OS programming:\par \par }{\i\fs20 Toolbox Programming in GSoft\~BASIC\par }{\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 This introduction to toolbox programming contains an appendix with an abridged version of the toolbox and GS/OS reference manuals. You do not need to buy the five reference books to use this course.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 The Toolbox Interface}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 The Toolbox Interface\tcl2}}}{\fs28 \par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Using the Toolbox}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Using the Toolbox\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 shell\:ORCA}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ORCA shell}}}{\fs20 GSoft\~BASIC makes use of one or more compiled toolbox interface files to handle tool calls. It comes with a tool interface file that handles the Apple\~II}{\fs18 GS}{\fs20  toolbox, GS/OS}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GS/OS}}}{\fs20 , the ORCA Shell and Talking Tools}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 Talking Tools}}}{\fs20 . From your standpoint of writing a program, all of these interfaces work as if they were built right into the GSoft\~BASIC language.\par As a quick example to show how this works, and give a basis for the rest of the chapter, here\rquote s a short program that makes use of QuickDraw\~II calls. Most toolbox programs create programs that use the Apple desktop interface, with menu bars, windows, and so forth. In the interest of brevity, this example doesn\rquote t. It makes use of the fact that GSoft\~BASIC\rquote s HGR statement}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 HGR statement}}}{\fs20  starts QuickDraw\~II to create a very short program.\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\pard\plain \s31\fi360\keepn\widctlpar\adjustright \v\f6\fs18\cgrid {\xe {\v\fs18 }{\v\fs18 samples\:QuickDraw\~II}}}{\fs18 HGR\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 DIM R AS RECT\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 FOR I = 1 TO 1000\par   R.H1 = RND (1) * 320\par   R.H2 = RND (1) * 320\par   IF R.H2 < R.H1 THEN\par     T% = R.H1\par     R.H1 = R.H2\par     R.H2 = T%\par }\pard \s31\fi360\widctlpar\adjustright {\fs18   END IF\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18   R.V1 = RND (1) * 200\par   R.V2 = RND (1) * 200\par   IF R.V2 < R.V1 THEN\par     T% = R.V1\par     R.V1 = R.V2\par     R.V2 = T%\par }\pard \s31\fi360\widctlpar\adjustright {\fs18   END IF\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18   SET640COLOR ( RND (1) * 16)\par   PAINTOVAL (R)\par NEXT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 GET A$\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par There are three items in this program that come from the toolbox interface files rather than from GSoft\~BASIC. The first is the RECT type. Rectangles are used extensively throughout the toolbox for everything from window sizes to ovals\emdash which is how they are used here.\par Near the end of the program you\rquote ll see two calls to QuickDraw\~II. The first is SET640COLOR; it sets the pen color to one of the 16 available colors. In this program it sets them randomly. The next is PAINTOVAL, which paints an oval that\rquote s inside the RECT parameter.\par As a whole, the program draws 1000 random size ovals at random locations using random colors. When it finishes, it waits for you to press the return key, then exits.\par We\rquote ll refer back to this program later in this chapter.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 The GSoft\~BASIC Toolbox Interface}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 The GSoft\~BASIC Toolbox Interface\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 {\*\bkmkstart bk33}There is no need to include the tool interface files, as in other languages. Instead, GSoft\~BASIC loads the tool interface file automatically as it starts.\par Of course, to do that, it needs to know where the tool interface file is located. GSoft\~BASIC searches for tool interface files in three locations. The names of these prefixes, in the order they are searched, are:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 13:GSoftDefs:\par 9:\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 8:\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GSoft\~BASIC\:shell version}}}{\fs20 The first prefix is the ORCA library prefix. This is the natural place to put the tool interface files if you are using the shell version of GSoft\~BASIC, running it as a language from the ORCA shell.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GSoft\~BASIC\:Finder version}}}{\fs20 Prefix 9: is set to the prefix of the executing application, in this case either the ORCA shell for the shell version of GSoft\~BASIC, or GSoft.Sys16 for the Finder version. This is the natural place to put the tool interface files for the Finder version of GSoft\~BASIC.\par The last prefix searched is 8:, which is the default prefix when the GSoft\~BASIC program starts to execute. You can put compiled tool interface files here for user tools used only with a specific program you are developing.\par For each directory, GSoft\~BASIC searches all of the files looking for tool interface files. Tool interface files are created with CompileTool, documented in Chapter 4. Each tool interface file has a file type of $5E and an auxiliary file type of $8007. The files are loaded in the same order shown by the CATALOG command.\par An important point about this process is that duplicate tool names and records can exist. When they do, the most recently loaded definition is used. This means you can replace existing calls or records with new versions by putting the declarations in your own tool file, compiling the tool file, and placing the compiled tool file in the same directory as your program. The newer declaration overrides the original declaration, but the original tool interface file is left unchanged, so it still works with other programs that expect the unmodified tool interface file.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GSoft\~BASIC\:shell version}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GSoft\~BASIC\:Finder version}}}{\fs20 The tool interface file is compiled into a form that takes little space and loads quickly, but this form can\rquote t be read. The text version of the standard tool interface file is called GSoftTools.int. If you are using the Finder version of GSoft\~BASIC, you can find this file in the same folder as GSoft.Sys16; for the shell version, look in the ORCA Libraries folder.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Using Apple\rquote s Documentation}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Using Apple\rquote s Documentation\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 There were only two Apple\~II}{\fs18 GS}{\fs20  programming languages available when Apple\rquote s toolbox reference manuals were written: The APW Assembler (also released under the name ORCA/M) and APW C. Several programming languages were eventually released for the Apple\~II}{\fs18 GS}{\fs20 , but a toolbox reference manual was not released for each language. That\rquote s because, with a little practice, you can read Apple\rquote s documentation and use it from any language.\par There are two sources of information about how to make a particular tool call. The first is the toolbox reference manuals themselves. Looking at the documentation for PaintOval in }{\i\fs20 Apple\~II}{\i\fs18 GS}{\i\fs20  Toolbox Reference Volume 2}{\fs20 , page 16-189, you see that this call has a single parameter. You can see this either from the stack diagram used by assembly language programmers, or from the example for C programmers at the bottom of the page.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parameters\:tool calls}}}{\fs20 The assembly language documentation is generally the easiest to read, since it is presented as a diagram. Still looking at PaintOval, you see that the parameter is labeled \ldblquote POINTER to RECT defining enclosing rectangle.\rdblquote  This tells you the call expects a pointer to a RECT for its parameter. This illustrates the one big difference between pretty much every language around and the two languages used in the toolbox reference manual, assembly language and C. In most other languages, including BASIC, it makes more sense to pass a RECT as a reference parameter than as a pointer. (Value and reference parameters are covered in }{\i\fs20 Passing Parameters by Reference and Value}{\fs20  in Chapter 17.) }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parameters\:pass by reference}}}{\fs20 As far as the toolbox is concerned, there\rquote s no difference: it gets a pointer to a RECT either way, since BASIC and other languages implement reference parameters by passing a pointer; the difference is entirely in how you write the program.\par The second major source of information about making tool calls is the GSoft\~BASIC tool interface file, GSoftTools.int. Looking in that file, you see this declaration for PaintOval:\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TOOL $04, $59 SUB      PaintOval((Rect))\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 The parentheses}{\pard\plain \s25\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parentheses}}}{\fs20  around the parameter type tell you the parameter is passed by reference, and parameters passed to the toolbox by reference are always passed as a pointer. You can ignore the information before SUB; that\rquote s the tool number and tool call number, needed by GSoft\~BASIC but not by you when you are writing BASIC programs.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Putting these facts together, you can see why the call to PaintOval in the sample program at the start of this chapter looks like\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PAINTOVAL (R)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 R is a RECT record variable. Since the tool interface file tells us the parameter is passed by reference, we don\rquote t need to pass it as a pointer.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parameters\:pass by reference}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parameters\:pass by value}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 parameters\:tool calls}}}{\fs20 With a little experience, you\rquote ll be able to predict whether a pointer parameter is passed by reference, like this example, or by value, in which case you need to pass a pointer. As a general rule, parameters are passed by reference when the value is a record you fill in, and they are passed by value when the value is likely to be a pointer passed to you by the toolbox itself. For example, window pointers are passed by value, so you actually pass a pointer. The original window pointer was created by the Window Manager and passed to you as a pointer\emdash it\rquote s not a record you should, or even can, create and fill in yourself.\par Many tool calls use more than one parameter. PaintArc is one such example; it\rquote s on the page right before PaintOval in the toolbox reference manual. The three parameters are listed top to bottom; that\rquote s the order you code them in the parameter list. The toolbox documentation tells you the parameters are a pointer to a RECT and two integers. The GSoftTools.int file shows the call like this:\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TOOL $04, $63 SUB      PaintArc((Rect), %, %)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 The first parameter is a RECT, just like it was for PaintOval. The next two parameters are INTEGER values. A typical call would look like this:\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PAINTARC (R, 45, 90)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par Some tool calls return a value. One of the many examples is TextWidth, a QuickDraw\~II call that returns the width of a text string in pixels. This width takes the current graphical font into account. Looking on page 16-270 of }{\i\fs20 Apple\~II}{\i\fs18 GS}{\i\fs20  Toolbox Reference Volume 2}{\fs20 , you see three values shown on the stack before the call, and one after. You will only see a value on the stack after the tool call if the tool is a FUNCTION rather than a SUB; the value left on the stack is the value the tool call returns. This value is also on the stack before the call, but it is not a parameter. You can see this easily by looking at the declaration in GSoftTools.int:\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TOOL $04, $AB FUNCTION TextWidth(Univ, %)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 which clearly shows that TextWidth is a FUNCTION that takes two parameters.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The first parameter is a special case. Univ parameters are used when the toolbox call can accept several different types of values, or when there is no clear correlation between the value the toolbox expects and the types available in GSoft\~BASIC. In this case, the toolbox expects a pointer to a sequence of characters. It turns out you can pass a pointer to a string for this parameter, since GSoft\~BASIC strings are also a sequence of characters. The second parameter is the number of characters in the string. A typical call looks like\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 S$ = "Hello, toolbox."\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 WIDTH% = TEXTWIDTH (@S$, LEN(S$))\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 p-strings}}}{\fs20 Some tool calls expect C strings or P strings, named after C and Pascal. C strings are sequences of characters ending with a null character, which is the character CHR$(0). This is the kind of string GSoft\~BASIC uses. P strings start with one byte that tells how long the string is, followed by the characters in the string. Since a byte can only hold values from 0 to 255, this limits the length of a P string to 255 characters. Fortunately, it\rquote s pretty easy to add the length byte to the front of a GSoft\~BASIC string to fool the toolbox. The line\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 S$ = CHR$ (LEN (S$)) + S$\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 adds the required length byte to a string.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 One dirty little secret of the toolbox is that some calls were not designed for use from a high-level language. These calls return multiple values or return values that are not 2 or 4 bytes long. The vast majority of these calls are concentrated in the Integer Math Tool Set, SANE, and the Loader. Fortunately, integer math is built right into GSoft\~BASIC; and SANE, Apple\rquote s floating-point libraries, aren\rquote t used at all. GSoft\~BASIC\rquote s floating-point routines are much faster than Apple\rquote s. If you need to make any of these calls, though, you\rquote ll have to do it using a user tool that is written in assembly language and converts the toolbox parameters into something meaningful in GSoft\~BASIC.\par {\*\bkmkend bk33}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 toolbox\:interface files}{\rxe bk33}}}{\*\bkmkend bk34}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 toolbox}{\rxe bk34}}}{\v\fs20 \par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 GS/OS and the ORCA Shell Calls}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 GS/OS and the ORCA Shell Calls\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 GS/OS}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GS/OS}}}{\fs20  and }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 shell\:ORCA}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ORCA shell}}}{\fs20 ORCA Shell calls are handled the same way as tool calls. True, they are not tools, but the interfaces are created the same way and the calls are made the same way. As a GSoft\~BASIC programmer, Apple\rquote s system tools, your user tools, GS/OS and the ORCA Shell calls all work exactly the same way.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 The Role of User Tools}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 The Role of User Tools\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 user tools}}}{\fs20 GSoft\~BASIC is interpreted, so it can\rquote t actually call or be called from other Apple\~II}{\fs18 GS}{\fs20  languages. On the other hand, it supports user written tools in a way no other Apple\~II}{\fs18 GS}{\fs20  language does, providing simple calls to load and unload user tools. If you need to write a few subroutines in assembly language}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 assembly language}}}{\fs20 , you can package them in a user tool and call them from GSoft\~BASIC. Even better, the same subroutines can be used from any other Apple\~II}{\fs18 GS}{\fs20  language that supports user tools. All of the ORCA languages do.\par See }{\i\fs20 Loading and Unloading Libraries}{\fs20 , later in this chapter, for the commands used to set up user tools. Appendix D, }{\i\fs20 Writing User Tools for GSoft\~BASIC}{\fs20 , shows how the tool is actually created. Once created and loaded, you use a user tool just like a tool created by Apple.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Tool and GS/OS Errors}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Tool and GS/OS Errors\tcl2}}}{\fs28 \par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 TOOLERROR\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 TOOLERROR\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 TOOLERROR function\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\keepn\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 toolbox\:errors}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GS/OS\:errors}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ORCA Shell\:errors}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 user tools\:errors}}}{\pard\plain \s25\fi360\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 libraries\:errors}}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Returns the error code from the most recent tool, user tool or GS/OS call. A value of zero indicates there was no error.\par Apple\rquote s tools, user tools, GS/OS and ORCA Shell calls all return an error code. The error code is returned by each and every call. From the time the call completes until the next call is made you can use TOOLERROR to find out what the error code was.\par Zero is universally used to indicate that no error occurred. If an error does occur, the error code tells you two things. First, dividing the error by 256 and converting the result to an integer by truncation tells you the tool number for the tool that flagged the error. For example,\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TOOLNUMBER% = TOOLERROR / 256\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 sets the INTEGER variable TOOLNUMBER% to the number of the tool that flagged the error. The tool that flagged the error might seem obvious, since TOOLERROR is used right after a tool call, but tool errors don\rquote t always originate with the tool you call. For example, it\rquote s quite possible to get error 513 ($0201), which is a Memory Manager error indicating insufficient memory, from a NEWWINDOW call, which is a Window Manager tool call.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 GS/OS errors are reported just like tool errors. The tool number for a GS/OS error will be 0.\par User tool errors are also reported the same way as Apple\rquote s toolbox errors. The tool number will match the user tool number, which could duplicate an Apple tool number.\par The error numbers themselves are documented with the tools. You can find a summary of all of the error numbers used by Apple\rquote s toolbox and GS/OS calls in Appendix E of }{\i\fs20 Programmer\rquote s Reference for System 6.0}{\fs20 .\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Loading and Unloading Libraries}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Loading and Unloading Libraries\tcl2}}}{\fs28 \par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 LOADLIBRARY expression\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 LOADLIBRARY\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LOADLIBRARY statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 user tools\:loading}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 libraries\:loading}}}{\fs20 Loads a user tool from disk.\par The command name refers to a user tool as a library for compatibility with other versions of GSoft\~BASIC that may someday exist on platforms other than the Apple\~II}{\fs18 GS}{\fs20 . The generic term "library" makes sense across all platforms, although libraries are always implemented as user tools in the Apple\~II}{\fs18 GS}{\fs20  version of GSoft\~BASIC.\par }{\f6\fs20 expression}{\fs20  is the tool number to load. User tools are numbered 0 to 255; this number is coded as part of the file name and is used in the interface file.\par GSoft\~BASIC looks for a file with the name UserToolXXX, where XXX is the tool number. It looks first in the local directory, which defaults to the location of the GSoft\~BASIC interpreter. The local directory can be changed before using LOADLIBRARY using the CHDIR command. If the tool is not found in the local directory, GSoft\~BASIC looks in the System directory using the path *:System:Tools:UserToolXXX.\par See Appendix D for more information about writing user tools.\par See also UNLOADLIBRARY.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 UNLOADLIBRARY expression\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 UNLOADLIBRARY\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 UNLOADLIBRARY statement\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 user tools\:unloading}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 libraries\:unloading}}}{\fs20 Unloads the specified user tool, freeing the RAM used by the tool.\par The command name refers to a user tool as a library for compatibility with other versions of GSoft\~BASIC that may someday exist on platforms other than the Apple\~II}{\fs18 GS}{\fs20 . The generic term "library" makes sense across all platforms, although libraries are always implemented as user tools in the Apple\~II}{\fs18 GS}{\fs20  version of GSoft\~BASIC.\par See also LOADLIBRARY.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 TOOL and GSOS Tokens}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 TOOL and GSOS Tokens\tcl2}}}{\fs28 \par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 GSOS\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 GSOS\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GSOS token\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 When you use a GS/OS}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GS/OS}}}{\fs20  call in a GSoft\~BASIC program, the GS/OS call name is converted into a three byte sequence. These bytes are the GSOS token, which marks the start of the call sequence; and a two byte call number, coded as two individual bytes, least significant byte first. These three bytes are followed by the parameter list, if any.\par Except for the substitution of the word GSOS for TOOL, these tokens are used in exactly the same way as TOOL tokens, described below.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 TOOL\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 TOOL\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 TOOL token\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 When you use a tool call in a GSoft\~BASIC program, the tool name is converted into a three byte sequence. These bytes are the TOOL token, which marks the start of the tool call sequence; the tool number; and the tool call number. These three bytes are followed by the parameter list, if any.\par If the tool interface file is available when you edit or list the program, GSoft\~BASIC automatically looks the name up based on the tool and tool call numbers, displaying the name of the tool call. If the tool call file is missing for some reason, the tool call is listed like this:\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TOOL<$04,$DB>\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par The first number is the tool number, while the second is the tool call number. This particular token is for tool 4, QuickDraw\~II; and tool call $DB, Set640Color.\par You can type tool calls using this format, too. This feature actually exists so you can edit a file without the tool interface file, something that might happen if you edit a program that uses a user tool you don\rquote t have installed. GSoft\~BASIC needs to be able to read a token in the same form so it is possible to convert the program back to its tokenized form. TOOL tokens must be typed exactly as shown, though. No spaces can be inserted, and two digit hexadecimal numbers must be used for the tool number and tool call number.\par Fortunately, this isn\rquote t a big issue, since you\rquote ll normally have tool interface files for any tools you use, and with the tool interface file installed, you can use the tool call name rather than the numbers.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 LIBRARY\par }\pard \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\pard\plain \s29\sb160\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\tc {\v\fs20 }{\v\fs20 LIBRARY\tcl3}}}{\v\fs20 \par }\pard\plain \s25\sb40\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\sb40\keepn\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 LIBRARY token\bxe }}}{\v\fs20 \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 user tools}}}{\fs20 When you use a tool call in a GSoft\~BASIC program, the user tool name is converted into a three byte sequence. These bytes are the LIBRARY token, which marks the start of the tool call sequence; the user tool number; and the user tool call number. These three bytes are followed by the parameter list, if any.\par Except for the substitution of the word LIBRARY for TOOL, these tokens are used in exactly the same way as TOOL tokens, described above.\par \sect }\sectd \lndscpsxn\sbkodd\linex0\endnhere\titlepg\sectdefaultcl {\headerl \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 Appendices\par }}{\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Appendix A: Error Messages\par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Appendix A \endash  Error Messages}{\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\v\f4\fs36\cgrid {\tc {\v Appendix A \endash  Error Messages\tcl1}}}{\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 This appendix shows all of the errors that GSoft\~BASIC can generate. In starts with a table that shows the error number and error message. The error number shown is the error number returned by the ERR function.\par Next is an expanded description of the short text error message printed by GSoft\~BASIC, along with common causes for the error.\par }\pard\plain \s32\fi-1800\li2160\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx1260\tx2160\adjustright \f4\cgrid {\fs18 Error\tab Message\par }\pard\plain \s25\fi-1800\li2160\sb40\widctlpar\tx1260\tx2160\adjustright \f4\cgrid {\fs18 0\tab Undefined statement\par 1 *\tab Unimplemented command\par 2\tab Syntax error\par 3\tab The line is too long\par 4\tab Line numbers must range from 1 to 65535\par 5\tab The program is too long\par 6\tab Expression too complex\par 7\tab Out of variable table space\par 8\tab Type mismatch\par 9\tab Not enough subscripts\par 10\tab Too many subscripts\par 11\tab Invalid subscript\par 12\tab Redimensioned variable error\par 13\tab The size of a value exceeded 32767 bytes\par 14\tab More than 10 nested control statements\par 15\tab NEXT without FOR\par 16\tab Too many nested subroutine calls\par 17\tab RETURN without GOSUB\par 18\tab Expected an integer\par 19\tab Integer overflow\par 20\tab GOSUB without RETURN\par 21\tab FOR without NEXT\par 22\tab POP without GOSUB\par 23\tab Invalid function parameter\par 24\tab A string value exceeded 32767 characters\par 25\tab Illegal quantity error\par 26 *\tab Math result is inexact\par 27\tab RENUMBER overlaps old and new lines\par 28\tab Expected a string\par 29\tab INPUT or DATA is too long\par 30\tab INPUT or DATA contains an empty or misformed number\par 31\tab Out of data\par 32\tab Could not start QuickDraw\par 33\tab WHILE without WEND\par 34\tab WEND without WHILE\par 35\tab ELSE without IF\par 36\tab Block IF without END IF\par 37\tab END IF without IF\par 38\tab Multiple ELSE clause\par 39\tab DO without LOOP\par 40\tab LOOP without DO\par 41\tab Missing CASE\par 42\tab SELECT CASE without END SELECT\par 43\tab END SELECT without SELECT CASE\par 44\tab CASE without SELECT CASE\par 45\tab PRINT USING format string has no format models\par 46\tab PRINT USING format string has \\ without closing \\\par 47\tab PRINT USING format string has more than 24 characters in a number model\par 48\tab Undefined function\par 49\tab Incorrect number of parameters\par 50\tab ASCII file could not be written\par 51\tab ASCII file could not be read\par 52\tab File numbers must be in the range 1 to 32767\par 53\tab Unopened file referenced\par 54\tab Too many open files\par 55\tab The file is already open\par 56\tab File I/O error\par 57\tab Out of memory\par 58\tab Output attempted to a file opened for input\par 59\tab Input attempted to a file opened for output\par 60\tab Illegal file name\par 61\tab Undefined subroutine\par 62\tab Inappropriate END SUB or END FUNCTION\par 63\tab Parameter type mismatch\par 64\tab SETMEM and CLEAR cannot be used in a procedure\par 65\tab Duplicate field\par 66\tab Redefined type\par 67\tab Expected type\par 68\tab Illegal use of a nil pointer\par 69\tab Undefined field\par 70\tab Record used inside itself\par 71\tab Functions cannot return records\par 72\tab Unknown tool\par 73\tab Could not load the library\par 74\tab Hexadecimal numbers cannot exceed $FFFFFFFF\par 75\tab Misuse of a constant\par 76\tab Misformed tool or GS/OS token\par 77\tab HGR must be used before graphics commands\par 78\tab LEN is required for RANDOM files\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard \s25\fi-360\li720\sb40\widctlpar\adjustright {\fs18 *\tab Commands marked with an asterisk can be generated by the ERROR command, but will not be generated by GSoft\~BASIC. These errors are used in specialized, non-commercial versions of the interpreter.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 A string value exceeded 32767 characters\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Strings are limited to 32767 characters; an operation was attempted that would have created a longer string.\par Change the program so all strings are smaller than 32767 characters.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 ASCII file could not be read\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 After using the EDIT command and an editor to make changes to your BASIC program, the editor writes the edited program as an ASCII file. When the editor returns control to GSoft\~BASIC, GSoft\~BASIC tries to read that file. This error indicates that the file could not be read.\par The most likely reason for this error is a damaged disk, although lack of memory could cause the error. If you see this error, use a program that checks disk for bad blocks. If you have a program that will do it, check the structure of the disk, too.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 ASCII file could not be written\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 GSoft\~BASIC converts the tokenized BASIC program to an ASCII file when you use a full screen editor via the EDIT command or when you debug a program using the DEBUG command. This error indicates that the file could not be written.\par There are a variety of reasons why the file might not be written. The most common are a lack of space on the disk where the program is located, a disk error, or a lack of free memory.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Block IF without END IF\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 An IF-THEN statement was started, but no END IF was found.\par Remember to include an END IF for all block IF statements. For example,\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 IF FOUND THEN CALL PROCESS\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 is a perfectly legal BASIC statement, contained entirely on one line, but\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 IF FOUND THEN\par }\pard \s31\fi360\widctlpar\adjustright {\fs18   CALL PROCESS\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 needs an END IF.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CASE without SELECT CASE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A CASE statement was found outside of a SELECT CASE.\par Make sure all CASE statements appear between a SELECT CASE and an END SELECT. Keep in mind that other mismatched statements might cause this error even if the CASE statement appears between a SELECT CASE and END SELECT. For example,\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 SELECT CASE COLOR\par   CASE RED\par     IF SHORT THEN\par       PRINT "R";\par     ELSE\par       PRINT "RED";\par   CASE GREEN\par     IF SHORT THEN\par       PRINT "G";\par     ELSE\par       PRINT "GREEN";\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SELECT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 could cause this error, even though the real error is that the IF statement has no matching END IF.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Could not load the user tool\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The LOADLIBRARY command was unable to load the user tool.\par Make sure the user tool file is in the Tools folder, inside the System folder. Check to insure there is enough memory to load the tool. Check the system disk for bad blocks.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Could not start QuickDraw\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The HGR statement encountered an error starting QuickDraw\~II. This is generally caused by lack of memory.\par If you are using a program that allows more than one program to run, shut down the other programs. Try shift-booting to prevent desk accessories and inits from using memory\emdash possibly memory critical to QuickDraw\~II.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 DO without LOOP\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A DO statement was started, but the program or procedure finished without finding a matching LOOP.\par Make sure there is exactly one LOOP for each DO. Keep in mind that other mismatched statements might cause this error even if there is a matching LOOP for the DO. For example,\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DO\par   GET #1, CH\par   IF CH = 13 THEN\par     PRINT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 LOOP WHILE NOT EOF(1)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 would cause this error if the first value read is not 13, even though the real error is that the IF statement has no matching END IF.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Duplicate field\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A record contains two fields with the same name.\par Make all field names in a given record unique.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 ELSE without IF\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 An ELSE statement was encountered when no IF statement was active.\par Make sure ELSE statements are only used when an IF statement is active.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 END IF without IF\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 An END IF was found with no matching IF-THEN statement.\par Make sure IF-THEN statements have exactly one matching END IF statement. Check for other incomplete statements that might cause this error, such as\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 IF NOT DONE THEN\par   WHILE P <> NIL\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END IF\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 END SELECT without SELECT CASE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 An END SELECT statement was found without a matching SELECT CASE statement.\par Make sure there is exactly one END SELECT for each SELECT CASE. Keep in mind that other mismatched statements might cause this error even if there is a matching END SELECT for the SELECT CASE. For example,\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 SELECT CASE COLOR\par   CASE RED\par     IF SHORT THEN\par       PRINT "R";\par     ELSE\par       PRINT "RED";\par   CASE GREEN\par     IF SHORT THEN\par       PRINT "G";\par     ELSE\par       PRINT "GREEN";\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SELECT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 could cause this error, even though the real error is that the IF statement has no matching END IF.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Expected an integer\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 An INTEGER value was expected, but a value that could not be converted to an INTEGER was encountered. For example, this error would occur if a string were used as an array subscript.\par Change the expression so an INTEGER or a number that can be converted to an INTEGER is created. For example, you could convert a string representing a number to a number using VAL, as in\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 GET A$\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PRINT A(VAL(A$))\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Expected a string\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A string value was expected, but some other type of value was encountered. For example, this error would occur if a number was used as the file name in an OPEN statement.\par Change the expression so a string appears in the required position.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Expected type\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A statement expected a type, such as INTEGER or the name of a record, but some other token was found.\par Check for spelling errors or other typographical errors. Check the documentation for the statement involved to make sure it is entered correctly. If the statement is using a type you declared, make sure the statement that declares the type is executed before the statement that uses the type.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Expression too complex\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The expression stack overflowed during evaluation of the expression.\par Make the expression shorter by using temporary variables.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 File I/O error\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 GS/OS reported an error while reading or writing a file.\par This can be caused by any number of reasons. The most common occur when writing a file. Problems to look for include:\par }\pard \s25\fi-360\li720\sb40\widctlpar\adjustright {\fs20 \bullet \tab Writing to a full disk.\par \bullet \tab Creating a new file in the root directory of a ProDOS format disk that already has 51 entries.\par \bullet \tab A disk error. Check for bad blocks or a bad directory structure.\par \bullet \tab A lack of free memory to open or manipulate the file.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 File numbers must be in the range 1 to 32767\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The programs used a file number outside the allowed range.\par Change the file number to a number in the allowed range.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 FOR without NEXT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The program ended after starting a FOR loop, but without finishing with a NEXT.\par An obvious way to make this error is forgetting a NEXT, but it can also occur if you jump out of an unfinished FOR loop. For example,\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 10 FOR I = 1 TO 10\par 20   GOTO 40\par 30 NEXT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 40 END\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 is not legal, and will cause this error.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Functions cannot return records\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A FUNCTION declaration has a function return type that is a record.\par Functions can return pointers to records, but not records. Change the return type so it is something other than a record, or so it is a pointer to a record.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 GOSUB without RETURN\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The program ended after making a GOSUB call, but without a matching RETURN.\par The most likely cause of this error is forgetting the RETURN at the end of a subroutine. In any case, make sure each subroutine called with GOSUB returns with a RETURN or removes the call with POP.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Hexadecimal numbers cannot exceed $FFFFFFFF\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A hexadecimal constant exceeds the maximum allowed value.\par Change the hexadecimal value to an allowed value.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 HGR must be used before graphics commands\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A graphics command, such as HPLOT, was used before the HGR command.\par Graphics commands use Apple\rquote s QuickDraw\~II tool set, which must be initialized before any of the graphics commands can be used. The easiest way to initialize QuickDraw\~II is with the HGR command, although starting the tool manually will also work, and will avoid this error.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Illegal file name\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A file name was formed improperly.\par Check the file name to make sure it conforms to the requirements for the file system in use. Keep in mind that GS/OS can use many file systems, and each has unique requirements. If you are using DIR$, check to make sure the wildcard characters used match the requirements for DIR$.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Illegal quantity error\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A valid number that is not allowed for a particular purpose has been passed to a built-in command. For example, using a negative number for a parameter to MID$ would cause this error.\par Use a correct number for the parameter.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Illegal use of a nil pointer\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The program attempted to use the value pointed to by a pointer, but the pointer itself was set to NIL.\par For example, the program\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM P AS POINTER TO INTEGER\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 PRINT P^\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 would generate this error. The pointer has not been set to point to anything.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Give the pointer a value.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Inappropriate END SUB or END FUNCTION\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 An END SUB was found at the end of a FUNCTION or in the main program, or an END FUNCTION was found at the end of a SUB or in the main program.\par Make sure exactly one END SUB appears at the end of every subroutine defined with SUB, and one END FUNCTION appears at the end of every function defined with FUNCTION. Make sure neither is used in any other way.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Incorrect number of parameters\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A procedure call does not have the same number of parameters as the corresponding procedure declaration.\par Make sure both the call and declaration use the same number of parameters.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Input attempted to a file opened for output\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A command that reads from a file was used with a file number for a file opened for output only.\par Make sure the file number is correct. If you need to read and write a file, open it as BINARY or RANDOM.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 INPUT or DATA contains an empty or misformed number\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 An INPUT statement or DATA statement had a numeric variable, so it tried to read a number, but found non-numeric information.\par Either the input data is incorrect or the program is incorrect. Change one or the other so INPUT and DATA get the kind of values they need.\par If you need to read a value that might be a number, but you can\rquote t tell beforehand, read the value as a string. Scan what you get to see if it is a valid number. If so, you can use VAL to convert the string to a number.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 INPUT or DATA is too long\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A single piece of information is longer than 255 characters. Generally that will be a string that is too long in an input file, but it could be a number with lots of unnecessary leading zeros, or a number that is longer than need be because of unneeded fraction digits.\par In files containing strings, consider reading the file character by character and assembling the string inside the program.\par For numbers, try using scientific notation. Keep in mind that even DOUBLE numbers are only accurate to about 15 decimal digits, so any more than 16 significant digits won\rquote t change the final DOUBLE value.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Integer overflow\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 This error occurs due to a numeric overflow when converting to an INTEGER or LONG value, such as\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 I% = 38000.0\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par You can reduce the value or use a different kind of value. Keep in mind that GSoft\~BASIC does handle infinity, so you can\rquote t overflow a SINGLE or DOUBLE value.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Invalid function parameter\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A type mismatch occurred in a built-in BASIC function; for example, a string may have been passed to a function that only accepts numbers.\par Change the parameter so the types match. If you need to use a value that is not the correct type, consider type casting or converting the value to the correct type with functions like CINT or STR$.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Invalid subscript\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A subscript is less than zero or greater than the maximum subscript for the array. For example,\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM A(5)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 A(6) = 6\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 would cause this error.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Change the size of the array or the subscript used.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Line numbers must range from 1 to 65535\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A line number was found that lay outside the allowed range.\par Change the line number so it is in the allowed range.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 LEN is required for RANDOM files\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A file is being opened for RANDOM input and output with the OPEN statement. RANDOM files must have a record length, specified with the LEN parameter, but no LEN parameter is present.\par Add a LEN parameter to the open statement. The length should be the size of one record in the random access file.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 LOOP without DO\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A LOOP statement was encountered without a matching DO.\par Make sure there is exactly one LOOP for each DO. Keep in mind that other mismatched statements might cause this error even if there is a DO for the LOOP statement. For example,\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DO\par   GET #1, CH\par   IF CH = 13 THEN\par     PRINT\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 LOOP WHILE NOT EOF(1)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 would cause this error if the first value read is 13, even though the real error is that the IF statement has no matching END IF.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Math result is inexact\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A valid number has been passed to a math function, but the result is not valid.\par The commercial version of GSoft\~BASIC does not use this error. It is reserved for specialized versions that report math errors in different ways than the commercial version.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Misformed tool or GS/OS token\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A tool token in a source file does not follow the rules for writing a token.\par Review the rules for coding tokens in the description of TOOL in Chapter 19.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Missing CASE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 SELECT was used, but there was no CASE immediately after.\par The correct syntax for the SELECT statement is\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 SELECT CASE expression\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Misuse of a constant\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 An attempt was made to assign a value to a constant, extract the address of a constant, or find the size of a constant.\par These operations are either forbidden on constants or make no sense when applied to a constant. If the error occurs when a constant is passed as a parameter, make sure the constant is passed by value, not by reference. (A simple way to do this is to enclose the constant in parentheses.)\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 More than 10 nested control statements\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Control statements were nested too deeply.\par Use subroutines to handle inner nested statements or redesign the logic so the nested statements are not so deep.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Multiple ELSE clause\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Two ELSE statements were found for a single IF statement.\par Make sure there is only one ELSE clause for each IF-THEN statement. You can use multiple ELSE IF statements after IF-THEN and before ELSE, but only one ELSE.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 NEXT without FOR\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A NEXT statement was encountered without a matching FOR statement.\par This error can occur due to an unfinished statement. If you think the FOR-NEXT statements are matched, look for misformed statements inside the loop, like\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 FOR I = 1 TO 10\par   IF A(I) < 0.0 THEN\par     A(I) = 0.0\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 NEXT I\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par In this case, the IF statement is not complete. The NEXT appears when BASIC expects an END IF, but the actual error is a NEXT with no matching FOR.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Not enough subscripts\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 More subscripts are expected for the array than are supplied. For example,\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM A(5, 5)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 A(5) = 6\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 would cause this error.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Supply the required number of subscripts. Make sure you do not have more than one array with the same name.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Out of data\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A READ statement tried to read information from a DATA statement, but there were no unused DATA statements.\par Make sure the DATA statements are in the same procedure as the READ statements, or that both are in the main program. If you need to reuse data, use RESTORE.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Out of memory\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 SETMEM or a disk I/O command needed free memory, but could not find a large enough continuous piece of free memory to satisfy the need.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ALLOCATE statement}}}{\fs20 This error does not occur for ALLOCATE. While ALLOCATE gets memory from the same memory pool as SETMEM and the disk commands, it does not flag an error if there is not enough memory. Instead, ALLOCATE returns the NIL pointer, allowing you to check for the error and handle it inside your program.\par Some possible solutions are:\par }\pard \s25\fi-360\li720\sb40\widctlpar\adjustright {\fs20 \bullet \tab Reduce the amount of memory used for the program or variable space.\par \bullet \tab Reduce the memory used by ALLOCATE statements.\par \bullet \tab If you are using a program that allows you to run multiple programs, quit the other programs before running GSoft\~BASIC.\par \bullet \tab Shift-boot to reduce the memory used by desk accessories and inits.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Out of variable table space\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The variables, variable values, strings and local variable space for procedures exceeded the memory set aside for variables.\par Increase the memory used for variables using the SETMEM command.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Output attempted to a file opened for input\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A command that writes to a file was used with a file number for a file opened for input only.\par Make sure the file number is correct. If you need to read and write a file, open it as BINARY or RANDOM.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Parameter type mismatch\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The type of a parameter to a subroutine or function was not the same as the type of the parameter passed to the procedure, and the types could not be converted using default type conversion rules.\par Make sure all parameters are present in the procedure call, and that no extra parameters have been inserted. Make sure the values passed can be converted to the type of the declared parameter. }{\i\fs20 Check SUB and FUNCTION Parameter Lists}{\fs20  in Chapter 17 for the rules that apply to parameter types.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 POP without GOSUB\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A POP statement was encountered when no GOSUB was active.\par Change the program so POP is only used after a GOSUB, and multiple POP statements are not used for a single GOSUB.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 PRINT USING format string has \\ without closing \\\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A PRINT USING format string contained a \\ character, starting the format model for a fixed length string field, but no matching \\ character was found to end the format model.\par Make sure only space characters appear between the \\ characters in a fixed length string format model. If you are trying to print a \\ character from the format string, precede the \\ character with a _ character, as in\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PRINT USING "_\\#"; 45\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 PRINT USING format string has more than 24 characters in a number model\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A numeric format model has more than 24 format characters.\par Format models for numbers are limited to 24 characters. Reduce the number of characters in the format model.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 PRINT USING format string has no format models\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A PRINT USING statement has a format string, but there are no format models in the string.\par If you don't need to format any numbers or strings, use a PRINT statement to print a string constant, not PRINT USING. If you intended to use a format model, check the format string\emdash no format models were found in the format string.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Record used inside itself\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A record declaration appears inside the declaration of the same record, as in\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 TYPE POINTS\par   SUCC AS POINTS\par   H AS INTEGER\par   V AS INTEGER\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END TYPE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 linked lists}}}{\fs20 Records can contain fields that are records, but not if the field is the same as the record it appears in. If you want to create multiple records, use an array of records or a linked list of records, as in\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM POINTS(30) AS POINT\par }\pard \s31\fi360\keepn\widctlpar\adjustright {\fs18 TYPE POINTLIST\par   SUCC AS POINTER TO POINTLIST\par   H AS INTEGER\par   V AS INTEGER\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END TYPE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par See }{\i\fs20 Using the Record Type In The Record (Linked Lists)}{\fs20  in Chapter 10 for an explanation that tells why the declaration of POINTLIST is valid, but the declaration of POINTS is not.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Redefined type\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A type was defined using a type name already in use.\par Make sure all type names are unique, and that types are defined only once.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Redimensioned variable error\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 An array or record was declared twice, or the same name was used for two different arrays or records.\par In general, all arrays and records should appear in DIM statements at the top of a program or procedure. If they are all collected in one location, it\rquote s easy to avoid, or at least track down, this sort of error.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 RENUMBER overlaps old and new lines\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The RENUMBER command was used, but a renumbered line had a new line number larger than the first succeeding non-renumbered line.\par Renumber the program a different way, or eliminate line numbers completely.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 RETURN without GOSUB\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A RETURN statement was encountered when no GOSUB was active.\par Be careful of a program that drops into a subroutine, like this:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 10 FOR I = 1 TO 10\par 20   GOSUB 50\par 30 NEXT\par 50 PRINT I\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 60 RETURN\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 Adding the line\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 40 END\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 will create a working program.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SELECT CASE without END SELECT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A SELECT CASE statement was started, but the program or procedure finished without finding a matching END SELECT.\par Make sure there is exactly one END SELECT for each SELECT CASE. Keep in mind that other mismatched statements might cause this error even if there is a matching END SELECT for the SELECT CASE. For example,\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 SELECT CASE COLOR\par   CASE RED\par     IF SHORT THEN\par       PRINT "R";\par     ELSE\par       PRINT "RED";\par   CASE GREEN\par     IF SHORT THEN\par       PRINT "G";\par     ELSE\par       PRINT "GREEN";\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 END SELECT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 could cause this error, even though the real error is that the IF statement has no matching END IF.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SETMEM and CLEAR cannot be used in a procedure\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The SETMEM command or CLEAR command was used in a procedure. These commands can only be used in the main body of the program, and should be used before DIM statements and type declarations.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Syntax error\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The line is not a legal BASIC statement.\par This is a general catch-all message for misformed lines. Examine the line carefully for problems, remembering that the problem may be subtle, like a comma used where a semicolon is expected.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 The file is already open\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 An OPEN statement was used to open a file, but the file was already open.\par Make sure the file is only opened one time, or that it is closed before another OPEN statement is used. You might want to close and reopen a file if it was originally open for input, and you need to write new information to the file, for example.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 The line is too long\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 GSoft\~BASIC lines are limited to 255 tokenized bytes during the conversion from ASCII text to tokenized GSoft BASIC programs. The limit doesn\rquote t technically apply to a tokenized file, although GSoft\~BASIC doesn\rquote t give you any way to create a line longer than this limit. This error is flagged as a file is loaded from an editor or from a disk file, not while the program executes.\par In general, tokens are shorter than ASCII text typed from the command line or in an editor, so this error won\rquote t occur until the typed line is far longer than 255 characters.\par Shorten the line until this error does not occur. If you are using long strings, consider building the string from shorter strings on multiple lines using string concatenation, like this:\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 A$ = "Hello, "\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 A$ = A$ + "world."\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 The program is too long\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The program is too big to fit in the program buffer.\par Increase the size of the program buffer using the SETMEM command.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 The size of a value exceeded 32767 bytes\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Arrays and records are limited to 32767 bytes each. You can have multiple arrays or records that, added together, exceed this size, but no single array or record can be larger than 32767 bytes.\par Reduce the size of the array or record. Consider using linked lists rather than a large array.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Too many nested subroutine calls\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 GOSUB or ON-GOSUB statements were nested more than 24 levels deep.\par Check for unwanted recursive subroutine calls. If you need to nest subroutines more than 24 levels deep, switch to subroutines created with SUB.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Too many open files\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 GSoft\~BASIC can open up to 8 files at one time. This error occurs when an OPEN statement is used while 8 files are already open.\par Reduce the number of open files. Keep in mind that you can close a file, open another, close it, then reopen the first\emdash the limit is on the number of files that are open at one time, not on the total number of files opened by the program.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Too many subscripts\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Fewer subscripts are expected for the array than are supplied. For example,\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 DIM A(5)\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 A(5, 2) = 6\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 would cause this error.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Supply the proper number of subscripts. Make sure you do not have more than one array with the same name.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Type mismatch\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A value was used in an incorrect way, such as adding a string to a number or using a pointer that points to a different kind of value than expected.\par Change the expression so the types match. If you need to use a value that is not the correct type, consider type casting or converting the value to the correct type with functions like CINT or STR$.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Undefined field\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 An attempt was made to reference a field of a record, but the field does not exist in the record.\par Check the spelling for the record field. Make sure you are using a value of the kind of record you expect.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Undefined function\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A FN function was used, as in\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PRINT FN SQUARE (4)\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 but no DEF FN statement had been found which defined the function.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Double-check the spelling in the function declaration and its use. Make sure the DEF FN appears in the same procedure as the line containing the DEF FN function call, or that both appear in the main program. Make sure the DEF FN declaration is executed before the function is used the first time.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Undefined statement\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A command that uses a line number as a destination, such as\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 GOTO 500\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 referred to a line number that was not found.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Change the command to refer to a line number that exists, or add the appropriate line number to a statement. If the line number exists, but the line number is not in the same procedure as the statement that uses it, move both statements to the same procedure.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Undefined subroutine\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A CALL statement was used, but the identifier that follows is not the name of a subroutine defined with a SUB statement.\par Check spelling to make sure the subroutine name is spelled correctly. Make sure the subroutine is in the program file. Keep in mind that tool calls and GS/OS calls do not need a CALL statement, just the identifier.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Unimplemented command\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A command that is recognized by some versions of GSoft\~BASIC is not available in this version.\par You can generate this command deliberately with the ERROR command, but it is not generated by the commercial release of GSoft\~BASIC 1.0.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Unknown tool\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A tool, user tool, or GS/OS call was encountered in the program, but the tool was not found in the tool symbol table.\par Make sure the GSoftTools.int file is in the correct location. (It can appear in several places; see Chapter 19.) If the program uses additional tool files, be sure they are also in place. If the program was written with a later version of GSoft\~BASIC than the one you are using, upgrade your copy.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 Unopened file referenced\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The program used a file number in a command that only works on an open file, but no file with the given number was open.\par Use OPEN to open a file before using any other command to manipulate the file. Make sure you have not closed the file with CLOSE.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 WEND without WHILE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A WEND was encountered when no WHILE statement was active.\par Make sure WEND is only used when a WHILE loop is active. Keep in mind that other mismatched statements can make a correct WHILE-WEND loop generate this error. See the example for \ldblquote WHILE without WEND,\rdblquote  for one way this can happen.\par }\pard\plain \s29\sb160\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 WHILE without WEND\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The end of the program or subroutine was reached while a WHILE statement was active, but no WEND was found.\par Make sure all WHILE statements have a matching WEND. Make sure the matching WEND is not hidden by another unfinished statement. For example,\par \par }\pard\plain \s31\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 P = CUSTOMERS\par WHILE P <> NIL\par   IF P.NAME = NAME THEN\par     CALL MATCHFOUND(P)\par     P = NIL\par   ELSE\par     P = P^.SUCC\par }\pard \s31\fi360\widctlpar\adjustright {\fs18 WEND\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 will generate this error if P is NIL right away, even though the real error is that the IF has no matching END IF.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \sect }\sectd \lndscpsxn\sbkodd\linex0\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Appendix B: Console Control Codes\par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Appendix B \endash  Console Control Codes}{\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\v\f4\fs36\cgrid {\tc {\v Appendix B \endash  Console Control Codes\tcl1}}}{\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 text programming}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 text screen}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 console control codes}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 shell\:GSoft\~BASIC}}}{\fs20 When you are writing programs that will be executed in the GSoft\~BASIC shell or from the Finder after using MakeRuntime, you have several special console control codes available. These are special characters which cause the console to take some action, like moving the cursor or turning the cursor off. This appendix lists those console control codes.\par Keep in mind that these codes are specific to the console driver used with GSoft\~BASIC. While they are fairly common on Apple\~II}{\fs18 GS}{\fs20  console drivers, they are not universal. These codes don\rquote t apply at all if you are writing text to the graphics screen, printing to a printer, or writing to a disk file.\par Use the CHR$ function to convert these codes to characters, and any output statement to send them to the console. For example,\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 PRINT CHR$(7);\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 will beep the speaker.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 Character codes in the range 0 to 31 that are not listed in the table are ignored.\par Character codes from 32 to 127 are ASCII characters. Sending them to the console driver displays the character and moves the cursor forward one position. If the cursor starts in the rightmost position on a line, it moves to the first position of the following line, scrolling the screen if necessary.\par If you send a code from 128 to 255 to the console driver, it starts by subtracting 128. The result is in the range 0 to 127, and is treated as described above.\par In many cases, there is a built-in BASIC command that does the same thing as the control codes. You can find these commands scattered throughout Chapter 13, }{\i\fs20 Input and Output}{\fs20 .\par \par }\pard\plain \s32\fi-720\li1080\ri360\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \adjustright \f4\cgrid {\fs20 Code\tab Description\par }\pard\plain \s25\fi-720\li1080\ri360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 5\tab Turn the cursor on. The character under the cursor is displayed as an inverse character. You would normally use this code to indicate that the user should type a character.\par 6\tab Turn the cursor off. This is the default; the cursor position is remembered, but there is no visible indication of the cursor position on the screen.\par 7\tab Beep the speaker.\par 8\tab Move the cursor one space to the left. Does nothing if the cursor is in the leftmost column.\par 10\tab Move the cursor down one line. The cursor is not moved to the leftmost column; it simply moves down. If the cursor starts in the lowest line, the screen scrolls up one line, losing the topmost line and replacing the bottommost line with spaces; in this case the relative position of the cursor does not change.\par 11\tab Clear to the end of the screen. All characters under the cursor, to the right of the cursor, or on lines below the cursor are replaced with spaces.\par 12\tab Clear the screen and home the cursor. All characters are replaced with spaces, and the cursor is moved to the top left position on the screen. This does the same thing as BASIC\rquote s HOME statement.\par 13\tab Carriage return. The cursor moves to the leftmost column on the current line.\par 14\tab Standard characters. All characters printed after sending this code use the standard display set. More precisely, the most significant bit is set on characters before they are displayed, giving standard ASCII characters. In most cases, it makes more sense to use BASIC\rquote s NORMAL statement.\par 15\tab Alternate characters. Characters are sent to the screen without setting the most significant bit, so they are displayed using either mousetext or inverse characters.\par \tab \tab Looking at }{\i\fs20 Text Screen Codes}{\fs20  in Appendix C, printing an ASCII character from the rightmost eight columns would display as the character eight columns to the left. For example, printing A would display an inverse A.\par 24\tab Mousetext off. Turns off the mousetext mode enabled with code 27. In most cases, it makes more sense to use BASIC\rquote s NORMAL statement.\par 25\tab Moves the cursor to the top left screen position. The screen is not cleared.\par 27\tab Mousetext on. After using this code, printing a character in the range \lquote @\rquote  ..\rquote _\rquote , which includes the uppercase alphabetic characters, displays the character as one of the mousetext characters. See Appendix C for a description of the mousetext character set.\par \tab \tab Sending this character code to the console does the same thing as BASIC\rquote s MOUSETEXT command.\par 28\tab Moves the cursor one column to the right. Does nothing if the cursor starts in the rightmost column.\par 29\tab Clear to the end of the line. The character beneath the cursor and all characters to the right of the cursor are replaced with spaces.\par 30\tab Position the cursor. The two following characters are used as the horizontal and vertical cursor position. After subtracting 31 from each character value, the cursor is moved to that location. For example,\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 \tab \tab PRINT CHR$(30); CHR$(31 + 4); CHR$(31 + 5);\par }\pard\plain \s25\fi-720\li1080\ri360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par \tab moves the cursor to the fourth column, fifth line on the screen.\par 31\tab Move the cursor up one line. Does nothing if the cursor starts in the topmost line.\par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 \sect }\sectd \lndscpsxn\sbkodd\linex0\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Appendix C: Character Sets\par }}\pard\plain \s26\sb40\sa600\keepn\widctlpar\adjustright \b\f4\fs36\cgrid {Appendix C \endash  Character Sets}{\pard\plain \s26\sb40\sa600\keepn\widctlpar\adjustright \b\v\f4\fs36\cgrid {\tc {\v Appendix C \endash  Character Sets\tcl1}}}{\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 The ASCII Character Set}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 The ASCII Character Set\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The ASCII character set}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ASCII character set\bxe }}}{\fs20  establishes numeric equivalents for 95 printing characters. The tie between the ASCII character set and computers is so pervasive that virtually all keyboards built for use in the United States allow input of all of the ASCII characters\emdash and only the ASCII characters. (Some software, like the Apple\~II}{\fs18 GS}{\fs20  toolbox, adds extra characters by interpreting option keys, but these aren\rquote t actually on the keyboard}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 keyboard}}}{\fs20 .)\par The ASCII character set also defines 33 nonprinting characters, numbered 0 to 31 and 127. All of these have a suggested meaning, and many are now nearly universal. You\rquote ll see many of these values used in the console control codes from Appendix B. This wasn\rquote t always true. To get an idea of how long the ASCII character set has been around, consider that character 127, rub, is used as a delete character. The reason it\rquote s character 127 is that this character is made up of seven 1 bits. When a mistake was made punching code into a paper tape\emdash yes, a long yellow strip of paper used to store programs and data\emdash deleting a character meant backing up and punching all seven holes out, or \ldblquote rubbing out\rdblquote  the letter. And for the first 10 years or so of the microcomputer revolution, it was rare to find a keyboard with the entire ASCII character set available.\par The complete ASCII character set is shown below. To find the number for a particular character, add the values to the top and left of the given character. For example, the ordinal value for the character A is 64 + 1, or 65.\par \par }\trowd \trqc\trgaph80\trleft-80\trkeep \clvertalt\cltxlrtb \cellx381\clvertalt\clbrdrb\brdrs\brdrw15 \cltxlrtb \cellx842\clvertalt\clbrdrb\brdrs\brdrw15 \cltxlrtb \cellx1303\clvertalt\clbrdrb\brdrs\brdrw15 \cltxlrtb \cellx1764\clvertalt\clbrdrb\brdrs\brdrw15 \cltxlrtb \cellx2225\clvertalt\clbrdrb\brdrs\brdrw15 \cltxlrtb \cellx2686\clvertalt\clbrdrb\brdrs\brdrw15 \cltxlrtb \cellx3147\clvertalt\clbrdrb\brdrs\brdrw15 \cltxlrtb \cellx3608\clvertalt\clbrdrb\brdrs\brdrw15 \cltxlrtb \cellx4069\pard \s25\qc\sb40\keep\keepn\widctlpar\intbl\adjustright {\f7\fs14 \cell 0\cell 16\cell 32\cell 48\cell 64\cell 80\cell 96\cell 112\cell }\pard\plain \widctlpar\intbl\adjustright \f4\cgrid {\f7\fs14 \row }\trowd \trqc\trgaph80\trleft-80\trkeep \clvertalt\cltxlrtb \cellx381\clvertalt\clbrdrt\brdrs\brdrw15 \cltxlrtb \cellx842\clvertalt\clbrdrt\brdrs\brdrw15 \cltxlrtb \cellx1303\clvertalt\clbrdrt\brdrs\brdrw15 \cltxlrtb \cellx1764\clvertalt\clbrdrt\brdrs\brdrw15 \cltxlrtb \cellx2225\clvertalt\clbrdrt\brdrs\brdrw15 \cltxlrtb \cellx2686\clvertalt\clbrdrt\brdrs\brdrw15 \cltxlrtb \cellx3147\clvertalt\clbrdrt\brdrs\brdrw15 \cltxlrtb \cellx3608\clvertalt\clbrdrt\brdrs\brdrw15 \cltxlrtb \cellx4069\pard\plain \s25\qc\sb40\keep\keepn\widctlpar\intbl\brdrr\brdrs\brdrw15 \adjustright \f4\cgrid {\f7\fs14 0\cell }\pard \s25\qc\sb40\keep\keepn\widctlpar\intbl\adjustright {\f7\fs14 nul\cell dle\cell \cell 0\cell @\cell P\cell `\cell p\cell }\pard\plain \widctlpar\intbl\adjustright \f4\cgrid {\f7\fs14 \row }\trowd \trqc\trgaph80\trleft-80\trkeep \clvertalt\cltxlrtb \cellx381\clvertalt\cltxlrtb \cellx842\clvertalt\cltxlrtb \cellx1303\clvertalt\cltxlrtb \cellx1764\clvertalt\cltxlrtb \cellx2225\clvertalt\cltxlrtb \cellx2686\clvertalt\cltxlrtb \cellx3147\clvertalt\cltxlrtb \cellx3608\clvertalt\cltxlrtb \cellx4069\pard\plain \s25\qc\sb40\keep\keepn\widctlpar\intbl\brdrr\brdrs\brdrw15 \adjustright \f4\cgrid {\f7\fs14 1\cell }\pard \s25\qc\sb40\keep\keepn\widctlpar\intbl\adjustright {\f7\fs14 soh\cell dc1\cell !\cell 1\cell A\cell Q\cell a\cell q\cell }\pard\plain \widctlpar\intbl\adjustright \f4\cgrid {\f7\fs14 \row }\pard\plain \s25\qc\sb40\keep\keepn\widctlpar\intbl\brdrr\brdrs\brdrw15 \adjustright \f4\cgrid {\f7\fs14 2\cell }\pard \s25\qc\sb40\keep\keepn\widctlpar\intbl\adjustright {\f7\fs14 stx\cell dc2\cell "\cell 2\cell B\cell R\cell b\cell r\cell }\pard\plain \widctlpar\intbl\adjustright \f4\cgrid {\f7\fs14 \row }\pard\plain \s25\qc\sb40\keep\keepn\widctlpar\intbl\brdrr\brdrs\brdrw15 \adjustright \f4\cgrid {\f7\fs14 3\cell }\pard \s25\qc\sb40\keep\keepn\widctlpar\intbl\adjustright {\f7\fs14 etx\cell dc3\cell #\cell 3\cell C\cell S\cell c\cell s\cell }\pard\plain \widctlpar\intbl\adjustright \f4\cgrid {\f7\fs14 \row }\pard\plain \s25\qc\sb40\keep\keepn\widctlpar\intbl\brdrr\brdrs\brdrw15 \adjustright \f4\cgrid {\f7\fs14 4\cell }\pard \s25\qc\sb40\keep\keepn\widctlpar\intbl\adjustright {\f7\fs14 eot\cell dc4\cell $\cell 4\cell D\cell T\cell d\cell t\cell }\pard\plain \widctlpar\intbl\adjustright \f4\cgrid {\f7\fs14 \row }\pard\plain \s25\qc\sb40\keep\keepn\widctlpar\intbl\brdrr\brdrs\brdrw15 \adjustright \f4\cgrid {\f7\fs14 5\cell }\pard \s25\qc\sb40\keep\keepn\widctlpar\intbl\adjustright {\f7\fs14 enq\cell nak\cell %\cell 5\cell E\cell U\cell e\cell u\cell }\pard\plain \widctlpar\intbl\adjustright \f4\cgrid {\f7\fs14 \row }\pard\plain \s25\qc\sb40\keep\keepn\widctlpar\intbl\brdrr\brdrs\brdrw15 \adjustright \f4\cgrid {\f7\fs14 6\cell }\pard \s25\qc\sb40\keep\keepn\widctlpar\intbl\adjustright {\f7\fs14 ack\cell syn\cell &\cell 6\cell F\cell V\cell f\cell v\cell }\pard\plain \widctlpar\intbl\adjustright \f4\cgrid {\f7\fs14 \row }\pard\plain \s25\qc\sb40\keep\keepn\widctlpar\intbl\brdrr\brdrs\brdrw15 \adjustright \f4\cgrid {\f7\fs14 7\cell }\pard \s25\qc\sb40\keep\keepn\widctlpar\intbl\adjustright {\f7\fs14 bel\cell etb\cell '\cell 7\cell G\cell W\cell g\cell w\cell }\pard\plain \widctlpar\intbl\adjustright \f4\cgrid {\f7\fs14 \row }\pard\plain \s25\qc\sb40\keep\keepn\widctlpar\intbl\brdrr\brdrs\brdrw15 \adjustright \f4\cgrid {\f7\fs14 8\cell }\pard \s25\qc\sb40\keep\keepn\widctlpar\intbl\adjustright {\f7\fs14 bs\cell can\cell (\cell 8\cell H\cell X\cell h\cell x\cell }\pard\plain \widctlpar\intbl\adjustright \f4\cgrid {\f7\fs14 \row }\pard\plain \s25\qc\sb40\keep\keepn\widctlpar\intbl\brdrr\brdrs\brdrw15 \adjustright \f4\cgrid {\f7\fs14 9\cell }\pard \s25\qc\sb40\keep\keepn\widctlpar\intbl\adjustright {\f7\fs14 ht\cell em\cell )\cell 9\cell I\cell Y\cell i\cell y\cell }\pard\plain \widctlpar\intbl\adjustright \f4\cgrid {\f7\fs14 \row }\pard\plain \s25\qc\sb40\keep\keepn\widctlpar\intbl\brdrr\brdrs\brdrw15 \adjustright \f4\cgrid {\f7\fs14 10\cell }\pard \s25\qc\sb40\keep\keepn\widctlpar\intbl\adjustright {\f7\fs14 lf\cell sub\cell *\cell :\cell J\cell Z\cell j\cell z\cell }\pard\plain \widctlpar\intbl\adjustright \f4\cgrid {\f7\fs14 \row }\pard\plain \s25\qc\sb40\keep\keepn\widctlpar\intbl\brdrr\brdrs\brdrw15 \adjustright \f4\cgrid {\f7\fs14 11\cell }\pard \s25\qc\sb40\keep\keepn\widctlpar\intbl\adjustright {\f7\fs14 vt\cell esc\cell +\cell ;\cell K\cell [\cell k\cell \{\cell }\pard\plain \widctlpar\intbl\adjustright \f4\cgrid {\f7\fs14 \row }\pard\plain \s25\qc\sb40\keep\keepn\widctlpar\intbl\brdrr\brdrs\brdrw15 \adjustright \f4\cgrid {\f7\fs14 12\cell }\pard \s25\qc\sb40\keep\keepn\widctlpar\intbl\adjustright {\f7\fs14 ff\cell fs\cell ,\cell <\cell L\cell \\\cell l\cell |\cell }\pard\plain \widctlpar\intbl\adjustright \f4\cgrid {\f7\fs14 \row }\pard\plain \s25\qc\sb40\keep\keepn\widctlpar\intbl\brdrr\brdrs\brdrw15 \adjustright \f4\cgrid {\f7\fs14 13\cell }\pard \s25\qc\sb40\keep\keepn\widctlpar\intbl\adjustright {\f7\fs14 cr\cell gs\cell -\cell =\cell M\cell ]\cell m\cell \}\cell }\pard\plain \widctlpar\intbl\adjustright \f4\cgrid {\f7\fs14 \row }\pard\plain \s25\qc\sb40\keep\keepn\widctlpar\intbl\brdrr\brdrs\brdrw15 \adjustright \f4\cgrid {\f7\fs14 14\cell }\pard \s25\qc\sb40\keep\keepn\widctlpar\intbl\adjustright {\f7\fs14 co\cell rs\cell .\cell >\cell N\cell ^\cell n\cell ~\cell }\pard\plain \widctlpar\intbl\adjustright \f4\cgrid {\f7\fs14 \row }\trowd \trqc\trgaph80\trleft-80\trkeep \clvertalt\cltxlrtb \cellx381\clvertalt\cltxlrtb \cellx842\clvertalt\cltxlrtb \cellx1303\clvertalt\cltxlrtb \cellx1764\clvertalt\cltxlrtb \cellx2225\clvertalt\cltxlrtb \cellx2686\clvertalt\cltxlrtb \cellx3147\clvertalt\cltxlrtb \cellx3608\clvertalt\cltxlrtb \cellx4069\pard\plain \s25\qc\sb40\keep\widctlpar\intbl\brdrr\brdrs\brdrw15 \adjustright \f4\cgrid {\f7\fs14 15\cell }\pard \s25\qc\sb40\keep\widctlpar\intbl\adjustright {\f7\fs14 si\cell us\cell /\cell ?\cell O\cell _\cell o\cell rub\cell }\pard\plain \widctlpar\intbl\adjustright \f4\cgrid {\f7\fs14 \row }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Text Screen Codes}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Text Screen Codes\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The text screen}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 text screen}}}{\fs20  can display 256 different character values. Thirty-two of these are duplicates, so the total number of distinct characters it can display is 224.\par Oddly enough, the Apple\~II has always displayed standard ASCII characters by adding 128 to the ASCII character value. When you use any Apple\~II print command, this mapping is done automatically, but if you decide to }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 POKE statement}}}{\fs20 poke characters directly to the screen buffer you will need to account for this oddity.\par The screen image below shows an actual screen dump of all of the characters the Apple\~II}{\fs18 GS}{\fs20  can display using the standard US ROMs. To find the character number, add the row (counting from 0) to 16 times the column (again counting from 0). For example, a standard white on black lowercase a is 1 + 14 * 16, or 225.\par }\pard \s25\qc\fi360\sb40\keepn\widctlpar\adjustright {\fs20 {\pict{\*\picprop\shplid1039{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex67\picscaley66\piccropl0\piccropr0\piccropt0\piccropb0\picw227\pich266\picwgoal4540\pichgoal5320\macpict\bliptag2061862417\blipupi72{\*\blipuid 7ae586119477b1a97fa14465add16d82}1f1a00000000010a00e31101a00082a03039a0008e01000a0000000002e8025398001e00000000010a00e800000000010a00e300000000010a00e3000107007fe6ff01e00005e5ff01e00005e5ff01e00005e5ff01e00005e5ff01e0001f10f9cfef3f80fe73ffbffb3f90fe03fe3ff0feff098ffe3ff0ffefffffe0001f10f9cfef3f80fe73ffbffb3f90fe03fe3ff0feff098ffe3ff0ffefffffe0001f1dfa2fe8bf80fe8bff7ff9ff88fe03fddff77fffff77fddff77ff7ffffe0001f1dfa2fe8bf80fe8bff7ff9ff88fe03fddff77fffff77fddff77ff7ffffe0001f1dfaafe8bf80fe9bfc9ff8ff84fef3fd5ff77fffff67fd5ff77ffbff0fe0001f1dfaafe8bf80fe9bfc9ff8ff84fef3fd5ff77fffff67fd5ff77ffbff0fe0001f10faefef3f80feabf80fe07f80fe8bfd1ff0feff0357fd1ff0feff0277e0001f10faefef3f80feabf80fe07f80fe8bfd1ff0feff0357fd1ff0feff0277e0001f10facfe83f80fecbf81ff8ff80fe8bfd3ff7feff0337fd3ff7feff0277e0001f10facfe83f80fecbf81ff8ff80fe8bfd3ff7feff0337fd3ff7feff0277e0001f10fa0fe83f80fe8bf81ff9ff80fef3fdfff7feff0377fdfff7feff020fe0001f10fa0fe83f80fe8bf81ff9ff80fef3fdfff7feff0377fdfff7feff020fe0001f10f9efe83f80fe73fc0ffbff80fe83fe1ff7feff038ffe1ff7feff027fe0001f10f9efe83f80fe73fc0ffbff80fe83fe1ff7feff038ffe1ff7feff027fe000150df80fe03f80fe03fc9fe43f80fe83f4ff027fe000150df80fe03f80fe03fc9fe43f80fe83f4ff027fe0001e17f88fe73f88fe23ffbfffbf80fe03ff7ff8fff7ffdfff7ff8fdff01e0001e17f88fe73f88fe23ffbfffbf80fe03ff7ff8fff7ffdfff7ff8fdff01e0001f18f94fe8bf88fe63ff7ffdbf80fe03febff77ff7ff9ffebff77ffeff01e0001f18f94fe8bf88fe63ff7ffdbf80fe03febff77ff7ff9ffebff77ffeff01e0001f1dfa2fe8bf88fe23fc9ffdff9cfe7bfddff77ff7ffdffddff77fe3ff87e0001f1dfa2fe8bf88fe23fc9ffdff9cfe7bfddff77ff7ffdffddff77fe3ff87e0001f1dfa2fe8bf88fe23fbefe03f82fe8bfddff77ff7ffdffddff77ffdff77e0001f1dfa2fe8bf88fe23fbefe03f82fe8bfddff77ff7ffdffddff77ffdff77e0001f1dfbefeabf88fe23fbdff07f9efe8bfc1ff57ff7ffdffc1ff57fe1ff77e0001f1dfbefeabf88fe23fbdff07f9efe8bfc1ff57ff7ffdffc1ff57fe1ff77e0001f10fa2fe93f80fe23fbdff8ffa2fe7bfddff6feff09dffddff6ffddff87e0001f10fa2fe93f80fe23fbdff8ffa2fe7bfddff6feff09dffddff6ffddff87e0001f1dfa2fe6bf88fe73fd6ffdbf9efe0bfddff97ff7ff8ffddff97fe1fff7e0001f1dfa2fe6bf88fe73fd6ffdbf9efe0bfddff97ff7ff8ffddff97fe1fff7e000150df80fe03f80fe03fc9fffbf80fe0bf4ff02f7e000150df80fe03f80fe03fc9fffbf80fe0bf4ff02f7e0001f06fbcfef3f94fe73feff13bfa0fe03fc3ff0ffebff8ffc3ff0ffdfffffe0001f06fbcfef3f94fe73feff13bfa0fe03fc3ff0ffebff8ffc3ff0ffdfffffe0001f1dfa2fe8bf94fe8bfffffdbfa0fe03fddff77febff77fddff77fdfffffe0001f1dfa2fe8bf94fe8bfffffdbfa0fe03fddff77febff77fddff77fdfffffe0001f1dfa2fe8bf94fe0bfdfff8ffbcfebbfddff77febfff7fddff77fc3ff47e0001f1dfa2fe8bf94fe0bfdfff8ffbcfebbfddff77febfff7fddff77fc3ff47e0001f10fbcfef3f80fe33fcfff07fa2fec3fc3ff0feff09cffc3ff0ffddff3fe0001f10fbcfef3f80fe33fcfff07fa2fec3fc3ff0feff09cffc3ff0ffddff3fe0001f10fa2fea3f80fe43fc7fe03fa2fe83fddff5feff09bffddff5ffddff7fe0001f10fa2fea3f80fe43fc7fe03fa2fe83fddff5feff09bffddff5ffddff7fe0001f10fa2fe93f80fe83fc3ffdffa2fe83fddff6feff097ffddff6ffddff7fe0001f10fa2fe93f80fe83fc3ffdffa2fe83fddff6feff097ffddff6ffddff7fe0001f1dfbcfe8bf80fefbfc9ffdbfbcfe83fc3ff77fffff07fc3ff77fc3ff7fe0001f1dfbcfe8bf80fefbfc9ffdbfbcfe83fc3ff77fffff07fc3ff77fc3ff7fe000140df80fe03f80fe03fdefffbf80fe03f3ff01e000140df80fe03f80fe03fdefffbf80fe03f3ff01e0001e17f9cfe73f94fefbf80fffff80fe03fe3ff8ffebff07fe3ff8fdff01e0001e17f9cfe73f94fefbf80fffff80fe03fe3ff8ffebff07fe3ff8fdff01e0001f18fa2fe8bf94fe0bfddfffff80fe03fddff77febfff7fddff77ffeff01e0001f18fa2fe8bf94fe0bfddfffff80fe03fddff77febfff7fddff77ffeff01e0001f1dfa0fe83fbefe13febfffff9efe7bfdfff7ffc1ffeffdfff7ffe1ff87e0001f1dfa0fe83fbefe13febfffff9efe7bfdfff7ffc1ffeffdfff7ffe1ff87e0001f1dfa0fe73f94fe33ff7fe03fa0fe83fdfff8ffebffcffdfff8ffdfff7fe0001f1dfa0fe73f94fe33ff7fe03fa0fe83fdfff8ffebffcffdfff8ffdfff7fe0001f1dfa0fe0bfbefe0bff7fffffa0fe73fdffff7fc1fff7fdffff7fdfff8fe0001f1dfa0fe0bfbefe0bff7fffffa0fe73fdffff7fc1fff7fdffff7fdfff8fe0001f1dfa2fe8bf94fe8bfebfffffa0fe0bfddff77febff77fddff77fdffff7e0001f1dfa2fe8bf94fe8bfebfffffa0fe0bfddff77febff77fddff77fdffff7e0001f1df9cfe73f94fe73fd5fffff9efef3fe3ff8ffebff8ffe3ff8ffe1ff0fe0001f1df9cfe73f94fe73fd5fffff9efef3fe3ff8ffebff8ffe3ff8ffe1ff0fe000140df80fe03f80fe03f80fffff80fe03f3ff01e000140df80fe03f80fe03f80fffff80fe03f3ff01e0001f1dfbcfefbf88fe13ffffefff82fe43fc3ff07ff7ffeffc3ff07ffdffbfe0001f1dfbcfefbf88fe13ffffefff82fe43fc3ff07ff7ffeffc3ff07ffdffbfe0001f1dfa2fe23f9efe33ffefefff82fe43fddffdffe1ffcffddffdfffdffbfe0001f1dfa2fe23f9efe33ffefefff82fe43fddffdffe1ffcffddffdfffdffbfe0001f1dfa2fe23fa8fe53ffdfefff9efef3fddffdffd7ffaffddffdffe1ff0fe0001f1dfa2fe23fa8fe53ffdfefff9efef3fddffdffd7ffaffddffdffe1ff0fe0001f1dfa2fe23f9cfe93fbbfefffa2fe43fddffdffe3ff6ffddffdffddffbfe0001f1dfa2fe23f9cfe93fbbfefffa2fe43fddffdffe3ff6ffddffdffddffbfe0001f1dfa2fe23f8afefbfd7fefffa2fe43fddffdfff5ff07fddffdffddffbfe0001f1dfa2fe23f8afefbfd7fefffa2fe43fddffdfff5ff07fddffdffddffbfe0001f1dfa2fe23fbcfe13feffefffa2fe4bfddffdffc3ffeffddffdffddffb7e0001f1dfa2fe23fbcfe13feffefffa2fe4bfddffdffc3ffeffddffdffddffb7e0001f1dfbcfe23f88fe13feffefff9efe33fc3ffdfff7ffeffc3ffdffe1ffcfe0001f1dfbcfe23f88fe13feffefff9efe33fc3ffdfff7ffeffc3ffdffe1ffcfe000140df80fe03f80fe03ffffe03f80fe03f3ff01e000140df80fe03f80fe03ffffe03f80fe03f3ff01e0001f18fbefe8bfb0fefbf80ffdff80fe03fc1ff77fcfff07fc1ff77ffeff01e0001f18fbefe8bfb0fefbf80ffdff80fe03fc1ff77fcfff07fc1ff77ffeff01e0001f18fa0fe8bfb2fe83f81ffeff80fe03fdfff77fcdff7ffdfff77ffeff01e0001f18fa0fe8bfb2fe83f81ffeff80fe03fdfff77fcdff7ffdfff77ffeff01e0001f1dfa0fe8bf84fef3f82fff7f9cfe8bfdfff77ffbff0ffdfff77fe3ff77e0001f1dfa0fe8bf84fef3f82fff7f9cfe8bfdfff77ffbff0ffdfff77fe3ff77e0001f1dfbcfe8bf88fe0bfc4fe03fa2fe8bfc3ff77ff7fff7fc3ff77fddff77e0001f1dfbcfe8bf88fe0bfc4fe03fa2fe8bfc3ff77ff7fff7fc3ff77fddff77e0001f1dfa0fe8bf90fe0bfa8fff7fbefe8bfdfff77feffff7fdfff77fc1ff77e0001f1dfa0fe8bf90fe0bfa8fff7fbefe8bfdfff77feffff7fdfff77fc1ff77e0001f1dfa0fe8bfa6fe8bf90ffeffa0fe9bfdfff77fd9ff77fdfff77fdfff67e0001f1dfa0fe8bfa6fe8bf90ffeffa0fe9bfdfff77fd9ff77fdfff77fdfff67e0001f1dfbefe73f86fe73f90ffdff9efe6bfc1ff8fff9ff8ffc1ff8ffe1ff97e0001f1dfbefe73f86fe73f90ffdff9efe6bfc1ff8fff9ff8ffc1ff8ffe1ff97e000140df80fe03f80fe03f80fffff80fe03f3ff01e000140df80fe03f80fe03f80fffff80fe03f3ff01e0001f1dfbefe8bf90fe3bf81ff57f8cfe03fc1ff77fefffc7fc1ff77ff3ffffe0001f1dfbefe8bf90fe3bf81ff57f8cfe03fc1ff77fefffc7fc1ff77ff3ffffe0001f1dfa0fe8bfa8fe43f81feabf92fe03fdfff77fd7ffbffdfff77fedffffe0001f1dfa0fe8bfa8fe43f81feabf92fe03fdfff77fd7ffbffdfff77fedffffe0001f1dfa0fe8bfa8fe83f81ff57f90fe8bfdfff77fd7ff7ffdfff77fefff77e0001f1dfa0fe8bfa8fe83f81ff57f90fe8bfdfff77fd7ff7ffdfff77fefff77e0001f1dfbcfe8bf90fef3f91feabfbcfe8bfc3ff77fefff0ffc3ff77fc3ff77e0001f1dfbcfe8bf90fef3f91feabfbcfe8bfc3ff77fefff0ffc3ff77fc3ff77e0001f1dfa0fe8bfaafe8bfb1ff57f90fe8bfdfff77fd5ff77fdfff77fefff77e0001f1dfa0fe8bfaafe8bfb1ff57f90fe8bfdfff77fd5ff77fdfff77fefff77e0001f1dfa0fe53fa4fe8bffffeabf90fe53fdfffaffdbff77fdfffaffefffafe0001f1dfa0fe53fa4fe8bffffeabf90fe53fdfffaffdbff77fdfffaffefffafe0001f1dfa0fe23f9afe73fb0ff57f90fe23fdfffdffe5ff8ffdfffdffefffdfe0001f1dfa0fe23f9afe73fb0ff57f90fe23fdfffdffe5ff8ffdfffdffefffdfe000140df80fe03f80fe03f90feabf80fe03f3ff01e000140df80fe03f80fe03f90feabf80fe03f3ff01e0001f18f9efe8bf88fefbf80feabf80fe03fe1ff77ff7ff07fe1ff77ffeff01e0001f18f9efe8bf88fefbf80feabf80fe03fe1ff77ff7ff07fe1ff77ffeff01e0001f18fa0fe8bf88fe0bfffff57f80fe03fdfff77ff7fff7fdfff77ffeff01e0001f18fa0fe8bf88fe0bfffff57f80fe03fdfff77ff7fff7fdfff77ffeff01e0001f1dfa0fe8bf88fe13f80feabf9cfe8bfdfff77ff7ffeffdfff77fe3ff77e0001f1dfa0fe8bf88fe13f80feabf9cfe8bfdfff77ff7ffeffdfff77fe3ff77e0001f1dfa0feabf80fe23fffff57fa2fe8bfdfff57fffffdffdfff57fddff77e0001f1dfa0feabf80fe23fffff57fa2fe8bfdfff57fffffdffdfff57fddff77e0001f1dfa6feabf80fe43f80feabfa2feabfd9ff57fffffbffd9ff57fddff57e0001f1dfa6feabf80fe43f80feabfa2feabfd9ff57fffffbffd9ff57fddff57e0001f1dfa2fedbf80fe43fffff57f9efeabfddff27fffffbffddff27fe1ff57e0001f1dfa2fedbf80fe43fffff57f9efeabfddff27fffffbffddff27fe1ff57e0001f1df9efe8bf80fe43ffffeabf82fedbfe1ff77fffffbffe1ff77ffdff27e0001f1df9efe8bf80fe43ffffeabf82fedbfe1ff77fffffbffe1ff77ffdff27e000170df80fe03f80fe03f80ff57f9cfe03f6ff04e3ffffe000170df80fe03f80fe03f80ff57f9cfe03f6ff04e3ffffe0001f1dfa2fe8bf88fe73ff7fffffa0fe03fddff77ff7ff8ffddff77fdfffffe0001f1dfa2fe8bf88fe73ff7fffffa0fe03fddff77ff7ff8ffddff77fdfffffe0001f1dfa2fe8bf90fe8bfefff07fa0fe03fddff77fefff77fddff77fdfffffe0001f1dfa2fe8bf90fe8bfefff07fa0fe03fddff77fefff77fddff77fdfffffe0001f1dfa2fe53fa0fe8bfdffefbfbcfe8bfddffaffdfff77fddffaffc3ff77e0001f1dfa2fe53fa0fe8bfdffefbfbcfe8bfddffaffdfff77fddffaffc3ff77e0001f1dfbefe23fa0fe73f80fefffa2fe53fc1ffdffdfff8ffc1ffdffddffafe0001f1dfbefe23fa0fe73f80fefffa2fe53fc1ffdffdfff8ffc1ffdffddffafe0001f1dfa2fe53fa0fe8bfdffefffa2fe23fddffaffdfff77fddffaffddffdfe0001f1dfa2fe53fa0fe8bfdffefffa2fe23fddffaffdfff77fddffaffddffdfe0001f1dfa2fe8bf90fe8bfeffefffa2fe53fddff77fefff77fddff77fddffafe0001f1dfa2fe8bf90fe8bfeffefffa2fe53fddff77fefff77fddff77fddffafe0001f1dfa2fe8bf88fe73ff7fe03fa2fe8bfddff77ff7ff8ffddff77fddff77e0001f1dfa2fe8bf88fe73ff7fe03fa2fe8bfddff77ff7ff8ffddff77fddff77e0001306f80fe03f80fe03fdff0280fe03f3ff01e0001306f80fe03f80fe03fdff0280fe03f3ff01e0001e06f9cfe8bf88fe73fdff1288fe03fe3ff77ff7ff8ffe3ff77ff7ffffe0001e06f9cfe8bf88fe73fdff1288fe03fe3ff77ff7ff8ffe3ff77ff7ffffe0001e06f88fe8bf84fe8bfdff0d80fe03ff7ff77ffbff77ff7ff77ffeff01e0001e06f88fe8bf84fe8bfdff0d80fe03ff7ff77ffbff77ff7ff77ffeff01e0001f1df88fe53f82fe8bffffe07f98fe8bff7ffafffdff77ff7ffaffe7ff77e0001f1df88fe53f82fe8bffffe07f98fe8bff7ffafffdff77ff7ffaffe7ff77e0001f06f88fe23f82fe7bfeff13bf88fe8bff7ffdfffdff87ff7ffdfff7ff77e0001f06f88fe23f82fe7bfeff13bf88fe8bff7ffdfffdff87ff7ffdfff7ff77e0001f06f88fe23f82fe0bfeff13bf88fe8bff7ffdfffdfff7ff7ffdfff7ff77e0001f06f88fe23f82fe0bfeff13bf88fe8bff7ffdfffdfff7ff7ffdfff7ff77e0001f06f88fe23f84fe13feff13bf88fe7bff7ffdfffbffefff7ffdfff7ff87e0001f06f88fe23f84fe13feff13bf88fe7bff7ffdfffbffefff7ffdfff7ff87e0001f1df9cfe23f88fee3ffffe03f9cfe0bfe3ffdfff7ff1ffe3ffdffe3fff7e0001f1df9cfe23f88fee3ffffe03f9cfe0bfe3ffdfff7ff1ffe3ffdffe3fff7e000150df80fe03f80fe03fd5fffff80fe73f4ff028fe000150df80fe03f80fe03fd5fffff80fe73f4ff028fe0001f12f82fefbf88fe03ff7fffbf84fe03ffdff07ff7feff07dff07ffbffffe0001f12f82fefbf88fe03ff7fffbf84fe03ffdff07ff7feff07dff07ffbffffe0001f12f82fe0bfaafe03ff7fffbf80fe03ffdfff7fd5feff02dfff7ffeff01e0001f12f82fe0bfaafe03ff7fffbf80fe03ffdfff7fd5feff02dfff7ffeff01e0001f1df82fe13f9cfe23ff7fffbf8cfefbffdffeffe3ffdfffdffefff3ff07e0001f1df82fe13f9cfe23ff7fffbf8cfefbffdffeffe3ffdfffdffefff3ff07e0001f12f82fe23f88fe03ff7fffbf84fe13ffdffdfff7feff07dffdfffbffefe0001f12f82fe23f88fe03ff7fffbf84fe13ffdffdfff7feff07dffdfffbffefe0001f1df82fe43f9cfe23fb6fffbf84fe23ffdffbffe3ffdfffdffbfffbffdfe0001f1df82fe43f9cfe23fb6fffbf84fe23ffdffbffe3ffdfffdffbfffbffdfe0001f1dfa2fe83faafe03fd5fffbf84fe43fddff7ffd5fffffddff7fffbffbfe0001f1dfa2fe83faafe03fd5fffbf84fe43fddff7ffd5fffffddff7fffbffbfe0001f1df9cfefbf88fe03fe3fffbfa4fefbfe3ff07ff7fffffe3ff07fdbff07e0001f1df9cfefbf88fe03fe3fffbfa4fefbfe3ff07ff7fffffe3ff07fdbff07e000170df80fe03f80fe03ff7fffbf98fe03f6ff04e7ffffe000170df80fe03f80fe03ff7fffbf98fe03f6ff04e7ffffe0001f11fa2fefbf80fe03ff7ffdffa0fe3bfddff07ffeff08fddff07fdfffc7e0001f11fa2fefbf80fe03ff7ffdffa0fe3bfddff07ffeff08fddff07fdfffc7e0001f1dfa4fec3f88fe03fe3ff8ffa0fe63fdbff3fff7fffffdbff3ffdfff9fe0001f1dfa4fec3f88fe03fe3ff8ffa0fe63fdbff3fff7fffffdbff3ffdfff9fe0001f1dfa8fec3f88fe23fd5ff07fa2fe63fd7ff3fff7ffdffd7ff3ffddff9fe0001f1dfa8fec3f88fe23fd5ff07fa2fe63fd7ff3fff7ffdffd7ff3ffddff9fe0001f1dfb0fec3fbefe03fb6fe03fa4fec3fcfff3ffc1fffffcfff3ffdbff3fe0001f1dfb0fec3fbefe03fb6fe03fa4fec3fcfff3ffc1fffffcfff3ffdbff3fe0001f1dfa8fec3f88fe23ff7ff07fb8fe63fd7ff3fff7ffdffd7ff3ffc7ff9fe0001f1dfa8fec3f88fe23ff7ff07fb8fe63fd7ff3fff7ffdffd7ff3ffc7ff9fe0001f1dfa4fec3f88fe23ff7ff8ffa4fe63fdbff3fff7ffdffdbff3ffdbff9fe0001f1dfa4fec3f88fe23ff7ff8ffa4fe63fdbff3fff7ffdffdbff3ffdbff9fe0001f1dfa2fefbf80fe43ff7ffdffa2fe3bfddff07fffffbffddff07fddffc7e0001f1dfa2fefbf80fe43ff7ffdffa2fe3bfddff07fffffbffddff07fddffc7e000140df80fe03f80fe03ff7fffff80fe03f3ff01e000140df80fe03f80fe03ff7fffff80fe03f3ff01e0001d0efa0fe03f80fe13f80fe03f98fe23fdfcff01effdfeff04e7ffdfe0001d0efa0fe03f80fe13f80fe03f98fe23fdfcff01effdfeff04e7ffdfe0001e06fa0fe83f80fe23fdff0588fe23fdfff7feff09dffdfff7fff7ffdfe0001e06fa0fe83f80fe23fdff0588fe23fdfff7feff09dffdfff7fff7ffdfe0001e06fa0fe43f80fe43fdff0588fe23fdfffbfeff09bffdfffbfff7ffdfe0001e06fa0fe43f80fe43fdff0588fe23fdfffbfeff09bffdfffbfff7ffdfe0001e06fa0fe23f80fe83fdff0588fe23fdfffdfeff097ffdfffdfff7ffdfe0001e06fa0fe23f80fe83fdff0588fe23fdfffdfeff097ffdfffdfff7ffdfe0001e06fa0fe13f88fe43fdff1288fe23fdfffefff7ffbffdfffefff7ffdfe0001e06fa0fe13f88fe43fdff1288fe23fdfffefff7ffbffdfffefff7ffdfe0001e06fa0fe0bf88fe23fdff1288fe23fdffff7ff7ffdffdffff7ff7ffdfe0001e06fa0fe0bf88fe23fdff1288fe23fdffff7ff7ffdffdffff7ff7ffdfe0001e06fbefe03f90fe13fdff129cfe23fc1fffffefffeffc1fffffe3ffdfe0001e06fbefe03f90fe13fdff129cfe23fc1fffffefffeffc1fffffe3ffdfe000150df80fe03f80fe03ffffe03f80fe23f4ff02dfe000150df80fe03f80fe03ffffe03f80fe23f4ff02dfe0001f11fa2fefbf80fe03ffeffaff80fee3fddff07ffeff08fddff07fffff1fe0001f11fa2fefbf80fe03ffeffaff80fee3fddff07ffeff08fddff07fffff1fe0001f11fb6fe1bf80fe03ffeffaff80fe33fc9ffe7ffeff08fc9ffe7fffffcfe0001f11fb6fe1bf80fe03ffeffaff80fe33fc9ffe7ffeff08fc9ffe7fffffcfe0001f1dfaafe1bf80fefbffefe23fb6fe33fd5ffe7fffff07fd5ffe7fc9ffcfe0001f1dfaafe1bf80fefbffefe23fb6fe33fd5ffe7fffff07fd5ffe7fc9ffcfe0001f1dfaafe1bfbefe03feefffffaafe1bfd5ffe7fc1fffffd5ffe7fd5ffe7e0001f1dfaafe1bfbefe03feefffffaafe1bfd5ffe7fc1fffffd5ffe7fd5ffe7e0001f1dfa2fe1bf80fefbfcefe23faafe33fddffe7fffff07fddffe7fd5ffcfe0001f1dfa2fe1bf80fefbfcefe23faafe33fddffe7fffff07fddffe7fd5ffcfe0001f11fa2fe1bf80fe03f80ffaffaafe33fddffe7ffeff08fddffe7fd5ffcfe0001f11fa2fe1bf80fe03f80ffaffaafe33fddffe7ffeff08fddffe7fd5ffcfe0001f11fa2fefbf80fe03fcfffaffa2fee3fddff07ffeff08fddff07fddff1fe0001f11fa2fefbf80fe03fcfffaffa2fee3fddff07ffeff08fddff07fddff1fe0001407f80fe03f80fe03fefeff0280fe03f3ff01e0001407f80fe03f80fe03fefeff0280fe03f3ff01e0001d0ffa2fe03f80fe43f81fe03f80fe6bfddffdff02bffddffdff0297e0001d0ffa2fe03f80fe43f81fe03f80fe6bfddffdff02bffddffdff0297e0001d0ffa2fe03f80fe23f81fffbf80feb3fddffdff02dffddffdff024fe0001d0ffa2fe03f80fe23f81fffbf80feb3fddffdff02dffddffdff024fe0001f10fb2fe23f80fe13f81fffbfbcfe03fcdffdfeff09effcdffdffc3ffffe0001f10fb2fe23f80fe13f81fffbfbcfe03fcdffdfeff09effcdffdffc3ffffe0001f10faafe53f80fe0bf81ff9bfa2fe03fd5ffafeff09f7fd5ffaffddffffe0001f10faafe53f80fe0bf81ff9bfa2fe03fd5ffafeff09f7fd5ffaffddffffe0001f1dfa6fe8bf80fe13f81ff9bfa2fe03fd9ff77fffffeffd9ff77fddffffe0001f1dfa6fe8bf80fe13f81ff9bfa2fe03fd9ff77fffffeffd9ff77fddffffe0001e0ffa2fe03f80fe23f81fffbfa2fe03fddffdff09dffddfffffddffffe0001e0ffa2fe03f80fe23f81fffbfa2fe03fddffdff09dffddfffffddffffe0001f1dfa2fe03f88fe43f81fffbfa2fe03fddffffff7ffbffddfffffddffffe0001f1dfa2fe03f88fe43f81fffbfa2fe03fddffffff7ffbffddfffffddffffe000140df80fe03f80fe03f81fe03f80fe03f3ff01e000140df80fe03f80fe03f81fe03f80fe03f3ff01e0001c0ff9cfe03f80fe73f9bfefff80fe03fe3ffdff028ffe3ffcff01e0001c0ff9cfe03f80fe73f9bfefff80fe03fe3ffdff028ffe3ffcff01e0001e16fa2fe03f82fe8bff3fefff80feabfddffffffdff77fddffdff0257e0001e16fa2fe03f82fe8bff3fefff80feabfddffffffdff77fddffdff0257e0001f1dfa2fe03f84fe13fe3fefff9cfe53fddffffffbffeffddfffffe3ffafe0001f1dfa2fe03f84fe13fe3fefff9cfe53fddffffffbffeffddfffffe3ffafe0001f1dfa2fe03f88fe23fc0fefffa2feabfddffffff7ffdffddfffffddff57e0001f1dfa2fe03f88fe23fc0fefffa2feabfddffffff7ffdffddfffffddff57e0001f1dfa2fe03f90fe23fe3fefffa2fe53fddfffffefffdffddfffffddffafe0001f1dfa2fe03f90fe23fe3fefffa2fe53fddfffffefffdffddfffffddffafe0001f1dfa2fe03fa0fe03ff3fefffa2feabfddfffffdffffffddfffffddff57e0001f1dfa2fe03fa0fe03ff3fefffa2feabfddfffffdffffffddfffffddff57e0001e0ff9cfe03f80fe23ffbfefff9cfe03fe3ffdff09dffe3fffffe3ffffe0001e0ff9cfe03f80fe23ffbfefff9cfe03fe3ffdff09dffe3fffffe3ffffe0001d11f80fffff80fe03f84fefff80fe03ffffe03ffcff01e03ffeff01e0001d11f80fffff80fe03f84fefff80fe03ffffe03ffcff01e03ffeff01e00005e5ff01e00005e5ff01e00005e5ff01e00005e5ff01e00005e5ff01e000a0008fa00083ff}}{\fs20 \par }\pard \s25\qc\fi360\sb80\widctlpar\adjustright {\fs20 The Apple\~II}{\fs18 GS}{\fs20  Text Screen Character Set\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Toolbox Character Codes}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Toolbox Character Codes\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 fonts}}}{\v\fs20 characters:fonts;}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 toolbox\:fonts}}}{\fs20 Fonts in the Apple\~II}{\fs18 GS}{\fs20  toolbox generally use the ASCII character set. Apple has also defined several other characters, usually to support alphabets for languages other than English. The table below shows the characters defined by Apple.\par Keep in mind that these are guidelines, not requirements. A Greek font, for example, will generally dump the ASCII character to make room for the Greek characters. Some fonts implement radically different character sets, such as postal bar codes, hieroglyphics, or special symbols. Even fonts that implement the ASCII character set don\rquote t always add all of the characters shown below. Still, if the character is available, its character number almost always matches the number shown.\par \par }\trowd \trqc\trgaph80\trleft-80\trkeep \clvertalt\cltxlrtb \cellx385\clvertalt\clbrdrb\brdrs\brdrw15 \cltxlrtb \cellx850\clvertalt\clbrdrb\brdrs\brdrw15 \cltxlrtb \cellx1315\clvertalt\clbrdrb\brdrs\brdrw15 \cltxlrtb \cellx1780\clvertalt\clbrdrb\brdrs\brdrw15 \cltxlrtb \cellx2245\clvertalt\clbrdrb\brdrs\brdrw15 \cltxlrtb \cellx2710\clvertalt\clbrdrb\brdrs\brdrw15 \cltxlrtb \cellx3175\clvertalt\clbrdrb\brdrs\brdrw15 \cltxlrtb \cellx3640\clvertalt\clbrdrb\brdrs\brdrw15 \cltxlrtb \cellx4105\clvertalt\clbrdrb\brdrs\brdrw15 \cltxlrtb \cellx4570\clvertalt\clbrdrb\brdrs\brdrw15 \cltxlrtb \cellx5035\clvertalt\clbrdrb\brdrs\brdrw15 \cltxlrtb \cellx5500\clvertalt\clbrdrb\brdrs\brdrw15 \cltxlrtb \cellx5965\clvertalt\clbrdrb\brdrs\brdrw15 \cltxlrtb \cellx6430\clvertalt\clbrdrb\brdrs\brdrw15 \cltxlrtb \cellx6895\clvertalt\clbrdrb\brdrs\brdrw15 \cltxlrtb \cellx7360\clvertalt\clbrdrb\brdrs\brdrw15 \cltxlrtb \cellx7825\pard\plain \qc\keepn\widctlpar\intbl\adjustright \f4\cgrid {\fs20 \cell 00\cell 10\cell 20\cell 30\cell 40\cell 50\cell 60\cell 70\cell 80\cell 90\cell A0\cell B0\cell C0\cell D0\cell E0\cell F0\cell }\pard \widctlpar\intbl\adjustright {\fs20 \row }\trowd \trqc\trgaph80\trleft-80\trkeep \clvertalt\clbrdrr\brdrs\brdrw15 \cltxlrtb \cellx385\clvertalt\clbrdrt\brdrs\brdrw15 \cltxlrtb \cellx850\clvertalt\clbrdrt\brdrs\brdrw15 \cltxlrtb \cellx1315\clvertalt\clbrdrt\brdrs\brdrw15 \cltxlrtb \cellx1780\clvertalt\clbrdrt\brdrs\brdrw15 \cltxlrtb \cellx2245\clvertalt\clbrdrt\brdrs\brdrw15 \cltxlrtb \cellx2710\clvertalt\clbrdrt\brdrs\brdrw15 \cltxlrtb \cellx3175\clvertalt\clbrdrt\brdrs\brdrw15 \cltxlrtb \cellx3640\clvertalt\clbrdrt\brdrs\brdrw15 \cltxlrtb \cellx4105\clvertalt\clbrdrt\brdrs\brdrw15 \cltxlrtb \cellx4570\clvertalt\clbrdrt\brdrs\brdrw15 \cltxlrtb \cellx5035\clvertalt\clbrdrt\brdrs\brdrw15 \cltxlrtb \cellx5500\clvertalt\clbrdrt\brdrs\brdrw15 \cltxlrtb \cellx5965\clvertalt\clbrdrt\brdrs\brdrw15 \cltxlrtb \cellx6430\clvertalt\clbrdrt\brdrs\brdrw15 \cltxlrtb \cellx6895\clvertalt\clbrdrt\brdrs\brdrw15 \cltxlrtb \cellx7360\clvertalt\clbrdrt\brdrs\brdrw15 \cltxlrtb \cellx7825\pard \qc\keepn\widctlpar\intbl\adjustright {\fs20 0\cell }{\f12\fs20 \cell \cell }{\fs20 spc}{\f12\fs20 \cell 0\cell @\cell P\cell `\cell p\cell \u196\'80\cell \u234\'90\cell \u8224\'a0\cell \u8734\'b0\cell \u191\'c0\cell \endash \cell \cell \cell }\pard \widctlpar\intbl\adjustright {\f12\fs20 \row }\trowd \trqc\trgaph80\trleft-80\trkeep \clvertalt\clbrdrr\brdrs\brdrw15 \cltxlrtb \cellx385\clvertalt\cltxlrtb \cellx850\clvertalt\cltxlrtb \cellx1315\clvertalt\cltxlrtb \cellx1780\clvertalt\cltxlrtb \cellx2245\clvertalt\cltxlrtb \cellx2710\clvertalt\cltxlrtb \cellx3175\clvertalt\cltxlrtb \cellx3640\clvertalt\cltxlrtb \cellx4105\clvertalt\cltxlrtb \cellx4570\clvertalt\cltxlrtb \cellx5035\clvertalt\cltxlrtb \cellx5500\clvertalt\cltxlrtb \cellx5965\clvertalt\cltxlrtb \cellx6430\clvertalt\cltxlrtb \cellx6895\clvertalt\cltxlrtb \cellx7360\clvertalt\cltxlrtb \cellx7825\pard \qc\keepn\widctlpar\intbl\adjustright {\fs20 1\cell }{\f12\fs20 \cell \u17\'11\cell }{\f12\fs18 !}{\f12\fs20 \cell 1\cell A\cell Q\cell a\cell q\cell \u197\'81\cell \u235\'91\cell \u176\'a1\cell \u177\'b1\cell \u161\'c1\cell \emdash \cell \cell \cell }\pard \widctlpar\intbl\adjustright {\f12\fs20 \row }\pard \qc\keepn\widctlpar\intbl\adjustright {\fs20 2\cell }{\f12\fs20 \cell \u18\'12\cell "\cell 2\cell B\cell R\cell b\cell r\cell \u199\'82\cell \u237\'92\cell \u162\'a2\cell \u8804\'b2\cell \u172\'c2\cell \ldblquote \cell \cell \cell }\pard \widctlpar\intbl\adjustright {\f12\fs20 \row }\pard \qc\keepn\widctlpar\intbl\adjustright {\fs20 3\cell }{\f12\fs20 \cell \cell #\cell 3\cell C\cell S\cell c\cell s\cell \u201\'83\cell \u236\'93\cell \u163\'a3\cell \u8805\'b3\cell \u8730\'c3\cell \rdblquote \cell \cell \cell }\pard \widctlpar\intbl\adjustright {\f12\fs20 \row }\pard \qc\keepn\widctlpar\intbl\adjustright {\fs20 4\cell }{\f12\fs20 \cell \cell $\cell 4\cell D\cell T\cell d\cell t\cell \u209\'84\cell \u238\'94\cell \u167\'a4\cell \u165\'b4\cell \u402\'c4\cell \lquote \cell \cell \cell }\pard \widctlpar\intbl\adjustright {\f12\fs20 \row }\pard \qc\keepn\widctlpar\intbl\adjustright {\fs20 5\cell }{\f12\fs20 \cell \cell %\cell 5\cell E\cell U\cell e\cell u\cell \u214\'85\cell \u239\'95\cell \bullet \cell \u181\'b5\cell \u8776\'c5\cell \rquote \cell \cell \cell }\pard \widctlpar\intbl\adjustright {\f12\fs20 \row }\pard \qc\keepn\widctlpar\intbl\adjustright {\fs20 6\cell }{\f12\fs20 \cell \cell &\cell 6\cell F\cell V\cell f\cell v\cell \u220\'86\cell \u241\'96\cell \u182\'a6\cell \u8706\'b6\cell \u8710\'c6\cell \u247\'d6\cell \cell \cell }\pard \widctlpar\intbl\adjustright {\f12\fs20 \row }\pard \qc\keepn\widctlpar\intbl\adjustright {\fs20 7\cell }{\f12\fs20 \cell \cell '\cell 7\cell G\cell W\cell g\cell w\cell \u225\'87\cell \u243\'97\cell \u223\'a7\cell \u8721\'b7\cell \u171\'c7\cell \u9674\'d7\cell \cell \cell }\pard \widctlpar\intbl\adjustright {\f12\fs20 \row }\pard \qc\keepn\widctlpar\intbl\adjustright {\fs20 8\cell }{\f12\fs20 \cell \cell (\cell 8\cell H\cell X\cell h\cell x\cell \u224\'88\cell \u242\'98\cell \u174\'a8\cell \u8719\'b8\cell \u187\'c8\cell \u255\'d8\cell \cell \cell }\pard \widctlpar\intbl\adjustright {\f12\fs20 \row }\pard \qc\keepn\widctlpar\intbl\adjustright {\fs20 9\cell }{\f12\fs20 \cell \cell )\cell 9\cell I\cell Y\cell i\cell y\cell \u226\'89\cell \u244\'99\cell \u169\'a9\cell \u960\'b9\cell \u8230\'c9\cell \cell \cell \cell }\pard \widctlpar\intbl\adjustright {\f12\fs20 \row }\pard \qc\keepn\widctlpar\intbl\adjustright {\fs20 A\cell }{\f12\fs20 \cell \cell *\cell :\cell J\cell Z\cell j\cell z\cell \u228\'8a\cell \u246\'9a\cell \u8482\'aa\cell \u8747\'ba\cell }{\fs20 spc}{\f12\fs20 \cell \cell \cell \cell }\pard \widctlpar\intbl\adjustright {\f12\fs20 \row }\pard \qc\keepn\widctlpar\intbl\adjustright {\fs20 B\cell }{\f12\fs20 \cell \cell +\cell ;\cell K\cell [\cell k\cell \{\cell \u227\'8b\cell \u245\'9b\cell \u180\'ab\cell \u170\'bb\cell \u192\'cb\cell \cell \cell \cell }\pard \widctlpar\intbl\adjustright {\f12\fs20 \row }\pard \qc\keepn\widctlpar\intbl\adjustright {\fs20 C\cell }{\f12\fs20 \cell \cell ,\cell <\cell L\cell \\\cell l\cell |\cell \u229\'8c\cell \u250\'9c\cell \u168\'ac\cell \u186\'bc\cell \u195\'cc\cell \cell \cell \cell }\pard \widctlpar\intbl\adjustright {\f12\fs20 \row }\pard \qc\keepn\widctlpar\intbl\adjustright {\fs20 D\cell }{\f12\fs20 \cell \cell -\cell =\cell M\cell ]\cell m\cell \}\cell \u231\'8d\cell \u249\'9d\cell \u8800\'ad\cell \u8486\'bd\cell \u213\'cd\cell \cell \cell \cell }\pard \widctlpar\intbl\adjustright {\f12\fs20 \row }\pard \qc\keepn\widctlpar\intbl\adjustright {\fs20 E\cell }{\f12\fs20 \cell \cell .\cell >\cell N\cell ^\cell n\cell ~\cell \u233\'8e\cell \u251\'9e\cell \u198\'ae\cell \u230\'be\cell \u338\'ce\cell \cell \cell \cell }\pard \widctlpar\intbl\adjustright {\f12\fs20 \row }\trowd \trqc\trgaph80\trleft-80\trkeep \clvertalt\clbrdrr\brdrs\brdrw15 \cltxlrtb \cellx385\clvertalt\cltxlrtb \cellx850\clvertalt\cltxlrtb \cellx1315\clvertalt\cltxlrtb \cellx1780\clvertalt\cltxlrtb \cellx2245\clvertalt\cltxlrtb \cellx2710\clvertalt\cltxlrtb \cellx3175\clvertalt\cltxlrtb \cellx3640\clvertalt\cltxlrtb \cellx4105\clvertalt\cltxlrtb \cellx4570\clvertalt\cltxlrtb \cellx5035\clvertalt\cltxlrtb \cellx5500\clvertalt\cltxlrtb \cellx5965\clvertalt\cltxlrtb \cellx6430\clvertalt\cltxlrtb \cellx6895\clvertalt\cltxlrtb \cellx7360\clvertalt\cltxlrtb \cellx7825\pard \qc\widctlpar\intbl\adjustright {\fs20 F\cell }{\f12\fs20 \cell \cell /\cell ?\cell O\cell _\cell o\cell \cell \u232\'8f\cell \u252\'9f\cell \u216\'af\cell \u248\'bf\cell \u339\'cf\cell \cell \cell \cell }\pard \widctlpar\intbl\adjustright {\f12\fs20 \row }\pard \widctlpar\adjustright {\fs20 \par }\pard \fi-360\li360\widctlpar\adjustright {\fs20 \bullet \tab The characters from the space ($20) to the tilde ($7E) are all standard printing ASCII characters.\par \bullet \tab While they have standard definitions, the characters $11..$14, $AD, $B0..$B3, $B5..$BA, $BD, $C2..$C6 and $D6 tend to be rare in most fonts.\par \bullet \tab Character $CA is the non-breaking space.\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \sect }\sectd \lndscpsxn\sbkodd\linex0\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Appendix D: Writing User Tools for GSoft\~BASIC\par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Appendix D \endash  Writing User Tools for GSoft\~BASIC}{\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\v\f4\fs36\cgrid {\tc {\v Appendix D \endash  Writing User Tools for GSoft\~BASIC\tcl1}}}{\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 The Role Of User Tools}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 The Role Of User Tools\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\*\bkmkstart bk35}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 assembly language}}}{\fs20 While GSoft\~BASIC is a powerful, flexible language, there are some things it doesn\rquote t do well. Things like high-speed serial communications, accessing hardware, or implementing fast graphics routines work better in other languages, usually assembly language. User tools give you a way to write specific subroutines like these in a different language, then use them from GSoft\~BASIC.\par There are two other benefits of user tools. First, they can be used from languages other than GSoft\~BASIC. Any Apple\~II}{\fs18 GS}{\fs20  language that supports user tools, such as ORCA/Pascal, ORCA/C, ORCA/Modula-2 and ORCA/M, can use the same user tool you write for GSoft\~BASIC. Second, they give you a way to add features to GSoft\~BASIC through fast, efficient assembly language libraries.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Writing User Tools}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Writing User Tools\tcl2}}}{\fs28 \par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Apple\~II}{\fs20 GS}{\fs24  Toolbox Reference Volume 2}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Apple\~II}{\v\fs20 GS}{\v\fs24  Toolbox Reference Volume 2\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Appendix A of the }{\i\fs20 Apple\~II}{\i\fs18 GS}{\i\fs20  Toolbox Reference, Volume 2}{\fs20  is the official documentation about how to write user tools. It tells you exactly how tools are organized, installed, and what the environment is when tool routines are called.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Avoiding Tool Number Conflicts}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Avoiding Tool Number Conflicts\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 There are 256 available user tool numbers. While it is unlikely that there will be 256 publicly released user tools for the Apple\~II}{\fs18 GS}{\fs20 , even approaching this number means there will be inevitable conflicts.\par If you write your tools carefully, though, this does not need to be a serious problem.\par The plain truth is that a tool doesn\rquote t need to know its own tool number. You can change the tool number for a carefully written tool by renaming the file and changing the interface file to use the new number. This makes it relatively easy for anyone using your tool to renumber it if there is a numbering conflict with some other existing tool.\par There are two places where it might seem that a tool needs to use its own tool number. The first is if the tool needs to call itself. That\rquote s not really necessary, though. The tool can be organized internally as a series of subroutines, and calls from inside the tool can call the subroutines rather than using the tool call mechanism. In addition to avoiding a dependence on a specific tool number, this will also make the call faster.\par The second possible problem area is tool error numbers. It is traditional to use the tool number as the most significant byte of the error number. In fact, that\rquote s exactly what the Game Paddle Library does\emdash the parameter out of range error is the tool number multiplied by 256 and added to 1. If you change the tool number, though, you\rquote ll find that the most significant byte of the error number changes, too. That\rquote s because the error number is formed from the tool number passed to the Game Paddle Library when it is called, not from a fixed internal constant. Every tool call can look to see what the actual tool number is, rather than depending on a fixed tool number.\par The Byte Works, Inc. is using user tools to implement a set of standard libraries. These libraries are numbered sequentially from 1. While all our libraries have numbers that can be changed, it is still best to avoid conflicts when possible, so we suggest that you use user tool numbers of 64 or higher for your own libraries. We will maintain a list of user tools developed for GSoft\~BASIC to advise you which numbers have been used.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 The GSoft\~BASIC Interface}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 The GSoft\~BASIC Interface\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Writing the tool is the biggest part of creating a user tool for GSoft\~BASIC, but it\rquote s not the only part. You also need to create a tool interface file and compile the interface with CompileTool}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool}}}{\fs20 . This creates the .gst file that GSoft\~BASIC loads so it knows how to call your user tool.\par See }{\i\fs20 CompileTool}{\fs20  in Chapter 4 for details.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Installing the Game Paddle Library}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Installing the Game Paddle Library\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 This section shows you how to install and make use of a user tool from GSoft\~BASIC. The description assumes you are installing and using a user tool that already has a GSoft\~BASIC interface file. If you have a user tool that does not have a GSoft\~BASIC interface file, see }{\i\fs20 CompileTool}{\fs20  in Chapter 4. CompileTool}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CompileTool}}}{\fs20  is the utility you use to create GSoft\~BASIC interface files.\par There are three critical pieces to any user tool: The tool itself, the interface file that tells GSoft\~BASIC what\rquote s in the tool, and the documentation that tells you how to use the tool calls.\par The documentation for the Game Paddle Library is in Chapter\~18.\par The next two paragraphs tell you how to manually install the Game Paddle Library. There is also an installer option to install the tool. If you used that option when you installed GSoft\~BASIC the files will already be in place.\par To install the tool itself, copy the file UserTool001 from the folder :GSoft.Extras:System:Tools on the extras disk to the Tools folder, found inside your System folder. The disk containing this folder must be mounted when your program uses LOADLIBRARY to load the tool.\par The interface file is in the :GSoft:Samples:GameTool folder on the program disk. Copy GameTool.gst to any of these locations.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 The Folder Containing GSoft.Sys16\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Copy the file to this folder if you are using the GSoft\~BASIC shell. This is the most common place to put the tool interface.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 13:GSoftDefs:\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Copy the file to this folder if you are using the version of GSoft\~BASIC that runs from the ORCA shell.\par }\pard\plain \s34\sb260\sa140\keepn\widctlpar\adjustright \b\f4\cgrid {\fs20 The Folder Containing Your Program\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Copy the interface file to the folder containing your program if you don\rquote t want the user tool to be available for every program you create. If you copy the file to the local folder, though, don\rquote t copy it to the other locations. If you do, GSoft\~BASIC will load the file from each location. That won\rquote t actually cause your program to fail, but it takes extra time each time you start GSoft\~BASIC, and the files take up extra RAM.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Sample Source}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Sample Source\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 There are some subtle tricks to writing user tools, like the fact that there are actually two return addresses on the stack when your tool is called, not one. It helps to have an example as you sort these issues out!\par The complete source code for the Game Paddle Library and the Time Library are in your samples folder. They are written in assembly language, and require ORCA/M to assemble.{\*\bkmkend bk35}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 user tools\:writing}{\rxe bk35}}}{\fs20 \par \sect }\sectd \lndscpsxn\sbkodd\linex0\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Appendix E: Converting Applesoft\~BASIC Programs to GSoft\~BASIC\par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Appendix E \endash  Converting Applesoft\~BASIC Programs to GSoft\~BASIC}{\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\v\f4\fs36\cgrid {\tc {\v Appendix E \endash  Converting Applesoft\~BASIC Programs to GSoft\~BASIC\tcl1}}}{\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 {\*\bkmkstart bk39}The purpose of this appendix is to help you convert Applesoft\~BASIC programs to GSoft\~BASIC. It is also useful if you need to convert a GSoft\~BASIC program to Applesoft\~BASIC, or if you want to develop a program for both platforms simultaneously.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Applesoft\~BASIC Peeks, Pokes and Calls}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Applesoft\~BASIC Peeks, Pokes and Calls\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 PEEK function}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 POKE statement}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CALL statement}}}{\fs20 This section lists PEEKs, POKEs and CALLs that are common in Applesoft\~BASIC programs. It tells what the statement is used for in Applesoft\~BASIC, and how to get the same effect in GSoft\~BASIC.\par Some PEEK, POKE and CALL addresses are shown as negative numbers. This is an Applesoft\~BASIC convention for representing numbers in the range 32768 to 65535. The larger numbers actually worked in Applesoft\~BASIC, so, for example, you might occasionally see PEEK (49152) to read the keyboard instead of PEEK (-16384). To convert from negative numbers to positive, add the value to 65536. To convert from positive values to negative, subtract 65536 from the value. Hexadecimal notation is always used for the GSoft\~BASIC equivalents, although positive integers will work just as well\emdash but }{\i\fs20 negative values will not work in GSoft\~BASIC}{\fs20 ! The old 8 bit Apple\~][ used a 16 bit address bus, which is why 65536 (2 raised to the power 16) is used to convert from negative to positive equivalent numbers. The Apple\~II}{\fs18 GS}{\fs20  uses 24 bit numbers for addresses, which GSoft\~BASIC stores as 32 bit values, so this conversion doesn\rquote t work.\par PEEKs and POKEs to soft switches still work, but there is often a better way to get the same effect in GSoft\~BASIC. CALL statements from Applesoft\~BASIC cannot be made from GSoft\~BASIC.\par \par }\pard\plain \s32\li360\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx1980\adjustright \f4\cgrid {\fs20 {\*\bkmkstart bk36}Call\tab Use and Conversion\par }\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \f4\cgrid {\f6\fs18 CALL -10621}{\fs20 \tab Clears the internal stack of all control information.\par \tab There is no GSoft\~BASIC equivalent.\par }{\f6\fs18 CALL -3288}{\fs20 \tab }{\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ONERR GOTO statement}}}{\fs20 Clears the internal stack in ONERR GOTO handlers.\par \tab There is no GSoft\~BASIC equivalent.\par }{\f6\fs18 CALL -3086}{\fs20 \tab Clears the high resolution screen to black.\par \tab There is no GSoft\~BASIC equivalent, but the Apple\~II}{\fs18 GS}{\fs20  graphics screen can be cleared with HGR.\par }{\f6\fs18 CALL -3082}{\fs20 \tab Clears the high resolution screen to the color most recently used in an HPLOT statement.\par \tab There is no GSoft\~BASIC equivalent, but the Apple\~II}{\fs18 GS}{\fs20  graphics screen can be rapidly painted any color with QuickDraw\~II\rquote s SETSOLIDPENPAT and PAINTRECT commands.\par }{\f6\fs18 CALL -1998}{\fs20 \tab Clears the low resolution screen to black or fills the text screen with inverse @ characters.\par \tab There is no GSoft\~BASIC equivalent.\par }{\f6\fs18 CALL -1994}{\fs20 \tab Clears the upper half of the low resolution screen to black or fills the upper half of the text screen with inverse @ characters.\par \tab There is no GSoft\~BASIC equivalent.\par }{\f6\fs18 CALL -958}{\fs20 \tab Clears the text screen from the current character position to the bottom right corner of the screen.\par \tab Use\par \par }\pard\plain \s31\fi-1620\li1980\widctlpar\adjustright \f6\fs20\cgrid {\fs18 \tab \tab PRINT CHR$(11);\par }\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par \tab in GSoft\~BASIC.\par }{\f6\fs18 CALL -936}{\fs20 \tab Erases the text screen and places the cursor at the top left of the screen.\par \tab Use HOME in GSoft\~BASIC.\par }{\f6\fs18 CALL -922}{\fs20 \tab Moves the cursor down one line.\par \tab Use\par \par }\pard\plain \s31\fi-1620\li1980\widctlpar\adjustright \f6\fs20\cgrid {\fs18 \tab \tab PRINT CHR$(10);\par }\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par \tab in GSoft\~BASIC.\par }{\f6\fs18 CALL -912}{\fs20 \tab Scrolls the screen up one line.\par \tab There is no GSoft\~BASIC equivalent, but you can get the same effect by moving the cursor to line 24, issuing a carriage return using a PRINT statement, then repositioning the cursor if you need to preserve the original location.\par }{\f6\fs18 CALL -868}{\fs20 \tab Clears the text screen from the cursor to the end of the line.\par \tab Use\par \par }\pard\plain \s31\fi-1620\li1980\widctlpar\adjustright \f6\fs20\cgrid {\fs18 \tab \tab PRINT CHR$(29);\par }\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par \tab in GSoft\~BASIC.{\*\bkmkend bk36}}{\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CALL statement}{\rxe bk36}}}{\fs20 \par \par }\pard\plain \s32\li360\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx1980\adjustright \f4\cgrid {\fs20 {\*\bkmkstart bk37}PEEK\tab Use and Conversion\par }\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \f4\cgrid {\f6\fs18 PEEK (36)}{\fs20 \tab Returns the current horizontal cursor position.\par \tab Use the POS function in GSoft\~BASIC. Keep in mind that Applesoft\~BASIC numbers the columns 0 to 79, but GSoft\~BASIC numbers them 1 to 80.\par }{\f6\fs18 PEEK (37)}{\fs20 \tab Returns the current vertical cursor position.\par \tab Use the CSRLIN function in GSoft\~BASIC. Keep in mind that Applesoft\~BASIC numbers the lines 0 to 23, but GSoft\~BASIC numbers them 1 to 24.\par }{\f6\fs18 PEEK (216)}{\fs20 \tab Returns a value greater than 127 if an ONERR GOTO handler is active.\par \tab There is no GSoft\~BASIC equivalent.\par }{\f6\fs18 PEEK (219) * 256 + PEEK (218)\par }{\fs20 \tab Used in ONERR GOTO handlers, this expression returns the line number where the error occurred.\par \tab Use ERL in GSoft\~BASIC.\par }{\f6\fs18 PEEK (222)}{\fs20 \tab Used in ONERR GOTO handlers, this PEEK returns the error number.\par \tab Use ERR in GSoft\~BASIC.\par }{\f6\fs18 PEEK (-16384)}{\fs20 \tab Returns the last character typed from the keyboard}{\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 keyboard}}}{\fs20 .\par \tab Use\par \par }\pard\plain \s31\fi-1620\li1980\widctlpar\adjustright \f6\fs20\cgrid {\fs18 \tab \tab PEEK ($00C000)\par }\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par \tab in GSoft\~BASIC. Keep in mind that there are several ways to read the keyboard under GS/OS. If the Event Manager or the GNO shell are in use, reading the keyboard this way is not appropriate.\par }{\f6\fs18 PEEK (-16336)}{\fs20 \tab Clicks the speaker.\par \tab Use\par \par }\pard\plain \s31\fi-1620\li1980\widctlpar\adjustright \f6\fs20\cgrid {\fs18 \tab \tab PEEK ($00C030)\par }\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par \tab in GSoft\~BASIC.\par }{\f6\fs18 PEEK (-16352)}{\fs20 \tab Clicks the cassette recorder output.\par \tab The cassette recorder output is only present on the Apple\~][ and Apple\~//e.\par }{\f6\fs18 PEEK (-16320)}{\fs20 \tab Triggers the game paddle port utility strobe.\par \tab Use\par \par }\pard\plain \s31\fi-1620\li1980\widctlpar\adjustright \f6\fs20\cgrid {\fs18 \tab \tab PEEK ($00C040)\par }\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par \tab in GSoft\~BASIC.\par }{\f6\fs18 PEEK (-16287)}{\fs20 \tab Reads game paddle button 0. If the result is greater than 127, the button is being pressed; if not, the button is not being pressed.\par \tab Use\par \par }\pard\plain \s31\fi-1620\li1980\widctlpar\adjustright \f6\fs20\cgrid {\fs18 \tab \tab PEEK ($00C061)\par }\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par \tab in GSoft\~BASIC.\par }{\f6\fs18 PEEK (-16286)}{\fs20 \tab Reads game paddle button 1. If the result is greater than 127, the button is being pressed; if not, the button is not being pressed.\par \tab Use\par \par }\pard\plain \s31\fi-1620\li1980\widctlpar\adjustright \f6\fs20\cgrid {\fs18 \tab \tab PEEK ($00C062)\par }\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par \tab in GSoft\~BASIC.\par }{\f6\fs18 PEEK (-16285)}{\fs20 \tab Reads game paddle button 2. If the result is greater than 127, the button is being pressed; if not, the button is not being pressed.\par \tab Use\par \par }\pard\plain \s31\fi-1620\li1980\widctlpar\adjustright \f6\fs20\cgrid {\fs18 \tab \tab PEEK ($00C063)\par }\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par \tab in GSoft\~BASIC.{\*\bkmkend bk37}}{\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 PEEK function}{\rxe bk37}}}{\fs20 \par \par }\pard\plain \s32\li360\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx1980\adjustright \f4\cgrid {\fs20 {\*\bkmkstart bk38}POKE\tab Use and Conversion\par }\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \f4\cgrid {\f6\fs18 POKE 32 , L}{\fs20 \tab Sets the left edge of the text screen.\par \tab There is no GSoft\~BASIC equivalent.\par }{\f6\fs18 POKE 33 , W}{\fs20 \tab Sets the width of the text screen.\par \tab There is no GSoft\~BASIC equivalent.\par }{\f6\fs18 POKE 34 , T}{\fs20 \tab Sets the top edge of the text screen.\par \tab There is no GSoft\~BASIC equivalent.\par }{\f6\fs18 POKE 35 , B}{\fs20 \tab Sets the bottom edge of the text screen.\par \tab There is no GSoft\~BASIC equivalent.\par }{\f6\fs18 POKE 36 , CH}{\fs20 \tab }{\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 tabs}}}{\fs20 Sets the horizontal cursor position.\par \tab Use HTAB in GSoft\~BASIC. Keep in mind that Applesoft\~BASIC numbers the columns 0 to 79, but GSoft\~BASIC numbers them 1 to 80.\par }{\f6\fs18 POKE 37 , CV}{\fs20 \tab Sets the horizontal cursor position.\par \tab Use VTAB in GSoft\~BASIC. Keep in mind that Applesoft\~BASIC numbers the lines 0 to 23, but GSoft\~BASIC numbers them 1 to 24.\par }{\f6\fs18 POKE 216 , 0}{\fs20 \tab Turns any active ONERR GOTO handler off.\par \tab Use\par \par }\pard\plain \s31\fi-1620\li1980\widctlpar\adjustright \f6\fs20\cgrid {\fs18 \tab \tab ONERR GOTO 0\par }\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par \tab in GSoft\~BASIC.\par }{\f6\fs18 POKE -16368 , 0}{\fs20 \tab Clears the keyboard}{\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 keyboard}}}{\fs20  strobe.\par \tab Use\par \par }\pard\plain \s31\fi-1620\li1980\widctlpar\adjustright \f6\fs20\cgrid {\fs18 \tab \tab POKE $00C010, 0\par }\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par \tab in GSoft\~BASIC.\par }{\f6\fs18 POKE -16304 , 0}{\fs20 \tab Switches the display from the text screen to one of the graphics modes. See also POKE -16297 and POKE -16298.\par \tab Depending on how you are translating the program, you may want to leave the POKE as is, or you may want to use GSoft\~BASIC\rquote s HGR statement.\par }{\f6\fs18 POKE -16303 , 0}{\fs20 \tab Switches the display from one of the graphics modes to the text screen.\par \tab Depending on how you are translating the program, you may want to leave the POKE as is, or you may want to use GSoft\~BASIC\rquote s TEXT command.\par }{\f6\fs18 POKE -16302 , 0}{\fs20 \tab Switches the display to full screen graphics. See also POKE -16301.\par \tab There is no GSoft\~BASIC equivalent to mixed text and graphics. Depending on how the text and graphics screens are accessed, you may be able to omit the POKE altogether or use it as is.\par }{\f6\fs18 POKE -16301 , 0}{\fs20 \tab Switches the display to mixed text and graphics. See also POKE -16302.\par \tab There is no GSoft\~BASIC equivalent to mixed text and graphics. \par }{\f6\fs18 POKE -16300 , 0}{\fs20 \tab Switches the display from page 2 to page 1. See also POKE -16299.\par \tab You do not usually use page 2 with GSoft\~BASIC, but with adequate preparation you can use this POKE as is. See }{\i\fs20 Low Resolution Graphics and Text Screen Access}{\fs20 , later in this appendix, for details.\par }{\f6\fs18 POKE -16299 , 0}{\fs20 \tab Switches the display from page 1 to page 2. See also POKE -16300.\par \tab You do not usually use page 2 with GSoft\~BASIC, but with adequate preparation you can use this POKE as is. See }{\i\fs20 Low Resolution Graphics and Text Screen Access}{\fs20 , later in this appendix, for details.\par }{\f6\fs18 POKE -16298 , 0}{\fs20 \tab Displays the Apple\~][ low resolution graphics screen, as opposed to the high resolution graphics screen. See also POKE -16304 and POKE -16297.\par \tab Depending on how you are translating the program, you may want to leave the POKE as is, or you may want to use GSoft\~BASIC\rquote s HGR statement.\par }{\f6\fs18 POKE -16297 , 0}{\fs20 \tab Displays the Apple\~][ high resolution graphics screen, as opposed to the low resolution graphics screen. This is not the same as the Apple\~II}{\fs18 GS}{\fs20  graphics screen normally used by GSoft\~BASIC and the Apple\~II}{\fs18 GS}{\fs20  toolbox. See also POKE -16304 and POKE -16298.\par \tab Depending on how you are translating the program, you may want to leave the POKE as is, or you may want to use GSoft\~BASIC\rquote s HGR statement.\par }{\f6\fs18 POKE -16296 , 0}{\fs20 \tab Turns off game paddle annunciator 0.\par \tab Use\par \par }\pard\plain \s31\fi-1620\li1980\widctlpar\adjustright \f6\fs20\cgrid {\fs18 \tab \tab POKE $00C058 , 0\par }\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par \tab in GSoft\~BASIC.\par }{\f6\fs18 POKE -16295 , 0}{\fs20 \tab Turns on game paddle annunciator 0.\par \tab Use\par \par }\pard\plain \s31\fi-1620\li1980\widctlpar\adjustright \f6\fs20\cgrid {\fs18 \tab \tab POKE $00C059 , 0\par }\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par \tab in GSoft\~BASIC.\par }{\f6\fs18 POKE -16294 , 0}{\fs20 \tab Turns off game paddle annunciator 1.\par \tab Use\par \par }\pard\plain \s31\fi-1620\li1980\widctlpar\adjustright \f6\fs20\cgrid {\fs18 \tab \tab POKE $00C05A , 0\par }\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par \tab in GSoft\~BASIC.\par }{\f6\fs18 POKE -16293 , 0}{\fs20 \tab Turns on game paddle annunciator 1.\par \tab Use\par \par }\pard\plain \s31\fi-1620\li1980\widctlpar\adjustright \f6\fs20\cgrid {\fs18 \tab \tab POKE $00C05B , 0\par }\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par \tab in GSoft\~BASIC.\par }{\f6\fs18 POKE -16292 , 0}{\fs20 \tab Turns off game paddle annunciator 2.\par \tab Use\par \par }\pard\plain \s31\fi-1620\li1980\widctlpar\adjustright \f6\fs20\cgrid {\fs18 \tab \tab POKE $00C05C , 0\par }\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par \tab in GSoft\~BASIC.\par }{\f6\fs18 POKE -16291 , 0}{\fs20 \tab Turns on game paddle annunciator 2.\par \tab Use\par \par }\pard\plain \s31\fi-1620\li1980\widctlpar\adjustright \f6\fs20\cgrid {\fs18 \tab \tab POKE $00C05D , 0\par }\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par \tab in GSoft\~BASIC.\par }{\f6\fs18 POKE -16290 , 0}{\fs20 \tab Turns off game paddle annunciator 3.\par \tab Use\par \par }\pard\plain \s31\fi-1620\li1980\widctlpar\adjustright \f6\fs20\cgrid {\fs18 \tab \tab POKE $00C05E , 0\par }\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par \tab in GSoft\~BASIC.\par }{\f6\fs18 POKE -16289 , 0}{\fs20 \tab Turns on game paddle annunciator 3.\par \tab Use\par \par }\pard\plain \s31\fi-1620\li1980\widctlpar\adjustright \f6\fs20\cgrid {\fs18 \tab \tab POKE $00C05F , 0\par }\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par \tab in GSoft\~BASIC.{\*\bkmkend bk38}}{\pard\plain \s25\fi-1620\li1980\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 POKE statement}{\rxe bk38}}}{\fs20 \par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Low Resolution Graphics and Text Screen Access}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Low Resolution Graphics and Text Screen Access\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 low resolution graphics}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 text screen}}}{\fs20 PEEKs and POKEs in the range $0400 to $07FF are reading and writing the first of two pages used for 40 column text or low resolution graphics. This memory area can be displayed as text, low resolution graphics, or a mixture with graphics on top and four lines of text at the bottom. The display method is set using soft switches. See the various POKE commands in the previous section for details about the locations to poke for various effects.\par While GSoft\~BASIC does not support low resolution graphics directly, PEEKs and POKEs to the graphics page work fine, and PEEKs and POKEs to the text screen work fine, too.\par Applesoft\~BASIC programs written for the Apple\~//e, Apple\~//c or Apple\~II}{\fs18 GS}{\fs20  may also manipulate memory in the range $010400 to $0107FF, generally using bank switching, but occasionally by poking assembly routines into RAM. This gives access to the other 40 columns of text used when 80 columns of text are displayed. Bank switching will still work under GSoft\~BASIC. Poking assembly routines into RAM is not safe under GS/OS}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GS/OS}}}{\fs20 , but converting the program to use POKEs is generally easy. Under Applesoft\~BASIC, you could not POKE directly into memory bank 1, which is why these tricks are used in Applesoft\~BASIC. From GSoft\~BASIC you can POKE anywhere in RAM.\par PEEKs and POKEs in the range $0800 to $0BFF are accessing the second 40 column text and low resolution graphics page. Accessing $010800 to $010BFF, again through bank switching or poking assembly language into RAM, is manipulating the second 40 columns of an 80 column display. Accessing this second page is generally not safe under GS/OS. If you must use the second display, you must reserve this memory first using the Memory Manager Tool Set. Since this range of memory is generally used for direct page memory by the first program GS/OS executes, this will be difficult\emdash in fact, you may need to write a GS/OS init that will reserve the memory permanently at boot time.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Commands in GSoft\~BASIC That Are Not In Applesoft\~BASIC}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Commands in GSoft\~BASIC That Are Not In Applesoft\~BASIC\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 These commands exist in GSoft\~BASIC but not in Applesoft\~BASIC. In some cases there are equivalent ways to accomplish the same thing, generally with the PEEKs, POKEs and CALLs shown earlier in this appendix.\par If you are converting a GSoft\~BASIC program to Applesoft\~BASIC, you will have to remove each of these commands from the program.\par \par }\pard\plain \s31\fi360\widctlpar\tx360\tx1980\tx3600\tx5220\tx6840\tx7820\adjustright \f6\fs20\cgrid {\fs18 !}{\pard\plain \s31\fi360\widctlpar\tx360\tx1980\tx3600\tx5220\tx6840\tx7820\adjustright \v\f6\fs18\cgrid {\xe {\v\fs18 }{\v\fs18 !}}}{\fs18 \tab ALLOCATE\tab BREAK\tab CASE\tab CDBL\tab CHDIR\tab CINT\tab CLOSE\tab CLNG\tab CSNG\tab CSRLIN\tab CURDIR$\tab DIR$\tab DISPOSE\tab DO\tab ERL\tab ERROR\tab ERR\tab EOF\tab FUNCTION\tab GSOS\tab KILL\tab LINE INPUT\tab LOADLIBRARY\tab LOC\tab LOF\tab LOOP\tab MKDIR\tab MOUSETEXT\tab NAME\tab NIL\tab OPEN\tab PUT\tab RMDIR}{\fs18\cf6 \tab }{\fs18 SEEK\tab SELECT\tab SETMEM\tab SIZEOF\tab SUB\tab TOOL\tab TOOLERROR\tab TYPE\tab UNLOADLIBRARY\tab LIBRARY\tab WHILE\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Commands in Applesoft\~BASIC That Are Not In GSoft\~BASIC}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Commands in Applesoft\~BASIC That Are Not In GSoft\~BASIC\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 These commands exist in Applesoft\~BASIC but not in GSoft\~BASIC.\par \par }\pard\plain \s31\fi360\widctlpar\tx360\tx1980\tx3600\tx5220\tx6840\tx7820\adjustright \f6\fs20\cgrid {\fs18 &\tab COLOR=\tab DEL\tab DRAW\tab FLASH\tab GR\tab HGR2\tab HIMEM:\tab HLIN\tab IN#\tab LIST\tab LOAD\tab LOMEM:\tab NOTRACE\tab PDL\tab PLOT\tab PR#\tab RECALL\tab ROT=\tab SAVE\tab SCALE=\tab SCRN\tab SHLOAD\tab STORE\tab TRACE\tab USR\tab VLIN\tab XDRAW\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par In some cases, like FLASH and SHLOAD, the commands actually aren\rquote t available in Applesoft\~BASIC on an Apple\~II}{\fs18 GS}{\fs20 , either\emdash the cassette port is missing, and the character ROM no longer supports flashing characters. STORE and RECALL were also used with cassette tape drives, and have no GSoft\~BASIC equivalent.\par LOAD and SAVE worked with either cassette tape drives or disks, depending on whether a file name was used. GSoft\~BASIC supports LOAD and SAVE from the command line, but not from inside an executing program.\par The & and USR commands were used to extend Applesoft\~BASIC using assembly language. Old & packages and USR subroutines cannot safely execute under GS/OS, so any Applesoft\~BASIC program that uses them would need to be converted. GSoft\~BASIC does support extensions via assembly language, but it uses LIBRARY to do so. Since the old commands must be rewritten anyway, it makes sense to take advantage of the names and parameter passing available from user tools.\par IN# and PR# are used in Applesoft\~BASIC to redirect input and output to hardware cards. The disk commands are used to handle all input and output in GSoft\~BASIC. GS/OS drivers can be written for practically any device, and have already been written for most of them.\par DEL and LIST are available in GSoft\~BASIC, but not from inside a program. The GSoft\~BASIC shell has both commands, and they work just like they do in Applesoft\~BASIC.\par HIMEM: and LOMEM: deal with memory allocation in a way that is not safe under GS/OS. GSoft\~BASIC supports SETMEM for the same purpose.\par COLOR=, DRAW, GR, HGR2, HLIN, PLOT, ROT=, SCALE=, SCRN, VLIN and XDRAW are older graphics commands. GSoft\~BASIC has access to QuickDraw\~II, where you will find equivalents for most of these commands, as well as many new features.\par TRACE and NOTRACE are used for debugging Applesoft\~BASIC programs. GSoft\~BASIC uses BREAK and source level debuggers (sold separately) for the same task.\par The PDL command reads game paddle controls and joysticks. There is no equivalent command in GSoft\~BASIC, but there is a game port user tool that does the same thing. See appendix D for details.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Commands That Are Different in Applesoft\~BASIC and GSoft\~BASIC}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Commands That Are Different in Applesoft\~BASIC and GSoft\~BASIC\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 These commands exist in both implementations of BASIC, and with the exception of CALL, generally do the same thing. Each command has some extended capabilities in GSoft\~BASIC that you will have to take into account when porting GSoft\~BASIC programs to Applesoft\~BASIC, though. CALL is the only statement that exists in both languages that will cause problems when you port an Applesoft\~BASIC program to GSoft\~BASIC.\par \par }\pard \s25\fi-1080\li1440\sb40\widctlpar\adjustright {\f6\fs18 CALL}{\fs20 \tab }{\pard\plain \s25\fi-1080\li1440\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 CALL statement}}}{\fs20 The CALL statement is used to call machine language subroutines in Applesoft\~BASIC and SUB subroutines in GSoft\~BASIC.\par }{\f6\fs18 DEF FN}{\fs20 \tab }{\pard\plain \s25\fi-1080\li1440\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DEF FN statement}}}{\fs20 GSoft\~BASIC supports multiple parameters and more return types.}{\f6\fs18 \par DIM}{\fs20 \tab }{\pard\plain \s25\fi-1080\li1440\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DIM statement}}}{\fs20 GSoft\~BASIC supports named types using AS clauses.}{\f6\fs18 \par FOR}{\fs20 \tab }{\pard\plain \s25\fi-1080\li1440\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 FOR statement}}}{\fs20 GSoft\~BASIC supports all number types as FOR loop variables; Applesoft\~BASIC only allows SINGLE numbers.}{\f6\fs18 \par GET}{\fs20 \tab }{\pard\plain \s25\fi-1080\li1440\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 GET statement}}}{\fs20 GSoft\~BASIC supports file numbers.}{\f6\fs18 \par HCOLOR=}{\fs20 \tab }{\pard\plain \s25\fi-1080\li1440\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 HCOLOR= statement}}}{\fs20 Applesoft\~BASIC uses the high resolution graphics screen, which displays a limited 6 colors on a 280 by 192 pixel screen. GSoft\~BASIC uses the Apple\~II}{\fs18 GS}{\fs20  graphics screen, which supports 16 distinct colors (more with some tricks) on a 320 by 200 pixel screen.}{\f6\fs18 \par HGR}{\fs20 \tab Starts QuickDraw II in 320 by 200 pixel mode. See also HCOLOR=.}{\f6\fs18 \par HPLOT}{\fs20 \tab Draws a line on the QuickDraw II display. See also HCOLOR=.}{\f6\fs18 \par IF}{\fs20 \tab }{\pard\plain \s25\fi-1080\li1440\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 IF statement}}}{\fs20 GSoft\~BASIC adds block IF-THEN-ELSE statements. All Applesoft\~BASIC IF statements will still work.}{\f6\fs18 \par INPUT}{\fs20 \tab }{\pard\plain \s25\fi-1080\li1440\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 INPUT statement}}}{\fs20 GSoft\~BASIC supports file numbers.}{\f6\fs18 \par PEEK}{\fs20 \tab }{\pard\plain \s25\fi-1080\li1440\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 PEEK function}}}{\fs20 GSoft\~BASIC uses 24 bit addresses, while Applesoft\~BASIC uses 16 bit addresses. This causes conversion problems with Applesoft\~BASIC addresses that are negative numbers. These must be converted to positive numbers by adding 65536 before they can be used in GSoft\~BASIC. See the PEEK and POKE conversion table, earlier in this appendix, for a complete discussion.}{\f6\fs18 \par POKE}{\fs20 \tab }{\pard\plain \s25\fi-1080\li1440\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 POKE statement}}}{\fs20 See PEEK.}{\f6\fs18 \par PRINT}{\fs20 \tab }{\pard\plain \s25\fi-1080\li1440\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 PRINT statement}}}{\pard\plain \s25\fi-1080\li1440\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 tabs}}}{\fs20 GSoft\~BASIC supports PRINT USING and printing to files by file number.}{\f6\fs18 \par PUT}{\fs20 \tab }{\pard\plain \s25\fi-1080\li1440\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 PUT statement}}}{\fs20 GSoft\~BASIC supports file numbers.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Other Differences}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Other Differences\tcl2}}}{\fs28 \par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Available Memory}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Available Memory\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 memory}}}{\fs20 Applesoft\~BASIC is limited to memory from $000800 to the beginning of the operating system in use. For ProDOS, that\rquote s $009600, giving you 35.5K of RAM. This memory is used both for the program and for variables. High resolution graphics, using page 2 of the text or low resolution graphics screens, & packages and machine language subroutines all took memory away.\par GSoft\~BASIC doesn\rquote t have a fixed limit on memory. It\rquote s a rare Apple\~II}{\fs18 GS}{\fs20  that can\rquote t set aside 256K each for the program and variable buffers and have room left over for dynamic memory allocated with ALLOCATE, and it\rquote s quite common for an Apple\~II}{\fs18 GS}{\fs20  to have enough memory to set aside 1024K or more for each buffer. Compared to Applesoft\~BASIC, the memory available to GSoft\~BASIC programs is staggering. If you use a great deal of memory, it\rquote s unlikely you will be able to port your program to Applesoft\~BASIC without seriously crippling its capabilities.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Disk Input and Output}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Disk Input and Output\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 disk commands}}}{\fs20 Applesoft\~BASIC does not have disk input and output commands. Disk input and output is handled by special print statements that start with CHR$(4). GSoft\~BASIC uses built-in disk commands that generally match those found on Microsoft\~BASIC}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 Microsoft\~BASIC}}}{\fs20  implementations on DOS and Windows machines. While Applesoft\~BASIC and GSoft\~BASIC each have specific commands that are not available in the other implementation, you will find that common file operations are easy enough to accomplish from either BASIC. On the other hand, the commands are implemented in very different ways, so they will have to be translated as a program is ported in either direction.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Line Numbers}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Line Numbers\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 line numbers}}}{\fs20 GSoft\~BASIC does not require line numbers. You can add them after the fact with the RENUMBER command, which is a good first step anytime you are porting a program from GSoft\~BASIC to Applesoft\~BASIC.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Numbers}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Numbers\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SINGLE}}}{\fs20 Applesoft\~BASIC really only handles one number type, single precision real numbers. While it can store numbers in INTEGER format, these numbers are always converted to SINGLE values for calculations. This makes it faster to use SINGLE numbers in Applesoft\~BASIC, while it is much faster to use INTEGER values in GSoft\~BASIC.\par GSoft\~BASIC also adds BYTE, LONG and DOUBLE numbers. These are not supported in Applesoft\~BASIC, so you will need to avoid them or convert them to port a GSoft\~BASIC program to Applesoft\~BASIC.\par Finally, Applesoft\~BASIC uses a five byte SINGLE number that has over 9 decimal digits of precision, while GSoft\~BASIC uses a four byte SINGLE with over 7 decimal digits of precision. Some Applesoft\~BASIC programs make use of this extra precision. The easiest way to deal with this in GSoft\~BASIC is to convert the numbers to DOUBLE, which gives you even more precision\emdash about 16 decimal digits of precision.\par This extra precision gives Applesoft\~BASIC one other edge. In some situations, roundoff error shows up earlier in GSoft\~BASIC than it does in Applesoft\~BASIC. This is again caused by the extra precision from Applesoft\~BASIC\rquote s longer SINGLE numbers. Once again, in programs where this extra precision matters, you can switch to DOUBLE numbers.\par {\*\bkmkend bk39}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 Applesoft\~BASIC}{\rxe bk39}}}{\v\fs20 \par }{\fs20 \sect }\sectd \lndscpsxn\sbkodd\linex0\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Appendix F: Implementation Details\par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Appendix F \endash  Implementation Details}{\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\v\f4\fs36\cgrid {\tc {\v Appendix F \endash  Implementation Details\tcl1}}}{\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Memory Use}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Memory Use\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 memory\:use}}}{\fs20 GSoft\~BASIC uses two large memory buffers which it subdivides for efficient internal use, the program buffer and the variable buffer. Programs can also allocate memory from outside this range using the ALLOCATE statement; see }{\i\fs20 Dynamic Memory}{\fs20 , later in this appendix.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Program Buffer}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Program Buffer\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The program buffer}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 program buffer\bxe }}}{\fs20  is used to store the executing program. The program is stored as a series of tokenized lines, as described in }{\i\fs20 Organization in Memory}{\fs20 , later in this appendix.\par If you are using GSoft\~BASIC from the GSoft\~BASIC shell, the program buffer is set using the SETMEM command. You will generally want to make the program buffer about 32K larger than the program to give you plenty of room to add new lines to the program. To get the approximate size of an existing program, multiply the number of blocks shown by the CATALOG command for the program file by 512.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 shell\:ORCA}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ORCA shell}}}{\fs20 If you are using GSoft\~BASIC from the ORCA shell, the program buffer is formed exactly to size as the program loads. From the ORCA shell, the program is stored as an ASCII text file. This file is loaded into RAM, then the program is converted to tokenized form. After this conversion, the program buffer\rquote s size is reduced to the exact size needed and the ASCII text file representation of the program is marked as purgeable. This releases the memory for use by your program, but leaves the file in memory for faster loading next time if the memory isn\rquote t needed by your program.\par The most efficient of all is a program converted to run from the Finder using the MakeRuntime utility}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 MakeRuntime utility}}}{\fs20 . These programs are stored on disk in tokenized format. When you run the program, GSoft\~BASIC allocates exactly the right amount of space and loads the program into RAM.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Variable Buffer}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Variable Buffer\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 SUB statement}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 FUNCTION statement}}}{\fs20 The variable buffer is used for global variables, subroutine parameters, local subroutine variables and strings. As the program starts to run, GSoft\~BASIC scans the file for SUB and FUNCTION statements, setting up a table in this buffer. Types, variables and DEF FN names from the main program are next. Finally, as each SUB or FUNCTION is called, a stack frame is created. The stack frame holds information about the call, such as the return address and the value of the parameters, as well as any local types, variables and DEF FN declarations from the procedure. This memory is released and later reused once the procedure finishes.\par String variables are actually a pointer to a string stored in a string pool at the end of the variable buffer. As strings values are changed, empty memory can be created between the current string values. Eventually, there may not be enough memory left to store a string value, create a new subroutine, or create a new variable. When this happens, the strings are compacted, collecting all of the small pieces of memory into a single large piece. This process is called garbage collection}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 garbage collection}}}{\fs20 . If garbage collection doesn\rquote t create enough free memory for the operation that is underway, your program stops with an out of memory error.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 FRE function}}}{\fs20 Garbage collection occurs automatically when needed. In some programs garbage collection can cause a delay at a critical time, such as a visible update on the screen or during communication with a time-sensitive external device. If this becomes a problem, use the FRE command to force garbage collection at a more convenient time and make sure the variable buffer is large enough that garbage collection will not be needed before you can force it again. Your program will be simpler, smaller and faster if you let garbage collection happen automatically, though, so in the vast majority of situations you should ignore garbage collection entirely and let it happen when needed.\par Tool interface files don\rquote t take up space in this buffer. The space needed by tool interface files is allocated from main memory.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Dynamic Memory}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Dynamic Memory\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The ALLOCATE statement}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ALLOCATE statement}}}{\fs20  gets memory from outside the program buffer and variable buffer. When you ask for a piece of memory larger than 2048 bytes, ALLOCATE gets a chunk of memory directly from Apple\rquote s Memory Manager Tool Set. For smaller chunks, GSoft\~BASIC allocates a 4096 byte chunk of memory and subdivides it.\par Using ALLOCATE statements, a relatively small program with a small variable buffer can get access to all of the memory in the Apple\~II}{\fs18 GS}{\fs20 . For some kinds of programs, this makes a great deal more sense than using fixed arrays in a large variable buffer.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Other Memory Locations}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Other Memory Locations\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 memory\:map}}}{\fs20 Applesoft\~BASIC programmers are used to owning the machine, using PEEK and POKE commands to hammer any memory they like. A memory map shows the places to stay away from, but any location not on the memory map is fair game. Not so with GSoft\~BASIC, which runs under GS/OS! The operating system, GSoft\~BASIC itself, other programs, inits, desk accessories and drivers all use memory. They claim memory using Apple\rquote s Memory Manager Tool Set, use the memory they get this way, and free the memory when it is no longer needed. With a few exceptions, it simply isn\rquote t safe for a GSoft\~BASIC program to use PEEK and POKE commands.\par }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 ALLOCATE statement}}}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 DISPOSE statement}}}{\fs20 In general, your programs should use ALLOCATE to get memory and DISPOSE when the program is finished with the memory.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Tokenized Files}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Tokenized Files\tcl2}}}{\fs28 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 {\*\bkmkstart bk40}GSoft\~BASIC organizes tokenized files and files in memory as lines of tokenized symbols. Tokens are one, two or three byte numbers used to represent a reserved word or tool name. Using a number, usually a one byte number, makes programs much smaller; and allows the interpreter to run much faster, since it doesn\rquote t have to read and look up a sequence of characters to decide what command to execute. For example, a PRINT statement takes six bytes in an ASCII file\emdash five for the letters and one for a space that invariably follows them\emdash but only one byte with a value of 186 in a tokenized line.\par This space saving is so dramatic that tokenized programs are usually shorter than the same program after it is compiled to machine code with a compiler. Of course the compiled program is faster, but in some cases space is more important than speed. This is one of the frustrating reasons why Applesoft\~BASIC programs generally could not be compiled. Due to the memory limits of an eight bit Apple\~][ computer, even modest Applesoft\~BASIC programs frequently used all of the memory available to them. Compiling the program would frequently make it too large to fit in memory!\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 The Organization of Tokenized Programs}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 The Organization of Tokenized Programs\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Whether the program is in a file or loaded in RAM, each program consists of a sequence of lines.\par Each line starts with a two byte offset to the start of the following line. The end of the program is marked with two bytes of zero where this offset would normally appear. The offset is a two byte unsigned value stored least significant byte first. This means that each line must be smaller than 65535 bytes in length.\par The next two bytes are the line number. Line numbers are optional in GSoft\~BASIC; if a line has no line number, the line number field is set to 0. Again, the number is a two byte unsigned value stored least significant byte first. This implies that the largest allowed line number is 65535.\par Next comes the tokenized line. Every token that is a reserved word or the name of a tool call is converted to its equivalent token. }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 tabs}}}{\fs20 Spaces and tabs are used to separate tokens from surrounding characters, but once their job is done they are dropped from the line. }{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 identifiers}}}{\fs20 Identifiers, numbers, operators, data in DATA statements, strings and comments are stored in their original ASCII character form.\par The end of the line is marked with a zero byte.\par In a disk file, the end of file mark for the file appears right after the two zero bytes that mark the end of the sequence of lines. Since the last line ends in a zero, too, this means every program ends with three bytes of zero.\par Programs in RAM are represented the same way, and also end with three zero bytes. The program buffer}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 program buffer}}}{\fs20  can extend further in memory; if it does, the contents of all bytes past the end marker are undefined.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Line Number Schemes}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Line Number Schemes\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 line numbers}}}{\fs20 There are actually two incompatible line number schemes in use. In programs like those imported from Applesoft\~BASIC or typed from the GSoft\~BASIC shell which use line numbers on every line, line numbers must be sequential and unique. In programs that do not use line numbers on every line, line numbers do not have to be sequential. They do have to be unique within the main program or within any specific procedure, but you can safely use, say, 999 as an error exit in several different procedures. Even the limitation that line numbers within a procedure be unique is not enforced; if there are two identical line numbers in the same procedure, GSoft\~BASIC will find and use the first line number.\par In a few cases GSoft\~BASIC needs some way to tell these two kinds of programs apart. This is important when the program is being edited, but not when it is running. It does so by scanning the program when it is first loaded. If there is any non-blank line in the program where a line number is missing or zero, the program is treated as if it uses optional line numbers. If every line has a non-zero line number, the program is treated as an old-style program with a line number on every line.\par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 BASIC Tokens}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 BASIC Tokens\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The following table shows the tokens used by GSoft\~BASIC. These tokens are mixed with line lengths, line numbers, and ASCII characters as described in }{\i\fs20 File Organization}{\fs20  and }{\i\fs20 Organization in Memory}{\fs20 , later in this appendix.\par The table shows the hexadecimal value for the token, the decimal value, and the ASCII characters printed by GSoft\~BASIC when the token is listed.\par Token $FF (255) is a special token used to extend the number of available tokens from 128 to 383. It is the first byte of a two byte token; the next byte completes the pair. The decimal values shown assume that you read the complete two-byte token from memory as an INTEGER.\par TOOL ($9F), LIBRARY ($A4) and GSOS ($90) start a three byte token sequence. For TOOL and LIBRARY, the byte immediately following this token is the tool number, and the third byte is the tool call number. For GSOS, the second byte is the least significant byte of the two-byte call number, and the last byte is the most significant byte of the two-byte call number.\par \par }\pard\plain \ri-5760\widctlpar\adjustright \f4\cgrid {\f6\fs18 \sect }\sectd \lndscpsxn\sbknone\linex0\cols2\endnhere\sectdefaultcl \pard\plain \ri-5760\widctlpar\adjustright \f4\cgrid {\f6\fs18 $80\tab 128\tab END\par $81\tab 129\tab FOR\par $82\tab 130\tab NEXT\par $83\tab 131\tab DATA\par $84\tab 132\tab INPUT\par $85\tab 133\tab CLNG\par $86\tab 134\tab DIM\par $87\tab 135\tab READ\par $88\tab 136\tab CSNG\par $89\tab 137\tab TEXT\par $8A\tab 138\tab PUT\par $8B\tab 139\tab SEEK\par $8C\tab 140\tab CALL\par $8D\tab 141\tab CDBL\par $8E\tab 142\tab CINT\par $8F\tab 143\tab CLOSE\par $90\tab 144\tab GSOS\par $91\tab 145\tab HGR\par $92\tab 146\tab HCOLOR=\par $93\tab 147\tab HPLOT\par $94\tab 148\tab CHDIR\par $95\tab 149\tab DIR$\par $96\tab 150\tab HTAB\par $97\tab 151\tab HOME\par $98\tab 152\tab MKDIR\par $99\tab 153\tab NAME\par $9A\tab 154\tab OPEN\par $9B\tab 155\tab BREAK\par $9C\tab 156\tab LINE\par $9D\tab 157\tab NORMAL\par $9E\tab 158\tab INVERSE\par $9F\tab 159\tab TOOL\par $A0\tab 160\tab RMDIR\par $A1\tab 161\tab POP\par $A2\tab 162\tab VTAB\par $A3\tab 163\tab SETMEM\par $A4\tab 164\tab LIBRARY\par $A5\tab 165\tab ONERR\par $A6\tab 166\tab RESUME\par $A7\tab 167\tab unused\par $A8\tab 168\tab unused\par $A9\tab 169\tab SPEED=\par $AA\tab 170\tab LET\par $AB\tab 171\tab GOTO\par $AC\tab 172\tab CURDIR$\par $AD\tab 173\tab IF\par $AE\tab 174\tab RESTORE\par $AF\tab 175\tab EOF\par $B0\tab 176\tab GOSUB\par $B1\tab 177\tab RETURN\par $B2\tab 178\tab REM\par $B3\tab 179\tab STOP\par $B4\tab 180\tab ON\par $B5\tab 181\tab WAIT\par $B6\tab 182\tab KILL\par $B7\tab 183\tab LOF\par $B8\tab 184\tab DEF\par $B9\tab 185\tab POKE\par $BA\tab 186\tab PRINT\par $BB\tab 187\tab CONT\par $BC\tab 188\tab LOC\par $BD\tab 189\tab CLEAR\par $BE\tab 190\tab GET\par $BF\tab 191\tab unused\par $C0\tab 192\tab TAB\par $C1\tab 193\tab TO\par $C2\tab 194\tab FN\par $C3\tab 195\tab SPC\par $C4\tab 196\tab THEN\par $C5\tab 197\tab TYPE\par $C6\tab 198\tab NOT\par $C7\tab 199\tab STEP\par $C8\tab 200\tab unused\par $C9\tab 201\tab TOOLERROR\par $CA\tab 202\tab LOADLIBRARY\par $CB\tab 203\tab UNLOADLIBRARY\par $CC\tab 204\tab SIZEOF\par $CD\tab 205\tab AND\par $CE\tab 206\tab OR\par $CF\tab 207\tab unused\par $D0\tab 208\tab unused\par $D1\tab 209\tab unused\par $D2\tab 210\tab SGN\par $D3\tab 211\tab INT\par $D4\tab 212\tab ABS\par $D5\tab 213\tab SUB\par $D6\tab 214\tab FRE\par $D7\tab 215\tab FUNCTION\par $D8\tab 216\tab POINTER\par $D9\tab 217\tab POS\par $DA\tab 218\tab SQR\par $DB\tab 219\tab RND\par $DC\tab 220\tab LOG\par $DD\tab 221\tab EXP\par $DE\tab 222\tab COS\par $DF\tab 223\tab SIN\par $E0\tab 224\tab TAN\par $E1\tab 225\tab ATN\par $E2\tab 226\tab PEEK\par $E3\tab 227\tab LEN\par $E4\tab 228\tab STR$\par $E5\tab 229\tab VAL\par $E6\tab 230\tab ASC\par $E7\tab 231\tab CHR$\par $E8\tab 232\tab LEFT$\par $E9\tab 233\tab RIGHT$\par $EA\tab 234\tab MID$\par $EB\tab 235\tab ERL\par $EC\tab 236\tab ERROR\par $ED\tab 237\tab ERR\par $EE\tab 238\tab CSRLIN\par $EF\tab 239\tab MOUSETEXT\par $F0\tab 240\tab WHILE\par $F1\tab 241\tab WEND\par $F2\tab 242\tab DO\par $F3\tab 243\tab LOOP\par $F4\tab 244\tab UNTIL\par $F5\tab 245\tab ELSE\par $F6\tab 246\tab SELECT\par $F7\tab 247\tab CASE\par $F8\tab 248\tab USING\par $F9\tab 249\tab AS\par $FA\tab 250\tab AT\par $FB\tab 251\tab NIL\par $FC\tab 252\tab ALLOCATE\par $FD\tab 253\tab DISPOSE\par $FE\tab 254\tab unused\par $FF\tab 255\tab first of multi-byte\par $FF01\tab 511\tab BYTE\par $FF02\tab 767\tab LONG\par $FF03\tab 1023\tab SINGLE\par $FF04\tab 1279\tab DOUBLE\par $FF05\tab 1535\tab STRING\par $FF06\tab 1791\tab INTEGER\par $FF07\tab 2047\tab OUTPUT\par $FF08\tab 2303\tab BINARY\par $FF09\tab 2559\tab APPEND\par $FF0A\tab 2815\tab RANDOM\par $FF0B\tab 3071\tab TCP \par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 \sect }\sectd \lndscpsxn\sbknone\linex0\endnhere\sectdefaultcl \pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\*\bkmkend bk40}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 tokens}{\rxe bk40}}}{\v\fs20 \par }\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\f4\fs28\cgrid {\fs24 Example of a Tokenized Program}{\pard\plain \s28\sb320\sa160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \adjustright \b\v\f4\cgrid {\tc {\v\fs24 Example of a Tokenized Program\tcl3}}}{\fs24 \par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Here\rquote s a short program, shown both in its text form and as a file dump that shows how it is represented in memory or on disk. The dump shows the offset within the file along the left side, followed by sixteen bytes per line in groups of four. The ASCII equivalents are shown to the right, where you can see that the numbers, operators and identifiers}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 identifiers}}}{\fs20  are represented as ASCII characters.\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18    10 FOR I = 1 TO 10\par    20   PRINT I\par    30 NEXT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 $000000   0C000A00 81493D31 C1313000 07001400   '     I=1 10     '\par $000010   BA490006 001E0082 000000              ' I         '\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par \sect }\sectd \lndscpsxn\sbkodd\linex0\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Appendix G: Quick Reference to the Shell\par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Appendix G \endash  Quick Reference to the Shell}{\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\v\f4\fs36\cgrid {\tc {\v Appendix G \endash  Quick Reference to the Shell\tcl1}}}{\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\v\f6\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 shell\:GSoft\~BASIC}}}{\fs20 BYE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Exits GSoft\~BASIC.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CAT [ pathname ]\par }\pard \s30\fi-360\li360\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20 CATALOG [ pathname ]\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Catalogs a directory.\par If no path name is given, the current directory is cataloged. If given, the path name can be a full or partial path name, the name of a volume, or the name of a device.\par The abbreviation CAT can be used instead of the full name of CATALOG.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 COPY from to\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Copies a file from one location to another.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CREATE pathname\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Creates a new directory.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 DEBUG [ linenumber | filename ]\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Runs a program, with the same options as the RUN command. The difference is that DEBUG enters an ORCA compatible debugger (like ORCA/Debugger or Splat!), breaking on the first line executed.\par }{\b\fs20 Do not use this command}{\fs20  unless an ORCA compatible debugger is installed! ORCA compatible debuggers work by intercepting the 65816}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 65816}}}{\fs20  COP instruction. There is no way for GSoft\~BASIC to tell if a debugger is installed or not, so it will issue the COP instruction whether or not a debugger is actually present. If there is no debugger installed, this causes the computer to crash. While this does no actual harm, the only way to recover is to reboot.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 DEL start [ ',' end ]\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Deletes a single line or a range of lines.\par The DEL command cannot be used with programs that do not use line numbers on every line.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 DELETE filename\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Deletes the named file.\par The file can be a directory. After checking to be sure the user really wants to delete the directory and its contents, all files in the directory and the directory itself are deleted.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 EDIT [ filename ]\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Enters an ORCA compatible editor, displaying the program in memory. If a file name is given, the file is loaded and edited exactly as if the commands\par \par }\pard\plain \s31\fi360\widctlpar\adjustright \f6\fs20\cgrid {\fs18 LOAD filename\par EDIT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \s25\sb40\widctlpar\adjustright {\fs20 were used.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 LIST [ line-number [ ',' [ line-number ] ] ]\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Lists the entire program, a single line, or a range of lines.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 LOAD filename\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Loads a program from disk.\par The program may be a GSoft\~BASIC tokenized file, a TXT file, or a BASIC SRC file. If the file is a TXT or SRC file, it is handled as if the NEW command was used, then each of the lines in the file was typed in turn.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 LOCK filename\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Locks a file. Locked files cannot be renamed, deleted, or written to.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 MOVE from to\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Moves a file from one location to another.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 NEW\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The program is deleted from the workspace.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 PR [ line-number [ ',' [ line-number ] ] ]\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Works like LIST, but sends the listing to a printer that is supported by the .PRINTER driver.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 PREFIX [ pathname ]\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Changes the default prefix (GS/OS prefix number 8) to the given path name.\par If no prefix is given, the current value for the prefix is shown.\par A path name consisting of two periods moves up one directory level.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 RENAME old new\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Renames a file.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 RENUMBER first ',' step [ ',' start [ ',' end ] ]\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Renumbers a program.\par \par }\pard \s25\fi360\sb40\widctlpar\tx1440\adjustright {\f6\fs20 first}{\fs20 \tab First line number to use.\par }\pard \s25\fi360\widctlpar\tx1440\adjustright {\f6\fs20 step}{\fs20 \tab Increment between new line numbers.\par }{\f6\fs20 start}{\fs20 \tab First line to renumber.\par }{\f6\fs20 end}{\fs20 \tab Last line to renumber.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 RUN [ line-number | filename ]\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Runs a program.\par If a number is supplied as a parameter, program execution starts at that line.\par If a file name is supplied as a parameter, the file is loaded and executed. The file may be a GSoft\~BASIC tokenized file, a TXT file, or a BASIC SRC file. If the file is a TXT or SRC file, it is handled as if the NEW command was used, then each of the lines in the file was typed in turn.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SAVE filename\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Saves a program to disk.\par The file is saved as a GSoft\~BASIC tokenized file.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SSAVE filename\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Saves a program to disk.\par The file is saved as an ORCA\~BASIC source file.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 TSAVE filename\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Saves a program to disk.\par The file is saved as a text file.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 UNLOCK filename\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Unlocks a file locked with the LOCK command. Locked files cannot be renamed, deleted, or written to.\par \sect }\sectd \lndscpsxn\sbkodd\linex0\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Appendix H: Quick Reference to GSoft\~BASIC\par }}\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\f4\fs36\cgrid {Appendix H \endash  Quick Reference to GSoft\~BASIC}{\pard\plain \s26\sb40\sa600\widctlpar\adjustright \b\v\f4\fs36\cgrid {\tc {\v Appendix H \endash  Quick Reference to GSoft\~BASIC\tcl1}}}{\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Statements}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Statements\tcl2}}}{\fs28 \par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 ! any-ascii-characters\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The ! statement starts a comment. All characters from the ! character to the end of the line are ignored.\par See also REM.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 ALLOCATE '(' l-value [ ',' expression ] ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Allocates memory from the computer\rquote s memory. }{\f6\fs20 l-value }{\fs20 is set to a pointer to the allocated memory. }{\f6\fs20 expression}{\fs20  is the number of bytes of memory to reserve. If }{\f6\fs20 expression}{\fs20  is not used, enough memory is reserved for one value of the type l-value.\par See also DISPOSE, SIZEOF.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 BREAK\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Enters an ORCA compatible high level language source-level debugger, breaking on the current line.\par }{\b\fs20 Do not use this command}{\fs20  unless an ORCA compatible debugger is installed! ORCA compatible debuggers work by intercepting the 65816}{\pard\plain \s25\fi360\sb40\widctlpar\adjustright \v\f4\fs20\cgrid {\xe {\v\fs20 }{\v\fs20 65816}}}{\fs20  COP instruction. There is no way for GSoft\~BASIC to tell if a debugger is installed or not, so it will issue the COP instruction whether or not a debugger is actually present. If there is no debugger installed, this causes the computer to crash. While this does no actual harm, the only way to recover is to reboot.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CALL identifier [ parameter-list ]\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Calls a subroutine defined by a SUB statement or a tool defined in a tool interface file. See SUB for details.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CASE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 See SELECT.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CLEAR\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Erases all types, variables and strings. Variables are removed whether they were created with the DIM statement or by being used without encountering a DIM statement.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CHDIR pathname\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Changes the default prefix to }{\f6\fs20 pathname}{\fs20 .\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CLOSE [ '#' expression ]\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Closes a file.\par If a file number is used, CLOSE closes the specific file specified by the expression. If no file number is used, CLOSE closes all files that have been opened by OPEN.\par See also OPEN.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CONT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Continues execution after a STOP or END command.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 DATA any-ascii-characters\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Creates DATA for READ statements. More than one piece of data can be created with a single DATA statement by separating the data with commas.\par See also READ, RESTORE.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 DEF FN identifier '(' identifier [ ',' identifier ]* ')' '=' expression\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Creates a local function.\par Parameters and the value returned by the function can be any numeric or string type. Types are assigned using trailing type characters, as in }{\f6\fs20 A$}{\fs20  for a string.\par When the function is called using a FN term in an expression, each parameter in the call is evaluated and assigned to the corresponding parameter variable. The expression is then evaluated. The expression must result in a value that is type compatible with the function name. The expression can use constants, parameter variables, other variables that do not have the same name as a parameter, and other functions.\par Functions created with DEF FN are local to the main program or procedure in which they are created.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 DIM identifier [ subscript ] [ AS type ] [ ',' identifier [ subscript ] [ AS type ] ]*\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Creates a variable. The variable can be an array or a single value. For arrays, a subscript is given. The result of each expression is converted to an integer and used as the maximum subscript value for the array. The minimum subscript value is always 0.\par If no type is given, the last character of the name determines the variable type. Types assigned with the }{\f6\fs20 AS}{\fs20  clause may be used with arrays or single values.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 DISPOSE '(' l-value ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Disposes of memory previously allocated with ALLOCATE.\par It is an error to dispose of memory using a pointer that was not assigned by ALLOCATE or to dispose of the same memory twice. BASIC cannot catch this error. An error of this type may eventually lead to corrupted memory or a crash.\par See also ALLOCATE.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 DO [ WHILE expression | UNTIL expression ]\par }\pard \s30\fi-360\li360\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20 LOOP [ WHILE expression | UNTIL expression ]\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The DO and LOOP commands form a loop, executing all statements between them until certain conditions are met. Conditions can be used on either or both the DO and LOOP clause, or on neither one.\par Execution begins at the DO statement. If the statement is a DO WHILE statement, the expression is evaluated, and if it is true (any non-zero numeric value is treated as true) the statements between DO and LOOP are executed. If the condition is false (zero is treated as false) execution continues with the first statement after the LOOP statement.\par If the DO statement is a DO UNTIL statement, the expression is evaluated, but this time the statements between DO and LOOP are evaluated if the expression is false. If the expression is true, execution skips to the first statement after the LOOP statement.\par If the LOOP statement is eventually executed, and there is no condition, execution jumps back to the DO statement.\par If the LOOP statement is a LOOP WHILE, the expression is evaluated. If it is true, execution jumps back to the DO statement. If it is false, execution continues with the statement after the LOOP statement.\par If the LOOP statement is a LOOP UNTIL, the expression is evaluated. If it is false, execution jumps back to the DO statement. If it is true, execution continues with the statement after the LOOP statement.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 ELSE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 See }{\f6\fs20 IF}{\fs20 .\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 END\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Stops execution of a program.\par See also IF, SELECT CASE, FUNCTION, SUB, TYPE.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 ERROR expression\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Behaves exactly as if a run-time error occurred. The expression designates the error number, which can be read using the ERR function.\par For a list of error messages by number, see the full documentation for the ERROR command.\par See also ERR, ERL.\par }\pard\plain \s30\fi-360\li360\sb320\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 FOR identifier '=' expression TO expression [ STEP expression ]\par }\pard \s30\fi-360\li360\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20 NEXT [ identifier ] [ ',' identifier ]*\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The FOR-NEXT loop executes a series of statements a specific number of times.\par The expressions are evaluated. The first expression is assigned to the control variable, which is the identifier immediately after FOR. It must be a single numeric value; arrays, record fields and pointers are not allowed. The remaining expressions are evaluated once and the results stored. The statements between the FOR and NEXT statements are then executed.\par When the NEXT statement is encountered, the value after STEP (or 1 if STEP is not used) is added to the loop control variable. If the step value is positive, and the control value is less than or equal to the value of the expression after TO, execution loops to the statement after the FOR statement; otherwise, execution continues with the statement after NEXT. If the step value is negative and the control value is greater than or equal to the expression after TO, execution loops to the statement after the FOR statement; otherwise, execution continues with the statement after NEXT.\par The NEXT statement can be used to end more than one FOR statement. In this case, a comma is used. Generally the loop control variables are listed, but this is not required.\par }\pard\plain \s30\fi-360\li360\sb320\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 FUNCTION identifier [ parameter-definition-list ] [ AS type ]\par }\pard \s30\fi-360\li360\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20 [ statement ]*\par }\pard \s30\fi-360\li360\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20 END FUNCTION\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Defines a function. \par The identifier is the name of the function, used when it is called. This is followed by the parameter list, if any, and the type returned by the function. The statements that appear between the FUNCTION statement and the END FUNCTION statement are executed as if they were a program, then the last value set for the function is returned to the caller.\par The parameter list consists of one or more parameter declarations separated by commas. Each parameter declaration is a variable, optionally followed by AS and a type. If no type is given explicitly, the type is derived from the name of the variable. For example, I% would be an integer.\par Arrays, records, pointers, strings and all numeric types are allowed as parameters. Pointers, strings and numeric types are allowed as return values. While records and arrays cannot be returned directly, you can return pointers to either type\emdash but insure that the value is dynamically allocated, and not a local variable!\par Inside the function, all parameters work as if they were variables preset to the value passed when the function is called. If the function is called with the name of a variable whose type exactly matches the parameter, and the value is changed inside the function, the value of the original variable is also changed. If the types do not match exactly, or if the function is called with an expression, or if the variable passed is surrounded by parentheses, the original value is not changed.\par Variables declared inside the function survive until the function returns, but no longer. If the function is called again, an entirely new set of variables is allocated. Variables from outside the function cannot be accessed from inside, except for parameters, as noted above. Types defined in the main program are, however, available in the function as well as the program.\par The value returned by the function is set by assigning a value to the function name. This can be done more than one time; the last value set is the one returned. If no value is set, 0 is returned for numeric functions, a null string for strings, and a null pointer for pointers.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 GET [ '#' expression ',' [ expression ] ',' ] l-value\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Reads a single value from the keyboard or a disk file.\par If no file is specified, the variable must be a string. A single character is read from the keyboard, converted to a string, and saved in the variable. If no characters have been typed, GET waits for a key before returning.\par If a file is given, GET reads binary information from the file. While strings are still treated as single characters, any other data type can be read, including integers, real numbers, records or pointers.\par See also PUT, INPUT.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 GOSUB line-number\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Control jumps to the first line whose number matches }{\f6\fs20 line-number}{\fs20 . }{\f6\fs20 line-number}{\fs20  must be an integer constant. When a RETURN statement is encountered, control jumps to the statement after GOSUB.\par Subroutines can be nested up to 24 levels deep.\par If GOSUB is used in a procedure, the destination line must be in the same procedure.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 GOTO line-number\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Control jumps to the first line whose number matches }{\f6\fs20 line-number}{\fs20 . }{\f6\fs20 line-number}{\fs20  must be an integer constant.\par If GOTO is used in a procedure, the destination line must be in the same procedure.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 HCOLOR= expression\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Sets the pen color to one of the 16 colors used on the 320 mode graphics screen. Unless they have been deliberate changed with QuickDraw II calls, the colors are:\par \par }\pard\plain \s32\li360\ri2880\sb160\keepn\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \tx1800\tx3240\adjustright \f4\cgrid {\fs20 Number\tab Applesoft Color\tab GSoft\~BASIC Color\par }\pard\plain \s25\li360\ri2880\sb40\keepn\widctlpar\tx1800\tx3240\adjustright \f4\cgrid {\fs20 0\tab black\tab black\par 1\tab green\tab green\par 2\tab violet\tab purple\par 3\tab white\tab white\par 4\tab black\tab dark gray\par 5\tab orange\tab orange\par 6\tab blue\tab blue\par 7\tab white\tab red\par 8\tab \tab beige\par 9\tab \tab yellow\par 10\tab \tab brown\par 11\tab \tab light blue\par 12\tab \tab lilac\par 13\tab \tab Periwinkle blue\par 14\tab \tab light gray\par }\pard \s25\li360\ri2880\sb40\widctlpar\tx1800\tx3240\adjustright {\fs20 15\tab \tab dark green\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 HGR\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Starts QuickDraw in 320 graphics mode (if it has not already been started), switches the display to the graphics screen, clears the screen to black, and sets the pen color to white.\par See HPLOT, HCOLOR=, and TEXT.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 HOME\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Clears the text screen and places the cursor at the top left of the screen.\par See also HTAB, VTAB.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 HPLOT [ expression ',' expression ] [ TO expression ',' expression ]*\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 If the initial location is given, the pen is moved to that location and a single point is drawn. If one or more TO clauses follow, lines are drawn from the previous point to the location after TO.\par See HGR and HCOLOR=. \par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 HTAB expression\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Sets the horizontal cursor position on the text screen. This changes the location of the flashing input cursor and the location where the next characters will be written on the text screen.\par Columns are numbered from 1 at the left of the screen to 80 at the right. Numbers outside this range are legal, and are converted to the closest existing screen column.\par The vertical position is not changed.\par See also CSRLIN, HOME, POS, VTAB.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 IF expression THEN statement\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The expression is evaluated. If the result is not zero, the statement following THEN is executed. If the result of the expression is zero, the statement is not executed.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 IF expression GOTO line-number\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The expression is evaluated. If the result is not zero, the GOTO is executed, causing processing to skip to the specified line. If the result of the expression is zero, processing continues with the statement following the if statement.\par }{\f6\fs20 line-number}{\fs20  must be an integer constant.\par }\pard\plain \s30\fi-360\li360\sb320\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 IF expression THEN\par }\pard \s30\fi-360\li360\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20 [ ELSE IF expression ]*\par [ ELSE ]\par }\pard \s30\fi-360\li360\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20 END IF\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The expression following }{\f6\fs20 IF}{\fs20  is evaluated. If the result is not zero, lines between this statement and the first }{\f6\fs20 ELSE}{\fs20  are executed, and all others are skipped. If the result is zero, expressions in subsequent }{\f6\fs20 ELSE IF}{\fs20  statements are evaluated, in turn, until one of them results in a non-zero value. When a non-zero expression result is found, the statements from that expression to the following }{\f6\fs20 ELSE}{\fs20  or }{\f6\fs20 ELSE IF}{\fs20  are executed, and all others are skipped.\par If no expressions evaluate to non-zero, and there is an }{\f6\fs20 ELSE}{\fs20  clause, the statements between }{\f6\fs20 ELSE}{\fs20  and }{\f6\fs20 END IF}{\fs20  are executed. If there is no }{\f6\fs20 ELSE}{\fs20  clause, no statements are executed.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 INPUT [ '#' expression ',' ] [ string-expression ';' ] l-value [ ',' l-value ]*\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Reads a comma delimited value from the keyboard or a disk file.\par If }{\f6\fs20 string-expression}{\fs20  appears, it is used as a prompt string. It is written to standard output without a carriage return, then the input is read. If no prompt string is given and input is from the keyboard, a ? character is written as a default prompt string.\par One or more values can be read with a single INPUT statement by separating the variables with commas. These values can be any number type or a string.\par Multiple input values are separated by carriage returns or commas. Any spaces appearing between input values are ignored.\par See also LINE INPUT.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 INVERSE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Subsequent characters are printed using the inverse character set.\par See also MOUSETEXT, NORMAL.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 KILL filename\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Deletes the file or directory }{\f6\fs20 filename}{\fs20 .\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 [ LET ] l-value '=' expression\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The expression is evaluated, and the result stored in the location indicated by }{\f6\fs20 l-value}{\fs20 .\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 LINE INPUT [ '#' expression ',' ] [ string-expression ';' ] l-value [ ',' l-value ]*\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Works almost exactly like INPUT. The exception is how the two handle commas. LINE INPUT ignores them, reading all characters up to the end of a line.\par See also INPUT.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 LOADLIBRARY expression\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Loads a user tool from disk.\par }{\f6\fs20 expression}{\fs20  is the tool number to load. GSoft\~BASIC looks for a file with the name UserToolXXX, where XXX is the tool number. It looks first in the local directory, which defaults to the location of the GSoft\~BASIC interpreter. The local directory can be changed before using LOADLIBRARY using the CHDIR command. If the tool is not found in the local directory, GSoft\~BASIC looks in the System directory at the path *:System:Tools:UserToolXXX.\par See also UNLOADLIBRARY.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 LOOP\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 See DO.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 MKDIR pathname\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Creates a new directory with the name }{\f6\fs20 pathname}{\fs20 .\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 MOUSETEXT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Subsequent characters are printed using the mouse text character set.\par See also INVERSE, NORMAL.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 NAME filename AS filename\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Renames the file, directory or disk. The first file name is the original file name, and the second is the new file name.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 NEXT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 See }{\f6\fs20 FOR}{\fs20 .\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 NORMAL\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Subsequent characters are printed using the normal character set.\par See also INVERSE, MOUSETEXT.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 ON expression GOTO line-number [ ',' line-number ]*\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The expression is evaluated and truncated to an integer. Numbering from one, the corresponding line number is selected from the list of line numbers, and execution jumps to that line.\par If there is no corresponding line number, execution continues with the statement after the ON-GOTO statement.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 ON expression GOSUB line-number [ ',' line-number ]*\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The expression is evaluated and truncated to an integer. Numbering from one, the corresponding line number is selected from the list of line numbers, and execution jumps to that line. Execution returns to the line after the ON-GOSUB statement when a RETURN statement is executed in the subroutine.\par If there is no corresponding line number, execution continues with the statement after the ON-GOSUB statement.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 ONERR GOTO line-number\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 This statement has no immediate effect. If, later in the program, an error is encountered, execution jumps to the line }{\f6\fs20 line-number}{\fs20 . From there, you can use ERR and ERL to identify the type and location of the error.\par The destination line must appear in the main program, not in a subroutine or function.\par See also ERR, ERL, RESUME.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 OPEN filename FOR io-kind AS '#' expression [ LEN expression ]\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Opens the file }{\f6\fs20 filename}{\fs20 .\par The file may be opened in any of the following ways by substituting the token shown for the }{\f6\fs20 io-kind}{\fs20  field.\par \par }\pard \s25\fi-1080\li1440\ri360\sb40\widctlpar\brdrt\brdrs\brdrw15\brsp40 \brdrb\brdrs\brdrw15\brsp40 \adjustright {\fs20 I/O kind\tab use\par }\pard \s25\fi-1080\li1440\ri360\sb40\widctlpar\adjustright {\f6\fs20 OUTPUT}{\fs20 \tab The file is opened for output. If the file already exists, any old contents are lost.\par }{\f6\fs20 INPUT}{\fs20 \tab The file is opened for input. The file must already exist, but the file type does not matter. Input starts from the beginning of the file.\par }{\f6\fs20 APPEND}{\fs20 \tab The file is opened for output. If the file already exists, the old contents are not lost. New information is written after all of the old information.\par }{\f6\fs20 RANDOM}{\fs20 \tab The file is opened for random access. The LEN field is required; each record written to or read from the file will use that number of bytes.\par }{\f6\fs20 BINARY}{\fs20 \tab The file is opened for input and output.\par \par }\pard \s25\fi360\sb40\widctlpar\adjustright {\fs20 The value following }{\f6\fs20 #}{\fs20  is used in subsequent file commands to identify the opened file. This value can range from 1 to 32767. No two open files may use the same file number, but once the file is closed, the number is available for use by another OPEN statement.\par If used, the }{\f6\fs20 LEN}{\fs20  expression gives the internal buffer size used to cache input and output. This field is required for random access files, and matches the length of one random access record. For all other file types, larger values use more RAM but generally result in faster disk input and output, while lower values save RAM but result in slower input and output.\par See also CLOSE, GET, EOF, LOC, LOF, PRINT, PRINT USING, PUT, SEEK.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 POKE expression ',' expression\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The value of the second expression is converted to an integer. The least significant 8 bits are stored in the memory location specified by the first expression.\par See also PEEK, WAIT.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 POP\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Removes one GOSUB return address from the stack. In effect, this turns the most recent GOSUB into a GOTO.\par }\pard\plain \s30\fi-360\li360\sb320\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 PRINT [ '#' expression ]\par }\pard \s30\fi-360\li360\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20       [ expression\par         | SPC '(' expression ')'\par         | TAB '(' expression ')'\par         | ';'\par }\pard \s30\fi-360\li360\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20         | ',' ]*\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The various expressions are evaluated and printed in standard form. See PRINT on page 163 for a complete description of the formats used to print various kinds of information.\par Output is normally printed to the text screen. Using # followed by a number sends the output to a file, instead.\par SPC is a special function that prints spaces. The expression is evaluated and the specified number of spaces are printed.\par TAB is a special function that prints spaces until the tab column is reached. For example, if the expression evaluates to 10, spaces are inserted until column 10 is reached, forcing the next character printed to show up in column 10. Columns number from 1.\par The semicolon character is used to separate multiple expressions without printing characters between them. If used at the end of the line, a new line is not started before the next PRINT statement begins to print.\par The comma character is used to separate expressions and provide easy column alignment. Spaces are inserted until a space is printed in a column divisible by 16.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 PRINT [ '#' expression ] USING format-string ';' expression [ ( ',' | ';' ) expression ]* ( ',' | ';' )\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The format string is printed. Whenever a character that starts a format model is encountered in the format string, one expression from the list that follows the format string is evaluated. The result is rounded, truncated, or converted to fit in the space provided by the format model and printed.\par See the PRINT USING on page 169 for a complete description of format models.\par Output is normally printed to the text screen. Using # followed by a number sends the output to a file, instead.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 PUT '#' expression ',' [ expression ] ',' l-value\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Writes values to files. It is usually used for binary or random access files, although technically it can be used with any file type.\par The first expression is the file number, assigned when the file is opened with OPEN.\par The next expression is the location in the file to write the value. For random access files, this is the record number; for all other files, this is a byte number. In both cases, the first value in the file is numbered 1.\par }{\f6\fs20 l-value}{\fs20  is the value to write to the file.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 READ l-value [ ',' l-value ]*\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Reads one or more values from a DATA statement. The READ and DATA statements must appear in the same subroutine or must both be in the main program.\par See also DATA, RESTORE.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 REM any-ascii-characters\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The REM statement starts a comment. All characters following the command up to the end of the line are ignored\par See also !.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 RESTORE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Restores the DATA counter, so the next READ statement reads from the first DATA statement in the current subroutine.\par See also DATA, READ.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 RESUME\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 RESUME is used in ONERR-GOTO handlers to return to the line where the error occurred. It returns to the start of the offending line.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 RETURN\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns from the most recent GOSUB, transferring control to the statement following the GOSUB statement.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 RMDIR filename\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Deletes the file or directory }{\f6\fs20 filename}{\fs20 .\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SEEK '#' expression ',' expression\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Sets the file so the next read or write occurs at the position indicated by the second expression.\par For random access files, the file is divided into chunks based on the length specified when the file is opened. For all other file types, the file is divided into bytes. In each case, the first chunk is numbered 1, with the remaining chunks numbered sequentially.\par }\pard\plain \s30\fi-360\li360\sb320\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SELECT CASE expression\par }\pard \s30\fi-360\li360\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20 [ CASE case-range [ ',' case-range ]* ]*\par [ CASE ELSE ]\par }\pard \s30\fi-360\li360\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20 END SELECT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The expression in the SELECT CASE statement is evaluated. Expressions in the subsequent CASE statements are examined; when an expression is found that matches the original, all statements between the matching CASE statement and the following CASE or END SELECT are executed.\par Multiple expressions can be used on a single CASE statement, making it easy to use the same code for several different values. You can also specify a range of values by separating the lowest allowed value and highest allowed value with TO. Unlike many languages, expressions are not limited to scalar quantities; real numbers and strings are allowed as CASE values.\par If no matching expression is found, and a CASE ELSE statement is used, statements between the CASE ELSE and END SELECT are executed. If no matching expression is found and no CASE ELSE is used, execution continues with the statement following END SELECT.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SETMEM '(' expression ',' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Sets the size of a memory buffer. The first expression is the memory buffer to set; this is 0 for the variable buffer and 1 for the program buffer. The second expression is the new size for the buffer in bytes.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 STOP\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Stops execution of the program. If line numbers are used, the line number is printed.\par You can stop a program at a problem point and examine or even change variables, then resume execution with the command CONT.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SPEED expression\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Sets the output speed for characters written to the screen.\par A speed of 255 writes characters as rapidly as possible; this is the default. A value of 0 introduces a long delay after each character is written. Intermediate values cause progressively longer or shorter delays.\par }\pard\plain \s30\fi-360\li360\sb320\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SUB identifier [ parameter-definition-list ]\par }\pard \s30\fi-360\li360\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20 [ statement ]*\par }\pard \s30\fi-360\li360\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20 END SUB\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Defines a subroutine. \par The first identifier is the name of the subroutine, used when it is called. This is followed by the parameter list, if any. The statements that appear between the SUB statement and the END SUB statement are executed as if they were a program.\par The parameter list consists of one or more parameter declarations separated by commas. Each parameter declaration is a variable, optionally followed by AS and a type. If no type is given explicitly, the type is derived from the name of the variable. For example, I% would be an integer.\par Arrays, records, pointers, strings and all numeric types are allowed as parameters.\par Inside the subroutine, all parameters work as if they were variables preset to the value passed when the subroutine is called. If the subroutine is called with the name of a variable whose type exactly matches the parameter, and the value is changed inside the function, the value of the original variable is also changed. If the types do not match exactly, or if the subroutine is called with an expression, or if the variable passed is surrounded by parentheses, the original value is not changed.\par Variables declared inside the subroutine survive until the subroutine returns, but no longer. If the subroutine is called again, an entirely new set of variables is allocated. Variables from outside the subroutine cannot be accessed from inside, except for parameters, as noted above. Types defined in the main program are, however, available in the subroutine as well as the program.\par Subroutines are called with the CALL statement.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 TEXT\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 If the graphics screen is visible, the display is shifted back to the text screen. If the text screen is visible, nothing is changed.\par }\pard\plain \s30\fi-360\li360\sb320\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 TYPE identifier\par }\pard \s30\fi-360\li360\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20   [ ( field-name [ AS type ] )\par     | ( CASE [ expression ] ) ]+\par }\pard \s30\fi-360\li360\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20 END TYPE\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Creates a new type with the name }{\f6\fs20 identifier}{\fs20 . This type is a record, containing one or more fields. Each field has a distinct type, and the fields may have differing types.\par Each field appears on a separate line. }{\f6\fs20 field-name}{\fs20  is the name of the field, while }{\f6\fs20 type}{\fs20  is the type for the field. If the type is not specified, the type is taken from the type character appearing at the end of the identifier, just as the type is derived for a variable. For example, I% is an integer field, while R is a single-precision real number field.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 TYPE identifier AS type\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Creates a new type with the name }{\f6\fs20 identifier}{\fs20 .\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 UNLOADLIBRARY expression\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Unloads the specified user tool, freeing the RAM used by the tool.\par See also LOADLIBRARY.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 VTAB expression\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Sets the vertical cursor position on the text screen. This changes the location of the flashing input cursor and the location where the next characters will be written on the text screen.\par Lines are numbered from 1 at the top of the screen to 24 at the bottom. Numbers outside this range are legal, and are converted to the closest existing screen line.\par The horizontal position is not changed.\par See also CSRLIN, HOME, HTAB, POS.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 WAIT expression ',' expression\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 A logical and is performed between the byte at the memory address specified by the first expression and the value specified by the second expression. If the result is not zero, execution continues with the next statement. If the result is zero, the process repeats.\par See also PEEK, POKE.\par }\pard\plain \s30\fi-360\li360\sb320\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 WHILE expression\par }\pard \s30\fi-360\li360\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright {\fs20 WEND\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 The expression is evaluated. If it is not zero, the statements between WHILE and WEND are executed, and the process repeats. If the expression evaluates to zero, execution continues with the statement after WEND.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 Functions}{\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\v\f4\fs28\cgrid {\tc {\v\fs28 Functions\tcl2}}}{\fs28 \par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 ABS '(' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns the absolute value of }{\f6\fs20 expression}{\fs20 .\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 ASC '(' string-expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns the ASCII numeric value for the first character in }{\f6\fs20 string-expression}{\fs20 . ASC returns 0 if there are no characters in }{\f6\fs20 string-expression}{\fs20 .\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 ATN '(' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns the arc-tangent of }{\f6\fs20 expression}{\fs20 .\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CDBL '(' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Converts }{\f6\fs20 expression}{\fs20  to a double precision floating-point value.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CHR$ '(' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns a string consisting of a single character whose ASCII value is }{\f6\fs20 expression}{\fs20 .\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CINT '(' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Converts }{\f6\fs20 expression}{\fs20  to an integer value.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CLNG '(' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Converts }{\f6\fs20 expression}{\fs20  to a long integer value.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 COS '(' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns the cosine of }{\f6\fs20 expression}{\fs20 .\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CSNG '(' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Converts }{\f6\fs20 expression}{\fs20  to a single precision floating-point value.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CSRLIN\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns the line number where the next character will be printed. Lines are numbered from 1 to 24.\par See also HTAB, POS, VTAB.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 CURDIR$\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns the name of the current directory.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 DIR$ [ '(' file-name ')' ]\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns file names from a directory.\par The first call should specify a parameter. This can be the name of a specific file or the wildcard character \ldblquote *\rdblquote . Full or partial path names may be used. DIR$ will return the name of the file if there is a file by the given name, or the name of the first file in the directory if the wildcard character is used.\par If the wildcard character is used, subsequent calls may be made without a parameter. These calls return the names of the remaining files in the directory. When all files have been returned, DIR$ returns an empty string.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 EOF '(' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns 0 if there is unread information in a file, and -1 if there is not.\par See also GET, LOC, LOF, OPEN, SEEK.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 ERL\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Used in an ONERR-GOTO handler, ERL returns the line number of the line where the error occurred. If the line where the error occurred does not have a number, ERL returns 0.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 ERR\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Used in an ONERR-GOTO handler, ERR returns an error number indicating the type of the error.\par See Appendix\~A for a list of the error numbers and their meanings.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 EXP '(' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns the exponent of }{\f6\fs20 expression}{\fs20 .\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 FRE '(' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Forces garbage collection on the string space, then returns the number of bytes remaining for variables, subroutine stacks, and strings.\par The expression value should be 0, but is actually ignored.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 INT '(' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns the integer part of a number.\par Unlike CINT, INT does not convert the result to an integer. Instead, the type of the result matches the type of the argument. For integer and long arguments, the expression result is returned unchanged. For single and double precision real numbers, the value returned is the largest integer that is less than or equal to the value of the expression.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 LEFT$ '(' string-expression ',' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns }{\f6\fs20 expression}{\fs20  characters from the beginning of a string. If the length of the string is less than }{\f6\fs20 expression}{\fs20 , the entire string is returned.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 LEN '(' string-expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns the number of characters in }{\f6\fs20 string-expression}{\fs20 .\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 LOC '(' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns the number of records or bytes that have been read from or written to a file so far. At the beginning of a file, LOC returns 0.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 LOF '(' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns the number of records or bytes in a file.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 LOG '(' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns the natural logarithm of }{\f6\fs20 expression}{\fs20 .\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 MID$ '(' string-expression ',' expression ',' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns characters from any position in a string. The first expression is the index of the first character to return, numbering from 1. The second expression is the number of characters to return.\par If there are not enough characters, all available characters are returned. If the character index is larger than the length of the string, a string with no characters is returned.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 NIL\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns a pointer value that is type compatible with all pointers, and that indicates a pointer which is not pointing to any memory location.\par All pointers are initially set to NIL.\par The ordinal value for NIL is 0.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 PEEK '(' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns the value of the byte located at the address }{\f6\fs20 expression}{\fs20 .\par See also POKE, WAIT.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 POS '(' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns the column where the next character will be printed. Columns are numbered starting from 1.\par See also CSRLIN, HTAB, VTAB.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 RIGHT$ '(' string-expression ',' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns }{\f6\fs20 expression}{\fs20  characters from the end of a string. If the length of the string is less than }{\f6\fs20 expression}{\fs20 , the entire string is returned.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 RND '(' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns a random single precision number that is greater than or equal to 0.0 and less than 1.0.\par If }{\f6\fs20 expression}{\fs20  is a negative number, RND resets the random number generator seed using the argument as a seed value.\par If }{\f6\fs20 expression}{\fs20  is zero, RND returns the same value it returned on the previous call.\par If }{\f6\fs20 expression}{\fs20  is a positive number, a pseudo-random number is returned.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SGN '(' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns -1 if }{\f6\fs20 expression}{\fs20  is negative, 0 if }{\f6\fs20 expression}{\fs20  is zero, and 1 if }{\f6\fs20 expression}{\fs20  is positive.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SIN '(' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns the sine of }{\f6\fs20 expression}{\fs20 .\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SIZEOF '(' ( type | identifier ) ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns the size required to store one value of a given type, or the size used by the variable }{\f6\fs20 identifier}{\fs20 . The size is given in bytes.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 SQR '(' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns the square root of }{\f6\fs20 expression}{\fs20 .\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 STR$ '(' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Converts a numeric value to a string using the same formatting rules as the PRINT statement.\par See also VAL.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 TAN '(' expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns the tangent of }{\f6\fs20 expression}{\fs20 .\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 TOOLERROR\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns the error code from the most recent tool, user tool or GS/OS call. A value of zero indicates there was no error.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 VAL '(' string-expression ')'\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Converts a string that represents a number into a value using the same rules as READ and INPUT.\par See also STR$.\par }\pard\plain \s30\fi-360\li360\sb320\sa80\keepn\widctlpar\brdrt\brdrs\brdrw5\brsp40 \adjustright \b\f6\cgrid {\fs20 VERSION\par }\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\fs20 Returns the GSoft\~BASIC version number encoded as a long integer. The format is VVMMBBTRR, where\par \par }\pard \s25\fi-540\li900\sb40\widctlpar\adjustright {\fs20 VV\tab Major release number.\par MM\tab Minor release number.\par BB\tab Bug fix release number.\par T\tab Release type; 0 for commercial, 1 for development, 2 for alpha and 3 for beta.\par RR\tab Release number for the current type.\par }\pard\plain \s27\sb400\sa200\keepn\widctlpar\brdrt\brdrs\brdrw30\brsp40 \adjustright \b\f4\fs36\cgrid {\fs28 BNF Used in This Appendix\par }\pard\plain \s30\fi-360\li360\sa80\keepn\widctlpar\adjustright \b\f6\cgrid {\fs20 add-expression ::= mul-expression [ addop mul-expression ]*\par addop ::= '+' | '-'\par and-expression ::= relational-expression [ AND relational-expression ]*\par array-subscript ::= '(' expression [ ',' expression ]* ')'\par case-range ::= expression [ TO expression ]\par digit ::= '0'..'9'\par exp-expression ::= term [ '^' term ]*\par exponent-char ::= 'e' | 'E' | 'd' | 'D'\par expression ::= and-expression [ OR and-expression ]*\par field-name ::= identifier\par filename ::= string-constant\par format-string ::= string-constant\par }\pard \s30\fi-360\li360\sa80\widctlpar\adjustright {\fs20 function-name ::= identifier\par hexadecimal-constant ::= '$' [ '0'..'9' | 'a'..'f' | 'A'..'F' ]+\par identifier ::= letter [ letter | digit ] type-character\par }\pard \s30\fi-360\li360\sa80\keepn\widctlpar\adjustright {\fs20 integer-constant ::= [ '0'..'9' ]+\par io-kind ::= OUTPUT | INPUT | APPEND | RANDOM | BINARY\par l-value ::= identifier [ array-subscript | '^' [ l-value ] | '.' l-value | '^' '.' l-value ]\par letter ::= 'A'..'Z' | 'a'..'z'\par line-number ::= integer-constant\par mul-expression ::= exp-expression [ mulop exp-expression ]*\par mulop ::= '*' | '/'\par parameter-definition ::= identifier [ AS type ] [ '(' ')' ]\par parameter-definition-list ::= [ '(' parameter-definition [ ',' parameter-definition ]* ')' ]\par parameter ::= '(' expression ')' | expression\par parameter-list ::= [ '(' parameter [ ',' parameter ]* ')' ]\par pathname ::= string-constant\par pointer-name ::= identifier\par read-constant ::= [ integer-constant ] [ '.' [ integer-constant ] ] [ exponent-char [ addop ] integer-constant ]\par record-name ::= identifier\par relational-expression ::= add-expression [ relop add-expression ]*\par relop ::= '=' | '<' | '>' | '<=' | '=<' | '>=' | '=>' | '<>' | '><'\par subscript ::= '(' expression [ ',' expression ]* ')'\par statement ::= \{any statement from those listen in this appendix\}\par string-constant ::= '"' \{any characters except "\} '"'\par }\pard \s30\fi-360\li360\sa80\widctlpar\adjustright {\fs20 string-expression ::= expression\par }\pard \s30\fi-360\li360\keepn\widctlpar\adjustright {\fs20 term ::= addop term\par \tab | '@' l-value\par \tab | NOT term\par \tab | real-constant\par \tab | integer-constant\par \tab | hexadecimal-constant\par \tab | string-constant\par \tab | identifier array-subscript\par \tab | record-name '.' l-value\par \tab | pointer-name '^'\par \tab | pointer-name '^' '.' l-value\par \tab | type-name '(' expression ')'\par \tab | function-name parameter-list\par }\pard \s30\fi-360\li360\sa80\widctlpar\adjustright {\fs20 \tab | FN function-name parameter-list\par type ::= [ POINTER TO ] type-name\par }\pard \s30\fi-360\li360\sa80\keepn\widctlpar\adjustright {\fs20 type-character ::= '~' | '%' | '&' | '!' | '#' | '$'\par type-name ::= BYTE | INTEGER | LONG | SINGLE | DOUBLE | STRING | identifier\par }\pard\plain \widctlpar\adjustright \f4\cgrid {\fs20 \sect }\sectd \lndscpsxn\sbkodd\linex0\cols2\colsx144\endnhere\sectdefaultcl {\headerl \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 Index\par }}{\headerr \pard\plain \s24\widctlpar\tqr\tx7920\adjustright \f4\cgrid {\f5\fs20 \tab Index\par }}\pard\plain \s25\fi360\sb40\widctlpar\adjustright \f4\cgrid {\pard\plain \s25\fi360\sb40\widctlpar\adjustright \b\v\f4\fs20\cgrid {\tc {\b\v\fs20 }{\b\v\fs20 Index\tcl1}}}{\b\v\fs20 \par }\pard\plain \s22\fi-180\li180\keepn\widctlpar\adjustright \f4\fs20\cgrid {\field{\*\fldinst {\b  INDEX  }}{\fldrslt {\b special characters\par }{\par }\pard \s22\fi-180\li180\widctlpar\adjustright {^ 114, 122, 129, 173\par ~ 29, 79, 85, 99\par ! 29, 79, 81, }{\b 83}{, 85, 99, 173, 284\par # 79, 81, 86, 99, 169, 178, 179, 191\par $ 29, 30, 79, 81, 87, 99, 172\par % 29, 79, 85, 99\par & 29, 79, 85, 99, 173\par ( 81, 114\par ) 81, 114\par * 81, 114, 120, 172, 204\par + 81, 96, 112, 114, 118, 126, 171, 173\par , 81\par - 81, 114, 119, 125\par . 114, 130\par / 81, 114, 121\par < 81, 114, 124\par <= 114, 124\par <> 114, 124\par = 81, 114, 124\par > 81, 114, 124\par >= 114, 124\par ? 29, 179\par ? statement 164\par @ 81, 87, 114, 128, 131\par \par }\pard \s22\fi-180\li180\keepn\widctlpar\adjustright {\b numbers\par }{\par }\pard \s22\fi-180\li180\widctlpar\adjustright {320 mode graphics 207\par 65816 47, 85, 159, 295, 299\par \par }\pard \s22\fi-180\li180\keepn\widctlpar\adjustright {\b A\par }{\par }\pard \s22\fi-180\li180\widctlpar\adjustright {ABS function }{\b 133}{\par absolute value 133\par active program 41, 42\par addition 118\par address operator 87, 128, 131\par ALLOCATE statement 93, 107, }{\b 211}{, 213, 214, 258, 290\par AND 114, 123\par Apple\~Pascal 188\par Applesoft\~BASIC 6, 8, 41, }{\b 42}{, 45, 49, 52, 207, 277-287\par arc tangent 133\par arrays }{\b 92}{-}{\b 93}{, 94, 95, 99, 100-101, 103\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {as parameters 225, 228\par subscripts 126\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {AS 100, 101, 108, 200, 205, 223, 230\par ASC function }{\b 140}{\par ASCII character set 41, 82, 87, 124, 140, 141, 176, }{\b 269}{\par ASCII files 9, 41, 45, 191\par assembly language 4, 27, 85, 244, 273\par assignment compatibility 95\par assignment statement 131\par ATN function }{\b 133}{\par \par }\pard \s22\fi-180\li180\keepn\widctlpar\adjustright {\b B\par }{\par }\pard \s22\fi-180\li180\widctlpar\adjustright {backing up the disks 5\par binary conversions 114-115\par binary files 45, 192, 195, 198, 200\par binary operators 113\par BREAK statement }{\b 159}{\par built in functions 127, 133-144, 158\par BYE shell command }{\b 44}{\par BYTE 29, 79, 85, 87, 91, 99, 101, 115, 117, 164\par \par }\pard \s22\fi-180\li180\keepn\widctlpar\adjustright {\b C\par }{\par }\pard \s22\fi-180\li180\widctlpar\adjustright {CALL statement }{\b 230}{, 231, 277, 278, 285\par CASE 105, 106\par case sensitivity 71, 79\par CASE statement }{\b 153}{\par CAT shell command }{\b 44}{\par CATALOG shell command }{\b 44}{\par CDBL function }{\b 134}{\par CHDIR statement }{\b 203}{\par CHR$ function }{\b 141}{\par CINT function }{\b 135}{\par CLEAR statement }{\b 216}{\par CLNG 87\par CLNG function }{\b 135}{\par CLOSE statement }{\b 200}{\par command line editor 39\par Command-. 159\par comments 80, }{\b 83}{\par comparison operators 113, 123\par CompileTool 27-34, 274\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {arrays 30, 33\par base types 29\par BNF 32-33\par comments 29, 32, 33\par constants 29, 33\par file types 28\par flags 28\par functions 31, 34\par GSOS 31, 34\par hexadecimal constants 30\par identifiers 29, 34\par named types 30\par ORCA Shell 32\par parameters 30-31, 34\par record parameters 31\par records 30\par reference parameters 31, 34\par string parameters 31\par TOOL 30, 34\par tool numbers 30\par type characters 29, 30, 34\par UNIV 29, 34\par USERTOOL 31, 34\par value parameters 31, 34\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {console control codes 267\par console device 16\par constants 79, 125\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {floating-point 82\par hexadecimal 81\par integer 81\par long integer 81\par string 80\par strings 82\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {CONT statement }{\b 160}{\par conversions\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {binary 114-115\par unary 115-118\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {COPY shell command }{\b 46}{\par copying disks 5\par copyright 26\par COS function }{\b 136}{\par cosine 136\par CREATE shell command }{\b 47}{\par CSNG function }{\b 137}{\par CSRLIN function }{\b 182}{\par CTRL-C 159\par CTRL-S 159\par CURDIR$ function }{\b 204}{\par \par }\pard \s22\fi-180\li180\keepn\widctlpar\adjustright {\b D\par }{\par }\pard \s22\fi-180\li180\widctlpar\adjustright {data formats 85\par DATA statement }{\b 184}{\par DateString function }{\b 236}{\par DEBUG shell command }{\b 47}{\par debugger 47, 159\par DEF FN statement 54, 127, }{\b 221}{, 285\par default prefix\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {see directories \par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {DEL shell command }{\b 47}{\par DELETE shell command }{\b 47}{\par device names 188\par devices 188\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {.PRINTER 8, 21\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {DIM statement 79, 98, 99, }{\b 100}{, 216, 285\par DIR$ function }{\b 204}{\par directories 204\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {changing 50, 203\par copying 47\par creating 205\par default 50, 189, 203, 204\par deleting 205\par files in 44, 204\par see also files \par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {directory names 187, 188\par disk\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {floppy 6\par hard 7\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {disk commands 286\par disk names 187\par DISPOSE statement 211, }{\b 213}{, 290\par division 121\par DO statement }{\b 145}{\par DOS 188\par DOUBLE 29, 79, }{\b 82}{, 86, 91, 99, 101, 111, 114, 115, 116, 117, 118, 119, 120, 134\par \par }\pard \s22\fi-180\li180\keepn\widctlpar\adjustright {\b E\par }{\par }\pard \s22\fi-180\li180\widctlpar\adjustright {EDIT shell command }{\b 48}{\par editing the command line 39\par editor\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {about command }{\b 65}{\par arrow keys 61\par auto-indent mode }{\b 59}{, 70, 77\par beep the speaker command }{\b 65}{\par beginning of line command }{\b 65}{\par bottom of screen command 60, }{\b 65}{\par buttons 63\par check boxes 63\par close command }{\b 65}{\par control underscore key }{\b 59}{\par copy command }{\b 65}{\par create macros command 61\par cursor down command 60, }{\b 65}{\par cursor left command 60, }{\b 66}{\par cursor position 78\par cursor right command 60, }{\b 66}{\par cursor up command 60, }{\b 66}{\par customizing }{\b 77}{\par cut command }{\b 66}{\par define macros command }{\b 66}{\par delete character command }{\b 66}{, 76\par delete character left command }{\b 66}{, 76\par delete command }{\b 66}{\par delete line command }{\b 67}{, 76\par delete to end of line command }{\b 67}{, 76\par delete word command }{\b 67}{, 76\par deleting characters in macros 61\par dialogs 62\par edit line controls 63\par edit line items 62\par end macro definition command 61\par end of line command }{\b 67}{\par ESCAPE key 60\par escape mode }{\b 59}{\par executing macros }{\b 61}{\par exit macro creation command 61\par help command }{\b 67}{\par hidden characters 60\par insert blank lines command 59\par insert line command }{\b 67}{\par insert mode }{\b 58}{\par insert space command }{\b 67}{\par line length }{\b 58}{\par list controls 64\par macro keystrokes }{\b 61}{\par macros }{\b 60}{\par modes 77\par mouse 64\par moving through a file }{\b 71}{\par multiple files 68, 75\par multiple files. 74\par new command }{\b 68}{\par open Apple key 59\par open command }{\b 68}{\par over strike mode }{\b 58}{, 78\par paste command 65, }{\b 69}{\par quit command }{\b 69}{\par remove blanks command }{\b 69}{\par repeat counts }{\b 59}{, }{\b 70}{\par resource fork 78\par RETURN key 60, }{\b 70}{\par save as command }{\b 70}{\par save command }{\b 71}{\par screen move commands 60\par scroll down one line command }{\b 71}{\par scroll down one page command }{\b 71}{\par scroll up one line }{\b 71}{\par scroll up one page command }{\b 71}{\par search and replace down command }{\b 73}{\par search and replace up command }{\b 74}{\par search down command }{\b 71}{\par search up command }{\b 73}{\par select file command }{\b 74}{\par select mode 77\par }\pard\plain \s20\li720\widctlpar\adjustright \f4\cgrid {by character }{\b 59}{, 60, 69\par by line }{\b 59}{\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {set/clear auto-indent mode command }{\b 76}{\par set/clear escape mode command }{\b 76}{\par set/clear insert mode command }{\b 76}{\par set/clear select mode command }{\b 76}{\par set/clear tab stops command }{\b 74}{\par setting defaults }{\b 77}{\par shift left command }{\b 74}{\par shift right command }{\b 75}{\par start of line command 60\par switch files command }{\b 75}{\par tab command 60, }{\b 75}{\par tab left command 60, }{\b 75}{\par tab mode 78\par tabs 60, 63, 78\par top of screen command 60, }{\b 76}{\par undo command 66\par undo delete buffer 66, 76\par undo delete command }{\b 76}{\par version }{\b 65}{\par word left command 60, }{\b 77}{\par word right command 60, }{\b 77}{\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {END statement }{\b 160}{\par EOF function }{\b 202}{\par equal 124\par ERL function }{\b 158}{\par ERR function }{\b 158}{\par ERROR statement 86, }{\b 156}{, 157, 158\par EXP function }{\b 137}{\par exponent 82, 85, 91, 137, 143, 165, 173\par exponentiation 114, 122\par expression 111-130\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {conversions in 114\par logical 111\par mathematical 111\par operator precedence 113\par pointer 112\par string 112\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s22\fi-180\li180\keepn\widctlpar\adjustright {\b F\par }{\par }\pard \s22\fi-180\li180\widctlpar\adjustright {false 112\par field 93, 103, 104, 130\par file names 45, 51, 187, 204\par file numbers 191\par File Type Notes 45\par file types\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {BAS 42, 45, 49\par BIN 45, 192, 195, 198, 201\par DIR 45\par DVU 28, 45\par S16 45\par SRC 28, 41, 45, 49, 55, 69\par TOK 41, 55\par TXT 28, 41, 45, 49, 55, 69, 201\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {files\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {access privileges 45, 46, 49, 55\par auxiliary type 41, 45\par copying 46\par dates 45\par deleting 47, 205\par letter case 51, 204\par moving 49\par names 45, 51, 187\par renaming 51, 205\par see also directories \par size 45, 202\par type 41, 45\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {Finder\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {creating programs for 8, 9, 16\par running GSoft\~BASIC from 8, 39\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {floating-point 33, 85, 96, 100, 112, 118, 119, 129, 132, 134, 137, 165, 170, 192\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {constants 82\par see also DOUBLE \par see also SINGLE \par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {floppy disk 6\par FN\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {see DEF FN \par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {folders\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {see directories \par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {fonts 270\par FOR statement }{\b 147}{, 285\par FORTRAN 91\par FRE function }{\b 141}{, 290\par full path names 188\par FUNCTION statement 89, 127, 185, }{\b 230}{, 289\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {parameters 223\par recursion 229\par variable scope 228\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {functions\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {built in 127, 133-144, 158\par see also DEF FN \par see also FUNCTION statement \par see also tools \par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s22\fi-180\li180\keepn\widctlpar\adjustright {\b G\par }{\par }\pard \s22\fi-180\li180\widctlpar\adjustright {garbage collection 87, 141, 290\par GET statement }{\b 202}{, 285\par GOSUB statement }{\b 219}{, 221\par GOTO statement }{\b 155}{\par graphics 207-210\par graphics environment 17\par greater than 124\par greater than or equal 124\par GS/OS 4, 18, 21, 22, 28, 31, 40, 187, 188, 190, 239, 244, 245, 283\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {errors 244\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {GSoft\~BASIC\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {Finder version 11, 39, 241\par run time 39\par shell version }{\b 39}{-}{\b 55}{, 241\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {GSOS token }{\b 245}{\par GTBootInit statement }{\b 233}{\par GTClearAnnunciator statement }{\b 234}{\par GTGetPaddle function }{\b 234}{\par GTGetSwitch function }{\b 234}{\par GTSetAnnunciator statement }{\b 234}{\par GTShutDown statement }{\b 234}{\par GTStartup statement }{\b 233}{\par GTStatus function }{\b 234}{\par GTVersion function }{\b 234}{\par \par }\pard \s22\fi-180\li180\keepn\widctlpar\adjustright {\b H\par }{\par }\pard \s22\fi-180\li180\widctlpar\adjustright {hard disk 7\par HCOLOR= statement }{\b 207}{, 285\par hexadecimal 30, 81\par HFS 187\par HGR statement 17, }{\b 208}{, 240\par hidden characters 60\par HOME statement }{\b 183}{\par HPLOT statement }{\b 209}{\par HTAB statement }{\b 183}{\par \par }\pard \s22\fi-180\li180\keepn\widctlpar\adjustright {\b I\par }{\par }\pard \s22\fi-180\li180\widctlpar\adjustright {identifiers 57, }{\b 79}{, 85, 87, 98, 99, 291, 294\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {case sensitivity 79\par length 79\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {IF statement }{\b 151}{, 286\par immediate execution 43\par inf }{\b 86}{\par infinity }{\b 86}{, 118, 119, 120, 121, 122, 123, 133, 140\par Innovative Systems 85\par INPUT statement }{\b 178}{, 187, 286\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {see also LINE INPUT \par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {installer 21\par installing GSoft\~BASIC 6-8\par INT function }{\b 137}{\par INTEGER 29, 79, }{\b 81}{, 85, 91, 99, 100, 101, 111, 114, 116, 117, 118, 119, 120, 121, 122, 135, 164\par integers 85\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {constants 81\par storage 85\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {INVERSE statement }{\b 177}{\par \par }\pard \s22\fi-180\li180\keepn\widctlpar\adjustright {\b K\par }{\par }\pard \s22\fi-180\li180\widctlpar\adjustright {keyboard 88, 129, 161, 163, 178, 187, 202, 215, 269, 279, 281\par KILL statement }{\b 205}{\par \par }\pard \s22\fi-180\li180\keepn\widctlpar\adjustright {\b L\par }{\par }\pard \s22\fi-180\li180\widctlpar\adjustright {l-values 130-131\par language numbers 77\par language stamp 41\par LEFT$ function }{\b 141}{\par LEN function }{\b 142}{\par less than 124\par less than or equal 124\par LET statement }{\b 131}{\par libraries\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {errors 244\par loading 245\par see also CompileTool \par see also user tools \par unloading 245\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {LIBRARY token }{\b 246}{\par licensing 26\par line editor 39\par LINE INPUT statement }{\b 181}{, 187\par line numbers 43, }{\b 89}{, 158, 287, 292\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {RENUMBER shell command 51\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {lines 79\par linked lists 94, 107, 260\par LIST shell command }{\b 48}{\par LOAD shell command }{\b 49}{\par LOADLIBRARY statement }{\b 245}{\par LOC function }{\b 202}{\par LOCK shell command }{\b 49}{\par LOF function }{\b 202}{\par LOG function }{\b 138}{\par logarithm 138\par logical AND 123\par logical expression 111\par logical NOT 126\par logical OR 123\par logical value 112\par LONG 29, 79, }{\b 81}{, 85, 91, 99, 101, 111, 114, 116, 117, 118, 119, 120, 121, 122, 135, 164\par long integers\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {constants 81\par storage 85\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {LOOP statement }{\b 145}{\par low resolution graphics 207, 283\par \par }\pard \s22\fi-180\li180\keepn\widctlpar\adjustright {\b M\par }{\par }\pard \s22\fi-180\li180\widctlpar\adjustright {MakeRuntime utility }{\b 24}{, 214, 289\par mantissa 117, 165\par mathematical expression 111\par matrix 91\par memory 88, 161, 286\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {ALLOCATE statement 211\par array storage 92\par DISPOSE statement 213\par map 290\par NIL function 213\par PEEK function 215\par POKE statement 215\par records 93, 103\par requirements 5, 19\par see also pointers \par SETMEM statement 213\par use 289\par variant records 105\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {menu bar 18\par Microsoft 91\par Microsoft\~BASIC 286\par MID$ function }{\b 142}{\par MKDIR statement }{\b 205}{\par mouse 64\par MOUSETEXT statement }{\b 177}{\par MOVE shell command }{\b 49}{\par multiplication 120\par \par }\pard \s22\fi-180\li180\keepn\widctlpar\adjustright {\b N\par }{\par }\pard \s22\fi-180\li180\widctlpar\adjustright {NAME statement }{\b 205}{\par named types 94\par NaN }{\b 86}{, 118, 119, 120, 121, 122, 123, 133, 140\par natural logarithm 138\par NEW shell command }{\b 50}{\par NEXT statement }{\b 147}{\par NIL function }{\b 213}{\par NORMAL statement }{\b 178}{\par NOT 114, 126\par not equal 124\par NULL 87\par null character 82\par \par }\pard \s22\fi-180\li180\keepn\widctlpar\adjustright {\b O\par }{\par }\pard \s22\fi-180\li180\widctlpar\adjustright {ON-GOSUB statement }{\b 220}{, 221\par ON-GOTO statement }{\b 156}{\par ONERR GOTO statement }{\b 157}{, 277\par OPEN statement }{\b 200}{\par operator precedence 113\par OR 114, 123\par ORCA\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {installing GSoft\~BASIC 7\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {ORCA shell 9, 34, 239, 244, 289\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {errors 244\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {ORCA/Debugger 47, 159\par ORCA/M 4\par output 16\par overflow 118, 119, 120, 121, 122\par \par }\pard \s22\fi-180\li180\keepn\widctlpar\adjustright {\b P\par }{\par }\pard \s22\fi-180\li180\widctlpar\adjustright {p-strings 243\par parameters 223, 230, 231\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {arrays as 225, 228\par built-in functions 127\par DEF FN 128, 221\par pass by reference 31, 96, 227, 229, 242\par pass by value 31, 96, 227, 242\par records as 224, 228\par tool calls 241, 242\par type compatibility 95, 96\par types for 229\par unary conversions 115\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {parentheses 31, 96, 114, 125, 126, 223, 225, 227, 230, 242\par partial path names 188, 189\par path names\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {see directories \par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {pausing a program 159\par PEEK function }{\b 215}{, 277, 278-280, 286\par POINTER 102\par pointer expression 112\par pointers 87, 91, 92, 93-94, 98, 112, 211, 224\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {comparing 124\par dereferencing 129\par math 119, 120, 136\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {POKE statement }{\b 215}{, 270, 277, 280-283, 286\par POP statement }{\b 221}{\par POS statement }{\b 183}{\par power\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {see exponent \par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {PR shell command }{\b 50}{\par prefix\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {see directory \par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {PREFIX shell command }{\b 50}{\par pretty printing 57\par PRINT statement }{\b 163}{, 187, 286\par PRINT USING statement }{\b 169}{, 187\par printers\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {.PRINTER driver 8, }{\b 21}{-}{\b 24}{, 188, 190\par characters per line 23\par configuration 22\par control characters 23, 190\par extra blank lines 23\par formatting 167\par initialization 23\par lines overwritten 23\par lines per page 22\par slot 22\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {PRIZM 159\par ProDOS 187\par program buffer 42, 213, }{\b 289}{, 291\par program files\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {see file types \par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {PUT statement }{\b 203}{, 286\par \par }\pard \s22\fi-180\li180\keepn\widctlpar\adjustright {\b Q\par }{\par }\pard \s22\fi-180\li180\widctlpar\adjustright {QuickDraw\~II 17, 207, 208\par \par }\pard \s22\fi-180\li180\keepn\widctlpar\adjustright {\b R\par }{\par }\pard \s22\fi-180\li180\widctlpar\adjustright {RAM 9, 87, 161\par random access files 199, 200, 202, 203\par random numbers 138-139\par READ statement }{\b 185}{\par records 30, 91, 92, 93, 94, 97, 103-108, 130, 131, 132, 166, 224, 230\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {variant 103, 105-107\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {recursion 219, 222, 226, 229\par registration card 5\par REM statement }{\b 83}{\par RENAME shell command }{\b 51}{\par RENUMBER shell command }{\b 51}{\par reserved symbols }{\b 80}{\par reserved words }{\b 80}{\par resources 9\par RESTORE statement }{\b 185}{\par RESUME statement }{\b 158}{\par return characters 23, 41, 60\par RETURN statement }{\b 221}{\par Rez 9\par RIGHT$ function }{\b 143}{\par RMDIR statement }{\b 205}{\par RND function }{\b 138}{\par RUN shell command }{\b 54}{\par \par }\pard \s22\fi-180\li180\keepn\widctlpar\adjustright {\b S\par }{\par }\pard \s22\fi-180\li180\widctlpar\adjustright {samples\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {Array Parameters 226\par Artillery 14\par ATN2 134\par Binary File I/O 1 197\par Binary File I/O 2 198\par Finance 12\par Hexadecimal File Dump 193\par Keyboard 129\par Move Up One Directory 204\par Print Directory 205\par Print Text File 151\par QuickDraw\~II 240\par Random Access File I/O 200\par Sieve 52\par TOUPPER 141\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {SANE 85\par SAVE shell command 41, }{\b 55}{, 69\par saving programs 13, 55\par SEEK statement }{\b 203}{\par SELECT statement }{\b 153}{\par SETMEM statement }{\b 213}{\par SGN function }{\b 139}{\par shape tables 207\par shell 8\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {GSoft\~BASIC 6, 7, 8, 16, }{\b 39}{-}{\b 55}{, 267, 295\par ORCA 7, 9, 16, 28, 32, 34, 239, 244, 289\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {shell prefix 61, 67, 77\par SIN function }{\b 139}{\par sine 139\par SINGLE 29, 79, }{\b 82}{, 85, 91, 99, 101, 111, 114, 115, 116, 117, 118, 119, 120, 137, 287\par site license 5\par SIZEOF function }{\b 214}{\par source files\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {see file types \par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {SPEED statement }{\b 175}{\par Splat! 47, 159\par SQR function }{\b 140}{\par square root 140\par SSAVE shell command 41, }{\b 55}{, 69\par standard output 16\par STOP statement }{\b 161}{\par stopping a program 159, 161\par STR$ function }{\b 143}{\par STRING 29, 79, }{\b 82}{, 87, 91, 99, 101\par strings 97, 124, 140-144\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {concatenation 118\par constants 80, }{\b 82}{\par converting numbers to 143\par converting to numbers 143\par expressions 112\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {SUB statement 89, 185, }{\b 231}{, 289\par subtraction 119\par SYSEMAC file 61\par SYSHELP file 67\par SysTabs file 77\par system\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {requirements 5\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {System 6.0 4\par SYSTEMP file 65, 69\par \par }\pard \s22\fi-180\li180\keepn\widctlpar\adjustright {\b T\par }{\par }\pard \s22\fi-180\li180\widctlpar\adjustright {tabs 7, 60, 63, 71, 72, 78, 167, 183, 190, 280, 286, 291\par Talking Tools 28, 239\par TAN function }{\b 140}{\par tangent 140\par term 113, 125-130\par text files }{\b 41}{, 45, 191, 200\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {see also file types \par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {text programming 11, 267\par text screen 11, 16, 167, 175, 182, 267, 270, 283\par TEXT statement }{\b 210}{\par Time statement }{\b 237}{\par TimeString function }{\b 236}{\par tokens 57, }{\b 79}{, 83, 291-294\par TOOL token }{\b 246}{\par toolbox 1, 4, 9, 17, 19, 239-243\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {errors 244\par fonts 270\par interface files 27-34, 240-243\par learning 2, 3, 18, 239\par reference manuals 4\par see also CompileTool \par see also QuickDraw\~II \par string parameters 87\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {TOOLERROR function }{\b 244}{\par true 112\par TSAVE shell command 41, }{\b 55}{, 58, 69\par TTBootInit statement }{\b 235}{\par TTShutDown statement }{\b 236}{\par TTStartup statement }{\b 235}{\par TTStatus function }{\b 236}{\par TTVersion function }{\b 236}{\par type casting 87, 128-129\par type characters 98\par type compatibility 95-98\par TYPE statement 91, 94, 102, }{\b 103}{, }{\b 108}{\par types 85, 91-110\par \par }\pard \s22\fi-180\li180\keepn\widctlpar\adjustright {\b U\par }{\par }\pard \s22\fi-180\li180\widctlpar\adjustright {unary addition 126\par unary conversions 115-118\par unary negation 126\par unary subtraction 125\par UNIV\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {see CompileTool \par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {UNLOADLIBRARY statement }{\b 245}{\par UNLOCK shell command }{\b 55}{\par user tools 244, 246\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {errors 244\par interface files 27\par loading 245\par see also CompileTool \par see also libraries \par unloading 245\par writing 273-275\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s22\fi-180\li180\keepn\widctlpar\adjustright {\b V\par }{\par }\pard \s22\fi-180\li180\widctlpar\adjustright {VAL function }{\b 143}{\par variable scope 228\par variant records 103, 105-107, 211\par version\par }\pard\plain \s21\fi-180\li540\widctlpar\adjustright \f4\fs20\cgrid {editor 65\par }\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {VERSION function }{\b 216}{\par version number 216\par VTAB statement }{\b 184}{\par \par }\pard \s22\fi-180\li180\keepn\widctlpar\adjustright {\b W\par }{\par }\pard \s22\fi-180\li180\widctlpar\adjustright {WAIT statement }{\b 161}{\par WEND statement }{\b 150}{\par WHILE statement }{\b 150}{\par white space 72, 83\par windows 18\par work prefix 65, 69\par workspace 42, 216\par \par }\pard \s22\fi-180\li180\keepn\widctlpar\adjustright {\b Y\par }{\par }\pard \s22\fi-180\li180\widctlpar\adjustright {Y2K bug 236}}}\pard\plain \s22\fi-180\li180\widctlpar\adjustright \f4\fs20\cgrid {\par }}