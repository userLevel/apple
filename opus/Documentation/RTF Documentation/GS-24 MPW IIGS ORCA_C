{\rtf1\mac\ansicpg10000\uc1 \deff0\deflang1033\deflangfe1033{\upr{\fonttbl{\f0\fnil\fcharset256\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fnil\fcharset256\fprq2{\*\panose 020b0604020202020204}Arial;}{\f2\fnil\fcharset256\fprq2{\*\panose 02070309020205020404}Courier New;}{\f3\fnil\fcharset2\fprq2{\*\panose 02000500000000000000}Symbol;}{\f4\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Times;}{\f5\fnil\fcharset256\fprq2{\*\panose 1f1803b4fbbc00027258}Helvetica;}{\f6\fnil\fcharset256\fprq2{\*\panose 6f844c4f434b00027258}Courier;}{\f7\fnil\fcharset256\fprq2{\*\panose 020b0503030404040204}Geneva;}{\f8\froman\fcharset77\fprq2{\*\panose 00000000000000000000}Tms Rmn;}{\f9\fswiss\fcharset77\fprq2{\*\panose 00000000000000000000}Helv;}{\f10\froman\fcharset77\fprq2{\*\panose 00000000000000000000}MS Serif;}{\f11\fswiss\fcharset77\fprq2{\*\panose 00000000000000000000}MS Sans Serif;}{\f12\fnil\fcharset256\fprq2{\*\panose 7a1c0000000d00027258}New York;}{\f13\fswiss\fcharset77\fprq2{\*\panose 00000000000000000000}System;}{\f14\fnil\fcharset2\fprq2{\*\panose 05020102010804080708}Wingdings;}{\f15\froman\fcharset256\fprq1{\*\panose 00000000000000000000}FE Roman font face;}{\f16\fmodern\fcharset256\fprq1{\*\panose 00000000000000000000}FE Modern font face;}{\f17\froman\fcharset256\fprq1{\*\panose 00000000000000000000}FE Truetype Roman font face;}{\f18\fmodern\fcharset256\fprq1{\*\panose 00000000000000000000}FE Truetype Modern font face;}{\f19\froman\fcharset77\fprq2{\*\panose 00000000000000000000}Century;}{\f20\fnil\fcharset256\fprq2{\*\panose 020b0806080604040204}Chicago;}{\f21\fnil\fcharset2\fprq2{\*\panose 03b51150005f001d74c0}Zapf Dingbats;}{\f22\fnil\fcharset77\fprq0{\*\panose 00000000000000000000};}{\f23\fnil\fcharset256\fprq2{\*\panose 020b0a06030101010103}Abadi MT Condensed Extra Bold;}{\f24\fnil\fcharset256\fprq2{\*\panose 020b0306030101010103}Abadi MT Condensed Light;}{\f25\fnil\fcharset256\fprq2{\*\panose 020b0509000000000004}Andale Mono;}{\f26\fnil\fcharset256\fprq2{\*\panose 05000000000000000000}Animals 1;}{\f27\fnil\fcharset256\fprq2{\*\panose 020b0a04020102020204}Arial Black;}{\f28\fnil\fcharset256\fprq2{\*\panose 020b0506020202030204}Arial Narrow;}{\f29\fnil\fcharset256\fprq2{\*\panose 020f0704030504030204}Arial Rounded MT Bold;}{\f30\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}AvantGarde Bk BT;}{\f31\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}AvantGarde BkOb BT;}{\f32\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}AvantGarde Dm BT;}{\f33\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}AvantGarde DmOb BT;}{\f34\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}AvantGarde Md BT;}{\f35\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}AvantGarde MdOb BT;}{\f36\fnil\fcharset256\fprq2{\*\panose 020b0603050302020204}Balloons;}{\f37\fnil\fcharset256\fprq2{\*\panose 02020602080505020303}Baskerville Old Face;}{\f38\fnil\fcharset256\fprq2{\*\panose 04030905020b02020c02}Bauhaus 93;}{\f39\fnil\fcharset256\fprq2{\*\panose 02020503060305020303}Bell MT;}{\f40\fnil\fcharset256\fprq2{\*\panose 02050806060905020404}Bernard MT Condensed;}{\f41\fnil\fcharset256\fprq2{\*\panose 02040602050305030304}Book Antiqua;}{\f42\fnil\fcharset256\fprq2{\*\panose 02050604050505020204}Bookman Old Style;}{\f43\fnil\fcharset256\fprq2{\*\panose 04030b070d0b02020403}Braggadocio;}{\f44\fnil\fcharset256\fprq2{\*\panose 020b0903060703020204}Britannic Bold;}{\f45\fnil\fcharset256\fprq2{\*\panose 03060802040406070304}Brush Script MT;}{\f46\fnil\fcharset256\fprq2{\*\panose 02040603050505030304}Calisto MT;}{\f47\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Capitals;}{\f48\fnil\fcharset256\fprq2{\*\panose 020b0502020202020204}Century Gothic;}{\f49\fnil\fcharset256\fprq2{\*\panose 02040604050505020304}Century Schoolbook;}{\f50\fnil\fcharset256\fprq2{\*\panose 00000000000000000000}Charcoal;}{\f51\fnil\fcharset256\fprq2{\*\panose 04020805060202030203}Colonna MT;}{\f52\fnil\fcharset256\fprq2{\*\panose 030f0702030302020204}Comic Sans MS;}{\f53\fnil\fcharset256\fprq2{\*\panose 020b0603050302020204}CommonBullets;}{\f54\fnil\fcharset256\fprq2{\*\panose 0208090404030b020404}Cooper Black;}{\f55\fnil\fcharset256\fprq2{\*\panose 020e0705020206020404}Copperplate Gothic Bold;}{\f56\fnil\fcharset256\fprq2{\*\panose 020e0507020206020404}Copperplate Gothic Light;}{\f57\fnil\fcharset256\fprq2{\*\panose 04020505020e03040504}Desdemona;}{\f58\fnil\fcharset256\fprq2{\*\panose 00000400000000000000}Disney Print;}{\f59\fnil\fcharset256\fprq2{\*\panose 02090707080505020304}Engravers MT;}{\f60\fnil\fcharset256\fprq2{\*\panose 020b0504020202050204}Eurostile;}{\f61\fnil\fcharset256\fprq2{\*\panose 020b0603050302020204}Festive;}{\f62\fnil\fcharset256\fprq2{\*\panose 0204060206030a020304}Footlight MT Light;}{\f63\fnil\fcharset256\fprq2{\*\panose 05000000000000000000}FrenchScript;}{\f64\fnil\fcharset256\fprq2{\*\panose 00000000000000000000}Gadget;}{\f65\fnil\fcharset256\fprq2{\*\panose 02020404030301010803}Garamond;}{\f66\fnil\fcharset256\fprq2{\*\panose 02040502050405020303}Georgia;}{\f67\fnil\fcharset256\fprq2{\*\panose 020b0a04020203020204}Gill Sans Ultra Bold;}{\f68\fnil\fcharset256\fprq2{\*\panose 02030808020601010101}Gloucester MT Extra Condensed;}{\f69\fnil\fcharset256\fprq2{\*\panose 00000400000000000000}GME Title-Regular;}{\f70\fnil\fcharset256\fprq2{\*\panose 02020502050305020303}Goudy Old Style;}{\f71\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Grolier 1;}{\f72\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Grolier 2;}{\f73\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}Grolier Bd 1;}{\f74\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}Grolier Bd 2;}{\f75\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}Grolier BdIt 1;}{\f76\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}Grolier BdIt 2;}{\f77\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Grolier It 1;}{\f78\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Grolier It 2;}{\f79\fnil\fcharset256\fprq2{\*\panose 04040505050a02020702}Harrington;}{\f80\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Helvetica Black;}{\f81\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Helvetica Compressed;}{\f82\fnil\fcharset256\fprq2{\*\panose 020b0806030902050204}Impact;}{\f83\fnil\fcharset256\fprq2{\*\panose 04020605060303030202}Imprint MT Shadow;}{\f84\fnil\fcharset256\fprq2{\*\panose 00000400000000000000}Inso GI1 SILDoulosL;}{\f85\fnil\fcharset256\fprq2{\*\panose 00000400000000000000}Inso GI1 SILDoulosL I;}{\f86\fnil\fcharset256\fprq2{\*\panose 00000400000000000000}Inso If1 SILDoulosL;}{\f87\fnil\fcharset256\fprq2{\*\panose 00000400000000000000}Inso If1 SILDoulosL I;}{\f88\fnil\fcharset256\fprq2{\*\panose 03010101010101010101}Kidprint;}{\f89\fnil\fcharset256\fprq2{\*\panose 040307050d0c02020703}Kino MT;}{\f90\fnil\fcharset256\fprq2{\*\panose 00000000000000000000}Lucida Blackletter;}{\f91\fnil\fcharset256\fprq2{\*\panose 02040602050505020304}Lucida Bright;}{\f92\fnil\fcharset256\fprq2{\*\panose 03010101010101010101}Lucida Calligraphy;}{\f93\fnil\fcharset256\fprq2{\*\panose 02060602050505020204}Lucida Fax;}{\f94\fnil\fcharset256\fprq2{\*\panose 03010101010101010101}Lucida Handwriting;}{\f95\fnil\fcharset256\fprq2{\*\panose 020b0602030504020204}Lucida Sans;}{\f96\fnil\fcharset256\fprq2{\*\panose 020b0509030504030204}Lucida Sans Typewriter;}{\f97\fnil\fcharset256\fprq2{\*\panose 020b0602060201020203}Lydian MT;}{\f98\fnil\fcharset256\fprq2{\*\panose 03020802060602070202}Matura MT Script Capitals;}{\f99\fnil\fcharset256\fprq2{\*\panose 02040503050201020203}Minion Web;}{\f100\fnil\fcharset256\fprq2{\*\panose 03090702030407020403}Mistral;}{\f101\fnil\fcharset256\fprq2{\*\panose 02070704070505020303}Modern No. 20;}{\f102\fnil\fcharset256\fprq2{\*\panose 020b0509030404040204}Monaco;}{\f103\fnil\fcharset256\fprq2{\*\panose 03010101010201010101}Monotype Corsiva;}{\f104\fnil\fcharset2\fprq2{\*\panose 01010601010101010101}Monotype Sorts;}{\f105\fnil\fcharset256\fprq2{\*\panose 020b0509000000000004}Monotype.com;}{\f106\fnil\fcharset2\fprq2{\*\panose 02000500000000000000}MT Extra;}{\f107\fnil\fcharset256\fprq2{\*\panose 020b0504020203020204}News Gothic MT;}{\f108\fnil\fcharset256\fprq2{\*\panose 04050602080702020203}Onyx;}{\f109\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Palatino;}{\f110\fnil\fcharset256\fprq2{\*\panose 02020502060505020804}Perpetua Titling MT;}{\f111\fnil\fcharset256\fprq2{\*\panose 040506030a0602020202}Playbill;}{\f112\fnil\fcharset256\fprq2{\*\panose 02060603020205020403}Rockwell;}{\f113\fnil\fcharset256\fprq2{\*\panose 02060903040505020403}Rockwell Extra Bold;}{\f114\fnil\fcharset256\fprq2{\*\panose 00000000000000000000}Sand;}{\f115\fnil\fcharset256\fprq2{\*\panose 020b0603050302020204}SportsFigures;}{\f116\fnil\fcharset256\fprq2{\*\panose 040409050d0802020404}Stencil;}{\f117\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}Swing;}{\f118\fnil\fcharset256\fprq2{\*\panose 020b0604030504040204}Tahoma;}{\f119\fnil\fcharset256\fprq2{\*\panose 00000000000000000000}Techno;}{\f120\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Textile;}{\f121\fnil\fcharset256\fprq2{\*\panose 020b0603020202020204}Trebuchet MS;}{\f122\fnil\fcharset256\fprq2{\*\panose 020b0604030504040204}Verdana;}{\f123\fnil\fcharset2\fprq2{\*\panose 05030102010509060703}Webdings;}{\f124\fnil\fcharset256\fprq2{\*\panose 020a0a07050505020404}Wide Latin;}{\f125\fnil\fcharset2\fprq2{\*\panose 05020102010507070707}Wingdings 2;}{\f126\fnil\fcharset2\fprq2{\*\panose 05040102010807070707}Wingdings 3;}{\f127\fnil\fcharset256\fprq2{\*\panose 05000000000000000000}ZapfDingbats BT;}}{\*\ud{\fonttbl{\f0\fnil\fcharset256\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fnil\fcharset256\fprq2{\*\panose 020b0604020202020204}Arial;}{\f2\fnil\fcharset256\fprq2{\*\panose 02070309020205020404}Courier New;}{\f3\fnil\fcharset2\fprq2{\*\panose 02000500000000000000}Symbol;}{\f4\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Times;}{\f5\fnil\fcharset256\fprq2{\*\panose 1f1803b4fbbc00027258}Helvetica;}{\f6\fnil\fcharset256\fprq2{\*\panose 6f844c4f434b00027258}Courier;}{\f7\fnil\fcharset256\fprq2{\*\panose 020b0503030404040204}Geneva;}{\f8\froman\fcharset77\fprq2{\*\panose 00000000000000000000}Tms Rmn;}{\f9\fswiss\fcharset77\fprq2{\*\panose 00000000000000000000}Helv;}{\f10\froman\fcharset77\fprq2{\*\panose 00000000000000000000}MS Serif;}{\f11\fswiss\fcharset77\fprq2{\*\panose 00000000000000000000}MS Sans Serif;}{\f12\fnil\fcharset256\fprq2{\*\panose 7a1c0000000d00027258}New York;}{\f13\fswiss\fcharset77\fprq2{\*\panose 00000000000000000000}System;}{\f14\fnil\fcharset2\fprq2{\*\panose 05020102010804080708}Wingdings;}{\f15\froman\fcharset256\fprq1{\*\panose 00000000000000000000}FE Roman font face;}{\f16\fmodern\fcharset256\fprq1{\*\panose 00000000000000000000}FE Modern font face;}{\f17\froman\fcharset256\fprq1{\*\panose 00000000000000000000}FE Truetype Roman font face;}{\f18\fmodern\fcharset256\fprq1{\*\panose 00000000000000000000}FE Truetype Modern font face;}{\f19\froman\fcharset77\fprq2{\*\panose 00000000000000000000}Century;}{\f20\fnil\fcharset256\fprq2{\*\panose 020b0806080604040204}Chicago;}{\f21\fnil\fcharset2\fprq2{\*\panose 03b51150005f001d74c0}Zapf Dingbats;}{\f22\fnil\fcharset77\fprq0{\*\panose 00000000000000000000};}{\f23\fnil\fcharset256\fprq2{\*\panose 020b0a06030101010103}Abadi MT Condensed Extra Bold;}{\f24\fnil\fcharset256\fprq2{\*\panose 020b0306030101010103}Abadi MT Condensed Light;}{\f25\fnil\fcharset256\fprq2{\*\panose 020b0509000000000004}Andale Mono;}{\f26\fnil\fcharset256\fprq2{\*\panose 05000000000000000000}Animals 1;}{\f27\fnil\fcharset256\fprq2{\*\panose 020b0a04020102020204}Arial Black;}{\f28\fnil\fcharset256\fprq2{\*\panose 020b0506020202030204}Arial Narrow;}{\f29\fnil\fcharset256\fprq2{\*\panose 020f0704030504030204}Arial Rounded MT Bold;}{\f30\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}AvantGarde Bk BT;}{\f31\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}AvantGarde BkOb BT;}{\f32\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}AvantGarde Dm BT;}{\f33\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}AvantGarde DmOb BT;}{\f34\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}AvantGarde Md BT;}{\f35\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}AvantGarde MdOb BT;}{\f36\fnil\fcharset256\fprq2{\*\panose 020b0603050302020204}Balloons;}{\f37\fnil\fcharset256\fprq2{\*\panose 02020602080505020303}Baskerville Old Face;}{\f38\fnil\fcharset256\fprq2{\*\panose 04030905020b02020c02}Bauhaus 93;}{\f39\fnil\fcharset256\fprq2{\*\panose 02020503060305020303}Bell MT;}{\f40\fnil\fcharset256\fprq2{\*\panose 02050806060905020404}Bernard MT Condensed;}{\f41\fnil\fcharset256\fprq2{\*\panose 02040602050305030304}Book Antiqua;}{\f42\fnil\fcharset256\fprq2{\*\panose 02050604050505020204}Bookman Old Style;}{\f43\fnil\fcharset256\fprq2{\*\panose 04030b070d0b02020403}Braggadocio;}{\f44\fnil\fcharset256\fprq2{\*\panose 020b0903060703020204}Britannic Bold;}{\f45\fnil\fcharset256\fprq2{\*\panose 03060802040406070304}Brush Script MT;}{\f46\fnil\fcharset256\fprq2{\*\panose 02040603050505030304}Calisto MT;}{\f47\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Capitals;}{\f48\fnil\fcharset256\fprq2{\*\panose 020b0502020202020204}Century Gothic;}{\f49\fnil\fcharset256\fprq2{\*\panose 02040604050505020304}Century Schoolbook;}{\f50\fnil\fcharset256\fprq2{\*\panose 00000000000000000000}Charcoal;}{\f51\fnil\fcharset256\fprq2{\*\panose 04020805060202030203}Colonna MT;}{\f52\fnil\fcharset256\fprq2{\*\panose 030f0702030302020204}Comic Sans MS;}{\f53\fnil\fcharset256\fprq2{\*\panose 020b0603050302020204}CommonBullets;}{\f54\fnil\fcharset256\fprq2{\*\panose 0208090404030b020404}Cooper Black;}{\f55\fnil\fcharset256\fprq2{\*\panose 020e0705020206020404}Copperplate Gothic Bold;}{\f56\fnil\fcharset256\fprq2{\*\panose 020e0507020206020404}Copperplate Gothic Light;}{\f57\fnil\fcharset256\fprq2{\*\panose 04020505020e03040504}Desdemona;}{\f58\fnil\fcharset256\fprq2{\*\panose 00000400000000000000}Disney Print;}{\f59\fnil\fcharset256\fprq2{\*\panose 02090707080505020304}Engravers MT;}{\f60\fnil\fcharset256\fprq2{\*\panose 020b0504020202050204}Eurostile;}{\f61\fnil\fcharset256\fprq2{\*\panose 020b0603050302020204}Festive;}{\f62\fnil\fcharset256\fprq2{\*\panose 0204060206030a020304}Footlight MT Light;}{\f63\fnil\fcharset256\fprq2{\*\panose 05000000000000000000}FrenchScript;}{\f64\fnil\fcharset256\fprq2{\*\panose 00000000000000000000}Gadget;}{\f65\fnil\fcharset256\fprq2{\*\panose 02020404030301010803}Garamond;}{\f66\fnil\fcharset256\fprq2{\*\panose 02040502050405020303}Georgia;}{\f67\fnil\fcharset256\fprq2{\*\panose 020b0a04020203020204}Gill Sans Ultra Bold;}{\f68\fnil\fcharset256\fprq2{\*\panose 02030808020601010101}Gloucester MT Extra Condensed;}{\f69\fnil\fcharset256\fprq2{\*\panose 00000400000000000000}GME Title-Regular;}{\f70\fnil\fcharset256\fprq2{\*\panose 02020502050305020303}Goudy Old Style;}{\f71\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Grolier 1;}{\f72\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Grolier 2;}{\f73\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}Grolier Bd 1;}{\f74\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}Grolier Bd 2;}{\f75\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}Grolier BdIt 1;}{\f76\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}Grolier BdIt 2;}{\f77\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Grolier It 1;}{\f78\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Grolier It 2;}{\f79\fnil\fcharset256\fprq2{\*\panose 04040505050a02020702}Harrington;}{\f80\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Helvetica Black;}{\f81\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Helvetica Compressed;}{\f82\fnil\fcharset256\fprq2{\*\panose 020b0806030902050204}Impact;}{\f83\fnil\fcharset256\fprq2{\*\panose 04020605060303030202}Imprint MT Shadow;}{\f84\fnil\fcharset256\fprq2{\*\panose 00000400000000000000}Inso GI1 SILDoulosL;}{\f85\fnil\fcharset256\fprq2{\*\panose 00000400000000000000}Inso GI1 SILDoulosL I;}{\f86\fnil\fcharset256\fprq2{\*\panose 00000400000000000000}Inso If1 SILDoulosL;}{\f87\fnil\fcharset256\fprq2{\*\panose 00000400000000000000}Inso If1 SILDoulosL I;}{\f88\fnil\fcharset256\fprq2{\*\panose 03010101010101010101}Kidprint;}{\f89\fnil\fcharset256\fprq2{\*\panose 040307050d0c02020703}Kino MT;}{\f90\fnil\fcharset256\fprq2{\*\panose 00000000000000000000}Lucida Blackletter;}{\f91\fnil\fcharset256\fprq2{\*\panose 02040602050505020304}Lucida Bright;}{\f92\fnil\fcharset256\fprq2{\*\panose 03010101010101010101}Lucida Calligraphy;}{\f93\fnil\fcharset256\fprq2{\*\panose 02060602050505020204}Lucida Fax;}{\f94\fnil\fcharset256\fprq2{\*\panose 03010101010101010101}Lucida Handwriting;}{\f95\fnil\fcharset256\fprq2{\*\panose 020b0602030504020204}Lucida Sans;}{\f96\fnil\fcharset256\fprq2{\*\panose 020b0509030504030204}Lucida Sans Typewriter;}{\f97\fnil\fcharset256\fprq2{\*\panose 020b0602060201020203}Lydian MT;}{\f98\fnil\fcharset256\fprq2{\*\panose 03020802060602070202}Matura MT Script Capitals;}{\f99\fnil\fcharset256\fprq2{\*\panose 02040503050201020203}Minion Web;}{\f100\fnil\fcharset256\fprq2{\*\panose 03090702030407020403}Mistral;}{\f101\fnil\fcharset256\fprq2{\*\panose 02070704070505020303}Modern No. 20;}{\f102\fnil\fcharset256\fprq2{\*\panose 020b0509030404040204}Monaco;}{\f103\fnil\fcharset256\fprq2{\*\panose 03010101010201010101}Monotype Corsiva;}{\f104\fnil\fcharset2\fprq2{\*\panose 01010601010101010101}Monotype Sorts;}{\f105\fnil\fcharset256\fprq2{\*\panose 020b0509000000000004}Monotype.com;}{\f106\fnil\fcharset2\fprq2{\*\panose 02000500000000000000}MT Extra;}{\f107\fnil\fcharset256\fprq2{\*\panose 020b0504020203020204}News Gothic MT;}{\f108\fnil\fcharset256\fprq2{\*\panose 04050602080702020203}Onyx;}{\f109\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Palatino;}{\f110\fnil\fcharset256\fprq2{\*\panose 02020502060505020804}Perpetua Titling MT;}{\f111\fnil\fcharset256\fprq2{\*\panose 040506030a0602020202}Playbill;}{\f112\fnil\fcharset256\fprq2{\*\panose 02060603020205020403}Rockwell;}{\f113\fnil\fcharset256\fprq2{\*\panose 02060903040505020403}Rockwell Extra Bold;}{\f114\fnil\fcharset256\fprq2{\*\panose 00000000000000000000}Sand;}{\f115\fnil\fcharset256\fprq2{\*\panose 020b0603050302020204}SportsFigures;}{\f116\fnil\fcharset256\fprq2{\*\panose 040409050d0802020404}Stencil;}{\f117\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}Swing;}{\f118\fnil\fcharset256\fprq2{\*\panose 020b0604030504040204}Tahoma;}{\f119\fnil\fcharset256\fprq2{\*\panose 00000000000000000000}Techno;}{\f120\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Textile;}{\f121\fnil\fcharset256\fprq2{\*\panose 020b0603020202020204}Trebuchet MS;}{\f122\fnil\fcharset256\fprq2{\*\panose 020b0604030504040204}Verdana;}{\f123\fnil\fcharset2\fprq2{\*\panose 05030102010509060703}Webdings;}{\f124\fnil\fcharset256\fprq2{\*\panose 020a0a07050505020404}Wide Latin;}{\f125\fnil\fcharset2\fprq2{\*\panose 05020102010507070707}Wingdings 2;}{\f126\fnil\fcharset2\fprq2{\*\panose 05040102010807070707}Wingdings 3;}{\f127\fnil\fcharset256\fprq2{\*\panose 05000000000000000000}ZapfDingbats BT;}}}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\widctlpar\adjustright \f4\cgrid \snext0 Normal;}{\s1\sb240\widctlpar\adjustright \b\f5\ul\cgrid \sbasedon0 \snext0 heading 1;}{\s2\sb120\widctlpar\adjustright \b\f5\cgrid \sbasedon0 \snext0 heading 2;}{\s3\li360\widctlpar\adjustright \b\f4\cgrid \sbasedon0 \snext0 heading 3;}{\s4\li360\widctlpar\adjustright \f4\ul\cgrid \sbasedon0 \snext0 heading 4;}{\s5\li720\widctlpar\adjustright \b\f4\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\s6\li720\widctlpar\adjustright \f4\fs20\ul\cgrid \sbasedon0 \snext0 heading 6;}{\s7\li720\widctlpar\adjustright \i\f4\fs20\cgrid \sbasedon0 \snext0 heading 7;}{\s8\li720\widctlpar\adjustright \i\f4\fs20\cgrid \sbasedon0 \snext0 heading 8;}{\s9\li720\widctlpar\adjustright \i\f4\fs20\cgrid \sbasedon0 \snext0 heading 9;}{\*\cs10 \additive Default Paragraph Font;}{\s15\li5040\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid \sbasedon0 \snext0 toc 8;}{\s16\li4320\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid \sbasedon0 \snext0 toc 7;}{\s17\li3600\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid \sbasedon0 \snext0 toc 6;}{\s18\li2880\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid \sbasedon0 \snext0 toc 5;}{\s19\li2160\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid \sbasedon0 \snext0 toc 4;}{\s20\li1440\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid \sbasedon0 \snext0 toc 3;}{\s21\li720\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid \sbasedon0 \snext0 toc 2;}{\s22\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid \sbasedon0 \snext0 toc 1;}{\s23\li2160\widctlpar\adjustright \f4\cgrid \sbasedon0 \snext0 index 7;}{\s24\li1800\widctlpar\adjustright \f4\cgrid \sbasedon0 \snext0 index 6;}{\s25\li1440\widctlpar\adjustright \f4\cgrid \sbasedon0 \snext0 index 5;}{\s26\li1080\widctlpar\adjustright \f4\cgrid \sbasedon0 \snext0 index 4;}{\s27\li720\widctlpar\adjustright \f4\cgrid \sbasedon0 \snext0 index 3;}{\s28\li360\widctlpar\adjustright \f4\cgrid \sbasedon0 \snext0 index 2;}{\s29\widctlpar\adjustright \f4\cgrid \sbasedon0 \snext0 index 1;}{\*\cs30 \additive \sbasedon10 line number;}{\s31\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \f4\cgrid \sbasedon0 \snext31 footer;}{\s32\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \f4\cgrid \sbasedon0 \snext32 header;}{\*\cs33 \additive \fs16\up6 \sbasedon10 footnote reference;}{\s34\widctlpar\adjustright \f4\fs20\cgrid \sbasedon0 \snext34 footnote text;}{\s35\li5760\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid \sbasedon0 \snext0 toc 9;}{\*\cs36 \additive \sbasedon10 page number;}{\s37\widctlpar\adjustright \f4\cgrid \sbasedon0 \snext0 Unnamed Style;}{\s38\ri960\sb160\sl280\slmult0\keep\widctlpar\adjustright \f22\cgrid \sbasedon0 \snext38 1text;}{\s39\sl240\slmult0\widctlpar\adjustright \f6\fs20\cgrid \sbasedon0 \snext39 cv;}}{\*\revtbl {Unknown;}}{\info{\title MPW IIGS ORCA/C\'aa }{\author Mike Westerfield}{\operator Mike Westerfield}{\creatim\yr2000\mo10\dy10\hr22\min1}{\revtim\yr2000\mo10\dy10\hr22\min1}{\printim\yr2000\mo10\dy10\hr21\min59}{\version2}{\edmins2}{\nofpages192}{\nofwords61728}{\nofchars351852}{\*\company Byte Works, Inc.}{\nofcharsws432098}{\vern99}}\margl1440\margr1440 \facingp\widowctrl\ftnbj\aenddoc\hyphhotz0\sprstsp\otblrul\brkfrm\sprstsm\truncex\nolead\msmcap\lytprtmet\hyphcaps0\viewkind1\viewscale100 \fet0\sectd \sbkodd\pgnrestart\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\f5\fs20 \par }}{\footerl \pard\plain \widctlpar\adjustright \f4\cgrid {\fs20 \par }}{\footerr \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\fs20 \par }}{\headerf \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\f5\fs20 \par }}{\footerf \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\fs20 \par }}{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \qc\widctlpar\tx450\tx720\adjustright \f4\cgrid {\b\fs72 \par \par }\pard \qc\widctlpar\adjustright {\b\i\fs72 MPW\~II}{\b\i\fs48 GS}{\b\i\fs72  ORCA/C}{\b\fs48\up20 \u8482\'aa}{\b\i\fs72  \par }{\b\i\shad\fs36 An MPW based C Compiler\par for\par Apple\~II}{\b\i\shad\fs28 GS}{\b\i\shad\fs36  Cross Development\par }\pard \widctlpar\tx450\tx720\adjustright {\fs20 \par \par \par \par \par \par \par \par }\pard \qc\widctlpar\tx450\tx720\adjustright {\b\fs36 \par \par \par \par \par Mike Westerfield\par }\pard \widctlpar\tx450\tx720\adjustright {\fs20 \par \par \par \par \par \par \par \par \par \par \par }\pard \qc\widctlpar\tx450\tx720\adjustright {\fs36 Byte Works}{\fs20\up12 \u174\'a8}{\fs36 , Inc.}{\par 8000 Wagon Mound Dr. N.W.\par Albuquerque, NM  87120\par (505) 898-8183\par MikeW50@AOL.COM\par }\pard \widctlpar\tx450\tx720\adjustright {\fs20 \par \par \par \par }\pard \qc\widctlpar\tx450\tx720\adjustright {\f12 \sect }\sectd \sbkodd\pgnlcrm\endnhere\titlepg\sectdefaultcl {\footerl \pard\plain \widctlpar\adjustright \f4\cgrid {\fs20 \chpgn \par }}{\footerr \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\fs20 \chpgn \par }}{\footerf \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\f5\fs20 \chpgn \par }}\pard\plain \qj\fi540\widctlpar\tx450\tx720\adjustright \f4\cgrid {\b\fs20 Limited Warranty}{\fs20  - Subject to the below stated limitations, Byte Works, Inc. hereby warrants that this program will load and run on the standard manufacturer's configuration for the computer listed for a period of thirty (30) days from date of purchase. Except for such warranty, this product is supplied on an "as is" basis without warranty as to merchantability or its fitness for any particular purpose. The limits of warranty extend only to the original purchaser.\par Neither Byte Works, Inc. nor the authors of this program are liable or responsible to the purchaser and/or user for loss or damage caused, or alleged to be caused, directly or indirectly by this software and its attendant documentation, including (but not limited to) interruption of service, loss of business, or anticipatory profits.\par }\pard \fi540\widctlpar\tx450\tx720\adjustright {\fs18 \par }\pard \widctlpar\adjustright {\fs20 Apple is a registered trademark of Apple Computer, Inc.\par MPW is a registered trademark of Apple Computer, Inc.\par Byte Works is a registered trademark of Byte Works, Inc.\par ORCA and ORCA/C are trademarks of Byte Works, Inc.\par \par Copyright 1989, 1991, 1992, 1994, 1995\par By The Byte Works, Inc.\par All Rights Reserved\par \par Master Set 1.0.0.0\par }\pard \fi540\widctlpar\adjustright {\fs20 \par }\pard \qc\widctlpar\adjustright {\f12\fs28 \sect }\sectd \sbkodd\pgnlcrm\endnhere\titlepg\sectdefaultcl {\headerl \pard\plain \widctlpar\adjustright \f4\cgrid {\f5\fs20 Table of Contents\par }}{\headerr \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\f5\fs20 Table of Contents\par }}{\footerl \pard\plain \widctlpar\adjustright \f4\cgrid {\f5\fs20 \chpgn \par }}{\footerr \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\f5\fs20 \chpgn \par }}\pard\plain \widctlpar\adjustright \f4\cgrid {\b\fs48 Table of Contents\par }{\par \par }\pard\plain \s22\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {\field{\*\fldinst { TOC \\f \\l "1-2"  }}{\fldrslt {Chapter 1 \endash  Overview of MPW\~II}{\fs20 GS}{ ORCA/C\tab 1\par }\pard\plain \s21\li720\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {What\rquote s In This Package\tab 1\par About the Manual\tab 1\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard\plain \s22\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {\field{\*\fldinst { TOC \\f \\l "1-2"  }}{\fldrslt {Chapter 2 \endash  Installation\tab 3\par }\pard\plain \s21\li720\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {Other Required Software\tab 3\par Installing MPW\~II}{\fs20 GS}{ ORCA/C\tab 3\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard\plain \s22\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {\field{\*\fldinst { TOC \\f \\l "1-1"  }}{\fldrslt {Chapter 3 \endash  The Command Line\tab 5\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard\plain \s22\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {\field{\*\fldinst { TOC \\f \\l "1-2"  }}{\fldrslt {Chapter 4 \endash  Writing Assembly Language Subroutines\tab 7\par }\pard\plain \s21\li720\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {Introduction\tab 7\par The Basics\tab 7\par Returning Function Values From Assembly Language Subroutines\tab 8\par Passing Parameters to Assembly Language Subroutines\tab 8\par Accessing C Variables from Assembly Language\tab 9\par Calling C Procedures and Functions from Assembly Language\tab 10\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard\plain \s22\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {\field{\*\fldinst { TOC \\f  }}{\fldrslt {Chapter 5 \endash  Program Symbols\tab 11\par }\pard\plain \s21\li720\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {Character Set\tab 11\par Identifiers\tab 11\par Reserved Words\tab 12\par Reserved Symbols\tab 12\par Continuation Lines\tab 13\par Constants\tab 13\par }\pard\plain \s20\li1440\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {Decimal Integers\tab 13\par Octal Integers\tab 14\par Hexadecimal Integers\tab 15\par Character Constants\tab 15\par String Constants\tab 16\par Escape Sequences\tab 17\par Real Numbers\tab 18\par }\pard\plain \s21\li720\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {White Space\tab 19\par Comments\tab 19\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard\plain \s22\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {\field{\*\fldinst { TOC \\f  }}{\fldrslt {Chapter 6 \endash  The Preprocessor\tab 21\par }\pard\plain \s21\li720\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {Syntax\tab 21\par Preprocessor Macros\tab 21\par Including Files\tab 24\par Precompiled Headers\tab 25\par Conditional Compilation\tab 26\par Line Numbers\tab 29\par Flagging Errors\tab 29\par Pragmas\tab 30\par }\pard\plain \s20\li1440\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {cda\tab 30\par cdev\tab 30\par databank\tab 31\par debug\tab 31\par expand\tab 32\par float\tab 33\par ignore\tab 33\par keep\tab 34\par lint\tab 34\par memorymodel\tab 35\par nba\tab 36\par nda\tab 36\par noroot\tab 37\par optimize\tab 37\par path\tab 39\par rtl\tab 39\par stacksize\tab 40\par toolparms\tab 40\par xcmd\tab 41\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard\plain \s22\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {\field{\*\fldinst { TOC \\f \\l "1-2"  }}{\fldrslt {Chapter 7 \endash  Basic Data Types\tab 43\par }\pard\plain \s21\li720\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {Integers\tab 43\par Reals\tab 43\par Pointers\tab 44\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard\plain \s22\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {\field{\*\fldinst { TOC \\f \\l "1-2"  }}{\fldrslt {Chapter 8 \endash  C Programs\tab 45\par }\pard\plain \s21\li720\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {The Anatomy of a C Program\tab 45\par The Function main\tab 45\par Argc and Argv\tab 45\par Separate Compilation\tab 46\par Interface Files\tab 46\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard\plain \s22\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {\field{\*\fldinst { TOC \\f \\l "1-2"  }}{\fldrslt {Chapter 9 \endash  Declarations\tab 49\par }\pard\plain \s21\li720\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {Declarations\tab 49\par Storage Classes\tab 49\par Type Specifiers\tab 51\par Enumerations\tab 53\par Arrays\tab 54\par Pointers\tab 55\par Structures\tab 56\par Unions\tab 59\par Initializers\tab 59\par Constructing Complex Data Types\tab 61\par Scope and Visibility\tab 62\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard\plain \s22\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {\field{\*\fldinst { TOC \\f  }}{\fldrslt {Chapter 10 \endash  Functions\tab 65\par }\pard\plain \s21\li720\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {Declaring a Function\tab 65\par Parameters\tab 67\par }\pard\plain \s20\li1440\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {Traditional C Parameters\tab 67\par Function Prototypes\tab 68\par }\pard\plain \s21\li720\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {Variable Length Parameter Lists\tab 69\par Common Mistakes With Parameters\tab 69\par How Parameters are Passed\tab 70\par Returning Values from Functions\tab 72\par Pascal Functions\tab 72\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard\plain \s22\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {\field{\*\fldinst { TOC \\f  }}{\fldrslt {Chapter 11 \endash  Expressions\tab 73\par }\pard\plain \s21\li720\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {Syntax\tab 73\par Operator Precedence\tab 74\par Terms\tab 74\par }\pard\plain \s20\li1440\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {L-values\tab 74\par Constants\tab 75\par Simple Variables\tab 75\par Arrays\tab 75\par Function Calls\tab 76\par Component Selection\tab 77\par Parenthesized Expressions\tab 78\par Postincrement and Postdecrement\tab 78\par }\pard\plain \s21\li720\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {Math Operators\tab 79\par }\pard\plain \s20\li1440\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {Addition\tab 79\par Subtraction\tab 79\par Multiplication\tab 80\par Division\tab 80\par Remainder\tab 80\par Unary Subtraction\tab 81\par Unary Addition\tab 81\par Prefix Increment\tab 81\par Prefix Decrement\tab 81\par Sizeof Operator\tab 82\par }\pard\plain \s21\li720\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {Comparison Operations\tab 82\par Logical Operations\tab 83\par Bit Manipulation\tab 83\par Assignment Operators\tab 84\par }\pard\plain \s20\li1440\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {Simple Assignment\tab 84\par Compound Assignment\tab 85\par Multiple Assignments\tab 86\par }\pard\plain \s21\li720\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {Pointers and Addresses\tab 86\par Sequential Evaluation\tab 86\par Conditional Expressions\tab 87\par Automatic Type Conversions\tab 87\par }\pard\plain \s20\li1440\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {Assignment Conversions\tab 87\par Function Argument Conversions\tab 88\par Unary Conversion Rules\tab 88\par Binary Conversion Rules\tab 88\par }\pard\plain \s21\li720\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {Type Casting\tab 89\par }\pard\plain \s20\li1440\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {Converting Integers to Integers\tab 89\par Converting Floating-Point Values to Integers\tab 89\par Converting Pointers to Integers\tab 89\par Converting Floating-Point Values to Other Floating-Point Formats\tab 90\par Converting Integers to Floating-Point Values\tab 90\par Converting to and from Enumerations\tab 90\par Converting Pointers to Pointers\tab 90\par Converting Integers to Pointers\tab 90\par Converting Arrays to Pointers\tab 91\par Converting Functions to Pointers\tab 91\par Converting to Void\tab 91\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard\plain \s22\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {\field{\*\fldinst { TOC \\f \\l "1-2"  }}{\fldrslt {Chapter 12 \endash  Statements\tab 93\par }\pard\plain \s21\li720\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {Compound Statements\tab 93\par Null Statements\tab 94\par Expression Statements\tab 94\par While Statement\tab 94\par Do Statement\tab 95\par For Statement\tab 95\par If Statement\tab 96\par Goto Statement\tab 96\par Switch Statement\tab 97\par Break and Continue\tab 98\par Return Statement\tab 98\par Segment Statement\tab 99\par Asm Statement\tab 100\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard\plain \s22\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {\field{\*\fldinst { TOC \\f \\l "1-2"  }}{\fldrslt {Chapter 13 \endash  Libraries\tab 103\par }\pard\plain \s21\li720\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {Overview of the Libraries\tab 103\par System Functions\tab 103\par Standard C Libraries\tab 107\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard\plain \s22\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {\field{\*\fldinst { TOC \\f \\l "1-2"  }}{\fldrslt {Appendix A \endash  Error Messages\tab 161\par }\pard\plain \s21\li720\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {Compilation Errors\tab 161\par Terminal Compilation Errors\tab 173\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard\plain \s22\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {\field{\*\fldinst { TOC \\f \\l "1-1"  }}{\fldrslt {Appendix B \endash  ANSI C\tab 175\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard\plain \s22\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {\field{\*\fldinst { TOC \\f \\l "1-1"  }}{\fldrslt {Appendix C \endash  ORCA/C on the Apple\~II}{\fs20 GS}{\tab 177\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard\plain \s22\ri720\widctlpar\tldot\tx8280\tqr\tx8640\adjustright \f4\cgrid {\field{\*\fldinst { TOC \\f \\l "1-1"  }}{\fldrslt {Index\tab 179\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\sect }\sectd \sbkodd\pgnrestart\endnhere\titlepg\sectdefaultcl {\headerl \pard\plain \widctlpar\adjustright \f4\cgrid {\f5\fs20 MPW\~II}{\f5\fs18 GS}{\f5\fs20  ORCA/C\par }}{\headerr \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\f5\fs20 Chapter 1:   Overview of ORCA/C for Nintendo\par }}{\footerl \pard\plain \widctlpar\adjustright \f4\cgrid {\f5\fs20 \chpgn \par }}{\footerr \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\f5\fs20 \chpgn \par }}{\footerf \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\f5\fs20 \chpgn \par }}\pard\plain \keepn\widctlpar\adjustright \f4\cgrid {\b\fs48 Chapter 1 \endash  Overview of MPW\~II}{\b\fs36 GS}{\b\fs48  ORCA/C\par }{\par }{\pard\plain \keepn\widctlpar\adjustright \v\f4\cgrid {\tc {\v }{\v Chapter 1 \endash  Overview of MPW\~II}{\v\fs20 GS}{\v  ORCA/C\tcl1}}}{\v \par }{\par }\pard \qj\fi360\widctlpar\adjustright {This chapter describes what is in this manual and the contents of the MPW\~II}{\fs20 GS}{ ORCA/C disk.\par \par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 What\rquote s In This Package}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 What\rquote s In This Package\tcl2}}}{\b\fs36 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {This package includes a version of ORCA/C for the Apple\~II}{\fs20 GS}{ which has been ported to run under MPW on a Macintosh computer. It includes the following items:\par \par }\pard \qj\fi-3600\li3600\widctlpar\adjustright {MPW\~II}{\fs20 GS}{ ORCA/C Documentation\tab This documentation, which describes installing ORCA/C under MPW and gives a complete technical description of the compiler.\par Tools:cciigs\tab The executable file for the compiler.\par ORCACLibraries:ORCACLib\tab The run-time library file used with the compiler. As delivered, these libraries are appropriate for creating stand-alone programs for the Apple\~II}{\fs20 GS}{. With minor adjustments, they can be used on any 65816 platform.\par ORCACDefs:\u8776\'c5\tab These are the header files for the Apple\~II}{\fs20 GS}{ toolbox, ANSI C, and some common UNIX I/O libraries.\par Source:ORCALib:\u8776\'c5\tab Source code and build files for the run-time libraries.\par Source:cnv:\u8776\'c5\tab Binaries and source code for the utility used to preprocess the library files. This program is included for completeness, but is probably not needed. It was used as one step in moving the source code for the run-time libraries from ORCA/M format to MPW\~II}{\fs20 GS}{ Assembly format. It is designed to insert comment characters and convert expanded macro invocations to comments.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 About the Manual}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 About the Manual\tcl2}}}{\b\fs36 \par }\pard \keepn\widctlpar\adjustright {\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Chapter 2 covers installing ORCA/C and describes other required software.\par Chapter 3 describes the command line flags and options supported by MPW\~II}{\fs20 GS}{ ORCA/C.\par Chapter 4 describes the calling conventions used by ORCA/C. This information is useful for understanding the subroutine libraries and for writing assembly language functions that are called from C, access C variables, or call C functions.\par The remaining chapters are a complete description of the C language as implemented in ORCA/C. With a few exceptions, ORCA/C is an implementation of ANSI C; however, even the ANSI C standard leaves some room for differences in compiler implementations. For this reason, the complete C language description is included to resolve any ambiguity regarding how a particular feature is implemented.\par Appendix B summarizes the differences between ORCA/C and ANSI C.\par Appendix C summarizes the differences between this implementation of ORCA/C and the native Apple\~II}{\fs20 GS}{ implementation.\par }\pard \qc\widctlpar\adjustright {\f12\fs28 \sect }\sectd \sbkodd\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\f5\fs20 Chapter 2:  Installation\par }}{\footerl \pard\plain \widctlpar\adjustright \f4\cgrid {\f5\fs20 \chpgn \par }}\pard\plain \qj\keepn\widctlpar\adjustright \f4\cgrid {\b\fs48 Chapter 2 \endash  Installation\par }\pard \keepn\widctlpar\adjustright {\par }{\pard\plain \keepn\widctlpar\adjustright \v\f4\cgrid {\tc {\v }{\v Chapter 2 \endash  Installation\tcl1}}}{\v \par }{\par }\pard \qj\fi360\widctlpar\adjustright {This chapter describes the supporting software needed to use ORCA/C, and how to install ORCA/C.\par }\pard \keepn\widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Other Required Software}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 Other Required Software\tcl2}}}{\b\fs36 \par }\pard \keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {MPW\~II}{\fs20 GS}{ ORCA/C was designed for, and compiled under, the release version of MPW tools contained in E.T.O. 13. You should start with a complete MPW installation.\par ORCA/C generates OMF files that are processed by the MPW\~II}{\fs20 GS}{ Linker to create Apple\~II}{\fs20 GS}{ executable files. Apple\~II}{\fs20 GS}{ executable files can be converted to raw binary files using MakeBin\~II}{\fs20 GS}{ . Both utilities, as well as several others that may prove useful, are in the APDA product }{\i MPW\~II}{\i\fs20 GS}{\i  Tools Version 1.3}{.\par The libraries are assembled with }{\i MPW\~II}{\i\fs20 GS}{\i  Assembler Version 1.2}{. This assembler may also prove useful for developing large or complex subroutines.\par }\pard \widctlpar\adjustright {\ulw \par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Installing MPW\~II}{\b\fs28 GS}{\b\fs36  ORCA/C}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 Installing MPW\~II}{\b\v\fs28 GS}{\b\v\fs36  ORCA/C\tcl2}}}{\b\fs36 \par }\pard \keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {MPW should be installed before installing ORCA/C. After installing MPW, follow these steps:\par \par }\pard \qj\fi-360\li720\widctlpar\adjustright {1.\tab Copy the ORCACLibraries and ORCACDefs folders from the MPW IIGS ORCAC 1 disk to the installed MPW folder.\par 2.\tab Copy the file cciigs from MPW IIGS ORCAC 2:Tools:cciigs to the Tools folder of MPW.\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\fi-1800\li1800\ri1080\widctlpar\tx440\adjustright {\f21\fs22 \u-3981\'73}{\b \tab Warning}{\tab Do not copy the entire Tools folder. Doing so will erase the original contents of the MPW Tools folder, and many of those tools are required for use of ORCA/C.\~\~}{\f21\fs14 \u-3981\'73}{\b \par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\fi-360\li720\widctlpar\adjustright {3.\tab Create a folder named Source in any convenient location. Copy the files from the Source folders on MPW IIGS ORCAC 2 MPW IIGS ORCAC 3 into this source folder, then copy the files from MPW IIGS ORCAC 3:Source:ORCALib into the ORCALib folder in the Source folder you created.\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\fi-1800\li1800\ri1080\widctlpar\tx440\adjustright {\f21\fs22 \u-3981\'73}{\b \tab Warning}{\tab There is a folder called ORCALib in the source folder on both disks. Be sure to copy the files from the folder, rather than the folder itself, when you copy the files from MPW IIGS ORCAC 3. If you copy the folder, you will erase the files copied from MPW\~IIGS\~ORCAC\~2.\~\~}{\f21\fs14 \u-3981\'73}{\b \par }\pard \qc\widctlpar\adjustright {\par }\pard \fi-360\li720\widctlpar\adjustright {\tab The various Make files will need to be updated based on the actual location of the Source folder.}{\f12\fs28 \sect }\sectd \sbkodd\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\f5\fs20 Chapter 2:  Installation\par }}{\footerl \pard\plain \widctlpar\adjustright \f4\cgrid {\f5\fs20 \chpgn \par }}\pard\plain \keepn\widctlpar\adjustright \f4\cgrid {\b\fs48 Chapter 3 \endash  The Command Line\par }\pard \qj\keepn\widctlpar\adjustright {\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\tc {\v }{\v Chapter 3 \endash  The Command Line\tcl1}}}{\par }\pard \widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The command line for MPW\~II}{\fs20 GS}{ ORCA/C has the following form:\par \par }{\f6\fs20 \tab cciigs <flags> <source file>\par }{\par The flags can be any of the following, in any order, but all options must appear before the source file name.\par \par }\pard \qj\fi-2880\li3240\widctlpar\tx3960\adjustright {-b\tab Turns on generation of inline debug code. This works like\par \par }{\f6\fs20 \tab \tab #pragma debug -1\par }{\par \tab placed at the beginning of the source file.\par \par -d <name> [ \lquote =\lquote  <token> ]\tab Defines a macro from the command line. If the equal character and token are omitted, this is equivalent to placing\par \par }{\f6\fs20 \tab \tab #define <name> 1\par }{\par \tab at the start of the source file. If the token is included, this is equivalent to placing\par \par }{\f6\fs20 \tab \tab #define <name> <token>\par }{\par \tab at the start of the source file. }{\f6\fs20 <token>}{ can be an identifier, a numeric constant with an optional leading sign, or a string.\par \par -i <path>\tab Adds an include file to the search paths used to resolve #include directives. This works exactly like\par \par }{\f6\fs20 \tab \tab #pragma path <path>\par }{\par \tab at the start of the source file.\par \par -l\tab The source file is echoed to standard out.\par \par -o\tab Turns optimization on. This is equivalent to\par \par }{\f6\fs20 \tab \tab #pragma optimize -1\par }{\par \tab at the start of the source file.\par \par -p\tab Tells the compiler to print copyright, version and progress information to standard out.\par \par -r\tab Forces the compiler to rebuild the .sym symbol file, even if the modification dates of the source file and .sym file indicate it isn\rquote t necessary.\par \par -s\tab Tells the compiler to print symbol table and intermediate code to standard out. This flag is used in conjunction with internal debug code, which buts be enabled before compiling the compiler before this flag will have an affect.\par \par -y\tab Tells the compiler to ignore the .sym file. Any .sym file present is not used, and no new .sym file is generated.\par \par -w\tab Tells the compiler to pause after printing an error. Compilation continues when you press a key, and aborts if you press Command-.\par }\pard \qc\widctlpar\adjustright {\f12\fs28 \sect }\sectd \sbkodd\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\f5\fs20 Chapter 4:  Writing Assembly Language Subroutines\par }}\pard\plain \keepn\widctlpar\adjustright \f4\cgrid {\b\fs48 Chapter 4 \endash  Writing Assembly Language Subroutines\par }\pard \qj\keepn\widctlpar\adjustright {\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\tc {\v }{\v Chapter 4 \endash  Writing Assembly Language Subroutines\tcl1}}}{\par }\pard \widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {This chapter describes the subroutine calling convention used by ORCA/C. Using this information, you can write assembly language functions that can be called from ORCA/C, and you can call ORCA/C functions from assembly language.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Introduction}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Introduction\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {There are two ways to mix assembly language with ORCA/C. One way is to use the built-in mini-assembler that is a part of ORCA/C. The mini-assembler is suitable for tasks where a few lines of assembly are needed in a program that is mostly C. When several dozen lines or several subroutines must be coded in assembly language, you can also choose the MPW\~II}{\fs20 GS}{ Assembler}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v MPW\~II}{\v\fs20 GS}{\v  Assembler}}}{, which offers more power for larger assembly language tasks. This chapter deals with using the MPW\~II}{\fs20 GS}{ Assembler to write entire functions or libraries in assembly language. Chapter 12 gives details on using the asm statement to embed assembly language code in a C program.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 The Basics}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 The Basics\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 \par }\pard \qj\fi360\widctlpar\adjustright {Calling an assembly language subroutine from C is actually quite easy. For our first example, we will take the simplest case:  a function returning void defined in assembly language that has no parameters and does not use any global variables from C.\par We will define a small function to clear the keyboard strobe. This is one of those tasks that is difficult to do from C, yet takes only four lines of assembly language. You might want to call this function from a real program\emdash the effect is to erase any character that the user has typed, but that has not yet been processed by a scan library call.\par The C program must declare the function as }{\f6\fs20 extern}{. This is how you tell the compiler that the function appears outside of the C part of the program. A program that simply calls the subroutine would look like this:\par \par }\pard \li360\keepn\widctlpar\adjustright {\f6\fs20 \tab extern void Clear(void);\par \par \tab int main(void)\par \tab \{\par \tab Clear();\par \tab \}\par }\pard \qj\fi360\widctlpar\adjustright {\par The assembly language function is:\par \par }\pard \qj\li360\keepn\widctlpar\tx1440\tx2160\adjustright {\f6\fs20 \tab case\tab on\par ; \par ;  Clear the keyboard strobe\par ;\par \tab Export\tab Clear\par Clear\tab proc\par \tab sep\tab #$20\par \tab sta\tab >$C010\par \tab rep\tab #$20\par \tab rtl\par }\pard \qj\li360\widctlpar\tx1440\tx2160\adjustright {\f6\fs20 \tab endp\par \tab end\par }\pard \qj\fi360\widctlpar\adjustright {\par An important point to remember is that C is case sensitive. Like most languages, assembly language is normally case insensitive. The case on directive at the start of the assembly language program makes the assembler case sensitive, like C. If you leave this directive out, you must always use uppercase characters when referring to the function from C.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Returning Function Values From Assembly Language Subroutines}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Returning Function Values From Assembly Language Subroutines\tcl2}}}{\b\fs36 \par }\pard \qj\fi360\widctlpar\adjustright {\b \par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v assembly language\: returning function values}}}{Function values are returned in the registers. This means that within your assembly language subroutine you would load the registers with the values that you want to return to your C program. Char, int and unsigned int values are returned in the accumulator as two-byte quantities. Long integers and pointers are returned in the X and A registers, with the most significant word in X and the least significant word in A. Real numbers, both single and double precision, are returned as pointers to floating-point values which have been stored in SANE's extended format. This format is described in }{\i Apple Numerics Manual. }{Structures, unions and arrays are returned as a pointer to the first byte of the object. As with other types of pointers, the most significant word should be placed in X and the least significant word should be stored in A. \par Please note that characters only require one byte of storage, but are returned in a two-byte register. Be sure to zero the most significant byte of the value that you return.\par For a complete discussion of the internal formats of numbers, see Chapters 5 and 7. Basically, though, they correspond to what you are used to in assembly language.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Passing Parameters to Assembly Language Subroutines}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Passing Parameters to Assembly Language Subroutines\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\tx720\tx2160\tx2880\tx4320\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v parameters\: passing}}}{ORCA/C places the parameters which appear in a subroutine call on the stack, in the opposite of the order that they appear in the parameter list. It then issues a JSL to your subroutine.\par The value that is on the stack depends on the type of the value being passed. Int, unsigned int, long, unsigned long, characters, enumerations, structures, unions and pointers appear on the stack as actual values. The normal unary conversions are performed before the value is placed on the stack. Basically, that means that character values are expanded to two bytes before they are pushed, while two-byte and four-byte values are pushed on the stack as is. Structures and unions are placed on the stack in the same format that they are stored in memory, while floating-point values are pushed on the stack as extended format SANE numbers. Arrays and string parameters (which are actually just a special form of an array) are passed as an address that points to the first byte of the value.\par Consider this C program fragment:\par }\pard \qj\fi360\widctlpar\tx720\tx2160\tx2880\tx4320\adjustright {\par }\pard \qj\li360\keepn\widctlpar\adjustright {\f6\fs20 ...\par \par void doSomething(z, ch, i);\par \par int i;\par char ch;\par float *z;\par \par ...\par \par i = 3;\par ch = 'a';\par *z = 5.6;\par doSomething (&z, ch, i);\par \par }\pard \qj\li360\widctlpar\adjustright {\f6\fs20 ...\par }\pard \qj\fi360\widctlpar\adjustright {\par When doSomething is called, the stack will look like this:\par \par }\pard \qc\widctlpar\adjustright {\fs28 {\pict{\*\picprop\shplid1025{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex66\picscaley66\piccropl0\piccropr0\piccropt0\piccropb0\picw487\pich354\picwgoal9740\pichgoal7080\macpict\bliptag-1105204965\blipupi72{\*\blipuid be1fe91b1bdb95c60ea0b67f6be0e645}05b900000000016201e71101a10064000c574f524400000000016201e701000a00000000016201e7200002006d00da006d200002001c00da001c220041001c510022000b001c5100a10096000c01000000010000000000000003364f0d000c2e0004000000002b031e03203131a00097a10096000c010000000100000000000000280037000203203130a00097a10096000c0100000001000000000000002b091e0139a00097220077001c51002200e3001c5100220026001c09002200260064090022005c001c090022005c00640900220092006409002200ad006409002200fe001c09002200c8001c09002200ad001c09002200920025f700a10096000c01000000010000000000000028001f00410130a00097a10096000c0100000001000000000000002a1b0133a00097a10096000c0100000001000000000000002a1b0130a00097a10096000c010000000100000000000000280070003d03276127a00097a10096000c010000000100000000000000280070000b0138a00097a10096000c01000000010000000000000028005500803a546865207365636f6e6420706172616d657465722069732061206368617261637465722e20204974732076616c756520697320706173736564202a10386f6e2074686520737461636b20616e6420616c736f2072657175697265732074776f206279746573206f6620737461636b2073706163652ea00097a10096000c01000000010000000000000028008b000b0137a00097a10096000c0100000001000000000000002a1b0136a000972000b6001c0161001c2000b6006d0161006da10096000c0100000001000000000000002a1b0135a00097a10096000c0100000001000000000000002a1b0134a00097220134001c510022014f001c5100a10096000c0100000001000000000000002a1b0133a00097a10096000c0100000001000000000000002a1b0132a00097a10096000c0100000001000000000000002a1b0131a00097a10096000c0100000001000000000000002a1b0130a0009722011e001c09002200fe006409002200c800640900a10096000c01000000010000000000000028008b00803554686520746869726420706172616d6574657220697320612063616c6c206279207265666572656e6365206f662061207265616c0d2a10316e756d6265722e202048657265206120706f696e74657220746f20746865206e756d626572206973207061737365642e0d2a102b506f696e74657273207265717569726520666f7572206279746573206f6620737461636b2073706163652ea00097a10096000c01000000010000000000000028008a003607706f696e746572a00097a10096000c0100000001000000000000002b081d02746fa00097a10096000c0100000001000000000000002b0317017aa00097a10096000c0100000001000000000000002800f700370672657475726ea00097a10096000c01000000010000000000000028011500340761646472657373a0009722011e00640900a10096000c01000000010000000000000028001f00803b54686520666972737420706172616d6574657220697320616e20696e74656765722e20204974732076616c756520697320706173736564206f6e0d2a103074686520737461636b20616e642072657175697265732074776f206279746573206f6620737461636b2073706163652ea00097a10096000c0100000001000000000000002b02c83a46696e616c6c792c207765206172652063616c6c656420776974682061204a534c2c20736f207468652072657475726e2076616c75652069730d2a103661742074686520746f70206f662074686520737461636b20616e642075736573207468726565206279746573206f6620737461636b0d2a100673706163652ea0009774001e014300820149008e014600820143008e0146008e0149008e01460082220146008e0c00a10096000c0100000001000000000000002b27330d537461636b20706f696e746572a00097ff}}{\par }\pard \qj\fi360\widctlpar\adjustright {\par If changed, the direct page register and data bank register must be restored before returning to the calling function. The function is always called with long registers, and you must return control to the caller with long registers.\par The assembly language function is responsible for removing parameters from the stack before returning to the calling function.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Accessing C Variables from Assembly Language}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Accessing C Variables from Assembly Language\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\tx720\tx2160\tx2880\tx4320\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v assembly language\:accessing global variables}}}{All global variables which can be accessed from outside of a C source file by another C function are available from assembly language. If you are using the small memory model, all C variables are accessed using absolute addressing. In the large memory model all variables must be accessed using long addressing.\par It is also possible to define variables in assembly language that can be accessed from C. To do that, define the variable as external in the C program, just as you would if the variable was in a separately compiled C function. Then define the variable in assembly language. The assembly language variable must be defined globally; that is, it must be the name of a code segment, or it must be declared as global via the entry directive. If you are using the small memory model, the variable must be placed in the blank segment.\par The C language uses case sensitive variable names. The assembler defaults to case insensitive variables, passing all variable names to the linker as uppercase strings. To make the assembler case sensitive, use the assembler's case directive.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Calling C Procedures and Functions from Assembly Language}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Calling C Procedures and Functions from Assembly Language\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\tx720\tx2160\tx2880\tx4320\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v assembly language\:calling C procedures and functions}}}{Calling a C function from assembly language is extremely straightforward. You simply push any required parameters onto the stack and issue a JSL to the function you want to call. The one trick is that you must push the parameters on the stack staring with the last parameter, and working toward the first. Two-byte values are returned to you in the accumulator, four-byte values are returned with the least significant word in the accumulator and the most significant word in the X register, and real and double values are returned as pointers to ten-byte SANE extended format numbers. Note that real numbers should be passed as ten-byte SANE extended format numbers. Structures, arrays and unions are also returned as a pointer to the first byte of the object.\par }\pard \widctlpar\adjustright {\fs28 \sect }\sectd \sbkodd\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\f5\fs20 Chapter 5:  Program Symbols\par }}\pard\plain \widctlpar\adjustright \f4\cgrid {\b\fs48 Chapter 5 \endash  Program Symbols\par }\pard \qj\ri720\widctlpar\adjustright {\pard\plain \qj\ri720\widctlpar\adjustright \v\f4\cgrid {\tc {\v }{\v Chapter 5 \endash  Program Symbols\tcl1}}}{\v \par }{\par \par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v tokens\bxe }}}{\*\bkmkstart bk0}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v identifiers}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v constants}}}{C programs are made up of a series of program symbols called tokens. Tokens are the words used to write a program. They consist of identifiers, symbols, and constants.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Character Set}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 Character Set\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v character set\bxe }}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v extended characters}}}{ORCA/C supports the extended Apple character set. All typable characters are accepted in the source stream, and all can be passed through the standard output channels.\par Some of the special characters are also allowed as C source stream tokens. These international alphabetic characters are accepted wherever the 26 uppercase and lowercase ASCII letters would normally be allowed:\par \par }\pard \qj\widctlpar\adjustright {\tab \u196\'80\tab \u197\'81\tab \u199\'82\tab \u201\'83\tab \u209\'84\tab \u214\'85\tab \u220\'86\tab \u225\'87\tab \u224\'88\tab \u228\'8a\tab \u227\'8b\tab \u229\'8c\tab \u231\'8d\tab \u233\'8e\tab \u232\'8f\tab \u234\'90\tab \u235\'91\tab \u237\'92\tab \u236\'93\tab \u238\'94\tab \u239\'95\tab \u241\'96\tab \u243\'97\tab \u242\'98\tab \u244\'99\tab \u246\'9a\tab \u245\'9b\tab \u250\'9c\tab \u249\'9d\tab \u251\'9e\tab \u252\'9f\tab \u198\'ae\tab \u216\'af\tab \u170\'bb\tab \u186\'bc\tab \u230\'be\tab \u248\'bf\tab \u192\'cb\tab \u195\'cc\tab \u213\'cd\tab \u338\'ce\tab \u339\'cf\tab \u255\'d8\tab \u223\'a7\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\widctlpar\adjustright {These characters are treated as distinct alphabetic characters, just as uppercase and lowercase letters are distinct in C. For example, }{\f6\fs20 \u252\'9f}{ and }{\f6\fs20 u}{ are not the same character, so }{\f6\fs20 run}{ and }{\f6\fs20 r\u252\'9fn}{ are not the same identifier.\par }\pard \qj\fi360\widctlpar\adjustright {Six extended characters are also accepted as equivalents to C tokens:\par \par }\pard \li720\ri6300\widctlpar\brdrt\brdrs\brdrw15 \brdrb\brdrs\brdrw15 \tx1800\adjustright {character\tab C equivalent\par }\pard \li720\ri6300\widctlpar\tx1800\adjustright {\u247\'d6\tab /\par \u171\'c7\tab <<\par \u187\'c8\tab >>\par \u8800\'ad\tab !=\par \u8804\'b2\tab <=\par \u8805\'b3\tab >=\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Identifiers}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 Identifiers\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v identifiers\bxe }}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v case sensitivity}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v identifiers\:case sensitivity}}}{Identifiers in C start with an alphabetic character or underscore and are followed by zero or more alphabetic characters, numeric characters, or underscores. C is a case sensitive language, which means that the identifiers }{\f6\fs20 matrix}{ and }{\f6\fs20 Matrix}{ are actually two different identifiers.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v identifiers\:length}}}{ORCA/C imposes a limit of 255 characters on the length of any single identifier.\par ORCA/C allows the use of characters from Apple\rquote s extended chacter set in identifiers. They are treated as new alphabetic characters, distinct from the original characters. For example, }{\f6\fs20 r\u252\'9fn}{ is a legal identifier, but it is different from the identifier }{\f6\fs20 run}{. The extended characters that are treated as alphabetic characters are:\par \par }\pard \qj\fi720\widctlpar\adjustright {\u196\'80\tab \u197\'81\tab \u192\'cb\tab \u195\'cc\tab \u199\'82\tab \u201\'83\tab \u209\'84\tab \u214\'85\tab \u213\'cd\tab \u216\'af\tab \u220\'86\tab \u198\'ae\tab \u338\'ce\tab \u225\'87\tab \u224\'88\tab \u227\'8b\tab \u229\'8c\tab \u231\'8d\tab \u233\'8e\tab \u232\'8f\tab \u234\'90\tab \u235\'91\tab \u237\'92\tab \u236\'93\tab \u238\'94\tab \u239\'95\tab \u241\'96\tab \u243\'97\tab \u242\'98\tab \u244\'99\tab \u246\'9a\tab \u245\'9b\tab \u248\'bf\tab \u250\'9c\tab \u249\'9d\tab \u251\'9e\tab \u252\'9f\tab \u255\'d8\tab \u223\'a7\tab \u170\'bb\tab \u186\'bc\tab \u230\'be\tab \u339\'cf\par }\pard \qj\fi360\widctlpar\adjustright {\par Some examples of legal C identifiers are shown below. They each represent a different identifier.\par }\pard \qj\fi540\widctlpar\adjustright {\par }\pard \qj\li360\keepn\widctlpar\tx1520\tx2700\tx3860\tx5040\tx6200\adjustright {\f6\fs20 main\tab array\tab myVar\tab myvar\tab _subroutine\tab my_var\tab \par }\pard \qj\li360\widctlpar\tx1520\tx2700\tx3860\tx5040\tx6200\adjustright {\f6\fs20 x1\tab x348\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Reserved Words}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Reserved Words\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v reserved words\bxe }}}{Reserved words are identifiers that have special meaning in C. Unless a reserved word is redefined as a preprocessor macro, it can only be used for the meaning that C assigns to it, except that reserved words can appear in comments or string constants. The reserved words in C are shown below. The reserved words that are underlined are reserved in ORCA/C, but not in ANSI C.\par \par }\pard \qj\li360\keepn\widctlpar\tx1620\tx2880\tx4140\tx5400\tx6660\tx7920\adjustright {\f6\fs20 auto\tab }{\f6\fs20\ul asm}{\f6\fs20 \tab break\tab case\tab char\tab }{\f6\fs20\ul comp}{\f6\fs20 \tab const\par continue\tab default\tab do\tab double\tab else\tab enum\tab }{\f6\fs20\ul extended}{\f6\fs20 \par extern\tab float\tab for\tab goto\tab if\tab }{\f6\fs20\ul inline}{\f6\fs20 \tab int\par long\tab }{\f6\fs20\ul pascal}{\f6\fs20 \tab register\tab return\tab }{\f6\fs20\ul segment}{\f6\fs20 \tab short\tab signed\par sizeof\tab static\tab struct\tab switch\tab typedef\tab union\tab unsigned\par }\pard \qj\li360\widctlpar\tx1620\tx2880\tx4140\tx5400\tx6660\tx7920\adjustright {\f6\fs20 void\tab volatile\tab while\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Reserved Symbols}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Reserved Symbols\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v reserved symbols\bxe }}}{Reserved symbols are the punctuation of the C language. Reserved symbols are used as mathematical operators, for forming array subscripts and parameter lists, for separating statements, and so forth. With some restrictions, reserved symbols can also be used in comments, string constants, and characters constants. See the sections below for details.\par The reserved symbols in C are:\par \par }\pard \qj\li360\keepn\widctlpar\tx1080\tx1800\tx2520\tx3240\tx3960\tx4680\tx5400\tx6120\tx6840\adjustright {\f6\fs20 !\tab %\tab ^\tab &\tab *\tab -\tab +\tab =\tab ~\tab |\tab \par .\tab <\tab >\tab /\tab ?\tab ->\tab ++\tab --\tab <<\tab >>\tab \par <=\tab >=\tab ==\tab !=\tab &&\tab ||\tab +=\tab -=\tab *=\tab /=\tab \par %=\tab <<=\tab >>=\tab &=\tab ^=\tab |=\tab (\tab )\tab [\tab ]\tab \par }\pard \qj\li360\widctlpar\tx1080\tx1800\tx2520\tx3240\tx3960\tx4680\tx5400\tx6120\tx6840\adjustright {\f6\fs20 \{\tab \}\tab ,\tab ;\tab :\tab \par }\pard \qj\fi360\widctlpar\adjustright {\par In some older versions of C, the assignment operators (like +=) could be specified with the equal sign first, as in =+. This caused some semantic problems in the language; most modern compilers, including ORCA/C, do not permit the equal sign to come first. Some compilers also permit white space to appear between the characters, as in + =. ORCA/C does not allow this, either.\par Six tokens can also be represented using a single character from the extended character set. They are:\par \par }\pard \li3240\ri3780\widctlpar\brdrt\brdrs\brdrw15 \brdrb\brdrs\brdrw15 \tx4320\adjustright {character\tab C equivalent\par }\pard \li3240\ri3780\widctlpar\tx4320\adjustright {\u247\'d6\tab /\par \u171\'c7\tab <<\par \u187\'c8\tab >>\par \u8800\'ad\tab !=\par \u8804\'b2\tab <=\par \u8805\'b3\tab >=\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v trigraphs\bxe }}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v string constants\: trigraphs}}}{Some older computers do not support complete character sets on their terminals or printers. For that reason, the C language includes trigraphs. A trigraph is a sequence of three characters, two question marks and a third character, which can replace another character. While there is no reason to use trigraphs on the Apple\~II}{\fs20 GS}{, you should be aware of their existence, since they can occasionally cause problems with string constants and character constants. The trigraphs, along with the character they represent, are shown below.\par \par }\pard \qj\li3240\ri4140\keepn\widctlpar\brdrt\brdrs\brdrw15 \brdrb\brdrs\brdrw15 \adjustright {trigraph\tab character\par }\pard \qj\li3240\ri4140\keepn\widctlpar\adjustright {\f6\fs20 ??(\tab [\par ??)\tab ]\par ??<\tab \{\par ??>\tab \}\par ??/\tab \\\par ??!\tab |\par ??'\tab ^\par ??-\tab ~\par }\pard \qj\li3240\ri4140\widctlpar\adjustright {\f6\fs20 ??=\tab #\par }\pard \qj\fi360\widctlpar\adjustright {\par For example, the following two lines are completely equivalent in C.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 while (~one | theOther) printf("Huh|\\n");\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 while (??- one ??! theOther) printf("Huh??!\\n");\par }{\par }\pard \qj\widctlpar\adjustright {Note the trigraph that appears in the string. This is one place where trigraphs can cause problems. The idea in the example shown was probably to write two question marks and an exclamation point, but this was translated into a single vertical bar. To avoid this, you can use \\? in the string constant to represent one of the question marks, as in\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 while (~one | theOther) printf("Huh?\\?!\\n");\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Continuation Lines}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Continuation Lines\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v continuation lines}}}{If a back slash character (\\) appears as the last character on a line, the line is continued from the first character of the next line. Lines may be continued in the preprocessor, in string constants, between any two tokens, or even in the middle of a token.\par See the section discussing string constants for details on continuing strings. See Chapter 6 for details on using continuation lines in the preprocessor.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Constants}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Constants\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Constants are used to place numbers and strings into the source code of the program. Each kind of constant has its own unique format, so they are discussed separately.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Decimal Integers}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Decimal Integers\tcl3}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Decimal integers come in two sizes and two kinds. The two sizes are referred to as integer and long integer, while the two kinds are signed and unsigned.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v integers\:constants}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v constants\:integer}}}{Signed integers consist of one to five digits. The number represented must range from 0 to 32767, and with the exception of the number 0, no number can start with a leading zero. (See octal integers, below, for the reason for this restriction.)  You may use a leading - character to form a negative number, although the - character and the number are technically two separate tokens. In practice, this technical distinction is rarely important.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v long integers\:constants}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v constants\:long integer}}}{If the number exceeds 32767, or if it is followed by an l or L, the number becomes a long integer. Long integers can range from 0L to 2147483647L. Please note that the l or L character must follow immediately after the last digit, with no intervening white space characters.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v unsigned integers\:constants}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v constants\:unsigned integer}}}{Unsigned integers are integers which are followed by a u or U. Unsigned integers can range from 0U to 65535U. Unsigned integers have the same effect on the type of an expression as an unsigned variable; see Chapter 11 for details.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v unsigned long integers\:constants}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v constants\:unsigned long integer}}}{Unsigned long integers include any unsigned integer larger than 65535U, as well as any unsigned integer with an l or L appearing either before or after the u or U. Unsigned long integers can range from 0UL to 4294967295UL. As with unsigned integers, using an unsigned long integer constant will affect the type of the expression.\par The table below shows some examples of legal decimal constants.\par \par }\pard \qj\li360\ri1440\keepn\widctlpar\brdrt\brdrs\brdrw15 \brdrb\brdrs\brdrw15 \tx1800\tx3240\tx4680\adjustright {integer\tab unsigned integer\tab long integer\tab unsigned long integer\par }\pard \qj\li360\ri1440\keepn\widctlpar\tx1800\tx3240\tx4680\adjustright {\f6\fs20 0\tab 0U\tab 0L\tab 0LU\par 35\tab 35u\tab 35l\tab 35ul\par 32767\tab 65535u\tab 100000\tab 100000u\par }\pard \qj\li360\ri1440\widctlpar\tx1800\tx3240\tx4680\adjustright {\f6\fs20 600\tab 600U\tab 2147483647l\tab 4294967295ul\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Octal Integers}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Octal Integers\tcl3}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v integers\:constants}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v constants\:integer}}}{Octal numbers are integers represented in base eight, rather than the more familiar base ten. Octal numbers are made up of the digits 0 to 7. In C, octal}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v octal}}}{ numbers are distinguished from decimal numbers by a leading zero. Any number whose first character is zero is interpreted as an octal number in C, and may not contain the digits 8 or 9. This can lead to unexpected results if you are not aware of this convention. For example, the statement\par \par }{\f6\fs20 printf("%d\\n", 010);\par }{\par }\pard \qj\widctlpar\adjustright {will print 8 to the screen, since 010 is 8 in base 8.\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v unsigned long integers\:constants}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v constants\:unsigned long integer}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v unsigned integers\:constants}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v constants\:unsigned integer}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v long integers\:constants}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v constants\:long integer}}}{As with decimal integers, octal integers can be long or short, signed or unsigned. The range of integers allowed in each representation are show below.\par \par }\pard \qj\li360\keepn\widctlpar\tx2520\tx3960\adjustright {\f6\fs20 int\tab 0\tab 077777\par unsigned int\tab 0\tab 0177777u\par long\tab 0\tab 017777777777L\par }\pard \qj\li360\widctlpar\tx2520\tx3960\adjustright {\f6\fs20 unsigned long\tab 0\tab 037777777777uL\par }\pard \qj\fi360\widctlpar\adjustright {\par One point of confusion this often leads to is the base of the number 0. Technically, the number 0 is an octal}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v octal}}}{ number, but in practice it doesn't make any difference. You may use it when a decimal number is required because the difference in base only matters when the number is converted from the string you type in when you enter a program to the internal number used in calculations. In practice, then, you can use 0 as either a base 8, base 10 or base 16 number.\par The table below shows some examples of legal octal constants, with their decimal equivalents.\par \par }\pard \qj\li360\ri3960\keepn\widctlpar\brdrt\brdrs\brdrw15 \brdrb\brdrs\brdrw15 \tx2700\adjustright {octal integer\tab decimal integer\par }\pard \qj\li360\ri3960\keepn\widctlpar\tx2700\adjustright {\f6\fs20 0\tab 0\par 07\tab 7\par 010\tab 8\par 0100\tab 64\par 077777\tab 32767\par 0177777u\tab 65535u\par 017777777777L\tab 2147483647L\par }\pard \qj\li360\ri3960\widctlpar\tx2700\adjustright {\f6\fs20 037777777777uL\tab 4294967295ul\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Hexadecimal Integers}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Hexadecimal Integers\tcl3}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v integers\:constants}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v constants\:integer}}}{Hexadecimal numbers are integers represented in base sixteen, rather than the more familiar base ten. Hexadecimal numbers are made up of the digits 0 to 9 and the letters a to f or A to F. In C, hexadecimal}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v hexadecimal}}}{ numbers are distinguished from decimal numbers and octal}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v octal}}}{ numbers by a leading zero, followed by an x character or X character.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v unsigned long integers\:constants}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v constants\:unsigned long integer}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v unsigned integers\:constants}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v constants\:unsigned integer}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v long integers\:constants}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v constants\:long integer}}}{As with decimal and octal integers, hexadecimal integers can be long or short, signed or unsigned. The range of integers allowed in each representation are show below.\par \par }\pard \qj\li360\keepn\widctlpar\tx2520\tx3960\adjustright {\f6\fs20 int\tab 0\tab 0x7FFF\par unsigned int\tab 0\tab 0xFFFFu\par long\tab 0\tab 0x7FFFFFFFL\par }\pard \qj\li360\widctlpar\tx2520\tx3960\adjustright {\f6\fs20 unsigned long\tab 0\tab 0xFFFFFFFFuL\par }\pard \qj\fi360\widctlpar\adjustright {\par The table below shows some examples of legal hexadecimal}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v hexadecimal}}}{ constants, with their decimal equivalents.\par \par }\pard \qj\li360\ri3960\keepn\widctlpar\brdrt\brdrs\brdrw15 \brdrb\brdrs\brdrw15 \tx2520\adjustright {hexadecimal integer\tab decimal integer\par }\pard \qj\li360\ri3960\keepn\widctlpar\tx2520\adjustright {\f6\fs20 0x0\tab 0\par 0X7\tab 7\par 0x10\tab 16\par 0x100\tab 256\par 0xa\tab 10\par 0xF\tab 15\par 0x7FFF\tab 32767\par 0xFFFFu\tab 65535u\par 0x7FFFFFFFL\tab 2147483647L\par }\pard \qj\li360\ri3960\widctlpar\tx2520\adjustright {\f6\fs20 0xFFFFFFFFuL\tab 4294967295ul\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Character Constants}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Character Constants\tcl3}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v integers\:constants}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v constants\:integer}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v character constants}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v constants\: character}}}{Character constants are formed by enclosing one to four characters in quote marks, as in\par \par }{\f6 'a'\par }{\par Character constants containing a single character are treated exactly as if an integer constant equivalent to the ordinal value of the character was used instead of the character constant. For example, in any program that contains the character constant 'a', it would be legal, and have no effect on the executable program, to replace the character constant with 97.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ASCII character set}}}{That certainly doesn't mean there is no need for character constants. If you are trying to write a portable program that is comparing against the character a, you should use a character constant, since not all computers use the integer value 97 for a lowercase a.\par Multi-character character constants, such as 'AB', are also accepted by ORCA/C. Multi-character constants are stored in memory in string order. Because of the way strings and numbers are stored on the 65816 microprocessor, this means that the character constant 'AB' is equivalent to the integer 0x4241, not 0x4142, as you might suspect. The integer equivalent of 'ABC' is 0x00434241, while the integer equivalent of 'ABCD' is 0x44434241.\par \par }\pard \qj\fi-1800\li1800\ri1080\widctlpar\tx440\adjustright {\f20 }{\b \tab Note}{\tab ANSI C requires all character constants to be of type int, but ORCA/C allows 3 and 4 character constants, returning them as long int constants. Use #pragma ignore to restore strict conformance to the ANSI standard.\~\~}{\f20\fs20 }{\b \par }\pard \qj\fi360\widctlpar\adjustright {\par ORCA/C uses the ASCII character set to determine the ordinal values of the characters.\par Some characters in the ASCII character set cannot be represented using a key that can be typed from the keyboard. These characters are represented as escape sequences, and are discussed later in this chapter.\par The C language does not specify if integers are signed or unsigned; that detail is left up to the implementor of the compiler. In ORCA/C, integer constants are signed.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {Examples:\par \par }\pard \qj\fi360\widctlpar\tx1260\tx1980\tx2700\tx3420\tx4140\tx4860\tx5580\adjustright {\f6\fs20 'a'\tab 'A'\tab '\\''\tab '"'\tab '\\040'\tab '\\40'\tab '\\x10'\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 String Constants}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 String Constants\tcl3}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v strings\bxe }}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v string constants}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v constants\:strings}}}{String constants consist of any sequence of characters except new line or the quote character, enclosed in quote characters. (Both the new line character and the quote character can, however, be represented as an escape sequence.)  As with character constants, escape sequences are used to represent non-printing characters; they are described in the next section.\par Internally, strings are represented as a sequence of bytes, one for each character in the string, followed by a terminating null byte. }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v null character}}}{(A null byte has a value of zero.)  The value of each byte is the ordinal value for the character, as specified by the ASCII character set and the Apple extended character set.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v strings\:in expressions}}}{Unlike other constants, using a string constant in an expression does not cause the compiler to load the value of the string. Instead, as with arrays, the address of the first character is loaded. In practice, this means that you can use a string constant wherever a pointer to a string is required, as in the famous Hello, World program, shown below.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 int main(void)\par \par \{\par printf("Hello, world.\\n");\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par }{\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v strings\:continuation}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v continuation lines}}}{String constants can be spread across more than one line. There are two ways to do this. The first method has been a part of the C language for quite some time. It involves using the \\ character as the last character on the line. In that case, the string constant continues with the first character of the next line. The second method is new to ANSI C. In the second method, you simply code two string constants with no intervening tokens, and the compiler plugs them together. The Hello, World program is shown below using these two methods.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 int main(void)\par \par \{\par printf("Hello, \\\par world.\\n");\par \}\par \par \par int main(void)\par \par \{\par printf("Hello, "\par \tab      "world.\\n");\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par }{\par }\pard \qj\widctlpar\adjustright {Note that the second method allows you to put spaces or tabs in the program to improve readability, while the older method of using a continuation line requires that the continuation of the string start in column 1.\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v strings\:maximum length}}}{ORCA/C imposes two limits on strings. First, no single string constant may have more than 4000 characters. Second, no single function can have string constants whose total length exceeds 8000 characters.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {Examples:\par \par }{\f6\fs20 "Hello, world.\\n"\par "This is a string constant"    " that has been broken into two parts."\par "He said, \\"I have arrived.\\""\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 "What?\\?!"\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Escape Sequences}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Escape Sequences\tcl3}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v character constants}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v string constants}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v escape sequences\bxe }}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v control characters}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v newline character}}}{Escape sequences are used in string constants and character constants to represent characters that would otherwise be difficult to type from the keyboard, or that interfere with the construction of the constant itself. Escape sequences consist of the \\ character followed by a single character, an octal}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v octal}}}{ constant, or a hexadecimal}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v hexadecimal}}}{ constant. (In escape sequences, hexadecimal constants must begin with a lowercase x.)  The table below shows the escape sequences that consist of a single character, along with the equivalent integral value and the standard use for the escape sequence in C.\par \par }\pard \qj\li360\ri2700\keepn\widctlpar\brdrt\brdrs\brdrw15 \brdrb\brdrs\brdrw15 \tx2160\tx3960\adjustright {escape sequence\tab integral value\tab meaning\par }\pard \qj\li360\ri2700\keepn\widctlpar\tx2160\tx3960\adjustright {a\tab 7\tab alarm (bell)\par b\tab 8\tab back space\par f\tab 12\tab form feed\par n\tab 10\tab new line\par p\tab (special)\tab p-string}{\pard\plain \qj\li360\ri2700\keepn\widctlpar\tx2160\tx3960\adjustright \v\f4\cgrid {\xe {\v }{\v p-strings}}}{\par r\tab 13\tab carriage return\par t\tab 9\tab horizontal tab\par v\tab 11\tab vertical tab\par \\\tab 92\tab \\ character\par '\tab 96\tab ' character\par "\tab 34\tab " character\par }\pard \qj\li360\ri2700\widctlpar\tx2160\tx3960\adjustright {?\tab 63\tab ? character\par }\pard \qj\fi360\widctlpar\adjustright {\par Four of these escape sequences are used because of the syntax of character constants and string constants. Since the back slash character is used to start an escape sequence, you can also follow it with a second back slash character to place a single back slash character in a constant. The quote mark (") ends a string constant, and the single quote mark (') ends a character constant, so both have an escape sequence to allow you to put these characters in string and character constants. The ? character is used when a ? in a string or character constant might be confused with a trigraph. All of the remaining escape sequences except \\p are used to represent control characters that have special meaning to the console driver. While the value used for each of these control characters will vary from computer to computer, they always perform the same action when the string or character constant is used with the standard output libraries.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v strings\:p-strings}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v p-strings}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v null character}}}{The escape sequence \\p is not used in standard C. It is used in ORCA/C to allow the formation of a p-string. Normally, strings end with a terminating null character. Unfortunately, many of the tool calls in the Apple\~II}{\fs20 GS}{ toolbox require a p-string, which uses a length byte to indicate the length of a string. When you need to specify a p-string as a constant, use the escape sequence \\p right after the opening quote mark. The final string will start with a byte that indicates how many characters are in the string, and will be followed by a normal C string. The terminating null character is not counted as one of the characters when determining the value of the length byte. The \\p escape sequence is treated as the character p in a character constant, as well as in a string constant if the escape sequence is not the first character in the string.\par When you need to specify a specific numeric value in a character or string constant, you can follow the back slash character by one to three digits, which are then interpreted as an octal}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v octal}}}{ number. For example, since ORCA/C uses the ASCII character set, which specifies an ordinal value of 041 octal (33 decimal) for the character !, the character constants '!' and '\\41' represent the same value. You can also use a lowercase x followed by one , two or three digits to represent the value in hexadecimal notation. Thus, '\\x21' is also a valid way to represent '!'. You should be careful when using values in strings. While '\\41' represents the ! character in a character constant, "\\410" is not the same as "!0", as you might intend. Instead, the finished string has a single character with an ordinal value of eight. (The most significant two bits do not fit into a byte, and are discarded.)\par The C language does not specify what the compiler will do if you follow the \\ character by a character other than one of the ones discussed. In ORCA/C, use of a non-escape character after the \\ character will place that character in the constant. For example, the character constants '}{\f6\fs20 \\g'}{ and }{\f6\fs20 'g'}{ are exactly the same.\par For examples of strings and character constants that include escape sequences, see the two preceding sections.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Real Numbers}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Real Numbers\tcl3}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v floating-point\: constants}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v constants\: floating-point}}}{Floating-point constants are used to represent numbers that do not have integral value, or that cannot be represented using an integer because they are too large or too small. The general format is a sequence of digits, followed by a decimal point, followed by another sequence of digits, and an exponent, as in\par \par }{\f6\fs20 3.14159e-14\par }{\par }\pard \qj\widctlpar\adjustright {The exponent can start with either an uppercase E, or a lowercase e, as shown.\par }\pard \qj\fi360\widctlpar\adjustright {The format for floating-point constants can vary quite a bit from this general form. You can leave out the digit sequence before or after the decimal point, as in }{\f6\fs20 1.e10}{ or }{\f6\fs20 .1e10}{. In fact, you can leave off the exponent, too, as in }{\f6\fs20 1.}{ or }{\f6\fs20 .1}{. You must have either an exponent or a decimal point, but if you specify an exponent, you can omit the decimal point, as in }{\f6\fs20 12e40}{.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v SANE}}}{The exponent, if specified, starts with either a lowercase or uppercase e. This is followed by an optional plus or minus sign, and then by a sequence of one or more digits. The number is represented internally as an extended SANE format number, giving an accuracy of a little over 19 decimal digits, and an exponent range of -4932 to 4932. Keep in mind that if the number is stored in a float or double variable, the accuracy will be reduced to match the accuracy of the variable.\par C allows a floating point constant to be followed by f or F to indicate a float value, or l or L to indicate long double. While these characters are allowed, they have no effect on a floating-point constant in ORCA/C.{\*\bkmkend bk0}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v tokens}{\rxe bk0}}}{\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 White Space}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 White Space\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v white space}}}{White space characters may be used to separate the tokens in a program. White space characters include the space, line feed, carriage return, vertical tab, horizontal tab, back space, and form feed characters. The line feed, carriage return, form feed and vertical tab characters all end the current line, which has special meaning in the preprocessor and when continuing lines. With that exception, replacing any sequence of white space characters outside a string or character constant with a single space has no effect on the finished program. Generally, white space characters are used to format the program, making it easier to read.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Comments}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Comments\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v comments}}}{A comment starts with the characters /*, and ends with the first occurrence of the characters */. Comments are used solely to document the source code; replacing a comment with a single space will have no effect on the finished program.\par Note that comments can extend over more than one line, and that they can be used in preprocessor commands.\par C does not allow recursive comments (sometimes called nested comments); that is,\par \par }{\f6\fs20 /*   /*   */   */\par }{\par }\pard \qj\widctlpar\adjustright {is not a legal comment in C. You can use the preprocessor's #if, #endif commands to cause the compiler to ignore large sections of code which may include comments.\par }\pard \qj\fi540\widctlpar\adjustright {Comments can also start with the characters //. These comments extent to the end of the current line.\par \par }\pard \qj\fi-1800\li1800\ri1080\widctlpar\tx440\adjustright {\outl\f21\fs22 \u-3981\'73}{\b \tab Important}{\tab // comments are an extension to ANSI C. There are a few pathological statements that are technically legal in ANSI C that will not compile properly in ORCA/C because of its support for // comments. If you are compiling a program that should not use // coimments, see #pragma ignore for a way to disable them.\~\~}{\outl\f21\fs14 \u-3981\'73}{\b \par }\pard \qj\fi540\widctlpar\adjustright {\par }\pard \qc\widctlpar\adjustright {\f12\fs28 \sect }\sectd \sbkodd\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\f5\fs20 Chapter 6:   The Preprocessor\par }}\pard\plain \widctlpar\adjustright \f4\cgrid {\b\fs48 Chapter 6 \endash  The Preprocessor\par }\pard \qj\ri720\widctlpar\adjustright {\pard\plain \qj\ri720\widctlpar\adjustright \v\f4\cgrid {\tc {\v }{\v Chapter 6 \endash  The Preprocessor\tcl1}}}{\v \par }\pard \widctlpar\adjustright {\par \par }\pard \qj\fi360\widctlpar\adjustright {{\*\bkmkstart bk6}The C preprocessor is a series of commands that tell the compiler to take certain actions. Using the preprocessor, you can tell the compiler to skip certain sections of source code, to replace some source code by other source code, and so forth. While the preprocessor is built right into ORCA/C, logically, preprocessing occurs before the program is compiled.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Syntax}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Syntax\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Commands to the preprocessor all start with the # character, which must appear before any other non-white space character in the line. This is followed by the preprocessor command, which may require other parameters. You can separate the preprocessor command from the # character with white space characters. The preprocessor command ends with the first new line, vertical tab, carriage return, or form feed character. The # character can appear on a line by itself, in which case it is ignored.\par The ability to place white space characters before the # character and between the # character and the name of the preprocessor command is a recent addition to the C language. If you are concerned with portability, you may wish to code the preprocessor commands as we do in the examples, without white space characters.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v continuation lines}}}{There are two ways to extend a preprocessor command over more than one line in the source file. The first is to continue the line by placing a \\ character at the end of the line, as in\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 #define sec(x)  \\\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \tab \tab (1.0 / cos(x))\par }{\par The other way to extend a preprocessor command over more than one line is to start a comment on one line, and finish it on another line, as in\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 #define  \tab \tab \tab \tab /* trig extensions\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \tab \tab */\tab sec(x)   (1.0 / cos(x))\par }{\par While the preprocessor does not parse the source file, it does break the source file up into tokens to find macro names. The same rules are shared by the preprocessor and the compiler for forming tokens and comments.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Preprocessor Macros}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Preprocessor Macros\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\*\bkmkstart bk1}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v preprocessor macros\:see macros}{\txe }}}{The #define preprocessor command allows you to define macros. When the macro is used later in the source code of the program, it is replaced by the tokens laid out in the #define command. One of the most common uses of preprocessor macros is to define constants using simple textual replacement. For example, you can define the boolean constants true and false, as shown in the simple program below.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 #define TRUE -1\par #define FALSE 0\par \par int main(void)\par \par \{\par int bool;\par \par bool = TRUE;\par if (bool)\par    printf("Hello, world.\\n");\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par }{\par }\pard \qj\widctlpar\adjustright {While the compiler uses a more efficient mechanism to implement preprocessor macros, the way to think of this program is that the two #define statements define two macros, called TRUE and FALSE. Whenever the preprocessor finds one of those words in the program, it is replaced by the text that follows the words. In our example, then, preprocessing occurs before the compiler starts to compile the program, so the program the compiler actually compiles looks like this:\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 int main(void)\par \par \{\par int bool;\par \par bool = -1;\par if (bool)\par    printf("Hello, world.\\n");\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par }{\par Before moving on to more complicated examples, a few points are worth mentioning. First, the text that will replace the name of the macro starts with the first non-white space character after the name of the macro itself. This text is converted into a stream of tokens by the preprocessor, and stored as tokens. This has an important consequence. At first glance, it might seem that a statement like\par \par }{\f6\fs20 bool = 0FALSE;\par }{\par }\pard \qj\widctlpar\adjustright {would be legal, since, after macro replacement, the statement looks like this:\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 bool = 00;\par }{\par }\pard \qj\widctlpar\adjustright {In fact, the statement is not legal, because the macro has already been converted into an integer with a value of zero, so the compiler sees two integer constants after the equal sign. The correct equivalent, then, is\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 bool = 0 0;\par }{\par One thing you will notice in all of the examples is that all of the macro names are capitalized. You are not required to capitalize the names of macros, but this is a common convention used by many C programmers, and we will follow that convention in our examples. It is worth pointing out, though, that the names of macros, like all identifiers in C, are case sensitive.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v macros\:parameters}}}{Macros are not limited to simple textual replacement. For example, you can define a trigonometric function for the secant using a macro.\par \par }{\f6\fs20 #define sec(x) (1/cos(x))\par }{\par Note that in this case, since we want the macro to blend in with the standard C math library, we have used lowercase letters in the name of the macro.\par When you use a macro that has parameters in a program, you can substitute any number of tokens for the parameter. For example, all of the following are legal uses of the macro preprocessor, although not all of the examples result in legal C programs.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 sec(pi)\par sec(0.45)\par sec(pi/12.0)\par sec("strings are allowed, although this example will not compile")\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 sec((pi/12.0+.45)*0.01)\par }{\par Macros can have any number of parameters. To create a macro with more than one parameter, list the names of the parameters separated by commas. For example, you could define a macro to find the distance between two points, as in the following small program, which also shows one macro calling another.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 #include <math.h>\par #include <stdio.h>\par \par #define sqr(x) ((x)*(x))\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 #define distance(p1,p2) (sqrt(sqr(p1.x-p2.x)+sqr(p1.y-p2.y)))\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 int main(void)\par \par \{\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 struct point \{float x,y;\} point1,point2;\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 point1.x = 1.0;\par point1.y = 1.0;\par point2.x = 3.0;\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 point2.y = 1.0;\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 printf("The distance is %f\\n", distance(point1,point2));\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par }{\par There are a few important points to note about the syntax of macros that have parameters. First, the opening parenthesis must appear immediately after the name of the macro in both the definition and the use. This is to prevent confusion between a macro parameter and a simple textual replacement macro whose first character is a left parenthesis. Second, you can use parentheses within the macro call to enclose token streams that include commas, so long as the parentheses are legal in the C program produced by the macro expansion. The names of macro parameters, like macros, follow the same rules as identifiers in C, with the exception that reserved words are not reserved in the preprocessor. In fact, it is legal, although very poor form, to define a reserved word as a macro.\par {\*\bkmkstart bk2}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v macros\:nesting}}}{It is not legal to define more that one macro using the same name.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v macro stringization}}}{Within a macro, it is possible to merge the string value of a macro parameter with adjacent string constant, or to treat the parameter as a string constant. The # operator, when it appears before the name of a macro parameter, indicates that the parameter is to be treated as a string rather than a token. For example, the following code fragment will print the familiar Hello, world. string to the screen.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 #define greet(who) "Hello, " #who "."\par \par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 printf(greet(world));\par }{\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v token merging}}}{The macro preprocessor can also merge two tokens to form a new token. The ## operator controls this process. The following code fragment is equivalent to strPtr = setPtr.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 #define ptr(where) where ## Ptr\par \par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 ptr(str) = ptr(set)\par }{\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v macros\:predefined}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ANSI C}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v time}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v date}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v line numbers}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v file names}}}{Macros can also be removed with #undef. #undef takes a single parameter, which is the name of a macro to undefine. The macro by the given name is removed from the preprocessor's macro symbol table. It is not an error to undefine a macro that has never been defined. Once the macro has been undefined, it is also not an error to redefine it.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\pard\plain \qj\fi360\keepn\widctlpar\adjustright \v\f6\fs20\cgrid {\xe {\v\f6\fs20 }{\v\f6\fs20 $p$undef}}}{\v\f6\fs20 \par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 #undef greet\par }{\par There are several predefined macros that exist in any C program. These macros can be used in your program, but you cannot change them or remove them via the #undef command. Each of the predefined macros places a single token in your program; the token, and what it means, is shown in the table below.\par \par }\pard \qj\fi-2880\li3240\keepn\widctlpar\brdrt\brdrs\brdrw15 \brdrb\brdrs\brdrw15 \tx1800\tx3240\adjustright {macro\tab token\tab use\par }\pard \qj\fi-2880\li3240\keepn\widctlpar\tx1800\tx3240\adjustright {__DATE__}{\pard\plain \qj\fi-2880\li3240\keepn\widctlpar\tx1800\tx3240\adjustright \v\f4\cgrid {\xe {\v }{\v __DATE__}}}{\tab string\tab The date as of the start of the compilation, in the form Mmm dd yyyy, e.g., "Jan 12 1989".\par __FILE__}{\pard\plain \qj\fi-2880\li3240\keepn\widctlpar\tx1800\tx3240\adjustright \v\f4\cgrid {\xe {\v }{\v __FILE__}}}{\tab string\tab Name of the current source file.\par __LINE__}{\pard\plain \qj\fi-2880\li3240\keepn\widctlpar\tx1800\tx3240\adjustright \v\f4\cgrid {\xe {\v }{\v __LINE__}}}{\tab integer constant\tab Line number of the line being compiled. Each physical line in the file is counted, even if the line is in a comment or is skipped because of preprocessor commands.\par __TIME__}{\pard\plain \qj\fi-2880\li3240\keepn\widctlpar\tx1800\tx3240\adjustright \v\f4\cgrid {\xe {\v }{\v __TIME__}}}{\tab string\tab Time as of the start of the compilation, in the form hh:mm:ss, e.g., "15:36:12".\par __STDC__}{\pard\plain \qj\fi-2880\li3240\keepn\widctlpar\tx1800\tx3240\adjustright \v\f4\cgrid {\xe {\v }{\v __STDC__}}}{\tab integer constant\tab A non-zero value in any compiler that implements ANSI C. In ORCA/C, the value is -1. In a compiler that does not implement ANSI C, this macro will not be defined.\par __ORCAC__}{\pard\plain \qj\fi-2880\li3240\keepn\widctlpar\tx1800\tx3240\adjustright \v\f4\cgrid {\xe {\v }{\v __ORCAC__}}}{\tab integer constant\tab ORCA/C will return a -1. In any other C compiler, this macro will not be defined.\par }\pard \qj\fi-2880\li3240\widctlpar\tx1800\tx3240\adjustright {__VERSION__}{\pard\plain \qj\fi-2880\li3240\widctlpar\tx1800\tx3240\adjustright \v\f4\cgrid {\xe {\v }{\v __VERSION__}}}{\tab string\tab The compiler version in the form "2.0.0".\par }\pard \qj\fi540\widctlpar\adjustright {\*\bkmkend bk1}{\pard\plain \qj\fi540\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v macros}{\rxe bk1}}}{\*\bkmkend bk2}{\pard\plain \qj\fi540\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$undef\bxe }{\rxe bk2}}}{\v \par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Including Files}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Including Files\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\*\bkmkstart bk3}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v standard libraries}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v standard libraries\:see also libraries}{\txe }}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v libraries\:see also toolbox}{\txe }}}{The #include command is used to deal with situations where a source program is made up of more than one source file. The most common use of the #include directive is to include interface files for the standard C libraries. For example, to be completely correct, the common Hello, World program should actually start off with a #include command that includes the header for the standard input and output library, like this:\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 #include <stdio.h>\par \par int main(void)\par \par \{\par printf("Hello, world.\\n");\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par }{\par }\pard \qj\widctlpar\adjustright {\pard\plain \qj\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v toolbox}}}{The include statement is followed by a file name, which can be enclosed in quote marks or brackets. The compiler compiles all of the lines in the included file, then returns to the file that contained the #include command, and continues compiling with the line immediately after the #include command. In the example, the name of the header file for the standard input and output libraries is stdio.h. This file can be found with all of the other standard header files, which include not only the standard C libraries, but also the Apple\~II}{\fs20 GS}{ toolbox interface. These header files are located in the ORCACDefs folder. Any time you enclose a file name in brackets, the compiler will look for the file in the ORCACDefs folder.\par }\pard \qj\fi360\widctlpar\adjustright {The other common use for the #include command is to include source code you have written specifically for a program. This could include custom header files, macro definitions used in more than one source file, or even a single program which has grown too large to edit. In this case, you would enclose the file name in quote marks, as in\par \par }{\f6\fs20 #include "mymacros"\par }{\par }\pard \qj\widctlpar\adjustright {When the file name is enclosed in quote marks, the compiler looks for the file in the current directory. If the file you want to include is located in a folder in your current directory, you can use a partial path name; you can also use a full path name if the file you want to include is located on another disk, or in some other location on your current disk. Examples are shown below.\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 #include "/network/project.x/secret.macros"\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 #include "macrofolder/macro.file.1"\par }{\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v macros}}}{It is possible to use a macro for the file name, provided the file name can be broken down into tokens. In the case of a quoted file name, this will always work, since the file name is a string constant. In the case of a file name enclosed in brackets, you will be able to use any file name, but some file names from other file systems may not work. Note that the ability to use a macro for the file name is a recent addition to the C language, and may not be present in all C compilers.\par There is no fixed limit to the nesting level for included files. For example, an included file can include another file, which can also include still another file, and so on. This process can continue for as long as memory is available.{\*\bkmkend bk3}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$include\bxe }{\rxe bk3}}}{\par {\*\bkmkstart bk4}ORCA/C supports another file inclusion mechanism, the #append command. This command is used to chain two files together. Like the #include command, the #append command requires a file name as a parameter, and this file name can be enclosed in brackets or quote marks. Brackets are still used to indicate that the file should come from the ORCACDefs folder, and quote marks are used for files in the local directory, or for full path names. You can also use a macro to specify the path name, with the same restrictions that applied to the #include command.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v multiple languages}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v assembly language}}}{There are two principle differences between the #include command and the #append command. The first is that all lines after the #append directive are ignored. Once the compiler starts processing lines in the appended file, it never returns to the original file, as the #include directive does. Conceptually, the #append command is like a goto, while the #include command is like a subroutine call. The other difference between the two commands is that, if the #append command appears in the top level file, the file that is appended can be a source file for some language other than C. The top level file is the source file you actually compile, that is, a file that has not been included using the #include command. This powerful feature means that you can create a program using two or more languages, and then compile the entire program with a single step.{\*\bkmkend bk4}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$append\bxe }{\rxe bk4}}}{\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Precompiled Headers}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Precompiled Headers\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi-990\li1440\keepn\widctlpar\tx1800\adjustright {\pard\plain \qj\fi-990\li1440\keepn\widctlpar\tx1800\adjustright \v\f4\cgrid {\xe {\v }{\v header files}}}{\pard\plain \qj\fi-990\li1440\keepn\widctlpar\tx1800\adjustright \v\f4\cgrid {\xe {\v }{\v precompiled headers}}}{\pard\plain \qj\fi-990\li1440\keepn\widctlpar\tx1800\adjustright \v\f4\cgrid {\xe {\v }{\v sym files}}}{\v \par }\pard \qj\fi360\widctlpar\adjustright {Many C programs, especially those that use the Apple\~II}{\fs20 GS}{ toolbox, start with a list of header files to include. In practice, compiling the header files can actually take longer than compiling the executable part of the program.\par ORCA/C tries to cut compile times by eliminating the need to compile the headers files over and over. As each header file is compiled, ORCA/C writes the new symbol table information to a file we will call the .sym file. This file is in the same folder as the initial source file. The name of the file is formed by removing the last extension on the source file name, if any, and adding the characters ".sym". For example, the .sym file for a source file named foo.cc would be foo.sym. The next time the file is compiled, ORCA/C can read the symbol table from the .sym file, often cutting compile times more than in half.\par There are many ways to implement this concept. Two design considerations drove our choice for the implementation method. First, we wanted a mechanism that was 100% transparent to anyone using the compiler. With the exception that you will see .sym files formed for each compile, ORCA/C precompiled headers are completely automatic. The other factor that drove the design is that macro definitions that precede include statements can, and often do, effect the way a header file is compiled. For example, it is very common to use a macro to override the size of an array in a tool header file. This useful feature of the C language makes it impossible to compile the header file itself, replacing it with a symbol table, without requiring programmers to know when forcing a recompile of the symbol tables is appropriate.\par ORCA/C does several things to determine when a .sym file must be rebuilt. First, if the source file changes in any way before the include statements, the symbol file is rebuilt. If the time or date stamp on any include file changes, the symbol file will also be rebuilt. Finally, if an include file is missing or cannot be accessed, the .sym file is rebuilt.\par There are also some restrictions that apply to which header files are included in the .sym file. The first code-generating function or initialized variable in the program completes the .sym file, and all subsequent header files are compiled in the normal way. For example, if an include appears after a function definition (}{\i not}{ declaration) it will not be included in the .sym file. In addition, any header file that contains an initialized variable or function definition will not be included in the .sym file, and will block subsequent header files, too.\par Assuming the .sym file must be rebuilt, it actually takes two compiles before the process is complete. On the compile where the compiler determines that the .sym file should be rebuilt, it uses any information from the .sym file up to the point of change, then deletes the old .sym file. The new .sym file is built on the next compile.\par There are two flags that control the use of .sym files. On any of the compile commands, the \-i flag tells the compiler to compile the program as if the compiler did not support precompiled headers. Any .sym file that is present is ignored, and a new .sym file will not be built. The -r flag forces the compiler to rebuild the .sym file, even if the compiler does not see any reason to do so.\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\pard\plain \qj\fi360\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v small memory compiler}}}{\pard\plain \qj\fi360\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v memory\:see also small memory compiler}{\txe }}}{\v \par }\pard \qj\fi360\widctlpar\adjustright {Precompiled headers are not supported by the small memory version of the compiler.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Conditional Compilation}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Conditional Compilation\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v conditional compilation}}}{\v {\*\bkmkstart bk5}.i).$p$endif;}{The preprocessor includes a powerful conditional compilation mechanism. Using conditional compilation, it is possible to control the way a program is compiled by making small changes in the source for a program.\par The two commands which form the cornerstone for conditional compilation are #if and #endif. The #if command has an expression for an operand. This expression is evaluated. If the result of the expression is zero, all of the lines from the #if command to the matching #endif command are skipped by the compiler. If the result of the expression is not zero, the lines following the #if command are compiled in the normal way, and the matching #endif command is ignored.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v macros\:in }{\txe if statements}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v __STDC__}}}{As an example, we could write a very short program to test to see if a compiler implements ANSI C. All ANSI C compilers define the __STDC__ macros as a non-zero value. In compilers that do not implement ANSI C, the macro will not be defined. When an undefined macro name is used in an expression in an #if command, it is replaced by the integer constant 0. Our program, then, looks like this:\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 int main(void)\par \par \{\par #if __STDC__\par printf("This compiler implements ANSI C.\\n");\par #endif\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par }{\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v tokens}}}{While the lines between the #if and #endif statements are skipped if the expression in the #if statement evaluates to 0, the lines skipped must still be made up of legal C tokens. For example,\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 #if 0\par @\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 #endif\par }{\par }\pard \qj\widctlpar\adjustright {is not legal, since the character @ is not a legal C token.\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$if\:nesting}}}{#if statements may be nested. For example, we could expand our previous example to see if the compiler being used is ORCA/C, like this:\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 int main(void)\par \par \{\par #if __STDC__\par    printf("This compiler implements ANSI C.\\n");\par    #if __ORCAC__\par       printf("In fact, this is ORCA/C.\\n");\par    #endif\par #endif\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par }{\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$if\:expressions}}}{With a few exceptions, the rules for forming an expression in an #if statement are the same as the rules for expressions in the C language. The exceptions have to do with the fact that the expression is evaluated at compile time, rather than at run time, and also with features have been added to simplify tasks in the preprocessor. The major difference between expressions used in the #if command and expressions used in the program is that the expression that appears after the #if command must be a constant expression. For a detailed discussion of constant expressions, see Chapter 11.{\*\bkmkend bk5}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$if\bxe }{\rxe bk5}}}{\v .i).$p$endif;}{\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v defined operator}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v macros\:defined operator}}}{Preprocessor expressions can make use of two features which cannot be used in any other expression. The first has already been mentioned:  when an undefined macro is encountered, it is given a value of 0. The second feature is the defined operator. The defined operator is followed by the name of a macro, which may be enclosed in parentheses. The result of the operator is 1 if the macro is defined, and 0 if it is not defined. Rewritten to use the defined operator, our example program that determines if a compiler is an ANSI C compiler looks like this:\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 int main(void)\par \par \{\par #if defined __STDC__\par printf("This compiler implements ANSI C.\\n");\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 #endif\par \}\par }{\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$else\bxe }}}{As with the C language, the preprocessor's #if statement can have an else clause. Any #if statement can have a #else statement between the #if statement and the matching #endif statement. We can use this feature to extend our test program so that it prints a message if the compiler is not an ANSI C compiler, too.\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 int main(void)\par \par \{\par #if __STDC__\par printf("This compiler implements ANSI C.\\n");\par #else\par printf("This compiler does not implement ANSI C.\\n");\par #endif\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par }{\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$elif\bxe }}}{Complex conditions can be handled using the #elif command. The #elif command is a combination of the #if command and the #else command. Like the #else command, the #elif command is used after a #if command, but before the matching #endif command. It must also come before the #else command if there is one. Like the #if command, the #elif command is followed by an expression. This expression is only evaluated if the previous #if command or #elif command evaluated to zero. In that case, the expression is evaluated. If the result is zero, the preprocessor scans forward to the next matching #elif, #else or #endif command, and takes appropriate action. If the result of the expression is not zero, all statements up to the next matching #elif command, #else command, or #endif command are compiled. Any lines up to the matching #endif statement and the #endif statement itself are then skipped by the compiler. Note that more than one #elif command can appear in a single #if structure, in which case the preprocessor evaluates the expression in each statement in turn until one of the expressions results in a non-zero value. The lines following that statement are then compiled. If all of the #if and #elif statements have expressions that evaluates to zero, the lines following the #else statement are compiled.\par As an example, we can expand the program that determines what compiler we are using to detect ORCA/C or APW C}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v APW C}}}{.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 int main(void)\par \par \{\par #if __ORCAC__\par printf("This compiler is ORCA/C, which implements ANSI C.\\n");\par #elif __STDC__\par printf("This compiler implements ANSI C.\\n");\par #elif __APWC__\par printf("This compiler is APW C, which does not implement ANSI C.\\n");\par #else\par printf("This compiler does not implement ANSI C.\\n");\par #endif\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par }{\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$ifdef\bxe }}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$ifndef\bxe }}}{There are two special forms of the #if statement which are used to test for the existence of a macro. They are #ifdef and #ifndef. Both statements require an operand that is a single identifier. If the identifier has been defined as a preprocessor macro, then #ifdef works exactly like #if 1, and #ifndef works like #if 0. If the identifier is not a preprocessor macro, the results are switched. Recoding our program to determine if a compiler is an ANSI C compiler to use these commands, we have the following:\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 int main(void)\par \par \{\par #ifdef __STDC__\par printf("This compiler implements ANSI C.\\n");\par #endif\par #ifndef __STDC__\par printf("This compiler does not implement ANSI C.\\n");\par #endif\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Line Numbers}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Line Numbers\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Historically, the C language has been associated with preprocessors. The preprocessor described in this chapter was originally a separate program from the C compiler. It took a source file as input, and produced another source file as output; the output file was then compiled. The C++ language is a more recent example of a preprocessor used with the C language. There are also numerous examples of cross-compilers that work by taking a program written in one language, say FORTRAN, and producing a program written in C for compilation by the C compiler.\par This presents a problem when the compiler needs to flag an error. Meaningful error messages are associated with information about the source file in which the error occurs, and the line where the error occurs. It is very discouraging, for example, when a compiler is only able to tell you that a divide by zero error occurred somewhere in your 10,000 line program; it is far more useful if the compiler identifies which line of which source file the error occurred in.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$line}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v line numbers}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v file names}}}{The #line command is used by preprocessors for this purpose. It takes one or two parameters, either of which may be produced by expanding a macro. The first, which is required, is an integer constant. The value is used by the compiler as the line number of the next line that is compiled. The second parameter, which is optional, is the name of the source file, enclosed in quote marks. This name is used until it is overridden by another #line command. The line number and file name specified this way are used by the compiler for compile-time errors, reported by the program when a run-time error occurs and the #pragma debug directive has been set to an appropriate value, and used by the source-level debugger to show where you are in the original source file.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Flagging Errors}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Flagging Errors\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$error}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v errors}}}{The #error statement is used to produce a compile-time error message. It uses a single parameter, which must be a string constant. This string is printed as an error message at compile time. For example, the program\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 int main(void)\par \par \{\par #ifndef __GARBONZOC__\par #error "This program requires Garbonzo C."\par #endif\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par }{\par }\pard \qj\widctlpar\adjustright {would generate the compile-time error message\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 #error: This program requires Garbonzo C.\par }{\par }\pard \qj\widctlpar\adjustright {just before the #error command in the output listing.\par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Pragmas}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Pragmas\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$pragma}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v pragma}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v compiler directives}}}{The #pragma command is used for preprocessor commands that are specific to a particular compiler. Each #pragma command that ORCA/C recognizes is followed by an identifier that specifies the type of the statement. Any #pragma statement that does not start with one of the identifiers described below is skipped.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 cda}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 cda\tcl3}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v classic desk accessories}}}{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$pragma\:cda\bxe }}}{\b\f6 #pragma cda }{\b\i\f6 name start shutdown}{\b\f6 \par }\pard \qj\fi540\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The cda command is used to create a classic desk accessory. Classic desk accessories are not executed like normal C programs; instead, they are copied into the DESK.ACCS folder in the SYSTEM folder, where they can be used from any program that follows standard rules for the Apple\~II}{\fs20 GS}{.\par Normal C programs must contain a function called main. This function is the one executed when the program starts. Classic desk accessories do not have to have a function called main. Instead, you specify the name of the function that will be called when the classic desk accessory is executed as the }{\i\f6\fs20 start}{ parameter to the cda command.\par When the operating system is shutting down, it will call each of the classic desk accessories to give it a chance to do any shut-down processing that it may require. Each classic desk accessory must have a shut-down function. The }{\i\f6\fs20 shutdown}{ parameter is the name of your shut-down function. If you do not need to do any shut-down processing, you must still have a shut-down function, but it can be an empty function.\par Each classic desk accessory has a name. This name appears in the CDA menu, which is used to select the classic desk accessory to execute. The }{\i\f6\fs20 name}{ parameter is used to specify the name of your classic desk accessory. It must be a string constant.\par The cda command must be used before the start of the first function in the program. If it is used, you cannot use another cda command or an nda command.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 cdev}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 cdev\tcl3}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v control panel}}}{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$pragma\:cdev\bxe }}}{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v CDev}}}{\v \par }{\b\f6 #pragma cdev }{\b\i\f6 start}{\b\f6 \par }\pard \qj\fi540\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The cda command is used to create a Control Panel Device (CDev) for the Control Panel from System 6.0. Classic desk accessories are not executed like normal C programs; instead, they are copied into the CDEV folder in the SYSTEM folder, where they can be used from within Apple's Control Panel.\par Normal C programs must contain a function called main. This function is the one executed when the program starts. CDevs do not have to have a function called main. Instead, you specify the name of the function that will be called when the classic desk accessory is executed as the }{\i\f6\fs20 start}{ parameter to the cdev command. The function itself takes two long integer parameters and an integer parameter, returning a long integer.\par For a complete description of Control Panel Devices, as well as details about the parameters passed to this function and the value returned by the function, see Apple\~II File Type Notes for file type $C7 (CDV).\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 databank}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 databank\tcl3}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\v .}{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v databank}}}{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$pragma\:databank\bxe }}}{\b\f6 #pragma databank }{\b\i\f6 parm}{\b\f6 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {There are several instances that arise when using the toolbox where you need to create a function that a tool will call. When the C compiler creates the code for a function, it assumes that the data bank register is pointing to the bank that contains the global scalars. When a function is called by a tool, there is no guarantee that this is true. To solve this problem, you must use the databank directive before any function that will be called from a tool. This directive tells the compiler to save the original data bank register, and then set the data bank register to point to the bank containing the global scalars. Before returning from the subroutine, the original data bank register is restored.\par \par }{\f6\fs20 #pragma databank 1\par }{\par }\pard \qj\widctlpar\adjustright {Immediately after the function, switch back to the normal calling conventions using the command\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 #pragma databank 0\par }{\par Functions that have data bank restoration on can still be called from other C functions, but they will be slightly less efficient than functions that do not have data bank restoration enabled.\par See also the toolparms directive.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 debug}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 debug\tcl3}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v debugger}}}{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$pragma\:debug\bxe }}}{\b\f6 #pragma debug }{\b\i\f6 parm}{\par }\pard \qj\fi540\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The debug command is used to control the types of debugging the compiler will do. The various debugging features can be very useful when you are developing a program, but each debugger feature requires run-time code which takes up space and time in your finished program.\par This command is only used in rare cases. If you are using the desktop development environment, you will normally use the debug check box in the compile dialog to control debugging. When that box is checked, all of the debugging features described here are enabled. When that box is not checked, all of the debugging features are disabled.\par The debug command requires a single integer parameter. This parameter is actually a series of flags. For each flag, a value of 1 turns the debugging feature on, and a value of 0 turns it off. Even if new debugger features are added in the future, then, the command\par \par }{\f6\fs20 #pragma debug -1\par }{\par }\pard \qj\widctlpar\adjustright {will enable all debugging features, while the command\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 #pragma debug 0\par }{\par }\pard \qj\widctlpar\adjustright {will turn all debugger features off.\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v range checking}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v stack size}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v stack overflow}}}{Setting bit 0 (a value of 1) turns range checking on. The only checking this enables in the C compiler is a check for stack overflows. This check is made at the start of each function. The check ensures that there is enough room left on the run-time stack to declare all of the local variables needed by the function. This reduces the chance of crashes due to stack overflows. It is still possible to overflow the stack with a very complicated expression or by calling a tool.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v debugger}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v source-level debugger}}}{Setting bit 1 (a value of 2) tells the compiler to generate debug code for the source-level debugger. You should not set this bit unless the program will be executed from the desktop development environment. If you try to execute a program that has source-level debug code in it from the text shell or the Finder, the program will crash.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v profiler}}}{Setting bit 2 (a value of 4) tells the compiler to generate profile code. Profile code is used by the desktop development environment's profile command to tell you where the hot spots are in your program. You must set bit 1 if you set bit 2.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v run-time errors}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v errors}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v trace backs}}}{Setting bit 3 (a value of 8) tells the compile to generate trace back code. Without trace back code, a run-time error will simply report which error occurred. If you have enabled trace back code, you will get more information about the error. This information starts with the name of the function where the error occurred, along with the line number in the source file. This is followed by a table showing the function that called the one where the error occurred, and the line number the call was made from, then the function that called the previous one, and so forth, back to the function main. This information is written to error out, which defaults to the text screen in the text environment, and the shell window in the desktop environment.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v stack repair code}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v parameters}}}{Setting bit 4 (a value of 16) tells the compiler to check for stack errors. If this check is enabled, the compiler generates code for each function call that keeps track of the stack as the function is called, making sure the function removes exactly the right number of bytes from the stack. For example, if you call a function and pass an integer parameter, two bytes are pushed onto the stack. If the function expected a long integer, though, it will remove four bytes from the stack, and this error check would catch the error. When using this error flag, we suggest\par \par }{\f6\fs20 #pragma debug 25\par }{\par }\pard \qj\widctlpar\adjustright {which also turns on stack overflow checking and tracebacks. With tracebacks enabled, the compiler doesn't just tell you that an error occurred, it also tells you where the error occurred, making the error a lot easier to track down and correct.\par \par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 expand}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 expand\tcl3}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$pragma\:expand\bxe }}}{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v macros\:expanding}}}{\b\f6 #pragma expand }{\b\i\f6 int}{\par \par }\pard \qj\fi360\widctlpar\adjustright {The expand pragma allows you to see the tokens the compiler is actually compiling, essentially showing you the output from the preprocessor, with all of the preprocessor macros expanded. If INT is a non-zero value, the preprocessor prints the token stream sent to the compiler, after all tokens have been expanded. If INT is zero (the default), this information is not printed. This feature is useful for debugging macros and examining the effects of character constants and escape codes. The exact expansions produced are:\par \par }\pard \qj\fi-360\li720\widctlpar\adjustright {1.\tab All integers and character constants are expanded to base 10 values.\par 2.\tab Escape sequences in strings are printed as hex escape sequences.\par 3.\tab Macros are expanded.\par 4.\tab Floating point constants are converted to exponential form.\par 5.\tab Trigraphs are converted to their equivalent characters.\par 6.\tab Preprocessor directives are removed from the source stream.\par 7.\tab Any input skipped due to conditional compilation directives is removed from the source stream.\par 8.\tab Comments are removed.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 float}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 float\tcl3}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$pragma\:float\bxe }}}{\b\f6 #pragma float }{\b\i\f6 card slot}{\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v 68881}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v SANE}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v floating-point}}}{By default, ORCA/C generates calls to the Standard Apple Numerics Environment (SANE) to perform floating-point calculations. If you have installed an Innovative Systems FPE card, however, ORCA/C can create a program that calls the card directly. To create a program that calls the FPE card, place the float directive before the first function in your program. The card parameter should be coded as 1. The slot parameter is no longer used, although a value must be coded  If your program does not do any floating-point calculations, this directive will make no difference in the code or execution time. On some floating-point intense programs, however, the FPE card can speed up a program by a factor of 120.\par The actual effect of this directive is to tell the compiler not to generate direct calls to SANE, forcing it to use library calls for all floating-point calculations.\par In addition to using this directive, you should replace the SysFloat library in the Libraries folder with the library by the same name at the path :MoreExtras:FPE:SysFloat. This library generates calls to the FPE card, rather than calling SANE. Because of this arrangement, you will get some benefit from the FPE card by simply replacing the library, even if you forget to use this pragma.\par If a program is compiled with the FPE libraries, an FPE card must be installed or the program will crash or give incorrect answers. If you must create a program that can work with or without an FPE card, write the program to make SANE calls, and use the SANE patches that come with the FPE card.\par Card numbers other than 0 or 1 are not currently in use. They are reserved in case other floating-point cards are produced for the Apple\~II}{\fs20 GS}{.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 ignore}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 ignore\tcl3}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$pragma\:ignore\bxe }}}{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v errors}}}{\v \par }{\b\f6 #pragma ignore }{\b\i\f6 flags}{\b\f6 \par }\pard \qj\fi540\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {ORCA/C is an ANSI C compiler, adhering to the language specification defined by the American National Standards Institute (ANSI). ANSI C is actually the latest major standard in a long line of languages that have used the general name C; there are, in fact, five major dialects of C and countless minor variations.\par Judging from the changes made in ANSI C, one of the concerns of the standards committee was to make C a safer language, catching many errors in the compiler than might have resulted in incorrect programs in earlier compilers. In general, this is a very good goal, but some older C programs no longer compile under ANSI C compilers. In addition, the language is under pressure to change in the direction of C++. The ignore statement tells ORCA/C to ignore certain kinds of checks that are required of ANSI C compilers so you can port older C programs a little easier.\par The flags parameter is a series of bits, each controlling a specific error. If the bit is set, the error is }{\i not}{ reported. In MPW\~II}{\fs20 GS}{ ORCA/C, the default is always set to relax the requirements of the ANSI C standard. The flags that are currently available are:\par \par }\pard \qj\li360\widctlpar\brdrt\brdrs\brdrw15 \brdrb\brdrs\brdrw15 \tx900\adjustright {bit\tab use\par }\pard \qj\fi-540\li900\widctlpar\adjustright {0\tab If this bit is set, the compiler does not report illegal characters in the source stream when the characters occur in code that is not processed by the compiler. For example, it is fairly common for programs to use the $ character in file names, as in\par }\pard \qj\fi360\li900\widctlpar\adjustright {\par }{\f6\fs20 #ifdef VAX\par #include <sys$stdio.h>\par #endif\par }{This code is illegal under any properly implemented ANSI C compiler, whether or not VAX is defined. If bit 0 of the ignore pragma's flag word is set, and VAX is not defined, ORCA/C will not flag an error.\par }\pard \qj\fi-540\li900\widctlpar\adjustright {\par 1\tab If this bit is set, the compiler allows multi-character char constants to be 3 or 4 bytes long, converting them to a longint value. If this bit is clear, only 1 and 2 character char constants are allowed.\par \par 2\tab If this bit is set, the compiler allows spurious tokens to appear after the #endif directive. The tokens are treated as a comment, and have no effect on the program. If this bit is clear, tokens after #endif are treated as an error.\par \par 3\tab If this bit is set, the compiler treats // as the start of a comment that extends to the end of the current source line. If this bit is clear, these characters are scanned as defined by the ANSI C standard.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 keep}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 keep\tcl3}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$pragma\:keep\bxe }}}{\b\f6 #pragma keep }{\b\i\f6 name}{\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v object files}}}{The keep command sets the name of the output file. A name is provided automatically if you are using the desktop environment, although you can use this directive to choose your own name. The name you choose cannot be the name of an existing file unless the file is an executable file or object module.\par The single parameter is the name of the output file. As with the parameter for the #include command, this name is enclosed in quote marks or brackets, indicating if the file should be placed in the current directory or the ORCACDefs directory. In general, you would not want to place the file in the ORCACDefs directory.\par The keep command must be used before the start of the first function in the program, and only one keep command can be used in a program.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 lint}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 lint\tcl3}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$pragma\:lint\bxe }}}{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v parameters}}}{\b\f6 #pragma lint }{\b\i\f6 int}{\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The lint pragma forces stricter checking of programs than is required by the ANSI C standard. The checks are individually enabled and disabled by setting and clearing bits in }{\i int}{. To enable more than one check, add the values for the bits shown in the table below to form a single integer. To enable all lint checks, use a value of -1.\par \par }\pard \qj\fi-360\li720\widctlpar\adjustright {1\tab Flag the use of a function before the function is defined as an error. This is always bad form, but this flag is also very useful in checking to insure that all header files that should have been included have, in fact, been included. If you missed including the header file for string.h, for example, but used strcat in your program, the compiler will flag an error for using strcat.\par \par \tab Error message: "lint: undefined function"\par \par 2\tab Flag functions with no types as errors.\par \par \tab Error message: "lint: missing function type"\par 4\tab Flag functions with no prototyped parameter lists as errors. If you are using tool header files that do not have prototyped headers, but you still want to use this check for the rest of your program, put the lint pragma after the #include statements that include the tool header files.\par \par \tab Error message: "lint: missing parameter list"\par \par 8\tab Flag pragmas that are not recognized by ORCA/C as errors. Normally, ANSI C compilers ignore pragmas they do not recognize, assuming the source file is being used with more than one compiler. Because of this, spelling errors in a pragma can go unnoticed by the compiler; this bit helps find this sort of problem.\par \par \tab Error message: "lint: unknown pragma"\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 memorymodel}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 memorymodel\tcl3}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$pragma\:memorymodel\bxe }}}{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v small memory model}}}{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v large memory model}}}{\b\f6 #pragma memorymodel }{\b\i\f6 parm}{\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The parameter is an integer constant. If the value is zero, the compiler will generate code for the small memory model; a non-zero value will generate code for the large memory model. You should use a value of 1 for the large memory model to allow for future expansion of the number of memory models.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v arrays}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v structures}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v unions}}}{The large memory model is the most flexible. When you use the large memory model, your program can have up to 64K bytes of global variables other than arrays, structures and unions. Arrays, structures and unions can be as large as memory will allow, and you can have as many of them as will fit in memory. In particular, arrays are not limited to 64K bytes, nor is the total space used by arrays limited to 64K bytes. Dynamically allocated memory can also exceed 64K for a single chunk of memory.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v libraries}}}{When you use the small memory model, all global variables, including arrays, structures and unions, are limited to a single 64K byte area of memory. This area of memory is shared with any functions you use from the standard C library, and if you do not use the segment statement, with your program's code. In addition, the compiler assumes that you will not allocate any single array, structure or union that is larger than 64K bytes using the Memory Manager or malloc. This restriction applies to any single structure, not to the total amount of space in use; you can allocate arrays, structures and unions whose total space exceeds 64K. These restrictions allow the compiler to generate code that is much smaller and faster than the code generated when the large memory model is used.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v segment statement}}}{It is possible to create programs that are much larger than 64K bytes in length without using the large memory model. The segment statement can be used to split a program into more than one executable code segment. The large memory model is only needed if the total global variable space exceeds 64K bytes, or if you will be creating and manipulating dynamically allocated structures, unions or arrays where a single structure, union or array exceeds 64K bytes. When you can use the segment directive instead of the large memory model, it is best to do that, since the compiler generates smaller, more efficient code in the small memory model.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v segment statement}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v run-time stack}}}{Regardless of the memory model used, you can use the segment statement to place the code for the program in various static or dynamic segments. In addition, both memory models limit the run-time stack size. For information about the run-time stack, see the stacksize command, below.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 nba}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 nba\tcl3}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v HyperStudio}}}{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$pragma\:nba\bxe }}}{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v New Button Actions}}}{\v \par }{\b\f6 #pragma nba }{\b\i\f6 start}{\b\f6 \par }\pard \qj\fi540\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The nba command is used to create a HyperStudio New Button Action (NBA).\par Normal C programs must contain a function called main. This function is the one executed when the program starts. NBAs do not have to have a function called main. Instead, you specify the name of the function that will be called when the NBA is executed as the }{\i\f6\fs20 start}{ parameter to the nba command.\par The function itself takes a single parameter of type }{\f6\fs20 HSParamPtr}{ and returns void. When the NBA is called, HyperStudio passes a pointer to a structure containing a variety of information. Information is also returned in this structure.\par HyperStudio supports a variety of callbacks; these are calls from the NBA back to HyperStudio to perform some action. From ORCA/C, callbacks are made using the }{\f6\fs20 __NBACALLBACK}{ function, defined in HyperStudio.h. (Note:  The name starts with two }{\f6\fs20 _}{ characters, not one.)  This function requires two parameters:  The callback number and a pointer to a structure like the one passed to the NBA. In most cases, you will actually pass back the same pointer passed to the NBA, but it is possible to make multiple copies of the structure. If you do make copies of the structure, though, be sure to initialize the copies carefully, generally by copying the original structure in it's entirety into the copy. There are several fields in the structure that must be initialized properly for a callback to work.\par For a definition of the }{\f6\fs20 HSParams}{ structure, along with a number of other useful declarations, see HyperStudio.h. For complete details on how to write HyperStudio NBAs, contact Roger Wagner Publishing.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 nda}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 nda\tcl3}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \keepn\widctlpar\adjustright {\pard\plain \keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v new desk accessories}}}{\pard\plain \keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$pragma\:nda\bxe }}}{\b\f6 #pragma nda }{\b\i\f6 open close action init period eventmask menuLine}{\b\f6 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The nda command is used to create a new desk accessory. New desk accessories are not executed like normal C programs; instead, they are copied into the DESK.ACCS folder in the SYSTEM folder, where they can be used from any desktop program that follows standard rules for the Apple\~II}{\fs20 GS}{.\par A new desk accessory does not require a function called main, like standard C programs. Instead, there are four standard functions which must be defined, each of which is called by the Desk Manager to carry out some predefined task. The names of these functions are listed as the first four parameters to the nda command. The next two parameters are integer constants that specify how often the desk accessory is called when it is active (the period parameter), and what kinds of events it handles (the eventmask parameter). The last parameter is the name of the new desk accessory; the name appears in the Apple menu of any desktop program that can call the desk accessory. A more detailed description of each parameter is given below.\par \par }\pard \qj\fi-1440\li1800\widctlpar\adjustright {open\tab This parameter is an identifier that specifies the name of the function that is called when someone selects your desk accessory from the Apple Menu. It must return a pointer to the window that it opens.\par \par close\tab This parameter is an identifier that specifies the name of the function to call when the user wants to close your desk accessory. It must be possible to call this function even if open has not been called. The function does not return a value.\par \par action\tab The action parameter is the name of a function that is called whenever the desk accessory must perform some action. It must declare a single integer parameter, which defines the action that the function should take. See page 5-7 of the }{\ul Apple\~II}{\scaps\ul gs}{\ul  Toolbox Reference Manual}{ for a list of the actions that will result in a call to this function. The function does not return a value.\par \par init\tab The init parameter is the name of a function that is called at start up and shut down time. This gives your desk accessory a chance to do time consuming start up tasks or to shut down any tools it initialized. This function must define a single integer parameter. The function will be zero for a shut down call, and non-zero for a start up call. The function does not return a value.\par \par period\tab This parameter tells the Desk Manager how often it should call your desk accessory for routine updates, such as changing the time on a clock desk accessory. A value of -1 tells the Desk Manager to call you only if there is a reason, like a mouse down in your window; 0 indicates that you should be called as often as possible; any other value tells how many 60ths of a second to wait between calls.\par \par eventMask\tab This value tells the Desk Manager which events your program can handle. The Desk Manager will only call your program with the events you specify in this mask.\par \par menuLine\tab The last parameter is a string. It tells the Desk Manager the name of your desk accessory. The name must be preceded by two spaces. After the name, you should always include the characters \\H**.\par }\pard \qj\fi360\widctlpar\adjustright {\par The nda command must be used before the start of the first function in the program. If it is used, you cannot use another nda command or a cda command.\par For a complete discussion of new desk accessories, see page 58.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 noroot}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 noroot\tcl3}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v root file}}}{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$pragma\:noroot\bxe }}}{\v \par }{\b\f6 #pragma noroot\par }\pard \qj\fi540\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {When ORCA/C creates a program, it generates two object files for each source file it compiles. The first object file has a suffix of .root; this file contains initialization code and a call to main. The second file has a suffix of .a, and contains the various variables and functions declared within the source file.\par In a program consisting of multiple source files, the only source file that actually needs a .root segment is the one that actually contains main. This pragma can be used in all of the other source files to tell ORCA/C not to create a .root file, which will make the finished program slightly smaller.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 optimize}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 optimize\tcl3}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\v .}{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v optimizer}}}{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$pragma\:optimize\bxe }}}{\b\f6 #pragma optimize }{\b\i\f6 parm}{\b\f6 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The optimize command is used to control the level of optimization. The various features of the optimizer can make your program smaller and faster, but optimization takes time. During the development cycle, when you are repeatedly compiling and testing your program, the time required by the optimizer is significant enough that you will probably not want to optimize your program\par The optimize command requires a single integer parameter. This parameter is actually a series of flags. For each flag, a value of 1 turns the optimization on, and a value of 0 turns it off. Even if new optimizations are added in the future, then, the command\par \par }{\f6\fs20 #pragma optimize -1\par }{\par }\pard \qj\widctlpar\adjustright {will enable all optimizations, while the command\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 #pragma optimize 0\par }{\par }\pard \qj\widctlpar\adjustright {will turn all optimizations off. If you do not use the optimize command, the compiler does not optimize your program.\par }\pard \qj\fi360\widctlpar\adjustright {Bit 0 (a value of 1) controls optimization of the intermediate code. If enabled, the intermediate code is scanned for dead code, which is removed; peephole optimization is performed; and constant expressions are evaluated at compile time.\par Setting bit 1 (a value of 2) enables the native code peephole optimizer. This optimization scans the 65816 instructions produced by the compiler, replacing some sequences of instructions with equivalent, but more efficient, instructions.\par Setting bit 2 (a value of 4) enables register optimizations. Since the 65816 only has three user registers, all of which have special, preassigned purposes, the compiler does not perform the kinds of register optimizations described in many compiler books. Instead, it scans the 65816 instructions for certain operations that can be avoided. For example, if a\par \par }{\f6\fs20 ldy #2\par }{\par }\pard \qj\widctlpar\adjustright {instruction is detected, but the compiler knows that the value in the y register is already 2, the instruction is removed. While this optimization is technically another form of peephole optimization, the way the checks are performed is substantially different from the other peephole optimizations, so a separate optimizer is used.\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v stack repair code}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v crashes}}}{Setting bit 3 (a value of 8) turns off the stack repair code normally generated by the compiler. This cuts the size of the code and makes it considerably faster, but if your program has any parameter passing errors, this optimization may cause the program to crash. For help in finding such bugs, see the debug pragma. For a description of legal parameter passing rules, see Chapter 10.\par Setting bit 4 (a value of 16) enables common subexpression elimination. This optimization checks for repeated expressions, such as the array calculation for i+1 in\par \par }{\f6\fs20 a[i+1] = b[i+1] + c[i+1];\par }{\par }\pard \qj\widctlpar\adjustright {these common subexpressions are calculated once and saved, generally making the program smaller and faster.\par }\pard \qj\fi360\widctlpar\adjustright {Setting bit 5 (a value of 32) enables loop invariant removal. This optimization checks any code sequence that loops back on itself for expressions which don't change inside the loop, removing these calculations from the body of the loop.\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\pard\plain \qj\fi360\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v small memory compiler}}}{\v \par }\pard \qj\fi360\widctlpar\adjustright {The optimize command is not supported by the small memory version of the compiler. The pragma is accepted, but has no effect on the finished program.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 path}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 path\tcl3}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$pragma\:path\bxe }}}{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$include}}}{\v \par }{\b\f6 #pragma path }{\b\i\f6 name}{\b\f6 \par }\pard \qj\fi540\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The path pragma adds a folder to the list of folders the compiler searches when looking for a file.\par By default, an include or append statement looks in the current folder when a file name is enclosed in quote marks, and in the library folder (\{MPW\}ORCACDefs:) when a file name is enclosed in <> characters. If the compiler does not find the file, it looks in the other of these two folders.\par The path pragma adds a new pathname to the list of folders that are searched. The path name itself is the }{\i name}{ parameter, which is a string. This string can be a partial pathname, in which case it is expanded to a full path name.\par Paths added with the path directive are searched immediately after the current prefix, and are searched in the order that they are encountered by the compiler. For an example, assume a program includes these path pragmas:\par \par }{\f6\fs20 #pragma path "myheaders"\par #pragma path "network:projectx:headers:"\par }{\par }\pard \qj\widctlpar\adjustright {Then for the include statement\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 #include <stdio.h>\par }{\par }\pard \qj\widctlpar\adjustright {the compiler would look for the file using the following paths, stopping as soon as a file was found:\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 \{MPW\}ORCACDefs:stdio.h\par stdio.h\par myheaders:stdio.h\par network:projectx:headers:stdio.h\par }{\par }\pard \qj\widctlpar\adjustright {For this include:\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 #include "secrets.h"\par }{\par }\pard \qj\widctlpar\adjustright {the compiler would look for the file using the following paths, again stopping as soon as a file was found:\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 secrets.h\par myheaders:secrets.h\par network:projectx:headers:secrets.h\par \{MPW\}ORCACDefs:secrets.h\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 rtl}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 rtl\tcl3}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v Inits}}}{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$pragma\:rtl\bxe }}}{\v \par }{\b\f6 #pragma rtl\par }\pard \qj\fi540\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {ORCA/C programs normally exit via a Quit call to GS/OS, but some otherwise normal programming environments require a program to exit with an RTL machine language instruction. The rtl command tells ORCA/C to create a program that exits with an RTL rather than a Quit.\par The prime example of a program that must exit with a RTL instruction is an initialization program. There are two kinds of initialization programs, permanent initialization programs (file type $B6, PIF) and temporary initialization files (file type $B7, TIF). For information about these kinds of programs, see Apple\~II File Type Notes for the appropriate file type.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 stacksize}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 stacksize\tcl3}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\v .}{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v run-time stack}}}{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$pragma\:stacksize\bxe }}}{\b\f6 #pragma stacksize }{\b\i\f6 parm}{\b\f6 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {All C programs use a run-time stack for calling functions and allocation of locally defined variables. This run-time stack is allocated from bank zero. There is no fool-proof way to determine how much memory will be available in bank zero when your program runs, although programs produced using ORCA/C will issue an error if there is not enough memory. Allocating too little memory for the stack is also a serious problem that will generally result in your program crashing, and can result in corrupting memory being used by the operating system, tools, or other programs. (See the debug command for one way to detect stack overflows.)\par All of this means that you should allocate as small a stack as possible, but that there are serious penalties if the stack is too small.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v startgraph}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v startdesk}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v SANE}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v toolbox}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v direct page}}}{By default, ORCA/C uses the stack allocated by the program launcher; this is 4K for the System 6.0 Finder, PRIZM 2.0 and the ORCA/M 2.0 shell. This memory is used by the startgraph and startdesk functions to allocate direct page space for tools. It is used in all C programs to allocate direct page space for SANE. It is also used for function calls and local variables defined by your program. The stacksize command lets you change the size of the stack. In the desktop environment, you can generally allocate a stack up to about 16K bytes; in the text environment, or in S16 programs, you can often allocate a stack of 32K bytes. The parameter for the stacksize directive is the size of the stack you wish to allocate, in bytes. If it is not a multiple of 256, the number is increased to the next even multiple of 256.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 toolparms}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 toolparms\tcl3}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\v .}{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v toolbox}}}{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$pragma\:toolparms\bxe }}}{\b\f6 #pragma toolparms }{\b\i\f6 parm}{\b\f6 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {There are several instances that arise when using the toolbox where you need to create a function that a tool will call. Tools use a different mechanism for passing parameters than ORCA/C does, so you must tell the compiler to use the toolbox's conventions. Immediately before the function, you should tell the compiler to use the toolbox's mechanism for passing parameters by using the command\par \par }{\f6\fs20 #pragma toolparms 1\par }{\par Immediately after the function, switch back to the normal calling conventions using the command\par \par }{\f6\fs20 #pragma toolparms 0\par }{\par You do not have to use the toolparms directive if the function returns void and has no parameters.\par You cannot call a function defined this way from within the C program, although the function can call other functions written in C.\par This directive changes the stack model used to pass parameters from the one normally used by the ORCA languages to the model used by the Apple\~II}{\fs20 GS}{ toolbox. It does not change the order of the parameters. In ORCA/C (and most other C compilers, for that matter) parameters are pushed onto the stack starting with the rightmost parameter and working to the left, while in the toolbox (and almost all other high-level languages) the parameters are pushed onto the stack starting with the leftmost parameter and working to the right, just as you would read the parameter list. The toolparms pragma does not affect the order in which the parameters are pushed. To change the order of the parameters, use the pascal qualifier}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v pascal qualifier}}}{.\par See also the databank command.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 xcmd}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 xcmd\tcl3}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v HyperCard}}}{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$pragma\:xcmd\bxe }}}{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v XCMD}}}{\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v XCFN}}}{\v \par }{\b\f6 #pragma xcmd }{\b\i\f6 start}{\b\f6 \par }\pard \qj\fi540\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The xcmd command is used to create a HyperCard XCMD or XCFN.\par Normal C programs must contain a function called main. This function is the one executed when the program starts. XCMDs do not have to have a function called main. Instead, you specify the name of the function that will be called when the XCMD is executed as the }{\i\f6\fs20 start}{ parameter to the xcmd command.\par The function itself takes a single parameter of type }{\f6\fs20 XCMDPtr}{ and returns void. When the XCMD is called, HyperCard passes a pointer to a structure containing a variety of information. Information is also returned in this structure.\par HyperCard supports a variety of callbacks; these are calls from the XCMD back to HyperCard to perform some action. From ORCA/C, callbacks work almost exactly like tool calls, and from the programmer's standpoint they can be treated as tool calls. The various callbacks are declared in HyperXCMD.h, a header file provided by Apple and included with ORCA/C.\par For a definition of }{\f6\fs20 XCMDPtr}{ and the structure it points to, along with a number of other useful declarations, see HyperXCMD.h. For complete details on how to write HyperCard XCMDs, see the HyperCard folder on the System 6.0 CD ROM..\par {\*\bkmkend bk6}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v preprocessor}{\rxe bk6}}}{\v \par }\pard \qc\widctlpar\adjustright {\f12\fs28 \sect }\sectd \sbkodd\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\f5\fs20 Chapter 7:   Basic Data Types\par }}\pard\plain \widctlpar\adjustright \f4\cgrid {\b\fs48 Chapter 7 \endash  Basic Data Types\par }\pard \qj\widctlpar\adjustright {\pard\plain \qj\widctlpar\adjustright \b\v\f4\cgrid {\tc {\b\v }{\b\v Chapter 7 \endash  Basic Data Types\tcl1}}}{\b\v \par }{\b \par \par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v types}}}{C has a rich variety of data types. This chapter describes those C data types which are built into the language. The next chapter covers derived and user-defined data types.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v assembly language}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v data formats}}}{Some of the information in this chapter deals with the way information is stored internally in the memory of the computer. This information is provided for very advanced programmers who need to write assembly language subroutines that will deal with C data, or who need to do strange and dangerous tricks with the data to work with the machine at the hardware level. You do not need to understand this information to use ORCA/C for normal C programming. If it does not make sense to you, or if you will not be using the information, simply ignore it.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Integers}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Integers\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v integers}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v signed}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v unsigned}}}{The C language supports four different types of integers, each of which can be signed or unsigned. The four basic integer data types are char, short, int, and long. ANSI C specifies the minimum range for each of these integer data types. While older C compilers may not implement the integers using these same sizes, and new compilers are allowed to make the integers larger, the minimum sizes specified by ANSI C also happen to the most common size for integers on microcomputers, and are the sizes used by ORCA/C.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v char}}}{Integers defined as char are the smallest. Char values require one byte of storage. Signed char values can range from -127 to 127; unsigned char values have a range of 0 to 255. The C language allows the compiler implementor to decide if char values will be signed or unsigned by default; in ORCA/C, char values are unsigned by default. All other integer types are required to be signed integers by default.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v short}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v int}}}{Short and int variables are the same size. They require two bytes of storage. Signed values can range from -32767 to 32767, while unsigned values can range from 0 to 65535.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v long}}}{Long integers require four bytes of storage. Signed long integers range from -2147483647 to 2147483647, while unsigned long integers range from 0 to 4294967295.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v integers\:storage}}}{Internally, all unsigned integers are represented as binary values. Signed integers are represented as two's complement numbers. All of the integers that occupy more than one byte of storage are stored with the least significant byte first, proceeding to the most significant byte.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Reals}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Reals\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v SANE}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v 68881}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v floating-point}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v Innovative Systems}}}{ORCA/C supports four storage formats for real numbers. In all cases, calculations are performed using SANE or the Innovative Systems' 68881 floating point card using ten byte intermediate values. With some of the formats, the numbers are stored with less precision, so that you may see different results if you compare one equation that does not save intermediate results with a mathematically equivalent set of equations that store intermediate values in the less precise number formats.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v float}}}{Float and double are required in all C compilers. Float numbers are stored in the IEEE floating point number format, with the least significant byte first. They require four bytes of storage. Float values are accurate to seven decimal digits, and allow exponents with a range of about 1e-38 to 1e38.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v double}}}{Double numbers require eight bytes of storage each. They are stored least significant byte first, using the IEEE floating point format. They are accurate to fifteen decimal digits, and allow exponent ranges from 1e-308 to 1e308.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v extended}}}{Extended numbers are peculiar to implementations of C on Apple computers. They require ten bytes of storage each. The storage format is an extended version of the IEEE format, with the values stored least significant byte first. They are accurate to nineteen decimal digits, with an exponent range of 1e-4932 to 1e4932. This is the format used internally by both SANE and the 68881 floating point coprocessor, so there is no loss of precision if intermediate variables are of type extended. In addition, floating point calculations are performed faster if you are using SANE and all numbers are stored in extended format, since a conversion from the original format to extended format is always a first step in doing a calculation with SANE. Exactly the opposite is true if you are using the 68881 floating point card. In that case, conversions are done in hardware. Float variables are faster with the 68881 card, since it takes less time to pass the number to the card and retrieve the result with the shorter formats.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v comp}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v SANE}}}{Comp format numbers are signed integers that require eight bytes of storage. They range from -(2}{\fs20\up6 63}{-1) to 2}{\fs20\up6 63}{-1. While comp numbers are integers, they are treated as a special form of floating-point number.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Pointers}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Pointers\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v pointers}}}{Pointers are represented internally as four-byte unsigned numbers, with the least significant byte stored first. A value of zero is used to represent a null pointer. Using type casting, pointers can be treated as unsigned long integers in mathematical equations with no loss of precision.\par \par }\pard \qc\widctlpar\adjustright {\f12\fs28 \sect }\sectd \sbkodd\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\f5\fs20 Chapter 8:   C Programs\par }}\pard\plain \widctlpar\adjustright \f4\cgrid {\b\fs48 Chapter 8 \endash  C Programs\par }\pard \qj\widctlpar\adjustright {\pard\plain \qj\widctlpar\adjustright \b\v\f4\cgrid {\tc {\b\v }{\b\v Chapter 8 \endash  C Programs\tcl1}}}{\b\v \par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 The Anatomy of a C Program}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 The Anatomy of a C Program\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {C programs are made up of a series of declarations. These declarations consist of declarations of global variables and declarations of functions. In most C programs, some of the functions and global variables are defined in libraries or separately compiled modules. The compiler is informed of their existence through interface files.\par While macro preprocessor commands are used in C programs to define constants and implement some operations, the macro preprocessor is not technically a part of the C language. For a description of the macro preprocessor, see Chapter 6.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 The Function main}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 The Function main\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v main}}}{All C programs except classic desk accessories and new desk accessories must have a single function called main. This function is the first one called; when you return from main, program execution stops.\par It is not important where main appears in a program; if the program consists of several modules, main can appear in any of them, regardless of the order in which the modules are compiled or linked. The important point is that a function named main must appear in exactly one of the modules.\par You may declare the function main as either a function returning an integer or as a function returning void. Declaring it as a function returning an integer allows you to send a return code back to the caller. If your program is designed to run from script files, this is an important step. It allows you to tell the script file that the program terminated normally by returning zero, or to inform the shell that an error occurred by returning a non-zero value. If you do not return a value from main, the value reported to the shell is unpredictable.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Argc and Argv}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Argc and Argv\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v main}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v argc}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v argv}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v command line}}}{The shell passes two arguments to the function main. These arguments can be ignored or used; to ignore them, don't code any parameters to the function. These arguments allow you to look at the command line used to execute your program. The sample program below shows how these arguments are used.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 /* echo the command line arguments */\par \par #include <stdio.h>\par \par int main(argc, argv)\par \par int argc;\par char *argv[];\par \par \{\par int i;\par \par for (i = 0; i < argc; ++i)\par    printf("%2d: %s\\n", i, argv[i]);\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par }{\par In this program, you see argc and argv defined as parameters to main. While you do not have to define argc and argv, if you do, they must be defined in the order shown. When your program executes, the command line used to execute your program is scanned. If you executed the program from the text environment or from the shell window on ORCA/Desktop, the command line is the line you typed or that appeared in a script file that actually executed your program. If you execute your program using the RUN command from the shell, or using the Compile to Memory or Compile to Disk commands form the desktop, the command line will be empty.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v I/O redirection}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v alias command}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v shell\: variables}}}{After I/O redirection characters are removed, aliases are expanded, and any shell variables are expanded, the command line is broken into strings. These strings are formed by scanning the command line from left to right. A string consists of any sequence of characters that contain no white space. Argc is the number of strings found, while argv is an array of pointers to the strings. If any strings are present, the first (argv[0]) is always the name of your program.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v shell window}}}{To see how these strings are built, and to experiment with the way lines are scanned, type in the sample shown above. If you are using the desktop environment, be sure to turn debugging off. Then execute the program from the text shell or shell window, supplying a variety of parameters.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Separate Compilation}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Separate Compilation\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v object files}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v separate compilation}}}{C programs can be divided into more than one module, and each module can be compiled separately from the others. The resulting object files can then be linked together, producing a single program.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v Pascal}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v assembly language}}}{The object files that make up a program are not limited to object files created by the C compiler. You can mix C code with code written using ORCA/Pascal}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ORCA/Pascal}}}{, the APW}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v APW}}}{ assembler or the ORCA/M}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ORCA/M}}}{ assembler.\par Chapter 9 covers the storage types used to hide variables and functions from other modules, and the storage types used to make functions and variables from one module available to other modules.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Interface Files}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Interface Files\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v interface files}}}{Interface files are used to tell the C compiler about functions and data that appear in libraries or separately compiled modules, and to define macros that are used in more than one module. The distinction between an interface file and a file that contains C source code is merely a matter of convention. Interface files are created using the same text editor that you use to create programs. They can be modified by you. You can even extract declarations from an interface file and embed them directly in your program.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v libraries}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v toolbox}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v $p$include}}}{In general, interface files come from two sources. ORCA/C comes with a large number of interface files that help you use the standard C libraries and the Apple\~II}{\fs20 GS}{ toolbox. These interface files are located in the ORCACDefs folder of your library directory. To include one of these interface files in your program, use a #include command, and place the name of the interface file in brackets, like this:\par \par }{\f6\fs20 #include <stdio.h>\par }{\par When you read the descriptions of the standard C libraries in Chapter 13, each description shows the #include command that should be in your program to call the function. With some functions, you can avoid using the interface file, and that was quite common in older C compilers. ORCA/C implements function prototypes, though, which allow the compiler to perform sophisticated checking on the parameters you pass to a function. If you do not use the interface file, the compiler cannot make these checks. Since illegal parameters account for a large number of bugs is C programs, many of which can crash the executing program, it is a good idea to make use of the include files.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v separate compilation}}}{The second major source of include files are those that you write yourself. These can be new libraries that you have created, in which case the interface file should be placed in the ORCACDefs folder and accessed like any other library, or they could be interface files used in a program that is made up of separately compiled modules, in which case you would use quote marks around the file name in the #include command, instead of brackets. For example, if you need to include an interface file called commondefs in your program, and the interface file is in your current working directory, you could use the statement\par \par }{\f6\fs20 #include "commondefs"\par }\pard \qc\widctlpar\adjustright {\f12\fs28 \sect }\sectd \sbkodd\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\f5\fs20 Chapter 9:   Declarations\par }}\pard\plain \widctlpar\adjustright \f4\cgrid {\b\fs48 Chapter 9 \endash  Declarations\par }\pard \qj\widctlpar\adjustright {\pard\plain \qj\widctlpar\adjustright \b\v\f4\cgrid {\tc {\b\v }{\b\v Chapter 9 \endash  Declarations\tcl1}}}{\b\v \par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Declarations}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Declarations\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {A program is made up of one or more declarations, one of which must be a function called main. The basic syntax for a program is shown below.\par \par }\pard \fi-540\li900\widctlpar\adjustright {\i\f6\fs20 program}{\f6\fs20 :   \{}{\i\f6\fs20 initialized-declaration}{\f6\fs20  | }{\i\f6\fs20 function-definition}{\f6\fs20  | }{\i\f6\fs20 asm-function-declaration}{\f6\fs20 \}*\par }{\i\f6\fs20 initialized-declaration}{\f6\fs20 :\par \tab }{\i\f6\fs20 declaration-specifiers initialized-declarator}{\f6\fs20 \par \tab \{',' }{\i\f6\fs20 initialized-declarator}{\f6\fs20 \}* ';'\par }{\i\f6\fs20 initialized-declarator}{\f6\fs20 :  }{\i\f6\fs20 declarator}{\f6\fs20  \{'=' }{\i\f6\fs20 initializer}{\f6\fs20 \}\par }{\i\f6\fs20 function-definition}{\f6\fs20 :\par \tab \{}{\i\f6\fs20 declaration-specifiers}{\f6\fs20 \} }{\i\f6\fs20 declarator}{\f6\fs20  \{}{\i\f6\fs20 declaration-list}{\f6\fs20 \}\par \tab }{\i\f6\fs20 compound-statement\par declaration-list}{\f6\fs20 :  }{\i\f6\fs20 declaration}{\f6\fs20  \{',' }{\i\f6\fs20 declaration}{\f6\fs20 \}\par }{\i\f6\fs20 declaration}{\f6\fs20 :  }{\i\f6\fs20 declaration-specifiers}{\f6\fs20  }{\i\f6\fs20 declarator-list}{\f6\fs20  ';'\par }{\i\f6\fs20 declaration-specifiers}{\f6\fs20 :  \{}{\i\f6\fs20 storage-class-specifier}{\f6\fs20  | }{\i\f6\fs20 type-specifier}{\f6\fs20 \}*\par }{\i\f6\fs20 declarator}{\f6\fs20 :\par \tab }{\i\f6\fs20 identifier}{\f6\fs20  |\par \tab '(' }{\i\f6\fs20 declarator}{\f6\fs20  ')' |\par \tab }{\i\f6\fs20 function-declarator}{\f6\fs20  |\par \tab }{\i\f6\fs20 array-declarator}{\f6\fs20  |\par \tab }{\i\f6\fs20 pointer-declarator}{\f6\fs20 \par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Storage Classes}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Storage Classes\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\i\f6\fs20 storage-class-specifier}{\f6\fs20 :  [auto | extern | register | static | typedef]\par }{\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v storage class}}}{Each function or variable has a storage class. This storage class may be assigned explicitly by starting the declaration with one of the storage class names shown above.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v libraries}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v separate compilation}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v extern}}}{For global variables and functions, if no storage class is specified, a storage class of extern is assumed. There is a difference, however, between a variable or function defined with the storage class extern, and a variable or function defined with no explicit storage class. When the storage class of extern is specified explicitly, the compiler creates a reference to the variable or function, but it is not defined. Instead, the compiler expects that the variable or function will be resolved later by the linker. When no storage class is specified, the compiler generates a variable or function that can be accessed from outside of the current module. Only one such occurrence is allowed in any one program.\par \par }\pard \qj\fi360\keepn\widctlpar\tx2880\adjustright {\f6\fs20 extern int i;\tab /* an integer declared in another module */\par }\pard \qj\fi360\widctlpar\tx2880\adjustright {\f6\fs20 extern foo();\tab /* a function declared in another module */\par \par }\pard \qj\fi360\keepn\widctlpar\tx2880\adjustright {\f6\fs20 int i;\tab /* an integer which can be accessed from */\par }\pard \qj\fi360\widctlpar\tx2880\adjustright {\f6\fs20 \tab /* another module\tab \tab \tab      */\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v auto storage class}}}{For variables defined within a function, a storage class of auto is assumed. Auto variables are available throughout the function, but cannot be accessed from outside of the function. Auto variables defined within a function lose their value when the function returns to the caller.\par \par }\pard \qj\fi360\widctlpar\tx2880\adjustright {\f6\fs20 int i;\tab /* auto integer */\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v static}}}{The static storage class has three different meanings, depending on where it is used. Functions definitions of type static are not exported to the linker. They become private to the current module, and cannot be accessed from other modules, whether or not the code is turned into a library. Function declarations (where a function is declared, but the statements that make up the function are not specified) of type static indicate that the function body will appear later in the current source file, and that the function will be of storage class static. Global variables defined with a storage type of static cannot be accessed from outside the current module. Local variables defined with a storage type of static remain intact after leaving the function. That is, any value assigned to the variable during a function call is still available when the function is called the next time.\par \par }\pard \qj\fi360\keepn\widctlpar\tx2880\adjustright {\f6\fs20 static int i;\tab /* static integer */\par }\pard \qj\fi360\widctlpar\tx2880\adjustright {\f6\fs20 static foo();\tab /* a function that will be defined later */\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v register}}}{The register storage class can only be used with variables defined within a function. It has the same meaning as auto, but instructs the compiler to handle the value in the most efficient way possible, placing the value in a register if one is available. The 65816 does not have enough user registers to leave values in a register, so in ORCA/C, this storage class has exactly the same meaning as auto.\par Unlike any other storage class, this storage class can be used with a function parameter. Again, though, ORCA/C does not do anything special with the parameter if the storage class is register.\par \par }\pard \qj\fi360\widctlpar\tx2880\adjustright {\f6\fs20 register int i;\tab /* register int */\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v typedef}}}{The storage class typedef is used to define types. The name of the type appears where the variable name would have appeared in any other declaration, and the new type has the same type that the variable would have been assigned if typedef were not used. The new type can then be used as a type specifier (see the next section).\par \par }\pard \qj\fi360\keepn\widctlpar\tx2880\adjustright {\f6\fs20 typedef int *intPtr;\tab /* definition of a type: pointer to integer */\par }\pard \qj\fi360\widctlpar\tx2880\adjustright {\f6\fs20 intPtr ip;\tab /* defining ip as a pointer to an integer */\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Type Specifiers}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Type Specifiers\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\b\v\fs36 {\*\bkmkstart bk7}\par }{\par }\pard \fi-540\li900\keepn\widctlpar\adjustright {\i\f6\fs20 type-specifier}{\f6\fs20 :\par \tab \{volatile\} \{const\}\par \tab [}{\i\f6\fs20 enumeration-type-specifier}{\f6\fs20  |\par \tab }{\i\f6\fs20 floating-point-type-specifier}{\f6\fs20  |\par \tab }{\i\f6\fs20 integer-type-specifier}{\f6\fs20  |\par \tab }{\i\f6\fs20 structure-type-specifier}{\f6\fs20  |\par \tab }{\i\f6\fs20 identifier}{\f6\fs20  |\par \tab }{\i\f6\fs20 union-type-specifier}{\f6\fs20  |\par \tab void]\par \tab \{volatile\} \{const\}\par }{\i\f6\fs20 floating-point-type-specifier}{\f6\fs20 :\par \tab float |\par \tab \{long\} double |\par \tab extended |\par \tab comp\par }{\i\f6\fs20 integer-type-specifier}{\f6\fs20 :\par \tab signed |\par \tab \{signed\} int |\par \tab \{signed | unsigned\} short \{int\} |\par \tab \{signed | unsigned\} long \{int\} |\par \tab unsigned \{int\} |\par }\pard \fi-540\li900\widctlpar\adjustright {\f6\fs20 \tab \{signed | unsigned\} char\par }\pard \qj\fi-540\li900\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v functions}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v variables}}}{The type specifier specifies the type for a variable or function. The type specifier for a function is optional, whether or not a storage class specifier is used; if omitted, int is assumed. A variable declaration must include either a storage class specifier or a type specifier (and can, of course, include both). If the type specifier is omitted, a type specifier of int is assumed.\par Type specifiers for enumerations, structures and unions are covered in separate sections, below.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v floating-point}}}{Floating-point and integer type specifiers are used to declare variables, pointers, and arrays of the various built-in data types. They all have a similar structure. Floating-point numbers come in three sizes, as detailed in Chapter 7. The smallest size requires four bytes of storage; this size is designated by the type specifier float. Double-precision numbers, requiring eight bytes of storage, can be specified as double or long double. SANE extended format numbers, requiring ten bytes of storage each, have a type specifier of extended.\par SANE also supports an eight-byte signed integer format called comp. Comp variables are treated as a special case of floating-point numbers, despite the fact that they do not support exponents or non-integer values.\par \par }\pard \qj\fi360\widctlpar\tx2880\adjustright {\f6\fs20 float a,b;\tab /* two floating-point variables */\par double sum;\tab /* sum is double-precision */\par long double sum2;\tab /* sum2 is double-precision */\par double *dp;\tab /* pointer to a double precision variable */\par extended a[10];\tab /* array of 10 extended variables */\par extern float sum();\tab /* external function returning float */\par comp big;\tab /* eight-byte signed integer */\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v integers}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v char}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v int}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v short}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v long}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v comp}}}{Integer type specifiers have a variety of formats, but are easy to understand once you know the systematic way they are defined. There are basically four types of integers: char, short, int and long. Since short and long are considered to be modifications of the basic type of int, you can follow either of these type specifiers with int, but you are not required to do so, and most programmers do not. Any of the four basic integer data types can be signed or unsigned. By default, they are all signed. If you like, you may prefix any of the types with signed, ensuring that the value is signed even if the source code is ported to another compiler. This is a good idea for char variables, since some compilers use unsigned char by default, but doesn't matter on the other integer data types, which are always signed by default. You may also create unsigned versions of each of the data types by prefixing it with unsigned. When an unsigned integer suits your needs, it is a good idea to use them. On the Apple\~II}{\fs20 GS}{, code for comparing unsigned values is much more efficient than code for comparing signed values. The examples below show some typical cases.\par \par }\pard \qj\fi360\widctlpar\tx2880\adjustright {\f6\fs20 foo();\tab /* function returning int */\par int i,j,k;\tab /* three signed integer variables */\par signed char *cp;\tab /* a pointer to a signed character */\par unsigned long l[10];\tab /* an array of 10 unsigned long integers */\par long int l;\tab /* a long int */\par short sum;\tab /* a short integer */\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v typedef}}}{When you define a type using the typedef storage class, the name of the type (and identifier) can be used as a type specifier in later declarations. For example, let's assume that a pointer to an integer has been defined as a new type:\par \par }{\f6\fs20 typedef int *intPtr;\par }{\par You can now use this type to define variables and function results.\par \par }\pard \qj\fi360\widctlpar\tx2520\adjustright {\f6\fs20 intPtr ip;\tab /* ip is a pointer to int */\par intPtr search();\tab /* search is a function returning a pointer to int */\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v void}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v functions}}}{Void is a special type specifier that declares a function that does not return a value, or that a pointer points to a generic type. There are three places where this type specifier can be used. Functions returning void are functions that do not return a value. In other languages, these are known as subroutines or procedures, and the term function is only used when a result is returned. Older C programs, written before void became a part of the language, defined functions returning int for this purpose, depending on C to dispose of the unneeded value. There are two reasons to use void explicitly on new programs:  it avoids confusion, and possibly errors, and ORCA/C generates more efficient code when exiting a function of type void than when exiting a function returning int.\par The second place where void is used is to define an untyped pointer. These should be avoided when possible, but are occasionally useful. The most common place to use this type of pointer is in functions that require a pointer to a data structure whose type can change from call to call.\par Finally, void is used in type casting to cast a pointer to an untyped pointer, making the pointer type-compatible with any other pointer. In older C programs, a pointer to char was generally used for pointers to an unspecified type.\par \par }\pard \qj\fi360\keepn\widctlpar\tx2880\adjustright {\f6\fs20 void *untyped_pointer;\tab /* an untyped pointer */\par }\pard \qj\fi360\widctlpar\tx2880\adjustright {\f6\fs20 void fn(void);\tab /* a function that returns nothing */\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v volatile}}}{Volatile is a type specifier that modifies a type. If it appears with no other type, a type of int is assumed. Volatile can appear before or after any other type specifier. Volatile is an instruction to the compiler, telling it that the value can be changed in ways that are not under control of the compiler. Examples would be hardware ports like the Apple\~II}{\fs20 GS}{ keyboard latch at 0x00C000, or variables that will be changed by interrupt handlers. The compiler is not allowed to do optimizations on volatile variables that would delay references to the variable, or change the order in which references occur.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v const}}}{Const is another type specifier which modifies an existing type. If it appears with no other type, a type of int is assumed. Const can appear before or after any other type specifier. Const variables cannot be changed by the compiler, although they can be initialized. Any attempt to change the variable will result in a compile-time error.\par {\*\bkmkend bk7}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v type specifier\bxe }{\rxe bk7}}}{\v \par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Enumerations}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Enumerations\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \fi-540\li900\keepn\widctlpar\adjustright {\i\f6\fs20 enumeration-type-specifier}{\f6\fs20 :\par \tab enum \{}{\i\f6\fs20 identifier}{\f6\fs20 \} |\par \tab '\{' }{\i\f6\fs20 enumeration-constant}{\f6\fs20  \{',' }{\i\f6\fs20 enumeration-constant}{\f6\fs20 \}* '\}'\par }{\i\f6\fs20 enumeration-constant}{\f6\fs20 :  }{\i\f6\fs20 identifier}{\f6\fs20  \{'=' }{\i\f6\fs20 expression}{\f6\fs20 \}\par }\pard \qj\fi-540\li900\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v enum}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v constants}}}{Enumerations provide an easy way to create integer constants. They are used in situations where a series of names make the program easier to read than using integer values. For example, when dealing with the 640 pixel wide screen, you have four colors available. While they can be changed, these colors default to black, purple, green and white, with integer values for the colors of 0 through 3. You could write a program that uses the integers 0 through 3 to represent these colors, or you could use preprocessor macros to create names for the colors. Enumerations provide yet another alternative. The enumeration\par \par }{\f6\fs20 enum \{black, purple, green, white\} pencolor;\par }{\par }\pard \qj\widctlpar\adjustright {defines the integer variable pencolor, and simultaneously defines four integer constants. The values of these constants start at zero and increment by one, so that\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 printf("%d\\n", green);\par }{\par }\pard \qj\widctlpar\adjustright {would write 2 to standard out.\par }\pard \qj\fi360\widctlpar\adjustright {An enumeration can be used to define a new enumeration type by including an enumeration tag before the list of enumeration constants. For example,\par \par }{\f6\fs20 enum color \{black, purple, green, white\} pencolor;\par }{\par }\pard \qj\widctlpar\adjustright {In this case, we have still defined the variable pencolor, but you can define an enumeration type without creating variables. The enumeration type color can now be used to define other variable with the same enumeration type.\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 enum color frameColor, buttonColor, menuColor;\par }{\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v expressions}}}{By default, enumeration constants are assigned values by setting the first to zero, then incrementing each successive enumeration constant by one. It is possible, however, to set each constant to an explicit integer value. Once this is done, if the next constant does not have an explicit value, a value is assigned to it by incrementing the last constant value by one, as before. To do this, follow the constant by an equal sign and a constant expression, as shown below.\par \par }\pard \qj\fi-540\li900\widctlpar\adjustright {\f6\fs20 enum month \{January = 1, February, March, April, May, June, July, August, September, October, November, December\};\par enum ages \{George = 28, Matilda = 28, Jimmy = 5, Cindy\};\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\widctlpar\adjustright {In the first case, integer values for months are assigned sequentially, but a starting value of one was needed for January. The second example shows the ages of everyone in a family. Note that it is legal to specify the same value for two different enumeration constants. Cindy's age would be six, since no specific value was specified, and the previous constant has a value of five. While these examples do not show it explicitly, any integer value may be used, including negative values.\par }\pard \widctlpar\adjustright {\par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Arrays}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Arrays\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {{\*\bkmkstart bk8}\par }\pard \fi-540\li900\keepn\widctlpar\adjustright {\i\f6\fs20 array-declarator}{\f6\fs20 :  }{\i\f6\fs20 declarator}{\f6\fs20  '[' \{}{\i\f6\fs20 constant-expression}{\f6\fs20 \} ']'\par }\pard \qj\fi-540\li900\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Arrays are indexed lists of data, where all of the data in the array has the same type. In C, you can form arrays of any type except functions (although arrays of pointers to functions are legal), including arrays of structures, unions, or other arrays. To define an array, follow the declarator for the variable with a left bracket, a constant expression, and a right bracket. The constant expression is evaluated, and used to determine how many elements are in the array. The first element is indexed with a value of zero, and remaining indices are formed by adding one to the previous index.\par For example, to form an array of ten integers, and then fill the array with the numbers one through ten, you could use the following statements:\par \par }{\f6\fs20 int a[10],i;\par \par for (i = 0; i < 10; ++i)\par    a[i] = i+1;\par }{\par }\pard \qj\widctlpar\adjustright {It is important to keep in mind that the lowest index is zero, and the highest is one smaller than the number of subscripts. So, in the example just given, there is no tenth element of the array. That is, a[10] does not exist, and storing a value at a[10] may cause the program to crash.\par }\pard \qj\fi360\widctlpar\adjustright {Arrays of more complicated elements are formed the same way as arrays of simple variables. For example, to form an array of points, where a point is defined as a structure containing three float numbers, you could use\par \par }{\f6\fs20 struct point \{float x,y,z;\};\par struct point list[100];\par }{\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v arrays\:multiple subscripts}}}{C does not allow multiply subscripted arrays, but it does allow arrays of arrays, which amount to the same thing. For example, to create a ten by ten matrix of float values, you would use the declaration\par \par }{\f6\fs20 float a[10][10];\par }{\par }\pard \qj\widctlpar\adjustright {The following code shows how to access elements of the array by forming the identity matrix (a matrix with ones along the diagonal, and zeros everywhere else).\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 for (i = 0; i < 10; ++i) \{\par    for (j = 0; j < 10; ++j)\par       a[i][j] = 0.0;\par    a[i][i] = 1.0;\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20    \}\par }{\par In some cases, it is permissible to define an array without specifying the size. This is true for singly-dimensioned arrays that are external to the current unit, arrays that are passed as a parameter to a function, and arrays that are initialized. In the first two cases, the compiler does not need to know the exact size of the array, since storage for the array is allocated elsewhere. It is up to you to make sure that you do not access values beyond the end of the array. Even in these cases, if the array is an array of arrays, all subscripts but the first must be specified. In the case of an initialized array, the compiler determines the size of the array by counting the initializers. The following example shows legal and illegal declarations of external arrays.\par \par }\pard \qj\fi360\keepn\widctlpar\tx2880\adjustright {\f6\fs20 extern int a[][10];\tab /* legal:  ? by 10 array of int */\par }\pard \qj\fi360\widctlpar\tx2880\adjustright {\f6\fs20 extern int b[10][];\tab /* NOT LEGAL! */\par int a[] = \{1,2,3\};\tab /* legal:  three elements */\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v arrays\:storage}}}{The array is stored in memory in such a way that the first subscript indexes the slowest. To visit sequential locations in memory, you would use a[0][0], a[0][1], a[0][2], and so forth.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v arrays\:memory requirements}}}{The size of an array is the number of elements in the array times the size of an array element. In the previous example, each floating-point number requires four bytes of storage, so an array with ten elements requires forty bytes of storage. The array of these ten element arrays also has 10 elements, so the array }{\f6\fs20 a}{ requires 400 bytes of storage. In a program, you would normally use the sizeof operator to determine the size of an array.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v arrays\:size limits}}}{Using the small memory model (which is the default), the largest single array that is allowed is 64K bytes. In addition, the total length of all variables, libraries, and code from your program that is not placed in another segment using the segment command is 64K bytes. The large memory model lifts these restrictions at a price of less efficient code. With the large memory model, an array can be as large as the largest free block of memory, so long as there is enough memory to load all global variables and static segments. With a memory card with enough memory, you could manipulate an array that is nearly eight megabytes long.\par {\*\bkmkend bk8}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v arrays\bxe }{\rxe bk8}}}{\v \par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Pointers}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Pointers\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {{\*\bkmkstart bk9}\par }\pard \fi-540\li900\keepn\widctlpar\adjustright {\i\f6\fs20 pointer-declarator}{\f6\fs20 :  '*' \{}{\i\f6\fs20 type-specifier}{\f6\fs20 \}* }{\i\f6\fs20 declarator}{\f6\fs20 \par }\pard \qj\fi-540\li900\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {A pointer is a data type that holds the address of another object. Pointers are represented internally as unsigned four-byte values. The value is the address of the object pointed to by the pointer. A pointer is defined by placing an * to the left of the variable, as in\par \par }{\f6\fs20 int *ip\tab /* ip is a pointer to an integer */\par }{\par Two operators are used to handle pointer types. The * operator, when used before a pointer, tells the compiler to load the object pointed to by the pointer. The & operator, when used before any l-value, tells the compiler to load the address of the object, rather than the actual object. The following code fragment uses the & operator to cause ip to point to the integer i, then sets i to four using a reference through the pointer, and finally prints the value of i directly and as a reference through the pointer ip.\par \par }\pard \qj\fi360\widctlpar\tx3600\adjustright {\f6\fs20 ip = &i;\tab /* ip now points to i */\par *ip = 4;\tab /* i now has a value of 4 */\par printf("%d = %d\\n", i, *ip);\tab /* both values printed will be 4 */\par }\pard \qj\fi360\widctlpar\adjustright {\par Pointers can be defined to point to any other data type except a bit field, including other pointers, functions or void.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v const}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v volatile}}}{ANSI C allows a pointer to have a type specifier before the declarator. This is generally used with the type specifiers volatile and const, but the type specifier is not restricted to just those two types. Const and volatile can be used in conjunction with other types, so they modify the existing type of the pointer. For example, the declaration\par \par }{\f6\fs20 int * const ip;\par }{\par }\pard \qj\widctlpar\adjustright {declares a pointer to an integer, and states that the pointer cannot be modified. If a type specifier other than const or volatile is used, it overrides the existing type. For example, the following declaration creates a pointer to a float variable.\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 int * float fp;\par }{\par }\pard \qj\widctlpar\adjustright {The best that can be said for such a declaration is that it is legal. Such declarations are confusing, and should not be used in real programs.\par }\pard \qj\fi360\widctlpar\adjustright {There are many other operators that can be used with pointers in C, including the array subscript operator, the increment and decrement operators, addition and subtraction, and comparisons. Chapter 11 discusses these topics.\par {\*\bkmkend bk9}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v pointers}{\rxe bk9}}}{\v \par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Structures}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Structures\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\b\v\fs36 {\*\bkmkstart bk11}\par }{\par }\pard \fi-540\li900\keepn\widctlpar\adjustright {\i\f6\fs20 structure-type-specifier}{\f6\fs20 :\par \tab struct }{\i\f6\fs20 identifier}{\f6\fs20  |\par \tab struct \{}{\i\f6\fs20 identifier}{\f6\fs20 \} '\{' }{\i\f6\fs20 field-list}{\f6\fs20  '\}'\par }{\i\f6\fs20 field-list}{\f6\fs20 :  }{\i\f6\fs20 component-declaration}{\f6\fs20  \{',' }{\i\f6\fs20 component-declaration}{\f6\fs20 \}*\par }{\i\f6\fs20 component-declaration}{\f6\fs20 :  }{\i\f6\fs20 type-specifier}{\f6\fs20  }{\i\f6\fs20 component}{\f6\fs20  \{',' }{\i\f6\fs20 component}{\f6\fs20 \}*\par }{\i\f6\fs20 component}{\f6\fs20 :\par \tab }{\i\f6\fs20 declarator}{\f6\fs20  |\par \tab \{}{\i\f6\fs20 declarator}{\f6\fs20 \} ':' }{\i\f6\fs20 expression}{\f6\fs20 \par }\pard \qj\fi-540\li900\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Structures are collections of variables that do not have to have the same type. With the exception of bit fields, each variable in a structure has a name, just as variables in other parts of the program do. (The name is optional on a bit field.)  Variables in a structure are called components, and the names of the variables are called component names. Each of the component names must be distinct from any other component name in the same structure. A structure can contain elements of any type except a function or void. Pointers to functions are allowed, but a function declaration cannot appear as a part of a structure.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v structures}}}{It is possible to define a structure type without defining variables, and then define variables later; to define a structure variable without defining a type; and to define both a type and variables at the same time. We will look at the general form by examining a structure that implements a linked list of points, with each point consisting of three float numbers.\par \par }{\f6\fs20 struct point \{struct point *next; float x,y,z;\} p, *list;\par }{\par }\pard \qj\widctlpar\adjustright {This structure contains four elements:  next, x, y and z. X, y and z are the three float variables that record the position of the point. Next is a pointer to another structure of type point. Note that it is permissible to use the definition of the structure point, so long as we are defining a pointer to the structure. Trying to recursively define the structure would be illegal, since the compiler could not compute the size of the structure. Finally, two variables are defined. The first, p, is a structure of type point, while the second is a pointer to a structure of type point.\par }\pard \qj\fi360\widctlpar\adjustright {Further variables of type point may be defined by using the structure name (called the tag) without redefining the form of the structure. For example, we could define three more points like this:\par \par }{\f6\fs20 struct point p1, p2, p3;\par }{\par The tag field of the structure is optional. If you omit the tag field, however, no other variables of the same type can be created later in the program.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v structures\:size}}}{The size of a structure can be determined by summing the size of each component. In the structure point, there are four elements, each of which is four bytes long, so the size of the variable p is sixteen bytes. The values appear in memory in the same order in which they are defined. In our example, next occurs first, followed by x, then y, and finally by z.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v structures\:accessing elements}}}{To access a component of a structure, the name of the structure is followed by a period and the name of the component name of the variable to be accessed. For example, to initialize the point p to (1.0,2.0,3.0), with a null pointer, we would use the assignments\par \par }{\f6\fs20 p.x = 1.0;\par p.y = 2.0;\par p.z = 3.0;\par p.next = NULL;\par }{\par }\pard \qj\widctlpar\adjustright {To set p1 to the reflection of p through the origin, we could use the statements\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 p1.x = -p.x;\par p1.y = -p.y;\par p1.z = -p.z;\par }{\par To access an element of a structure through a pointer to the structure, the -> operator is used. For example, to move the point pointed to by list two times further away from the origin, you would need to multiply each of the coordinates in the point by two. The following statements will make this change.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 list->x = list->x*2.0;\par list->y = list->y*2.0;\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 list->z = list->z*2.0;\par }{\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v structures\:assigning}}}{Structures may be assigned to other structures of the same type. For example, using the declarations from our examples, the following assignments are legal.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 p1 = p2;\par *list = p;\par p3 = *list;\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 p1 = *p.next;\par }{\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v structures\:in functions}}}{Functions can be defined which accept structures as parameters and which return structures as results. The following example shows a function which takes two points as parameters, and returns a point midway between the two inputs.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 struct point midpoint(struct point a, struct point b)\par \par \{\par struct point c;\par c.x = (a.x + b.x) / 2.0;\par c.y = (a.y + b.y) / 2.0;\par c.z = (a.z + b.z) / 2.0;\par return c;\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par }{\par }\pard \qj\widctlpar\adjustright {Using this function to find a point midway between p1 and p2, storing the result in p3, we would code\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 p3 = midpoint(p1,p2);\par }{\par {\*\bkmkstart bk10}Bit fields are a data type peculiar to structures. A bit field is an integer data type which is bit-aligned, rather than byte-aligned. They can be used to store integers in a very compact fashion, or to access bits within a byte of memory. To see how this is done, we will define a simple structure using bit fields.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 struct pack \{\par    unsigned field1 : 9;\par    unsigned        : 2;\par    unsigned field2 : 4;\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20    \} v;\par }{\par Each of the fields in this structure requires a specific number of bits, not bytes. Field1 requires nine bits; it takes up all of the first byte, and the first (most significant) bit of the next byte. It is an unsigned integer, with a range of 0 to 511. The next bit field has no name; it is only there to reserve a specific amount of space. Field2 requires four bits of space, and has a range of 0 to 31. The variable v, then, requires fifteen bits of space. In all cases where a series of bit fields does not end on a byte boundary, the compiler in effect creates another field to fill out the bits to an even byte boundary. In this example, one bit must be added, so that the variable v uses sixteen bits (two bytes). The two bits between field1 and field2, and the bit that comes after field2 cannot be accessed from the program, and their values are not predictable.\par Bit fields may be interspersed with other variables in a structure, as shown in the second example, below.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 struct data \{\par    unsigned color640 : 2;\par    int i;\par    unsigned color320 : 4;\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20    \} v;\par }{\par The variables which are not bit fields must start on a byte boundary. Thus, the variable color640 only requires two bits, but since the variable i must start on a byte boundary, the entire structure requires four bytes of storage (one each for color640 and color320, and two for i). A simple rearrangement of the structure reduces the memory requirements by one byte.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 struct data \{\par    unsigned color640 : 2;\par    unsigned color320 : 4;\par    int i;\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20    \} v;\par }{\par ORCA/C supports both signed and unsigned bit fields. Unsigned bit fields are stored in binary format. The range that can be represented is 0 to 2}{\fs20\up6 b}{-1, when b is the number of bits in the bit field. Signed values are represented in two's complement form, giving a valid range of -2}{\fs20\up6 b-1}{ to 2}{\fs20\up6 b-1}{-1. The maximum size for a bit field is thirty-two bits.\par Accessing bit fields is very inefficient compared to accessing integers. If speed is an issue, avoid their use.\par Programs that make use of bit fields are difficult to port from machine to machine, so bit fields should be used sparingly, if at all. Not all compilers support signed bit fields. The maximum size for a bit field varies from compiler to compiler, and the way bit fields are stored internally also varies.\par {\*\bkmkend bk10}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v bit fields}{\rxe bk10}}}{\*\bkmkend bk11}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v structures\bxe }{\rxe bk11}}}{\v \par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Unions}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Unions\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\b\v\fs36 {\*\bkmkstart bk12}\par }{\par }\pard \fi-540\li900\keepn\widctlpar\adjustright {\i\f6\fs20 union-type-specifier}{\f6\fs20 :\par \tab union }{\i\f6\fs20 identifier}{\f6\fs20  |\par \tab union \{}{\i\f6\fs20 identifier}{\f6\fs20 \} '\{' }{\i\f6\fs20 field-list}{\f6\fs20  '\}'\par }\pard \qj\fi-540\li900\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v unions\:size}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v unions\:accessing elements}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v unions\:in functions}}}{A union has a syntax similar to that of a structure and, like structures, contains named elements called components. Unlike structures, bit fields are not allowed in unions. Like structures, components of unions can be of any type except function returning or void. Within any one union type, each component name must be unique. No component can be of the same type as the union in which it appears, but components can point to unions of the same type.\par Components of unions are accessed the same way as components of a structure. Unions can be assigned to other unions of the same type and returned as the result of a function, just like structures. The major difference between structures and unions is in how storage is allocated for the components. In a structure, memory is assigned to each variable in turn, and the total size of the structure is the sum of the sizes of all of the components. In a union, each of the variables overlaps. The size of the union is the size of the largest component, since only one of the components is stored in the union at any one time. Unions are most useful in situations where two or more types of data will be stored in a location, but the two do not need to be stored at the same time. As an example, let's consider a program that evaluates expressions, and needs to store variable values. We will assume that the name of the variable must be stored, and that it is limited to ten characters. We will also assume that the variables can be integer or float. Since a single variable couldn't be both integer and float at the same time, we will use a union to overlay the int and float variables, saving space.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 enum kind \{integer, real\};\par struct variable \{\par    char name[11];\par    enum kind vkind;\par    union \{\par       int ival;\par       float rval;\par       \} val;\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20    \};\par }{\par }\pard \qj\widctlpar\adjustright {This example also shows the use of a tag field to record the type of value stored in the union. While this is not required, it is often useful. Without a tag field, your program must have some other way of figuring out if the value stored in the union is an integer or a floating-point number.\par }\pard \qj\fi360\widctlpar\adjustright {To evaluate the storage requirements for the structure, we first determine the size of the union. Ival is two bytes long, while rval is four bytes long. The union, then, is four bytes long. The name of the variable requires eleven bytes, and the tag field, which is an integer, requires another two bytes. The total size of the structure, then, is seventeen bytes.{\*\bkmkend bk12}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v unions\bxe }{\rxe bk12}}}{\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Initializers}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Initializers\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\b\v\fs36 {\*\bkmkstart bk13}\par }{\par }\pard \fi-540\li900\keepn\widctlpar\adjustright {\i\f6\fs20 initializer}{\f6\fs20 :\par \tab }{\i\f6\fs20 expression}{\f6\fs20  |\par \tab '\{' }{\i\f6\fs20 initializer-list}{\f6\fs20  \{','\} '\}'\par }{\i\f6\fs20 initializer-list}{\f6\fs20 :  }{\i\f6\fs20 initializer}{\f6\fs20  \{',' }{\i\f6\fs20 initializer}{\f6\fs20 \}*\par }\pard \qj\fi-540\li900\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v integers\:initialization}}}{When a variable is defined, the declaration can include an initializer which specifies the initial value for the variable. Variables with a storage class of static and extern can only be initialized with a constant expression. All static and extern variables that are not explicitly initialized are initialized with a value of zero. Function parameters cannot be initialized.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v floating-point\:initialization}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v enumerations\:initialization}}}{Integer, enumeration and floating-point variables are initialized by following the variable name with an equal sign and the initial value. The initial value can be enclosed in braces, but the usual practice is to omit the braces. Non-constant expressions can be used to initialize variables that have a storage class other than extern or auto. In that case, the compiler generates the same code that would be generated if the variable was initialized via an assignment statement.\par The following examples show some legal initializations.\par \par }{\f6\fs20 i = 4;\par auto j = i*4;\par static float x = 1.0, y = 2.0, z = 0.0;\par }{\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v enumerations\:initialization}}}{An enumeration can be initialized to an enumeration constant or to an integer value. As with integers, the expression must be a constant expression if the storage class of the enumeration variable is extern or static. For example, we can define an enumeration, declare a variable, and assign the variable an initial value all in one step, like this:\par \par }{\f6\fs20 enum color \{black,purple,green,white\} pencolor = white;\par }{\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v pointers\:initialization}}}{Initialization of pointers follow the same rules as initialization of integers. The following operands are all constants, and can be used in a constant initializer for a pointer:\par \par }\pard \qj\fi-360\li720\widctlpar\adjustright {1.\tab The integer constant 0 (or the preprocessor macro NULL).\par 2.\tab The name of a static or external function.\par 3.\tab The name of a static or external array.\par 4.\tab The & operator when applied to a static or external variable.\par 5.\tab The & operator when applied to a static or external array with constant subscripts.\par 6.\tab A non-zero integer constant cast as a pointer type.\par 7.\tab A string constant.\par 8.\tab An integer constant added or subtracted to any of the items 3 through 7.\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v arrays\:initialization}}}{Arrays are initialized by enclosing the initializers in braces, and separating them with commas. Each initializer in an array must be constant expressions. The example below shows the initialization of a ten-element array.\par \par }{\f6\fs20 int a[10] = \{1,2,3,4,5,6,7,8,9,10\};\par }{\par }\pard \qj\widctlpar\adjustright {Multi-dimensioned arrays follow the same pattern:\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 int a[2][2] = \{\{1,2\},\{3,4\}\};\par }{\par }\pard \qj\widctlpar\adjustright {In this case the initial values are as follows:\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\li2880\widctlpar\tx4140\adjustright {a[0][0]\tab 1\par a[0][1]\tab 2\par a[1][0]\tab 3\par a[1][1]\tab 4\par }\pard \qj\fi360\widctlpar\adjustright {\par There are four special rules used when dealing with array initializers. First, if an initializer for an array contains fewer values than the size of the array, the remainder of the array elements are initialized to zero. The second rule is that the size of an array does not need to be specified. In that case, the size of the array is derived from the number of initializers. For example, the following array has five elements, initialized to one through five.\par }{\f6\fs20 int a[] = \{1,2,3,4,5\};\par }{\par }\pard \qj\widctlpar\adjustright {Another special case is an array of characters. An array of characters can be initialized using a string, as in\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 char str[15] = "Hello, world.\\n";\par }{\par }\pard \qj\widctlpar\adjustright {The compiler automatically places a terminating null character at the end of the string constant. Finally, if the initializer list contains the proper number of elements, all embedded braces may be omitted. Repeating our previous example using this rule, we have\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 int a[2][2] = \{1,2,3,4\};\par }{\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v structures\:initialization}}}{Structures are initialized by enclosing all of the values in braces and separating them with commas. As with arrays, if the number of values supplied is less that the number of variables in the structure, the remaining elements are set to zero. In addition, if a structure is embedded in another structure, and the correct number of initializers are supplied, the braces around the initializers for the embedded structure may be dropped.\par \par }{\f6\fs20 struct point \{float x,y,z;\} p1 = \{1.0,2.0,3.0\};\par struct line \{point p1,p2\} line1 = \{1.0,2.0,3.0, 2.0,3.0,4.0\};\par struct line2 = \{\{1.0,2.0\}, \{2.0,3.0\}\};\par }{\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v unions\:initialization}}}{The first component of a union can be initialized with an expression resulting in the same type as the component. If the storage class for the union is auto, the first component must have a type that could be initialized if the component were specified as a separate auto variable. For example,\par \par }{\f6\fs20 union nums (float f; int i;\} x = 0.0;\par }{\par For all global or static variables, if no initializer is given, the variable is initialized to zero.\par The way initializations are handled by the compiler depends on where the variable is declared. Global and static variables are initialized by setting the memory area reserved for the variable to the correct initial value. Auto and register variables defined in a function are initialized using code that is equivalent to an assignment statement.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v extern}}}{If a variable is declared with an explicit storage class specifier of extern, it cannot be initialized.\par {\*\bkmkend bk13}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v initializers\bxe }{\rxe bk13}}}{\v \par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Constructing Complex Data Types}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Constructing Complex Data Types\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The facilities described in this chapter show how to declare variables in a variety of simple data types. You can also combine many of these attributes, creating complex definitions in a single step. For example,\par \par }{\f6\fs20 float (*arr[10])();\par }{\par }\pard \qj\widctlpar\adjustright {defines a ten-element array of pointers to functions returning float. With some restrictions, any combination of storage class specifiers, type specifiers and declarators can be used to form a type. These restrictions are:\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\fi-360\li720\widctlpar\adjustright {1.\tab }{\pard\plain \qj\fi-360\li720\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v void}}}{Void can only be used as the type returned by a function or pointed to by a pointer.\par \par 2.\tab }{\pard\plain \qj\fi-360\li720\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v arrays}}}{Arrays, structures and unions may contain pointers to functions, but may not contain functions.\par \par 3.\tab }{\pard\plain \qj\fi-360\li720\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v functions\:return type}}}{Functions can return structures, unions or pointers to arrays, but they cannot return an array.\par \par 4.\tab Functions cannot return another function. They can return a pointer to another function, however.\par }\pard \qj\fi360\widctlpar\adjustright {\par To read the type of a variable, it is important to understand the precedence of the declarator operators. Basically, declarators that appear to the right of the variable (arrays and functions) have a higher precedence than declarators appearing to the left (pointers). The declarator that is closest to the variable has the highest precedence. Parentheses can be used to override the normal precedence. To see how this is done, we will use an absurdly complex declaration.\par \par }{\f6\fs20 struct point \{float x,y,z;\} *(*(*(*x)())[10])();\par }{\par }\pard \qj\widctlpar\adjustright {Starting at the variable, we can read off the type. The variable x is a pointer to a function returning a pointer to a ten-element array of pointers to functions returning pointers to structures that contain three float variables. In a real program, such a declaration would probably not be needed. If such a declaration was needed, it would be easier to define using typedefs.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Scope and Visibility}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Scope and Visibility\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\*\bkmkstart bk14}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v variable scope\:see scope}{\txe }}}{All declarations that appear outside of a function are available from the declaration point to the end of the source file, unless some other declaration masks the declaration.\par Function parameters are available throughout the function unless some other declaration masks the parameter. Parameters cannot be accessed from outside the function, even from a function called by the one that defined the parameters. (Pointers to variables can, of course, be passed to another function, and the value changed, but the called function cannot access the variable using the original name.)  A function parameter can have the same name as a global variable or function, in which case the global variable or function cannot be referenced from the function. For example, the code fragment\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 int count;\par \par void test(float count)\par \par \{\par /* statements go here */\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par }{\par }\pard \qj\widctlpar\adjustright {is legal. Any function declared after the global declaration of count can use or modify count, but that variable cannot be used or modified from within the function test. Inside test, count refers to the float parameter.\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v parameters}}}{Variables defined at the top of the function body are also available anywhere in the function, and are not available from outside of the function. Variables defined at the top of the function body cannot duplicate the names of parameters, but they can duplicate global variables or functions.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 int count;\par \par void test(void)\par \par \{\par double count;\par ...\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par }{\par }\pard \qj\widctlpar\adjustright {Within the function, references to count use the double variable.\par }\pard \qj\fi360\widctlpar\adjustright {Any compound statement within a function can declare variables whose scope is limited to the duration of the compound statement. These variables cannot be accessed from outside the compound statement, although they can be used from compound statements embedded in the one where the variable is declared. Variables defined within a compound statement can reuse the names of global variables or functions, parameters, or variables defined in the program body or other compound statements. For example, the following function will print 1, 2 and 1 to standard out.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 void print(void)\par \par \{\par int i;\par \par i = 1;\par printf("%d\\n", i);\par    \{\par    int i;\par \par    i = 2;\par    printf("%d\\n", i);\par    \}\par printf("%d\\n", i);\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par }{\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v macros\:scope}}}{Preprocessor macros are available from the point they are defined to the end of the source file or to the undef command that removes the macro definition. Note that since macro expansion conceptually occurs before the program is compiled, once a macro is defined, and occurrence of the macro name will be replaced by the macro body, even if that occurrence appears to be defining a new variable. For example,\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 #define name sally\par int name;\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\widctlpar\adjustright {defines a new variable called sally, not a variable called name.\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v labels\:scope}}}{Labels in a function are available throughout the function in which the label appears.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v overloading classes}}}{There are several cases in C where a name can be duplicated within the same function, or in the global declaration area. The ability to do this is called overloading. The reason is that C maintains several different tables of symbols. The overloading classes are:\par \par }\pard \qj\fi-360\li720\widctlpar\adjustright {1.\tab Preprocessor macro names\par 2.\tab Statement labels\par 3.\tab Structure, union and enumeration tags\par 4.\tab Components of structures or unions\par 5.\tab Other names (variables, functions, typedef names, enumeration constants)\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v structures}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v unions}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v enum}}}{What this means is that the same name can be reused within a function, so long as it is not used more than once within the same overloading class. Another important point is that each structure and union has its own overloading class; thus, it is legal to define two structures or unions, and to use the same component names in the various structures and unions. This is, in fact, one of the few places where it is reasonable to take advantage of the overloading classes. For example, if you are defining more than one kind of linked list, it would be very reasonable to name the pointer to the next structure next in each of the structures. The following example shows each of these rules in effect.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 void test(void)\par \par \{\par #define name gorp\par int name;\par enum name \{Fred, Joe\};\par struct s \{int name\};\par union u \{int name\};\par goto name;\par name: ;\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}{\*\bkmkend bk14}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f6\fs20\cgrid {\xe {\v\f6\fs20 }{\v\f6\fs20 scope}{\rxe bk14}}}{\f6\fs20 \par }\pard \qc\widctlpar\adjustright {\f12\fs28 \sect }\sectd \sbkodd\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\f5\fs20 Chapter 10:   Functions\par }}\pard\plain \widctlpar\adjustright \f4\cgrid {\b\fs48 Chapter 10 \endash  Functions\par }{\pard\plain \widctlpar\adjustright \v\f4\cgrid {\tc {\v }{\v Chapter 10 \endash  Functions\tcl1}}}{\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Declaring a Function}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Declaring a Function\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \fi-540\li900\keepn\widctlpar\adjustright {\i\f6\fs20 function-declarator}{\f6\fs20 :\par \tab }{\i\f6\fs20 declarator}{\f6\fs20 \par \tab '('\par \tab [}{\i\f6\fs20 parameter-type-list}{\f6\fs20  \{',' '.' '.' '.'\} |\par \tab \{}{\i\f6\fs20 parameter-list}{\f6\fs20 \} ]\par \tab ')'\par \tab \{inline '(' [}{\i\f6\fs20 long-integer}{\f6\fs20  ',' ] }{\i\f6\fs20 long-integer}{\f6\fs20  ')'\}\par }{\i\f6\fs20 asm-function-declaration}{\f6\fs20 : asm }{\i\f6\fs20 identifier}{\f6\fs20  '\{' \{}{\i\f6\fs20 asm-line}{\f6\fs20 \}* '\}'\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v functions\:declaration}}}{C function declarations can be intermixed with other declarations throughout the program. The only restriction is that a C function cannot be defined within the body of another function.\par A function declaration looks very much like the declaration of any variable. The two major differences are than functions do not have to have a type specifier, and the type is always function returning something. When a function is declared without a type specifier, a type specifier of int is assumed. For example, the following two declarations are almost identical, but the first defines a function returning a pointer to int, while the second defines a pointer to a function returning int.\par \par }{\f6\fs20 int *f();\par int (*f)();\par }{\par It is also possible to declare a function automatically. This happens when a function that has not been declared is used in an expression, as in\par \par }{\f6\fs20 x = test();\par }{\par When a function is declared automatically, it is assumed to be a function returning int. Any later declarations or definitions must also be for a function returning int. To avoid problems, and to make effective use of function prototypes, it is a good idea to declare all functions before they are used.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v functions\:return type}}}{Functions can be defined to return any type except a function or array. Functions can be defined to return pointers to other functions or arrays, however.\par There is a fine distinction between a function declaration and a function definition. A function declaration tells the compiler that a function exists, either later in the same source file, in a separately compiled or assembled module, or in a library, but does not include the statements that tell the compiler what the function is supposed to do. A function definition includes a function body, which is a compound statement. To declare a function, follow the declaration with a semicolon, as shown above. To define a function, follow the declaration with the function body, like this:\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 void greet(void)\par \par \{\par printf("Hello, world.\\n");\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par }{\par }\pard \qj\widctlpar\adjustright {Note that there is no semicolon after the closing parenthesis in the first line. It is an error to place one there.\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v functions\:extern}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v functions\:static}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v separate compilation}}}{Whenever a function is declared in a program, the compiler assumes that the definition occurs elsewhere. If the definition is not within the current program segment, you must use the extern storage class specifier, as in\par \par }{\f6\fs20 extern void greet(void);\par }{\par The storage class extern can also be used when the function definition will appear later in the same source file. The storage class static can also be used to declare a function that will be defined later in the same source file. The difference between the two is that, with the storage class static, the function must appear in the same source file, and static functions are not available outside the source file, while functions with a storage class of extern can be called from separately compiled modules.\par The default storage class for a function is extern.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v functions\:inline}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v inline}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v toolbox}}}{ORCA/C supports two special kinds of function definitions. The first is an inline definition, used to create header files for functions at a fixed address, such as the Apple\~II}{\fs20 GS}{ tools. An inline declaration replaces the function body with the word inline, followed by one or two integer constants enclosed in parentheses and separated by a comma.\par The inline directive is used one of two ways. When writing Apple\~II}{\fs20 GS}{ toolbox header files, the inline directive is always coded with two integers and the pascal qualifier, as in this declaration from QuickDraw.h:\par \par }\pard \qj\fi360\keepn\widctlpar\tx1440\tx2160\adjustright {\f6\fs20 extern pascal void LineTo(Integer, Integer) inline(0x3C04, dispatcher);\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\widctlpar\adjustright {In this case, the first integer in the inline directive is the tool number; it is passed in the X register when the call is made. The second number is the address to call. For normal Apple\~II}{\fs20 GS}{ tool calls, this will be 0xE10000. The tool header files use the macro dispatcher, which is equated to 0xE10000 in types.h. By varying the second value, which is the call address, you can create header files for user tools, or for any other functions at a fixed address that use toolbox calling conventions.\par }\pard \qj\fi360\widctlpar\adjustright {The inline directive is also used to create headers for functions that use ORCA/C calling conventions, but that are located at a fixed address. In this case, the pascal qualifier is not used. While the first integer can be coded, it is ignored. As with any C function declared using ORCA/C, the X register is undefined upon entry to the function.\par For example, given the declaration\par \par }\pard \qj\fi360\keepn\widctlpar\tx1440\tx2160\adjustright {\f6\fs20 extern int FixedFunction (int) inline(0x01ABCD);\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\widctlpar\adjustright {the call\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 j = FixedFunction(5);\par }{\par }\pard \qj\widctlpar\adjustright {would call a C function at the fixed address 0x01ABCD.\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v functions\:asm}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v asm statement}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v assembly language}}}{Another type of function is a function written entirely in assembly language. These functions have a return type and a parameter list, just as other functions do. The compiler uses the function return type and parameter list to check function calls in the rest of the program to make sure parameters are passed correctly, and to check to make sure that the value returned by the function is used in a legal way, but it is up to you to actually write the assembly language statements that use the parameters, remove them from the stack before returning to the caller, and to return any values to the caller.\par }\pard \qj\fi360\keepn\widctlpar\adjustright {An example of an assembly language function is shown below.\par \par }\pard \qj\fi360\keepn\widctlpar\tx1440\tx2160\adjustright {\f6\fs20 /* See if a key has been pressed; return 128 is so, and 0 otherwise */\par \par asm int keypress ()\par \par \{\par \tab lda\tab >0xC000\par \tab and\tab #0x0080\par \tab rtl\par }\pard \qj\fi360\widctlpar\tx1440\tx2160\adjustright {\f6\fs20 \}\par }\pard \qj\fi360\widctlpar\adjustright {\par For a description of the syntax of assembly language statements, see the description of the asm statement in Chapter 12. For details on how parameters are passed and how function values are returned, see Chapter 4.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Parameters}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Parameters\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v functions\:parameters - see parameters}}}{{\*\bkmkstart bk15}In addition to returning a result, functions can take inputs in the form of passed parameters. C supports two different ways of handling parameters that have little to do with one another. The historical reason for this is that older C compilers use a very simple mechanism for defining parameters, while modern C compilers, including ANSI C compilers, support a parameter passing mechanism that allows the compiler to do some compile-time checking of function calls. These parameter mechanisms will be described separately.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Traditional C Parameters}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Traditional C Parameters\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \fi-360\li720\keepn\widctlpar\adjustright {\i\f6\fs20 parameter-list}{\f6\fs20 : }{\i\f6\fs20 identifier}{\f6\fs20  \{',' }{\i\f6\fs20 identifier}{\f6\fs20 \}*\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The original parameter passing mechanism is very simple. Function declarations do not have parameter lists, even if the function that will be called allows or requires parameters. In a function definition, the names of the parameters are listed between the parentheses that follow the function name, separated by commas. The parameters are then defined before the start of the function body. Each parameter that appears in the parameter list must be defined, and, while types, structures, unions and enumerations may be defined, the only variables that can appear are those listed in the parameter list. As an example, the following function accepts an integer and a pointer to a string as parameters.\par \par }{\f6\fs20 void roman(numeral, digit)\par \par char *numeral;\par int digit;\par \par \{\par /* statements go here */\par \}\par }{\par For each parameter there must be exactly one variable declaration between the function declaration statement and the body of the function. No other variables can be defined in this area, although type declarations are allowed. Parameters may not be initialized, and the only storage class that can be used is register. Parameters, like variables, can be any type except void or a function.\par Because function declarations do not allow parameter declarations, traditional C parameters cannot be checked for correctness by the compiler. For example, if the function shown above is called using a statement like\par \par }{\f6\fs20 roman(4);\par }{\par }\pard \qj\widctlpar\adjustright {there is obviously a problem:  the function definition expects two parameters, while the call is only passing one.\par \par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Function Prototypes}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Function Prototypes\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \fi-540\li900\keepn\widctlpar\adjustright {\i\f6\fs20 parameter-type-list}{\f6\fs20 :  }{\i\f6\fs20 parameter-declaration}{\f6\fs20  \{',' }{\i\f6\fs20 parameter-declaration}{\f6\fs20 \}*\par }{\i\f6\fs20 parameter-declaration}{\f6\fs20 :  }{\i\f6\fs20 declaration-specifiers}{\f6\fs20 \par \tab [}{\i\f6\fs20 declarator}{\f6\fs20  }{\i\f6\fs20 abstract-declarator}{\f6\fs20 ]\par }\pard \qj\fi-540\li900\keepn\widctlpar\adjustright {\i\f6\fs20 abstract-declarator}{\f6\fs20 :  \{}{\i\f6\fs20 non-empty-abstract-declarator}{\f6\fs20 \}\par }{\i\f6\fs20 non-empty-abstract-declarator}{\f6\fs20 :  ['(' }{\i\f6\fs20 non-empty-abstract-declarator}{\f6\fs20  ')'] | [}{\i\f6\fs20 abstract-declarator}{\f6\fs20  '(' ')'] | [}{\i\f6\fs20 abstract-declarator}{\f6\fs20  '[' \{}{\i\f6\fs20 expression}{\f6\fs20 \} ']'] | ['*' }{\i\f6\fs20 abstract-declarator}{\f6\fs20 ]}{\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v parameters\:function prototypes}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v function prototypes}}}{Function prototypes correct the deficiencies in C described in the last section. They give the compiler the ability to check a function call to ensure that the parameters passed by a function call match the parameter list expected by the corresponding function. With a function prototype, each parameter is specified as a variable declaration, rather than simply a name. The function prototype can be used in both the declaration and definition of a function. Once a function has been declared or defined using a function prototype, the compiler checks subsequent calls to the function, flagging any calls that pass a parameter list that the function cannot handle as an error.\par For an example, we will repeat the example from the last section using function prototypes.\par \par }{\f6\fs20 void roman(char *numeral, int digit)\par \par \{\par /* statements go here */\par \}\par }{\par }\pard \qj\widctlpar\adjustright {This simple example shows that the major difference in the way a function is defined using function prototypes is that the variable declarations are moved into the parameter list. Once the function has been declared or defined, however, the call\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 roman(4)\par }{\par }\pard \qj\widctlpar\adjustright {would cause the compiler to flag an error, rather than silently producing a program that might crash.\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v parameters\:checking}}}{In addition to detecting parameter lists that have too few, too many, or incorrect types of parameters, function prototypes allow the compiler to do type conversions. With a traditional parameter list, for example, if you define a function that expects a long integer, and call it with an integer parameter, the result can be as severe as a run-time crash, and will rarely give a correct answer, even if the program does not crash. If the function has been declared using function prototypes, however, the integer parameter is converted to a long integer. All conversions that are performed during assignment using the = operator will also be performed for parameters passed to a function that has been declared using function prototypes.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v parameters\:void prototypes}}}{A special case arises when a function has no parameters. The parameter list should include the single word void, indicating that no parameters are allowed. Any call to the function that tries to pass a parameter will then be flagged as an error.\par }\pard \qj\fi360\sb240\widctlpar\adjustright {\f6\fs20 extern void MakeMyDay(void); /* prototype function with no parameters */\par }\pard \qj\fi360\widctlpar\adjustright {\par It is possible to use an abstract declarator in a function prototype. Basically, an abstract declarator defines a type without giving a variable name. This form of declaration is usually restricted to parameter lists for function declarations, rather than function definitions. An abstract declarator would be of no use in a function definition, since the parameter would have no name, and thus could not be referenced in the function body. In a function declaration, however, it allows you to tell the compiler about the parameter list without specifying the names of the parameters.\par There is an important restriction that applies when using function prototypes. Functions must be declared before they are used. If a function is used before it is defined, the compiler sets up a default declaration. This declaration assumes that the function is not prototyped. Later, when the function is defined with a prototyped parameter list, a conflict arises, and the compiler flags an error.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Variable Length Parameter Lists}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Variable Length Parameter Lists\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v parameters\:variable length lists}}}{Many C functions, most notably those in the standard input and output library, use variable length parameter lists. For example, when you call printf, you always supply a format string, but you can also supply additional parameters. ANSI C introduced a mechanism to handle variable length parameter lists entirely from C, although the method requires you to use a function prototype.\par Basically, the parameter list is split into a fixed part and a variable part. The fixed part is required: at least one fixed variable must be present. The variable part is represented in the function prototype by three periods, and must appear at the end of the parameter list. For example, to declare a function that will add one or more integers, returning the sum as a result, we would use\par \par }{\f6\fs20 int sum(int first,...)\par }{\par }\pard \qj\widctlpar\adjustright {In this case, first is the fixed parameter.\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v va_arg}}}{The functions va_start, va_arg and va_end, from the stdarg.h library, provide a way of using the variable length parameter list from C. For examples of their use, see the description of va_arg in Chapter 13.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v stack repair code}}}{Variable argument lists will not work if stack repair code is enabled; stack repair code is enabled by default. For an explanation of stack repair code, see the next section. To turn off stack repair code, see the optimize pragma.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Common Mistakes With Parameters}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Common Mistakes With Parameters\tcl2}}}{\b\fs36 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v stack repair code}}}{Probably the most pervasive programming error in C programs is misuse of parameter lists. This isn't helped by the fact that many compilers seem to work with some kinds of parameter errors, and as a result, some programmers have written supposedly portable C programs that are incorrect. In all C standards, from the original Kerninghan and Ritchie specification right through to the most recent ANSI C standard, passing the wrong number or wrong type of parameters to a function gives, as the standards put it, undefined results. Basically, that means that a C compiler can support that practice if it chooses, but programs written that way are not portable to other C compilers; it is perfectly legal for a C compiler to simply ignore the possibility that the error can occur, resulting in a program that could actually crash. Passing a different number of parameters than were expected by the function being called was one early way to handle variable argument lists, which helped encourage the practice, but it is not supported by all C compilers.\par To make this work, C compilers that support the practice of allowing you to call a function with the wrong number or type of parameters have the caller remove parameters from the stack after control returns from the function. In effect, this patches the stack, removing parameters whether or not the function that was called knew they were on the stack. On the 65816 CPU used in the Apple\~II}{\fs20 GS}{, it is a little more efficient for the function to remove its own parameters, and that is how ORCA/C works. As a result, if you call a function with the wrong number or type of parameters, you risk crashing the computer.\par On the one hand, ORCA/C is a perfectly correct implementation of C, since passing incorrect parameters is not a feature that C compilers must support, but on the other hand, there are a lot of programs that assume this is legal C, and parameter errors are unfortunately easy to make in C. For that reason, by default, ORCA/C installs stack repair code that makes sure extra parameters are removed from the stack. This stack repair code takes up a lot of room and slows execution speed considerably, though, so ORCA/C also has a way to turn off the stack repair code. For more information on turning off the stack repair code, see the optimize pragma. Finally, to help you track down this sort of error, ORCA/C also has a debug option that will tell you when the parameter list is the wrong size; you can find a description of this feature under the debug pragma.\par {\*\bkmkend bk15}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v parameters}{\rxe bk15}}}{\v \par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 How Parameters are Passed}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 How Parameters are Passed\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v parameters\:passing}}}{Integers, floating-point variables, and pointers are always passed by value. C does not have a mechanism for passing one of these types by reference like Pascal or Ada. This means that a function cannot change to original value of a variable passed as a parameter. For example, the program\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 void change(int i)\par \par \{\par ++i;\par printf("%d\\n", i);\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 int main(void)\par \par \{\par int i;\par \par i = 1;\par printf("%d\\n", i);\par change(i);\par printf("%d\\n", i);\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par }{\par }\pard \qj\widctlpar\adjustright {does not change the value of i in main. The program will print 1, 2 and 1 to the screen, not 1, 2 and 2.\par }\pard \qj\fi360\widctlpar\adjustright {This does not mean that there is no way to create a function that can modify a variable in another function, just that there is no way to do it directly. When a function is supposed to change the original value of a variable, a pointer to the variable is passed, rather than the variable itself. Using this idea in the example just presented, we can create a program that will print 1, 2 and 2:\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 void change(int *i)\par \par \{\par *i += 1;\par printf("%d\\n", *i);\par \}\par \par int main(void)\par \par \{\par int i;\par \par i = 1;\par printf("%d\\n", i);\par change(&i);\par printf("%d\\n", i);\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par }{\par Arrays, structures and unions, on the other hand, are always passed by reference. In all three cases, the address of the first byte of the structure is passed, not the actual bytes that make up the structure. If the function that is called makes any change to the array, structure or union, the change affects the copy passed to the function. The following example illustrates this by using a function to clear an array.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 void clear(float matrix[10][10]);\par \par \{\par int i,j;\par \par for (i = 0; i < 10; ++i)\par    for (j = 0; j < 10; ++j)\par       matrix[i][j] = 0.0;\par \}\par \par int main(void)\par \par \{\par float a[10][10];\par \par clear(a);\par /* a is now all zeros */\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par }{\par ORCA/C passes parameters starting with the rightmost parameter, and working to the left. The expressions are also evaluated in that order. While there is no strict requirement that parameters be processed this way in C, most C compilers follow the same practice. Simple variables of type char, short, int, long, float, double and extended are all passed by value, placing the actual value on the stack. The most significant byte is always placed on the stack first; since the 65816 stack builds from the top of memory towards the bottom, this means that the values appear least significant byte first in memory. Pointers are passed as unsigned long values, and will always have a range of 0 to 0x00FFFFFF. Arrays, structures and unions are passed by placing the address of the first byte of the array, structure or union on the stack. The compiler expects that all parameters are removed from the stack by the function called.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Returning Values from Functions}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Returning Values from Functions\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v functions\:returning a value}}}{Functions can return any type except an array or function, although they can return a pointer to an array of function. The value, if any, is returned as an expression on a return statement. Functions returning void should use the return statement without an expression. If function is declared as returning void, any expression in the return statement will be flagged as an error.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Pascal Functions}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Pascal Functions\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v pascal qualifier\bxe }}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v case sensitivity}}}{C functions have two major differences from functions and procedures in other languages. First, most C compilers push the parameters to a function onto the stack working from right to left. In all other common languages, parameters are generally passed starting with the leftmost parameter and working to the right. Second, C is a case sensitive language, so that the functions foo and Foo are different. All other common languages are case insensitive, and would flag an error if you attempt to create two functions whose names differ only in the case of the letters used. The pascal qualifier allows you to create C functions that can be called from other languages, or to call procedures and functions defined in languages other than C.\par To use the pascal qualifier, place the word pascal immediately after the storage class specifier (if any), and before the function type. For example,\par \par }{\f6\fs20 extern pascal int sum(int a, int b);\par }{\par }\pard \qj\widctlpar\adjustright {could be used to allow C to call a function named sum that requires two integer parameters and returns an integer result. Because the pascal qualifier has been used, the integer a is push on the stack before the integer b, exactly the opposite of the normal order. This function could be written in any language \endash  including C, so long as the function definition also specifies the pascal qualifier.\par }\pard \qj\fi360\widctlpar\adjustright {The C compiler still treats the names of functions using the pascal qualifier as case sensitive, but the names are converted to uppercase characters before passing them on to the linker. This preserves the feel of C, but satisfies the requirements of other languages. It does create one problem, however: it is possible to define two functions in C whose names differ only in the case of the letters used, and end up with a linker error, while the compiler does not see a problem. If this happens, you must choose names that have differences other than the case of the letters.\par }\pard \qc\widctlpar\adjustright {\f12\fs28 \sect }\sectd \sbkodd\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\f5\fs20 Chapter 11:   Expressions\par }}\pard\plain \widctlpar\adjustright \f4\cgrid {\b\fs48 Chapter 11 \endash  Expressions\par }{\pard\plain \widctlpar\adjustright \v\f4\cgrid {\tc {\v }{\v Chapter 11 \endash  Expressions\tcl1}}}{\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Syntax}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Syntax\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v expressions\:syntax}}}{In other chapters about the compiler, the syntax charts for the language is intermixed with the description of the C language. This doesn't work well for expressions, which can be explained more easily in terms of the operators and operands that make up the expression. This section presents the syntax charts for expressions for completeness.\par \par }\pard \fi-540\li900\widctlpar\adjustright {\i\f6\fs20 expression}{\f6\fs20 :  }{\i\f6\fs20 comma-expression}{\f6\fs20 \par }{\i\f6\fs20 comma-expression}{\f6\fs20 :  }{\i\f6\fs20 assignment-expression}{\f6\fs20  \{',' }{\i\f6\fs20 assignment-expression}{\f6\fs20 \}\par }{\i\f6\fs20 assignment-expression}{\f6\fs20 :\par \tab }{\i\f6\fs20 conditional-expression}{\f6\fs20  |\par \tab [}{\i\f6\fs20 unary-expression}{\f6\fs20 \par \tab [\par \tab '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '^=' | '='\par \tab ]\par \tab }{\i\f6\fs20 assignment-expression}{\f6\fs20 ]\par }{\i\f6\fs20 unary-expression}{\f6\fs20 :  }{\i\f6\fs20 postfix-expression}{\f6\fs20 \par \tab | }{\i\f6\fs20 cast-expression}{\f6\fs20 \par \tab | }{\i\f6\fs20 sizeof-expression}{\f6\fs20 \par \tab | ['-' | '+' | '!' | '~' | '&' | '*' | '--' | '++'] }{\i\f6\fs20 unary-expression}{\f6\fs20 \par }{\i\f6\fs20 postfix-expression}{\f6\fs20 :\par \tab }{\i\f6\fs20 identifier}{\f6\fs20  |\par \tab }{\i\f6\fs20 constant}{\f6\fs20  |\par \tab ['(' }{\i\f6\fs20 expression}{\f6\fs20  ')']\par \tab \{['[' }{\i\f6\fs20 expression}{\f6\fs20  ']'] | ['.' }{\i\f6\fs20 identifier}{\f6\fs20 ] | ['->' }{\i\f6\fs20 identifier}{\f6\fs20 ]\par \tab  | ['(' \{}{\i\f6\fs20 comma-expression}{\f6\fs20 \} ')'] | '++' | '--'\}*\par }{\i\f6\fs20 cast-expression}{\f6\fs20 :  '(' }{\i\f6\fs20 type-name}{\f6\fs20  ')' }{\i\f6\fs20 unary-expression}{\f6\fs20 \par }{\i\f6\fs20 type-name}{\f6\fs20 :  }{\i\f6\fs20 type-specifier abstract-declarator}{\f6\fs20 \par }{\i\f6\fs20 sizeof-expression}{\f6\fs20 :  sizeof ['(' }{\i\f6\fs20 type-name}{\f6\fs20  ')'] | }{\i\f6\fs20 unary-expression}{\f6\fs20 \par }{\i\f6\fs20 conditional-expression}{\f6\fs20 :\par \tab }{\i\f6\fs20 logical-or-expression}{\f6\fs20  \{'?' }{\i\f6\fs20 expression}{\f6\fs20  ':' }{\i\f6\fs20 conditional-expression}{\f6\fs20 \}\par }{\i\f6\fs20 logical-or-expression}{\f6\fs20 :\par \tab }{\i\f6\fs20 logical-and-expression}{\f6\fs20  \{'||' }{\i\f6\fs20 logical-and-expression}{\f6\fs20 \}*\par }{\i\f6\fs20 logical-and-expression}{\f6\fs20 :\par \tab }{\i\f6\fs20 bitwise-or-expression}{\f6\fs20  \{'&&' }{\i\f6\fs20 bitwise-or-expression}{\f6\fs20 \}*\par }{\i\f6\fs20 bitwise-or-expression}{\f6\fs20 :\par \tab }{\i\f6\fs20 bitwise-xor-expression}{\f6\fs20  \{'|' }{\i\f6\fs20 bitwise-xor-expression}{\f6\fs20 \}*\par }{\i\f6\fs20 bitwise-xor-expression}{\f6\fs20 :\par \tab }{\i\f6\fs20 bitwise-and-expression}{\f6\fs20  \{'^' }{\i\f6\fs20 bitwise-and-expression}{\f6\fs20 \}*\par }{\i\f6\fs20 bitwise-and-expression}{\f6\fs20 :  }{\i\f6\fs20 equality-expression}{\f6\fs20  \{'&' }{\i\f6\fs20 equality-expression}{\f6\fs20 \}*\par }{\i\f6\fs20 equality-expression}{\f6\fs20 :\par \tab }{\i\f6\fs20 relational-expression}{\f6\fs20  \{['==' | '!='] }{\i\f6\fs20 relational-expression}{\f6\fs20 \}*\par }{\i\f6\fs20 relational-expression}{\f6\fs20 :\par \tab }{\i\f6\fs20 shift-expression}{\f6\fs20  \{['<' | '<=' | '>' | '>='] }{\i\f6\fs20 shift-expression}{\f6\fs20 \}*\par }\pard \fi-540\li900\keepn\widctlpar\adjustright {\i\f6\fs20 shift-expression}{\f6\fs20 :\par }\pard \fi-540\li900\widctlpar\adjustright {\f6\fs20 \tab }{\i\f6\fs20 additive-expression}{\f6\fs20  \{['<<' | '>>'] }{\i\f6\fs20 additive-expression}{\f6\fs20 \}*\par }{\i\f6\fs20 additive-expression}{\f6\fs20 :\par \tab }{\i\f6\fs20 multiplicative-expression}{\f6\fs20  \{['+' | '-'] }{\i\f6\fs20 multiplicative-expression}{\f6\fs20 \}*\par }{\i\f6\fs20 multiplicative-expression}{\f6\fs20 :\par \tab }{\i\f6\fs20 unary-expression}{\f6\fs20  \{['*' | '%' | '/'] }{\i\f6\fs20 unary-expression}{\f6\fs20 \}*\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Operator Precedence}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Operator Precedence\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v operator precedence}}}{C has a rich variety of operators, as well as a complicated set of operator precedences. Operator precedence is what forces the value of the expression 1+2*3 to be 7, rather than 9, which would be the result if the expression where evaluated left to right. The table below shows the precedence of all of the operators. The operators with the highest precedence are shown above the operators with lower precedence.\par \par }\pard \qj\fi360\widctlpar\tx1080\tx1800\tx2520\tx3240\tx3960\tx4680\tx5400\tx6120\tx6840\tx7560\adjustright {\f6\fs20 terms\par ++}{\fs20\up6 1}{\f6\fs20 \tab --}{\fs20\up6 1}{\f6\fs20 \par ++}{\fs20\up6 2}{\f6\fs20 \tab --}{\fs20\up6 2}{\f6\fs20 \tab sizeof\tab (...)}{\fs20\up6 3}{\f6\fs20 \tab ~\tab !\tab -}{\fs20\up6 4}{\f6\fs20 \tab +}{\fs20\up6 4}{\f6\fs20 \tab &}{\fs20\up6 5}{\f6\fs20 \tab *}{\fs20\up6 6}{\f6\fs20 \par *\tab /\tab %\par +\tab -\par <<\tab >>\par <\tab >\tab <=\tab >=\par ==\tab !=\par &}{\fs20\up6 7}{\f6\fs20 \par ^\par |\par &&\par ||\par ? :}{\fs20\up6 8}{\f6\fs20 \par =\tab +=\tab -=\tab *=\tab /=\tab %=\tab <<=\tab >>=\tab &=\tab ^=\tab |=\par ,}{\par }\pard \qj\fi540\widctlpar\adjustright {\par }{\fs20\up6 1}{ postfix operators\par }{\fs20\up6 2}{ prefix operators\par }{\fs20\up6 3}{ type casts\par }{\fs20\up6 4}{ unary addition, subtraction\par }{\fs20\up6 5}{ address operator\par }{\fs20\up6 6}{ indirection operator\par }{\fs20\up6 7}{ bitwise and\par }{\fs20\up6 8}{ conditional evaluation operator (a ternary operator)\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Terms}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Terms\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v terms}}}{Expressions are made up of terms separated by operators. The terms represent the variables and constants to be worked on, or the locations where these variables will be stored. This includes elements of arrays and components of structures and unions. Terms also include values returned by functions.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 L-values}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 L-values\tcl3}}}{\b\fs28 \par }\pard \qj\fi540\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v l-values}}}{In discussing the various forms that a term can take, some will be referred to as l-values. This is an important concept in any language, but is much more important in C, with its multiple assignment operators and operators with side effects. Conceptually, an l-value is any simple value that can be changed. L-values include arithmetic variables, elements of arrays, structures, unions, components of structures and unions, enumeration variables and pointers. L-values do not include entire arrays, functions, or constants.\par }\pard \qj\sb480\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Constants}{\pard\plain \qj\sb480\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Constants\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v constants}}}{The simplest type of term is the constant. Constants can appear in base ten, base eight (octal}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v octal}}}{) or base sixteen (hexadecimal}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v hexadecimal}}}{). Constants can be coded as integers, real numbers, or strings, with a variety of attributes. Constants are not l-values. Constants are covered fully in Chapter 5.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Simple Variables}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Simple Variables\tcl3}}}{\b\fs28 \par }\pard \qj\fi540\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v variables}}}{Another simple type of term is the variable. The simple variable can have a variety of types, but always appears as a name in the expression. The variable must be defined before it is used. Variables come in all of the same types that constants come it, except for strings:  a string variable is actually an array of characters. Variables are l-values. All operators have some restrictions on the type of variables they can be used with.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Arrays}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Arrays\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\*\bkmkstart bk16}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v arrays\:as pointers}}}{Arrays can appear in expressions in one of two ways, with or without a subscript. When an array appears without a subscript, it is not an l-value. It can appear in several places in this form. When an array appears in the operand of the sizeof operator, the size of the entire array is returned. For example,\par \par }{\f6\fs20 int a[10];\par \par ...\par \par i = sizeof(a);\par }{\par }\pard \qj\widctlpar\adjustright {would set i to twenty, since the array a consists of ten integers, each of which is two bytes long. In other situations, the usual unary or binary conversions are performed. (The usual conversions are discussed in the section "Automatic Type Conversions," later in this chapter.)  When the conversions are performed, the array is converted to a pointer to the first element of the array, and the type of the result is a pointer to an element of the array. For example,\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 int a[10], *ip;\par \par ...\par \par ip = a;\par }{\par }\pard \qj\widctlpar\adjustright {sets ip to point to a[0].\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v arrays\:indexing}}}{An array element is accessed by coding the name of the array followed by a left bracket, an expression, and a right bracket. The expression is evaluated. The result type must be integral; it is used to index into the array. The result type of the entire term is the same as the type of one element of the array. The type of the term is an l-value if one term of the array is an l-value, and it is not an l-value if one element of the array is not an l-value. For example, with the definition\par \par }{\f6\fs20 int a[10][10];\par }{\par }\pard \qj\widctlpar\adjustright {a[1] is not an l-value, since it refers to a ten-element array of integers. A[1][3], on the other hand, is an l-value:  the type of the term is int.\par }\pard \qj\fi360\widctlpar\adjustright {The subscript operator can also be applied to a pointer. Just as array names are treated as pointers to the first element of an array, a subscript operator applied to a pointer treats the pointer as the address of the first element of an array whose elements have the same type as the base type of the pointer. For example, the following statements show four ways to fill an array of ten integers with the numbers one through ten. The second method shows indexing of a pointer. Note the variety of other ways made possible by the close relationship between pointers and arrays in C.\par \par }{\f6\fs20 int a[10], i, *ip;\par \par /* method 1: subscripting the array */\par for (i = 0; i < 10; ++i)\par    a[i] = i+1;\par \par /* method 2: subscripting the pointer */\par ip = a;\par for (i = 0; i < 10; ++i)\par    ip[i] = i+1;\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 /* method 3: dereferencing the pointer */\par for (i = 0; i < 10; ++i)\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20    *(ip+i) = i+1;\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 /* method 4: dereferencing the array */\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 for (i = 0; i < 10; ++i)\par    *(a+i) = i+1;\par {\*\bkmkend bk16}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v arrays}{\rxe bk16}}}{\v \par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Function Calls}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Function Calls\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\widctlpar\adjustright {\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v functions}}}{A function call is coded as the name of a function followed by a pair of parentheses. If the function requires (or allows) parameters, the parameters are coded as expressions separated by commas, and appear between the parentheses. The parentheses are required even if the function has no parameters. The result type is the type returned by the function. It is not an l-value. If the function returns void, the result may not be used as an operand for any operator described in this chapter; this is equivalent to the procedure call or subroutine call in other languages.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v functions\:calling through a pointer}}}{If a function appears in an expression without the parentheses that indicate a parameter list, it is treated as a pointer to the function. This property of functions is often used when assigning a value to a pointer to a function, or when passing a function as a parameter. To call a function when a pointer to the function is available, code the pointer as if it were a function call. The following program uses these principles to print both the sine and cosine of \u960\'b9/4.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 #define pi 3.1415926535\par \par void print(float (*f)(), float val)\par \par \{\par printf("%f\\n", f(val));\par \}\par \par int main(void)\par \par \{\par print(sin, pi/4.0);\par print(cos, pi/4);\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par }{\par Actual parameters to functions are evaluated starting with the rightmost parameter and proceeding to the left. The order in which parameters are evaluated varies from compiler to compiler. Since the order of evaluation can be critical to the outcome of functions with side effects, it is best not to use such functions in your programs. The following example illustrates this. It can also be used to test the order of evaluation used by a particular compiler.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 int val;\par \par int change(void)\par \par \{\par return val++;\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 int test(int a, int b)\par \par \{\par return a+b;\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 int main(void)\par \par \{\par val = 1;\par \par if (test(2*change(), change()) == 4)\par    printf("Arguments are evaluated left-to-right.\\n");\par else\par    printf("Arguments are evaluated right-to-left.\\n");\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Component Selection}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Component Selection\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v direct selection}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v structures}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v unions}}}{The direct selection operator allows selection of a field from within a structure or union. It appears as a period separating an expression whose result is a structure or union (on the left) from the name of a component of the structure or union (on the right). The result has the same type as the field of the structure or union. It is an l-value if the expression to the left of the period is an l-value, and the component is not an array. The expression to the left of the period is not an l-value if the structure or union is returned by a function.\par \par }{\f6\fs20 struct point \{float x,y,z;\};\par struct polygon \{point a,b,c,d;\} p;\par \par p.a.x = 1.0;\tab /* set the x-coordinate of point a in polygon p to 1 */\par }{\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v indirect selection}}}{The indirect selection operator, ->, is similar to the direct selection operator in that it is used to access components of structures and unions. The difference is that the left side is a pointer to a structure or union, rather than a structure or union. Once again, the result has the same type as the field of the structure or union. The result is an l-value if the component is not an array.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 struct polygon *pPtr;\par \par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 pPtr->a.x = 1.0;\tab /* set the x-coordinate of point a 1 */\par }{\par The indirect selection operator is completely equivalent to the direct selection operator applied to the pointer after it has been dereferenced. For example, the above example could be restated as\par \par }{\f6\fs20 (*pPtr).a.x = 1.0;\par }{\par }\pard \qj\widctlpar\adjustright {and the result would not change.\par \par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Parenthesized Expressions}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Parenthesized Expressions\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v operator precedence}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v parentheses}}}{A parenthesized expression is an expression enclosed in parentheses. The parentheses do not affect the status of the enclosed expression in any way. In particular, the type of the parenthesized expression is the same as the type of the enclosed expression, and it is an l-value if and only if the enclosed expression is an l-value. The sole effect of the parentheses is to modify the precedence of the operators. The expression within the parentheses is evaluated before the surrounding operators are applied.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Postincrement and Postdecrement}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Postincrement and Postdecrement\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ++ operator}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v -- operator}}}{The postincrement and postdecrement operators are used to increment or decrement scalar values. The operand must be an l-value. The result of the expression is the value before the operator is applied. For example,\par \par }{\f6\fs20 i = 1;\par j = i++;\par printf("%d, %d\\n", j, i);\par }{\par }\pard \qj\widctlpar\adjustright {prints 1, 2 to standard out, not 2, 2.\par }\pard \qj\fi360\widctlpar\adjustright {The result is not an l-value. The result type is the type of the operand.\par If the ++ or -- operator is applied to a pointer, the updated pointer points to one object beyond (++) or before (--) the original value. The example below illustrates this by filling an array, then printing the contents backwards.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 int i, a[10], *ip;\par \par ip = a;\par for (i = 1; i < 11; ++i)\par    ip++ = i;\par \par ip--;\par for (i = 1; i < 11; ++i)\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20    printf("%d\\n", ip--);\par }{\par The result is technically undefined if an overflow or underflow results. In ORCA/C, if unsigned numbers are used, the result wraps around zero. For example, using unsigned integers, incrementing an integer whose value is 65535 would result in zero, and decrementing zero would yield 65535. For the case of signed integers, incrementing 32767 would give -32768, while decrementing -32768 would give 32767.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Math Operators}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Math Operators\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {C supports a total of ten operators for dealing with numeric values. Five of these are binary operators, four are unary operators, and one is a built-in function. The operations, and the symbols used to represent the operations, are shown below.\par \par }\pard \qj\li1080\ri720\widctlpar\brdrt\brdrs\brdrw15 \brdrb\brdrs\brdrw15 \tx2700\tx3600\tx4500\adjustright {operation\tab symbol\tab type\tab operands\par }\pard \qj\li1080\ri720\widctlpar\tx2700\tx3600\tx4500\adjustright {addition\tab }{\f6\fs20 +}{\tab binary\tab any arithmetic type or pointer\par subtraction\tab }{\f6\fs20 -}{\tab binary\tab any arithmetic type or pointer\par multiplication\tab }{\f6\fs20 *}{\tab binary\tab any arithmetic type\par division\tab }{\f6\fs20 /}{\tab binary\tab any arithmetic type\par remainder\tab }{\f6\fs20 %}{\tab binary\tab any integer type\par unary addition\tab }{\f6\fs20 +}{\tab unary\tab any arithmetic type\par unary subtraction\tab }{\f6\fs20 -}{\tab unary\tab any arithmetic type\par increment\tab }{\f6\fs20 ++}{\tab unary\tab any arithmetic type or pointer\par decrement\tab }{\f6\fs20 --}{\tab unary\tab any arithmetic type or pointer\par size\tab }{\f6\fs20 sizeof()}{\tab function\tab any type or unary expression\par }\pard \qj\fi360\widctlpar\adjustright {\par Integer types include char, short, int, long, and the unsigned forms of all of these. Arithmetic types include the integer types plus float, double, comp and extended.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Addition}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Addition\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v + operator}}}{The operands are converted to the same type using the usual binary conversion rules. The two operands are then added. The result is the same type as the converted operands, and is not an l-value.\par Integer overflow is not detected. If two integers exceed the range of the type of the operands, the extra most-significant bits are lost.\par Floating-point errors are not detected automatically. Errors can be detected by direct calls to SANE. If a floating-point underflow occurs, the result is zero. Floating-point overflow gives a result of infinity, which can lead to correct, non-infinite answers in some forms of equations.\par The addition operator can also be used to add an integer to a pointer. The result is a pointer of the same type as the input pointer. If, for example, n is added to a pointer, the new pointer points n elements past the original pointer. If ip is a pointer to an integer, then, *(ip+2) load the integer that is two integers past the integer pointed to by ip.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Subtraction}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Subtraction\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v - operator}}}{The operands are converted to the same type using the usual binary conversion rules. The second operand is then subtracted from the first. The result is the same type as the converted operands, and is not an l-value.\par Integer overflow is not detected. If two integers exceed the range of the type of the operands, the extra most-significant bits are lost.\par If the operands are one of the unsigned integer types, and the left operand is smaller than the right operand, the result is a positive unsigned number wrapped through the given base. For example, if the operands are unsigned int, and the left operand has a value of 1, while the right has a value of 2, then the result is 65536-1, or 65535. Another way of thinking about this is to recognize that this result has the bit pattern of the signed result of the operation, but that it is represented as an unsigned number. \par Floating-point errors are not detected automatically. Errors can be detected by direct calls to SANE. If a floating-point underflow occurs, the result is zero. Floating-point overflow gives a result of infinity, which can lead to correct, non-infinite answers in some forms of equations.\par The subtraction operator can also be used with two pointer operators if the pointers are of the same type. The result is an integer; it is the number of elements between the two pointers. For example, (&a[4])-(&a[1]) would be 3, regardless of the type of the array.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Multiplication}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Multiplication\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v * operator}}}{The operands are converted to the same type using the usual binary conversion rules. The two operands are then multiplied. The result is the same type as the converted operands, and is not an l-value.\par Integer overflow is not detected. If two integers exceed the range of the type of the operands, the extra most-significant bits are lost.\par Floating-point errors are not detected automatically. Errors can be detected by direct calls to SANE. If a floating-point underflow occurs, the result is zero. Floating-point overflow gives a result of infinity, which can lead to correct, non-infinite answers in some forms of equations.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Division}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Division\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v / operator}}}{The operands are converted to the same type using the usual binary conversion rules. The first operand (the numerator) is then divided by the second operand (the denominator). The result is the same type as the converted operands, and is not an l-value.\par For integer division, any fractional part of the result is discarded; i.e., 4/3 gives a result of 1, not 1.333. For positive results, all C compilers return the truncated number; i.e., the largest integer that is less than or equal to the floating-point result. Various compilers truncate negative numbers in different ways, so it is not a good idea to depend on the results of integer division when the results are negative. In ORCA/C, as in most implementations of C, truncation of a negative result returns the integer closest to zero. For example, (-4)/3 gives a result of -1, not -2.\par Integer division by zero is not detected. The results of dividing by zero are not predictable.\par For floating-point division, the result is the floating-point number that is the best representation of the correct answer; here, some differences between the actual result and the correct mathematical result may occur due to round-off error.\par Floating-point errors are not detected automatically. Errors can be detected by direct calls to SANE. If a floating-point underflow occurs, the result is zero. Floating-point overflow gives a result of infinity, which can lead to correct, non-infinite answers in some forms of equations.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Remainder}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Remainder\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v % operator}}}{The operands are converted to the same type using the usual binary conversion rules. The first operand is then divided by the second. The result is the remainder from the division. The result is the same type as the converted operands, and is not an l-value.\par For non-zero b, the following relation always holds. It defines the action of this operation in a mathematical sense, including the results when one argument is negative and the other is positive.\par \par }{\f6\fs20 ((a/b)*b + a%b) == a\par }{\par Integer division by zero is not detected. The results of dividing by zero are not predictable.\par The remainder function requires integer operands; it is an error to supply a floating-point value as one or both of the operands.\par }\pard \qj\sb480\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Unary Subtraction}{\pard\plain \qj\sb480\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Unary Subtraction\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v - operator}}}{The operand, which can be of any arithmetic type, is converted using the usual unary conversion rules. The result is not an l-value. The operation is completely equivalent to subtracting the value from zero. The same rules that would apply to subtracting the number from zero also apply to unary subtraction when handling overflows, underflows, and dealing with unsigned operands.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Unary Addition}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Unary Addition\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v + operator}}}{The operand, which can be of any arithmetic type, is converted using the usual unary conversion rules. The result is not an l-value. The operation is completely equivalent to adding the value to zero. The same rules apply for handling overflows, underflows, and dealing with unsigned operands. Other than any type conversions performed, this operation does not actually generate any code, since adding a number to zero does not change the number.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Prefix Increment}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Prefix Increment\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ++ operator}}}{The operand, which can be and scalar l-value, is incremented by one. The usual binary conversions are applied to the operand and to the constant one. The result is stored back in the operand after the usual assignment conversions are applied. The result is the new operand, and is not an l-value. The type of the result is the same as the type of the operand.\par If the operand is a pointer, the pointer is moves so that it points to the next item of the type pointed to by the pointer. For example, if the pointer is a pointer to an integer, a value of two is added to the ordinal value of the pointer, since integers are two bytes long.\par If the argument is an unsigned value, and the value of the argument is the largest unsigned number that can be represented with the given integer size, the result is zero. If the argument is a signed integer and the value is the largest signed integer, the result is technically undefined, but is actually one less than the value of the argument subtracted from zero in ORCA/C. For example, if the value if the signed integer i is 32767 (the largest signed integer), and the ++ operator is applied to the integer, the result is -32768.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Prefix Decrement}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Prefix Decrement\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v -- operator}}}{The operand, which can be and scalar l-value, is decremented by one. The usual binary conversions are applied to the operand and to the constant one. The result is stored back in the operand after the usual assignment conversions are applied. The result is the new operand, and is not an l-value. The type of the result is the same as the type of the operand.\par If the operand is a pointer, the pointer is moves so that it points to the previous item of the type pointed to by the pointer. For example, if the pointer is a pointer to an integer, a value of two is subtracted from the ordinal value of the pointer, since integers are two bytes long.\par If the argument is an unsigned value, and the value of the argument is zero, the result is the largest unsigned number that can be represented with the given integer size. If the argument is a signed integer and the value is the smallest signed integer, the result is technically undefined, but is actually one less than the value of the argument subtracted from zero in ORCA/C. For example, if the value if the signed integer i is -32768 (the smallest signed integer that can be represented in two bytes using two's complement notation), and the }{\f6\fs20 -- }{operator is applied to the integer, the result is 32767.\par }\pard \qj\sb480\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Sizeof Operator}{\pard\plain \qj\sb480\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Sizeof Operator\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v sizeof operator}}}{The sizeof operator returns the size of the operand, in bytes. The result is not an l-value. The operand can be a type name or any unary expression. The operand cannot be a function, void, or an array declared without giving explicit values for all dimensions. If the operand is an array, the result is the complete size of the array. For any other unary operand, the result is the size of the result type.\par There are two forms of the sizeof operator. When the operand is a type name, it must be enclosed in parentheses. When the operand is a unary expression, it does not have to be enclosed in parentheses, although it does no harm to use the parentheses.\par When the operand is a unary expression, the expression is not evaluated at run-time. In other words, ++ and -- operators do not change the value of the variables, function calls are not made, and assignments are not performed. The expression is examined at compile time to determine the result type, but no code is generated.\par Taking the size of a bit field returns the size of the underlying type.\par While the sizeof operator does not perform any type conversions, the expression appearing in the operand can perform type conversions.\par In ORCA/C, the result of the sizeof operator is of type unsigned long.\par The examples below illustrate some of these principles. The declarations which precede the tables are used to compute the sizes of the terms.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 int *ip, i, a[10];\par float f, fa[5][5];\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 struct point (float x,y,z;\} p;\par \par }\pard \qj\fi360\widctlpar\tx2880\adjustright {\f6\fs20 sizeof (int)\tab 2\par sizeof (char)\tab 1\par sizeof (unsigned)\tab 2\par sizeof (long)\tab 4\par sizeof (float)\tab 4\par sizeof (double)\tab 8\par sizeof (extended)\tab 10\par sizeof (comp)\tab 8\par sizeof (void *)\tab 4\par sizeof (i)\tab 2\par sizeof ip\tab 4\par sizeof (*ip)\tab 2\par sizeof a\tab 20\par sizeof a[1]\tab 2\par sizeof f\tab 4\par sizeof fa\tab 100\par sizeof (point)\tab 12\par sizeof p\tab 12\par sizeof (0L)\tab 4\par sizeof (1+7)\tab 2\par sizeof (sizeof(0))\tab 4\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Comparison Operations}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Comparison Operations\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {There are six comparison operators in C. The operands of any of these operators can work on any arithmetic type, or on two pointers if both pointers are of the same type. The equality operators can also be used on a pointer and the integer constant zero. Two pointers are considered to be equal if they point to the same byte of memory, or if both pointers are NULL. A pointer is equal to the integer constant zero if the value of the pointer is NULL. Pointer a is less than pointer b if a points to an object stored at a smaller address than the object b points to. The only time this is generally of concern in a C program is when the pointers point to elements of the same array. In that case, pointer a is less than pointer b if pointer a points to an element with a smaller subscript than the element pointed to by b.\par The six comparison operators are shown in the table below.\par \par }\pard \qj\li2160\ri2520\widctlpar\brdrt\brdrs\brdrw15 \brdrb\brdrs\brdrw15 \tx3600\adjustright {operator\tab condition\par }\pard \qj\li2160\ri2520\widctlpar\tx3600\adjustright {<\tab less than}{\pard\plain \qj\li2160\ri2520\widctlpar\tx3600\adjustright \v\f4\cgrid {\xe {\v }{\v < operator}}}{\par <=\tab less than or equal}{\pard\plain \qj\li2160\ri2520\widctlpar\tx3600\adjustright \v\f4\cgrid {\xe {\v }{\v <= operator}}}{\par >\tab greater than}{\pard\plain \qj\li2160\ri2520\widctlpar\tx3600\adjustright \v\f4\cgrid {\xe {\v }{\v > operator}}}{\par >=\tab greater than or equal}{\pard\plain \qj\li2160\ri2520\widctlpar\tx3600\adjustright \v\f4\cgrid {\xe {\v }{\v >= operator}}}{\par ==\tab equal}{\pard\plain \qj\li2160\ri2520\widctlpar\tx3600\adjustright \v\f4\cgrid {\xe {\v }{\v == operator}}}{\par !=\tab not equal}{\pard\plain \qj\li2160\ri2520\widctlpar\tx3600\adjustright \v\f4\cgrid {\xe {\v }{\v != operator}}}{\par }\pard \qj\fi540\widctlpar\adjustright {\par }\pard \qj\widctlpar\adjustright {For example, a < b is true if a is less than b, and false if it is not.\par }\pard \qj\fi360\widctlpar\adjustright {If the condition tested by the operator is true, the result is a signed integer value of one. If the condition is false, the result is zero. The result is not an l-value.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Logical Operations}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Logical Operations\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {There are two binary logical operators, and one unary logical operator. All of the operations accept any scalar type as an operand. The result is of type integer, and is one for a true result, and zero for false. The result is not an l-value.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v && operator}}}{The logical and operator is &&. The first operand is evaluated. If it is non-zero, it is treated as true, while a zero result is treated as false. If the result is false, the right operand is not evaluated at all, since the result has already been determined, and the result of the && operation is zero. If the left operand is non-zero, the second operand is evaluated. If it is zero, the result is zero (false); if the second operand results in a non-zero value, the result is one (true).\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v || operator}}}{The logical or operator is ||. The first operand is evaluated. If it is non-zero, it is treated as true, while a zero result is treated as false. If the result is true, the right operand is not evaluated at all, since the result has already been determined, and the result of the || operation is one. If the left operand is zero, the second operand is evaluated. If it is zero, the result is zero (false); if the second operand results in a non-zero value, the result is one (true).\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ! operator}}}{The logical negation operator is !. The single operand, which can be of any scalar type, is converted using the standard unary conversion rules. If the operand is zero, the result is one; if the operand is non-zero, the result is zero.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Bit Manipulation}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Bit Manipulation\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {C has six powerful bit manipulation operators. The operands for all of the operators can be of any integer type. The result is not an l-value.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v & operator}}}{The bitwise and operator is &. It is a binary operator. The two operands are converted using the standard binary conversion rules. The type of the result matches the type of the converted operands. The result is formed by performing an and of the individual bits in the two operands. For example, 0x1248 & 0x1441 == 0x1040.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v | operator}}}{The bitwise or operator is |. It is a binary operator. The two operands are converted using the standard binary conversion rules. The type of the result matches the type of the converted operands. The result is formed by performing an or of the individual bits in the two operands. For example, 0x1040 | 0x0208 == 0x1248.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ^ operator}}}{The bitwise exclusive or operator is ^. It is a binary operator. The two operands are converted using the standard binary conversion rules. The type of the result matches the type of the converted operands. The result is formed by performing an exclusive or of the individual bits in the two operands. The result of an exclusive or is 1 if one of the bits, but not both, is 1, and 0 of both bits are 0 or both bits are 1. For example, 0x1248 ^ 0x1040 == 0x0208.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ~ operator}}}{The bitwise negation operator is ~. It is a unary operator. The single operand, which appears to the right of the operator, is converted using the standard unary conversion rules. The type of the result matches the type of the converted operand. The result is formed by performing an exclusive or of the individual bits in the operand with a second operand composed entirely of ones. The effect is to reverse each bit in the operand. For example, ~0x1248 == 0xEDB7.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v << operator}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v >> operator}}}{C supports two binary shift operators, << and >>. In each case, the operands are converted separately using the standard unary conversion rules, not the binary conversion rules. The result type is the type of the converted left operand. It is formed by shifting the operand a certain number of bits to the left (for the << operator) or right (the >> operator).\par For unsigned operands, zeros are shifted in from both the left and right to fill the new bit positions. Zeros are also used to fill the bit positions created by the shift left operator (<<) if the left operand is signed. If the shift right operator (>>) is used with a signed left operand, the sign bit is replicated to fill the unused bit position. The result of these rules is that shifting a number left is mathematically equivalent to multiplying the number by two raised to the power of the second operand, providing that no overflows occur. Shifting an unsigned number to the right is equivalent to dividing the number by two raised to the power of the second operand. The same is true for signed operands unless the result would be zero; in that one case, the result of shifting is always -1.\par If the right operand is zero, the result is the value of the left operand. The results are not predictable if the right operand is less than zero. Even if you determine the results by experimentation, we reserve the right to change the compiler in the future in ways that could affect such results.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Assignment Operators}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Assignment Operators\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Simple Assignment}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Simple Assignment\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v = operator}}}{C has a variety of assignment operators. The simplest is the assignment operator, =. The simple assignment operator evaluates the expression to the right of the operator, then assigns the result to the l-value that appears to the left of the operator. The result of the expression is the value assigned to the l-value, and has the same type as the unconverted l-value.\par The simple assignment operator can be used with any arithmetic types. If the type of the expression does not match the type of the l-value, the expression is converted to the l-value's type using the same rules that would apply if the expression were to be cast to the correct type explicitly. See the discussion of type casing for details.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v structures}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v unions}}}{Structures and unions can be assigned so long as the type of the expression matches the type of the l-value exactly. The contents of the structure or union are copied to the destination structure or union. All bytes are copied, even if some involve unused bit fields, bits used to align other fields to a byte boundary, or unused bytes in a union. The number of bytes copied is equal to the number of bytes reported by the sizeof operator for the size of the structure or union.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v pointers}}}{Pointers can be assigned so long as the type of the expression matches the type of the l-value exactly. Some C compilers automatically cast pointer types during assignment; ANSI C does not permit automatic casting of pointer types. It is also legal to assign an integer to a pointer so long as the integer is a constant with a value of zero.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v arrays}}}{Finally, an array can be assigned to a pointer if the elements of the array are of the same type as the values pointed to by the pointer. The resulting pointer points to the first element of the array.\par The assignment operator cannot be used to copy one array into another.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Compound Assignment}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Compound Assignment\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v assignments\:compound}}}{The compound assignment operators are a combination of simple assignment and one of the arithmetic or bitwise binary operators. The effect is to perform the operation on the l-value and the expression, assigning the result to the l-value. The result is not an l-value. It has the same type as the l-value that appears to the left of the operation.\par The one difference between a compound assignment operator and an equivalent expression formed using the simple assignment operator and the binary operation is that the l-value is only evaluated one time. For example, if a function is used to compute the subscript of an array, as in\par \par }{\f6\fs20 a[f(x)] += 3;\par }{\par }\pard \qj\widctlpar\adjustright {the function f is only called one time. The equivalent expression using the simple assignment operator is\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 a[f(x)] = a[f(x)] + 3;\par }{\par }\pard \qj\widctlpar\adjustright {In this case, the function f is called two times. While it is rare in well-written programs, there are cases where the two expressions would yield different results.\par }\pard \qj\fi360\widctlpar\adjustright {The same restrictions that apply to the operator associated with the compound assignment also apply to the compound assignment operator. Errors are handled the same way, and the same types of operands are allowed. The table below shows the compound assignment operators with the associated binary operator and the types of operands that are allowed.\par \par }\pard \qj\li1440\ri2160\keepn\widctlpar\brdrt\brdrs\brdrw15 \brdrb\brdrs\brdrw15 \tx3060\tx3960\tx4860\adjustright {assignment\tab binary}{\ul \par }{operator\tab operator\tab operands\par }\pard \qj\li1440\ri2160\keepn\widctlpar\tx3060\tx3960\tx4860\adjustright {\f6\fs20 +=\tab +\tab }{any arithmetic type or \par \tab \tab pointer += integer}{\pard\plain \qj\li1440\ri2160\keepn\widctlpar\tx3060\tx3960\tx4860\adjustright \v\f4\cgrid {\xe {\v }{\v += operator}}}{\par }{\f6\fs20 -=\tab -\tab }{any arithmetic type or\par \tab \tab pointer -= integer}{\pard\plain \qj\li1440\ri2160\keepn\widctlpar\tx3060\tx3960\tx4860\adjustright \v\f4\cgrid {\xe {\v }{\v -= operator}}}{\par }{\f6\fs20 *=\tab *\tab }{any arithmetic type}{\pard\plain \qj\li1440\ri2160\keepn\widctlpar\tx3060\tx3960\tx4860\adjustright \v\f4\cgrid {\xe {\v }{\v *= operator}}}{\par }{\f6\fs20 /=\tab /\tab }{any arithmetic type}{\pard\plain \qj\li1440\ri2160\keepn\widctlpar\tx3060\tx3960\tx4860\adjustright \v\f4\cgrid {\xe {\v }{\v /= operator}}}{\par }{\f6\fs20 %=\tab %\tab }{any integer type}{\pard\plain \qj\li1440\ri2160\keepn\widctlpar\tx3060\tx3960\tx4860\adjustright \v\f4\cgrid {\xe {\v }{\v %= operator}}}{\par }{\f6\fs20 <<=\tab <<\tab }{any integer type}{\pard\plain \qj\li1440\ri2160\keepn\widctlpar\tx3060\tx3960\tx4860\adjustright \v\f4\cgrid {\xe {\v }{\v <<= operator}}}{\par }{\f6\fs20 >>=\tab >>\tab }{any integer type}{\pard\plain \qj\li1440\ri2160\keepn\widctlpar\tx3060\tx3960\tx4860\adjustright \v\f4\cgrid {\xe {\v }{\v >>= operator}}}{\par }{\f6\fs20 &=\tab &\tab }{any integer type}{\pard\plain \qj\li1440\ri2160\keepn\widctlpar\tx3060\tx3960\tx4860\adjustright \v\f4\cgrid {\xe {\v }{\v &= operator}}}{\par }{\f6\fs20 ^=\tab ^\tab }{any integer type}{\pard\plain \qj\li1440\ri2160\keepn\widctlpar\tx3060\tx3960\tx4860\adjustright \v\f4\cgrid {\xe {\v }{\v ^= operator}}}{\par }\pard \qj\li1440\ri2160\widctlpar\tx3060\tx3960\tx4860\adjustright {\f6\fs20 |=\tab |\tab }{any integer type}{\pard\plain \qj\li1440\ri2160\widctlpar\tx3060\tx3960\tx4860\adjustright \v\f4\cgrid {\xe {\v }{\v |= operator}}}{\par }\pard \qj\fi360\widctlpar\adjustright {\par The original C language allowed the operator to appear after the = character. This is no longer allowed in C, and most programs have been converted to avoid this form of the compound assignment operator. A more recent change is to require the compound assignment operators to be treated as single tokens. The effect of this change is that white space may not appear between the operator and the = character. This is a more recent change to the language, and some programs ported form other compilers may still have white space after the operator. The compiler will identify this error when it occurs, and the program can be easily corrected.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Multiple Assignments}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Multiple Assignments\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v multiple assignments}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v assignments\:multiple}}}{Unlike the other binary operators in C, all of the assignment operators are right-associative. This means that if more than one assignment operator appears in a single expression, the rightmost operation is performed first. This allows for multiple assignments in one expression. For example, x, y and z can all be initialized to zero at one time, as shown below.\par \par x = y = z = 0.0;\par \par }\pard \qj\widctlpar\adjustright {In most other high-level languages, this same operation would require three assignment statements.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Pointers and Addresses}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Pointers and Addresses\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v & operator}}}{The address operator & is used to obtain a pointer to an l-value. The result is a pointer of type "pointer to value," where value is the type of the l-value. For example, the following code uses the address operator to initialize a pointer to point to an integer.\par \par }{\f6\fs20 int i, *ip;\par \par ip = &i;\par }{\par The address operator can be used with register variables in ORCA/C. Some C compilers do not permit the address operator to be used with register variables, and others may generate less efficient code if the address operator is used with a register variable.\par When the address operator is applied to a function, the result is of type pointer to function. When the address operator is used on an array whose elements are of type T, the result is of type pointer to array of T, or simply pointer to T.\par The address operator cannot be used on a bit field. For example, the following use of the address operator is illegal.\par \par }\pard \qj\fi360\widctlpar\tx3600\adjustright {\f6\fs20 struct \{unsigned i: 8; unsigned j: 8;\} bar;\par char *cp;\par \par cp = &bar.i;\tab /* illegal */\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v * operator}}}{The indirection operator is used to dereference pointers. It appears as an asterisk to the left of an l-value of type pointer. If the pointer is of type "pointer to T," the result is an l-value of type T.\par The pointer must point to a valid variable when it is dereferenced. If it does not, the results are unpredictable. In most cases, a random value will be loaded, but if the pointer is pointing into one of the memory mapped I/O areas, almost anything can happen,  including turning disk drive motors on or off, switching displays, and so forth.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Sequential Evaluation}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Sequential Evaluation\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v , operator}}}{The sequential evaluation operator is a comma. It can be used between two expressions in many places where an expression can be used. The left expression is evaluated first. The result is discarded, and the right expression is evaluated. The result and result type are the same as the result and result type of the right expression. The result is not an l-value.\par More than one comma operator can be used in a single expression, in which case the expressions are evaluated left to right, and the result and result type are determined by the last expression.\par The comma operator cannot be used in parameter lists to function calls, field length expressions in structure and union delcarator lists, enumeration value expressions in enumeration lists, or initializer expressions in declarations and initializers. Parentheses can be used to allow the use of the comma operator in these situations.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Conditional Expressions}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Conditional Expressions\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ? operator}}}{C has one ternary operator which can be used to conditionally execute a statement.\par \par }{\f6\fs20 test() ? doTrue() : doFalse();\par }{\par The first operand can be any scalar type. It is evaluated. If the first operand is non-zero, the second expression is evaluated. If the first operand is zero, the last expression is evaluated. The result is the evaluated second or third operand, and is not an l-value.\par The last two expressions can take on several forms. If they are both arithmetic expressions, the usual binary conversion rules are applied, and the result is the common type, regardless of which expression is actually evaluated. They can also be pointers to the same type, in which case the result is a pointer to the same type. They can be structures or unions if the types are the same, in which case the result is the same type as the operand. Both expressions can be of type void, in which case the result is of type void. Finally, one can be the integer constant zero, and the other can be a pointer type. In that case, the result type matches the pointer.\par The conditional operator is right-associative, so the expression\par \par }{\f6\fs20 a ? b : c ? d : e\par }{\par }\pard \qj\widctlpar\adjustright {is interpreted as\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 a ? b : (c ? d : e)\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Automatic Type Conversions}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Automatic Type Conversions\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Assignment Conversions}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Assignment Conversions\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v assignment conversions}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v = operator}}}{When one value is assigned to another, the expression that appears to the right of the assignment operator must be of the same type as the l-value that appears to the left of the operator.\par There are several cases when the compiler can automatically perform type conversions on the right hand side to force the type to match the type of the l-value. These are:\par \par }\pard \qj\fi-360\li720\widctlpar\adjustright {1.\tab The integer 0 is assigned to a pointer. In that case, the integer is converted to a long, unsigned value and cast to the appropriate pointer type before storage.\par \par 2.\tab The l-value and expression are of different arithmetic types. (The arithmetic types include all integer and floating-point types, as well as enumerations.)  In that case, the expression is converted to the type of the l-value as if the expression were explicitly cast to the correct type. See the section on type casing for details.\par }\pard \qj\fi360\widctlpar\adjustright {\par There are many other conversions that are performed as a normal part of evaluating an expression. These conversions are discussed in the sections that follow.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Function Argument Conversions}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Function Argument Conversions\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v functions}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v parameters}}}{When parameters are passed to a function for which a prototype exists, the expressions are converted using the same rules that would apply if the expression were being assigned to a variable of the type of the parameter. If no prototype exists, or if the parameter appears as an optional parameter in a variable length parameter list, the unary conversion rules are applied to the expression.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Unary Conversion Rules}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Unary Conversion Rules\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ! operator}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v - operator}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v + operator}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ~ operator}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v * operator}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ? operator}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v << operator}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v >> operator}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v unary conversion rules}}}{The unary conversion rules are applied to the operands of the unary operators !, -, +, ~ and *. They are also applied to the leftmost operand of the ternary ? : operator, the operands of the bit shift operations << and >>, and to parameters to functions when function prototypes are not used.\par Unary conversions are used primarily to reduce the number of forms an operator must handle. Short integers and char variables are converted to type int; unsigned short and unsigned char are converted to type unsigned. Float and double values are converted to type extended. Finally, arrays and functions are converted to pointers of the appropriate type.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Binary Conversion Rules}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Binary Conversion Rules\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v binary conversion rules}}}{The binary conversion rules are used to ensure that both operands of a binary operator are of the same type before the operation is performed. The binary conversion rules are best expressed as a series of rules which are applied in turn until one of the conditions specified by a rule is matched. Before these rules are applied, the unary conversion rules are applied to each operand. The binary conversion rules, in the order in which they are applied, are:\par \par }\pard \qj\fi-360\li720\widctlpar\adjustright {1.\tab If either operand is not an arithmetic type, or if the operands are of the same type, no conversion is performed.\par 2.\tab If one operand is of type extended, then the other operand is converted to extended.\par 3.\tab If one operand is of type double, then both operands are converted to extended.\par 4.\tab If one operand is of type float, then both operands are converted to extended.\par 5.\tab If one operand is of type unsigned long, the other operand is converted to unsigned long.\par 6.\tab If one operand is of type long, the other operand is converted to long.\par 7.\tab If one operand is of type unsigned int, the other operand is converted to unsigned int.\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v floating-point}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v SANE}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v 68881}}}{ORCA/C will convert all expressions involving a floating-point operand to type extended. While C traditionally requires this type of conversion, and SANE and the 68881 floating-point processor both make it economical, ANSI C does not require all floating-point calculations to be performed in the longest format available.\par In the cases where the internal representation of the number remains the same, no actual code is generated by the compiler. In cases where the internal representation does change, the conversions are discussed in detail in the next section, type casting.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Type Casting}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Type Casting\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v type casting}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v cast}}}{A type cast takes the form of a type name in parentheses immediately before an expression. The expression is evaluated, and then the value of the expression is changed to match the type specified.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Converting Integers to Integers}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Converting Integers to Integers\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v integers}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v int}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v unsigned}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v short}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v char}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v long}}}{When one integer is converted to another, the new value is the same as the old if it can be represented in the new type.\par There are several cases where the value of the original integer cannot be represented in the new type. The first occurs when a signed integer is converted to an unsigned integer of the same size, and the original value is less than zero. In that case, the new value is 2}{\fs20\up6 n}{+val, where n is 8 for unsigned char; 16 for unsigned short and unsigned int; and 32 for unsigned long; and val is the original value. Another way of looking at the conversion is that the bit pattern does not change, and the signed value becomes the unsigned equivalent of the two's complement bit pattern used to represent the number.\par When an unsigned integer is converted to a signed integer of the same size, no conversion is performed. If the unsigned value is too large to represent in the signed form, the result is undefined. In fact, the result becomes the negative number whose bit pattern is the same as the original unsigned number.\par If a shorter value is converted to a longer one, the only case where the arithmetic value cannot be represented is if the shorter value is a signed number, and the value is less than zero, and the longer number is an unsigned number. In this case, the number is first converted to a signed value of the same size as the unsigned type, and then the above rules apply.\par If a long value is converted to a shorter one, and the final value cannot be represented exactly, the extra bits are discarded.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Converting Floating-Point Values to Integers}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Converting Floating-Point Values to Integers\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v floating-point}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v float}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v double}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v extended}}}{Floating-point values are converted to integers by discarding any fraction part, then converting the resulting number to an integer. If the number is too large or too small to represent as an integer, the results are unpredictable. Any of the floating-point formats can be converted to any integer format.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Converting Pointers to Integers}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Converting Pointers to Integers\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v pointers}}}{In ORCA/C (but not in all implementations of C), pointers are the same size as unsigned long integers. When converting a pointer to an integer, the compiler treats the pointer as if it were an unsigned long integer. If the pointer is converted to a format other than unsigned long integer, the rules for converting an unsigned long integer to the specified format apply.\par Pointers can be converted to long and unsigned long with no loss of information. In general, converting a pointer to char, int or short and then converting the result back to a pointer will result in a different, probably incorrect, pointer value.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Converting Floating-Point Values to Other Floating-Point Formats}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Converting Floating-Point Values to Other Floating-Point Formats\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v float}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v double}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v extended}}}{When converting from float to double or extended, or when converting from double to extended, there is no loss of precision, regardless of the input value.\par When converting from extended to double or float, or when converting from double to float, several things can happen. It is possible that the value being converted cannot be represented accurately. For example, 1.00000000001 can be represented reasonably well using double or extended, but if the double or extended number is converted to float, loss of precision will result in a float value of 1.0. It is also possible that the exponent will be too large or too small for the smaller format. If the exponent is too small, underflow results, and the new number is set to zero. For example, converting the double number 1e-300 to a float number would result in zero. If the exponent is too large, overflow occurs, and the result is infinity. For example, converting 1e300 from double to float would cause an overflow.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Converting Integers to Floating-Point Values}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Converting Integers to Floating-Point Values\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v integers}}}{All of the integer formats can be converted to any of the floating-point formats. In some cases, there may be a loss of precision. For example, float variables are accurate to about seven decimal digits, so converting the long integer 1000000001 to a float value would result in 1.0e9, not 1.000000001e9.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Converting to and from Enumerations}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Converting to and from Enumerations\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {For the purpose of conversions, enumeration constants are treated as signed decimal integer constants, and enumeration variables are treated as type int.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Converting Pointers to Pointers}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Converting Pointers to Pointers\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v pointers}}}{Any pointer type can be converted to any other pointer type. There is no loss of precision or change in representation, so converting the pointer back to its original type will always result in the original value. This is not true in all C compilers, so avoid making use of this principle in programs that will be ported to other machines.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Converting Integers to Pointers}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Converting Integers to Pointers\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v integers}}}{The integer 0 is used to represent the null pointer. It can be converted to a pointer in all implementations of C.\par ORCA/C also allows conversion of any other integer value to a pointer. To make sense on the 65816 CPU, the apparent range of the integer should be in the range 0x00000000 to 0x00FFFFFF. If it is not, using the pointer will generally result in the most significant byte being ignored. Some tools, however, may crash or access other areas of memory.\par No Apple\~II}{\fs20 GS}{ actually has all of the memory represented by these values installed. It is up to you to ensure that the integer value represents an area of memory that is safe to access. If the memory does not belong to your program, changing it will cause unpredictable results. These results could include damaging disk files or crashing the computer.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Converting Arrays to Pointers}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Converting Arrays to Pointers\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v pointers}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v arrays}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v sizeof operator}}}{An array name is automatically converted to a pointer to the first element of the array in all cases except when the array appears as the operand for the sizeof operator.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Converting Functions to Pointers}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Converting Functions to Pointers\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v pointers}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v functions}}}{Except in cases where a function name is used to call a function, the function name is automatically converted to a pointer to the function.\par }\pard \qj\widctlpar\adjustright {\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b\fs28 Converting to Void}{\pard\plain \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright \b\v\f4\fs28\cgrid {\tc {\b\v\fs28 }{\b\v\fs28 Converting to Void\tcl3}}}{\b\fs28 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v void}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v functions}}}{Any type can be converted to void, although the result cannot be used. The only place where this conversion is generally used is when a function that normally returns a value is called in a context where the return value is not needed. In that case, the conversion serves as a clue to the compiler that the result will not be used. This has no effect in ORCA/C programs, since the code to use a value returned by a function is not generated unless the value is actually used.\par }\pard \qc\widctlpar\adjustright {\f12\fs28 \sect }\sectd \sbkodd\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\f5\fs20 Chapter 12:   Statements\par }}\pard\plain \widctlpar\adjustright \f4\cgrid {\b\fs48 Chapter 12 \endash  Statements\par }\pard \qj\widctlpar\adjustright {\pard\plain \qj\widctlpar\adjustright \v\f4\cgrid {\tc {\v }{\v Chapter 12 \endash  Statements\tcl1}}}{\v \par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Compound Statements}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Compound Statements\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v compound statement}}}{\par }\pard \fi-540\li900\keepn\widctlpar\adjustright {\i\f6\fs20 compound-statement}{\f6\fs20 :  '\{' \{}{\i\f6\fs20 initialized-declaration}{\f6\fs20  ';'\}* \{}{\i\f6\fs20 statement}{\f6\fs20 \}* '\}'\par }{\i\f6\fs20 statement}{\f6\fs20 :\par \tab [}{\i\f6\fs20 expression}{\f6\fs20  ';'] |\par \tab }{\i\f6\fs20 labeled-statement}{\f6\fs20  |\par \tab }{\i\f6\fs20 compound-statement}{\f6\fs20  |\par \tab }{\i\f6\fs20 if-statement}{\f6\fs20  |\par \tab }{\i\f6\fs20 while-statement}{\f6\fs20  |\par \tab }{\i\f6\fs20 do-statement}{\f6\fs20  |\par \tab }{\i\f6\fs20 for-statement}{\f6\fs20  |\par \tab }{\i\f6\fs20 switch-statement}{\f6\fs20  |\par \tab }{\i\f6\fs20 break-statement}{\f6\fs20  |\par \tab }{\i\f6\fs20 continue-statement}{\f6\fs20  |\par \tab }{\i\f6\fs20 return-statement}{\f6\fs20  |\par \tab }{\i\f6\fs20 goto-statement}{\f6\fs20  |\par \tab }{\i\f6\fs20 segment-statement}{\f6\fs20  |\par \tab }{\i\f6\fs20 asm-statement }{\f6\fs20 |\par \tab }{\i\f6\fs20 null-statement\par labeled-statement}{\f6\fs20 :\par \tab [}{\i\f6\fs20 identifier}{\f6\fs20  | [case }{\i\f6\fs20 expression}{\f6\fs20 ] | default] ':' }{\i\f6\fs20 statement}{\f6\fs20 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Compound statements (also called blocks) are used as function bodies and to group statements together. For example, the for loop loops over a single statement. By using a compound statement, more than one statement can be executed each time the body of the loop is executed.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v declarations}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v initializers}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v scope}}}{The compound statement has two parts. The first part is a series of declarations. If present, variables declared in the block constitute a new scope. They cannot be used or modified from outside of the compound statement; in fact, they do not exist in memory until the compound statement is entered. These variables can be initialized. If so, the initializations are only carried out if the compound statement is executed from the beginning. If control is passed to a statement in a compound statement by a goto statement or switch statement, the variables are not initialized. Since the variables in a compound statement have a scope limited to the compound statement, names that have been used globally, as parameters, or in the compound statement that the new one is embedded in can be redefined within the compound statement. If this is done, the declaration within the compound statement has precedence until control leaves the compound statement. For example, the following program is legal in C, and will print 1, 2, 1 to the screen, not 1, 2, 2.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 int main(void)\par \par \{\par int i;\par \par i = 1;\par printf("%d\\n", i);\par \par    \{\par    int i;\par \par    i = 2;\par    printf("%d\\n", i);\par    \}\par \par printf("%d\\n", i);\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par }{\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v statements}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v functions}}}{The second part of the compound statement is a list of zero or more statements, including compound statements. Unless a statement changes the flow of control, these statements are executed one at a time until all of the statements have been executed. If the compound statement is the body of a function, control will return to the caller. If the compound statement is embedded in another compound statement, control will pass to the statement immediately after the compound statement.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v break statement}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v continue statement}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v switch statement}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v goto statement}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v return statement}}}{It is legal to leave a compound statement using a goto, break, continue or return statement. It is also legal to use a goto or switch statement to enter a compound statement without executing some of the statements, although variables will not be initialized in that case.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Null Statements}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Null Statements\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \fi-540\li900\keepn\widctlpar\adjustright {\i\f6\fs20 null-statement}{\f6\fs20 :  ';'\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v null statement}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v while statement}}}{Anywhere a statement can be used, a semicolon can be used. This is the null statement, which is a statement that takes no action and generates no code. It is generally used in connection with loop statements that have no statement body, such as a loop waiting for a interrupt to take place. A null statement is shown as the body of a while statement in the example below.\par \par }{\f6\fs20 while (NoBurglar()) ;\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Expression Statements}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Expression Statements\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v expressions}}}{An expression followed by a semicolon can be used as a statement. The expression is evaluated, and the result, if any, is discarded.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 While Statement}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 While Statement\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \fi-540\li900\keepn\widctlpar\adjustright {\i\f6\fs20 while-statement}{\f6\fs20 :  while '(' }{\i\f6\fs20 expression}{\f6\fs20  ')' }{\i\f6\fs20 statement}{\f6\fs20 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v while statement}}}{The while statement consists of the reserved word while followed by an expression in parentheses and a statement. The expression must be an arithmetic type; in particular, it must be of a type such that the comparison (expression) != 0 is legal. If the expression is non-zero, the statement is executed, and the process repeats. If the expression evaluates to zero, control passes to the statement following the while statement.\par The while loop can terminate early due to the effects of a return, goto or break statement.\par \par }{\f6\fs20 /* initialize an array */\par i = 0;\par while (i < 10)\par    a[i++] = 0;\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Do Statement}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Do Statement\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \fi-540\li900\keepn\widctlpar\adjustright {\i\f6\fs20 do-statement}{\f6\fs20 :  do }{\i\f6\fs20 statement}{\f6\fs20  while '(' }{\i\f6\fs20 expression}{\f6\fs20  ')' ';'\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v do statement}}}{The do statement consists of the reserved word do, a statement, the reserved word while, and an expression enclosed in parentheses. The statement is executed. Next, the expression is evaluated. The expression must be an arithmetic type; in particular, it must be of a type such that the comparison (expression) != 0 is legal. If the result is zero, control passes to the statement following the while clause that concludes the do statement. If the result of the expression is non-zero, the process repeats.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v while statement}}}{The difference between the do statement and the while statement is that the do statement always executes the statement at least one time. The while statement checks the loop condition first; if it is zero, the statement never gets executed.\par The do loop can terminate early due to the effects of a return, goto or break statement.\par \par }{\f6\fs20 do\par    printf("Please press a key.\\n");\par while (! KeyPress());\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 For Statement}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 For Statement\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \fi-540\li900\keepn\widctlpar\adjustright {\i\f6\fs20 for-statement}{\f6\fs20 :  for '(' \{}{\i\f6\fs20 expression}{\f6\fs20 \} ';' \{}{\i\f6\fs20 expression}{\f6\fs20 \} ';' \{}{\i\f6\fs20 expression}{\f6\fs20 \} ')' }{\i\f6\fs20 statement}{\f6\fs20 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v for statement}}}{The for statement is designed for use when a statement must be executed for a specified number of times. Because of its design, it can be used in many other situations. It consists of the reserved word for, followed by three expressions enclosed in parentheses and separated by semicolons, and a statement.\par Each of the expressions is optional. Execution of the for statement starts by evaluating the first expression, which is normally used to initialize a loop variable. The second expression is then evaluated. The expression must be an arithmetic type; in particular, it must be of a type such that the comparison (expression) != 0 is legal. If the result is non-zero, the statement is executed. The third expression, which is generally used to increment the loop counter, is then evaluated, and the process repeats starting at the evaluation of the second expression. If the second expression evaluates to zero, execution continues with the statement following the body of the for statement.\par If the second statement is not coded, the compiler assumes that is always evaluates to a non-zero value.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 /* initialize an array */\par for (i = 0; i < 100; ++i)\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20    a[i] = i;\par }\pard \qj\fi360\sb240\widctlpar\adjustright {\pard\plain \qj\fi360\sb240\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v while statement}}}{Another way to think of the for statement is that it is roughly equivalent to a while statement with the expressions placed in certain locations. The for statement\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 for (exp1; exp2; exp3) statement;\par }{\par }\pard \qj\widctlpar\adjustright {is equivalent to the statement\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 \{\par exp1;\par while (exp2) \{\par    statement;\par    exp3;\par    \}\par \}\par }{\par The one exception is the way the continue statement works. In the for statement, the continue statement jumps to exp3; in the while statement, the continue statement jumps to the end of the block, just past exp3.\par The for loop can terminate early due to the effects of a goto, return or break statement in the body of the loop.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 If Statement}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 If Statement\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \fi-540\li900\keepn\widctlpar\adjustright {\i\f6\fs20 if-statement}{\f6\fs20 :  if '(' }{\i\f6\fs20 expression}{\f6\fs20  ')' }{\i\f6\fs20 statement}{\f6\fs20  \{else }{\i\f6\fs20 statement}{\f6\fs20 \}\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v if statement}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v else statement}}}{The if statement is used to conditionally execute a statement. The expression is evaluated. The expression must be an arithmetic type; in particular, it must be of a type such that the comparison (expression) != 0 is legal. If the result is non-zero, the statement following the condition is executed. If the result is zero, the statement is not executed.\par The optional else clause is used to provide a second statement that will be executed if the conditional expression evaluates to zero. It is not executed if the expression yields a non-zero result.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 for (i = 1; i <= 10; ++i)\par    if (i & 1)\par       printf("%d is odd.\\n", i);\par    else\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20       printf("%d is even.\\n", i);\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Goto Statement}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Goto Statement\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \fi-540\li900\keepn\widctlpar\adjustright {\i\f6\fs20 goto-statement}{\f6\fs20 :  goto }{\i\f6\fs20 identifier}{\f6\fs20  ';'\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v goto statement}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v labels}}}{The goto statement is used to transfer control to another statement. The identifier is a named label. The label must appear on exactly one statement somewhere in the current function body. The next statement executed is the statement that the label appears on.\par It is legal to place a label on a statement and not place a goto statement in the function that refers to that label. It is not legal, however, to try to branch to a label that does not exist, or to place two labels with the same name in the same function, whether or not a goto statement exists that refers to the duplicate label.\par }\pard \sb480\keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Switch Statement}{\pard\plain \sb480\keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Switch Statement\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \fi-540\li900\keepn\widctlpar\adjustright {\i\f6\fs20 switch-statement}{\f6\fs20 :  switch '(' }{\i\f6\fs20 expression}{\f6\fs20  ')' }{\i\f6\fs20 statement}{\f6\fs20 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v switch statement}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v case label}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v default label}}}{The switch statement is used to choose from a list of statements. The expression, which must yield an integer value, is evaluated. The statement that follows is generally a compound statement. Conceptually, it is scanned for a case label with a value that matches the value generated by the expression. If such a value is found, control is passed to the statement following the case label. If there is no match, and there is a default label, the statement after the default label is executed. If there is no match, and there is no default label, control passes to the statement after the switch statement.\par There are some restrictions on the labels in the switch statement body. The case labels must have constants that are the same type as the expression after the usual unary conversions are applied to both. For example, it is not legal to use a case label with an int constant if the expression results in a long int value. Duplicate labels are not permitted. This means that two case statements cannot have constant expressions that result in the same value, and two default labels cannot appear in the body of the statement. Case labels and the default label can only appear in the body of a switch statement.\par After control is passed to one of the statements in the switch statement, execution continues as if a goto had been used to branch to the statement. For example, the following statements would print five lines on the screen. The first would have five asterisks, the second would have four, and so on. The point is that in some languages, execution would be transferred out of the switch statement when the next case label was encountered; this is not true in C.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 for (i = 1; i <= 5; ++i) \{\par    switch (i) \{\par       case 1: printf("*");\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20       case 2: printf("*");\par       case 3: printf("*");\par       case 4: printf("*");\par       case 5: printf("*");\par       \}\par    printf("\\n");\par    \}\par }{\par As the example shows, execution falls through from the statements marked by one case label to the next group of statements. It is customary in C to use the break statement at the end of each of the groups of statements.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 for (i = 1; i <= 5; ++i) \{\par    switch (i) \{\par       case 1: printf("*");\par               break;\par       case 2: printf("**");\par               break;\par       case 3: printf("***");\par               break;\par       case 4: printf("****");\par               break;\par       case 5: printf("*****");\par       \}\par    printf("\\n");\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20    \}\par }{\par The goto and return statements can also be used to leave the body of the switch statement before the last statement is executed.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Break and Continue}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Break and Continue\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \fi-540\li900\keepn\widctlpar\adjustright {\i\f6\fs20 break-statement}{\f6\fs20 :  break ';'\par }{\i\f6\fs20 continue-statement}{\f6\fs20 :  continue ';'\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {{\*\bkmkstart bk17}{\*\bkmkstart bk18}The break and continue statements are used to exit a loop early or branch to the end of the loop body.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v for statement}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v do statement}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v while statement}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v switch statement}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v case label}}}{The break statement can be used in the body of a while, do, for or switch statement. When it is encountered, control is transferred to the statement after the while, do, for or switch statement. For example, break statements can be used to cause the C switch statement to work like the Pascal case statement, as shown in the section above.\par The continue statement is used to branch to the end of a while, do or for loop. Conceptually, the continue statement does a goto to the end of the loop body.\par The easiest way to understand the break and continue statements completely is to look at the equivalent goto statements. The following four statement models show the statements which use break and continue statements. In all of the statements except switch, there is a label called C. A continue statement in the body of the loop (called body in the examples) is equivalent to a goto to the label C. In all of the statements, there is also a label called B. A break statement in the loop body is completely equivalent to goto B.\par \par }{\f6\fs20 while (}{\i\f6\fs20 expression}{\f6\fs20 ) \{}{\i\f6\fs20 body}{\f6\fs20 ; C: ;\} B: ;\par do \{}{\i\f6\fs20 body}{\f6\fs20 ; C: ;\} while (}{\i\f6\fs20 expression}{\f6\fs20 ); B: ;\par for (}{\i\f6\fs20 expression}{\f6\fs20 ; }{\i\f6\fs20 expression}{\f6\fs20 ; }{\i\f6\fs20 expression}{\f6\fs20 ) \{}{\i\f6\fs20 body}{\f6\fs20 ; C: ;\} B: ;\par switch (}{\i\f6\fs20 expression}{\f6\fs20 ) \{}{\i\f6\fs20 body}{\f6\fs20 ;\} B: ;\par }{\par If a break or continue statement appears within nested statements, it applies to the most recent enclosing statement. In the following code fragment, continue and break statements appear inside a switch statement, which is in turn inside a for loop. The break statement exits the switch statement. Since the continue statement has no meaning in the switch statement, it applies to the for statement.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 for (i = 0; i < 10; ++i)\par    switch (i) \{\par       1: 2: 3: 5: 7:\par          printf("%d is prime.\\n", i);\par          continue;\par       9:\par          printf("%d is odd.\\n", i);\par          break;\par       default:}{\pard\plain \qj\fi360\keepn\widctlpar\adjustright \v\f6\fs20\cgrid {\xe {\v\f6\fs20 }{\v\f6\fs20 default label}}}{\f6\fs20 \par          printf("%d is even.\\n", i);\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20       \}\par {\*\bkmkend bk17}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v break statement}{\rxe bk17}}}{\*\bkmkend bk18}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v continue statement}{\rxe bk18}}}{\v \par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Return Statement}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Return Statement\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \fi-540\li900\keepn\widctlpar\adjustright {\i\f6\fs20 return-statement}{\f6\fs20 :  return \{}{\i\f6\fs20 expression}{\f6\fs20 \} ';'\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v return statement}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v functions\:return value}}}{The return statement returns control to the function that called the current function. If the current function is main, control is returned to the program launcher that was used to execute the program.\par If the return statement is followed by an expression, that expression is evaluated. The type of the expression must be compatible with the type of the function in the same sense that an expression must be compatible with the l-value when the assignment operator is used. The value of the expression is returned to the caller as the return value of the function.\par If a function has a return type, but control is returned by a return statement that does not have an expression, the returned value is unpredictable.\par If the function executes to the end of the compound statement without encountering a return statement, the effect is the same as if a return statement with no expression were encountered.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Segment Statement}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Segment Statement\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \fi-540\li900\keepn\widctlpar\adjustright {\i\f6\fs20 segment-statement}{\f6\fs20 :  segment }{\i\f6\fs20 string-constant}{\f6\fs20  \{',' dynamic\} ';'\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }{\pard\plain \qj\fi360\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v segment statement}}}{\pard\plain \qj\fi360\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v memory model}}}{\v \par }\pard \qj\fi360\widctlpar\adjustright {The segment statement is used to break a program into two or more load segments. It can be used with either the large or small memory model. The affect is to cause all functions defined after the segment statement to appear in a new load segment. To understand what this does, we will look at the memory models used on the Apple\~II}{\fs20 GS}{ in detail.\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\pard\plain \qj\fi360\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v memory\:see also small memory model}{\txe }}}{\pard\plain \qj\fi360\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v memory\:see also large memory model}{\txe }}}{\v \par }{\pard\plain \qj\fi360\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v large memory model}}}{\pard\plain \qj\fi360\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v small memory model}}}{\v \par }\pard \qj\fi360\widctlpar\adjustright {In any program compiled by ORCA/C, memory is allocated for up to five different purposes. Local variables are allocated from a stack frame allocated from bank zero when the program starts to execute. Dynamic memory can also be allocated at run time by using the library functions calloc and malloc. All functions and libraries are placed in a static code segment; this segment is called the blank segment, and has no name. With the small memory model, global scalars, arrays and structures are also placed in the blank segment. If the large memory model is used, global scalars are placed in a separate segment called ~GLOBALS, and global arrays and structures are placed in a third segment called ~ARRAYS. Like the blank segment, ~GLOBALS and ~ARRAYS are static segments.\par The blank segment and the ~GLOBALS segment are each limited to 64K bytes in length; only the ~ARRAYS segment can be larger than 64K bytes. If the program is larger than 64K bytes in length, the small memory model cannot be used with a single segment. When this happens, there are two alternatives. If the program has many large arrays, the memorymodel directive, described in Chapter 6, can be used to create the ~GLOBALS and ~ARRAYS segments. This causes the compiler to generate larger, slower code to access the arrays, however. If the program does not use a large number of arrays or structures, but has several thousand lines of C code, the problem may be that the code itself exceeds 64K bytes. Using the large memory model will not help in that case. What is needed is a way to cause some of the functions to be placed in a separate static segment. The segment statement does just that:  the operand is a string constant that becomes the name of a new segment. All functions defined after the segment statement are placed in the new segment.\par \par }{\f6\fs20 segment "parser"\tab /* place subroutines in the parser segment */\par }{\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v static segments}}}{You can create as many static segments as you like. There are advantages and disadvantages to using a large number of segments. On computers with small amounts of memory, or where other programs have fragmented memory, small segments are more likely to load, since there is a better chance that a piece of memory large enough to hold the segment will be found by the loader. A program made up of several segments, however, creates a large number of inter-segment references in the relocation dictionary. These relocation records take up room on the disk, and slow down the loader.\par The functions that make up a particular segment do not have to appear in the same source file, nor do they have to appear next to each other in a source file. During the link process, the linker combines all of the functions that have the same segment name into the same load segment, regardless of the order they appear in the source program.\par After using the segment statement, if you wish to place a function in the blank segment, code a segment name with ten spaces.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v dynamic segments}}}{The segment statement can also be used to create dynamic segments. A dynamic segment is not loaded until a call is made to one of the functions in the segment. Once a call is made to a function in the dynamic segment, the segment remains in memory until an explicit call is made to the loader to unload the segment. If more than one segment statement is used to create a dynamic segment, each of the segment statements must specify that the segment is dynamic. If a single function that is not dynamic appears in the load segment, the entire load segment will become a static load segment.\par \par }{\f6\fs20 segment "initial", dynamic\par }{\par If you have a choice between using the large memory model or the segment statement (as might be the case in a program with several large arrays and a lot of executable code, it is best to use the segment directive, rather than the large memory model, since the compiler generates smaller, faster code when the small memory model is used.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Asm Statement}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Asm Statement\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \fi-540\li900\keepn\widctlpar\adjustright {\i\f6\fs20 asm-statement}{\f6\fs20 :  asm '\{' \{}{\i\f6\fs20 asm-line}{\f6\fs20 \}* '\}' ';'\par }{\i\f6\fs20 asm-line}{\f6\fs20 :  \{}{\i\f6\fs20 identifier}{\f6\fs20  ':'\} }{\i\f6\fs20 op-code}{\f6\fs20  \{}{\i\f6\fs20 operand}{\f6\fs20 \} \{';' }{\i\f6\fs20 comment}{\f6\fs20 \}\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v asm statement}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v assembly language}}}{The asm statement allows you to code assembly language statements in the body of a function. The syntax for these statement varies a bit from the syntax used by assemblers; these differences are due to the C language itself.\par Each of the assembly language statements consists of an operation code. The operation codes are the standard three-letter 65816 operation code mnemonics found in standard references for the 65816. The operation code can be specified in uppercase, lowercase, or a mix of cases. They will not be described in this manual.\par Each operation code may be preceded by a label. Unlike assemblers, this label is formatted like a C label. The name of the label follows the same rules as any C identifier, and is case sensitive. Like labels in C, it must be followed by a colon. The label may be used to identify branch points, data locations, or statements.\par Many 65816 operations require an operand. This operand is coded after the operation code. It follows the same syntax as is used by assemblers, with a few minor exceptions. First, spaces are allowed in the operand. Second, while expressions may be used, they are limited in form. Expressions must be constant expressions or global or local variables. Global and local variable names may be followed by a + or - operator and a constant expression. Global labels are treated as absolute addresses if the small memory model is in use, and long addresses if the large memory model is in use, unless the addressing mode is modified. (Modification of addressing modes is covered below.)  Local variables are treated as direct page locations. If the size of all of the local variables is larger than 255 bytes, this can cause errors in some cases. The mini-assembler does not detect this error. For that reason, it is up to the programmer to ensure that the size of local variables is kept to a minimum if they will be used as the operands of assembly language statements.\par The constant expressions used in operands follow the rules for constant expressions in C. All operators and constant operands that can appear in a C constant expression are also allowed in the operand field of an assembly language statement. In particular, note that integer constants use the C syntax for hexadecimal}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v hexadecimal}}}{ and octal}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v octal}}}{ numbers, not the syntax found in most books on assembly language.\par When an expression is used in any of the operands, you can force the value to be one byte (forcing direct page addressing), two bytes (forcing absolute addressing) or three bytes (forcing long addressing). This will override the default addressing mode. To force a particular addressing mode, precede the expression with one of the characters shown in the table below.\par \par }\pard \qj\li1440\ri3600\keepn\widctlpar\brdrt\brdrs\brdrw15 \brdrb\brdrs\brdrw15 \tx2880\adjustright {character\tab addressing mode\par }\pard \qj\li1440\ri3600\keepn\widctlpar\tx2880\adjustright {<\tab direct page\par |\tab absolute\par }\pard \qj\li1440\ri3600\widctlpar\tx2880\adjustright {>\tab long absolute\par }\pard \qj\fi360\widctlpar\adjustright {\par The syntax for the various addressing modes is shown in the table below. For descriptions on what the addressing modes do, see any of the reference books on the 65816. For addressing modes that have the same physical format, the actual addressing mode used depends on the value of the expression and the kinds of labels used, as described earlier. For example, an operand value of 255 would trigger direct page addressing, 1000 would trigger absolute addressing, and 100000 would trigger absolute long addressing. When a register is shown, such as the A in the accumulator addressing mode, it is shown in uppercase, but may be coded in uppercase or lowercase in a program.\par There is one restriction on relative branch operands that does not apply to the other instructions. Relative branches must be made to a label; you cannot code a constant value, nor can you code a label plus or minus some offset.\par \par }\pard \qj\li1440\ri1800\keepn\widctlpar\brdrt\brdrs\brdrw15 \brdrb\brdrs\brdrw15 \tx4320\adjustright {addressing mode\tab format\par }\pard \qj\li1440\ri1800\widctlpar\tx4320\adjustright {absolute\tab expression\par absolute indexed by X\tab expression,X\par absolute indexed by Y\tab expression,Y\par absolute indexed indirect\tab (expression,X)\par absolute indirect\tab (expression)\par absolute indirect long\tab [expression]\par absolute long\tab expression\par absolute long indexed by X\tab expression,X\par accumulator\tab A\par block move\tab expression,expression\par direct page\tab expression\par direct page indexed by X\tab expression,X\par direct page indexed by Y\tab expression,Y\par direct page indirect\tab (expression)\par direct page indexed indirect\tab (expression,X)\par direct page indirect long\tab [expression]\par direct page indirect indexed\tab (expression),Y\par direct page indirect long indexed\tab [expression],Y\par immediate\tab #expression\par implied\tab (no operand)\par relative addressing\tab expression\par stack relative\tab expression,S\par stack relative indirect indexed\tab (expression,S),Y\par }\pard \qj\fi360\widctlpar\adjustright {\par The operand, or operation code if there is no operand, may be followed by a semicolon. If so, this signals the start of an assembly language comment, and all characters from the semicolon to the end of the line are ignored.\par Preprocessor macros are still processed within the assembly language statements, and preprocessor macros can be used in the asm statement. The syntactic rules for using the preprocessor and macros in the assembly statement are exactly the same as they are in any other location in the C program. C style comments can also appear the asm statement.\par There are three directives supported by the built-in assembler. They are dcb, dcw, and dcl, which create a byte, word or long word (long int) variable, respectively. The operand for each of these directives is an expression which is evaluated and used to initialize the space.\par The short example shown below loads a C integer value i, counts the bits that are set, and stores the result in the C integer variable j.\par \par }\pard \qj\li1080\keepn\widctlpar\tx1440\tx2160\tx2880\adjustright {\f6\fs20 asm \{\par \tab \tab lda\tab i\par \tab \tab ldx\tab #0\par \tab \tab ldy\tab #16\par \tab lb1:\tab lsr\tab a\par \tab \tab bcc\tab lb2\par \tab \tab inx\par \tab lb2:\tab dey\par \tab \tab bne\tab lb1\par \tab \tab stx\tab j\par }\pard \qj\li1080\widctlpar\tx1440\tx2160\tx2880\adjustright {\f6\fs20    \}\par }\pard \qc\widctlpar\adjustright {\f12\fs28 \sect }\sectd \sbkodd\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\f5\fs20 Chapter 13:  Libraries\par }}\pard\plain \widctlpar\adjustright \f4\cgrid {\b\fs48 Chapter 13 \endash  Libraries\par }\pard \qj\widctlpar\adjustright {\pard\plain \qj\widctlpar\adjustright \v\f4\cgrid {\tc {\v }{\v Chapter 13 \endash  Libraries\tcl1}}}{\v \par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Overview of the Libraries}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Overview of the Libraries\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {ORCA/C comes with a powerful set of library functions. Most of these are standard libraries that are provided in any good C compiler. A few are unique to ORCA/C or to implementations of C on Apple computers. These functions have been added to make it easier to deal with the Apple\~II}{\fs20 GS}{ toolbox.\par The standard C libraries are listed in alphabetical order for easy reference. This layout is not the best for learning to use the libraries, but it makes it easy to look up a library function to see exactly how it is implemented in ORCA/C. If you are new to C, the book that you are using to learn C should give a more tutorial introduction to the libraries.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 System Functions}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 System Functions\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The run-time library for ORCA/C contains a number of functions that can be manipulated directly from ORCA/C. In some cases, these are functions normally called by the C startup code, or for some other internal purpose, that perform some service you may need in an unusual circumstance. In these cases, you can declare the function as extern and call it from within your C program. In other cases, the default action may not be what you want; for example, you may want to intercept run-time errors, displaying them in a dialog or trapping them for internal handling. In these situations, you can define the function in your program, and ORCA/C will use your version rather than the one from the library.\par Source code for all of these subroutines is included with ORCA/C.\par }\pard \widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 SysCharErrout}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 SysCharErrout}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 extern pascal void SysCharErrout (char);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Writes a character to error out.\par }\pard \widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 SysCharOut}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 SysCharOut}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 extern pascal void SysCharOut (char);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Writes a character to standard out.\par }\pard \widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 SysIOShutDown}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 SysIOShutDown}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 extern pascal void SysIOShutDown (void);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Closes any files opened by SysIOStartup.\par }\pard \widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 SysIOStartup}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 SysIOStartup}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 extern pascal void SysIOStartup (void);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Starts the I/O system using the files in prefixes 10, 11 and 12. If the files have already been opened, the existing open file is used, and the file is not closed when the program exits. If prefix 10 is .CONSOLE, }{\f6\fs20 DRead}{ calls are used to read lines of text, allowing editing. In this case, you can use RETURN to finish a line, or ctrl-@ or command. to signal an end of file.\par }\pard \widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 SysKeyAvail}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 SysKeyAvail}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 extern pascal int SysKeyAvail (void);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Returns 1 (TRUE) if there is an input character available, and 0 (FALSE) if there is not.\par If a character has been put back with a call to }{\f6\fs20 SysPutback}{, and has not been read by a subsequent call to }{\f6\fs20 SysKeyin}{, the result is TRUE. The rest of the discussion assumes there is no character in the putback buffer.\par If input is redirected from a file, this function is equivalent to a test for end of file, returning the opposite result.\par For input from .CONSOLE, if there is remaining input in the line buffer, TRUE is returned. If not, and if the Event Manager is active, the result is TRUE if there is a keypress or auto key event available, and FALSE if not. If the Event Manager is not active, the result is TRUE if bit 7 of 0x0C0000 is set, and FALSE if not. (0x0C0000 is the hardware keyboard input location.)\par Note:  If input is from .CONSOLE, the fact that this function returns TRUE is }{\i not}{ a guarantee that a call to }{\f6\fs20 SysKeyin}{ will return immediately, since }{\f6\fs20 SysKeyin}{ would wait for an entire line to be typed.\par }\pard \widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 SysKeyin}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 SysKeyin}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 extern pascal char SysKeyin (void);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Reads a character from standard in. If an end of file condition occurs, (char) 0 is returned.\par If input is from .CONSOLE, an entire line is read on the first call to this subroutine, and remaining characters are returned on subsequent calls until the line is exhausted; another call will then read in a new line.\par }\pard \widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 SysPutback}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 SysPutback}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 extern pascal void SysPutback (char);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Places a character in a one-character putback buffer. This character will be the next character returned by }{\f6\fs20 SysKeyin}{, and }{\f6\fs20 SysKeyAvail}{ will return TRUE until the buffer is emptied.\par If another call is made to }{\f6\fs20 SysPutback}{ before the first character is used, the original character is lost.\par }\pard \widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 SystemEnvironmentInit}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 SystemEnvironmentInit}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 extern pascal void SystemEnvironmentInit (void);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {This subroutine initializes global variables used by the compilers and their libraries. It should be called by programs that are not started in the normal way as one step in initializing the run-time environment.\par }\pard \qj\sb240\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 SystemError}{\pard\plain \qj\sb240\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 SystemError}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 extern pascal void SystemError (int);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {When a run-time error occurs, libraries call }{\f6\fs20 SystemError}{. By defining your own version of }{\f6\fs20 SystemError}{, you can intercept and handle run-time errors within your own program. You can also call }{\f6\fs20 SystemError}{ from within your own program if your own program needs to report an error.\par By default, }{\f6\fs20 SystemError}{ calls two other library subroutines, }{\f6\fs20 SystemPrintError}{ and }{\f6\fs20 SystemErrorLocation}{, to actually handle the error. If you write your own version of }{\f6\fs20 SystemError}{, you may want to call one or both of these subroutines for some or all of the errors.\par The table below shows the various error numbers currently reported by the run-time libraries. Some of these errors are used by only one of the ORCA languages, so not all of them are actually possible from within a program written entirely in C.\par \par }\pard \qj\li1440\ri1800\keepn\widctlpar\brdrt\brdrs\brdrw15 \brdrb\brdrs\brdrw15 \tx2880\adjustright {Error Number\tab Error\par }\pard \qj\li1440\keepn\widctlpar\tx2880\adjustright {1\tab Subrange exceeded\par 2\tab File not open\par 3\tab Read while at end of file\par 4\tab I/O error\par 5\tab Out of memory\par 6\tab EOLN while at end of file\par 7\tab Set overflow\par 8\tab Jump to undefined case statement label\par }{\i \tab This error cannot be recovered from!\par }{9\tab Integer math error\par 10\tab Real math error\par 11\tab Underflow\par 12\tab Overflow\par 13\tab Divide by zero\par 14\tab Inexact\par 15\tab Stack overflow\par }\pard \qj\li1440\widctlpar\tx2880\adjustright {16\tab Stack error\par }\pard \widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 SystemErrorLocation}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 SystemErrorLocation}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 extern pascal void SystemErrorLocation (void);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {This subroutine is called by }{\f6\fs20 SystemError}{ when a run-time error is reported. Normally, this subroutine prints any traceback information recorded due to the debug pragma, then shuts down the program. This subroutine can be called from within a C program to print traceback information during the debug cycle, or replaced with a different subroutine that either handles an error and recovers from it, or shuts down the system in a different way.\par }\pard \widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 SystemMinStack}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 SystemMinStack}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 extern pascal void SystemMinStack (void);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {This subroutine finds the start of the segment containing the return address, setting the variable }{\f6\fs20 ~MinStack}{ to this value. It should be the very first subroutine called by programs that are not started in the normal way, assuming the program owns the stack frame. }{\f6\fs20 ~MinStack}{ must be set before calling }{\f6\fs20 SystemSANEInit}{ or before using any debug options that check for stack overflows. It can be set manually from assembly language.\par }\pard \qj\sb240\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 SystemMMShutDown}{\pard\plain \qj\sb240\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 SystemMMShutDown}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 extern pascal void SystemMMShutDown (void);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {This subroutine shuts down the memory manager used by the run time libraries. It should be called just before a program exits for the last time. The memory manager is left in a restartable state after this call.\par }\pard \widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 SystemPrintError}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 SystemPrintError}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 extern pascal void SystemPrintError (int);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Writes a text error message to standard out. See }{\f6\fs20 SystemError}{ for a list of the errors that }{\f6\fs20 SystemPrintError}{ can handle, as well as the strings it will print.\par }\pard \widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 SystemQuitFlags}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 SystemQuitFlags}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 extern pascal void SystemQuitFlags (unsigned);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \fi360\widctlpar\adjustright {This subroutine sets the quit flags field for the GS/OS Quit call that is made to exit from a normal C program. See }{\ul Apple\~II}{\fs20\ul GS}{\ul  GS/OS Reference}{ for the allowed values for this parameter.\par }\pard \widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Note:  In restartable programs, be sure to initialize this variable to 0 manually. The libraries do not normally initialize this value.\par }\pard \widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 SystemQuitPath}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 SystemQuitPath}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 extern pascal void SystemQuitPath (GSString255Ptr);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \fi360\widctlpar\adjustright {This subroutine sets the quit pathname field for the GS/OS Quit call that is made to exit from a normal C program. See }{\ul Apple\~II}{\fs20\ul GS}{\ul  GS/OS Reference}{ for the allowed values for the parameter.\par }\pard \widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Note:  In restartable programs, be sure to initialize this variable to NULL manually. The libraries do not normally initialize this value.\par }\pard \widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 SystemSANEInit}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 SystemSANEInit}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 extern pascal void SystemSANEInit (void);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \fi360\widctlpar\adjustright {This subroutine is called to start SANE. Replacing it with a dummy subroutine would cause the system to skip starting SANE. Calling this subroutine from a CDA or an NDA is a quick way to start SANE, which is not normally started by ORCA/C for these kinds of programs.\par \par }\pard \qj\fi360\widctlpar\adjustright {This subroutine keeps track of whether SANE was initially started, starting SANE only if needed. }{\f6\fs20 SystemSANEShutDown}{ will only shut down SANE if it was started by this subroutine.\par }\pard \widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 SystemSANEShutDown}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 SystemSANEShutDown}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 extern pascal void SystemSANEShutDown (void);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {If SANE was started by an earlier call to }{\f6\fs20 SystemSANEInit}{, this subroutine shuts down the tool.\par }\pard \qj\sb240\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 SystemUserID}{\pard\plain \qj\sb240\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 SystemUserID}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 extern pascal void SystemUserID (unsigned, char *);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {This subroutine should be called right after }{\f6\fs20 SystemMinStack}{ by programs that are not started in the normal way. The first parameter must be passed; it is the user ID for the program. The second parameter can either be a pointer to a command line string or NULL. If the string is a pointer to a command line string, the command line should start with an 8 character identifier naming the launcher, and be followed by the command line as a null terminated string.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Standard C Libraries}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Standard C Libraries\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\b\fs28 abort\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See exit.\par \par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 abs}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 abs}}}{\b\fs28 \tab labs}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 labs}}}{\b\fs28 \tab fabs}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 fabs}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <stdlib.h>\par int      abs(int x);\par long     labs(long x);\par \par #include <math.h>\par extended fabs(extended x);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function abs accepts an integer argument and returns the absolute value of the argument. Note that abs is in stdlib.h, not math.h, as with some older C compilers.\par The function labs accepts a long integer argument and returns the absolute value of the argument. Note that labs is in stdlib.h, not math.h, as with some older C compilers.\par The function fabs accepts an extended floating-point argument and returns the absolute value of the argument.\par \par }{\f6\fs20 distance = fabs(x1-x2);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 acos}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 acos}}}{\b\fs28 \par }{\par }{\f6 #include <math.h>\par extended acos(extended x);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v EDOM}}}{The function acos returns the trigonometric arc cosine (inverse cosine) of the argument. The result is in radians, and lies in the range 0 to \u960\'b9. If the argument is less than -1.0 or greater than 1.0, errno is set to EDOM.\par \par }{\f6\fs20 angle = acos(arg);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 asctime\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See ctime.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 assert}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 assert}}}{\b\fs28 \par }{\par }{\f6 #include <assert.h>\par void assert(int v);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Assert is a macro generally used while a program is under development. It takes a single argument, which must be an expression that would be legal as the condition expression in an if statement. If that argument is zero, assert prints "Assertion failed:  file }{\i file}{, line }{\i number}{" to standard out, where }{\i file}{ is the name of the source file, and }{\i number}{ is the line number within the source file. The program is then stopped by calling exit(-1). If the #pragma debug directive has been used to enable trace backs, ORCA/C will also print the line number and source file name where the assert call was made, and a trace back showing what calls were made to arrive at that point.\par The macro NDEBUG is used to disable the debug code generated by calls to assert. If NDEBUG is defined when the assert.h header file is read, no code is generated for the assert calls.\par \par }{\f6\fs20 assert(parm != 0.0);\tab /* we should never be passed a value of zero! */\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 asin}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 asin}}}{\b\fs28 \par }{\par }{\f6 #include <math.h>\par extended asin(extended x);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v EDOM}}}{The asin function returns the trigonometric arc sine (inverse sine) of the argument. The result is in radians, and lies in the range -\u960\'b9/2 to \u960\'b9/2. If the argument is less than -1.0 or greater than 1.0, errno is set to EDOM.\par \par }{\f6\fs20 angle = asin(arg);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 atan}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 atan}}}{\b\fs28 \par }{\par }{\f6 #include <math.h>\par extended atan(extended x);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The atan function returns the trigonometric arc tangent (inverse tangent) of the argument. The result is in radians, and lies in the range -\u960\'b9/2 to \u960\'b9/2.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v arctan}}}{In some versions of C, this function is called arctan. ORCA/C includes arctan as a macro equivalent of atan to make it easier to port programs written under these compilers.\par \par }{\f6\fs20 angle = atan(arg);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 atan2}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 atan2}}}{\b\fs28 \par }{\par }{\f6 #include <math.h>\par extended atan2(extended y, extended x);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v EDOM}}}{The atan2 function returns the trigonometric arc tangent (inverse tangent) of the arguments. Since the actual coordinates of a point are given, rather than the quotient of the two points (as with atan), this function can return results in the range -\u960\'b9 to \u960\'b9. The result is in radians, and represents the angle between the positive x axis and the point (x, y) in Cartesian coordinates. A domain error occurs if both x and y are zero, in which case errno is set to EDOM.\par \par }{\f6\fs20 angle = atan2(y,x);\par }\pard \qj\sb240\keepn\widctlpar\adjustright {\b\fs28 atexit}{\pard\plain \qj\sb240\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 atexit}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <stdlib.h>\par int atexit(void (*func)());\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The atexit function registers a function so it will be called when the program is complete, either due to a call to the exit function, or because a return is made from the main function. More than one function can be registered in this way; if so, they are called in reverse of the order in which atexit was called to register the functions. The functions must not require parameters, and should return void. The atexit function returns a non-zero value if the function is registered successfully, and zero if there is not enough memory to satisfy the request.\par If the same function is registered more than once, ORCA/C will call the function once for each time it is registered. Other compilers may handle this situation differently.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 void hello(void)\par \par \{\par printf("Hello, world.\\n");\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 int main(void)\par \par \{\par atexit(hello);\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par }{\par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 atof}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 atof}}}{\b\fs28 \tab atoi}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 atoi}}}{\b\fs28 \tab atol}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 atol}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <stdlib.h>\par double atof(char *str);\par int    atoi(char *str);\par long   atol(char *str);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {These functions are simpler versions of the string conversion functions strtod and strtol. The definitions below define these functions in terms of their more powerful counterparts. For details on what strings are accepted and how errors are handled, see the description of the strtod function.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 double atof(char *str)\par \par \{\par return strtod(str, (char**)NULL);\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 int atoi(char *str)\par \par \{\par return (int) strtol(str, (char**)NULL, 10);\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 long atol(char *str)\par \par \{\par return strtol(str, (char**)NULL, 10);\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \}\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 bsearch}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 bsearch}}}{\b\fs28 \par }{\par }{\f6 #include <stdlib.h>\par void *bsearch(void *key, void *base, size_t count, size_t size, \par               int (*compar)(const void *ptr1, const void *str2));\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The bsearch function performs a binary search. It searches the array pointed to by base. This array consists of count elements, each of which is size bytes long. The array must be sorted in ascending order. The parameter key points to a value of the same type as the elements of the array; key is the element to search for. The function compar is supplied by the program; it takes two arguments whose types match the type of key, and returns 0 of the arguments match, -1 of the first argument is less than the second, and 1 if the first argument is greater than the second. If the value is found, a pointer to the array element is returned; otherwise, bsearch returns NULL.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 int CompareZip(address *addr1, address *addr2)\par \par \{\par if (addr1.zip == addr2.zip)\par    return 0;\par if (addr1.zip < addr2.zip)\par    return -1;\par return 1;\par \}\par \par ...\par /* find an address with a zip code of 87114 */\par addr.zip = 87114;\par aPtr = bsearch(&addr, addressList, listSize, sizeof(address),\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20    CompareZip);\par }{\par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 c2pstr}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 c2pstr}}}{\b\fs28 \tab p2cstr}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 p2cstr}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <string.h>\par char *c2pstr(char *string);\par char *p2cstr(char *string);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v p-strings}}}{These functions are used to translate between null-terminated C strings and the so-called Pascal strings, which have a leading length byte. In both cases, a pointer to the resulting string is returned. The original string is not changed in any way; the result string is built in an internal buffer. Because an internal buffer is used, subsequent calls to either of these functions can destroy old values. For that reason, it is important to copy the result to a local string buffer if one of these functions will be called before the need for the converted string has passed.\par The function c2pstr converts a null-terminated string into a string with a leading length byte. If the null-terminated string is longer than 255 characters, a string with 255 characters is created. The string has a terminating null character following the last character, so standard C string manipulation functions can still be used on the result.\par The function p2cstr converts a string with a leading length byte into a null-terminated string.\par These functions are not standard C functions. They are included in Apple\~II}{\fs20 GS}{ based C compilers to make it easier to deal with the toolbox, which often requires strings with a length byte.\par \par }{\f6\fs20 /* use a null-terminated string to set a window title */\par SetWTitle(strcpy(title, c2pstr(temp)), window);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 calloc\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See malloc.\par \par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 ceil}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 ceil}}}{\b\fs28 \tab floor}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 floor}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <math.h>\par extended ceil(extended x);\par extended floor(extended x);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function ceil accepts a floating-point argument and returns the floating-point representation of the argument, rounded up to the next higher integer. If the argument is an integer, the result is the same value.\par The function floor is similar, except that the result is rounded down towards negative infinity.\par \par }{\f6\fs20 x = ceil(x);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 cfree\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See free.\par \par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 chmod}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 chmod}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <fcntl.h>\par int chmod(char *path, int mode);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Changes the access bits in the file. The following bit flags are supported.\par \par }\pard \qj\li360\widctlpar\tx1440\tx2520\adjustright {0x0100\tab Read\tab enables the file for input\par 0x0080\tab Write\tab enables the file for output\par 0x1000\tab Delete\tab allows the file to be deleted\par 0x2000\tab Rename\tab allows the file to be renamed\par 0x4000\tab Backup\tab indicates that the file should be backed up\par 0x8000\tab Invisible\tab makes the file invisible to the Finder\par }\pard \qj\fi360\widctlpar\adjustright {\par The flags are added together to make up the mode field. Setting a flag enables the corresponding GS/OS bit, enabling the action described. Clearing the flags disables the action. For example, the call\par \par }{\f6\fs20 chmod("myfile", 0x6100);\par }{\par }\pard \qj\widctlpar\adjustright {sets the access bits so that the file "myfile" can be read or renamed, and indicates that it should be backed up. The file cannot be written to or deleted without changing the access bits. The file is visible to the Finder.\par }\pard \qj\fi360\widctlpar\adjustright {The flags for Delete, Rename, Backup and Invisible are unique to the Apple\~II}{\fs20 GS}{. All of the bits in 0x0E7F are used for other purposes under UNIX. They are ignored in ORCA/C.\par While this function is a common one in C libraries, it is not required by the ANSI C standard, and should be avoided if possible. In particular, the function should not be used in programs that will be ported to other computers unless it is imbedded in conditional compilation code so that the function will only be called on the Apple\~II}{\fs20 GS}{ version of the program.\par If the call is successful, the function returns 0; otherwise, a -1 is returned and errno is set as indicated in the list below.\par If the file does not exist, errno is set to ENOENT.\par }\pard \qj\sb240\keepn\widctlpar\adjustright {\b\fs28 clalloc\par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {See malloc.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 clearerr\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See ferror.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 clock}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 clock}}}{\b\fs28 \par }{\par }{\f6 #include <time.h>\par #define CLK_TCK (60)\par typedef unsigned long clock_t;\par \par clock_t clock(void);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The clock function is used on multi-tasking systems to see how much time has been used by a program. The result is returned as the number of clock ticks since the program started. The number of clock ticks per second is defined by the macro CLK_TCK; on most systems, this time is returned in microseconds. (One microsecond is 10}{\fs20\up6 -6}{ seconds.)\par The Apple\~II}{\fs20 GS}{ operating system is not a multi-tasking operating system, and the Apple\~II}{\fs20 GS}{ clock is not accurate to the microsecond time scale. ORCA/C uses the tick count returned by the Miscellaneous Tool Set GetTick call for a clock count; CLK_TCK is therefore 60. The tick count is started whenever a heartbeat interrupt handler is installed. The Event Manager installs a heartbeat interrupt handler, so the clock function can always be used from the desktop development environment. If you will be using the clock function from the text environment, you will need to ensure that the heartbeat interrupt handler is active.\par \par }{\f6\fs20 clicks = clock();\par }{\par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 close}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 close}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <fcntl.h>\par int close(int filds);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The file with the file ID filds is closed. If the file has been duplicated using the dup call, it is not closed until each of the associated file IDs have been closed.\par If the call is successful, the function returns 0; otherwise, a -1 is returned and errno is set to EBADF (filds is not a valid file descriptor).\par While this function is a common one in C libraries, it is not required by the ANSI C standard, and should be avoided if possible.\par See also fclose.\par }\pard \qj\widctlpar\tx1440\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 cos}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 cos}}}{\b\fs28 \par }{\par }{\f6 #include <math.h>\par extended cos(extended x);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The cos function returns the trigonometric cosine of the argument. The argument must be supplied in radians.\par \par }{\f6\fs20 length = cos(x)*hypotenuse;\par }\pard \qj\sb240\keepn\widctlpar\adjustright {\b\fs28 cosh}{\pard\plain \qj\sb240\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 cosh}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <math.h>\par extended cosh(extended x);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ERANGE}}}{The cosh function returns the hyperbolic cosine of the argument. If an error occurs, errno is set to ERANGE.\par \par }{\f6\fs20 n = cosh(x);\par }{\par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 creat}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 creat}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <fcntl.h>\par int creat(char *path, int mode);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Creates a new file or opens an existing one for output. If the file exists, its length is set to 0. The name of the file is path. The mode parameter is identical to the mode parameter for the chmod call. The file created is a binary file. If the file already exists, it's file type is not changed.\par Please note that in APW C}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v APW C}}}{, creat does not have a mode parameter. It does in UNIX based C implementations, so we have maintained that use here.\par If the call is successful, the function returns 0; otherwise, a -1 is returned and errno is set as indicated in the list below.\par While this function is a common one in C libraries, it is not required by the ANSI C standard, and should be avoided if possible.\par \par }\pard \qj\li360\widctlpar\adjustright {\ul Possible errors\par }{\par EACCES\tab The file exists, and is not write enabled.\par EACCES\tab The file does not exist, and could not be opened.\par ENOENT\tab The pathname is null.\par EMFILE\tab OPEN_MAX files are already open.\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 ctime}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 ctime}}}{\b\fs28 \tab asctime}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 asctime}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <time.h>\par typedef unsigned long time_t;\par \par char *ctime(time_t *timeptr);\par char *asctime(struct tm *ts);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The ctime function takes a pointer to an encoded time as input and returns a pointer to an ASCII string of the form\par \par }{\f6\fs20 Www Mmm dd hh:mm:ss 19yy\\n\\0\par }{\par where the fields are:\par \par }\pard \qj\li360\ri3240\keepn\widctlpar\brdrt\brdrs\brdrw15 \brdrb\brdrs\brdrw15 \tx1620\tx2880\adjustright {Field\tab Example\tab Description\par }\pard \qj\li360\ri3240\keepn\widctlpar\tx1620\tx2880\adjustright {Www\tab Mon\tab day of week\par Mmm\tab Feb\tab month\par dd\tab 29\tab date\par hh\tab 16\tab hour (24 hour format)\par mm\tab 03\tab minutes\par ss\tab 57\tab seconds\par }\pard \qj\li360\ri3240\widctlpar\tx1620\tx2880\adjustright {yy\tab 88\tab year\par }\pard \qj\fi360\widctlpar\adjustright {\par The asctime function creates a similar time string, but takes a pointer to a calendar time structure created by localtime or gmtime as input.\par The return string is in a static buffer which is reused by each call to ctime or asctime. If you must keep a copy of the string, and subsequent calls will be made to ctime, be sure to save a copy of the string in a local buffer.\par See also time, gmtime, localtime.\par \par }{\f6\fs20 int main (void)\par \par \{\par time_t bintime;\par struct tm timestruct;\par \par bintime = time(NULL);\par printf("The time is %s\\n", ctime(&bintime));\par \par timestruct = *gmtime(&bintime);\par printf("The time is %s\\n", asctime(&timestruct));\par \}\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 difftime}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 difftime}}}{\b\fs28 \par }{\par }{\f6 #include <time.h>\par typedef unsigned long time_t;\par \par double difftime(time_t t1, time_t t0);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The difftime function returns the difference between t0 and t1, in seconds. The parameters are specified in the format used by the time function.\par \par }{\f6\fs20 printf("%.0f seconds have elapsed.\\n", difftime(time(NULL), oldtime));\par }{\par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 div}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 div}}}{\b\fs28 \tab ldiv}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 ldiv}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <stdlib.h>\par typedef struct div_t \{int quot,rem;\};\par typedef struct ldiv_t \{long quot,rem;\};\par \par div_t  div(int n, int d);\par ldiv_t ldiv(long n, long d);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function div computes the result of division and the remainder as a single step. The quot (quotient, or result of division) and rem (remainder) are returned in a structure. The function ldiv does the same thing for long arguments. The results are unpredictable if the denominator is zero.\par \par }{\f6\fs20 /* print a result as a whole number and fraction */\par res = div(numerator, denominator);\par printf("%d and %d/%d", res.quot, res.rem, denominator);\par }{\par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 dup}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 dup}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <fcntl.h>\par int dup(int old);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Duplicates a file ID. The original file ID is created by a creat or open call. This call creates a duplicate of the file ID. The actual file on disk is not closed until each individual file ID is closed.\par If the call is successful, the function returns 0; otherwise, a -1 is returned and errno is set as indicated in the list below.\par While this function is a common one in C libraries, it is not required by the ANSI C standard, and should be avoided if possible.\par \par }\pard \qj\li360\keepn\widctlpar\adjustright {\ul Possible errors\par }{\par }\pard \qj\li360\keepn\widctlpar\tx2160\adjustright {EBADF\tab Old is not a valid file descriptor\par }\pard \qj\li360\widctlpar\tx2160\adjustright {EMFILE\tab OPEN_MAX files are already open\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 enddesk\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See startdesk.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 endgraph\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See startgraph.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 EOF}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 EOF}}}{\b\fs28 \par }{\par }{\f6 #include <stdio.h>\par #define EOF (-1)\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {EOF is a value used to see if you have reached the end of a file. If so, the file input routines will report this character as the one read. After seeing this character, always use the feof function to ensure that the end of the file has, indeed, been reached, as opposed to the file containing a character 0xFF which has been sign extended to become a -1.\par \par }{\f6\fs20 /* process the characters in a file */\par do \{\par    done = (ch = fgetc(myFile)) == EOF;\par    if (done)\par       done = feof(myFile);\par    if (!done)\par       process(ch);\par    \}\par while (!done)\par }{\par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 errno}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 errno\bxe }}}{\b\fs28 \tab perror}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 perror}}}{\b\fs28 \tab strerror}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 strerror}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <errno.h>\par extern int errno;\par \par #include <string.h>\par char *strerror(int errnum);\par \par #include <stdio.h>\par void perror(char *s);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v run-time errors}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v errors}}}{This collection of functions, variables and macros implement the standard run-time error package for C.\par The variable errno is used by the libraries to report errors. Any time an error is detected by one of the libraries, an error number is stored in errno. Note that errno is never cleared by the libraries. To make effective use of errno, your program should clear errno before calling a function, call the function, then check errno to see if an error occurred.\par The error numbers used by errno are defined as macros in two interface files. Mathematical errors can be found in math.h, while all other errors are defined in errno.h.\par The perror function is used to print an error message. The error message is printed to error out. It consists of an error message (which is supplied as a parameter to perror), a colon and a space, a description of the error currently reported by errno, and a new line character.\par The strerror function returns a pointer to a string. If errno is supplied as the argument, the result is identical to the message description printed by perror. (This is not true in all implementations of C, however.)\par See also toolerror.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 if (errno) \{\par    perror("Error at line __LINE__ of __FILE__");\par    exit(errno);\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20    \}\par }{\par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 exit}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 exit}}}{\b\fs28 \tab _exit}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 _exit}}}{\b\fs28 \tab abort}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 abort}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <stdlib.h>\par void exit(int status);\par void _exit(int status);\par void abort(void);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The exit function exits the program, calling all functions registered by the function atexit, and then performing the normal clean-up operations of closing open streams, flushing buffers, and deleting files created by calls to tmpfile. The _exit function also exits, but does not do the clean-up operations. Any open streams will still be closed by the shell, which will also dispose of any memory used by the program. Both functions accept an integer argument, which is returned to the shell as a completion code. A completion code of zero tells the shell that the program finished normally, and any script files will continue to execute. A non-zero value tells the shell that some error occurred. Some shell utilities also use the return code to return a value to the shell.\par The abort function is the same as _exit(-1). Abort is not always implemented the same way. Depending on the implementation, abort can exit with some other exit code (so long as it is non-zero), or even exit with a maskable interrupt, so that the program can handle the situation as an error and return to the caller, often returning a value.\par \par }{\f6\fs20 exit(0);\par _exit(errno);\par }\pard \qj\sb240\keepn\widctlpar\adjustright {\b\fs28 exp}{\pard\plain \qj\sb240\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 exp}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <math.h>\par extended exp(extended x);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ERANGE}}}{The exp function returns the extended floating-point representation of e raised to the x power, where e is the base of the natural logarithm (approximately 2.718281828). If the exponent cannot be represented as an extended number, an overflow results. In that case, infinity is returned and errno is set to ERANGE.\par \par }{\f6\fs20 res = exp(x);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 fabs\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See abs.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 fclose}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 fclose}}}{\b\fs28 \par }{\par }{\f6 #include <stdio.h>\par int fclose(FILE *stream);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function fclose takes an open file as input, and closes the file. If an error occurs, fclose returns EOF; otherwise, it returns zero.\par \par }\pard \qj\fi360\widctlpar\tx4320\adjustright {\f6\fs20 fclose(myfile);\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 fcntl}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 fcntl}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <fcntl.h>\par int fcntl(int filds, int cmd, int arg);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function fcntl provides control over open files. The }{\i filds}{ parameter is the file ID for a previously opened file. Under UNIX, the }{\i cmd}{ parameter can take on a number of values, but on the Apple\~II}{\fs20 GS}{, the only value that makes sense is F_DUPFD, which makes a copy of the file descriptor. The number of the file descriptor returned is always greater than or equal to }{\i arg}{, and has exactly the same characters as the old file descriptor.\par While this function is a common one in C libraries, it is not required by the ANSI C standard, and should be avoided if possible.\par If an error occurs, fcntl returns -1 and sets errno to one of these values; if an errno does not occur, fcntl returns 0.\par \par }\pard \qj\li360\widctlpar\tx2160\adjustright {\ul Possible errors\par }{\par EBADF\tab filds is not a valid file descriptor.\par EINVAL\tab The }{\i cmd}{ parameter is not F_DUPFD.\par EMFILE\tab There ore no available file descriptors greater than arg-1.\par EMFILE\tab arg is negative.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 feof}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 feof}}}{\b\fs28 \par }{\par }{\f6 #include <stdio.h>\par int feof(FILE *stream);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The feof function checks to see if an end of file condition exists for the specified stream. An end of file condition exists if an attempt has been made to read past the end of a file. Note that an end of file condition does not exists if all of the characters in a file have been read, but no attempt has been made to read another character. A value of zero is returned if an end of file condition does not exist; a non-zero value is returned if an end of file has been detected.\par \par }\pard \qj\fi360\keepn\widctlpar\tx4320\adjustright {\f6\fs20 /* echo a file */\par stream = fopen("myfile", "r");\par if (stream != NULL)\par    do\par       putchar(fgetc(stream));\par    while (!feof(stream));\par }\pard \qj\fi360\widctlpar\tx4320\adjustright {\f6\fs20 fclose(stream);\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 ferror}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 ferror}}}{\b\fs28 \tab clearerr}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 clearerr}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <stdio.h>\par int  ferror(FILE *stream);\par void clearerr(FILE *stream);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The ferror function returns a non-zero value if a read or write error has occurred on the specified stream. It returns a zero if no error has occurred.\par If an error condition exists, it can be cleared by a call to clearerr or by closing the file.\par \par }\pard \qj\fi360\keepn\widctlpar\tx4320\adjustright {\f6\fs20 if (ferror(myFile)) \{\par    clearerr(myFile);\par }\pard \qj\fi360\widctlpar\tx4320\adjustright {\f6\fs20    HandleError();\par    \}\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 fflush}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 fflush}}}{\b\fs28 \par }{\par }{\f6 #include <stdio.h>\par int fflush(FILE *stream);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The fflush function takes a stream open for output and flushes any internal buffers, writing them to the destination device. The stream remains open. EOF is returned if there is an error; otherwise, zero is returned.\par \par }\pard \qj\fi360\widctlpar\tx4320\adjustright {\f6\fs20 fflush(myfile);\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 fgetc}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 fgetc}}}{\b\fs28 \tab getc}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 getc}}}{\b\fs28 \tab getchar}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 getchar}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <stdio.h>\par int fgetc(FILE *stream);\par int getc(FILE *stream);\par int getchar(void);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v errno}}}{These functions are used to read characters from a stream. The function fgetc and the macro getc do exactly the same thing:  the only difference is that fgetc is implemented as a function, while getc is implemented as a macro. In each case, a character is read from the stream and returned. The current position of the stream is updated after each read. If an error occurs during the read or if a read is attempted after the last character in the file has been read, EOF is returned. In that case, the feof should be used to see if the end of file has actually been reached. Errno can also be checked to see if an error has occurred.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v keyboard input}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v standard input}}}{The function getchar works like an fgetc(stdin), reading a character from standard in. If stdin is set to the keyboard (the default), control-@ is used to signal the end of a file. The end of a line is signaled with the }{\outl\fs20 return}{ key or }{\outl\fs20 enter}{ key. Note that the console input routines buffer the characters in chunks of one line to allow the user to edit the line while it is being typed. The getchar function will not return a character until an entire line has been typed.\par \par }\pard \qj\fi360\keepn\widctlpar\tx4320\adjustright {\f6\fs20 ch = fgetc(myFile);\par }\pard \qj\fi360\widctlpar\tx4320\adjustright {\f6\fs20 ch = getchar();\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 fgetpos}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 fgetpos}}}{\b\fs28 \tab fsetpos}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 fsetpos}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <stdio.h>\par int fgetpos(FILE *stream, fpos_t *pos);\par int fsetpos(FILE *stream, const fpos_t *pos);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The fgetpos function records the current position in a file. The information needed to restore the file to its position at the time of the call is recorded in a value of type fpos_t. The fsetpos function is used to restore the file to the position at the time of the fgetpos call.\par If either call is successful, the function returns 0; otherwise it returns a non-zero value and sets errno. While the exact values returned vary from compiler to compiler, in ORCA/C, these functions return -1 for a failure, and set errno to _IOERR.\par See also fseek and ftell.\par \par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 fgets}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 fgets}}}{\b\fs28 \tab gets}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 gets}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <stdio.h>\par char *fgets(char *s, int n, FILE *stream);\par char *gets(char *s);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function fgets reads a string from a file. Up to n-1 characters are read; they are placed in the character array pointed to by s. A pointer to the first character in s is returned if the read was successful. Input stops if an end of file condition is encountered, a new line character is encountered, or if n-1 characters are read. In all cases, a terminating null character is placed after the last character read. The new line character, if encountered, does become part of the string; it is placed just before the terminating null character.\par If an end of file is encountered before any characters are read, or if an error condition occurs during the read, fgets returns a null pointer and the buffer s is left undisturbed.\par The function gets reads characters into the buffer s, taking the characters from standard in. Characters are read until an end of line character is encountered. Unlike fgets, gets does not include the end of line mark as part of the string.\par \par }\pard \qj\fi360\widctlpar\tx4320\adjustright {\f6\fs20 /* process a file */\par do \{\par    fgets(line, 255, myFile);\par    process(line);\par    \}\par while (!feof(myFile));\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 floor\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See ceil.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 fmod}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 fmod}}}{\b\fs28 \par }{\par }{\f6 #include <math.h>\par extended fmod(extended x, extended y);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function fmod returns the floating-point remainder of x/y. If the result cannot be represented as an extended floating-point number, the result is undefined. This function can be thought of as performing the division, then removing the whole-number portion of the result. If y is zero, x is returned.\par See also modf.\par \par }{\f6\fs20 x = fmod(x,y);\par }{\par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 fopen}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 fopen}}}{\b\fs28 \tab freopen}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 freopen}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <stdio.h>\par FILE *fopen(char *filename, char *type);\par FILE *freopen(char *filename, char *type, FILE *stream);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function fopen opens a file. The name of the file to open is specified as a null-terminated string. It must be acceptable to the operating system as a file name.\par The second string, type, is used to determine the characteristics of the file to be opened. It consists of one of three flags, r, w or a. Each of these flags can be followed by a + character, which indicates that a file is to be opened for both input and output. Even if the file is open for both input and output, a call to fseek, rewind or fflush must appear between input calls and output calls. The meaning of the flags is:\par \par }\pard \qj\fi-1080\li1440\widctlpar\brdrt\brdrs\brdrw15 \brdrb\brdrs\brdrw15 \adjustright {flag\tab meaning\par }\pard \qj\fi-1080\li1440\widctlpar\adjustright {\par r\tab Open an existing file for input.\par w\tab Create a new file, or delete the contents of an existing one, for output.\par a\tab Create a new file, or append to an existing file, for output.\par r+\tab Open an existing file for input and output. The first record read/written will be at the start of the file.\par w+\tab Create a new file or delete the contents of an old file, opening it for input and output.\par a+\tab Create a new file, or append to an existing one, opening the file for input and output. The first value written will appear after all old entries in the file; reading without positioning the file mark will result in an end of file condition.\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v newline character}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v return key}}}{In addition, any of these flags may be followed by the character b. If the file does not exist, and the b flag is used, fopen will create a file with a BIN file type (a binary file); if the b flag is not used, the file type will be TXT (a text file). The other effect of the b flag is to change the way the \\n character is handled. The C language uses the \\n character to mark the end of a line, but not all computers use a \\n character to mark the end of a line in a file. There are a number of conventions, but the most common are to use the \\n character at the end of a line (e.g. UNIX), to use the \\r character at the end of a line (e.g. Apple\~II, Macintosh) or to use both characters (many MS-DOS programs do this). If you open a file without the b flag, the ORCA/C libraries do their best to hide this difference between the way lines are marked by C and the way they are marked in a file. The ORCA/C libraries automatically strip all \\n characters, replacing them with \\r characters on both input and output. If you use the b flag in fopen, the libraries do not change these characters.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v errno}}}{If the call to fopen completes without error, fopen returns a pointer to a file record. This pointer can then be supplied as the input to calls that require an open stream. If an error occurs, fopen returns a null pointer and stores an error code into errno.\par The function freopen is used to change the file associated with an existing stream. It starts by closing the file passed as a parameter, and then opens a new file using the same file buffer. If the open succeeds, freopen returns the original file buffer. If the open fails, freopen returns a null pointer and sets errno.\par ORCA/C does not impose any practical restrictions on the number of open files. So long as the operating system does not complain, ORCA/C can handle thousands of open files. For programs that will be ported to other machines, use the macro SYS_OPEN to determine the maximum number of files that can be open at one time.\par \par }\pard \qj\fi360\widctlpar\tx4320\adjustright {\f6\fs20 /* sample calls to fopen and freopen */\par FILE *myfile;\par \par myfile = fopen(fileName, "r");\tab /* open a file for input */\par myfile = fopen("out.cc", "w");\tab /* prepare to write to out.cc */\par myfile = fopen(fileName, "a");\tab /* place new info at the end */\par myfile = fopen(fileName, "wb");\tab /* open a binary output file */\par myfile = fopen(filename, "r+");\tab /* open a file for input & output */\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 fprintf}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 fprintf}}}{\b\fs28 \tab printf}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 printf}}}{\b\fs28 \tab sprintf}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 sprintf}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <stdio.h>\par int fprintf(FILE *stream, char *format, ...);\par int printf(char *format, ...);\par int sprintf(char *s, char *format, ...);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {These functions implement formatted output to a stream. They all process characters the same way; the difference is in where the characters are sent. In the case of fprintf, the characters can be sent to any stream open for output. The printf function writes characters to standard out. The sprintf function sends characters to a string, appending a terminating null character. In all cases, the number of characters written to the output device is returned if no error occurred, and EOF is returned if an error was detected. In the case of sprintf, the terminating null character is not included in the character count.\par The format string controls the characters that are sent to the output device. In the simplest case the characters in the format string are simply copied to the output device. The string may, however, have embedded conversion specifiers. These take the form of a % character followed by other information. In most cases, a conversion specifier requires a value to convert and write. In that case, the values are taken from the variable length parameter list that follows the format string. The number and type of parameters expected by the conversion specifiers must match exactly with the number and type of parameters specified, or a crash is likely.\par The general format for a conversion specifier is shown below. Most of the fields are optional; when this is true, it is noted in the text. The various fields are specified in the order given, with no intervening white space. Not all of the optional fields have any effect on a particular format specifier. In those cases, the field is still allowed, but is ignored.\par \par }\pard \qj\fi-1440\li1800\widctlpar\adjustright {%\tab All conversion specifiers start with the % character.\par \par -, 0, +, space, #\tab Zero or more of these flag characters follow the % character, in any order. The flag characters are described in detail below.\par \par unsigned int\tab An optional unsigned decimal constant specifies the minimum field width. This constant must not start with a zero, since the zero would be confused with the format flag. An asterisk can also be used for the minimum field width, in which case an integer parameter is used for the field width. If the number of characters needed to represent the value is greater than the field width, all of the characters are still printed. If the number of characters needed to represent the value is less that the minimum field width, extra characters are added to fill out the field. The character used can be a space or zero, and the extra characters can appear to the left or right of the value. These factors are under control of the flags.\par \par .unsigned int\tab The precision of the field is specified by a period and an unsigned decimal constant. In general, this represents the number of digits that will be used to represent a numeric value. Like the field width, the precision can be specified as an asterisk, in which case an integer is removed from the parameter list and used as the precision. See the descriptions of the individual conversion specifiers for the specific use of this value.\par \par h, l or L\tab This optional field is a size specifier. The h specifier indicates a short operand. It is valid with the d, o, u, x and X conversion specifiers, and is ignored for all other conversion specifiers. The l designator indicates that an integer value is long. It is valid with the d, o, u, x and X conversion specifiers, and is ignored for all other conversion specifiers. L is used with double-precision numbers to indicate double numbers. It is valid with the e, E, f, F, g and G conversion specifiers, and is ignored for all other conversion specifiers. The s and L designators are not needed by the formatter; they are included to make the format specifiers used here more compatible with those used by sscanf.\par \par conversion\tab The conversion specifier tells what type of variable is being formatted. This field is required. Each of the individual conversion operators is described below.\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\fi360\keepn\widctlpar\adjustright {The flag characters modify the normal operation of the format specifier.\par \par }\pard \qj\fi-1440\li1800\widctlpar\adjustright {-\tab If a formatted value is shorter than the minimum field width, it is normally right-justified in the field by adding characters to the left of the formatted value. If the - flag is used, the value is left-justified.\par \par 0\tab If a formatted value is shorter than the minimum field width, it is normally padded with space characters. If the 0 flag is used, the field is padded with zeros instead of spaces. The 0 pad character is only used when the output is right-justified.\par \par +\tab When a negative number is formatted, it is always preceded by a minus sign. This flag forces positive numbers to be preceded by a plus sign.\par \par space\tab When a negative number is formatted, it is always preceded by a minus sign. This flag forces positive values to be preceded by a space, lining up positive numbers with negative numbers of equal length.\par \par #\tab This flag modifies the standard output format for certain numeric conversions. The specific effects are described with the conversion specifiers.\par }\pard \qj\fi360\widctlpar\adjustright {\par One of the conversion operations shown below must appear as the last character of any conversion specifier.\par }\pard \qj\fi-1440\li1800\sb240\widctlpar\adjustright {d or i\tab }{\pard\plain \qj\fi-1440\li1800\sb240\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v integers\:formatting}}}{One argument is removed from the parameter list and written as a signed, decimal number. If the l flag is used, the argument should be of type long; otherwise, the value should be of type int.\par }\pard \qj\fi360\li1800\widctlpar\adjustright {If there is no precision specified, the sequence of digits created is as short as possible to represent the value. If a precision is specified, and the digit sequence is less than the precision, it is padded on the left with zeros to reach the specified number of digits. If the precision is zero and the value is zero, no value is printed. The default precision is one.\par The prefix is a - character is the argument is negative. For a positive argument, the prefix is + if a + flag is used, a space if the space flag is used, and there is no prefix if neither flag is used.\par The # flag is not used by the d conversion specifier.\par The i format specifier is identical to the d designator. It is included for compatibility with fscanf.\par }\pard \qj\fi-1440\li1800\widctlpar\adjustright {\par u\tab One argument is removed from the parameter list and written as an unsigned, decimal number. If the l flag is used, the argument should be of type unsigned long; otherwise, the value should be of type unsigned int.\par }\pard \qj\fi360\li1800\widctlpar\adjustright {If there is no precision specified, the sequence of digits created is as short as possible to represent the value. If a precision is specified, and the digit sequence is less than the precision, it is padded on the left with zeros to reach the specified number of digits. If the precision is zero and the value is zero, no value is printed. The default precision is one.\par The #, + and space flags are not used by the u conversion specifier.\par }\pard \qj\fi-1440\li1800\widctlpar\adjustright {\par o\tab One argument is removed from the parameter list and written as an unsigned, octal}{\pard\plain \qj\fi-1440\li1800\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v octal}}}{ number. If the l flag is used, the argument should be of type unsigned long; otherwise, the value should be of type unsigned int.\par }\pard \qj\fi360\li1800\widctlpar\adjustright {If there is no precision specified, the sequence of digits created is as short as possible to represent the value. If a precision is specified, and the digit sequence is less than the precision, it is padded on the left with zeros to reach the specified number of digits. If the precision is zero and the value is zero, no value is printed. The default precision is one.\par The + and space flags are not used by the o conversion specifier.\par If the # flag is used, the number is preceded with a leading zero.\par }\pard \qj\fi-1440\li1800\widctlpar\adjustright {\par x or X\tab One argument is removed from the parameter list and written as an unsigned, hexadecimal}{\pard\plain \qj\fi-1440\li1800\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v hexadecimal}}}{ number. If the l flag is used, the argument should be of type unsigned long; otherwise, the value should be of type unsigned int.\par }\pard \qj\fi360\li1800\widctlpar\adjustright {If there is no precision specified, the sequence of digits created is as short as possible to represent the value. If a precision is specified, and the digit sequence is less than the precision, it is padded on the left with zeros to reach the specified number of digits. If the precision is zero and the value is zero, no value is printed. The default precision is one.\par The + and space flags are not used by the x conversion specifier.\par If the # flag is used, the number is preceded by a leading 0x (for the x specifier) or 0X (for the X specifier).\par The x specifier causes the digits a through f and the x in the leading 0x (if present) to be written in lowercase, while the X specifier writes these as uppercase letters. This is the only difference between the two specifiers.\par }\pard \qj\fi-1440\li1800\widctlpar\adjustright {\par p\tab One pointer argument is removed from the parameter list and written as a pointer. The format used to write a pointer is implementation-defined; in ORCA/C, %p is completely equivalent to %lX.\par }\pard \qj\fi-1440\li1800\sb240\widctlpar\adjustright {c\tab }{\pard\plain \qj\fi-1440\li1800\sb240\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v characters\:formatting}}}{One argument is removed from the parameter list and written as a character. The argument should be of type unsigned or int.\par }\pard \qj\fi360\li1800\widctlpar\adjustright {If the value is not a valid ASCII character, it is still sent to the output device. What effect this has depends on the device. Unless you are familiar with the output device, and are deliberately using a character for some special effect, you should stick to characters with ordinal values from 0 to 127.\par The #, + and space flags are not used by the c conversion specifier.\par }\pard \qj\fi-1440\li1800\widctlpar\adjustright {\par s\tab }{\pard\plain \qj\fi-1440\li1800\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v strings\:formatting}}}{One argument is removed from the parameter list and written as a string. The argument should be of type char *, and should point to a null-terminated string.\par }\pard \qj\fi360\li1800\widctlpar\adjustright {If no precision is specified, all characters up to, but not including the terminating null character are written to the output stream. If a precision is specified, the number of characters written will be the smaller of the precision and the length of the string.\par The #, + and space flags are not used by the s conversion specifier.\par }\pard \qj\fi-1440\li1800\widctlpar\adjustright {\par b\tab One argument is removed from the parameter list and written as a string. The argument should be of type char *, and should point to a string with a length byte in the first character position.\par }\pard \qj\fi360\li1800\widctlpar\adjustright {If no precision is specified, all characters except the length byte are written to the output stream. Note that this gives one way of writing a null character to the output stream. If a precision is specified, the number of characters written will be the smaller of the precision and the length of the string, as specified by the length byte.\par This conversion specifier is not present in ANSI C.\par The #, + and space flags are not used by the s conversion specifier.\par }\pard \qj\fi-1440\li1800\widctlpar\adjustright {\par n\tab No characters are written to the output device. One argument is used from the parameter list; it must be of type int *. The number of characters that have been written up to this time by this formatting operation is saved to the specified location.\par \par f\tab }{\pard\plain \qj\fi-1440\li1800\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v floating-point\:formatting}}}{One argument is removed from the parameter list and written as a signed, floating-point number. The argument can be of type float, double, comp or extended.\par }\pard \qj\fi360\li1800\widctlpar\adjustright {If there is no precision specified, a precision of six is assumed. The number produced consists of at least one leading digit, but no more than are needed to represent the whole part of the number. This is followed by a decimal point and any fraction digits. The precision determines how many fraction digits are present.\par If the precision is zero, no fraction digits are written. The decimal point is also not written unless the # specifier is used.\par If the value cannot be represented accurately in the precision allowed, it is still written. The value is simply rounded to the closest value to the correct one.\par The prefix is a - character if the argument is negative. For a positive argument, the prefix is + if a + flag is used, a space if the space flag is used, and there is no prefix if neither flag is used.\par }\pard \qj\fi-1440\li1800\widctlpar\adjustright {\par e or E\tab One argument is removed from the parameter list and written as a signed, floating-point number. The argument can be of type float, double, comp or extended.\par }\pard \qj\fi360\li1800\widctlpar\adjustright {The value written is in exponential format. It consists of a leading digit of 1 through 9 (or 0 if the actual value is 0), followed by a decimal point and any remaining digits. This is followed by an exponent, which is an e (for the e specifier) or E (for the E specifier), followed by a plus or minus sign, and at least two exponent digits. If more than three digits are needed to express the exponent, then as few as possible are printed to represent the value.\par The precision specifies how many digits appear after the decimal point. If no precision is given, a precision of six is used. If the precision is zero, the decimal point and digits are omitted unless the # flag is present, in which case the decimal point is printed, but no digits follow the decimal point.\par The prefix is a - character if the argument is negative. For a positive argument, the prefix is + if a + flag is used, a space if the space flag is used, and there is no prefix if neither flag is used.\par }\pard \qj\fi-1440\li1800\widctlpar\adjustright {\par g or G\tab One argument is removed from the parameter list and written as a signed, floating-point number. The argument can be of type float, double, comp or extended.\par }\pard \qj\fi360\li1800\widctlpar\adjustright {The g specifier is used to print a value in either exponential or fraction format, depending on which size is more appropriate. If the exponent for the number is less than -3 or greater than or equal to the precision specified, the e format specifier is used. When this happens, the effect is as if the e specifier was used with a # flag and a precision one less than the precision given for the g specifier. If no precision is specified, a precision of six is assumed; a precision less than or equal to zero is converted to a precision of one.\par If the exponent value is greater than or equal to -3, and less than or equal to the precision, the number is formed using the rules for the f format specifier, with a precision equal to the specified precision less the value of the exponent, and again assuming that the # flag was used.\par If the # flag was specified for the g conversion specifier, the resulting number is the one sent to the output stream. If the # specifier is not present, any trailing fractional zeros are stripped from the number. If all of the fractional digits are zero, the decimal point is also removed.\par The prefix is a - character if the argument is negative. For a positive argument, the prefix is + if a + flag is used, a space if the space flag is used, and there is no prefix if neither flag is used.\par }\pard \qj\fi-1440\li1800\widctlpar\adjustright {\par %\tab The % specifier is used to write a % character to the output stream. No arguments are removed from the stack. Note that the minimum field width, the - justification character and the pad characters are still used with the % specifier. The precision specifier and all other flags have no effect.\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\fi360\keepn\widctlpar\tx4320\adjustright {\f6\fs20 printf("Hello, world.\\n");\par \par for (i = 0; i < 10; ++i)\par    printf("%d\\n", i);\par \par str = "Hello, world.";  /* NOTE: str is defined as char *str */\par for (i = 0; i < strlen(*str); ++i)\par    printf("%*s\\n", i, str);\par \par printf("x          sin(x)     cos(x)\\n");\par printf("-          ------     ------\\n");\par for (x = 0.0; x < pi; x += pi/10)\par }\pard \qj\fi360\widctlpar\tx4320\adjustright {\f6\fs20    printf("%10f %10f %10f\\n", x, sin(x), cos(x));\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 fputc}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 fputc}}}{\b\fs28 \tab putc}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 putc}}}{\b\fs28 \tab putchar}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 putchar}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <stdio.h>\par int fputc(char c, FILE *stream);\par int putc(char c, FILE *stream);\par int putchar(char c);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {These functions are used to write characters to an output stream. The function fputc and the macro putc do exactly the same thing:  the only difference is that fputc is implemented as a function, while putc is implemented as a macro. In each case, the character supplied as a parameter is written to the specified output stream and returned as the value of the function. If an error occurs during the write, EOF is returned instead of the character supplied as a parameter.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v standard output}}}{The function putchar works like an fputc(c,stdout), writing a character to standard out.\par \par }\pard \qj\fi360\widctlpar\tx4320\adjustright {\f6\fs20 /* write the printing ASCII characters to standard out */\par for (i = 32; i < 128; ++i)\par    putchar(i);\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 fputs}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 fputs}}}{\b\fs28 \tab puts}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 puts}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <stdio.h>\par int fputs(char *s, FILE *stream);\par int puts(char *s);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function fputs writes the characters in a null-terminated string to an output stream. The string is not followed by a line feed, although any line feed in the string is written. If the write is successful, zero is returned; otherwise, EOF is returned.\par The function puts is similar, but it writes the string to standard out. In addition, puts always writes a line feed character after writing the string.\par \par }\pard \qj\fi360\widctlpar\tx4320\adjustright {\f6\fs20 int main(void)\par \par \{\par puts("Hello, world.");\par \}\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 fread}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 fread}}}{\b\fs28 \par }{\par }{\f6 #include <stdio.h>\par size_t fread(void *ptr, size_t element_size, size_t count,\par              FILE *stream);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function fread reads characters from a stream, placing them in a memory location pointed to by ptr. The array should be at least count elements long, with each element element_size bytes long. The value returned is the actual number of elements read, which can be less than count if an error occurs (in which case zero is returned) or an end of file is found (in which case the number of items read before the end of file was encountered is returned). If either count or element_size is zero, no characters are read, and zero is returned.\par \par }\pard \qj\fi360\widctlpar\tx4320\adjustright {\f6\fs20 numItems = fread(array, sizeof(element), 40, myFile);\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 free}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 free}}}{\b\fs28 \par }{\par }{\f6 #include <stdlib.h>\par void free(void *ptr);\par void cfree(void *ptr);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function free is used to deallocate memory allocated using malloc, calloc or realloc. Once deallocated, the memory can be reused by subsequent calls to malloc or calloc. Memory allocated by malloc is allocated from the toolbox Memory Manager either as a single chunk of memory (for requests over 4K bytes), or as a smaller part of a 4K byte piece of memory. For large chunks of memory, free returns the memory to Apple's Memory Manager, allowing other programs and tools to use the memory. For smaller pieces of memory, free will only return the memory to Apple's Memory Manager if all of the individual pieces have been freed.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v cfree}}}{Older C libraries require memory allocated with calloc to be freed with a call to cfree, rather than free. In ANSI C, cfree has been deleted, and free is used to deallocate all memory. In ORCA/C, cfree has been retained as a macro that calls free for compatibility with old programs.\par }\pard \qj\fi360\keepn\widctlpar\adjustright {See also malloc.\par \par }{\f6\fs20 /* deallocate space for the array pointed to by aPtr */\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 free(aPtr);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 freopen\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See fopen.\par \par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 frexp}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 frexp}}}{\b\fs28 \tab ldexp}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 ldexp}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <math.h>\par extended frexp(extended x, int *nptr);\par extended ldexp(extended x, int n);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function frexp splits a floating-point number into a mantissa and exponent. The mantissa is returned as the result, and the exponent is saved to the integer pointed to by nptr. The mantissa will lie in the range 0.5 inclusive to 1.0 exclusive. The mantissa times 2 raised to the exponent will give the original argument x. If x is zero, n is set to zero and zero is returned.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ERANGE}}}{The function ldexp reverses the effect of frexp. The argument x is multiplied by 2 raised to the power n, and the result is returned. If an error occurs, errno is set to ERANGE.\par \par }{\f6\fs20 mantissa = frexp(val, &exponent);\par val = ldexp(mantissa, exponent);\par }{\par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 fscanf}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 fscanf}}}{\b\fs28 \tab scanf}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 scanf}}}{\b\fs28 \tab sscanf}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 sscanf}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <stdio.h>\par int fscanf(FILE *stream, char *format, ...);\par int scanf(char *format, ...);\par int sscanf(char *s, char *format, ...);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {These three functions are used to read formatted input. In each case, a format string controls the number of items read, what type they are, and several other characteristics. The only difference between the three functions is the source of the characters to format. The fscanf function reads characters from any stream that is open for input. The scanf function is similar, but always takes its characters from standard in. The sscanf function reads the characters from a null-terminated string.\par Each of the functions returns the number of successful scan operations. For example, if the function call is set up to read four integers, and all four are read successfully, the value four is returned. If an input/output error, end of file condition, or improper input data forces the read to stop early, only the number of successful scans is returned. If an end of file is encountered before any assignments are made, the functions return EOF. For the purpose of sscanf, the null terminator at the end of the string is treated as an end of file.\par The format string describes how many variables should be read, as well as several other characteristics about the input. It consists of three kinds of characters.\par \par }\pard \qj\fi-1440\li1800\widctlpar\adjustright {white space\tab If a white space character is found in the format string, the scanner skips to the next non-white space character. All white space characters are also read from the input stream. The effect, then, is that any white space in the format string causes all white space in the input stream to be skipped.\par \par conversions\tab Conversion specifiers start with a % character. The syntax for a conversion specifier is quite complex, so its format will be discussed later.\par \par other characters\tab Any other character must match a character read from the input stream. If the character in the format string does not match the character in the input stream, the scanner stops. The character that caused the mismatch is left in the input stream for the next input call.\par }\pard \qj\fi360\widctlpar\adjustright {\par There must be exactly one variable in the parameter list for each conversion specifier. (There is an exception to this rule; it will be discussed when the format is explained.)  The types of the format specifiers must match the type of the parameter exactly. The parameters are all pointers to a variable location; once a value is read by the scanner, it is stored at the location pointed to by the parameter.\par Each conversion specifier has the following fields, in the order listed. Some of the fields are optional; if so, this is mentioned in the text.\par \par }\pard \qj\fi-1440\li1800\widctlpar\adjustright {%\tab All conversion specifiers start with the % character.\par \par *\tab The asterisk is an assignment suppression flag. If present, it tells the scanner that it should read a value from the input stream, but that the value will not be saved. When the assignment suppression flag is used, a pointer is not removed from the variable parameter list.\par \par unsigned int\tab An optional unsigned decimal constant specifies the maximum field width. If this field is present, no more than the specified number of characters will be read from the input stream. It is possible, however, that fewer than the specified number of characters will be read. The field width must be greater than zero.\par \par h or l\tab This optional field is a size specifier. When used with an integer variable, h indicates that the variable is short, and l indicates that the variable is long. The l specifier can also be used with the floating-point types, where it indicates a double variable. The h and l specifiers are used with the d, u, o x or X format specifiers. In addition, the l specifier can be used with the f, e, E, g, or G floating-point specifiers. These specifiers are ignored when used with any other format specifier.\par \par conversion\tab The conversion specifier tells what type of variable is being read. This field is required. Each of the individual conversion operators is described below.\par }\pard \qj\fi360\widctlpar\adjustright {\par There are a variety of conversion specifiers used to describe the variable to be read. These are shown in the table below.\par \par }\pard \qj\fi-1440\li1800\widctlpar\adjustright {d\tab }{\pard\plain \qj\fi-1440\li1800\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v integers\:scanning}}}{A signed decimal value is read from the stream, converted to the internal format used by the 65816, and saved. The type of the pointer for this operation must be short * if the h size specifier is used, int * if no specifier is used, or long * if the l size specifier is used.\par }\pard \qj\fi360\li1800\widctlpar\adjustright {The scanner starts by skipping any white space characters in the input stream. These are not counted toward the maximum field width if one is specified. An optional sign is then allowed (+ or -). Next, the scanner expects zero or more decimal digits. Digits are read until a non-digit character is found, and end-of-file is encountered, or the maximum field width is reached. The digits read are then converted into a signed decimal integer and saved. If there are no digits, the resulting value is zero.\par The results are not predictable if an overflow occurs.\par }\pard \qj\fi-1440\li1800\widctlpar\adjustright {\par i\tab This format specifier is identical to the d format specifier, except that octal}{\pard\plain \qj\fi-1440\li1800\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v octal}}}{ and hexadecimal}{\pard\plain \qj\fi-1440\li1800\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v hexadecimal}}}{ numbers can be read. A number is considered to be octal if the first digit is a zero and the next character is not an x or X. A number is considered to be hexadecimal if the first two characters (after a leading sign) are 0x or 0X. Scanning of an octal number stops when a non-octal digit is found. Scanning of a hexadecimal number stops when a non-hexadecimal digit is found. The rules for converting the characters into a number are identical to those used by the compiler, but a trailing type marker is not allowed.\par \par u\tab An unsigned decimal value is read from the stream, converted to the internal format used by the 65816, and saved. The type of the pointer for this operation must be short * if the h size specifier is used, int * if no specifier is used, or long * if the l size specifier is used. Except for the fact that a leading sign is not allowed and the numbers are unsigned, this conversion specifier is identical to the d specifier used for signed decimal conversion.\par \par o\tab An unsigned octal}{\pard\plain \qj\fi-1440\li1800\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v octal}}}{ value is read from the stream, converted to the internal format used by the 65816, and saved. The type of the pointer for this operation must be short * if the h size specifier is used, int * if no specifier is used, or long * if the l size specifier is used. No leading sign is allowed, and only octal digits are scanned, but with those exceptions, scanning works exactly like scanning of a signed decimal integer with a format specifier of d.\par }\pard \qj\fi360\li1800\widctlpar\adjustright {While ORCA/C will stop scanning if an 8 or 9 is encountered in the input stream; the way these digits are handled is not consistent across all compilers.\par }\pard \qj\fi-1440\li1800\widctlpar\adjustright {\par x or X\tab An unsigned decimal value is read from the stream, converted to the internal format used by the 65816, and saved. The type of the pointer for this operation must be short * if the h size specifier is used, int * if no specifier is used, or long * if the l size specifier is used.\par }\pard \qj\fi360\li1800\widctlpar\adjustright {The scanner starts by skipping any white space characters in the input stream. These are not counted toward the maximum field width if one is specified. Next, the scanner expects zero or more hexadecimal}{\pard\plain \qj\fi360\li1800\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v hexadecimal}}}{ digits. Digits are read until a non-hexadecimal digit character is found or the maximum field width is reached. The digits read are then converted into an unsigned integer and saved.\par A leading 0x or 0X is allowed. If these characters appear, they are skipped; they do count toward the maximum field width.\par The x and X conversions are identical. Either conversion specifier will accept uppercase or lowercase hexadecimal digits.\par }\pard \qj\fi-1440\li1800\widctlpar\adjustright {\par p\tab A pointer is read from the source stream, converted to the internal format used by the 65816, and saved. Since the exact format of a pointer is implementation-defined, this conversion specifier should only be used to read pointers written with the %p conversion specifier with one of the print commands, like printf.\par \par c\tab }{\pard\plain \qj\fi-1440\li1800\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v characters\:scanning}}}{The pointer that is used from the variable list should be of type char *. If no field width is specified, exactly one character is read from the input stream and saved at the specified location. If an end of file condition exists, the conversion fails.\par }\pard \qj\fi360\li1800\widctlpar\adjustright {If a field width is specified, the pointer should point to an array of characters that can hold as many characters as the maximum field width. Unless an end of file condition occurs, characters are read and stored in the array until the entire field width has been read. No terminating null character is appended to the end of the array. The conversion operation fails, and no characters are saved, if an end of file is found before the entire field width has been processed.\par Note that leading white space characters are not skipped by this conversion.\par While a size specifier can be present, it is ignored.\par }\pard \qj\fi-1440\li1800\widctlpar\adjustright {\par s\tab }{\pard\plain \qj\fi-1440\li1800\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v strings\:scanning}}}{One pointer argument of type char * is used. A string is read from the stream and placed at the specified location.\par }\pard \qj\fi360\li1800\widctlpar\adjustright {The scanner starts by skipping any white space characters in the input stream. These are not counted toward the maximum field width if one is specified. Characters are read until an end of file is found, a white space character is found, or the maximum field width is reached (if one is specified). A null character is added to the end of the characters read. If an end of file is encountered before any non-white space characters have been found, the conversion operation fails.\par While a size specifier can be present, it is ignored.\par }\pard \qj\fi-1440\li1800\widctlpar\adjustright {\par b\tab The b format specifier works exactly like the s format specifier, except that a string with a leading length byte is saved. The string also has a null terminator. If the input string is longer than 255 characters, the resulting string will be n mod 256 characters long, where n is the actual number of characters read.\par }\pard \qj\fi360\li1800\widctlpar\adjustright {Note that this conversion specifier is not present in ANSI C. It is included in ORCA/C to make it easier to deal with p-strings, which are used extensively by the toolbox.\par }\pard \qj\fi-1440\li1800\widctlpar\adjustright {\par n\tab No input is read from the stream, and any size or field width specifier is ignored. One argument is used from the parameter list; it must be of type int *. The number of successful conversions that have been performed up to this time by the scan operation is saved to the specified location.\par \par f, e, E, g or G\tab }{\pard\plain \qj\fi-1440\li1800\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v floating-point\:scanning}}}{A signed decimal floating-point value is read from the stream, converted to the internal format used by the 65816, and saved. The type of the pointer for this operation must be float * if no specifier is used, or double * if the l size specifier is used.\par }\pard \qj\fi360\li1800\widctlpar\adjustright {The scanner starts by skipping any white space characters in the input stream. These are not counted toward the maximum field width if one is specified. The number itself consists of an optional leading sign, an optional digit sequence, an optional decimal point, another optional digit sequence, and an optional exponent. The exponent, if present, consists of the character e or E, an optional sign, and an optional digit sequence. If no digits appear before the exponent, the resulting value is zero. If no digits appear after the e or E character, the exponent value is zero. If the value is too large to represent, the result is an infinity with an appropriate sign. If the value is too small to represent, the result is zero. Note that the results of an overflow or underflow are not consistent across C compilers; other compilers may not return infinity or zero for overflow and underflow.\par All of these format specifiers are identical. They will all accept any form of floating-point value, with or without an exponent.\par }\pard \qj\fi-1440\li1800\widctlpar\adjustright {\par %\tab A single % character is expected in the input stream. The field with and size specifiers are ignored if present. No pointer is used from the parameter list.\par \par [...]\tab }{\pard\plain \qj\fi-1440\li1800\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v strings\:scanning}}}{A string is read from the input stream. A pointer of type char * is used from the parameter list; the characters read are stored at that location.\par }\pard \qj\fi360\li1800\widctlpar\adjustright {This specifier allows you to state exactly what characters are allowed in the input stream. Any characters appearing between the [ and ] characters are allowed; any other characters are not allowed, and cause the scanner to stop. The characters can be specified in any order, and duplicates are allowed.\par If the first character after the [ character is the ^ character, the meaning of the characters is reversed. In that case, the characters specified are not allowed in the input stream, and any characters not listed are accepted.\par Because of the syntax of the conversion specifier, it is not possible to specify a ^ character as the first character of a list of characters, nor is it possible to use the ] character in the list.\par Scanning continues until an end of file condition is reached, a character which is not in the allowed set of characters is found (in which case it remains unread), or, if a maximum field width is specified, the maximum number of characters have been read. The characters are stored at the location specified by the pointer in the parameter list, and a terminating null character is added to the characters.\par While a size specifier can be present, it is ignored.\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\tx4320\adjustright {\f6\fs20 /* echo a file of integers */\par while (fscanf(myFile, "%d", &i))\par    printf("%d\\n", i);\par \par /* echo white space delimited words from a file */\par while (fscanf(myFile, "%50s", str))\par    printf("%s\\n", str);\par \par /* read words consisting of characters from a file */\par while (fscanf(myFile, \par    "%50[abcdefghijklmnopqrstuvwxyz"\tab /* read a word */\par    "ABCDEFGHIJKLMNOPQRSTUVWXYZ]"\par    "%*[^abcdefghijklmnopqrstuvwxyz"\tab /* skip non-word chars */\par    "ABCDEFGHIJKLMNOPQRSTUVWXYZ]", str))\par    printf("%s\\n", str);\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 fseek}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 fseek}}}{\b\fs28 \tab rewind}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 rewind}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <stdio.h>\par int  fseek(FILE *stream, long offset, int wherefrom);\par void rewind(FILE *stream);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The fseek function is used to position the file pointer in a file. Stream is the file to position. Wherefrom is a code telling how to change the position. Three methods of changing the position are currently defined, and are shown in the table below. In ANSI C compilers, names are assigned for each of these codes; older compilers use the numeric values for the codes. Offset is the number of bytes to move by. If an end of file condition exists when this call is made, it is cleared. If an ungetc has been performed, its effects are ignored. The fseek function returns zero if the call is successful, and non-zero if an error occurs.\par \par }\pard \qj\fi-2160\li2520\keepn\widctlpar\brdrt\brdrs\brdrw15 \brdrb\brdrs\brdrw15 \tx1080\adjustright {code\tab name\tab meaning\par }\pard \qj\fi-2160\li2520\keepn\widctlpar\tx1080\adjustright {\par 0\tab SEEK_SET\tab Moves to offset bytes from the beginning of the file.\par }\pard \qj\fi-2160\li2520\widctlpar\tx1080\adjustright {\par 1\tab SEEK_CUR\tab Moves offset characters from the current file position. Offset can be a negative quantity, which causes the file mark to move toward the start of the file. If an attempt is made to move before the beginning of the file, the mark is set to the first byte in the file. If an attempt is made to move past the end of the file, random bytes are added to extend the length of the file.\par \par 2\tab SEEK_END\tab Moves offset bytes relative to the end of the file. As with SEEK_CUR, an attempt to move before the start of the file moves to the start of the file, and an attempt to move past the end of the file extends the file to the necessary length with random bytes.\par }\pard \qj\fi360\widctlpar\adjustright {\par The rewind function is a simple form of the fseek function. It is equivalent to a call to seek with an offset of zero and wherefrom set to SEEK_SET.\par See also ftell.\par \par }\pard \qj\fi360\widctlpar\tx4320\adjustright {\f6\fs20 /* read a record based on an index */\par fseek(myFile, index*sizeof(record), SEEK_SET);\par fread(record, sizeof(record), 1, myFile);\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 fsetpos\par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {See fgetpos.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 ftell}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 ftell}}}{\b\fs28 \par }{\par }{\f6 #include <stdio.h>\par long int ftell(FILE *stream);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The ftell function returns the current file mark for an open stream. In effect, this is the number of bytes between the start of the file and the next byte that will be read or written. It is generally used to record a position, with the result supplied to fseek at a later time.\par If an error occurs, ftell returns -1L and sets errno to the error number of the error detected.\par See also fseek.\par \par }\pard \qj\fi360\widctlpar\tx4320\adjustright {\f6\fs20 position = ftell(myFile);\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 fwrite}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 fwrite}}}{\b\fs28 \par }{\par }{\f6 #include <stdio.h>\par size_t fwrite(void *ptr, size_t element_size, size_t count,\par               FILE *stream);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function fwrite writes count elements of an array with elements element_size bytes long to the output stream, taking the values from memory starting at the location indicated by ptr. The function returns the actual number of array elements written, which will be less than count if an output error has occurred.\par \par }\pard \qj\fi360\widctlpar\tx4320\adjustright {\f6\fs20 fwrite(matrix, sizeof(float), 10*10, myFile);\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 getc\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See fgetc.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 getchar\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See fgetc.\par \par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 getenv}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 getenv}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <stdlib.h>\par char *getenv(const char *name)\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The getenv call returns a pointer to the value of a shell variable. If the shell variable has not been set, or if the program is executing from outside of the ORCA programming environment, where shell variables do not exist, a NULL value is returned.\par Note that the meaning of getenv varies from environment to environment. On other computers, getenv may return a value from a different source.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 gets\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See fgets.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 gmtime\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See localtime.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 isalnum}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 isalnum}}}{\b\fs28 \par }{\par }{\f6 #include <ctype.h>\par int isalnum(char c);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Isalnum is a macro that returns a non-zero value if the argument is an alphanumeric character, and zero if the argument is not an alphanumeric character. The argument must lie in the range -1 to 255, or the result is not valid. The alphanumeric characters are shown below.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 0 1 2 3 4 5 6 7 8 9\par a b c d e f g h i j k l m n o p q r s t u v w x y z\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\par }{\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 for (i = 0; i < 128; ++i)\par    if (isalnum(i))\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20       printf("%c is alphanumeric.\\n", i);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 isalpha}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 isalpha}}}{\b\fs28 \par }{\par }{\f6 #include <ctype.h>\par int isalpha(char c);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Isalpha is a macro that returns a non-zero value if the argument is an alphabetic character, and zero if it is not. The argument must lie in the range -1 to 255, or the result is not valid. The alphabetic characters are show below.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 a b c d e f g h i j k l m n o p q r s t u v w x y z\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\par }{\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 for (i = 0; i < 128; ++i)\par    if (isalpha(i))\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20       printf("%c is alphabetic.\\n", i);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 isascii}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 isascii}}}{\b\fs28 \par }{\par }{\f6 #include <ctype.h>\par int isascii(char c);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Isascii is a macro that returns a non-zero value if the argument's ordinal value is in the range 0 to 127, which is the range if the ASCII character set used on the Apple\~II}{\fs20 GS}{. It returns zero if the character is outside of the range of the ASCII character set.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 for (i = -500; i < 500; ++i)\par    if (isascii(i))\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20       printf("%d is the ordinal value of an ASCII character.\\n", i);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 iscntrl}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 iscntrl}}}{\b\fs28 \par }{\par }{\f6 #include <ctype.h>\par int iscntrl(char c);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Iscntrl is a macro that returns a non-zero value if the argument is a control character, and zero if it is not. The argument must lie in the range -1 to 255, or the result is not valid. The control characters are all those characters with an ordinal range of 0 to 31, plus the character whose ordinal value is 127.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 for (i = 0; i < 128; ++i)\par    if (iscntrl(i))\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20       printf("%d is the ordinal value of a control character.\\n", i);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 iscsym}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 iscsym}}}{\b\fs28 \par }{\par }{\f6 #include <ctype.h>\par int iscsym(char c);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {iscsym is a macro that returns a non-zero value if the argument is a character that can appear in a C identifier, and zero if it cannot. The argument must lie in the range -1 to 255, or the result is not valid. The characters which can appear in a C identifier are shown below.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 _\par 0 1 2 3 4 5 6 7 8 9\par a b c d e f g h i j k l m n o p q r s t u v w x y z\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\par }{\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 for (i = 0; i < 128; ++i)\par    if (iscsym(i))\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20       printf("%c can appear in a C symbol.\\n", i);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 iscsymf}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 iscsymf}}}{\b\fs28 \par }{\par }{\f6 #include <ctype.h>\par int iscsymf(char c);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Iscsymf is a macro that returns a non-zero value if the argument is a character that can appear as the first character of a C identifier, and zero if it cannot. The argument must lie in the range -1 to 255, or the result is not valid. The characters which can appear as the first character of a C identifier are shown below.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 _\par a b c d e f g h i j k l m n o p q r s t u v w x y z\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\par }{\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 for (i = 0; i < 128; ++i)\par    if (iscsymf(i))\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20       printf("%c can appear as the first character in a C symbol.\\n", i);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 isdigit}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 isdigit}}}{\b\fs28 \par }{\par }{\f6 #include <ctype.h>\par int isdigit(char c);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Isdigit is a macro that returns a non-zero value if the argument is one of the ten decimal digits, and zero if it is not. The argument must lie in the range -1 to 255, or the result is not valid. The ten decimal digits are shown below.\par \par }{\f6\fs20 0 1 2 3 4 5 6 7 8 9\par }{\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 for (i = 0; i < 128; ++i)\par    if (isdigit(i))\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20       printf("%c is a digit.\\n", i);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 isgraph}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 isgraph}}}{\b\fs28 \par }{\par }{\f6 #include <ctype.h>\par int isgraph(char c);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Isgraph is a macro that returns a non-zero value if the argument is one of the printing characters, other than a space. The argument must lie in the range -1 to 255, or the result is not valid. See isprint for a list of the printing characters.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 for (i = 0; i < 128; ++i)\par    if (isgraph(i))\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20       printf("%c is a graph character.\\n", i);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 islower}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 islower}}}{\b\fs28 \par }{\par }{\f6 #include <ctype.h>\par int islower(char c);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Islower is a macro that returns a non-zero value if the argument is one of the lowercase alphanumeric characters, and zero if it is not. The argument must lie in the range -1 to 255, or the result is not valid. The lowercase alphanumeric characters are shown below.\par \par }{\f6\fs20 a b c d e f g h i j k l m n o p q r s t u v w x y z\par }{\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 for (i = 0; i < 128; ++i)\par    if (islower(i))\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20       printf("%c is a lowercase character.\\n", i);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 isodigit}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 isodigit}}}{\b\fs28 \par }{\par }{\f6 #include <ctype.h>\par int isodigit(char c);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Isodigit is a macro that returns a non-zero value if the argument is one of the eight octal}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v octal}}}{ digits, and zero if it is not. The argument must lie in the range -1 to 255, or the result is not valid. The eight octal digits are shown below.\par \par }{\f6\fs20 0 1 2 3 4 5 6 7\par }{\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 for (i = 0; i < 128; ++i)\par    if (isodigit(i))\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20       printf("%c is an octal digit.\\n", i);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 isprint}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 isprint}}}{\b\fs28 \par }{\par }{\f6 #include <ctype.h>\par int isprint(char c);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Isprint is a macro that returns a non-zero value if the argument is one of the printing characters, and zero if it is not. The argument must lie in the range -1 to 255, or the result is not valid. The printing characters include the entire ASCII character set with the control characters removed. This includes all characters with an ordinal value of 32 to 126. The printing characters are shown below. Note that the first printing character is a space.\par }\pard \qj\fi360\sb240\keepn\widctlpar\adjustright {\f6\fs20   ! " # $ % & ' ( ) * + , - . /\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 0 1 2 3 4 5 6 7 8 9 : ; < = > ?\par @ A B C D E F G H I J K L M N O\par P Q R S T U V W X Y Z [ \\ ] ^ _\par ` a b c d e f g h i j k l m n o\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 p q r s t u v w x y z \{ | \} ~\par }{\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 for (i = 0; i < 128; ++i)\par    if (isprint(i))\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20       printf("%c is a printing character.\\n", i);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 ispunct}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 ispunct}}}{\b\fs28 \par }{\par }{\f6 #include <ctype.h>\par int ispunct(char c);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function ispunct is a macro that returns a non-zero value if the argument is one of the punctuation characters, and zero if it is not. The argument must lie in the range -1 to 255, or the result is not valid. The punctuation characters include the entire ASCII character set with the control characters and alphanumeric characters removed. This includes the space character, plus all of the characters shown below.\par \par }{\f6\fs20 ! " # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \\ ] ^ _ ` \{ | \} ~\par }{\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 for (i = 0; i < 128; ++i)\par    if (ispunct(i))\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20       printf("%c is a punctuation character.\\n", i);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 isspace}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 isspace}}}{\b\fs28 \par }{\par }{\f6 #include <ctype.h>\par int isspace(char c);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Isspace is a macro that returns a non-zero value if the argument is a white space character, and zero if it is not. The argument must lie in the range -1 to 255, or the result is not valid. The white space characters include the space, tab, carriage return, new line, vertical tab and form feed characters. These are the characters with ordinal values of 9 to 13 and 32.}{\f6\fs20 \par }{\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 for (i = 0; i < 128; ++i)\par    if (isspace(i))\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20       printf("%d is the ordinal value of a white space character.\\n", i);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 isupper}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 isupper}}}{\b\fs28 \par }{\par }{\f6 #include <ctype.h>\par int isupper(char c);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Isupper is a macro that returns a non-zero value if the argument is one of the uppercase alphanumeric characters, and zero if it is not. The argument must lie in the range -1 to 255, or the result is not valid. The uppercase alphanumeric characters are shown below.\par \par }{\f6\fs20 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 isxdigit}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 isxdigit}}}{\b\fs28 \par }{\par }{\f6 #include <ctype.h>\par int isxdigit(char c);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Isxdigit is a macro that returns a non-zero value if the argument is one of the sixteen hexadecimal}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v hexadecimal}}}{ digits, and zero if it is not. The argument must lie in the range -1 to 255, or the result is not valid. The sixteen hexadecimal digits are shown below.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 0 1 2 3 4 5 6 7 8 9\par a b c d e f\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 A B C D E F\par }{\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 for (i = 0; i < 128; ++i)\par    if (isxdigit(i))\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20       printf("%c is a hexadecimal digit.\\n", i);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 labs\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See abs.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 ldexp\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See frexp.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 ldiv\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See div.\par \par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 localtime}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 localtime}}}{\b\fs28 \tab gmtime}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 gmtime}}}{\b\fs28 \tab mktime}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 mktime}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <time.h>\par typedef unsigned long time_t;\par struct tm \{\par    int tm_sec;\tab /* seconds; 0 to 59 */\par    int tm_min;\tab /* minutes; 0 to 59 */\par    int tm_hour;\tab /* hours; 0 to 23 */\par    int tm_mday;\tab /* day of the month; 1 to 31 */\par    int tm_mon;\tab /* month; 0 to 11 */\par    int tm_year;\tab /* year; 0 == 1900 */\par    int tm_wday;\tab /* day of week; sun == 0 to sat == 6 */\par    int tm_yday;\tab /* day of year; 0 to 365 */\par    int tm_isdst;\tab /* daylight savings time?; a boolean value */\par    \}\par \par struct tm *localtime(time_t *t);\par struct tm *gmtime(time_t *t);\par time_t mktime(struct tm *tmptr);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The localtime function takes a time encoded as an unsigned long integer and returns a structure with the various time fields filled in. See the definition of the tm structure, above, for a description of the fields that are filled in. On the Apple\~II}{\fs20 GS}{ there is no way of telling if the current time is daylight savings time, so localtime always returns false (zero) for that field.\par The gmtime function is designed to return the time on the prime meridian, which runs through Greenwich England. This time is known as Greenwich Mean Time, or GMT. Since the Apple\~II}{\fs20 GS}{ does not have a way of knowing the difference between local time and GMT, the gmtime function returns the same values as localtime in ORCA/C.\par The mktime function takes a time structure as input and returns the time in the long integer format returned by the time function. As a side effect, it also recomputes the tm_wday and tm_yday fields based on the values of the other fields. It returns -1 if the call fails.\par See also time.\par \par }{\f6\fs20 curtime = time(NULL);\par t = *localtime(&curtime);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 log}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 log}}}{\b\fs28 \par }{\par }{\f6 #include <math.h>\par extended log(extended x);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ERANGE}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v EDOM}}}{The natural logarithm of the argument is returned. If the argument is negative, errno is set to EDOM. If the argument is zero or close to zero, a range error occurs and errno is set to ERANGE.\par \par }{\f6\fs20 res = log(x);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 log10}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 log10}}}{\b\fs28 \par }{\par }{\f6 #include <math.h>\par extended log10(extended x);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ERANGE}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v EDOM}}}{The base-10 logarithm of the argument is returned. If the argument is negative, errno is set to EDOM. If the argument is zero or close to zero, a range error occurs and errno is set to ERANGE.\par \par }{\f6\fs20 res = log10(x);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 longjmp\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See setjmp.\par \par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 lseek}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 lseek}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <fcntl.h>\par long lseek(int filds, long offset, int whence);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Repositions the file pointer, so that the next read or write occurs from a new position. The position is specified by offset. }{\i whence}{ indicates one of the following:\par \par }\pard \qj\fi-360\li720\widctlpar\adjustright {0\tab The file pointer is set to offset bytes from the start of the file.\par 1\tab The file pointer is set to the current position plus offset bytes.\par 2\tab The file pointer is set to offset bytes from the end of the file.\par }\pard \qj\fi360\widctlpar\adjustright {\par If the call is successful, the function returns 0; otherwise, a -1 is returned and errno is set as indicated in the list below.\par While this function is a common one in C libraries, it is not required by the ANSI C standard, and should be avoided if possible.\par See also fseek.\par }\pard \qj\li360\sb240\keepn\widctlpar\tx2160\adjustright {\ul Possible errors\par }\pard \qj\li360\keepn\widctlpar\tx2160\adjustright {\par EBADF\tab Old is not a valid file descriptor.\par }\pard \qj\li360\widctlpar\tx2160\adjustright {EINVAL\tab whence is not 0, 1 or 2.\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 malloc}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 malloc}}}{\b\fs28 \tab calloc}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 calloc}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <stdlib.h>\par void *malloc(size_t size);\par void *mlalloc(size_t size);\par void *calloc(size_t count, size_t size);\par void *clalloc(size_t count, size_t size);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function malloc allocates size bytes of memory and returns a pointer to the first byte of that memory. If there is not enough free memory to satisfy the request, or if the size is zero, malloc returns NULL.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v memory manager}}}{On the Apple\~II}{\fs20 GS}{, memory is allocated through Apple's Memory Manager. If you ask for more than 4096 bytes of memory, the memory will be requested from the Memory Manager in a single chunk. There is no guarantee that the memory will not cross a bank boundary. While special memory is only used if all other memory has already been allocated, there is also no guarantee that the memory will not be special memory. (Special memory consists of memory from banks 0, 1, 0xE0, and 0xE1. This memory is used for special purposes on the Apple\~II}{\fs20 GS}{.)  If a call to malloc is made asking for less than 4096 bytes of memory, 4096 bytes are still allocated from the Memory Manager. This memory is then subdivided by the compiler's run-time memory manager to satisfy other requests for small amounts of memory, taking a burden off of the toolbox's Memory Manager.\par The calloc function accepts two parameters, a count and a size. Enough memory is allocated to hold count elements of size }{\i size}{, using the same mechanism for allocating memory as is used by malloc. All of the allocated memory is then set to zero.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v mlalloc}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v clalloc}}}{Older C libraries often restrict malloc and calloc to a parameter of size unsigned, which would limit these functions to allocating 64K bytes of memory at a time. ANSI C requires parameters of type unsigned long, and eliminates mlalloc, which is used in older compilers when more than 64K bytes of memory is needed. ORCA/C still includes mlalloc as a macro which calls malloc, but its use should be avoided in new programs. The function clalloc was provided for similar reasons; again, clalloc is a macro in ORCA/C; it calls calloc.\par See also free, realloc.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 /* allocate space for the array pointed to by aPtr */\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 aPtr = malloc(sizeof(*aPtr));\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 memchr}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 memchr}}}{\b\fs28 \par }{\par }{\f6 #include <string.h>\par void *memchr(const void *ptr, int val, size_t len);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function memchr searches for a byte with the value val starting at the location pointed to by ptr for a maximum of len bytes. If a matching byte is found, a pointer to that byte is returned. If a matching byte is not found, a null pointer is returned.\par See also strchr. Unlike strchr, memchr does not stop if a zero value is found.\par \par }{\f6\fs20 /* skip to the next line in a TXT file */\par file = ((char *) memchr(file, '\\r', 255))+1;\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 memcmp}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 memcmp}}}{\b\fs28 \par }{\par }{\f6 #include <string.h>\par int memcmp(void *ptr1, void *ptr2, size_t len);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function memcmp compares two areas of memory, one starting at ptr1, and the other starting at ptr2, for a length of len bytes. If all bytes match, memcmp returns zero. If a byte is found that does not match, a negative number is returned if the byte pointed to by ptr1 is less than the byte pointed to by ptr2, and a positive value is returned otherwise.\par See also strcmp. Unlike strcmp, memcmp does not stop if null characters are found.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 /* see if two files loaded into memory are equal */\par if (memcmp(file1, file2, fileLen) == 0)\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20    printf("The files are equal.\\n");\par }{\par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 memcpy}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 memcpy}}}{\b\fs28 \tab memmove}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 memmove}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <string.h>\par void *memcpy(const void *dest, void *src, size_t len);\par void *memmove(void *dest, const void *src, size_t len);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function memcpy copies len bytes from the location starting at src to the location starting at dest. It returns the value of src. If the memory areas overlap, the results are unpredictable. The function memmove is similar, but is guaranteed to work if the memory areas overlap. Regardless of the location of the memory areas, memmove will produce a faithful copy of the original memory area at the destination.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 /* initialize a doubly-subscripted array row-by-row */\par for (i = 0; i < maxCol; ++i)\par    a[0][i] = 1.0;\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 for (i = 1; i < maxRow, ++i)\par    memcpy(a[i], a[0], sizeof(a[0]));\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 memmove\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See memcpy.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 memset}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 memset}}}{\b\fs28 \par }{\par }{\f6 #include <string.h>\par void *memset(const void *ptr, int val, size_t len);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function memset copies the value val into an area len bytes long, starting at ptr. It returns the value of ptr.\par \par }{\f6\fs20 /* clear a large array */\par memset(array, 0, sizeof(array));\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 mktime\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See localtime.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 mlalloc\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See malloc.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 modf}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 modf}}}{\b\fs28 \par }{\par }{\f6 #include <math.h>\par extended modf(extended x, int *nptr);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function modf returns the fraction part of the argument x. As a side effect, the integer part is placed in the location pointed to by nptr. The fraction part and integer part will have the same sign.\par See also fmod.\par \par }{\f6\fs20 res = modf(x, &i);\par }{\par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 offsetof}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 offsetof}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <stddef.h>\par size_t offsetof(type, member);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The offsetof macro returns the position of a structure member within a structure. The first input is a struct type. It must be defined in such a way that the expression\par \par }{\f6\fs20 &(type *)\par }{\par }\pard \qj\widctlpar\adjustright {is legal; for example, any type defined like this:\par }\pard \qj\fi360\widctlpar\adjustright {\par }{\f6\fs20 typedef struct type \{...\} type;\par }{\par }\pard \qj\widctlpar\adjustright {will work. The second parameter is the name of a variable in the structure. The value returned is the number of bytes that occur before the member in the structure.\par \par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 open}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 open}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <fcntl.h>\par int open(char *path, int oflag);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Creates a new file or opens an existing one for output.\par The }{\i oflag}{ parameter is formed by oring one or more of the following flags.\par \par }\pard \qj\fi-1440\li1800\widctlpar\adjustright {O_RDONLY\tab Open for read only.\par O_WRONLY\tab Open for write only.\par O_RDWR \tab Open for both reading and writing.\par O_NDELAY\tab Not used on the Apple\~II}{\fs20 GS}{. Included for UNIX compatibility.\par O_APPEND \tab If this flag is set, the file pointer is advanced to the end of the file before every write operation.\par O_CREAT\tab If the file does not exists, one is created.\par O_TRUNC\tab If the file exists, the length is set to 0 after opening the file.\par O_EXCL\tab If O_EXCL and O_CREAT are both set and the file exists, the call fails.\par O_BINARY\tab The file opened is a binary (BIN) file, rather than the default text (TXT) file. For text files, \\n characters are translated to \\r characters on output, and \\r characters are translated to \\n characters on input, conforming to Apple\~II}{\fs20 GS}{ conventions. For binary files, no such conversion is performed.\par \par \tab This flag is unique to the Apple\~II}{\fs20 GS}{.\par }\pard \qj\fi360\widctlpar\adjustright {\par If the call is successful, the function returns 0; otherwise, a -1 is returned and errno is set as indicated in the list below.\par \par }\pard \qj\li360\widctlpar\adjustright {\ul Possible errors\par }{\par EACCES\tab An I/O error or invalid pathname prevented opening of the file.\par EEXIST\tab O_CREAT and O_EXCL are set, and the file exists.\par EMFILE\tab OPEN_MAX files are already open.\par ENOENT\tab O_CREAT is not set and the file does not exist.\par ENOENT\tab The pathname is null.\par }\pard \qj\fi360\widctlpar\adjustright {\par While this function is a common one in C libraries, it is not required by the ANSI C standard, and should be avoided if possible.\par See also fopen.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 p2cstr\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {See c2pstr.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 pow}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 pow}}}{\b\fs28 \par }{\par }{\f6 #include <math.h>\par extended pow(extended x, extended y);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ERANGE}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v EDOM}}}{The argument x is raised to the power of the argument y, and the result is returned. If x is not zero, but y is zero, 1.0 is returned. If x is zero and y is positive, 0.0 is returned. Domain errors will occur if x is negative and y is not an integer, or if x is zero and y is zero or negative. In these cases, errno is set to EDOM. Range errors can also occur; in these cases, errno is set to ERANGE.\par \par }{\f6\fs20 cube = pow(num, 3.0);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 putc\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See fputc.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 putchar\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See fputc.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 puts\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See fputs.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 qsort}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 qsort}}}{\b\fs28 \par }{\par }{\f6 #include <stdlib.h>\par void qsort(void *base, size_t count, size_t size, \par            int (*compar)(const void *ptr1, const void *ptr2));\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The qsort function sorts an array. The array has count elements, each of which is size bytes long. The base parameter points to the first element of the array. The function compar is supplied by the program; it accepts two pointers as arguments, each of which points to an element of the array, and returns an integer as a result. The value returned is 0 if the first element is the same as the second, -1 if the first element is less than the second, and 1 if the first element is greater than the second. After the call, the array will be sorted in ascending order.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 int CompareZip(address *addr1, address *addr2)\par \par \{\par if (addr1->zip == addr2.zip)\par    return 0;\par if (addr1->zip < addr2.zip)\par    return -1;\par return 1;\par \}\par \par ...\par /* sort the addresses by zip code */\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 qsort(addressList, listSize, sizeof(address), CompareZip);\par }{\par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 raise}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 raise}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <signal.h>\par int raise(int sig);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The raise function generates a signal that will be handled by the signal handler. See signal for a way to install a signal handler and a description of signals.\par The function returns 0 if the sig parameter is valid, and 1 if it is not. If the signal is not valid, errno is also set to ERANGE.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 rand}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 rand}}}{\b\fs28 \tab srand}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 srand}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <stdlib.h>\par #define RAND_MAX 32767\par int  rand(void);\par void srand(int seed);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function srand is used to initialize a pseudo-random number generator. Subsequent calls to rand will return integers in the range 0 to RAND_MAX.\par Choosing a seed value is very important. If the same seed is used each time a program is executed, the program will always return the same pseudo-random number sequence. The seed should be chosen in such a way that it will be fairly random itself. One way of choosing a seed that works in most situations is to use the seconds in the current time of day.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 time_t t;\par struct tm trec;\par \par t = time(NULL);\par trec = *localtime(&t);\par srand(trec.tm_sec);\par for (i = 0; i < 100; ++i)\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20    printf("%8d", rand());\par }{\par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 read}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 read}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <fcntl.h>\par int read(int filds, void *buf, int n);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Up to }{\i n}{ bytes are read from the file whose file ID is }{\i filds}{. The bytes are placed in the buffer pointed to by }{\i buf}{.\par If an error occurs during reading, the function returns -1 and sets errno as indicated in the table below. If the file is already at the end of file mark, a zero is returned, but no error is set. If there are }{\i n}{ or more bytes left in the file, }{\i n}{ bytes are read, and }{\i n}{ is returned; the file pointer is advanced }{\i n}{ bytes. If there are less than }{\i n}{ bytes left in the file, the number of bytes remaining in the file are read, and this number is returned; the file pointer is then advanced to the end of the file.\par If the O_BINARY flag was not set when the file was opened, any \\r characters are converted to \\n characters as they are read.\par \par }{\ul Possible errors\par }{\par }\pard \qj\fi360\widctlpar\tx2160\adjustright {EIO\tab A physical I/O error occurred.\par EBADF\tab filds is not a valid file ID.\par EBADF\tab The file is not open for reading.\par }\pard \qj\fi360\widctlpar\adjustright {\par While this function is a common one in C libraries, it is not required by the ANSI C standard, and should be avoided if possible.\par See also fread.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 realloc}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 realloc}}}{\b\fs28 \par }{\par }{\f6 #include <stdlib.h>\par void *realloc(char *ptr, size_t size);\par void *relalloc(char *ptr, size_t size);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v relalloc}}}{The function realloc takes a pointer to a piece of memory allocated previously by malloc or calloc and changes the size of the memory. If the memory area shrinks, the deleted bytes are no longer available, although the memory not deleted is not disturbed. If the memory area grows, the old contents are preserved, but the value of the new bytes is unpredictable. A pointer is returned if the request is successful; the memory area may have been moved, so old copies of the pointer are no longer useful. If the request cannot be satisfied, a null pointer is returned, and the old memory area is not disturbed.\par If a null pointer is passed to realloc, the function behaves as if malloc had been called. If the pointer is not null, and the size is zero, the memory is deallocated and NULL is returned.\par In older C compilers, realloc was limited to a parameter of size unsigned, and another function called relalloc was used for requests for larger memory. In ANSI C, relalloc does not exist, and realloc can be used to request any amount of memory. ORCA/C includes relalloc as a macro equivalent of realloc for compatibility with older programs.\par See also free, malloc.\par }\pard \qj\fi360\sb240\keepn\widctlpar\adjustright {\f6\fs20 /* Bytes are obtained from InByte, buffered until no   */\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 /* more memory is available, and processed by DoIt.   */\par length = 0;\par size = remaining = growSize;\par ptr = start = malloc(growSize);\par if (ptr == NULL)\par    printf("Insufficient memory.\\n");\par else \{\par    ptr++ = InByte();\par    length++;\par    if (--remaining == 0) \{\par       size += growSize;\par       ptr = realloc(start, size);\par       if (ptr == NULL) \{\par          DoIt(start, length);\par          free(start);\par          length = 0;\par          size = remaining = growSize;\par          ptr = start = malloc(growSize);\par          \}\par       else \{\par          start = ptr;\par          ptr += length;\par          \}\par       \}\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20    \}\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 remove}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 remove}}}{\b\fs28 \par }{\par }{\f6 #include <stdio.h>\par int remove(char *filename);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The named file is deleted from the disk. The file name can be any file name or path name. A zero is returned if the delete is successful, and a non-zero is returned if the delete is not successful.\par \par }\pard \qj\fi360\widctlpar\tx4320\adjustright {\f6\fs20 remove("/hd/languages/apwc");\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 rename}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 rename}}}{\b\fs28 \par }{\par }{\f6 #include <stdio.h>\par int rename(char *oldname, char *newname);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The file with the name represented by the string oldname is renamed. The file names can be any file name or path name. After the rename call, the name of the file is the name given by newname. If the rename is successful, the function returns a zero; otherwise, a non-zero value is returned.\par The rename function is implemented by calling the GS/OS rename facility. Because of this, rename is more powerful under ORCA/C than it is under some other C implementations. This call can be used to move a file from one directory to another by specifying the path names of the old and new files.\par \par }\pard \qj\fi360\keepn\widctlpar\tx4320\adjustright {\f6\fs20 /* change a n file name */\par rename("myfile", "hisfile");\par \par /* move a file */\par }\pard \qj\fi360\widctlpar\tx4320\adjustright {\f6\fs20 rename("/hd/system/finder", "/hd/utilities/finder");\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 rewind\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See fseek.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 scanf\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See fscanf.\par \par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 setbuf}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 setbuf}}}{\b\fs28 \tab setvbuf}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 setvbuf}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <stdio.h>\par void setbuf(FILE *stream, char *buf);\par int setvbuf(FILE *stream, char *buf, int type, size_t size);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function setvbuf is used to change the size and characteristics of the default file buffer. By default, when fopen opens a file, the file has a BUFSIZ (1024) byte buffer used to collect characters to avoid the overhead of calls to the operating system for small read/write requests. The file is fully buffered, which means that, barring intervention with a call to fflush or fclose, 1024 bytes are collected before data is written to the disk, and 1024 bytes are read from disk to satisfy any read request.\par When setvbuf is called, the first parameter is a pointer to an open stream. This stream must already be open, but no input or output calls are allowed before the call to setvbuf. The buf parameter is a pointer to a character buffer to use as the file buffer. If buf is a null pointer, setvbuf will allocate a buffer from available memory; if buf is not null, it should be at least size bytes long. Size is the number of bytes to use for a buffer, while type is the type of buffering to use. There are three buffering types, designated using macros defined in the stdio.h interface files. These are:\par \par }\pard \qj\fi-1080\li1440\keepn\widctlpar\brdrt\brdrs\brdrw15 \brdrb\brdrs\brdrw15 \adjustright {type\tab meaning\par }\pard \qj\fi-1080\li1440\keepn\widctlpar\adjustright {\par _IOFBF\tab Full buffering. A buffer of size bytes is collected before output operations, and a buffer of size bytes is read for any read operation. This is the default buffering mechanism.\par }\pard \qj\fi-1080\li1440\widctlpar\adjustright {\par }\pard \qj\fi-1080\li1440\keepn\widctlpar\adjustright {_IOLBF\tab Line buffering. On output, the buffer is flushed any time a new line character is written to the buffer, or when the buffer is full.\par }\pard \qj\fi-1080\li1440\widctlpar\adjustright {\par }\pard \qj\fi-1080\li1440\keepn\widctlpar\adjustright {_IONBF\tab No buffering. All output passes directly to the operating system, and all input is satisfied with direct calls to the operating system.\par }\pard \qj\fi360\widctlpar\adjustright {\par The function setbuf is a simplified form of setvbuf. If the buf is a null pointer, no file buffering is used. If the buf pointer is not null, full buffering is used, and a pointer to a buffer of BUFSIZ bytes long is required as the input.\par \par }\pard \qj\fi360\widctlpar\tx4320\adjustright {\f6\fs20 /* Use line buffering, using line as a buffer 255 characters */\par /* long.                                                    */\par setvbuf(myFile, line, _IOLBF, 255);\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 setjmp}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 setjmp}}}{\b\fs28 \tab longjmp}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 longjmp}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <setjmp.h>\par typedef int jmp_buf[4];\par \par void longjmp(jmp_buf env, int status);\par int  setjmp(jmp_buf env);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The setjmp and longjmp functions are used to transfer control to a previous point in the program. The setjmp function is used to establish a jump location in the program. A jump buffer is passed; this jump buffer is later used by longjmp. The setjmp function returns a value of zero.\par Later, a call is made to longjmp, and the jump buffer and an integer are passed as parameters. The call can be made from the function that called setjmp, or from any function it called or that was called by a function it called (and so on), but longjmp must not be used from a function that called setjmp. Control it returned as if setjmp was call. The call to setjmp is not actually made; instead, a return is simulated. The stack is cleaned up, including disposing of the space used by any local auto variables. The value passed to longjmp as a status, which must be non-zero, is returned as the return value of setjmp. As far as the function that called setjmp in the first place can tell, setjmp has simply returned with a non-zero value.\par If longjmp is called with an invalid buffer or the function containing the setjmp call returns before the longjmp call is made, the results are unpredictable.\par \par }\pard \qj\fi360\keepn\widctlpar\tx4320\adjustright {\f6\fs20 jmp_buf buffer;\par \par void test(void)\par \par \{\par printf("In test.\\n");\par longjmp(buffer, 1);\par printf("This line will not be executed.\\n");\par }\pard \qj\fi360\widctlpar\tx4320\adjustright {\f6\fs20 \}\par \par }\pard \qj\fi360\keepn\widctlpar\tx4320\adjustright {\f6\fs20 int main(void)\par \par \{\par if (setjmp(buffer))\par    printf("Returned from jump.\\n");\par else \{\par    printf("Setting up the jump.\\n");\par    test();\par    \}\par }\pard \qj\fi360\widctlpar\tx4320\adjustright {\f6\fs20 \}\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 signal}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 signal}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <signal.h>\par void (*signal(int sig, void(*func)(int)))(int);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Signals are used to handle asynchronous interrupts. They are primarily used on multi-tasking systems, where another executing program or some hardware facility can cause an interrupt. In that sort of environment, signals can be used to inform the program what has happened. Signals are not used on the Apple\~II}{\fs20 GS}{; the signal.h library is included solely to aid in porting programs from multi-tasking environments.\par The signal function is used to specify how the various signals should be handled. The first parameter tells the signal handler which of the various signals you are talking about. ORCA/C supports the standard signals required by the ANSI standard. They are:\par \par }\pard \qj\fi360\keepn\widctlpar\tx1800\adjustright {SIGABRT\tab Abnormal termination.\par SIGFPE\tab Arithmetic errors.\par SIGILL\tab Invalid function image.\par SIGINT\tab Interactive attention signal.\par SIGSEGV\tab Invalid memory access.\par }\pard \qj\fi360\widctlpar\tx1800\adjustright {SIGTERM\tab Termination request sent to the program.\par }\pard \qj\fi360\widctlpar\adjustright {\par None of these errors apply to the Apple\~II}{\fs20 GS}{, and the ANSI standard does not require any of them to be handled. The SIGILL and SIGSEGV errors simply don't exist on the Apple\~II}{\fs20 GS}{. Abnormal terminations on the Apple\~II}{\fs20 GS}{ are severe enough that attempting to execute a function after one occurs would be foolish; it could damage data on a disk, for example. The other signals either have no direct counterpart on the Apple\~II}{\fs20 GS}{, or are handled by the Apple\~II}{\fs20 GS}{ toolbox, which is not always active.\par The second parameter to signal is either SIG_DFL, SIG_IGN, or a function. SIG_DFL tells the signal handler to use default handling, while SIG_IGN tells the signal handler to ignore the signal. With ORCA/C, these are the same, since the default handling is to ignore a signal. If you pass a function, the function will be called whenever the raise function is called to raise a signal. The signal number (e.g., SIGABRT) is passed to your function.\par The signal function returns the value of the previous signal handler, which you can save, and then restore later. If the }{\i sig}{ parameter is not one of the signals listed above, signal returns SIG_ERR and sets errno to ERANGE.\par See raise for a way to create a signal.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 sin}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 sin}}}{\b\fs28 \par }{\par }{\f6 #include <math.h>\par extended sin(extended x);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The sin function returns the trigonometric sine of the argument. The argument must be supplied in radians.\par \par }{\f6\fs20 height = sin(x)*hypotenuse;\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 sinh}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 sinh}}}{\b\fs28 \par }{\par }{\f6 #include <math.h>\par extended sinh(extended x);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ERANGE}}}{The sinh function returns the hyperbolic sine of the argument. If an error occurs, errno is set to ERANGE.\par \par }{\f6\fs20 n = sinh(x);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 sqrt}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 sqrt}}}{\b\fs28 \par }{\par }{\f6 #include <math.h>\par extended sqrt(extended x);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ERANGE}}}{The square root of the argument is returned. If the argument is negative, errno is set to ERANGE.\par \par }{\f6\fs20 length = sqrt(x*x + y*y);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 srand\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See rand.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 sscanf\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See fscanf.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 stderr\par }{\par }\pard \qj\fi360\widctlpar\tx4320\adjustright {See stdin.\par \par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 stdin}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 stdin}}}{\b\fs28 \tab stdout}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 stdout}}}{\b\fs28 \tab stderr}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 stderr}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <stdio.h>\par extern FILE *stderr;\par extern FILE *stdin;\par extern FILE *stdout;\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\tx4320\adjustright {These three predefined variables are the standard input stream (stdin), the standard output stream (stdout), and the error output stream (stderr). They are already open when any C program that runs under the shell is executing. In C programs that do not run under the shell, your program should open them using freopen before using any of these streams explicitly, or before using any of the file input and output facilities that automatically use one of these streams.\par When running under the shell, the shell will automatically handle any input or output redirection. If no redirection has been specified, input will come from the keyboard, and both standard out and error out will appear on the text screen (text environment) or the shell window (desktop environment).\par \par }\pard \qj\fi360\keepn\widctlpar\tx4320\adjustright {\f6\fs20 /* use the GS/OS console driver for standard out */\par }\pard \qj\fi360\widctlpar\tx4320\adjustright {\f6\fs20 freopen(".CONSOLE", "w", stdout);\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 stdout\par }{\par }\pard \qj\fi360\widctlpar\tx4320\adjustright {See stdin.\par \par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 strcat}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 strcat}}}{\b\fs28 \tab strncat}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 strncat}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <string.h>\par char *strcat(char *s1, char *s2);\par char *strncat(char *s1, char *s2, size_t n);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Strcat is a function that appends the contents of the string s2 to the contents of the string s1. A terminating null character is added to the end of the new string. Strcat returns a pointer to the first character in the string s1.\par Strcat will append characters until a terminating null is found in the string s2, even if the memory allocated for s1 is not large enough to hold the completed string. It is up to the programmer to ensure that the memory allocated for s1 is large enough to hold the concatenated string and the terminating null character.\par Strncat is a similar function that limits the total number of characters that can be copied. No more than n characters will be appended to the end of s1. If a terminating null character is found in s2 before n characters have been copied, all of the characters in s2, including the terminating null character, are copied to s1. If n characters are copied, and no terminating null character has been found, strncat adds a terminating null character to s1 and stops copying characters. If n is less than or equal to zero, no characters are copied.\par The result is unpredictable if the two strings overlap in memory.\par \par }{\f6\fs20 strcat(fileName, ".obj");\tab /* add .obj to a file name */\par \par n = 64-strlen(pathName);\tab /* add a file name to a path name,    */\par strncat(pathName, "/", n--);\tab /* making sure there are no overflows */\par strncat(pathName, fileName, n);\par }{\par }\pard \qj\keepn\widctlpar\tx1440\tx2880\tx4320\adjustright {\b\fs28 strchr}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\tx4320\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 strchr}}}{\b\fs28 \tab strpos}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\tx4320\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 strpos}}}{\b\fs28 \tab strrchr}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\tx4320\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 strrchr}}}{\b\fs28 \tab strrpos}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\tx4320\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 strrpos}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <string.h>\par char *strchr(char *s1, char c);\par int   strpos(const char *s1, int c);\par char *strrchr(char *s1, char c);\par int   strrpos(const char *s1, int c);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {These functions scan a null-terminated string for a character. Strchr and strrchr return a pointer to the character if it is found. A null pointer is returned if the character is not found. The null character is considered to be a character for the purposes of the scan, so searching for the null character will return a pointer to the terminating null. The difference between the two functions is that strchr returns a pointer to the first character that matches, while strrchr returns a pointer to the last matching character.\par The function strpos returns the position of the first matching character in the string. The position is the number of characters that appear before the matching character. If no matching character is found, -1 is returned.\par The function strrpos returns the position of the last matching character. Like strpos, it returns -1 if there are no matches.\par See also memchr.\par \par }{\f6\fs20 nextSpace = strchr(str, ' ');\tab /* find the next space */\par \par lineLen = strpos(line, '.');\tab /* find the # of chars in the sentence */\par }{\par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 strcmp}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 strcmp}}}{\b\fs28 \tab strncmp}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 strncmp}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <string.h>\par int strcmp(char *s1, char *s2);\par int strncmp(char *s1, char *s2, size_t n);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Strcmp compares two null-terminated strings. The strings are considered equal if all of the characters up to and including the terminating null character in each string matches. The string s1 is less than the string s2 if the ordinal value of the first mismatched character is smaller in s1, or if both strings match up to the terminating null character in s1, but s2 is longer than s1. Strcmp returns zero if the strings are equal, a negative integer if s1 is less than s2, and a positive integer if s1 is greater than s2.\par Strncmp is similar to strcmp. The difference is that strncmp will stop comparing the strings after n characters, even if a terminating null character has not been found in either string. In that case, the strings are considered to be equal. If a terminating null character appears in either string before n characters have been processed, strncmp returns the same result strcmp would have returned. If n is zero or negative, strncmp returns zero.\par See also memcmp.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 /* scan a table to find a matching name */\par for (i = 0; i < tableLength; ++i)\par    if (!strcmp(name, table[i]))\par       goto found;\par \par /* scan addresses that start with a five-digit zip code, */\par /* stopping if a match is found                          */\par for (i = 0; i < tableLength; ++i)\par    if (!strncmp(zipCode, addresses[i], 5))\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20       goto found;\par }{\par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 strcpy}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 strcpy}}}{\b\fs28 \tab strncpy}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 strncpy}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <string.h>\par char *strcpy(char *s1, char *s2);\par char *strncpy(char *s1, char *s2, size_t n);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Strcpy is a function that copies the contents of s2 to the string s1. All characters up to and including the terminating null character are copied. It is up to the programmer to ensure that the memory available for s1 is large enough to hold all of the characters, including the terminating null character.\par Strncpy is similar, but it will stop copying characters after n characters have been copied. If n characters are copied and no terminating null has been found, s1 will not have a terminating null. If s2 contains fewer than n characters, s1 is padded with null characters until n characters have been moved. If n is zero or negative, no copying is performed.\par Both functions return s1 as their result.\par The result is unpredictable if the two strings overlap in memory.\par \par }{\f6\fs20 strcpy(str, "This is a test.\\n");\tab /* copy a constant to a string */\par \par pos = strpos(line, ' ');\tab /* read the first word from a string */\par if (pos == -1)\par    strcpy(str, line);\par else\par    strncpy(str, line, pos);\par }\pard \qj\sb240\keepn\widctlpar\tx1440\tx2880\tx4320\adjustright {\b\fs28 strcspn}{\pard\plain \qj\sb240\keepn\widctlpar\tx1440\tx2880\tx4320\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 strcspn}}}{\b\fs28 \tab strpbrk}{\pard\plain \qj\sb240\keepn\widctlpar\tx1440\tx2880\tx4320\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 strpbrk}}}{\b\fs28 \tab strrpbrk}{\pard\plain \qj\sb240\keepn\widctlpar\tx1440\tx2880\tx4320\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 strrpbrk}}}{\b\fs28 \tab strspn}{\pard\plain \qj\sb240\keepn\widctlpar\tx1440\tx2880\tx4320\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 strspn}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <string.h>\par size_t  strspn(const char *s, const char *set);\par size_t  strcspn(const char *s, const char *set);\par char   *strpbrk(const char *s, const char *set);\par char   *strrpbrk(const char *s, const char *set);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {These functions all scan the string s and check each character to see if it is in the set of characters formed by the null-terminated string set. The set of characters can contain no characters, or all of the ASCII characters, and it can contain duplicate characters. The order of the characters in the set does not affect the scan.\par The function strspn scans the string s for the first character that is not in the set. The length of the longest initial segment in s containing only characters in set is returned. If all of the characters are in the set, the effect is to return the length of the string. If the set is the null string, zero is returned.\par The function strcspn performs the opposite check:  it skips over characters that are not in the set, stopping when a character is found that is in the set.\par The function strpbrk scans the string, skipping over characters that are in the set, and stopping at the first character that is not in the set, just like strcspn. The difference is that strpbrk returns a pointer to the character, rather than the number of characters skipped. If the string s does not have any characters from the set, NULL is returned.\par The function strrpbrk works like strpbrk, except that it returns a pointer to the last character in the string that is in the set, rather than the first character. If the string s does not have any characters from the set, NULL is returned.\par \par }{\f6\fs20 /* find and process all of the words in the */\par /* string pointed to by line                */\par strcpy(alpha, "abcdefghijklmnopqrstuvwxyz"\par               "ABCDEFGHIJKLMNOPQRSTUVWXYZ");\par while (*line) \{\par    line = strpbrk(line, alpha);\par    len = strspn(line, alpha);\par    if (len) \{\par       process(strncpy(word, line, len));\par       line += len;\par       \}\par    \}\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 strlen}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 strlen}}}{\b\fs28 \par }{\par }{\f6 #include <string.h>\par size_t strlen(const char *string);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function strlen returns the number of characters in a string. The number of characters is the number of characters that appear before the terminating null character.\par In older versions of C, strlen returned an int, which limited the length of string that could be processed by strlen. In ANSI C, strlen returns size_t, which is unsigned long in ORCA/C. This means that strlen can effectively find the length of any string that can be held in memory. If you are porting a program that is built around the assumption that strlen is int, you can safely change the return type of strlen to int in a copy of the string.h interface file. In that case, all but the least significant two bytes are dropped from the length of the string.\par \par }{\f6\fs20 len = strlen(myString);\par }\pard \qj\sb240\keepn\widctlpar\adjustright {\b\fs28 strerror\par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {See errno.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 strpos\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See strchr.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 strrchr\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See strchr.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 strrpos\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See strchr.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 strstr}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 strstr}}}{\b\fs28 \par }{\par }{\f6 #include <string.h>\par char *strstr(char *src, char *sub);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function strstr scans the string str for the first occurrence of the string sub. If a match is found, a pointer to the first character of the match is returned. If no match is found, a null pointer is returned.\par \par }{\f6\fs20 /* see if the correct answer occurs in the reply */\par if (strstr(reply, "Santa Fe") != NULL)\par    printf("Correct!  Santa Fe is the capitol of New Mexico.\\n");\par }{\par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 strtod}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 strtod}}}{\b\fs28 \tab strtol}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 strtol}}}{\b\fs28 \tab strtoul}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 strtoul}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <stdlib.h>\par double        strtod(char *str, char **ptr);\par long          strtol(char *str, char **ptr, int base);\par unsigned long strtoul(char *str, char **ptr, int base);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {These functions convert numbers represented as ASCII strings to the internal binary format used for calculations. In each case, str is a null-terminated ASCII string. Any leading white space is skipped, and then the longest sequence of characters which can be legally interpreted as a number are read and converted. The number is returned as the function's return value.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v HUGE_VAL}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ERANGE}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v errno}}}{If no conversions are possible, either because a null string was passed or because the first non-white space characters could not be interpreted as a number, zero is returned, the global variable errno is set to ERANGE, and ptr, if not NULL, is set to str. If the number causes overflow or underflow, errno is still set to ERANGE. In the case of underflow, zero is returned; in the case of overflow, infinity is returned. (Infinity is also available as the macro HUGE_VAL.)\par The second parameter can be null, or it can point to a character pointer. If it is not null, and a valid string for conversion exists, it is set to point to the character immediately after the last character used in the conversion process. This is still true if an overflow or underflow occurred. If str is null, or if no valid numeric string is found, ptr is set to the value of str.\par The function strtod converts a floating-point string to an extended value. The string has the same format as a string in a C source file. It can consist of a leading plus or minus sign. This is followed by a sequence of decimal digits, a decimal point, and another sequence of decimal digits. At least one of these digit sequences must appear, but either can be omitted, as can the decimal point. This is followed by an optional exponent, which, if present, consists of an e or E, an optional plus or minus sign, and a digit sequence. Imbedded white space is not allowed. Some examples of legal strings include:\par \par }{\f6\fs20 1.0\tab .1\tab 3\tab 1e+80\tab 1.2e-3\tab .1e-4\tab 1.e17\par }{\par The functions strtol and strtoul both have an additional parameter that is used to specify the base of the integer. The base can be zero or any number from 2 to 36. If the base is zero, the format of the number itself is used to determine the base of the number, using the same rules used by the C compiler. Namely, if the number starts with a digit from 1 to 9, it is base 10; if the number starts with 0x or 0X, it is base sixteen; and if the number starts with 0, and is not followed by an x or X, it is base 8. Any of the other values specify the base to use. For bases of 11 and higher, the alphabetic characters are used as digits, with A representing 10 and so forth to Z, which represents 35. Lowercase letters can also be used. If a letter is found which is not valid for the base in use, scanning stops. There is one exception to this rule:  if the base is specified as 16, and the number starts with 0x, the first two characters are ignored. Strtol also allows an optional leading sign.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ERANGE}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v errno}}}{The function strtol returns a long, while strtoul returns an unsigned long. If the number is too large, strtol returns LONG_MAX or LONG_MIN, depending on the sign, and strtoul returns ULONG_MAX. In both cases, errno is set to ERANGE.\par See also atof, atoi and atol.\par \par }{\f6\fs20 /* echo the integers in an ASCII buffer to standard out */\par while (cp != NULL)\par    printf("%f\\n", strtol(cp, &cp, 10));\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 strtok}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 strtok}}}{\b\fs28 \par }{\par }{\f6 #include <string.h>\par char *strtok(const char *str, const char *set);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function strtok scans the string str for tokens separated by the characters contained in the null-terminated string set. The first call to strtok should include a pointer to a string of characters for the parameter set. If the set does not change on subsequent calls, a null pointer can be passed, avoiding the overhead of reforming the set on each call to strtok.\par When called, strtok starts by forming an internal representation of the set of characters. If no set was passed, the last set passed to strtok is used.\par Next, if str is not null, strtok skips all characters in str that occur somewhere in the set of characters. If all of the characters are in the set, an internal pointer is set to null and a null pointer is returned. If a character is found which is not in the set, the internal pointer is set to point to the first character not in the set, and processing continues as if str had been null. By this time, though, the local copy strtok keeps of str is null, even if it was not null when strtok was called.\par To continue scanning the string, subsequent calls to strtok should use a null pointer for str. The set may be changed as needed. If str is null, and the internal pointer is null, strtok returns null. If the internal value is not null, strtok skips over all of the characters that are not in the set, overwriting the first character that is in the set with a null character. The internal pointer is then updated to point to the character after the null, and the old value of the internal pointer, which now points to a null-terminated token, is returned.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 /* find and process words in the string pointed to by line */\par \par /* form the set of separator characters */\par j = 0;\par for (i = 1; i < 128; ++i)\par    if (!isalpha(i))\par       set[j++] = i;\par set[j] = '\\0';\par \par /* find and process the words */\par str = strtok(line, set);\par while (str != NULL) \{\par    process(str);\par    str = strtok(NULL,NULL);\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20    \}\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 system}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 system}}}{\b\fs28 \par }{\par }{\f6 #include <stdlib.h>\par int system(char *command);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The system function takes a null-terminated string as input and executes the string as a series of shell calls. The character \\r can be used to separate lines if the argument consists of more than one source line. The only difference between this call and executing an EXEC file with the same commands is that an EXEC file creates a new stack frame for shell variables, while commands executed with this call work directly with the shell variables already in existence. Any command that can be typed from the shell can also be executed using this command.\par As with script files, execution will halt early if any of the commands returns a non-zero error code and the \{exit\} shell variable is set to any value. If this happens, the error code is returned by the system function. Execution will also stop if the shell's exit command is used. The exit command also returns a value, and this value is returned by the system function. If the commands execute normally, a zero is returned.\par Passing system a null pointer returns a zero if no shell is active, and a non-zero value if a shell is active.\par \par }{\f6\fs20 /* catalog the disk */\par system("catalog");\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 tan}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 tan}}}{\b\fs28 \par }{\par }{\f6 #include <math.h>\par extended tan(extended x);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ERANGE}}}{The function tan returns the trigonometric tangent of the argument. If an error occurs, errno is set to ERANGE. The argument must be supplied in radians.\par \par }{\f6\fs20 height = tan(x)*length;\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 tanh}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 tanh}}}{\b\fs28 \par }{\par }{\f6 #include <math.h>\par extended tanh(extended x);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function tanh returns the hyperbolic tangent of the argument.\par }\pard \qj\fi360\sb240\widctlpar\adjustright {\f6\fs20 n = tanh(x);\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 time}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 time}}}{\b\fs28 \par }{\par }{\f6 #include <time.h>\par typedef unsigned long time_t;\par \par time_t time(time_t *tptr);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The time function returns the current time as a coded integer. If the parameter tptr is not null, the time is also stored at the location indicated by tptr. If an error occurs, -1 is returned. (No error is possible in ORCA/C.)  See localtime for a way to format the time in a usable fashion.\par See also ctime, difftime, gmtime, mktime.\par \par }{\f6\fs20 t = time(NULL);\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 tmpfile\par }{\par }\pard \qj\fi360\widctlpar\adjustright {See tmpnam.\par \par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 tmpnam}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 tmpnam}}}{\b\fs28 \tab tmpfile}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 tmpfile}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <stdio.h>\par char *tmpnam(char *buf);\par FILE *tmpfile(void);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The tmpnam function is used to create a file name that does not interfere with other file names on the system. If the call is successful, tmpnam returns a pointer to the file name. If buf is not null, the null-terminated file name is also stored in the character array pointed to by buf. The buffer should be at least L_tmpnam characters long. The tmpnam function can create up to TMP_MAX unique file names; under ORCA/C, TMP_MAX is 10000. Note that subsequent calls to tmpnam or tmpfile will destroy the internal copy of any file name created by tmpnam. If subsequent calls to either function will be made, and you will need the file name again, you must save the file name in your own local buffer.\par The tmpfile function calls tmpnam to obtain a file name, then opens the file with flags of "w+b". The file is automatically deleted when the program stops.\par \par }\pard \qj\fi360\widctlpar\tx4320\adjustright {\f6\fs20 tmpnam(myFileName);\par myFile = tmpfile();\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 toascii}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 toascii}}}{\b\fs28 \par }{\par }{\f6 #include <ctype.h>\par int toascii(int c);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Toascii is a macro that takes any integer argument and returns a valid ASCII character. It makes the conversion by discarding all bits except the seven least significant bits.\par \par }{\f6\fs20 /* make sure an integer is ASCII before checking to */\par /* see if it is uppercase                           */\par if (isupper(toascii(ch))\par    printf("The character is uppercase.\\n");\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 toint}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 toint}}}{\b\fs28 \par }{\par }{\f6 #include <ctype.h>\par int toint(char c);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Toint is a function that returns the value of one of the hexadecimal}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v hexadecimal}}}{ digits. The digits consist of the characters '0' to '9', which have the values 0 to 9, respectively; and the alphabetic characters 'A' to 'F' (or their lowercase equivalents), which have the values 10 to 15, respectively.\par \par }{\f6\fs20 /* convert a hexadecimal string to an unsigned long value */\par val = 0;\par len = strlen(hexString);\par for (i = 0; i < len; ++i)\par    val = (val << 4) | toint(hexString[i]);\par }{\par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 tolower}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 tolower}}}{\b\fs28 \tab _tolower}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 _tolower}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <ctype.h>\par int tolower(char c);\par int _tolower(char c);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {If the argument is an uppercase alphabetic character, the lowercase equivalent of that letter is returned. If the argument is not an uppercase alphabetic character, the original value is returned unchanged.\par Tolower is a function. A faster macro called _tolower will perform the same operation if the argument is known to be an uppercase character, but it will also modify the argument if it is not an uppercase letter. When you know that the argument is an uppercase letter, use _tolower for efficiency. If the argument may not be an uppercase letter, use tolower.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 /* convert a string to lowercase letters */\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 i = 0;\par while (str[i] = tolower(str[i++]));\par }{\par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 toupper}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 toupper}}}{\b\fs28 \tab _toupper}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 _toupper}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <ctype.h>\par int toupper(char c);\par int _toupper(char c);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {If the argument is a lowercase alphabetic character, the uppercase equivalent of that letter is returned. If the argument is not a lowercase alphabetic character, the original value is returned unchanged.\par Toupper is a function. A faster macro called _toupper will perform the same operation if the argument is known to be a lowercase character, but it will also modify the argument if it is not a lowercase letter. When you know that the argument is a lowercase letter, use _toupper for efficiency. If the argument may not be a lowercase letter, use toupper.\par \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\f6\fs20 /* convert a string to uppercase letters */\par i = 0;\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 while (str[i] = toupper(str[i++]));\par }{\par }\pard \qj\keepn\widctlpar\adjustright {\b\fs28 ungetc}{\pard\plain \qj\keepn\widctlpar\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 ungetc}}}{\b\fs28 \par }{\par }{\f6 #include <stdio.h>\par int ungetc(char c, FILE *stream);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The function ungetc returns a character to a stream opened for input. The next call that reads a character from the file will read the character placed back into the stream by this call. Subsequent calls will read characters from the file in the normal way. The character is returned by ungetc if the call was successful; otherwise, EOF is returned. An attempt to push back EOF is ignored, and EOF is returned.\par ORCA/C implements a single character buffer. An attempt to call ungetc a second time before processing the first character will result in an error.\par \par }\pard \qj\fi360\widctlpar\tx4320\adjustright {\f6\fs20 /* collect a token from a file */\par i = 0;\par for (;;) \{\par    ch = fgetc(myFile);\par    if (isalpha(ch = fgetc(myFile)))\par       name[i++] = ch;\par    else \{\par       ungetc(ch, myFile);\par       break;\par       \}\par    \}\par name[i] = '\\0';\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\tx2880\adjustright {\b\fs28 va_arg}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 va_arg}}}{\b\fs28 \tab va_end}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 va_end}}}{\b\fs28 \tab va_start}{\pard\plain \qj\keepn\widctlpar\tx1440\tx2880\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 va_start}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <stdarg.h>\par typedef char *va_list[2];\par \par void va_start(va_list ap, ??? LastFixedParm);\par ??? va_arg(va_list ap, ???);\par void va_end(va_list ap);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v parameters}}}{This collection of macros and functions allow variable argument lists to be handled from C. In a function with variable argument lists, the first call is to the macro va_start. This call is used to initialize pointers that will be used by va_arg and va_end. Two parameters are passed:  the first is a local variable of type va_list, while the second is the name of the last fixed parameter in the parameter list. There must be at least one fixed parameter.\par The macro va_arg is used to recover the values of the parameters. It takes the same argument variable initialized by va_start as the first parameter, and the type of the next argument as the second parameter. The value of the next parameter is returned, and the ap variable is incremented past the parameter.\par The function va_end is called before leaving the function. It must be called after all of the arguments have been processed by va_arg. The va_end function cleans up the stack by removing the variable arguments from the stack.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v stack repair code}}}{These macros will not work if stack repair code is enabled; stack repair code is enabled by default. For an explanation of stack repair code, see Chapter 10. To turn off stack repair code, see the optimize pragma.\par \par }\pard \qj\fi360\keepn\widctlpar\tx4320\adjustright {\f6\fs20 /* return the sum of zero or more integers */\par \par int sum(int count, ...)\par }\pard \qj\fi360\widctlpar\tx4320\adjustright {\f6\fs20 \par \{\par va_list list;\par int total;\par \par va_start(list, count);\par total = 0;\par while (count--) \par    total += va_arg(list, int);\par va_end(list);\par return total;\par \}\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 vfprintf}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 vfprintf}}}{\b\fs28 \tab vprintf}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 vprintf}}}{\b\fs28 \tab vsprintf}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 vsprintf}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <stdio.h>\par int vfprintf(FILE *stream, char *format, va_list arg);\par int vprintf(char *format, va_list arg);\par int vsprintf(char *s, char *format, va_list arg);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {These functions are basically the same as the functions with the same name, sans the leading v. The difference is that these print functions use the vararg facility (see va_arg) to specify the parameters.\par \par }\pard \qj\keepn\widctlpar\tx1440\adjustright {\b\fs28 write}{\pard\plain \qj\keepn\widctlpar\tx1440\adjustright \b\v\f4\fs28\cgrid {\xe {\b\v\fs28 }{\b\v\fs28 write}}}{\b\fs28 \par }\pard \qj\keepn\widctlpar\adjustright {\par }{\f6 #include <fcntl.h>\par int write(filds, void *buf, unsigned n);\par }\pard \qj\fi360\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Up to }{\i n}{ bytes are written from the buffer pointed to by }{\i buf}{ to the file whose file ID is }{\i filds}{. If }{\i n}{ bytes cannot be written due to lack of space, as many bytes are written as possible. The number of bytes actually written is returned. If an error occurs, a -1 is returned and errno is set to one of the values shown below.\par If the file was not opened with the O_BINARY flag set, any \\n characters in the buffer are converted to \\r characters before being written.\par \par }{\ul Possible errors\par }{\par }\pard \qj\fi-1440\li1800\widctlpar\adjustright {EIO\tab A physical I/O error occurred.\par EBADF\tab filds is not a valid file ID.\par EBADF\tab The file is not open for writing.\par ENOSPC\tab There was not enough room on the device to write the bytes.\par ENOSPC\tab The O_BINARY flag was not set, and there was not enough room to allocate a temporary buffer for character conversion.\par }\pard \qj\fi360\widctlpar\adjustright {\par While this function is a common one in C libraries, it is not required by the ANSI C standard, and should be avoided if possible.\par See also fwrite.\par }\pard \widctlpar\adjustright {\fs28 \sect }\sectd \sbkodd\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\f5\fs20 Appendix A:  Error Messages\par }}\pard\plain \widctlpar\adjustright \f4\cgrid {\b\fs48 Appendix A \endash  Error Messages\par }\pard \qj\widctlpar\adjustright {\pard\plain \qj\widctlpar\adjustright \v\f4\cgrid {\tc {\v }{\v Appendix A \endash  Error Messages\tcl1}}}{\v \par }\pard \widctlpar\adjustright {\par \par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v compilation errors}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v link errors}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v run-time errors}}}{The errors flagged during the development of a program are of three basic types:  compilation errors, linking errors, and execution errors. Compilation errors are those that are flagged by the compiler when it is compiling your program. These are generally caused by mistakes in typing or simple omissions in the source code. Compilation errors are divided into four categories:  those that are marked with a caret (^) on the line in which they occurred; those where the exact position of the error cannot be determined or is not well defined; those which are due to the restrictions imposed by the ORCA/C compiler; and those which are so serious that compilation cannot continue.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v linker}}}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v link errors}}}{Link errors are reported by the linker when it is processing the object modules produced by the compiler.\par }{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v run-time errors}}}{Execution errors occur when your program is running. These can be detectable mistakes, such as a stack overflow with debugging enabled, or can be severe enough to cause the computer to crash, such as accessing memory in unexpected ways, as with pointer variables containing invalid addresses. \par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Compilation Errors}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Compilation Errors\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The errors listed below are all errors that the compiler can recover from.\par \par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 '(' expected\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The compiler expected a left parenthesis, and another token was found.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 ')' expected\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The compiler expected a right parenthesis, and another token was found.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 '>' expected\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The compiler expected a greater than sign, and another token was found.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 ';' expected\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The compiler expected a semicolon, and another token was found.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 '\{' expected\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The compiler expected a left brace, and another token was found.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 '\}' expected\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The compiler expected a right brace, and another token was found.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 ']' expected\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The compiler expected a right bracket, and another token was found.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 ':' expected\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The compiler expected a colon, and another token was found.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 '(', '[' or '*' expected\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The compiler expected one of these tokens, and another token was found.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 ',' expected\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The compiler expected a comma, and another token was found.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 '.' expected\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The compiler expected a period, and another token was found.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 '8' and '9' cannot be used in octal constants\par }{\par }\pard \qj\fi360\widctlpar\adjustright {Any integer constant staring with a zero is treated as an octal}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v octal}}}{ constant. Octal numbers do not use the digits 8 or 9.\par }\pard \qj\widctlpar\adjustright {\par }\pard \keepn\widctlpar\adjustright {\b\f6\fs28 A character constant must contain exactly one character\par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The character constant has zero characters, or more than one character. C character constants are limited to a single character. Use a string for more than one character. To create a character constant for the single quote mark, use }{\f6\fs20 '\\''}{.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 A function cannot be defined here\par }{\par }\pard \qj\fi360\widctlpar\adjustright {A function definition cannot appear in another function, a structure, or a union.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 A value cannot be zero bits wide\par }{\par }\pard \qj\fi360\widctlpar\adjustright {A bit field was declared, and the width of the bit field was given as zero bits. Bit fields must be at least one bit wide, but no more than thirty-two bits wide.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 An #if had no closing #endif\par }{\par }\pard \qj\fi360\widctlpar\adjustright {A preprocessor #if statement was found, but was not completed with an #endif.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Assignment to an array is not allowed\par }{\par }\pard \qj\fi360\widctlpar\adjustright {You cannot assign a value to an array in C, even if the value you are trying to assign is another array of the same type. Use the memcpy function to copy the contents of one array into another array.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Assignment to const is not allowed\par }{\par }\pard \qj\fi360\widctlpar\adjustright {An attempt has been made to assign a value to a variable that was declared as being a constant (using the const descriptor). Constant variables cannot be changed. You must either change the declaration or eliminate the assignment.\par }\pard \qj\sb240\keepn\widctlpar\adjustright {\b\f6\fs28 Assignment to void is not allowed\par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {An attempt has been made to assign a value to void.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Auto or register can only be used in a function body\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The auto storage class can only be used with variables defined locally in a function.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Bit fields must be less than 32 bits wide\par }{\par }\pard \qj\fi360\widctlpar\adjustright {ORCA/C restricts bit fields to 32 bits or less. The size of the bit field must be reduced.\par }\pard \qj\widctlpar\adjustright {\par }\pard \keepn\widctlpar\adjustright {\b\f6\fs28 Break must appear in a while, do, for or switch statement\par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {A break statement was found, but it did not appear in a while loop, a do loop, a for loop, or a switch statement. The break statement is used to leave one of these structures, and cannot be used outside of the structure.\par }\pard \qj\widctlpar\adjustright {\par }\pard \keepn\widctlpar\adjustright {\b\f6\fs28 Case and default labels must appear in a switch statement\par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {A case label or default label was found, but the label was not in the body of a switch statement. These types of labels cannot be used outside of a switch statement.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Compiler error\par }{\par }\pard \qj\fi360\widctlpar\adjustright {This error is generated when the compiler detects an internal problem. This can occur when another error appears in the program, and that error causes conflicting or missing information. This error sometimes appears before the message about the error that caused the problem. If this error appears in a program that has no other error messages, please report the problem. If it appears in conjunction with some other error, correcting the other error will get rid of this error, too.\par }\pard \qj\widctlpar\adjustright {\par }\pard \widctlpar\adjustright {\b\f6\fs28 Cannot redefine a macro\par }{\par }\pard \fi360\widctlpar\adjustright {You cannot include a second definition for a macro unless the new definition is token-for-token identical to the original definition. For example, the following two definitions can legally appear in the same program:\par \par }\pard \fi360\widctlpar\tx900\adjustright {\f6\fs20 #define EOF (-1)\par #define EOF (-1)\par }\pard \fi360\widctlpar\adjustright {\par The definitions\par \par }\pard \fi360\widctlpar\tx900\adjustright {\f6\fs20 #define EOF (-1)\par #define EOF -1\par }\pard \fi360\widctlpar\adjustright {\par }\pard \widctlpar\adjustright {would, however, generate this error message. There are four ways to deal with the problem:\par \par }\pard \fi-360\li720\widctlpar\adjustright {1.\tab Remove all but one of the macro definitions.\par \par 2.\tab Insure that each definition of the macro exactly matches all of the other definitions.\par }\pard \fi-360\li720\sb240\widctlpar\adjustright {3.\tab Undefine the old macro before redefining it.\par }\pard \fi-360\li720\widctlpar\adjustright {\par 4.\tab Bracket the definition with conditional compilation commands to prevent redefinition, as in\par \par }\pard \fi360\li360\widctlpar\adjustright {\f6\fs20 #ifndef EOF\par #define EOF (-1)\par #endif\par }\pard \widctlpar\adjustright {\par }{\b\f6\fs28 Cannot take the address of a bit field\par }{\par }\pard \qj\fi360\widctlpar\adjustright {An attempt has been made to extract the address of a field in a structure or union that is a bit field. Bit fields are not required to start on addressable boundaries, so it is not possible to take the address of a bit field.\par }\pard \widctlpar\adjustright {\par }{\b\f6\fs28 Cannot undefine standard macros\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The standard macros __LINE__, __FILE__, __DATE__, __TIME__, __STDC__ and __ORCAC__ cannot be undefined using the #undef command.\par }\pard \widctlpar\adjustright {\par }{\b\f6\fs28 Comp data type is not supported by the 68881\par }{\par }\pard \qj\fi360\widctlpar\adjustright {ORCA/C uses SANE to perform calculations on float, double, extended and comp numbers. When you use the #pragma float command to instruct the compiler to use the 68881 floating-point card, comp numbers can no longer be used, since the 65881 does not support the comp data type. This error message will flag any attempt to use comp numbers with the 68881 card.\par }\pard \widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Continue must appear in a while, do or for loop\par }{\par }\pard \qj\fi360\widctlpar\adjustright {A continue statement was found, but it did not appear in a while loop, a do loop, or a for loop. The continue statement is used to jump to the end of one of these structures, and cannot be used outside of the structure.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Digits expected in the exponent\par }{\par }\pard \qj\fi360\widctlpar\adjustright {A floating-point constant was coded with an e designator for the exponent, but no exponent was found. Either code an exponent or remove the e exponent designator.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Duplicate case label\par }{\par }\pard \qj\fi360\widctlpar\adjustright {Two identical values have been used for a case label in the same switch statement. Each of the case labels must be unique.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Duplicate label\par }{\par }\pard \qj\fi360\widctlpar\adjustright {Two labels with the same name have been defined in the same function. Each statement label must be different from the other statement labels in the function.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Duplicate symbol\par }{\par }\pard \qj\fi360\widctlpar\adjustright {Two symbols have been defined in the same overloading class, and the symbols were given the same name. For example, a single function cannot define the variable i as an int, and then redefine it as a float variable. One of the names must be changed so that all of the names are unique.\par }\pard \qj\sb240\keepn\widctlpar\adjustright {\b\f6\fs28 'dynamic' expected\par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The segment statement allows you to define the segment as dynamic by placing the identifier dynamic in the segment statement. This is the only token allowed in that spot. The compiler found a different token. You must remove it, or change it to dynamic.\par }\pard \qj\widctlpar\adjustright {\par }{\b\f6\fs28 The else has no matching if\par }{\par }\pard \qj\fi360\widctlpar\adjustright {An else statement appeared in a program, but no matching if statement was found. This can happen when the if statement is omitted entirely, when two else clauses are used with a single if statement, or when compound statements have been used improperly.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 End of line expected\par }{\par }\pard \qj\fi360\widctlpar\adjustright {Extra characters appeared in a preprocessor command.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Expression expected\par }{\par }\pard \qj\fi360\widctlpar\adjustright {A token that cannot be used to start an expression was found in a position where the compiler expected to find an expression.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Expression syntax error\par }{\par }\pard \qj\fi360\widctlpar\adjustright {An expression has not been formed correctly. This can occur when an operand or operation has been omitted, or when the operands and operations are not given in the correct order.\par }\pard \qj\widctlpar\adjustright {\par }{\b\f6\fs28 Extern variables cannot be initialized\par }{\par }\pard \qj\fi360\widctlpar\adjustright {When a variable is declared as extern, the compiler does not create the space for the variable, it only notes that such a variable exists in some other separately compiled module or library. A variable cannot be initialized unless space is created to hold the initial value. You can, of course, initialize the variable in the single location where it is declared.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 File name expected\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The #include, #append and #pragma keep directive expect an operand of a file name. None was found.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 File name is too long\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The C compiler limits file names to 255 characters. A longer file name was found in a #include, #append or #pragma keep directive.\par }\pard \qj\widctlpar\adjustright {\par }{\b\f6\fs28 Functions cannot return functions or arrays\par }{\par }\pard \qj\fi360\widctlpar\adjustright {A function can return a pointer to a function or array, but a function cannot return another function or a whole array.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Further errors suppressed\par }{\par }\pard \qj\fi360\widctlpar\adjustright {When more than eight errors occur on a single line, the compiler reports the first seven, then gives this error message rather than continuing with more errors.\par }\pard \qj\sb240\keepn\widctlpar\adjustright {\b\f6\fs28 Identifier expected\par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The C language requires that an identifier appear at the indicated place.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Illegal character\par }{\par }\pard \qj\fi360\widctlpar\adjustright {A character which is not used in the C language appeared outside of a comment or string constant.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Illegal math operation in a constant expression\par }{\par }\pard \qj\fi360\widctlpar\adjustright {An attempt has been made to perform an operation that is not allowed in a constant expression.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Illegal operand for the indirection operator\par }{\par }\pard \qj\fi360\widctlpar\adjustright {An attempt has been made to use the selection operator (.) or the indirection operator (*) in a context in which it is not allowed.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Illegal operand in a constant expression\par }{\par }\pard \qj\fi360\widctlpar\adjustright {An operand that could not be resolved as a constant at compile time was found in an expression that must yield a constant value.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Illegal type cast\par }{\par }\pard \qj\fi360\widctlpar\adjustright {An attempt was made to cast a variable to an illegal type.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Illegal use of forward declaration\par }{\par }\pard \qj\fi360\widctlpar\adjustright {An attempt has been made to use a forward declaration in a way that is not allowed. In general, no use can be made of a forward declaration except to declare a pointer to the type.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Implementation restriction: run-time stack space exhausted\par }{\par }\pard \qj\fi360\widctlpar\adjustright {In some cases, the compiler can detect at compile time that a stack overflow will occur when a program is executed; when this happens, this error appears. This is generally caused by defining an auto array that is larger than 32K bytes. You can avoid the problem by changing the array to a static array or using a pointer to a dynamically allocated array.\par }\pard \qj\widctlpar\adjustright {\par }\pard \keepn\widctlpar\adjustright {\b\f6\fs28 Implementation restriction: string space exhausted\par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Each function has a buffer that is used for string constants and a few values stored when debug code is created. This buffer is limited to 8000 bytes. You must turn debugging off or split the function into two or more smaller functions to avoid overflowing the buffer.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Implementation restriction: too many local labels\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The compiler generates internal labels to handle the flow of control statements. The number of labels that can appear in a single function is sufficient for about 2000 to 3000 lines of code, although the number can vary greatly based on coding style. If the limit is exceeded, you must split the function into two or more functions to avoid the limitation.\par }\pard \qj\sb240\keepn\widctlpar\adjustright {\b\f6\fs28 Incorrect operand size\par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Many 65816 operation codes require an operand of a specific size. For example, operands using indirect addressing generally require an expression value in the range 0 to 255. If the expression in the operand results in a value with an inappropriate size, and the operand cannot be legally converted to a correct size, this error will appear.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Incorrect number of macro parameters\par }{\par }\pard \qj\fi360\widctlpar\adjustright {A macro was invoked, and too few or too many parameters were supplied. Each of the parameters defined in the macro definition must be supplied exactly one time each time the macro is used.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Integer constant expected\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The inline directive, used for creating tool interface files, requires an integer constant and a long integer constant for the two operands. The #pragma nda directive also requires two integer constants. Something other than an integer constant was used.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Integer constants cannot use the f designator\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The f or F designator, used to force a floating-point constant to be a float rather than double value, has been used on an integer constant (such as a character or octal value). The f designator can only be used of floating-point values or decimal integer values.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Integer overflow\par }{\par }\pard \qj\fi360\widctlpar\adjustright {An integer constant with a value over 2147483647, or an unsigned constant with a value over 4294967295 appeared in the program. The integer is too large for ORCA/C to deal with.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Invalid operand\par }{\par }\pard \qj\fi360\widctlpar\adjustright {An operand was used with an instruction that does not support the operand. For example, this error would appear if you code absolute indexed addressing with a jsl instruction.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Invalid storage type for a parameter\par }{\par }\pard \qj\fi360\widctlpar\adjustright {Function parameters can have a storage class of auto or register. Some other storage type was specified for a parameter; it must be changed.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Keep must appear before any functions\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The #pragma keep directive must appear before the first function definition. Move it to the top of the source file.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 L-value required\par }{\par }\pard \qj\fi360\widctlpar\adjustright {Assignments and certain operators require an l-value. Something other than an l-value was used in one of these locations.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Lint: missing function type\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The lint pragma has been used with bit 1 set, and the function has been declared or defined without an explicit return type.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Lint: parameter list not prototyped\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The lint pragma has been used with bit 2 set, and a function has been declared or defined without a prototyped parameter list.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Lint: undefined function\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The lint pragma has been used with bit 0 set, and the function has been used, but not declared or defined before the use.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Lint: unknown pragma\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The lint pragma has been used with bit 3 set, and a pragma has been found which the compiler does not recognize.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 No end was found to the string\par }{\par }\pard \qj\fi360\widctlpar\adjustright {A string constant was started, but a closing quote mark was not found.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 No matching '?' found for this ':' operator\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The compiler found the start of a trinary operator, but could not find the ? character that separates the two expressions.\par }\pard \qj\widctlpar\adjustright {\par }\pard \keepn\widctlpar\adjustright {\b\f6\fs28 Only one default label is allowed in a switch statement\par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {A default label has been found in the body of a switch statement for which another default label has already been found. Only one default label can appear in any switch statement; one of them must be removed.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Only one #else may be used per #if\par }{\par }\pard \qj\fi360\widctlpar\adjustright {A #else command was found in the body of an #if statement that already has a #else clause. One of the #else statements must be removed or changed to an #elif command.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Only parameters or types may be declared here\par }{\par }\pard \qj\fi360\widctlpar\adjustright {An attempt was made to declare a variable in the declarations that follow the function header and precede the function body. Only parameters can be declared in this location.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Operand expected\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The compiler expected an operand (variable, parenthesized expression, etc.) during a function evaluation, but found some other token.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Operand syntax error\par }{\par }\pard \qj\fi360\widctlpar\adjustright {An operand was used for a 65816 instruction, but the miniassembler could not compile the operand. The error message will point to the problem area.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Operation expected\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The compiler expected an operation (+, *, etc.) during a function evaluation, but found some other token.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Pascal qualifier is only allowed on functions\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The pascal qualifier}{\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v pascal qualifier}}}{ can only be used on a function declaration or definition. This error appears when it is used on a type or variable.\par }\pard \qj\widctlpar\adjustright {\par }\pard \keepn\widctlpar\adjustright {\b\f6\fs28 Pointer initializers must resolve to an integer, address or string\par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The value provided in the initializer for a pointer must be an integer, an address, or a string, and the type must be correct for the pointer.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Real constants cannot be unsigned\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The u or U designator, used to indicate that an integer is unsigned, has been used on a real constant. Real constants cannot be unsigned.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Statement expected\par }{\par }\pard \qj\fi360\widctlpar\adjustright {A statement was expected in the body of a function or compound statement, but a token has been found which cannot be used to start a statement.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 String constant expected\par }{\par }\pard \qj\fi360\widctlpar\adjustright {String constants are required when the name of a CDA, NDA or segment is expected by the compiler. Something other than a string constant was found in one of these situations.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 String too long\par }{\par }\pard \qj\fi360\widctlpar\adjustright {ORCA/C limits each individual string constant to 4000 characters. A string constant longer than 4000 characters has appeared in the source file.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Switch expressions must evaluate to integers\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The operand of a switch statement must evaluate to one of the forms of integer (including characters). The function evaluates to some other type, and must be changed.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 The array size could not be determined\par }{\par }\pard \qj\fi360\widctlpar\adjustright {In some instances, arrays sizes must be given, and in others, the exact size can be left unspecified. This error notes that an attempt has been made to leave the size of an array unspecified when a specific size is required.\par }\pard \qj\widctlpar\adjustright {\par }\pard \keepn\widctlpar\adjustright {\b\f6\fs28 The & operator cannot be applied to arrays\par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {An array name is an address; applying the & operator to an address is not allowed.\par }\pard \qj\widctlpar\adjustright {\par }\pard \keepn\widctlpar\adjustright {\b\f6\fs28 The function's type must match the previous declaration\par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {A function declaration or definition has been found for a function that has been declared earlier. This is allowed, but the type returned by the function must match the earlier declaration.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 The last compound statement was not finished\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The function body contains the start of a compound statement, but the source file ended before the compound statement was completed.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 The last do statement was not finished\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The function body contains the start of a do statement, but the function ended before the do statement was completed.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 The last for statement was not finished\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The function body contains the start of a for statement, but the function ended before the for statement was completed.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 The last else clause was not finished\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The function body contains the start of an else clause for an if statement, but the function ended before the else clause was completed.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 The last if statement was not finished\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The function body contains the start of an if statement, but the function ended before the if statement was completed.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 The last switch statement was not finished\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The function body contains the start of a switch statement, but the function ended before the switch statement was completed.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 The last while statement was not finished\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The function body contains the start of a while statement, but the function ended before the while statement was completed.\par }\pard \qj\widctlpar\adjustright {\par }\pard \keepn\widctlpar\adjustright {\b\f6\fs28 The number of array elements must be greater than 0\par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {An array was declared with 0 elements. All arrays must have one or more elements.\par }\pard \qj\widctlpar\adjustright {\par }\pard \keepn\widctlpar\adjustright {\b\f6\fs28 The number of parameters does not agree with the prototype\par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {A function call had been made, but the number of parameters supplied in the function call does not match the number of parameters declared by the function prototype. Exactly one parameter must be supplied for each parameter in the function prototype, and the types of the parameters in the call must match the types of the parameters in the function prototype.\par }\pard \qj\widctlpar\adjustright {\par }\pard \keepn\widctlpar\adjustright {\b\f6\fs28 The operation cannot be performed on operands of the type given\par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {Not all operations can be used with all types. An attempt has been made to use an operation with an operand of an illegal type. For example, this error would occur if you attempt to use a bit manipulation operator on a floating-point number.\par }\pard \qj\widctlpar\adjustright {\par }\pard \keepn\widctlpar\adjustright {\b\f6\fs28 The selected field does not exist in the structure or union\par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {A field has been selected from a structure or union using the -> or . selection operators, but the field does not exist.\par }\pard \qj\widctlpar\adjustright {\par }\pard \keepn\widctlpar\adjustright {\b\f6\fs28 The selection operator must be used on a structure or union\par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The . or -> selection operator has been used on a variable that is not a structure or union.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 The structure has already been defined\par }{\par }\pard \qj\fi360\widctlpar\adjustright {An attempt has been made to redefine a structure or union. Once a set of fields has been associated with a structure or union, the structure or union tag can be used to define variables, but the fields must not be redefined.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 There is no #if for this directive\par }{\par }\pard \qj\fi360\widctlpar\adjustright {A #else or #elif command has been used, but cannot be associated with a #if command.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Token merging produced an illegal token\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The ## token merging operator was used in a macro, but the tokens merged did not result in a legal token. For example, merging - and 1 produces the string -1, but this string is not a legal token. (The characters "-1" form two separate tokens, the unary subtraction operator and the signed integer one.)\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Too many initializers\par }{\par }\pard \qj\fi360\widctlpar\adjustright {Too many initializers have been specified for an array or structure.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Type conflict\par }{\par }\pard \qj\fi360\widctlpar\adjustright {Incompatible types have been used with one of the operators in an expression, or an attempt has been made to pass a parameter with an incorrect type to a prototyped function.\par }\pard \qj\sb240\keepn\widctlpar\adjustright {\b\f6\fs28 Type expected\par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {The compiler expected a type in a declaration, but none was found.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Undeclared identifier\par }{\par }\pard \qj\fi360\widctlpar\adjustright {An identifier has been used, but it has not been declared. Except for some limited cases where a function may be called before it is used, all identifiers must be declared before they are used.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Unidentified operation code\par }{\par }\pard \qj\fi360\widctlpar\adjustright {An operation code appeared in the miniassembler, but it was not a legal 65816 operation code. Be sure the name of the operation code has not been redefined with a macro. If the error appears in an operand field, make sure the operation code requires an operand. If the error appears in a label field, be sure the label is followed by a colon.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Unions cannot have bit fields\par }{\par }\pard \qj\fi360\widctlpar\adjustright {Bit fields can only be used in structures.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Unknown cc= option on command line\par }{\par }\pard \qj\fi360\widctlpar\adjustright {There is a cc= command line option that the compiler does not recognize, possibly due to a malformed option.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Unknown preprocessor command\par }{\par }\pard \qj\fi360\widctlpar\adjustright {The preprocessor has encountered a command it does not recognize. The command must be removed.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 'while' expected\par }{\par }\pard \qj\fi360\widctlpar\adjustright {A while clause was expected at the end of a do statement, but none was found.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 You cannot initialize a parameter\par }{\par }\pard \qj\fi360\widctlpar\adjustright {Parameters cannot be initialized.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 You cannot initialize a type\par }{\par }\pard \qj\fi360\widctlpar\adjustright {Only variables can be initialized, not an entire class of variables represented by a type.\par }\pard \qj\widctlpar\adjustright {\par }\pard \keepn\widctlpar\adjustright {\b\f6\fs28 You must initialize the individual elements of a struct, union, or non-char array\par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {This error generally occurs when an initializer has been mistyped. When initializing a complex type, it is necessary to specify the values of each element or field, except for some cases when the compiler will finish initializing an area with zeros.\par }\pard \widctlpar\adjustright {\par \par }\pard \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs36 Terminal Compilation Errors}{\pard\plain \keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright \b\v\f4\fs36\cgrid {\tc {\b\v\fs36 }{\b\v\fs36 Terminal Compilation Errors\tcl2}}}{\b\fs36 \par }\pard \qj\keepn\widctlpar\adjustright {\b\fs36 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\pard\plain \qj\fi360\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v terminal errors}}}{A terminal error encountered during compilation will abort the compile.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Error purging }{\b\i\f6\fs28 file}{\b\f6\fs28 \par }{\par }\pard \qj\fi360\widctlpar\adjustright {An error occurred when the compiler was releasing a file. This could be a source file or an object file created by the compiler. This error can occur due to corrupted memory, a full disk, or an error while writing the file to disk.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Error reading }{\b\i\f6\fs28 file}{\b\f6\fs28 \par }{\par }\pard \qj\fi360\widctlpar\adjustright {A file read error occurred while reading the contents of one of the source files. If an exit is made to the editor, the location may not be correct. This error is reported by the operating system; it is generally caused by a corrupted disk or a disk with a bad block.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 ORCA/C requires version 1.1 or later of the shell\par }{\par }\pard \qj\fi360\keepn\widctlpar\adjustright {The ORCA/C compiler has been executed from APW}{\pard\plain \qj\fi360\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v APW}}}{ 1.0 or ORCA/M}{\pard\plain \qj\fi360\keepn\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ORCA/M}}}{ 1.0. You must update the shell.\par }\pard \qj\fi540\keepn\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Out Of Memory\par }{\par }\pard \qj\fi360\keepn\widctlpar\adjustright {There is not enough memory to compile the program.\par }\pard \qj\fi540\keepn\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Source files must have a file type of SRC\par }{\par }\pard \qj\fi360\widctlpar\adjustright {An attempt has been made to open a source file with a #include or #append directive, but the file was not a source file.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 Terminal compiler error\par }{\par }\pard \qj\fi360\widctlpar\adjustright {An internal error has occurred that the compiler cannot recover from. This error should be accompanied by some other error. When the other errors have been corrected, this error should go away. If it does not, please contact the Byte Works.\par }\pard \qj\widctlpar\adjustright {\par }\pard \qj\keepn\widctlpar\adjustright {\b\f6\fs28 User Termination\par }{\par }\pard \qj\fi360\keepn\widctlpar\adjustright {The user has entered the two-key abort command }{\outl\fs20 \u-3\'f0}{\b\fs20 .}{\fs20  }{(hold down the open-Apple key and then type a period). This does no harm to the program, it merely terminates compilation.\par }\pard \qj\keepn\widctlpar\adjustright {\par }{\b\f6\fs28 You cannot change languages from an included file\par }{\par }\pard \qj\fi360\widctlpar\adjustright {An attempt has been made to open another SRC file with a #append statement, but the file that contains the #append statement is an included file. If you are trying to do a multi-lingual compile, move the #append statement to the end of the C file that is passed to the compiler. If the file is supposed to be a C source file, change the language stamp using the Languages menu or the shell CHANGE command.\par }\pard \qj\widctlpar\adjustright {\par }\pard \keepn\widctlpar\adjustright {\b\f6\fs28 You cannot change languages with an include directive\par }\pard \qj\keepn\widctlpar\adjustright {\par }\pard \qj\fi360\widctlpar\adjustright {An attempt has been made to open another SRC file with a #include statement, but the file is not a C source file. If you are trying to do a multi-lingual compile, use the #append statement. If the file is supposed to be a C source file, change the language stamp using the Languages menu or the shell CHANGE command.\par }\pard \widctlpar\adjustright {\fs28 \sect }\sectd \sbkodd\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\f5\fs20 Appendix A:  Error Messages\par }}\pard\plain \widctlpar\adjustright \f4\cgrid {\b\fs48 Appendix B \endash  ANSI C\par }\pard \qj\widctlpar\adjustright {\pard\plain \qj\widctlpar\adjustright \v\f4\cgrid {\tc {\v }{\v Appendix B \endash  ANSI C\tcl1}}}{\v \par }\pard \widctlpar\adjustright {\par \par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ANSI C}}}{This appendix summarizes the differences between ORCA/C and ANSI C. For a complete description of the feature, see the manual.\par \par }\pard \qj\fi-360\li720\widctlpar\adjustright {\bullet \tab In ORCA/C, the following identifiers are reserved words.\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard \qj\fi-1800\li2520\widctlpar\brdrt\brdrs\brdrw15 \brdrb\brdrs\brdrw15 \adjustright {reserved word\tab use\par }\pard \qj\fi-1800\li2520\widctlpar\adjustright {\f6 asm}{\tab Used to create assembly language functions and to imbed assembly language code within a C function.\par }{\f6 comp}{\tab Used for SANE}{\pard\plain \qj\fi-1800\li2520\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v SANE}}}{ comp numbers.\par }{\f6 extended}{\tab Used for SANE extended numbers.\par }{\f6 inline}{\tab Used to declare functions called at a specific location with a given value in the X register. On the Apple\~II}{\fs20 GS}{, this is used to declare tool header files.\par }{\f6 pascal}{\tab Instructs the compiler to use Pascal calling conventions.\par }{\f6 segment}{\tab Used to place functions in a specific load segment.\par }\pard \qj\fi-360\li720\widctlpar\adjustright {\par \bullet \tab The #append directive works like #include, but does not return to the original source file.\par \par \bullet \tab There are several pragmas in ORCA/C. Pragmas are allowed by ANSI C, but none are required.\par \par \bullet \tab // comments are allowed.\par \par \bullet \tab A small number of ANSI C library functions are not included. This includes some variable argument I/O functions, a time function, and multi-character support.\par \par \bullet \tab The formatted I/O functions (e.g. printf) use %p as a format specifier for Pascal strings, not pointers.\par }\pard \widctlpar\adjustright {\fs28 \sect }\sectd \sbkodd\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\f5\fs20 Appendix C:  ORCA/C on the Apple\~II}{\f5\fs18 GS\par }}\pard\plain \widctlpar\adjustright \f4\cgrid {\b\fs48 Appendix C \endash  ORCA/C on the Apple\~II}{\b\fs36 GS}{\b\fs48 \par }\pard \qj\widctlpar\adjustright {\pard\plain \qj\widctlpar\adjustright \v\f4\fs20\cgrid {\tc {\v\fs20 }{\v Appendix C \endash  ORCA/C on the Apple\~II}{\v\fs20 GS}{\v \tcl1}}}{\v \par }\pard \widctlpar\adjustright {\par \par }\pard \qj\fi360\widctlpar\adjustright {\pard\plain \qj\fi360\widctlpar\adjustright \v\f4\cgrid {\xe {\v }{\v ANSI C}}}{This appendix summarizes the differences between MPW\~II}{\fs20 GS}{\~ORCA/C and the native implementation of ORCA/C on the Apple\~II}{\fs20 GS}{. For a complete description of any feature mentioned here, see the respective manuals.\par MPW\~II}{\fs20 GS}{ ORCA/C is a port of ORCA/C 2.0.3 for the Apple\~II}{\fs20 GS}{. Other than the differences listed in this appendix, the two compilers should be identical\emdash creating identical code from identical source, and even showing identical bugs.\par In general, new features you see here will eventually be available in ORCA/C for the Apple\~II}{\fs20 GS}{. The one big difference is that the MPW based compiler relaxes the ANSI standard whenever the compiler offers an option to enforce or ignore the standard, while the native Apple\~II}{\fs20 GS}{ compiler defaults to strict compliance with the standard. An explicit #pragma ignore at the start of each source file will cause both compilers to behave the same way.\par \par }\pard \qj\fi-640\li720\widctlpar\adjustright {\bullet \tab The inline directive (generally used for creating tool header files) has been extended in the MPW\~II}{\fs20 GS}{ compiler to allow calling functions that use C calling conventions.\par \par \bullet \tab The MPW\~II}{\fs20 GS}{ compiler allows enumerated constants as the first term of an inline directive.\par \par \bullet \tab When a #line directive is used, error messages in the MPW\~II}{\fs20 GS}{ compiler show the source file and line number set by the #line directive, not the source file and line number of the physical file.\par \par \bullet \tab All of the bits in the #pragma ignore directive default to 1 in the MPW\~II}{\fs20 GS}{ compiler, and to 0 in the Apple\~II}{\fs20 GS}{ compiler. This has the effect of relaxing the ANSI standard when possible on the MPW\~II}{\fs20 GS}{ compiler, and enforcing the ANSI standard strictly on the Apple\~II}{\fs20 GS}{ compiler.\par \par \bullet \tab The MPW\~II}{\fs20 GS}{ compiler accepts multi-byte character constants.\par \par \bullet \tab The MPW\~II}{\fs20 GS}{ compiler ignores spurious tokens after a #endif. (See #pragma ignore.)\par \par \bullet \tab The MPW\~II}{\fs20 GS}{ compiler allows // comments. (See #pragma ignore.)\par \par \bullet \tab The MPW\~II}{\fs20 GS}{ compiler supports the extended Apple character set (e.g. \u169\'a9, \u252\'9f, etc.). Characters that are obvious graphical equivalents of alphabetic characters, like \u231\'8d and \u238\'94, are allowed in identifiers. Characters that are abbreviations for mathematical symbols are supported as equivalents to the C tokens; for example, \u8800\'ad can be used instead of !=.\par }\pard \widctlpar\adjustright {\fs28 \sect }\sectd \sbkodd\cols2\colsx140\endnhere\titlepg\sectdefaultcl {\headerr \pard\plain \qr\widctlpar\adjustright \f4\cgrid {\f5\fs20 Index}{\f5\fs18 \par }}\pard\plain \qj\keepn\widctlpar\adjustright \f4\cgrid {\pard\plain \qj\keepn\widctlpar\adjustright \v\f4\cgrid {\tc {\v }{\v Index\tcl1}}}{\v \par }\pard \fi-360\li360\keepn\widctlpar\adjustright {\b Special Characters\par }{\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {\field{\*\fldinst { INDEX  }}{\fldrslt {~ operator 84, 88\par ^ operator 84\par ! operator 83, 88\par != operator 83\par #append }{\b 25}{\par #define }{\b 21}{\par #elif }{\b 28}{\par #else }{\b 27}{\par #endif , 27\par #error 29\par #if }{\b 26}{-}{\b 27}{\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {expressions 27\par nesting 27\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {#ifdef }{\b 28}{\par #ifndef }{\b 28}{\par #include }{\b 24}{-}{\b 25}{, 39, 47\par #line 29\par #pragma 30\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {cda }{\b 30}{\par cdev }{\b 30}{\par databank }{\b 31}{\par debug }{\b 31}{\par expand }{\b 32}{\par float }{\b 33}{\par ignore }{\b 33}{\par keep }{\b 34}{\par lint }{\b 34}{\par memorymodel }{\b 35}{\par nba }{\b 36}{\par nda }{\b 36}{\par noroot }{\b 37}{\par optimize }{\b 37}{\par path }{\b 39}{\par rtl }{\b 39}{\par stacksize }{\b 40}{\par toolparms }{\b 40}{\par xcmd }{\b 41}{\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {#undef }{\b 23}{, 24\par % operator 80\par %= operator 85\par & operator 83, 86\par && operator 83\par &= operator 85\par * operator 80, 86, 88\par *= operator 85\par + operator 79, 81, 88\par ++ operator 78, 81\par += operator 85\par , operator 86\par - operator 79, 81, 88\par -- operator 78, 81\par -= operator 85\par / operator 80\par /= operator 85\par 68881 33, 43, 88\par < operator 83\par << operator 84, 88\par <<= operator 85\par <= operator 83\par ^= operator 85\par = operator 84, 87\par == operator 83\par > operator 83\par >= operator 83\par >> operator 84, 88\par >>= operator 85\par ? operator 87, 88\par _exit 116\par _tolower 158\par _toupper 158\par __DATE__ 24\par __FILE__ 24\par __LINE__ 24\par __ORCAC__ 24\par __STDC__ 24, 26\par __TIME__ 24\par __VERSION__ 24\par | operator 83\par |= operator 85\par || operator 83\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard \fi-360\li360\keepn\widctlpar\adjustright {\b A\par }{\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {\field{\*\fldinst { INDEX  }}{\fldrslt {abort 116\par abs 107\par acos 107\par alias command 46\par ANSI C 24, 175, 177\par APW 46, 173\par APW C 28, 113\par arctan 108\par argc 45\par argv 45\par arrays 35, }{\b 54}{-}{\b 55}{, 61, 75-76, 84, 91\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {as pointers 75\par indexing 75\par initialization 60\par memory requirements 55\par multiple subscripts 54\par size limits 55\par storage 55\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {ASCII character set 15\par asctime 113\par asin 108\par asm statement 66, 100\par assembly language 7, 25, 43, 46, 66, 100\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {accessing global variables 9\par calling C procedures and functions 10\par passing parameters 8\par returning function values 8\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {assert 108\par assignment conversions 87\par assignments\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {compound 85\par multiple 86\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {atan 108\par atan2 108\par atexit 109\par atof 109\par atoi 109\par atol 109\par auto storage class 49\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard \fi-360\li360\keepn\widctlpar\adjustright {\b B\par }{\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {\field{\*\fldinst { INDEX  }}{\fldrslt {binary conversion rules 88\par bit fields 57-58\par break statement 94, 98\par bsearch 110\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard \fi-360\li360\keepn\widctlpar\adjustright {\b C\par }{\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {\field{\*\fldinst { INDEX  }}{\fldrslt {c2pstr 110\par calloc 140\par case label 97, 98\par case sensitivity 11, 72\par cast 89\par CDev 30\par ceil 111\par cfree 127\par char 43, 51, 89\par character constants 15, 17\par character set }{\b 11}{\par characters\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {formatting 124\par scanning 130\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {chmod 111\par clalloc 140\par classic desk accessories 30\par clearerr 118\par clock 112\par close 112\par command line 45\par comments 19\par comp 44, 51\par compilation errors 161\par compiler directives 30\par compound statement 93\par conditional compilation 26\par const 52, 55\par constants 11, 53, 75\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {character 15\par floating-point 18\par integer 13, 14, 15\par long integer 14, 15\par strings 16\par unsigned integer 14, 15\par unsigned long integer 14, 15\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {continuation lines 13, 16, 21\par continue statement 94, 98\par control characters 17\par control panel 30\par conversions 87\par cos 112\par cosh 113\par crashes 38\par creat 113\par ctime 113\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard \fi-360\li360\keepn\widctlpar\adjustright {\b D\par }{\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {\field{\*\fldinst { INDEX  }}{\fldrslt {data formats 43\par databank 31\par date 24\par debugger 31\par declarations 93\par default label 97, 98\par defined operator 27\par difftime 114\par direct page 40\par direct selection 77\par div 114\par do statement 95, 98\par double 43, 89, 90\par dup 115\par dynamic segments 100\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard \fi-360\li360\keepn\widctlpar\adjustright {\b E\par }{\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {\field{\*\fldinst { INDEX  }}{\fldrslt {EDOM 107, 108, 139, 143\par else statement 96\par enum 53, 63\par enumerations\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {initialization 60\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {EOF 115\par }\pard \s29\fi-180\li180\widctlpar\adjustright {ERANGE 113, 117, 127, 139, 143, 149, 150, 154, 155, 156\par }\pard \s29\widctlpar\adjustright {errno }{\b 116}{, 118, 121, 154, 155\par errors 29, 32, 33, 116\par escape sequences }{\b 17}{\par exit 116\par exp 117\par expressions 53, 73, 94\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {syntax 73\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {extended 44, 89, 90\par extended characters 11\par extern 49, 61\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard \fi-360\li360\keepn\widctlpar\adjustright {\b F\par }{\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {\field{\*\fldinst { INDEX  }}{\fldrslt {fabs 107\par fclose 117\par fcntl 117\par feof 118\par ferror 118\par fflush 118\par fgetc 118\par fgetpos 119\par fgets 119\par file names 24, 29\par float 43, 89, 90\par floating-point 33, 43, 51, 88, 89\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {constants 18\par formatting 124\par initialization 60\par scanning 130\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {floor 111\par fmod 120\par fopen 120\par for statement 95, 98\par fprintf 121\par fputc 126\par fputs 126\par fread 126\par free 127\par freopen 120\par frexp 127\par fscanf 127\par fseek 132\par fsetpos 119\par ftell 132\par function prototypes 68\par functions 51, 52, 65, 76, 88, 91, 94\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {asm 66\par calling through a pointer 76\par declaration 65\par extern 66\par inline 66\par parameters - see parameters 67\par return type 62, 65\par return value 98\par returning a value 72\par static 66\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {fwrite 133\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard \fi-360\li360\keepn\widctlpar\adjustright {\b G\par }{\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {\field{\*\fldinst { INDEX  }}{\fldrslt {getc 118\par getchar 118\par getenv 133\par gets 119\par gmtime 138\par goto statement 94, 96\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard \fi-360\li360\keepn\widctlpar\adjustright {\b H\par }{\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {\field{\*\fldinst { INDEX  }}{\fldrslt {header files 25\par }\pard \s29\fi-180\li180\widctlpar\adjustright {hexadecimal 15, 17, 75, 100, 123, 129, 138, 158\par }\pard \s29\widctlpar\adjustright {HUGE_VAL 154\par HyperCard 41\par HyperStudio 36\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard \fi-360\li360\keepn\widctlpar\adjustright {\b I\par }{\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {\field{\*\fldinst { INDEX  }}{\fldrslt {I/O redirection 46\par identifiers 11\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {case sensitivity 11\par length 11\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {if statement 96\par indirect selection 77\par initializers }{\b 59}{-}{\b 61}{, 93\par Inits 39\par inline 66\par Innovative Systems 43\par int 43, 51, 89\par integers 43, 51, 89, 90\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {constants 13, 14, 15\par formatting 123\par initialization 59\par scanning 129\par storage 43\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {interface files 46\par isalnum 133\par isalpha 134\par isascii 134\par iscntrl 134\par iscsym 135\par iscsymf 135\par isdigit 135\par isgraph 136\par islower 136\par isodigit 136\par isprint 136\par ispunct 137\par isspace 137\par isupper 137\par isxdigit 138\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard \fi-360\li360\keepn\widctlpar\adjustright {\b K\par }{\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {\field{\*\fldinst { INDEX  }}{\fldrslt {keyboard input 119\par }\pard\plain \fi-360\li360\keepn\widctlpar\adjustright \f4\cgrid }}\pard\plain \fi-360\li360\keepn\widctlpar\adjustright \f4\cgrid {\b L\par }{\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {\field{\*\fldinst { INDEX  }}{\fldrslt {l-values 74\par labels 96\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {scope 63\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {labs 107\par large memory model 35, 99\par ldexp 127\par ldiv 114\par libraries 35, 47, 49, 103\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {see also toolbox \par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {line numbers 24, 29\par link errors 161\par linker 161\par localtime 138\par log 139\par log10 139\par long 43, 51, 89\par long integers\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {constants 14, 15\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {longjmp 148\par lseek 139\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard \fi-360\li360\keepn\widctlpar\adjustright {\b M\par }{\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {\field{\*\fldinst { INDEX  }}{\fldrslt {macro stringization 23\par macros 21-24, 25\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {defined operator 27\par expanding 32\par in if statements\par nesting 23\par parameters 22\par predefined 24\par scope 63\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {main 45\par malloc 140\par memchr 140\par memcmp 141\par memcpy 141\par memmove 141\par memory\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {see also large memory model \par see also small memory compiler \par see also small memory model \par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {memory manager 140\par memory model 99\par memset 141\par mktime 138\par mlalloc 140\par modf 142\par MPW\~IIGS Assembler 7\par multiple assignments 86\par multiple languages 25\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard \fi-360\li360\keepn\widctlpar\adjustright {\b N\par }{\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {\field{\*\fldinst { INDEX  }}{\fldrslt {New Button Actions 36\par new desk accessories 36\par newline character 17, 120\par null character 16, 18\par null statement 94\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard \fi-360\li360\keepn\widctlpar\adjustright {\b O\par }{\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {\field{\*\fldinst { INDEX  }}{\fldrslt {object files 34, 46\par }\pard \s29\fi-180\li180\widctlpar\adjustright {octal 14, 15, 17, 18, 75, 100, 123, 129, 136, 162\par }\pard \s29\widctlpar\adjustright {offsetof 142\par open 142\par operator precedence 74, 78\par optimizer 37\par ORCA/M 46, 173\par ORCA/Pascal 46\par overloading classes 63\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard \fi-360\li360\keepn\widctlpar\adjustright {\b P\par }{\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {\field{\*\fldinst { INDEX  }}{\fldrslt {p-strings 17, 18, 110\par p2cstr 110\par parameters 32, 34, 62, 67-70, 88, 159\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {checking 68\par function prototypes 68\par passing 8, 70\par variable length lists 69\par void prototypes 68\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {parentheses 78\par Pascal 46\par pascal qualifier 41, }{\b 72}{, 169\par perror 116\par pointers 44, 55-56, 84, 89, 90, 91\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {initialization 60\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {pow 143\par pragma 30\par precompiled headers 25\par preprocessor 21-41\par preprocessor macros\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {see macros \par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {printf 121\par profiler 32\par putc 126\par putchar 126\par puts 126\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard \fi-360\li360\keepn\widctlpar\adjustright {\b Q\par }{\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {\field{\*\fldinst { INDEX  }}{\fldrslt {qsort 144\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard \fi-360\li360\keepn\widctlpar\adjustright {\b R\par }{\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {\field{\*\fldinst { INDEX  }}{\fldrslt {raise 144\par rand 144\par range checking 31\par read 145\par realloc 145\par register 50\par relalloc 145\par remove 146\par rename 146\par reserved symbols }{\b 12}{\par reserved words }{\b 12}{\par return key 120\par return statement 94, 98\par rewind 132\par root file 37\par run-time errors 32, 116, 161\par run-time stack 35, 40\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard \fi-360\li360\keepn\widctlpar\adjustright {\b S\par }{\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {\field{\*\fldinst { INDEX  }}{\fldrslt {SANE 18, 33, 40, 43, 44, 88, 175\par scanf 127\par scope 62-64, 93\par segment statement 35, 99\par separate compilation 46, 47, 49, 66\par setbuf 147\par setjmp 148\par setvbuf 147\par shell\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {variables 46\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {shell window 46\par short 43, 51, 89\par signal 148\par signed 43\par sin 149\par sinh 149\par sizeof operator 82, 91\par small memory compiler 26, 38\par small memory model 35, 99\par source-level debugger 31\par sprintf 121\par sqrt 150\par srand 144\par sscanf 127\par stack overflow 31\par stack repair code 32, 38, 69, 159\par stack size 31\par standard input 119\par standard libraries 24\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {see also libraries \par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {standard output 126\par startdesk 40\par startgraph 40\par statements 94\par static 50\par static segments 99\par stderr 150\par stdin 150\par stdout 150\par storage class 49\par strcat 151\par strchr 151\par strcmp 152\par strcpy 152\par strcspn 153\par strerror 116\par string constants 16, 17\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {trigraphs 12\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {strings }{\b 16}{\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {continuation 16\par formatting 124\par in expressions 16\par maximum length 17\par p-strings 18\par scanning 130, 131\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {strlen 153\par strncat 151\par strncmp 152\par strncpy 152\par strpbrk 153\par strpos 151\par strrchr 151\par strrpbrk 153\par strrpos 151\par strspn 153\par strstr 154\par strtod 154\par strtok 155\par strtol 154\par strtoul 154\par structures 35, }{\b 56}{-}{\b 58}{, 63, 77, 84\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {accessing elements 57\par assigning 57\par in functions 57\par initialization 61\par size 56\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {switch statement 94, 97, 98\par sym files 25\par SysCharErrout 103\par SysCharOut 103\par SysIOShutDown 103\par SysIOStartup 104\par SysKeyAvail 104\par SysKeyin 104\par SysPutback 104\par system 156\par SystemEnvironmentInit 104\par SystemError 105\par SystemErrorLocation 105\par SystemMinStack 105\par SystemMMShutDown 106\par SystemPrintError 106\par SystemQuitFlags 106\par SystemQuitPath 106\par SystemSANEInit 106\par SystemSANEShutDown 106\par SystemUserID 107\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard \fi-360\li360\keepn\widctlpar\adjustright {\b T\par }{\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {\field{\*\fldinst { INDEX  }}{\fldrslt {tan 156\par tanh 156\par terminal errors 173\par terms 74\par time 24, 157\par tmpfile 157\par tmpnam 157\par toascii 157\par toint 158\par token merging 24\par tokens }{\b 11}{, 19, 27\par tolower 158\par toolbox 24, 40, 47, 66\par toupper 158\par trace backs 32\par trigraphs }{\b 12}{\par type casting 89\par type specifier }{\b 51}{-}{\b 53}{\par typedef 50, 52\par types 43\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard \fi-360\li360\keepn\widctlpar\adjustright {\b U\par }{\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {\field{\*\fldinst { INDEX  }}{\fldrslt {unary conversion rules 88\par ungetc 159\par unions 35, }{\b 59}{, 63, 77, 84\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {accessing elements 59\par in functions 59\par initialization 61\par size 59\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {unsigned 43, 89\par unsigned integers\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {constants 14, 15\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {unsigned long integers\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {constants 14, 15\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard \fi-360\li360\keepn\widctlpar\adjustright {\b V\par }{\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {\field{\*\fldinst { INDEX  }}{\fldrslt {variable scope\par }\pard\plain \s28\li360\widctlpar\adjustright \f4\cgrid {see scope \par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {variables 51, 75\par va_arg 69, 159\par va_end 159\par va_start 159\par vfprintf 160\par void 52, 61, 91\par volatile 52, 55\par vprintf 160\par vsprintf 160\par }\pard\plain \fi-360\li360\keepn\widctlpar\adjustright \f4\cgrid }}\pard\plain \fi-360\li360\keepn\widctlpar\adjustright \f4\cgrid {\b W\par }{\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {\field{\*\fldinst { INDEX  }}{\fldrslt {while statement 94, 95, 96, 98\par white space 19\par write 160\par }\pard\plain \widctlpar\adjustright \f4\cgrid }}\pard\plain \widctlpar\adjustright \f4\cgrid {\par }\pard \fi-360\li360\keepn\widctlpar\adjustright {\b X\par }{\par }\pard\plain \s29\widctlpar\adjustright \f4\cgrid {\field{\*\fldinst { INDEX  }}{\fldrslt {XCFN 41\par XCMD 41\par }}}\pard\plain \s29\widctlpar\adjustright \f4\cgrid {\par }}