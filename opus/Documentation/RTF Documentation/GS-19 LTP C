{\rtf1\mac\ansicpg10000\uc1 \deff0\deflang1033\deflangfe1033{\upr{\fonttbl{\f0\fnil\fcharset256\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fnil\fcharset256\fprq2{\*\panose 020b0604020202020204}Arial;}{\f2\fnil\fcharset256\fprq2{\*\panose 02070309020205020404}Courier New;}{\f3\fnil\fcharset2\fprq2{\*\panose 02000500000000000000}Symbol;}{\f4\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Times;}{\f5\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Helvetica;}{\f6\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Courier;}{\f7\fnil\fcharset256\fprq2{\*\panose 020b0503030404040204}Geneva;}{\f8\froman\fcharset77\fprq2{\*\panose 00000000000000000000}Tms Rmn;}{\f9\fswiss\fcharset77\fprq2{\*\panose 00000000000000000000}Helv;}{\f10\froman\fcharset77\fprq2{\*\panose 00000000000000000000}MS Serif;}{\f11\fswiss\fcharset77\fprq2{\*\panose 00000000000000000000}MS Sans Serif;}{\f12\fnil\fcharset256\fprq2{\*\panose 02020502060305060204}New York;}{\f13\fswiss\fcharset77\fprq2{\*\panose 00000000000000000000}System;}{\f14\fnil\fcharset2\fprq2{\*\panose 05020102010804080708}Wingdings;}{\f15\froman\fcharset256\fprq1{\*\panose 00000000000000000000}FE Roman font face;}{\f16\fmodern\fcharset256\fprq1{\*\panose 00000000000000000000}FE Modern font face;}{\f17\froman\fcharset256\fprq1{\*\panose 00000000000000000000}FE Truetype Roman font face;}{\f18\fmodern\fcharset256\fprq1{\*\panose 00000000000000000000}FE Truetype Modern font face;}{\f19\froman\fcharset77\fprq2{\*\panose 00000000000000000000}Century;}{\f20\fnil\fcharset256\fprq2{\*\panose 020b0a06030101010103}Abadi MT Condensed Extra Bold;}{\f21\fnil\fcharset256\fprq2{\*\panose 020b0306030101010103}Abadi MT Condensed Light;}{\f22\fnil\fcharset256\fprq2{\*\panose 020b0509000000000004}Andale Mono;}{\f23\fnil\fcharset256\fprq2{\*\panose 05000000000000000000}Animals 1;}{\f24\fnil\fcharset256\fprq2{\*\panose 020b0a04020102020204}Arial Black;}{\f25\fnil\fcharset256\fprq2{\*\panose 020b0506020202030204}Arial Narrow;}{\f26\fnil\fcharset256\fprq2{\*\panose 020f0704030504030204}Arial Rounded MT Bold;}{\f27\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}AvantGarde Bk BT;}{\f28\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}AvantGarde BkOb BT;}{\f29\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}AvantGarde Dm BT;}{\f30\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}AvantGarde DmOb BT;}{\f31\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}AvantGarde Md BT;}{\f32\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}AvantGarde MdOb BT;}{\f33\fnil\fcharset256\fprq2{\*\panose 020b0603050302020204}Balloons;}{\f34\fnil\fcharset256\fprq2{\*\panose 02020602080505020303}Baskerville Old Face;}{\f35\fnil\fcharset256\fprq2{\*\panose 04030905020b02020c02}Bauhaus 93;}{\f36\fnil\fcharset256\fprq2{\*\panose 02020503060305020303}Bell MT;}{\f37\fnil\fcharset256\fprq2{\*\panose 02050806060905020404}Bernard MT Condensed;}{\f38\fnil\fcharset256\fprq2{\*\panose 02040602050305030304}Book Antiqua;}{\f39\fnil\fcharset256\fprq2{\*\panose 02050604050505020204}Bookman Old Style;}{\f40\fnil\fcharset256\fprq2{\*\panose 04030b070d0b02020403}Braggadocio;}{\f41\fnil\fcharset256\fprq2{\*\panose 020b0903060703020204}Britannic Bold;}{\f42\fnil\fcharset256\fprq2{\*\panose 03060802040406070304}Brush Script MT;}{\f43\fnil\fcharset256\fprq2{\*\panose 02040603050505030304}Calisto MT;}{\f44\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Capitals;}{\f45\fnil\fcharset256\fprq2{\*\panose 020b0502020202020204}Century Gothic;}{\f46\fnil\fcharset256\fprq2{\*\panose 02040604050505020304}Century Schoolbook;}{\f47\fnil\fcharset256\fprq2{\*\panose 00000000000000000000}Charcoal;}{\f48\fnil\fcharset256\fprq2{\*\panose 020b0806080604040204}Chicago;}{\f49\fnil\fcharset256\fprq2{\*\panose 04020805060202030203}Colonna MT;}{\f50\fnil\fcharset256\fprq2{\*\panose 030f0702030302020204}Comic Sans MS;}{\f51\fnil\fcharset256\fprq2{\*\panose 020b0603050302020204}CommonBullets;}{\f52\fnil\fcharset256\fprq2{\*\panose 0208090404030b020404}Cooper Black;}{\f53\fnil\fcharset256\fprq2{\*\panose 020e0705020206020404}Copperplate Gothic Bold;}{\f54\fnil\fcharset256\fprq2{\*\panose 020e0507020206020404}Copperplate Gothic Light;}{\f55\fnil\fcharset256\fprq2{\*\panose 04020505020e03040504}Desdemona;}{\f56\fnil\fcharset256\fprq2{\*\panose 00000400000000000000}Disney Print;}{\f57\fnil\fcharset256\fprq2{\*\panose 02090707080505020304}Engravers MT;}{\f58\fnil\fcharset256\fprq2{\*\panose 020b0504020202050204}Eurostile;}{\f59\fnil\fcharset256\fprq2{\*\panose 020b0603050302020204}Festive;}{\f60\fnil\fcharset256\fprq2{\*\panose 0204060206030a020304}Footlight MT Light;}{\f61\fnil\fcharset256\fprq2{\*\panose 05000000000000000000}FrenchScript;}{\f62\fnil\fcharset256\fprq2{\*\panose 00000000000000000000}Gadget;}{\f63\fnil\fcharset256\fprq2{\*\panose 02020404030301010803}Garamond;}{\f64\fnil\fcharset256\fprq2{\*\panose 02040502050405020303}Georgia;}{\f65\fnil\fcharset256\fprq2{\*\panose 020b0a04020203020204}Gill Sans Ultra Bold;}{\f66\fnil\fcharset256\fprq2{\*\panose 02030808020601010101}Gloucester MT Extra Condensed;}{\f67\fnil\fcharset256\fprq2{\*\panose 00000400000000000000}GME Title-Regular;}{\f68\fnil\fcharset256\fprq2{\*\panose 02020502050305020303}Goudy Old Style;}{\f69\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Grolier 1;}{\f70\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Grolier 2;}{\f71\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}Grolier Bd 1;}{\f72\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}Grolier Bd 2;}{\f73\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}Grolier BdIt 1;}{\f74\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}Grolier BdIt 2;}{\f75\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Grolier It 1;}{\f76\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Grolier It 2;}{\f77\fnil\fcharset256\fprq2{\*\panose 04040505050a02020702}Harrington;}{\f78\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Helvetica Black;}{\f79\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Helvetica Compressed;}{\f80\fnil\fcharset256\fprq2{\*\panose 020b0806030902050204}Impact;}{\f81\fnil\fcharset256\fprq2{\*\panose 04020605060303030202}Imprint MT Shadow;}{\f82\fnil\fcharset256\fprq2{\*\panose 00000400000000000000}Inso GI1 SILDoulosL;}{\f83\fnil\fcharset256\fprq2{\*\panose 00000400000000000000}Inso GI1 SILDoulosL I;}{\f84\fnil\fcharset256\fprq2{\*\panose 00000400000000000000}Inso If1 SILDoulosL;}{\f85\fnil\fcharset256\fprq2{\*\panose 00000400000000000000}Inso If1 SILDoulosL I;}{\f86\fnil\fcharset256\fprq2{\*\panose 03010101010101010101}Kidprint;}{\f87\fnil\fcharset256\fprq2{\*\panose 040307050d0c02020703}Kino MT;}{\f88\fnil\fcharset256\fprq2{\*\panose 00000000000000000000}Lucida Blackletter;}{\f89\fnil\fcharset256\fprq2{\*\panose 02040602050505020304}Lucida Bright;}{\f90\fnil\fcharset256\fprq2{\*\panose 03010101010101010101}Lucida Calligraphy;}{\f91\fnil\fcharset256\fprq2{\*\panose 02060602050505020204}Lucida Fax;}{\f92\fnil\fcharset256\fprq2{\*\panose 03010101010101010101}Lucida Handwriting;}{\f93\fnil\fcharset256\fprq2{\*\panose 020b0602030504020204}Lucida Sans;}{\f94\fnil\fcharset256\fprq2{\*\panose 020b0509030504030204}Lucida Sans Typewriter;}{\f95\fnil\fcharset256\fprq2{\*\panose 020b0602060201020203}Lydian MT;}{\f96\fnil\fcharset256\fprq2{\*\panose 03020802060602070202}Matura MT Script Capitals;}{\f97\fnil\fcharset256\fprq2{\*\panose 02040503050201020203}Minion Web;}{\f98\fnil\fcharset256\fprq2{\*\panose 03090702030407020403}Mistral;}{\f99\fnil\fcharset256\fprq2{\*\panose 02070704070505020303}Modern No. 20;}{\f100\fnil\fcharset256\fprq2{\*\panose 020b0509030404040204}Monaco;}{\f101\fnil\fcharset256\fprq2{\*\panose 03010101010201010101}Monotype Corsiva;}{\f102\fnil\fcharset2\fprq2{\*\panose 01010601010101010101}Monotype Sorts;}{\f103\fnil\fcharset256\fprq2{\*\panose 020b0509000000000004}Monotype.com;}{\f104\fnil\fcharset2\fprq2{\*\panose 02000500000000000000}MT Extra;}{\f105\fnil\fcharset256\fprq2{\*\panose 020b0504020203020204}News Gothic MT;}{\f106\fnil\fcharset256\fprq2{\*\panose 04050602080702020203}Onyx;}{\f107\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Palatino;}{\f108\fnil\fcharset256\fprq2{\*\panose 02020502060505020804}Perpetua Titling MT;}{\f109\fnil\fcharset256\fprq2{\*\panose 040506030a0602020202}Playbill;}{\f110\fnil\fcharset256\fprq2{\*\panose 02060603020205020403}Rockwell;}{\f111\fnil\fcharset256\fprq2{\*\panose 02060903040505020403}Rockwell Extra Bold;}{\f112\fnil\fcharset256\fprq2{\*\panose 00000000000000000000}Sand;}{\f113\fnil\fcharset256\fprq2{\*\panose 020b0603050302020204}SportsFigures;}{\f114\fnil\fcharset256\fprq2{\*\panose 040409050d0802020404}Stencil;}{\f115\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}Swing;}{\f116\fnil\fcharset256\fprq2{\*\panose 020b0604030504040204}Tahoma;}{\f117\fnil\fcharset256\fprq2{\*\panose 00000000000000000000}Techno;}{\f118\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Textile;}{\f119\fnil\fcharset256\fprq2{\*\panose 020b0603020202020204}Trebuchet MS;}{\f120\fnil\fcharset256\fprq2{\*\panose 020b0604030504040204}Verdana;}{\f121\fnil\fcharset2\fprq2{\*\panose 05030102010509060703}Webdings;}{\f122\fnil\fcharset256\fprq2{\*\panose 020a0a07050505020404}Wide Latin;}{\f123\fnil\fcharset2\fprq2{\*\panose 05020102010507070707}Wingdings 2;}{\f124\fnil\fcharset2\fprq2{\*\panose 05040102010807070707}Wingdings 3;}{\f125\fnil\fcharset2\fprq2 Zapf Dingbats;}{\f126\fnil\fcharset256\fprq2{\*\panose 05000000000000000000}ZapfDingbats BT;}}{\*\ud{\fonttbl{\f0\fnil\fcharset256\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fnil\fcharset256\fprq2{\*\panose 020b0604020202020204}Arial;}{\f2\fnil\fcharset256\fprq2{\*\panose 02070309020205020404}Courier New;}{\f3\fnil\fcharset2\fprq2{\*\panose 02000500000000000000}Symbol;}{\f4\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Times;}{\f5\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Helvetica;}{\f6\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Courier;}{\f7\fnil\fcharset256\fprq2{\*\panose 020b0503030404040204}Geneva;}{\f8\froman\fcharset77\fprq2{\*\panose 00000000000000000000}Tms Rmn;}{\f9\fswiss\fcharset77\fprq2{\*\panose 00000000000000000000}Helv;}{\f10\froman\fcharset77\fprq2{\*\panose 00000000000000000000}MS Serif;}{\f11\fswiss\fcharset77\fprq2{\*\panose 00000000000000000000}MS Sans Serif;}{\f12\fnil\fcharset256\fprq2{\*\panose 02020502060305060204}New York;}{\f13\fswiss\fcharset77\fprq2{\*\panose 00000000000000000000}System;}{\f14\fnil\fcharset2\fprq2{\*\panose 05020102010804080708}Wingdings;}{\f15\froman\fcharset256\fprq1{\*\panose 00000000000000000000}FE Roman font face;}{\f16\fmodern\fcharset256\fprq1{\*\panose 00000000000000000000}FE Modern font face;}{\f17\froman\fcharset256\fprq1{\*\panose 00000000000000000000}FE Truetype Roman font face;}{\f18\fmodern\fcharset256\fprq1{\*\panose 00000000000000000000}FE Truetype Modern font face;}{\f19\froman\fcharset77\fprq2{\*\panose 00000000000000000000}Century;}{\f20\fnil\fcharset256\fprq2{\*\panose 020b0a06030101010103}Abadi MT Condensed Extra Bold;}{\f21\fnil\fcharset256\fprq2{\*\panose 020b0306030101010103}Abadi MT Condensed Light;}{\f22\fnil\fcharset256\fprq2{\*\panose 020b0509000000000004}Andale Mono;}{\f23\fnil\fcharset256\fprq2{\*\panose 05000000000000000000}Animals 1;}{\f24\fnil\fcharset256\fprq2{\*\panose 020b0a04020102020204}Arial Black;}{\f25\fnil\fcharset256\fprq2{\*\panose 020b0506020202030204}Arial Narrow;}{\f26\fnil\fcharset256\fprq2{\*\panose 020f0704030504030204}Arial Rounded MT Bold;}{\f27\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}AvantGarde Bk BT;}{\f28\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}AvantGarde BkOb BT;}{\f29\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}AvantGarde Dm BT;}{\f30\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}AvantGarde DmOb BT;}{\f31\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}AvantGarde Md BT;}{\f32\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}AvantGarde MdOb BT;}{\f33\fnil\fcharset256\fprq2{\*\panose 020b0603050302020204}Balloons;}{\f34\fnil\fcharset256\fprq2{\*\panose 02020602080505020303}Baskerville Old Face;}{\f35\fnil\fcharset256\fprq2{\*\panose 04030905020b02020c02}Bauhaus 93;}{\f36\fnil\fcharset256\fprq2{\*\panose 02020503060305020303}Bell MT;}{\f37\fnil\fcharset256\fprq2{\*\panose 02050806060905020404}Bernard MT Condensed;}{\f38\fnil\fcharset256\fprq2{\*\panose 02040602050305030304}Book Antiqua;}{\f39\fnil\fcharset256\fprq2{\*\panose 02050604050505020204}Bookman Old Style;}{\f40\fnil\fcharset256\fprq2{\*\panose 04030b070d0b02020403}Braggadocio;}{\f41\fnil\fcharset256\fprq2{\*\panose 020b0903060703020204}Britannic Bold;}{\f42\fnil\fcharset256\fprq2{\*\panose 03060802040406070304}Brush Script MT;}{\f43\fnil\fcharset256\fprq2{\*\panose 02040603050505030304}Calisto MT;}{\f44\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Capitals;}{\f45\fnil\fcharset256\fprq2{\*\panose 020b0502020202020204}Century Gothic;}{\f46\fnil\fcharset256\fprq2{\*\panose 02040604050505020304}Century Schoolbook;}{\f47\fnil\fcharset256\fprq2{\*\panose 00000000000000000000}Charcoal;}{\f48\fnil\fcharset256\fprq2{\*\panose 020b0806080604040204}Chicago;}{\f49\fnil\fcharset256\fprq2{\*\panose 04020805060202030203}Colonna MT;}{\f50\fnil\fcharset256\fprq2{\*\panose 030f0702030302020204}Comic Sans MS;}{\f51\fnil\fcharset256\fprq2{\*\panose 020b0603050302020204}CommonBullets;}{\f52\fnil\fcharset256\fprq2{\*\panose 0208090404030b020404}Cooper Black;}{\f53\fnil\fcharset256\fprq2{\*\panose 020e0705020206020404}Copperplate Gothic Bold;}{\f54\fnil\fcharset256\fprq2{\*\panose 020e0507020206020404}Copperplate Gothic Light;}{\f55\fnil\fcharset256\fprq2{\*\panose 04020505020e03040504}Desdemona;}{\f56\fnil\fcharset256\fprq2{\*\panose 00000400000000000000}Disney Print;}{\f57\fnil\fcharset256\fprq2{\*\panose 02090707080505020304}Engravers MT;}{\f58\fnil\fcharset256\fprq2{\*\panose 020b0504020202050204}Eurostile;}{\f59\fnil\fcharset256\fprq2{\*\panose 020b0603050302020204}Festive;}{\f60\fnil\fcharset256\fprq2{\*\panose 0204060206030a020304}Footlight MT Light;}{\f61\fnil\fcharset256\fprq2{\*\panose 05000000000000000000}FrenchScript;}{\f62\fnil\fcharset256\fprq2{\*\panose 00000000000000000000}Gadget;}{\f63\fnil\fcharset256\fprq2{\*\panose 02020404030301010803}Garamond;}{\f64\fnil\fcharset256\fprq2{\*\panose 02040502050405020303}Georgia;}{\f65\fnil\fcharset256\fprq2{\*\panose 020b0a04020203020204}Gill Sans Ultra Bold;}{\f66\fnil\fcharset256\fprq2{\*\panose 02030808020601010101}Gloucester MT Extra Condensed;}{\f67\fnil\fcharset256\fprq2{\*\panose 00000400000000000000}GME Title-Regular;}{\f68\fnil\fcharset256\fprq2{\*\panose 02020502050305020303}Goudy Old Style;}{\f69\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Grolier 1;}{\f70\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Grolier 2;}{\f71\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}Grolier Bd 1;}{\f72\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}Grolier Bd 2;}{\f73\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}Grolier BdIt 1;}{\f74\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}Grolier BdIt 2;}{\f75\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Grolier It 1;}{\f76\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Grolier It 2;}{\f77\fnil\fcharset256\fprq2{\*\panose 04040505050a02020702}Harrington;}{\f78\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Helvetica Black;}{\f79\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Helvetica Compressed;}{\f80\fnil\fcharset256\fprq2{\*\panose 020b0806030902050204}Impact;}{\f81\fnil\fcharset256\fprq2{\*\panose 04020605060303030202}Imprint MT Shadow;}{\f82\fnil\fcharset256\fprq2{\*\panose 00000400000000000000}Inso GI1 SILDoulosL;}{\f83\fnil\fcharset256\fprq2{\*\panose 00000400000000000000}Inso GI1 SILDoulosL I;}{\f84\fnil\fcharset256\fprq2{\*\panose 00000400000000000000}Inso If1 SILDoulosL;}{\f85\fnil\fcharset256\fprq2{\*\panose 00000400000000000000}Inso If1 SILDoulosL I;}{\f86\fnil\fcharset256\fprq2{\*\panose 03010101010101010101}Kidprint;}{\f87\fnil\fcharset256\fprq2{\*\panose 040307050d0c02020703}Kino MT;}{\f88\fnil\fcharset256\fprq2{\*\panose 00000000000000000000}Lucida Blackletter;}{\f89\fnil\fcharset256\fprq2{\*\panose 02040602050505020304}Lucida Bright;}{\f90\fnil\fcharset256\fprq2{\*\panose 03010101010101010101}Lucida Calligraphy;}{\f91\fnil\fcharset256\fprq2{\*\panose 02060602050505020204}Lucida Fax;}{\f92\fnil\fcharset256\fprq2{\*\panose 03010101010101010101}Lucida Handwriting;}{\f93\fnil\fcharset256\fprq2{\*\panose 020b0602030504020204}Lucida Sans;}{\f94\fnil\fcharset256\fprq2{\*\panose 020b0509030504030204}Lucida Sans Typewriter;}{\f95\fnil\fcharset256\fprq2{\*\panose 020b0602060201020203}Lydian MT;}{\f96\fnil\fcharset256\fprq2{\*\panose 03020802060602070202}Matura MT Script Capitals;}{\f97\fnil\fcharset256\fprq2{\*\panose 02040503050201020203}Minion Web;}{\f98\fnil\fcharset256\fprq2{\*\panose 03090702030407020403}Mistral;}{\f99\fnil\fcharset256\fprq2{\*\panose 02070704070505020303}Modern No. 20;}{\f100\fnil\fcharset256\fprq2{\*\panose 020b0509030404040204}Monaco;}{\f101\fnil\fcharset256\fprq2{\*\panose 03010101010201010101}Monotype Corsiva;}{\f102\fnil\fcharset2\fprq2{\*\panose 01010601010101010101}Monotype Sorts;}{\f103\fnil\fcharset256\fprq2{\*\panose 020b0509000000000004}Monotype.com;}{\f104\fnil\fcharset2\fprq2{\*\panose 02000500000000000000}MT Extra;}{\f105\fnil\fcharset256\fprq2{\*\panose 020b0504020203020204}News Gothic MT;}{\f106\fnil\fcharset256\fprq2{\*\panose 04050602080702020203}Onyx;}{\f107\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Palatino;}{\f108\fnil\fcharset256\fprq2{\*\panose 02020502060505020804}Perpetua Titling MT;}{\f109\fnil\fcharset256\fprq2{\*\panose 040506030a0602020202}Playbill;}{\f110\fnil\fcharset256\fprq2{\*\panose 02060603020205020403}Rockwell;}{\f111\fnil\fcharset256\fprq2{\*\panose 02060903040505020403}Rockwell Extra Bold;}{\f112\fnil\fcharset256\fprq2{\*\panose 00000000000000000000}Sand;}{\f113\fnil\fcharset256\fprq2{\*\panose 020b0603050302020204}SportsFigures;}{\f114\fnil\fcharset256\fprq2{\*\panose 040409050d0802020404}Stencil;}{\f115\fnil\fcharset256\fprq2{\*\panose 02000800000000000000}Swing;}{\f116\fnil\fcharset256\fprq2{\*\panose 020b0604030504040204}Tahoma;}{\f117\fnil\fcharset256\fprq2{\*\panose 00000000000000000000}Techno;}{\f118\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Textile;}{\f119\fnil\fcharset256\fprq2{\*\panose 020b0603020202020204}Trebuchet MS;}{\f120\fnil\fcharset256\fprq2{\*\panose 020b0604030504040204}Verdana;}{\f121\fnil\fcharset2\fprq2{\*\panose 05030102010509060703}Webdings;}{\f122\fnil\fcharset256\fprq2{\*\panose 020a0a07050505020404}Wide Latin;}{\f123\fnil\fcharset2\fprq2{\*\panose 05020102010507070707}Wingdings 2;}{\f124\fnil\fcharset2\fprq2{\*\panose 05040102010807070707}Wingdings 3;}{\f125\fnil\fcharset2\fprq2 Zapf Dingbats;}{\f126\fnil\fcharset256\fprq2{\*\panose 05000000000000000000}ZapfDingbats BT;}}}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\nowidctlpar\adjustright \f4\cgrid \snext0 Normal;}{\s1\qc\nowidctlpar\adjustright \b\f4\fs36\cgrid \sbasedon0 \snext0 heading 1;}{\s2\sb200\sa200\keepn\nowidctlpar\adjustright \b\f4\fs28\cgrid \sbasedon0 \snext0 heading 2;}{\s3\li360\nowidctlpar\adjustright \b\f4\cgrid \sbasedon0 \snext0 heading 3;}{\s4\li360\nowidctlpar\adjustright \f4\ul\cgrid \sbasedon0 \snext0 heading 4;}{\s5\li720\nowidctlpar\adjustright \b\f4\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\s6\li720\nowidctlpar\adjustright \f4\fs20\ul\cgrid \sbasedon0 \snext0 heading 6;}{\s7\li720\nowidctlpar\adjustright \i\f4\fs20\cgrid \sbasedon0 \snext0 heading 7;}{\s8\li720\nowidctlpar\adjustright \i\f4\fs20\cgrid \sbasedon0 \snext0 heading 8;}{\s9\li720\nowidctlpar\adjustright \i\f4\fs20\cgrid \sbasedon0 \snext0 heading 9;}{\*\cs10 \additive Default Paragraph Font;}{\*\cs15 \additive \sbasedon10 page number;}{\s16\nowidctlpar\tqc\tx4320\tqr\tx8640\adjustright \f4\cgrid \sbasedon0 \snext16 footer;}{\s17\nowidctlpar\tqc\tx4320\tqr\tx8640\adjustright \f4\cgrid \sbasedon0 \snext17 header;}{\*\cs18 \additive \f4\fs18\up6 \sbasedon10 footnote reference;}{\s19\nowidctlpar\adjustright \f4\fs20\cgrid \sbasedon0 \snext19 footnote text;}{\s20\keepn\nowidctlpar\tqr\tx9350\adjustright \b\f4\fs20\lang1024\cgrid \sbasedon0 \snext0 \sautoupd toc 1;}{\s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid \sbasedon0 \snext21 Text;}{\s22\qc\sa200\nowidctlpar\adjustright \b\f4\fs20\cgrid \sbasedon0 \snext22 Text Box Title;}{\s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid \sbasedon0 \snext23 Code;}{\s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid \sbasedon0 \snext24 Problem;}{\s25\li360\nowidctlpar\tqr\tx9350\adjustright \f4\fs20\lang1024\cgrid \sbasedon0 \snext0 \sautoupd toc 2;}{\s26\li480\nowidctlpar\adjustright \f4\cgrid \sbasedon0 \snext0 \sautoupd toc 3;}{\s27\li720\nowidctlpar\adjustright \f4\cgrid \sbasedon0 \snext0 \sautoupd toc 4;}{\s28\li960\nowidctlpar\adjustright \f4\cgrid \sbasedon0 \snext0 \sautoupd toc 5;}{\s29\li1200\nowidctlpar\adjustright \f4\cgrid \sbasedon0 \snext0 \sautoupd toc 6;}{\s30\li1440\nowidctlpar\adjustright \f4\cgrid \sbasedon0 \snext0 \sautoupd toc 7;}{\s31\li1680\nowidctlpar\adjustright \f4\cgrid \sbasedon0 \snext0 \sautoupd toc 8;}{\s32\li1920\nowidctlpar\adjustright \f4\cgrid \sbasedon0 \snext0 \sautoupd toc 9;}{\s33\qj\fi360\widctlpar\adjustright \f4\cgrid \sbasedon0 \snext33 Body Text 2;}}{\*\revtbl {Unknown;}}{\info{\title Learn to Program}{\author Mike Westerfield}{\operator Mike Westerfield}{\creatim\yr2000\mo10\dy16\hr15\min49}{\revtim\yr2000\mo10\dy16\hr15\min49}{\printim\yr2000\mo10\dy16\hr15\min37}{\version2}{\edmins1}{\nofpages410}{\nofwords127391}{\nofchars726131}{\*\company Byte Works, Inc.}{\nofcharsws891739}{\vern99}}\margl1440\margr1440 \facingp\widowctrl\ftnbj\aenddoc\ftnrestart\hyphcaps0\viewkind1\viewscale100 \fet0\sectd \sbkodd\pgnrestart\linex0\endnhere\sectdefaultcl {\footerl \pard\plain \s16\widctlpar\tqr\tx9360\adjustright \f4\cgrid {\f5\fs20 \chpgn }{\par }}{\footerr \pard\plain \s16\widctlpar\tqr\tx9360\adjustright \f4\cgrid {\f5\fs20 \par }}{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \qc\widctlpar\tqr\tx9360\adjustright \f4\cgrid {\b\fs72 \par \par \par Learn to Program\par in\par C\par \par \par }{\b\fs36 \par \par \par \par \par by Mike Westerfield\par \par \par \par \par }{\b\fs28 Copyright 1990\par }{\b\fs36 Byte Works, Inc.\par \par \sect }\sectd \sbkodd\pgnlcrm\linex0\endnhere\sectdefaultcl {\footerr \pard\plain \s16\widctlpar\tqr\tx9360\adjustright \f4\cgrid {\f5\fs20 \tab \chpgn }{\par }}\pard\plain \qc\widctlpar\tqr\tx9360\adjustright \f4\cgrid {\b\fs36 Table of Contents\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard\plain \s20\keepn\nowidctlpar\tqr\tx9350\adjustright \b\f4\fs20\lang1024\cgrid {\field\fldedit{\*\fldinst {\b0  TOC \\o "1-3" }}{\fldrslt {Lesson One - Getting Started\tab }{\field{\*\fldinst { PAGEREF _Toc496344367 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300360037000000}}}{\fldrslt {1}}}{\par }\pard\plain \s25\li360\nowidctlpar\tqr\tx9350\adjustright \f4\fs20\lang1024\cgrid {Before We Get Started...\tab }{\field{\*\fldinst { PAGEREF _Toc496344368 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300360038000000}}}{\fldrslt {1}}}{\par How to Learn to Program\tab }{\field{\*\fldinst { PAGEREF _Toc496344369 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300360039000000}}}{\fldrslt {1}}}{\par What You Need\tab }{\field{\*\fldinst { PAGEREF _Toc496344370 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300370030000000}}}{\fldrslt {2}}}{\par Getting Everything Ready\tab }{\field{\*\fldinst { PAGEREF _Toc496344371 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300370031000000}}}{\fldrslt {2}}}{\par Your First Flight... er, Program\tab }{\field{\*\fldinst { PAGEREF _Toc496344372 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300370032000000}}}{\fldrslt {3}}}{\par A Close Look at Hello World\tab }{\field{\*\fldinst { PAGEREF _Toc496344373 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300370033000000}}}{\fldrslt {5}}}{\par Escape Sequences\tab }{\field{\*\fldinst { PAGEREF _Toc496344374 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300370034000000}}}{\fldrslt {7}}}{\par Reserved Words\tab }{\field{\*\fldinst { PAGEREF _Toc496344375 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300370035000000}}}{\fldrslt {7}}}{\par Case Sensitivity\tab }{\field{\*\fldinst { PAGEREF _Toc496344376 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300370036000000}}}{\fldrslt {8}}}{\par How Programs Execute\tab }{\field{\*\fldinst { PAGEREF _Toc496344377 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300370037000000}}}{\fldrslt {8}}}{\par Graphics Programs\tab }{\field{\*\fldinst { PAGEREF _Toc496344378 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300370038000000}}}{\fldrslt {9}}}{\par Solution to problem 1.1.\tab }{\field{\*\fldinst { PAGEREF _Toc496344379 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300370039000000}}}{\fldrslt {11}}}{\par Solution to problem 1.2.\tab }{\field{\*\fldinst { PAGEREF _Toc496344380 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300380030000000}}}{\fldrslt {11}}}{\par Solution to problem 1.3.\tab }{\field{\*\fldinst { PAGEREF _Toc496344381 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300380031000000}}}{\fldrslt {11}}}{\par Solution to problem 1.4.\tab }{\field{\*\fldinst { PAGEREF _Toc496344382 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300380032000000}}}{\fldrslt {12}}}{\par Solution to problem 1.5.\tab }{\field{\*\fldinst { PAGEREF _Toc496344383 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300380033000000}}}{\fldrslt {13}}}{\par Solution to problem 1.6.\tab }{\field{\*\fldinst { PAGEREF _Toc496344384 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300380034000000}}}{\fldrslt {13}}}{\par Solution to problem 1.7.\tab }{\field{\*\fldinst { PAGEREF _Toc496344385 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300380035000000}}}{\fldrslt {14}}}{\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }\pard\plain \s20\keepn\nowidctlpar\tqr\tx9350\adjustright \b\f4\fs20\lang1024\cgrid {Lesson Two - Variables and Loops\tab }{\field{\*\fldinst { PAGEREF _Toc496344387 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300380037000000}}}{\fldrslt {15}}}{\par }\pard\plain \s25\li360\nowidctlpar\tqr\tx9350\adjustright \f4\fs20\lang1024\cgrid {Integer Variables\tab }{\field{\*\fldinst { PAGEREF _Toc496344388 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300380038000000}}}{\fldrslt {15}}}{\par The For Loop\tab }{\field{\*\fldinst { PAGEREF _Toc496344389 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300380039000000}}}{\fldrslt {17}}}{\par Indenting:  Programmers Do It With Style\tab }{\field{\*\fldinst { PAGEREF _Toc496344390 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300390030000000}}}{\fldrslt {19}}}{\par Operator Precedence\tab }{\field{\*\fldinst { PAGEREF _Toc496344391 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300390031000000}}}{\fldrslt {20}}}{\par The Maximum Integer\tab }{\field{\*\fldinst { PAGEREF _Toc496344392 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300390032000000}}}{\fldrslt {21}}}{\par Integers Come in Several Sizes\tab }{\field{\*\fldinst { PAGEREF _Toc496344393 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300390033000000}}}{\fldrslt {21}}}{\par Integers Can be Signed or Unsigned\tab }{\field{\*\fldinst { PAGEREF _Toc496344394 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300390034000000}}}{\fldrslt {22}}}{\par More Conversion Specifications\tab }{\field{\*\fldinst { PAGEREF _Toc496344395 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300390035000000}}}{\fldrslt {22}}}{\par Floating-Point Numbers\tab }{\field{\*\fldinst { PAGEREF _Toc496344396 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300390036000000}}}{\fldrslt {23}}}{\par The Trace and Stop Commands\tab }{\field{\*\fldinst { PAGEREF _Toc496344397 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300390037000000}}}{\fldrslt {27}}}{\par Exponents\tab }{\field{\*\fldinst { PAGEREF _Toc496344398 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300390038000000}}}{\fldrslt {28}}}{\par Don't Panic!\tab }{\field{\*\fldinst { PAGEREF _Toc496344399 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003300390039000000}}}{\fldrslt {28}}}{\par Solution to problem 2.1.\tab }{\field{\*\fldinst { PAGEREF _Toc496344400 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400300030000000}}}{\fldrslt {31}}}{\par Solution to problem 2.2.\tab }{\field{\*\fldinst { PAGEREF _Toc496344401 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400300031000000}}}{\fldrslt {32}}}{\par Solution to problem 2.3.\tab }{\field{\*\fldinst { PAGEREF _Toc496344402 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400300032000000}}}{\fldrslt {32}}}{\par Solution to problem 2.4.\tab }{\field{\*\fldinst { PAGEREF _Toc496344403 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400300033000000}}}{\fldrslt {33}}}{\par Solution to problem 2.5.\tab }{\field{\*\fldinst { PAGEREF _Toc496344404 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400300034000000}}}{\fldrslt {34}}}{\par Solution to problem 2.6.\tab }{\field{\*\fldinst { PAGEREF _Toc496344405 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400300035000000}}}{\fldrslt {34}}}{\par Solution to problem 2.7.\tab }{\field{\*\fldinst { PAGEREF _Toc496344406 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400300036000000}}}{\fldrslt {36}}}{\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }\pard\plain \s20\keepn\nowidctlpar\tqr\tx9350\adjustright \b\f4\fs20\lang1024\cgrid {Lesson Three - Input, Loops and Conditions\tab }{\field{\*\fldinst { PAGEREF _Toc496344408 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400300038000000}}}{\fldrslt {37}}}{\par }\pard\plain \s25\li360\nowidctlpar\tqr\tx9350\adjustright \f4\fs20\lang1024\cgrid {Input\tab }{\field{\*\fldinst { PAGEREF _Toc496344409 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400300039000000}}}{\fldrslt {37}}}{\par Our First Game... er, Computer Aided Simulation\tab }{\field{\*\fldinst { PAGEREF _Toc496344410 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400310030000000}}}{\fldrslt {38}}}{\par The Do-While Loop\tab }{\field{\*\fldinst { PAGEREF _Toc496344411 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400310031000000}}}{\fldrslt {38}}}{\par How C Divides\tab }{\field{\*\fldinst { PAGEREF _Toc496344412 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400310032000000}}}{\fldrslt {41}}}{\par Empty Parameter Lists\tab }{\field{\*\fldinst { PAGEREF _Toc496344413 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400310033000000}}}{\fldrslt {43}}}{\par Nesting Loops\tab }{\field{\*\fldinst { PAGEREF _Toc496344414 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400310034000000}}}{\fldrslt {43}}}{\par Random Numbers\tab }{\field{\*\fldinst { PAGEREF _Toc496344415 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400310035000000}}}{\fldrslt {45}}}{\par Multiple Reads with scanf\tab }{\field{\*\fldinst { PAGEREF _Toc496344416 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400310036000000}}}{\fldrslt {47}}}{\par Reading Floating-Point Numbers\tab }{\field{\*\fldinst { PAGEREF _Toc496344417 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400310037000000}}}{\fldrslt {47}}}{\par The If Statement\tab }{\field{\*\fldinst { PAGEREF _Toc496344418 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400310038000000}}}{\fldrslt {48}}}{\par The Else Clause\tab }{\field{\*\fldinst { PAGEREF _Toc496344419 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400310039000000}}}{\fldrslt {49}}}{\par Those Darn Semicolons\tab }{\field{\*\fldinst { PAGEREF _Toc496344420 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400320030000000}}}{\fldrslt {49}}}{\par Nesting If Statements\tab }{\field{\*\fldinst { PAGEREF _Toc496344421 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400320031000000}}}{\fldrslt {49}}}{\par Solution to problem 3.1.\tab }{\field{\*\fldinst { PAGEREF _Toc496344422 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400320032000000}}}{\fldrslt {53}}}{\par Solution to problem 3.2.\tab }{\field{\*\fldinst { PAGEREF _Toc496344423 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400320033000000}}}{\fldrslt {53}}}{\par Solution to problem 3.3.\tab }{\field{\*\fldinst { PAGEREF _Toc496344424 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400320034000000}}}{\fldrslt {56}}}{\par Solution to problem 3.4.\tab }{\field{\*\fldinst { PAGEREF _Toc496344425 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400320035000000}}}{\fldrslt {58}}}{\par Solution to problem 3.5.\tab }{\field{\*\fldinst { PAGEREF _Toc496344426 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400320036000000}}}{\fldrslt {59}}}{\par Solution to problem 3.6.\tab }{\field{\*\fldinst { PAGEREF _Toc496344427 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400320037000000}}}{\fldrslt {60}}}{\par Solution to problem 3.7.\tab }{\field{\*\fldinst { PAGEREF _Toc496344428 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400320038000000}}}{\fldrslt {60}}}{\par Solution to problem 3.8.\tab }{\field{\*\fldinst { PAGEREF _Toc496344429 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400320039000000}}}{\fldrslt {60}}}{\par Solution to problem 3.9.\tab }{\field{\*\fldinst { PAGEREF _Toc496344430 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400330030000000}}}{\fldrslt {61}}}{\par Solution to problem 3.10.\tab }{\field{\*\fldinst { PAGEREF _Toc496344431 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400330031000000}}}{\fldrslt {62}}}{\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }\pard\plain \s20\keepn\nowidctlpar\tqr\tx9350\adjustright \b\f4\fs20\lang1024\cgrid {Lesson Four - Functions\tab }{\field{\*\fldinst { PAGEREF _Toc496344433 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400330033000000}}}{\fldrslt {67}}}{\par }\pard\plain \s25\li360\nowidctlpar\tqr\tx9350\adjustright \f4\fs20\lang1024\cgrid {Subroutines Avoid Repetition\tab }{\field{\*\fldinst { PAGEREF _Toc496344434 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400330034000000}}}{\fldrslt {67}}}{\par The Structure of a Function\tab }{\field{\*\fldinst { PAGEREF _Toc496344435 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400330035000000}}}{\fldrslt {69}}}{\par Local Variables\tab }{\field{\*\fldinst { PAGEREF _Toc496344436 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400330036000000}}}{\fldrslt {69}}}{\par How Functions are Executed\tab }{\field{\*\fldinst { PAGEREF _Toc496344437 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400330037000000}}}{\fldrslt {70}}}{\par Comments and Function Names\tab }{\field{\*\fldinst { PAGEREF _Toc496344438 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400330038000000}}}{\fldrslt {71}}}{\par Functions Let You Create New Commands\tab }{\field{\*\fldinst { PAGEREF _Toc496344439 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400330039000000}}}{\fldrslt {72}}}{\par More About Debugging Functions\tab }{\field{\*\fldinst { PAGEREF _Toc496344440 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400340030000000}}}{\fldrslt {73}}}{\par Functions Can Return a Value\tab }{\field{\*\fldinst { PAGEREF _Toc496344441 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400340031000000}}}{\fldrslt {73}}}{\par More about void and return\tab }{\field{\*\fldinst { PAGEREF _Toc496344442 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400340032000000}}}{\fldrslt {75}}}{\par A First Look at Pointers\tab }{\field{\*\fldinst { PAGEREF _Toc496344443 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400340033000000}}}{\fldrslt {76}}}{\par Some Archaic Features of C\tab }{\field{\*\fldinst { PAGEREF _Toc496344444 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400340034000000}}}{\fldrslt {79}}}{\par Solution to problem 4.1.\tab }{\field{\*\fldinst { PAGEREF _Toc496344445 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400340035000000}}}{\fldrslt {81}}}{\par Solution to problem 4.2.\tab }{\field{\*\fldinst { PAGEREF _Toc496344446 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400340036000000}}}{\fldrslt {82}}}{\par Solution to problem 4.3.\tab }{\field{\*\fldinst { PAGEREF _Toc496344447 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400340037000000}}}{\fldrslt {85}}}{\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }\pard\plain \s20\keepn\nowidctlpar\tqr\tx9350\adjustright \b\f4\fs20\lang1024\cgrid {Lesson Five - Arrays and Strings\tab }{\field{\*\fldinst { PAGEREF _Toc496344449 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400340039000000}}}{\fldrslt {89}}}{\par }\pard\plain \s25\li360\nowidctlpar\tqr\tx9350\adjustright \f4\fs20\lang1024\cgrid {Groups of Numbers as Arrays\tab }{\field{\*\fldinst { PAGEREF _Toc496344450 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400350030000000}}}{\fldrslt {89}}}{\par Be Careful With Arrays!\tab }{\field{\*\fldinst { PAGEREF _Toc496344451 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400350031000000}}}{\fldrslt {91}}}{\par Why Programmers are Humble \endash  At Least, in Private!\tab }{\field{\*\fldinst { PAGEREF _Toc496344452 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400350032000000}}}{\fldrslt {92}}}{\par Strings are Arrays\tab }{\field{\*\fldinst { PAGEREF _Toc496344453 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400350033000000}}}{\fldrslt {93}}}{\par Characters and Integers are Related\tab }{\field{\*\fldinst { PAGEREF _Toc496344454 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400350034000000}}}{\fldrslt {95}}}{\par A Bit About Memory\tab }{\field{\*\fldinst { PAGEREF _Toc496344455 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400350035000000}}}{\fldrslt {96}}}{\par Character Constants and String Constants\tab }{\field{\*\fldinst { PAGEREF _Toc496344456 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400350036000000}}}{\fldrslt {97}}}{\par Another Look at strlen\tab }{\field{\*\fldinst { PAGEREF _Toc496344457 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400350037000000}}}{\fldrslt {97}}}{\par Copying Strings with strcpy and strncpy\tab }{\field{\*\fldinst { PAGEREF _Toc496344458 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400350038000000}}}{\fldrslt {97}}}{\par Putting Strings Together with strcat and strncat\tab }{\field{\*\fldinst { PAGEREF _Toc496344459 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400350039000000}}}{\fldrslt {98}}}{\par Comparing Strings with strcmp and strncmp\tab }{\field{\*\fldinst { PAGEREF _Toc496344460 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400360030000000}}}{\fldrslt {99}}}{\par Passing Strings as Parameters\tab }{\field{\*\fldinst { PAGEREF _Toc496344461 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400360031000000}}}{\fldrslt {99}}}{\par Returning Strings as Function Results\tab }{\field{\*\fldinst { PAGEREF _Toc496344462 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400360032000000}}}{\fldrslt {101}}}{\par The string.h and ctype.h Libraries\tab }{\field{\*\fldinst { PAGEREF _Toc496344463 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400360033000000}}}{\fldrslt {101}}}{\par Solution to problem 5.1.\tab }{\field{\*\fldinst { PAGEREF _Toc496344464 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400360034000000}}}{\fldrslt {105}}}{\par Solution to problem 5.2.\tab }{\field{\*\fldinst { PAGEREF _Toc496344465 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400360035000000}}}{\fldrslt {105}}}{\par Solution to problem 5.3.\tab }{\field{\*\fldinst { PAGEREF _Toc496344466 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400360036000000}}}{\fldrslt {106}}}{\par Solution to problem 5.4.\tab }{\field{\*\fldinst { PAGEREF _Toc496344467 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400360037000000}}}{\fldrslt {106}}}{\par Solution to problem 5.5.\tab }{\field{\*\fldinst { PAGEREF _Toc496344468 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400360038000000}}}{\fldrslt {107}}}{\par Solution to problem 5.6.\tab }{\field{\*\fldinst { PAGEREF _Toc496344469 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400360039000000}}}{\fldrslt {107}}}{\par Solution to problem 5.7.\tab }{\field{\*\fldinst { PAGEREF _Toc496344470 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400370030000000}}}{\fldrslt {108}}}{\par Solution to problem 5.8.\tab }{\field{\*\fldinst { PAGEREF _Toc496344471 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400370031000000}}}{\fldrslt {109}}}{\par }\pard\plain \s20\keepn\nowidctlpar\tqr\tx9350\adjustright \b\f4\fs20\lang1024\cgrid {Lesson Six - More About Arrays\tab }{\field{\*\fldinst { PAGEREF _Toc496344473 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400370033000000}}}{\fldrslt {111}}}{\par }\pard\plain \s25\li360\nowidctlpar\tqr\tx9350\adjustright \f4\fs20\lang1024\cgrid {The Shell Sort\tab }{\field{\*\fldinst { PAGEREF _Toc496344474 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400370034000000}}}{\fldrslt {111}}}{\par Boolean Values\tab }{\field{\*\fldinst { PAGEREF _Toc496344475 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400370035000000}}}{\fldrslt {114}}}{\par Arrays of Arrays\tab }{\field{\*\fldinst { PAGEREF _Toc496344476 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400370036000000}}}{\fldrslt {116}}}{\par Trigonometry Functions\tab }{\field{\*\fldinst { PAGEREF _Toc496344477 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400370037000000}}}{\fldrslt {120}}}{\par Converting Types\tab }{\field{\*\fldinst { PAGEREF _Toc496344478 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400370038000000}}}{\fldrslt {121}}}{\par Rotation\tab }{\field{\*\fldinst { PAGEREF _Toc496344479 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400370039000000}}}{\fldrslt {123}}}{\par Solution to problem 6.1.\tab 129\par Solution to problem 6.2.\tab }{\field{\*\fldinst { PAGEREF _Toc496344480 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400380030000000}}}{\fldrslt {130}}}{\par Solution to problem 6.3.\tab }{\field{\*\fldinst { PAGEREF _Toc496344481 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400380031000000}}}{\fldrslt {132}}}{\par Solution to problem 6.4.\tab }{\field{\*\fldinst { PAGEREF _Toc496344482 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400380032000000}}}{\fldrslt {133}}}{\par Solution to problem 6.5.\tab }{\field{\*\fldinst { PAGEREF _Toc496344483 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400380033000000}}}{\fldrslt {133}}}{\par Solution to problem 6.6.\tab }{\field{\*\fldinst { PAGEREF _Toc496344484 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400380034000000}}}{\fldrslt {134}}}{\par Solution to problem 6.7.\tab }{\field{\*\fldinst { PAGEREF _Toc496344485 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400380035000000}}}{\fldrslt {145}}}{\par Solution to problem 6.8.\tab }{\field{\*\fldinst { PAGEREF _Toc496344486 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400380036000000}}}{\fldrslt {147}}}{\par Solution to problem 6.9.\tab }{\field{\*\fldinst { PAGEREF _Toc496344487 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400380037000000}}}{\fldrslt {149}}}{\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }\pard\plain \s20\keepn\nowidctlpar\tqr\tx9350\adjustright \b\f4\fs20\lang1024\cgrid {Lesson Seven - Types\tab }{\field{\*\fldinst { PAGEREF _Toc496344489 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400380039000000}}}{\fldrslt {153}}}{\par }\pard\plain \s25\li360\nowidctlpar\tqr\tx9350\adjustright \f4\fs20\lang1024\cgrid {Defining Types\tab }{\field{\*\fldinst { PAGEREF _Toc496344490 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400390030000000}}}{\fldrslt {153}}}{\par Enumerations\tab }{\field{\*\fldinst { PAGEREF _Toc496344491 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400390031000000}}}{\fldrslt {154}}}{\par Structures Store More than One Type\tab }{\field{\*\fldinst { PAGEREF _Toc496344492 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400390032000000}}}{\fldrslt {160}}}{\par Defining Variables Right Away with struct and enum\tab }{\field{\*\fldinst { PAGEREF _Toc496344493 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400390033000000}}}{\fldrslt {161}}}{\par Using typedef with struct and enum\tab }{\field{\*\fldinst { PAGEREF _Toc496344494 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400390034000000}}}{\fldrslt {162}}}{\par The switch Statement\tab }{\field{\*\fldinst { PAGEREF _Toc496344495 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400390035000000}}}{\fldrslt {162}}}{\par Solution to problem 7.1.\tab 167\par Solution to problem 7.2.\tab }{\field{\*\fldinst { PAGEREF _Toc496344496 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400390036000000}}}{\fldrslt {169}}}{\par Solution to problem 7.3.\tab }{\field{\*\fldinst { PAGEREF _Toc496344497 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400390037000000}}}{\fldrslt {175}}}{\par Solution to problem 7.4.\tab }{\field{\*\fldinst { PAGEREF _Toc496344498 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400390038000000}}}{\fldrslt {179}}}{\par Solution to problem 7.5.\tab }{\field{\*\fldinst { PAGEREF _Toc496344499 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003400390039000000}}}{\fldrslt {180}}}{\par Solution to problem 7.6.\tab }{\field{\*\fldinst { PAGEREF _Toc496344500 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500300030000000}}}{\fldrslt {184}}}{\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }\pard\plain \s20\keepn\nowidctlpar\tqr\tx9350\adjustright \b\f4\fs20\lang1024\cgrid {Lesson Eight - Pointers and Lists\tab }{\field{\*\fldinst { PAGEREF _Toc496344502 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500300032000000}}}{\fldrslt {185}}}{\par }\pard\plain \s25\li360\nowidctlpar\tqr\tx9350\adjustright \f4\fs20\lang1024\cgrid {What is a Pointer?\tab }{\field{\*\fldinst { PAGEREF _Toc496344503 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500300033000000}}}{\fldrslt {185}}}{\par Pointers are Variables, Too!\tab }{\field{\*\fldinst { PAGEREF _Toc496344504 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500300034000000}}}{\fldrslt {186}}}{\par Allocating and Deallocating Memory\tab }{\field{\*\fldinst { PAGEREF _Toc496344505 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500300035000000}}}{\fldrslt {186}}}{\par Linked Lists\tab }{\field{\*\fldinst { PAGEREF _Toc496344506 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500300036000000}}}{\fldrslt {188}}}{\par Stacks\tab }{\field{\*\fldinst { PAGEREF _Toc496344507 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500300037000000}}}{\fldrslt {189}}}{\par Queues\tab }{\field{\*\fldinst { PAGEREF _Toc496344508 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500300038000000}}}{\fldrslt {192}}}{\par Running Out Of Memory\tab }{\field{\*\fldinst { PAGEREF _Toc496344509 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500300039000000}}}{\fldrslt {193}}}{\par The & Operator Returns an Address\tab }{\field{\*\fldinst { PAGEREF _Toc496344510 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500310030000000}}}{\fldrslt {193}}}{\par The Special Relationship Between Pointers and Arrays\tab }{\field{\*\fldinst { PAGEREF _Toc496344511 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500310031000000}}}{\fldrslt {193}}}{\par Pointer Math\tab }{\field{\*\fldinst { PAGEREF _Toc496344512 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500310032000000}}}{\fldrslt {194}}}{\par Solution to problem 8.1.\tab }{\field{\*\fldinst { PAGEREF _Toc496344513 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500310033000000}}}{\fldrslt {197}}}{\par Solution to problem 8.2.\tab }{\field{\*\fldinst { PAGEREF _Toc496344514 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500310034000000}}}{\fldrslt {197}}}{\par Solution to problem 8.3.\tab }{\field{\*\fldinst { PAGEREF _Toc496344515 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500310035000000}}}{\fldrslt {198}}}{\par Solution to problem 8.4.\tab }{\field{\*\fldinst { PAGEREF _Toc496344516 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500310036000000}}}{\fldrslt {200}}}{\par Solution to problem 8.5.\tab }{\field{\*\fldinst { PAGEREF _Toc496344517 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500310037000000}}}{\fldrslt {201}}}{\par Solution to problem 8.6.\tab }{\field{\*\fldinst { PAGEREF _Toc496344518 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500310038000000}}}{\fldrslt {203}}}{\par Solution to problem 8.7.\tab }{\field{\*\fldinst { PAGEREF _Toc496344519 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500310039000000}}}{\fldrslt {203}}}{\par Solution to problem 8.8.\tab }{\field{\*\fldinst { PAGEREF _Toc496344520 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500320030000000}}}{\fldrslt {204}}}{\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }\pard\plain \s20\keepn\nowidctlpar\tqr\tx9350\adjustright \b\f4\fs20\lang1024\cgrid {Lesson Nine - Files\tab }{\field{\*\fldinst { PAGEREF _Toc496344522 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500320032000000}}}{\fldrslt {205}}}{\par }\pard\plain \s25\li360\nowidctlpar\tqr\tx9350\adjustright \f4\fs20\lang1024\cgrid {The Nature of Files in C\tab }{\field{\*\fldinst { PAGEREF _Toc496344523 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500320033000000}}}{\fldrslt {205}}}{\par What is a File?\tab }{\field{\*\fldinst { PAGEREF _Toc496344524 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500320034000000}}}{\fldrslt {205}}}{\par The Four Basic Operations\tab }{\field{\*\fldinst { PAGEREF _Toc496344525 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500320035000000}}}{\fldrslt {205}}}{\par File Variables\tab }{\field{\*\fldinst { PAGEREF _Toc496344526 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500320036000000}}}{\fldrslt {206}}}{\par Writing to a File\tab }{\field{\*\fldinst { PAGEREF _Toc496344527 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500320037000000}}}{\fldrslt {206}}}{\par Reading from a File\tab }{\field{\*\fldinst { PAGEREF _Toc496344528 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500320038000000}}}{\fldrslt {207}}}{\par File Names\tab }{\field{\*\fldinst { PAGEREF _Toc496344529 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500320039000000}}}{\fldrslt {208}}}{\par Directories, Path Names and Folders\tab }{\field{\*\fldinst { PAGEREF _Toc496344530 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500330030000000}}}{\fldrslt {208}}}{\par Reading Text Files One Line at a Time\tab }{\field{\*\fldinst { PAGEREF _Toc496344531 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500330031000000}}}{\fldrslt {209}}}{\par Bullet-proof Input\tab }{\field{\*\fldinst { PAGEREF _Toc496344532 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500330032000000}}}{\fldrslt {210}}}{\par Binary Files\tab }{\field{\*\fldinst { PAGEREF _Toc496344533 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500330033000000}}}{\fldrslt {213}}}{\par Random Access\tab }{\field{\*\fldinst { PAGEREF _Toc496344534 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500330034000000}}}{\fldrslt {214}}}{\par Solution to problem 9.1.\tab }{\field{\*\fldinst { PAGEREF _Toc496344535 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500330035000000}}}{\fldrslt {217}}}{\par Solution to problem 9.2.\tab }{\field{\*\fldinst { PAGEREF _Toc496344536 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500330036000000}}}{\fldrslt {217}}}{\par Solution to problem 9.3.\tab }{\field{\*\fldinst { PAGEREF _Toc496344537 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500330037000000}}}{\fldrslt {218}}}{\par Solution to problem 9.4.\tab }{\field{\*\fldinst { PAGEREF _Toc496344538 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500330038000000}}}{\fldrslt {220}}}{\par Solution to problem 9.5.\tab }{\field{\*\fldinst { PAGEREF _Toc496344539 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500330039000000}}}{\fldrslt {220}}}{\par Solution to problem 9.6.\tab }{\field{\*\fldinst { PAGEREF _Toc496344540 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500340030000000}}}{\fldrslt {221}}}{\par Solution to problem 9.8.\tab }{\field{\*\fldinst { PAGEREF _Toc496344541 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500340031000000}}}{\fldrslt {221}}}{\par Solution to problem 9.9.\tab }{\field{\*\fldinst { PAGEREF _Toc496344542 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500340032000000}}}{\fldrslt {222}}}{\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }\pard\plain \s20\keepn\nowidctlpar\tqr\tx9350\adjustright \b\f4\fs20\lang1024\cgrid {Lesson Ten - Miscellaneous Useful Stuff\tab }{\field{\*\fldinst { PAGEREF _Toc496344544 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500340034000000}}}{\fldrslt {225}}}{\par }\pard\plain \s25\li360\nowidctlpar\tqr\tx9350\adjustright \f4\fs20\lang1024\cgrid {A Look at this Lesson\tab }{\field{\*\fldinst { PAGEREF _Toc496344545 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500340035000000}}}{\fldrslt {225}}}{\par Number Bases\tab }{\field{\*\fldinst { PAGEREF _Toc496344546 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500340036000000}}}{\fldrslt {225}}}{\par The Bitwise And Operation\tab }{\field{\*\fldinst { PAGEREF _Toc496344547 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500340037000000}}}{\fldrslt {227}}}{\par The Bitwise Or Operator\tab }{\field{\*\fldinst { PAGEREF _Toc496344548 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500340038000000}}}{\fldrslt {228}}}{\par The Bitwise Exclusive Or Operator\tab }{\field{\*\fldinst { PAGEREF _Toc496344549 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500340039000000}}}{\fldrslt {229}}}{\par The Bitwise Negation Operator\tab }{\field{\*\fldinst { PAGEREF _Toc496344550 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500350030000000}}}{\fldrslt {231}}}{\par Escape Sequences\tab }{\field{\*\fldinst { PAGEREF _Toc496344551 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500350031000000}}}{\fldrslt {231}}}{\par The goto Statement\tab }{\field{\*\fldinst { PAGEREF _Toc496344552 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500350032000000}}}{\fldrslt {233}}}{\par The break Statement\tab }{\field{\*\fldinst { PAGEREF _Toc496344553 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500350033000000}}}{\fldrslt {233}}}{\par The break Statement in Nested Loops\tab }{\field{\*\fldinst { PAGEREF _Toc496344554 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500350034000000}}}{\fldrslt {237}}}{\par To goto or Not to goto\tab }{\field{\*\fldinst { PAGEREF _Toc496344555 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500350035000000}}}{\fldrslt {238}}}{\par The continue Statement\tab }{\field{\*\fldinst { PAGEREF _Toc496344556 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500350036000000}}}{\fldrslt {238}}}{\par Solution to problem 10.1.\tab }{\field{\*\fldinst { PAGEREF _Toc496344557 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500350037000000}}}{\fldrslt {241}}}{\par Solution to problem 10.2.\tab }{\field{\*\fldinst { PAGEREF _Toc496344558 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500350038000000}}}{\fldrslt {241}}}{\par Solution to problem 10.3.\tab }{\field{\*\fldinst { PAGEREF _Toc496344559 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500350039000000}}}{\fldrslt {242}}}{\par Solution to problem 10.4.\tab }{\field{\*\fldinst { PAGEREF _Toc496344560 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500360030000000}}}{\fldrslt {244}}}{\par Solution to problem 10.5.\tab }{\field{\*\fldinst { PAGEREF _Toc496344561 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500360031000000}}}{\fldrslt {245}}}{\par Solution to problem 10.6.\tab }{\field{\*\fldinst { PAGEREF _Toc496344562 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500360032000000}}}{\fldrslt {245}}}{\par Solution to problem 10.7.\tab }{\field{\*\fldinst { PAGEREF _Toc496344563 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500360033000000}}}{\fldrslt {246}}}{\par Solution to problem 10.8.\tab }{\field{\*\fldinst { PAGEREF _Toc496344564 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500360034000000}}}{\fldrslt {246}}}{\par Solution to problem 10.9.\tab }{\field{\*\fldinst { PAGEREF _Toc496344565 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500360035000000}}}{\fldrslt {247}}}{\par Solution to problem 10.10.\tab }{\field{\*\fldinst { PAGEREF _Toc496344566 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500360036000000}}}{\fldrslt {248}}}{\par Solution to problem 10.11.\tab }{\field{\*\fldinst { PAGEREF _Toc496344567 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500360037000000}}}{\fldrslt {248}}}{\par Solution to problem 10.12.\tab }{\field{\*\fldinst { PAGEREF _Toc496344568 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500360038000000}}}{\fldrslt {248}}}{\par Solution to problem 10.13.\tab }{\field{\*\fldinst { PAGEREF _Toc496344569 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500360039000000}}}{\fldrslt {248}}}{\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }\pard\plain \s20\keepn\nowidctlpar\tqr\tx9350\adjustright \b\f4\fs20\lang1024\cgrid {Lesson Eleven - More Miscellaneous Useful Stuff\tab }{\field{\*\fldinst { PAGEREF _Toc496344571 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500370031000000}}}{\fldrslt {251}}}{\par }\pard\plain \s25\li360\nowidctlpar\tqr\tx9350\adjustright \f4\fs20\lang1024\cgrid {Unions\tab }{\field{\*\fldinst { PAGEREF _Toc496344572 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500370032000000}}}{\fldrslt {251}}}{\par Separate Compilation\tab }{\field{\*\fldinst { PAGEREF _Toc496344573 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500370033000000}}}{\fldrslt {257}}}{\par Header Files\tab }{\field{\*\fldinst { PAGEREF _Toc496344574 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500370034000000}}}{\fldrslt {259}}}{\par Storage Classes\tab }{\field{\*\fldinst { PAGEREF _Toc496344575 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500370035000000}}}{\fldrslt {260}}}{\par Initializers\tab }{\field{\*\fldinst { PAGEREF _Toc496344576 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500370036000000}}}{\fldrslt {263}}}{\par Solution to problem 11.1.\tab }{\field{\*\fldinst { PAGEREF _Toc496344577 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500370037000000}}}{\fldrslt {267}}}{\par Solution to problem 11.2.\tab }{\field{\*\fldinst { PAGEREF _Toc496344578 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500370038000000}}}{\fldrslt {267}}}{\par Solution to problem 11.3.\tab }{\field{\*\fldinst { PAGEREF _Toc496344579 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500370039000000}}}{\fldrslt {267}}}{\par Solution to problem 11.4.\tab }{\field{\*\fldinst { PAGEREF _Toc496344580 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500380030000000}}}{\fldrslt {268}}}{\par Solution to problem 11.5.\tab }{\field{\*\fldinst { PAGEREF _Toc496344581 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500380031000000}}}{\fldrslt {269}}}{\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }\pard\plain \s20\keepn\nowidctlpar\tqr\tx9350\adjustright \b\f4\fs20\lang1024\cgrid {Lesson Twelve - Stand-Alone Programs\tab }{\field{\*\fldinst { PAGEREF _Toc496344583 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500380033000000}}}{\fldrslt {271}}}{\par }\pard\plain \s25\li360\nowidctlpar\tqr\tx9350\adjustright \f4\fs20\lang1024\cgrid {What is a Stand-Alone Program?\tab }{\field{\*\fldinst { PAGEREF _Toc496344584 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500380034000000}}}{\fldrslt {271}}}{\par Using StartGraph and EndGraph\tab }{\field{\*\fldinst { PAGEREF _Toc496344585 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500380035000000}}}{\fldrslt {271}}}{\par Desktop Programs\tab }{\field{\*\fldinst { PAGEREF _Toc496344586 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500380036000000}}}{\fldrslt {273}}}{\par Mixing Text and Graphics\tab }{\field{\*\fldinst { PAGEREF _Toc496344587 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500380037000000}}}{\fldrslt {274}}}{\par Stand-Alone Text Programs\tab }{\field{\*\fldinst { PAGEREF _Toc496344588 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500380038000000}}}{\fldrslt {276}}}{\par Solution to problem 12.1.\tab }{\field{\*\fldinst { PAGEREF _Toc496344589 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500380039000000}}}{\fldrslt {277}}}{\par Solution to problem 12.2.\tab }{\field{\*\fldinst { PAGEREF _Toc496344590 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500390030000000}}}{\fldrslt {283}}}{\par Solution to problem 12.3.\tab }{\field{\*\fldinst { PAGEREF _Toc496344591 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500390031000000}}}{\fldrslt {284}}}{\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }\pard\plain \s20\keepn\nowidctlpar\tqr\tx9350\adjustright \b\f4\fs20\lang1024\cgrid {Lesson Thirteen - Scanning Text\tab }{\field{\*\fldinst { PAGEREF _Toc496344593 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500390033000000}}}{\fldrslt {291}}}{\par }\pard\plain \s25\li360\nowidctlpar\tqr\tx9350\adjustright \f4\fs20\lang1024\cgrid {The Course of the Course\tab }{\field{\*\fldinst { PAGEREF _Toc496344594 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500390034000000}}}{\fldrslt {291}}}{\par Manipulating Text\tab }{\field{\*\fldinst { PAGEREF _Toc496344595 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500390035000000}}}{\fldrslt {291}}}{\par Building a Simple Scanner\tab }{\field{\*\fldinst { PAGEREF _Toc496344596 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500390036000000}}}{\fldrslt {292}}}{\par Symbol Tables\tab }{\field{\*\fldinst { PAGEREF _Toc496344597 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500390037000000}}}{\fldrslt {293}}}{\par Parsing\tab }{\field{\*\fldinst { PAGEREF _Toc496344598 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500390038000000}}}{\fldrslt {293}}}{\par Solution to problem 13.1.\tab }{\field{\*\fldinst { PAGEREF _Toc496344599 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003500390039000000}}}{\fldrslt {299}}}{\par Solution to problem 13.2.\tab }{\field{\*\fldinst { PAGEREF _Toc496344600 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600300030000000}}}{\fldrslt {300}}}{\par Solution to problem 13.3.\tab }{\field{\*\fldinst { PAGEREF _Toc496344601 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600300031000000}}}{\fldrslt {303}}}{\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }\pard\plain \s20\keepn\nowidctlpar\tqr\tx9350\adjustright \b\f4\fs20\lang1024\cgrid {Lesson Fourteen - Recursion\tab }{\field{\*\fldinst { PAGEREF _Toc496344603 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600300033000000}}}{\fldrslt {307}}}{\par }\pard\plain \s25\li360\nowidctlpar\tqr\tx9350\adjustright \f4\fs20\lang1024\cgrid {A Quick Look at Recursion\tab }{\field{\*\fldinst { PAGEREF _Toc496344604 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600300034000000}}}{\fldrslt {307}}}{\par How Functions Call Themselves\tab }{\field{\*\fldinst { PAGEREF _Toc496344605 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600300035000000}}}{\fldrslt {307}}}{\par Recursion is a Way of Thinking\tab }{\field{\*\fldinst { PAGEREF _Toc496344606 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600300036000000}}}{\fldrslt {308}}}{\par A Practical Application of Recursion\tab }{\field{\*\fldinst { PAGEREF _Toc496344607 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600300037000000}}}{\fldrslt {309}}}{\par Solution to problem 14.1.\tab 313\par Solution to problem 14.2.\tab 313\par Solution to problem 14.3.\tab }{\field{\*\fldinst { PAGEREF _Toc496344608 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600300038000000}}}{\fldrslt {315}}}{\par Solution to problem 14.4.\tab }{\field{\*\fldinst { PAGEREF _Toc496344609 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600300039000000}}}{\fldrslt {316}}}{\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }\pard\plain \s20\keepn\nowidctlpar\tqr\tx9350\adjustright \b\f4\fs20\lang1024\cgrid {Lesson Fifteen - Sorts\tab }{\field{\*\fldinst { PAGEREF _Toc496344611 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600310031000000}}}{\fldrslt {321}}}{\par }\pard\plain \s25\li360\nowidctlpar\tqr\tx9350\adjustright \f4\fs20\lang1024\cgrid {Sorting\tab }{\field{\*\fldinst { PAGEREF _Toc496344612 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600310032000000}}}{\fldrslt {321}}}{\par The Shell Sort\tab }{\field{\*\fldinst { PAGEREF _Toc496344613 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600310033000000}}}{\fldrslt {321}}}{\par Quick Sort\tab }{\field{\*\fldinst { PAGEREF _Toc496344614 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600310034000000}}}{\fldrslt {322}}}{\par How Fast Are They?\tab }{\field{\*\fldinst { PAGEREF _Toc496344615 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600310035000000}}}{\fldrslt {326}}}{\par Quick Sort Can Fail!\tab }{\field{\*\fldinst { PAGEREF _Toc496344616 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600310036000000}}}{\fldrslt {327}}}{\par Sorting Summary\tab }{\field{\*\fldinst { PAGEREF _Toc496344617 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600310037000000}}}{\fldrslt {327}}}{\par Solution to problem 15.1.\tab 329\par Solution to problem 15.2.\tab }{\field{\*\fldinst { PAGEREF _Toc496344618 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600310038000000}}}{\fldrslt {330}}}{\par Solution to problem 15.3.\tab }{\field{\*\fldinst { PAGEREF _Toc496344619 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600310039000000}}}{\fldrslt {332}}}{\par Solution to problem 15.4.\tab }{\field{\*\fldinst { PAGEREF _Toc496344620 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600320030000000}}}{\fldrslt {334}}}{\par Solution to problem 15.5.\tab }{\field{\*\fldinst { PAGEREF _Toc496344621 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600320031000000}}}{\fldrslt {337}}}{\par Solution to problem 15.6.\tab }{\field{\*\fldinst { PAGEREF _Toc496344622 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600320032000000}}}{\fldrslt {339}}}{\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }\pard\plain \s20\keepn\nowidctlpar\tqr\tx9350\adjustright \b\f4\fs20\lang1024\cgrid {Lesson Sixteen - Searches and Trees\tab }{\field{\*\fldinst { PAGEREF _Toc496344624 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600320034000000}}}{\fldrslt {343}}}{\par }\pard\plain \s25\li360\nowidctlpar\tqr\tx9350\adjustright \f4\fs20\lang1024\cgrid {Storing and Accessing Information\tab }{\field{\*\fldinst { PAGEREF _Toc496344625 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600320035000000}}}{\fldrslt {343}}}{\par Sequential Searches\tab }{\field{\*\fldinst { PAGEREF _Toc496344626 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600320036000000}}}{\fldrslt {343}}}{\par The Binary Search\tab }{\field{\*\fldinst { PAGEREF _Toc496344627 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600320037000000}}}{\fldrslt {343}}}{\par A Cross Reference Program for C\tab }{\field{\*\fldinst { PAGEREF _Toc496344628 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600320038000000}}}{\fldrslt {344}}}{\par The Binary Tree\tab }{\field{\*\fldinst { PAGEREF _Toc496344629 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600320039000000}}}{\fldrslt {351}}}{\par Solution to problem 16.1.\tab 357\par Solution to problem 16.2.\tab }{\field{\*\fldinst { PAGEREF _Toc496344630 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600330030000000}}}{\fldrslt {358}}}{\par Solution to problem 16.3.\tab }{\field{\*\fldinst { PAGEREF _Toc496344631 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600330031000000}}}{\fldrslt {360}}}{\par Solution to problem 16.4.\tab }{\field{\*\fldinst { PAGEREF _Toc496344632 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600330032000000}}}{\fldrslt {366}}}{\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }\pard\plain \s20\keepn\nowidctlpar\tqr\tx9350\adjustright \b\f4\fs20\lang1024\cgrid {Lesson Seventeen - A Project: Developing a Break-Out Game\tab }{\field{\*\fldinst { PAGEREF _Toc496344634 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600330034000000}}}{\fldrslt {373}}}{\par }\pard\plain \s25\li360\nowidctlpar\tqr\tx9350\adjustright \f4\fs20\lang1024\cgrid {Designing a Program\tab }{\field{\*\fldinst { PAGEREF _Toc496344635 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600330035000000}}}{\fldrslt {373}}}{\par The User: That's Who We Write For\tab }{\field{\*\fldinst { PAGEREF _Toc496344636 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600330036000000}}}{\fldrslt {373}}}{\par Laying the Groundwork\tab }{\field{\*\fldinst { PAGEREF _Toc496344637 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600330037000000}}}{\fldrslt {375}}}{\par Bottom-Up Design Verses Top-Down Design\tab }{\field{\*\fldinst { PAGEREF _Toc496344638 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600330038000000}}}{\fldrslt {379}}}{\par Starting the Program\tab }{\field{\*\fldinst { PAGEREF _Toc496344639 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600330039000000}}}{\fldrslt {380}}}{\par Drawing the Bricks\tab }{\field{\*\fldinst { PAGEREF _Toc496344640 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600340030000000}}}{\fldrslt {382}}}{\par Drawing the Score and Balls\tab }{\field{\*\fldinst { PAGEREF _Toc496344641 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600340031000000}}}{\fldrslt {383}}}{\par Bouncing the Ball\tab }{\field{\*\fldinst { PAGEREF _Toc496344642 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600340032000000}}}{\fldrslt {383}}}{\par The Bricks\tab }{\field{\*\fldinst { PAGEREF _Toc496344643 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600340033000000}}}{\fldrslt {384}}}{\par Labarski's Rule of Cybernetic Entomology\tab }{\field{\*\fldinst { PAGEREF _Toc496344644 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600340034000000}}}{\fldrslt {386}}}{\par Filling in the Last Stubs\tab }{\field{\*\fldinst { PAGEREF _Toc496344645 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600340035000000}}}{\fldrslt {387}}}{\par Tidy Up\tab }{\field{\*\fldinst { PAGEREF _Toc496344646 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600340036000000}}}{\fldrslt {388}}}{\par Ruffles and Flourishes\tab }{\field{\*\fldinst { PAGEREF _Toc496344647 \\h }{{\*\datafield 08d0c9ea79f9bace118c8200aa004ba90b02000000080000000e0000005f0054006f0063003400390036003300340034003600340037000000}}}{\fldrslt {388}}}{\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid }}\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard\plain \widctlpar\tqr\tx9360\adjustright \f4\cgrid {\b\fs36 \par \sect }\sectd \sbkodd\pgnrestart\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl {\footerr \pard\plain \s16\widctlpar\tqr\tx9360\adjustright \f4\cgrid {\f5\fs20 \tab \chpgn \par }}\pard\plain \s1\qc\nowidctlpar\outlinelevel0\adjustright \b\f4\fs36\cgrid {{\*\bkmkstart _Toc496343263}{\*\bkmkstart _Toc496344051}{\*\bkmkstart _Toc496344366}Lesson One{\*\bkmkend _Toc496343263}{\*\bkmkend _Toc496344051}{\*\bkmkend _Toc496344366}\par {\*\bkmkstart _Toc496344367}Getting Started{\*\bkmkend _Toc496344367}\par }\pard\plain \qj\widctlpar\adjustright \f4\cgrid {\b\fs28 \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl {\footerl \pard\plain \s16\widctlpar\adjustright \f4\cgrid {\f5\fs20 \chpgn }{\par }}\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344368}Before We Get Started...{\*\bkmkend _Toc496344368}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {When I went to grade school, my teachers tried to beat some basic skills into my thick head.  Back then, the basic skills included reading, writing, and arithmetic.  When it came to spelling, my mind was already warped, because my teachers had also explained that these were the three R's.\par Lately, in our rapidly changing world, we have added a new basic skill.  It just isn't good enough to be able to read and write, plus do some math.  In 1965, it wasn't easy to get from New York to Chicago without reading signs, writing instructions, counting some change and reading a clock.  Today, you will use a computer to make the same trip.  The travel agent will log your reservations in a computer.  You may get spending money from a computer-based automatic teller.  A digital watch counts bits to tell you what time it is.  Computers control the flow of trains and the displays used by air traffic controllers.  Your check book may even have a calculator.  It's become a computerized world, and people who can't or won't deal with computers are rapidly being left as far behind as an illiterate person in the sixties.\par Of course, you know all of that.  That's why you have decided to learn to program.  The purpose of this course is to teach you to program.  By the end of the course, you will know one of todays most popular programming languages, C.  You will know it well enough to write programs of your own.  Whether you want to plot an engineering equation, keep track of your Christmas mailing list, or write a computer game, this course will get you ready.\par If you have been around computers for a long time, you may know that there are many languages you can use to write programs for your computer.  It's fair to ask why this course uses C.\par One of the things you must look for in a computer language is that it must be fairly common.  If a language is common, that tells you two important things:  a lot of people think the language is a good one, and no matter what computer you decide to write a program for, you are likely to find the language you know.  Today, there are four languages that fulfill this first requirement.  They are C, Pascal, assembly language and BASIC.\par If you decide to make your living programming a computer, you will eventually learn all of these languages.  If you are learning to program, though, you have to pick just one of them to learn first.  We can immediately rule out assembly language.  In assembly language, you have to deal with the machine's internal structure.  It takes many individual instructions to do the simplest thing.  You will spend more time dealing with bits and bytes than learning how to write a well-organized program.  We can also rule out BASIC.  BASIC is a fine language in many respects, but it has become outdated by the rapid progress of programming practice.  Modern programming often deals with pointers, linked lists, and dynamically allocated memory.  The BASIC language can't deal with these ideas effectively.\par That leaves C and Pascal.  Pascal is an excellent language.  It is very popular in educational settings, and has been used to write a large number of applications.  C, however, is even more popular.  C tends to give the programmer more freedom that Pascal by not being so strict with type checking, and always providing a way around the checks that exist.  These features have made C very popular with professional programmers.  Since the pros use C, it is only natural that everyone else wants to use it, too.\par Before getting too much further, I also want to point out what this course is not.  This is not a course about writing Apple IIGS desktop programs.  I don't want to discourage you from writing desktop programs; quite the contrary.  On the other hand, as you will find out, there is a lot to learn about programming before you are really ready to tackle something like a desktop program.  By the time you finish this course, you will be ready to start to learn about desktop programming.  If you tried to learn desktop programming right away, though, you would probably fail.  There's just too much to learn to try and do it all at once.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344369}How to Learn to Program{\*\bkmkend _Toc496344369}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Learning to program has a lot in common with learning to fly an airplane.  When you learn to fly, most people start with an introductory flight with an instructor.  Those that don't often make a bad first landing, and never get a second chance.  (An old adage around flight schools is that any landing you walk away from was a good landing.)  Before, during and after the flight, the instructor will tell you about some of the basics of flight:  how the control surfaces work, what the controls do, and so forth.  There will be a lot you don't know, and a lot of things you are told may not make sense right away.  As you progress, you will spend time reading books and sitting in lectures, but you will also spend a lot of time actually flying the airplane.  You wouldn't expect to spend all of your time reading books and sitting in lectures, then walk out to the plane and go off for a cross-country flight with no instructor; you gradually work up to that point.  Eventually, though, you solo.  You start to fly long distances, first with an instructor and then alone.  Finally the day comes when you get your license.\par It's the same way with programming.  In a moment, we'll get started.  We'll start off with a few simple programs.  It is absolutely essential that you type them in and run them.  There will be many problems that you can work on your own.  The more problems you work, the better programmer you will become.  Sure, we will spend some time talking about the ideas behind programming, and there will be some problems that you need to work through with a pencil and paper.  For the most part, though, you will be programming; either typing in and analyzing programs with the help of this material, or writing and running your own programs.  Gradually, the programs will get longer, and before long you will be able to write your own programs.\par Just in case you missed the point, let me spell it out in very simple terms.  If you read this material, but don't type in the sample programs or work the problems, you will know as much about programming as you would know about flying from reading a book.  In short, very little.  Programming is a skill.  If you don't practice the skill, you will never learn it.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344370}What You Need{\*\bkmkend _Toc496344370}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Now is the time to sit down in front of your computer.  Before starting, let's make sure you have everything you will need.  First, you need an Apple IIGS computer.  It must have a monitor; it really doesn't matter if it is black and white or color.  The computer must have at least 1.125M of memory.  For the older Apple IIGS that came with 256K on the mother board, this means that the memory card in the special memory slot must be populated with 1M of memory.  In the most common case of an Apple memory card, this means that there should be a memory chip in each socket on the card.  You can check this by taking the top off of your computer and looking.  With the newer Apple IIGS, which comes with 1.125M of memory on the mother board, you don't need a memory card at all.\par You must have at least one 3.5" disk drive.  We will also assume that you have at least one other disk drive; it really doesn't matter if it is a 3.5" disk drive or a 5.25" disk drive.\par You will need a copy of ORCA/C.  If you decide to use a different C, there will be some things in this book that will not work.  You would have to figure out why and make appropriate adjustments.  By the time you finish this course, you will know enough to do that.  At first, though, you may not.  For that reason, I would suggest that you stick with ORCA/C.\par You will need at least four blank disks.  This course is written with the assumption that you have two floppy disk drives.  One of them must be a 3.5" floppy disk drive; you need that to run ORCA/C.  The other can be either a 3.5" floppy disk drive or a 5.25" floppy disk drive.  Three of the floppy disks should be 3.5" disk drives; you will use these to make a copy of ORCA/C.  The fourth disk should be a 3.5" disk or a 5.25" disk, depending on what you are using for a second disk drive.\par There are some other things that would be nice, but not essential.  Most people like to print their programs and look at the paper copy.  I highly recommend a printer if you intend to try this.  With some of the longer programs we will write, more memory would be nice.  With more memory, the process of translating your program from a text file into an executable program will go much faster.  A hard disk is also very nice.  Hard disks can hold much more than a floppy disk, so you will not have to switch disks as often.  Hard disks are also faster than floppy disks, which again speeds up the programming process.  Finally, an Applied Engineering TransWarp Accelerator card will roughly double the speed of your computer.  As I said, all of these are nice.  If you end up spending a lot of time programming, I would encourage developing a close relationship with St. Nicholas in an attempt to collect these items.  You can, however, do everything in this course without them.\par If you already have a hard disk, feel free to install ORCA/C on your hard disk and work from there.  All of the things we will do in this course will work fine from a hard disk.  You can find instructions on installing C on a hard disk in the documentation that comes with the compiler.  We will not cover it here.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344371}Getting Everything Ready{\*\bkmkend _Toc496344371}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {When I bought my first FORTRAN compiler for the Apple II, I had a frightening experience.  I wrote a program that crashed the compiler.  The program actually erased some of the information on the compiler disk, so I could not use that disk anymore.  In those days, many vendors still took the absurd position that compilers had to be copy protected.  My local dealer either could not or would not help me restore the disk.  I had one other copy (the program came with two copies), but I was afraid to use it.\par Fortunately, times have changed.  Most languages are no longer copy protected.  The very first thing you should do when you open your copy of ORCA/C is to make copies of each of the three floppy disks that come with the package.  You can use the Finder to do this.  If you know how to use some other copy program, and you like it better, go ahead and use it.  Any copy program will work.  Label each of the three disks you have copied, and put the originals in a safe place.\par You will also need one other formatted disk to put your programs on.  Go ahead and format that disk now.  You can give the disk any name you like.  Your name is one good choice.  Keep in mind that this disk must be available at the same time as the ORCA/C program disk.  If you have one 3.5" disk drive and one 5.25" disk drive, your program disk must be a 5.25" disk.  There will be plenty of room on the disk for a few dozen of the size programs you will write in this course.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344372}Your First Flight... er, Program{\*\bkmkend _Toc496344372}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {It's time to take that first test flight.  Strap yourself in.  After all, as you have no doubt heard, computers can crash, so always wear your seat belt.  Fortunately, though, a computer crash never hurts anything.  As we go through this program, there will be a lot you don't understand yet.  Be patient; in time, you will.  The one thing you should keep in mind, though, is that you can't write a program that will damage the computer.  Even if you do something wrong, the absolute worst thing that will happen is you will erase a disk \endash  and even that is so unlikely that it isn't worth worrying about very much.  It is, however, worth worrying about enough to make a copy of the ORCA/C disks, which is why you should never run from the original disks.\par We will use ORCA/C exactly the way it comes out of the box.  You will need two of the three disks for this program.  Start by putting the disk labeled "ORCA/C Boot Disk" into your boot drive, and starting your computer.  After the program starts, you will be asked for the program disk.  Eject the boot disk and replace it with the disk labeled "ORCA/C Desktop System."  After some more whirring, you will see a menu bar with four menus.\par All of your programs will be written to a separate program disk.  There is really nothing to stop you from putting your programs on the ORCA/C program disk, and you may occasionally do that by accident, but you will run out of room on the disk if you do this on a regular basis.  In short, it is time to put your blank disk in the second disk drive.\par }{\lang1024 {\shp{\*\shpinst\shpleft0\shptop-7522\shpright4608\shpbottom-4066\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz0\shplid1131{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 5505024}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s22\qc\sa200\nowidctlpar\adjustright \b\f4\fs20\cgrid {One Disk Drive?\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {If you truly have only one disk drive, you will have to put your programs on the ORCA/C program disk.  As it is shipped, the ORCA/C Desktop System disk, which is the one you will have in the disk drive while writing programs, has about 140K of free space.  This is actually quite a lot of space for the size programs we will write in this course.  At some point, the disk will be filled with your programs.  When that happens, you can use the Finder to copy the files to another disk, or just make a second copy of the ORCA/C Desktop System disk for your new programs.\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8192\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s22\qc\sa200\nowidctlpar\adjustright \b\f4\fs20\cgrid {One Disk Drive?\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {If you truly have only one disk drive, you will have to put your programs on the ORCA/C program disk.  As it is shipped, the ORCA/C Desktop System disk, which is the one you will have in the disk drive while writing programs, has about 140K of free space.  This is actually quite a lot of space for the size programs we will write in this course.  At some point, the disk will be filled with your programs.  When that happens, you can use the Finder to copy the files to another disk, or just make a second copy of the ORCA/C Desktop System disk for your new programs.\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx0\dpy-7522\dpxsize4608\dpysize3456\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{When you write a program, you type the program pretty much the same way you would type a letter in a word processor.  Our first step, then, is to open a new C program document.  Pull down the File menu and select New.  A window will appear, filling the desktop.  You probably expected that, but what you may not have expected is the five new menus which appear on the menu bar.  One of them is very important.  ORCA/C is one member of a large family of programming languages that all share the same programming environment.  You must tell the system what language you want to use to write your program.  To do this, pull down the Languages menu and select CC.  If you pull it down again, you will see that CC has a check mark beside it.  (It is traditional to call a C compiler CC, rather than just C.)\par Type in the following program.  The format isn't terribly critical, but since you don't know what is and what is not important yet, it is best to type it exactly as shown.  This program writes the characters "Hello, world." to the screen.  It's a simple program, but we must start somewhere.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par printf("Hello, world.\\n");\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Once the program is typed in, it is time to save it to disk.  This step isn't very important yet; it is very unlikely that these first few programs will crash the computer.  If you form the habit of always saving the program, though, you will be very thankful the first time the computer crashes after you have spent several minutes typing.  Once the computer crashes, it is easier to redo the typing than to recover the lost information \endash  even assuming the information can be recovered.  Sometimes it cannot.\par To save the program, select Save As... from the File menu.  A dialog will appear.  Click on the disk button until the name of your blank disk shows up at the top of the dialog.  If you are not sure what your program disk is named, watch the lights on the disk drive.  When your disk is selected, the light on the disk will light up, and the disk will whir for a moment.  Now type the name of the program file.  In this case, you should type HELLO.CC.  Finally, click on the save button.  Note that the name of the source window changed.\par }{\lang1024 {\shp{\*\shpinst\shpleft-144\shptop-2305\shpright4608\shpbottom-145\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz1\shplid1133{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 5439488}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s22\qc\sa200\nowidctlpar\adjustright \b\f4\fs20\cgrid {Setting the Language\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {If you forget to set the language, the message, "A compiler is not available for this language."  If that happens, pull down the language menu and select the language.  Make some change in the program \endash  inserting and removing a space will do \endash  and then save the program to disk again.\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8193\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s22\qc\sa200\nowidctlpar\adjustright \b\f4\fs20\cgrid {Setting the Language\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {If you forget to set the language, the message, "A compiler is not available for this language."  If that happens, pull down the language menu and select the language.  Make some change in the program \endash  inserting and removing a space will do \endash  and then save the program to disk again.\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx-144\dpy-2305\dpxsize4752\dpysize2160\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}{\shp{\*\shpinst\shpleft0\shptop1151\shpright9504\shpbottom9503\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz2\shplid1134{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 5373952}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s22\qc\sa200\nowidctlpar\adjustright \b\f4\fs20\cgrid {Desktop Editing\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {While you may be quite good at entering text with an editor, it is possible that this is your first look at a desktop editor.  The new stuff that appeared on the screen is called a window.  Along the top, you will see a black bar called the title bar.  The box on the left hand side is called the close box.  Clicking on the close box closes the window, removing it from the desktop.\par The right-hand box on the title bar, called the zoom box, is used to change the size of the window back to a previous value.  If you make the window smaller, then click on that box, the window will return to its original size.\par In the middle of the title bar is the name of the disk file where the last permanent copy of the text was stored.  If the window has never been saved, the name will be Untitled with a number.\par At the bottom right-hand corner of the window, you will see another box; this one has two overlapping boxes inside.  This is the grow box.  The grow box lets you change the size of the window.  To do this, you move the mouse to place the arrow cursor on the box, then press and hold down the mouse button.  As you move the mouse, an outline showing where the new window will be moves across the screen.  When the outline is in the correct spot, let up on the mouse button.\par To move the window, you drag the title bar.  Start by positioning the mouse cursor in the middle of the window's title bar, over the name of the window.  Next, press and hold the mouse button, dragging the outline to the new location, and finally, let up on the mouse button.\par As with any editor, you will often have more text in the file than can be displayed on the screen.  The scroll bars on the right and bottom edge of the window let you move through the file.  Clicking on one of the arrows "moves" the window over an imaginary, full size page that is 255 characters wide and as long as your program.  (The window does not move; instead the text moves as if you moved the window over this larger, imaginary text page.)  Clicking in the grey area beside the arrow moves the distance of a full window, rather than just one line or character.  Finally, you can drag the white area, called the thumb, to move over very large distances.  The relative position and size of the thumb in the scroll bar is proportional to the size and location of the window on the imaginary document that contains all of the text.\par You can enter text just as you would with any editor.  To correct a mistake, use the mouse to move the arrow mouse cursor over the window.  The arrow will change to a vertical bar with a curly top and bottom.  Position this bar where you want the flashing insertion-point to be and click on the mouse.  You can now use the backspace key to delete old text, then type in the new text.\par There are many short-cuts to using the desktop editor.  We won't cover them in this course.  At some point, you should spend some time reading the chapter in the ORCA/C manual that describes the desktop editor to learn some of these shortcuts.\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8194\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s22\qc\sa200\nowidctlpar\adjustright \b\f4\fs20\cgrid {Desktop Editing\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {While you may be quite good at entering text with an editor, it is possible that this is your first look at a desktop editor.  The new stuff that appeared on the screen is called a window.  Along the top, you will see a black bar called the title bar.  The box on the left hand side is called the close box.  Clicking on the close box closes the window, removing it from the desktop.\par The right-hand box on the title bar, called the zoom box, is used to change the size of the window back to a previous value.  If you make the window smaller, then click on that box, the window will return to its original size.\par In the middle of the title bar is the name of the disk file where the last permanent copy of the text was stored.  If the window has never been saved, the name will be Untitled with a number.\par At the bottom right-hand corner of the window, you will see another box; this one has two overlapping boxes inside.  This is the grow box.  The grow box lets you change the size of the window.  To do this, you move the mouse to place the arrow cursor on the box, then press and hold down the mouse button.  As you move the mouse, an outline showing where the new window will be moves across the screen.  When the outline is in the correct spot, let up on the mouse button.\par To move the window, you drag the title bar.  Start by positioning the mouse cursor in the middle of the window's title bar, over the name of the window.  Next, press and hold the mouse button, dragging the outline to the new location, and finally, let up on the mouse button.\par As with any editor, you will often have more text in the file than can be displayed on the screen.  The scroll bars on the right and bottom edge of the window let you move through the file.  Clicking on one of the arrows "moves" the window over an imaginary, full size page that is 255 characters wide and as long as your program.  (The window does not move; instead the text moves as if you moved the window over this larger, imaginary text page.)  Clicking in the grey area beside the arrow moves the distance of a full window, rather than just one line or character.  Finally, you can drag the white area, called the thumb, to move over very large distances.  The relative position and size of the thumb in the scroll bar is proportional to the size and location of the window on the imaginary document that contains all of the text.\par You can enter text just as you would with any editor.  To correct a mistake, use the mouse to move the arrow mouse cursor over the window.  The arrow will change to a vertical bar with a curly top and bottom.  Position this bar where you want the flashing insertion-point to be and click on the mouse.  You can now use the backspace key to delete old text, then type in the new text.\par There are many short-cuts to using the desktop editor.  We won't cover them in this course.  At some point, you should spend some time reading the chapter in the ORCA/C manual that describes the desktop editor to learn some of these shortcuts.\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx0\dpy1151\dpxsize9504\dpysize8352\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{When ORCA/C runs your program, it will need someplace to write characters.  The program will automatically open a special window called the shell window, and put the characters there.  It will not, however, cover up your program with the shell window.  To see what is happening, you need to shrink you program window to make room for the shell window.  The shell window always appears on the top, right side of the desktop, so shrinking your window to half of its current width is a good idea.  Do that now, putting the right hand side of your program window under the b in the Debug menu.\par }{\lang1024 {\shp{\*\shpinst\shpleft0\shptop247\shpright4464\shpbottom3051\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz3\shplid1135{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn pib}{\sv {\pict\picscalex35\picscaley35\piccropl0\piccropr0\piccropt0\piccropb0\picw640\pich402\picwgoal12800\pichgoal8040\macpict\bliptag-36819094\blipupi72{\*\blipuid fdce2f6a8d2a44c0efb450c43a9b41f9}21fc0000000001920280001102ff0c00ffffffff000000000000000002800000019200000000000000a0008200a0303900a0008e001e0001000a0000000002d004a400980050000000000080028000000000008002800000000000800280000102b1ff02b1ff0600c0b30000030600c0b30000030903c0000038b60000030903c0000038b60000032e11c00000f0007c61c00003e063000030c60003fd00051f18000c00f8fc000603e0000003e003fe000003de0000032e11c00000f0007c61c00003e063000030c60003fd00051f18000c00f8fc000603e0000003e003fe000003de0000033011c0003f3e006000c0000300600c0030c00003fd00071800000c00c000c0fe000603300000033003fe000003de0000033011c0003f3e006000c0000300600c0030c00003fd00071800000c00c000c0fe000603300000033003fe000003de0000033a34c000fffc0060e0c1e00303e71f0036ce3e1f1e618f001838f87c00c199f1b1f1e0033333e00331e3e331f00301f3e1f331f1f1e1e0e70000033a34c000fffc0060e0c1e00303e71f0036ce3e1f1e618f001838f87c00c199f1b1f1e0033333e00331e3e331f00301f3e1f331f1f1e1e0e7000003330fc000fff8007860c33003c6630c0036c6fe33126d98001e18cccc00f0f0c1c3330003e3333003fd3302300303fa33e6000003330fc000fff8007860c33003c6630c0036c6fe33126d98001e18cccc00f0f0c1c3330003e3333003fd3302300303fa33e6000003370fc000ffff006060c3f00306630c0036c6fe33196d8f001818cccc00c060c18331e0036333300333f33333300303fb3301f1e0e7000003370fc000ffff006060c3f00306630c0036c6fe33196d8f001818cccc00c060c18331e0036333300333f33333300303fb3301f1e0e7000003390fc0007ffe006060c3000306630d801986fd332001801818cccc00c0f0d9833030033333300333033331f003033331f33331f30030e7000003390fc0007ffe006060c3000306630d801986fd332001801818cccc00c0f0d9833030033333300333033331f003033331f33331f30030e70000033a34c0003ef80060f1e1e003e3e78700198f331f1e330f00183ccc7c00f9987181f1e00331f33003e1e3e1f23003f1f33231f1f231e1e0e70000033a34c0003ef80060f1e1e003e3e78700198f331f1e330f00183ccc7c00f9987181f1e00331f33003e1e3e1f23003f1f33231f1f231e1e0e70000031300c0d9000101e0fe000401e00001e0e50000031300c0d9000101e0fe000401e00001e0e50000030600c0b30000030600c0b300000302b1ff02b1ff06d9ffda00000306d9ffda00000306d9ffda00000306d9ffda0000032003ffc0007ff5ff039fffc7c7f1ff03e0003ffff0000503c600038380f10000032003ffc0007ff5ff039fffc7c7f1ff03e0003ffff0000503c600038380f10000032003ffcffe7ff5ff039fffe7e7f1ff03e7cf3ffff00005066600018180f10000032003ffcffe7ff5ff039fffe7e7f1ff03e7cf3ffff00005066600018180f10000032403ffcffe7ff5ff0783c3e7e7c3fc3c3ff5ff03e7cf3ffff000050607c3c18180f10000032403ffcffe7ff5ff0783c3e7e7c3fc3c3ff5ff03e7cf3ffff000050607c3c18180f10000032403ffcffe7ff5ff079999e7e799f9999ff5ff03e00f3ffff0000503c666618180f10000032403ffcffe7ff5ff079999e7e799f9999ff5ff03e00f3ffff0000503c666618180f10000032203ffcffe7ff5ff069981e7e799f9f9f4ff03e7ff3fffef00046667e18180f10000032203ffcffe7ff5ff069981e7e799f9f9f4ff03e7ff3fffef00046667e18180f10000032403ffcffe7ff5ff07999fe7e799f9999ff5ff03e7ff3ffff00005066666018180f10000032403ffcffe7ff5ff07999fe7e799f9999ff5ff03e7ff3ffff00005066666018180f10000032303ffc0007ff5ff0099fdc3029c3c3ff5ff03e0003ffff0000503c663c3c3c0f10000032303ffc0007ff5ff0099fdc3029c3c3ff5ff03e0003ffff0000503c663c3c3c0f100000306d9ffda00000306d9ffda00000306d9ffda00000306d9ffda00000302b1ff02b1ff0c00c0de00000ffeffdc00feff0c00c0de00000ffeffdc00feff2012c06c30000070000600000c003006300000c060f000000ffeffdc0002c000032012c06c30000070000600000c003006300000c060f000000ffeffdc0002c000032001c06cfe0008300006000018003006fe0001c030f000000ffeffdc0002c000032001c06cfe0008300006000018003006fe0001c030f000000ffeffdc0002c000032012c0fe70fc7e30c67e7c00307efc7e707c00fc18f000000ffeffdc0002c000032012c0fe70fc7e30c67e7c00307efc7e707c00fc18f000000ffeffdc0002c000032005c06c30c6c030fec6090060c030c630c600c60cf000000ffeffdc0002c000032005c06c30c6c030fec6090060c030c630c600c60cf000000ffeffdc0002c000032112c0fe30c6c030c6c6fe00307c30c630c600c618f000030c00000fdc0002c000032112c0fe30c6c030c6c6fe00307c30c630c600c618f000030c00000fdc0002c000032112c06c30c6c030c6c6c000180636c630c600c630f000030c00c00fdc0002c000032112c06c30c6c030c6c6c000180636c630c600c630f000030c00c00fdc0002c000032112c06c78c67e787c7e7e000cfc1c7e787c18c660f000030c03300fdc0002c000032112c06c78c67e787c7e7e000cfc1c7e787c18c660f000030c03300fdc0002c000030e00c0de00fe0c000fdc0002c000030e00c0de00fe0c000fdc0002c000031500c0de00050c30030f00fcfd000030e30002c000031500c0de00050c30030f00fcfd000030e30002c000031500c0de00050cfc0fcf00c6fd000070e30002c000031500c0de00050cfc0fcf00c6fd000070e30002c000031600c0de00fe0c080f00c67c7e7e003030e40002c000031600c0de00fe0c080f00c67c7e7e003030e40002c000031500c0de00fe0c070f00fc06c0c00030e30002c000031500c0de00fe0c070f00fc06c0c00030e30002c000031600c0de00fe0c080f00c07e7c7c003030e40002c000031600c0de00fe0c080f00c07e7c7c003030e40002c000031600c0de000a0c0ffc0f00c0c606060030e30002c000031600c0de000a0c0ffc0f00c0c606060030e30002c000031800c0de000c0c00000f00c07efcfc00780000e51802c000031800c0de000c0c00000f00c07efcfc00780000e51802c000030e00c0de00000ffeffdc0002c000030e00c0de00000ffeffdc0002c000032404c000003006fe00073000180000300630ed00000ffeff0100fcfd00007ce30002c000032404c000003006fe00073000180000300630ed00000ffeff0100fcfd00007ce30002c000032200c0fe000006fc000030fe00010618ed00050f00003f00c6fd0000c6e30002c000032200c0fe000006fc000030fe00010618ed00050f00003f00c6fd0000c6e30002c00003260fc0c67c707e00c67c70fc60c67c707e0ced000b0f00003f00c67c7e7e000630e40002c00003260fc0c67c707e00c67c70fc60c67c707e0ced000b0f00003f00c67c7e7e000630e40002c00003250fc0c6c630c600ee0630c660c6c630c60ced000a0f00003f00fc06c0c0000ce30002c00003250fc0c6c630c600ee0630c660c6c630c60ced000a0f00003f00fc06c0c0000ce30002c00003260fc0c6c630c600d67e30c660c6c630c60ced000b0f00003f00c07e7c7c003030e40002c00003260fc0c6c630c600d67e30c660c6c630c60ced000b0f00003f00c07e7c7c003030e40002c00003250fc06cc630c600c6c630c6306cc630c618ed000a0f00003f00c0c6060600c0e30002c00003250fc06cc630c600c6c630c6306cc630c618ed000a0f00003f00c0c6060600c0e30002c00003270fc0387c787e00c67e78c618387c787e30ed000c0f00003f00c07efcfc00fe0000e51802c00003270fc0387c787e00c67e78c618387c787e30ed000c0f00003f00c07efcfc00fe0000e51802c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000032b01c01cdf00060f00003f00fec0fd000330000030fa00033000003cfc000070fe000830c000003c00c000032b01c01cdf00060f00003f00fec0fd000330000030fa00033000003cfc000070fe000830c000003c00c000032801c030df00060f00003f0030c0fa000070fa000330000066fc000030fe000830c000006600c000032801c030df00060f00003f0030c0fa000070fa000330000066fc000030fe000830c000006600c000033201c030df002b0f00003f0030fc7cbc7c00707e0030007e7c7cc67cfcfc0000607cbc007c00307cfc7cfcfc007c6000c000033201c030df002b0f00003f0030fc7cbc7c00707e0030007e7c7cc67cfcfc0000607cbc007c00307cfc7cfcfc007c6000c000033101c060df00050f00003f0030fdc6150030c0003000c0c6c6eec6c6300000f8c6c600060030fec60830c600c6f800c000033101c060df00050f00003f0030fdc6150030c0003000c0c6c6eec6c6300000f8c6c600060030fec60830c600c6f800c000033201c030df002b0f00003f0030c6fec0fe00307c0030007cfec6d6fec630000060c6c0007e0030fec6c630c600c66000c000033201c030df002b0f00003f0030c6fec0fe00307c0030007cfec6d6fec630000060c6c0007e0030fec6c630c600c66000c000033201c030df00060f00003f0030c6fec02100300600300006c07ec6c0c636300060c6c000c60030c0c67e36c600c66000c000033201c030df00060f00003f0030c6fec02100300600300006c07ec6c0c636300060c6c000c60030c0c67e36c600c66000c000030098005000800000010002800080000001000280008000000100028000013201c01cdf002b0f00003f0030c67ec07e0078fc007800fc7e06c67ec61c3000607cc0007e00787ec6061cc6007c6000c000033201c01cdf002b0f00003f0030c67ec07e0078fc007800fc7e06c67ec61c3000607cc0007e00787ec6061cc6007c6000c000031b00c0de00030f00003ff300007cfd000060f700007cfb0002c000031b00c0de00030f00003ff300007cfd000060f700007cfb0002c000032f0cc000003000303c186cc6007070fb00017006fe00016c30f700080f00003f00c6007070fb00017006e90002c000032f0cc000003000303c186cc6007070fb00017006fe00016c30f700080f00003f00c6007070fb00017006e90002c000032e00c0fd00073066306cc6003030fb0006300600c0006c18f700080f00003f00c6003030fb00013006e90002c000032e00c0fd00073066306cc6003030fb0006300600c0006c18f700080f00003f00c6003030fb00013006e90002c000033519c0fcbc70fcfc60606cc67c30307c0000c67cbc307e0060fc6c0cf700100f00003f00c67c30307c0000c67cbc307ee90002c000033519c0fcbc70fcfc60606cc67c30307c0000c67cbc307e0060fc6c0cf700100f00003f00c67c30307c0000c67cbc307ee90002c00003360fc0c6c630c630f86000fec63030c60000fec60730c60030c6000c30f8000b0f00003f00fec63030c60000fec60130c6e90002c00003360fc0c6c630c630f86000fec63030c60000fec60730c60030c6000c30f8000b0f00003f00fec63030c60000fec60130c6e90002c000033519c0c6c030c630606000c6fe3030c60000d6c6c030c60018c6000cf700100f00003f00c6fe3030c60000d6c6c030c6e90002c000033519c0c6c030c630606000c6fe3030c60000d6c6c030c60018c6000cf700100f00003f00c6fe3030c60000d6c6c030c6e90002c00003361ac0fcc030c636603000c6c03030c63000eec6c030c6000cc6001830f800100f00003f00c6c03030c63000eec6c030c6e90002c00003361ac0fcc030c636603000c6c03030c63000eec6c030c6000cc6001830f800100f00003f00c6c03030c63000eec6c030c6e90002c0000336fec01778c61c601800c67e78787c3000c67cc0787e1800c6003030f800110f00003f00c67e78787c3000c67cc0787e18ea0002c0000336fec01778c61c601800c67e78787c3000c67cc0787e1800c6003030f800110f00003f00c67e78787c3000c67cc0787e18ea0002c000031c01c0c0f5000060f6000060f800030f00003ffb000060e30002c000031c01c0c0f5000060f6000060f800030f00003ffb000060e30002c000031001c070df00030f00003fdc0002c000031001c070df00030f00003fdc0002c000031001c018df00030f00003fdc0002c000031001c018df00030f00003fdc0002c000031001c018df00030f00003fdc0002c000031001c018df00030f00003fdc0002c000031001c00cdf00030f00003fdc0002c000031001c00cdf00030f00003fdc0002c000031001c018df00030f00003fdc0002c000031001c018df00030f00003fdc0002c000031001c018df00030f00003fdc0002c000031001c018df00030f00003fdc0002c000031001c070df00030f00003fdc0002c000031001c070df00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030b00c0de00030f00003fd9ff0b00c0de00030f00003fd9ff0f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030b00c0de00030f00003fd9ff0b00c0de00030f00003fd9ff0d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000031200c0e400010ee0fd00030f00003cda0000031200c0e400010ee0fd00030f00003cda0000031100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000030098005001000000018002800100000001800280010000000180028000011100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000031200c0e400010ee0fd00030f00003cda0000031200c0e400010ee0fd00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030ffffffcda0000030d00c0de00030ffffffcda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030d00c0de00030ffffffcda0000030d00c0de00030ffffffcda0000030d00c0de00030c00000cda0000030d00c0de00030c00000cda0000030d00c0de00030c0ffc0cda0000030d00c0de00030c0ffc0cda0000030a00c0de00fd0cda0000030a00c0de00fd0cda0000030a00c0de00fd0cda0000030a00c0de00fd0cda0000030a00c0de00fd0cda0000030a00c0de00fd0cda0000030d00c0de00030cfc0fccda0000030d00c0de00030cfc0fccda0000030d00c0de00030c30030cda0000030d00c0de00030c30030cda0000030a00c0de00fd0cda0000030a00c0de00fd0cda0000030d00c0de00030c03300cda0000030d00c0de00030c03300cda0000030d00c0de00030c00c00cda0000030d00c0de00030c00c00cda0000030d00c0de00030c00000cda0000030d00c0de00030c00000cda00000308daff00fcda00000308daff00fcda0000031602c00001fdff00f3e833063800000c00000cda0000031602c00001fdff00f3e833063800000c00000cda0000031703c03801f0fe00006ce8cc06f803800cffc00cda0000031703c03801f0fe00006ce8cc06f803800cffc00cda0000031703c0d801f0fe000073e833063803600cc0c00cda0000031703c0d801f0fe000073e833063803600cc0c00cda0000031703c31ff1f0fe00006ce8cc06f9ff180cc0ffccda0000031703c31ff1f0fe00006ce8cc06f9ff180cc0ffccda0000031703cc0031f0fe000073e833063980060cc0c0ccda0000031703cc0031f0fe000073e833063980060cc0c0ccda0000031703f00031f0fe00006ce8cc06f980018cffc0ccda0000031703f00031f0fe00006ce8cc06f980018cffc0ccda0000030098005001800000019202800180000001920280018000000192028000011703cc0031f0fe000073e833063980060c1800ccda0000031703cc0031f0fe000073e833063980060c1800ccda0000031703c31ff1f0fe00006ce8cc06f9ff180c1800ccda0000031703c31ff1f0fe00006ce8cc06f9ff180c1800ccda0000031703c0d801f0fe000073e833063803600c1800ccda0000031703c0d801f0fe000073e833063803600c1800ccda0000031703c03801f0fe00006ce8cc06f803800c1fffccda0000031703c03801f0fe00006ce8cc06f803800c1fffccda0000031703c00001f0fe000073e833063800000c00000cda0000031703c00001f0fe000073e833063800000c00000cda0000031602c00001fdff00ece8cc06f800000c00000cda0000031602c00001fdff00ece8cc06f800000c00000cda00000308daff00fcda00000308daff00fcda0000030600c0b30000030600c0b300000302b1ff02b1ff00a0008f00a0008300ff}}}{\sp{\sn fLine}{\sv 0}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}}{\shprslt\par\widctlpar\pvpara\posy246\absh2804\absw4464\dxfrtext180\dfrmtxtx180\dfrmtxty0\adjustright {\pict\picscalex35\picscaley35\piccropl0\piccropr0\piccropt0\piccropb0\picw640\pich402\picwgoal12800\pichgoal8040\macpict\bliptag-36819094\blipupi72{\*\blipuid fdce2f6a8d2a44c0efb450c43a9b41f9}21fc0000000001920280001102ff0c00ffffffff000000000000000002800000019200000000000000a0008200a0303900a0008e001e0001000a0000000002d004a400980050000000000080028000000000008002800000000000800280000102b1ff02b1ff0600c0b30000030600c0b30000030903c0000038b60000030903c0000038b60000032e11c00000f0007c61c00003e063000030c60003fd00051f18000c00f8fc000603e0000003e003fe000003de0000032e11c00000f0007c61c00003e063000030c60003fd00051f18000c00f8fc000603e0000003e003fe000003de0000033011c0003f3e006000c0000300600c0030c00003fd00071800000c00c000c0fe000603300000033003fe000003de0000033011c0003f3e006000c0000300600c0030c00003fd00071800000c00c000c0fe000603300000033003fe000003de0000033a34c000fffc0060e0c1e00303e71f0036ce3e1f1e618f001838f87c00c199f1b1f1e0033333e00331e3e331f00301f3e1f331f1f1e1e0e70000033a34c000fffc0060e0c1e00303e71f0036ce3e1f1e618f001838f87c00c199f1b1f1e0033333e00331e3e331f00301f3e1f331f1f1e1e0e7000003330fc000fff8007860c33003c6630c0036c6fe33126d98001e18cccc00f0f0c1c3330003e3333003fd3302300303fa33e6000003330fc000fff8007860c33003c6630c0036c6fe33126d98001e18cccc00f0f0c1c3330003e3333003fd3302300303fa33e6000003370fc000ffff006060c3f00306630c0036c6fe33196d8f001818cccc00c060c18331e0036333300333f33333300303fb3301f1e0e7000003370fc000ffff006060c3f00306630c0036c6fe33196d8f001818cccc00c060c18331e0036333300333f33333300303fb3301f1e0e7000003390fc0007ffe006060c3000306630d801986fd332001801818cccc00c0f0d9833030033333300333033331f003033331f33331f30030e7000003390fc0007ffe006060c3000306630d801986fd332001801818cccc00c0f0d9833030033333300333033331f003033331f33331f30030e70000033a34c0003ef80060f1e1e003e3e78700198f331f1e330f00183ccc7c00f9987181f1e00331f33003e1e3e1f23003f1f33231f1f231e1e0e70000033a34c0003ef80060f1e1e003e3e78700198f331f1e330f00183ccc7c00f9987181f1e00331f33003e1e3e1f23003f1f33231f1f231e1e0e70000031300c0d9000101e0fe000401e00001e0e50000031300c0d9000101e0fe000401e00001e0e50000030600c0b30000030600c0b300000302b1ff02b1ff06d9ffda00000306d9ffda00000306d9ffda00000306d9ffda0000032003ffc0007ff5ff039fffc7c7f1ff03e0003ffff0000503c600038380f10000032003ffc0007ff5ff039fffc7c7f1ff03e0003ffff0000503c600038380f10000032003ffcffe7ff5ff039fffe7e7f1ff03e7cf3ffff00005066600018180f10000032003ffcffe7ff5ff039fffe7e7f1ff03e7cf3ffff00005066600018180f10000032403ffcffe7ff5ff0783c3e7e7c3fc3c3ff5ff03e7cf3ffff000050607c3c18180f10000032403ffcffe7ff5ff0783c3e7e7c3fc3c3ff5ff03e7cf3ffff000050607c3c18180f10000032403ffcffe7ff5ff079999e7e799f9999ff5ff03e00f3ffff0000503c666618180f10000032403ffcffe7ff5ff079999e7e799f9999ff5ff03e00f3ffff0000503c666618180f10000032203ffcffe7ff5ff069981e7e799f9f9f4ff03e7ff3fffef00046667e18180f10000032203ffcffe7ff5ff069981e7e799f9f9f4ff03e7ff3fffef00046667e18180f10000032403ffcffe7ff5ff07999fe7e799f9999ff5ff03e7ff3ffff00005066666018180f10000032403ffcffe7ff5ff07999fe7e799f9999ff5ff03e7ff3ffff00005066666018180f10000032303ffc0007ff5ff0099fdc3029c3c3ff5ff03e0003ffff0000503c663c3c3c0f10000032303ffc0007ff5ff0099fdc3029c3c3ff5ff03e0003ffff0000503c663c3c3c0f100000306d9ffda00000306d9ffda00000306d9ffda00000306d9ffda00000302b1ff02b1ff0c00c0de00000ffeffdc00feff0c00c0de00000ffeffdc00feff2012c06c30000070000600000c003006300000c060f000000ffeffdc0002c000032012c06c30000070000600000c003006300000c060f000000ffeffdc0002c000032001c06cfe0008300006000018003006fe0001c030f000000ffeffdc0002c000032001c06cfe0008300006000018003006fe0001c030f000000ffeffdc0002c000032012c0fe70fc7e30c67e7c00307efc7e707c00fc18f000000ffeffdc0002c000032012c0fe70fc7e30c67e7c00307efc7e707c00fc18f000000ffeffdc0002c000032005c06c30c6c030fec6090060c030c630c600c60cf000000ffeffdc0002c000032005c06c30c6c030fec6090060c030c630c600c60cf000000ffeffdc0002c000032112c0fe30c6c030c6c6fe00307c30c630c600c618f000030c00000fdc0002c000032112c0fe30c6c030c6c6fe00307c30c630c600c618f000030c00000fdc0002c000032112c06c30c6c030c6c6c000180636c630c600c630f000030c00c00fdc0002c000032112c06c30c6c030c6c6c000180636c630c600c630f000030c00c00fdc0002c000032112c06c78c67e787c7e7e000cfc1c7e787c18c660f000030c03300fdc0002c000032112c06c78c67e787c7e7e000cfc1c7e787c18c660f000030c03300fdc0002c000030e00c0de00fe0c000fdc0002c000030e00c0de00fe0c000fdc0002c000031500c0de00050c30030f00fcfd000030e30002c000031500c0de00050c30030f00fcfd000030e30002c000031500c0de00050cfc0fcf00c6fd000070e30002c000031500c0de00050cfc0fcf00c6fd000070e30002c000031600c0de00fe0c080f00c67c7e7e003030e40002c000031600c0de00fe0c080f00c67c7e7e003030e40002c000031500c0de00fe0c070f00fc06c0c00030e30002c000031500c0de00fe0c070f00fc06c0c00030e30002c000031600c0de00fe0c080f00c07e7c7c003030e40002c000031600c0de00fe0c080f00c07e7c7c003030e40002c000031600c0de000a0c0ffc0f00c0c606060030e30002c000031600c0de000a0c0ffc0f00c0c606060030e30002c000031800c0de000c0c00000f00c07efcfc00780000e51802c000031800c0de000c0c00000f00c07efcfc00780000e51802c000030e00c0de00000ffeffdc0002c000030e00c0de00000ffeffdc0002c000032404c000003006fe00073000180000300630ed00000ffeff0100fcfd00007ce30002c000032404c000003006fe00073000180000300630ed00000ffeff0100fcfd00007ce30002c000032200c0fe000006fc000030fe00010618ed00050f00003f00c6fd0000c6e30002c000032200c0fe000006fc000030fe00010618ed00050f00003f00c6fd0000c6e30002c00003260fc0c67c707e00c67c70fc60c67c707e0ced000b0f00003f00c67c7e7e000630e40002c00003260fc0c67c707e00c67c70fc60c67c707e0ced000b0f00003f00c67c7e7e000630e40002c00003250fc0c6c630c600ee0630c660c6c630c60ced000a0f00003f00fc06c0c0000ce30002c00003250fc0c6c630c600ee0630c660c6c630c60ced000a0f00003f00fc06c0c0000ce30002c00003260fc0c6c630c600d67e30c660c6c630c60ced000b0f00003f00c07e7c7c003030e40002c00003260fc0c6c630c600d67e30c660c6c630c60ced000b0f00003f00c07e7c7c003030e40002c00003250fc06cc630c600c6c630c6306cc630c618ed000a0f00003f00c0c6060600c0e30002c00003250fc06cc630c600c6c630c6306cc630c618ed000a0f00003f00c0c6060600c0e30002c00003270fc0387c787e00c67e78c618387c787e30ed000c0f00003f00c07efcfc00fe0000e51802c00003270fc0387c787e00c67e78c618387c787e30ed000c0f00003f00c07efcfc00fe0000e51802c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000032b01c01cdf00060f00003f00fec0fd000330000030fa00033000003cfc000070fe000830c000003c00c000032b01c01cdf00060f00003f00fec0fd000330000030fa00033000003cfc000070fe000830c000003c00c000032801c030df00060f00003f0030c0fa000070fa000330000066fc000030fe000830c000006600c000032801c030df00060f00003f0030c0fa000070fa000330000066fc000030fe000830c000006600c000033201c030df002b0f00003f0030fc7cbc7c00707e0030007e7c7cc67cfcfc0000607cbc007c00307cfc7cfcfc007c6000c000033201c030df002b0f00003f0030fc7cbc7c00707e0030007e7c7cc67cfcfc0000607cbc007c00307cfc7cfcfc007c6000c000033101c060df00050f00003f0030fdc6150030c0003000c0c6c6eec6c6300000f8c6c600060030fec60830c600c6f800c000033101c060df00050f00003f0030fdc6150030c0003000c0c6c6eec6c6300000f8c6c600060030fec60830c600c6f800c000033201c030df002b0f00003f0030c6fec0fe00307c0030007cfec6d6fec630000060c6c0007e0030fec6c630c600c66000c000033201c030df002b0f00003f0030c6fec0fe00307c0030007cfec6d6fec630000060c6c0007e0030fec6c630c600c66000c000033201c030df00060f00003f0030c6fec02100300600300006c07ec6c0c636300060c6c000c60030c0c67e36c600c66000c000033201c030df00060f00003f0030c6fec02100300600300006c07ec6c0c636300060c6c000c60030c0c67e36c600c66000c000030098005000800000010002800080000001000280008000000100028000013201c01cdf002b0f00003f0030c67ec07e0078fc007800fc7e06c67ec61c3000607cc0007e00787ec6061cc6007c6000c000033201c01cdf002b0f00003f0030c67ec07e0078fc007800fc7e06c67ec61c3000607cc0007e00787ec6061cc6007c6000c000031b00c0de00030f00003ff300007cfd000060f700007cfb0002c000031b00c0de00030f00003ff300007cfd000060f700007cfb0002c000032f0cc000003000303c186cc6007070fb00017006fe00016c30f700080f00003f00c6007070fb00017006e90002c000032f0cc000003000303c186cc6007070fb00017006fe00016c30f700080f00003f00c6007070fb00017006e90002c000032e00c0fd00073066306cc6003030fb0006300600c0006c18f700080f00003f00c6003030fb00013006e90002c000032e00c0fd00073066306cc6003030fb0006300600c0006c18f700080f00003f00c6003030fb00013006e90002c000033519c0fcbc70fcfc60606cc67c30307c0000c67cbc307e0060fc6c0cf700100f00003f00c67c30307c0000c67cbc307ee90002c000033519c0fcbc70fcfc60606cc67c30307c0000c67cbc307e0060fc6c0cf700100f00003f00c67c30307c0000c67cbc307ee90002c00003360fc0c6c630c630f86000fec63030c60000fec60730c60030c6000c30f8000b0f00003f00fec63030c60000fec60130c6e90002c00003360fc0c6c630c630f86000fec63030c60000fec60730c60030c6000c30f8000b0f00003f00fec63030c60000fec60130c6e90002c000033519c0c6c030c630606000c6fe3030c60000d6c6c030c60018c6000cf700100f00003f00c6fe3030c60000d6c6c030c6e90002c000033519c0c6c030c630606000c6fe3030c60000d6c6c030c60018c6000cf700100f00003f00c6fe3030c60000d6c6c030c6e90002c00003361ac0fcc030c636603000c6c03030c63000eec6c030c6000cc6001830f800100f00003f00c6c03030c63000eec6c030c6e90002c00003361ac0fcc030c636603000c6c03030c63000eec6c030c6000cc6001830f800100f00003f00c6c03030c63000eec6c030c6e90002c0000336fec01778c61c601800c67e78787c3000c67cc0787e1800c6003030f800110f00003f00c67e78787c3000c67cc0787e18ea0002c0000336fec01778c61c601800c67e78787c3000c67cc0787e1800c6003030f800110f00003f00c67e78787c3000c67cc0787e18ea0002c000031c01c0c0f5000060f6000060f800030f00003ffb000060e30002c000031c01c0c0f5000060f6000060f800030f00003ffb000060e30002c000031001c070df00030f00003fdc0002c000031001c070df00030f00003fdc0002c000031001c018df00030f00003fdc0002c000031001c018df00030f00003fdc0002c000031001c018df00030f00003fdc0002c000031001c018df00030f00003fdc0002c000031001c00cdf00030f00003fdc0002c000031001c00cdf00030f00003fdc0002c000031001c018df00030f00003fdc0002c000031001c018df00030f00003fdc0002c000031001c018df00030f00003fdc0002c000031001c018df00030f00003fdc0002c000031001c070df00030f00003fdc0002c000031001c070df00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030b00c0de00030f00003fd9ff0b00c0de00030f00003fd9ff0f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030f00c0de00030f00003fdc0002c000030b00c0de00030f00003fd9ff0b00c0de00030f00003fd9ff0d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000031200c0e400010ee0fd00030f00003cda0000031200c0e400010ee0fd00030f00003cda0000031100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000030098005001000000018002800100000001800280010000000180028000011100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000031100c0e4000001fc00030f00003cda0000031200c0e400010ee0fd00030f00003cda0000031200c0e400010ee0fd00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030f00003cda0000030d00c0de00030ffffffcda0000030d00c0de00030ffffffcda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030c00c0de00000cfeccda0000030c00c0de00000cfeccda0000030d00c0de00030f33333cda0000030d00c0de00030f33333cda0000030d00c0de00030ffffffcda0000030d00c0de00030ffffffcda0000030d00c0de00030c00000cda0000030d00c0de00030c00000cda0000030d00c0de00030c0ffc0cda0000030d00c0de00030c0ffc0cda0000030a00c0de00fd0cda0000030a00c0de00fd0cda0000030a00c0de00fd0cda0000030a00c0de00fd0cda0000030a00c0de00fd0cda0000030a00c0de00fd0cda0000030d00c0de00030cfc0fccda0000030d00c0de00030cfc0fccda0000030d00c0de00030c30030cda0000030d00c0de00030c30030cda0000030a00c0de00fd0cda0000030a00c0de00fd0cda0000030d00c0de00030c03300cda0000030d00c0de00030c03300cda0000030d00c0de00030c00c00cda0000030d00c0de00030c00c00cda0000030d00c0de00030c00000cda0000030d00c0de00030c00000cda00000308daff00fcda00000308daff00fcda0000031602c00001fdff00f3e833063800000c00000cda0000031602c00001fdff00f3e833063800000c00000cda0000031703c03801f0fe00006ce8cc06f803800cffc00cda0000031703c03801f0fe00006ce8cc06f803800cffc00cda0000031703c0d801f0fe000073e833063803600cc0c00cda0000031703c0d801f0fe000073e833063803600cc0c00cda0000031703c31ff1f0fe00006ce8cc06f9ff180cc0ffccda0000031703c31ff1f0fe00006ce8cc06f9ff180cc0ffccda0000031703cc0031f0fe000073e833063980060cc0c0ccda0000031703cc0031f0fe000073e833063980060cc0c0ccda0000031703f00031f0fe00006ce8cc06f980018cffc0ccda0000031703f00031f0fe00006ce8cc06f980018cffc0ccda0000030098005001800000019202800180000001920280018000000192028000011703cc0031f0fe000073e833063980060c1800ccda0000031703cc0031f0fe000073e833063980060c1800ccda0000031703c31ff1f0fe00006ce8cc06f9ff180c1800ccda0000031703c31ff1f0fe00006ce8cc06f9ff180c1800ccda0000031703c0d801f0fe000073e833063803600c1800ccda0000031703c0d801f0fe000073e833063803600c1800ccda0000031703c03801f0fe00006ce8cc06f803800c1fffccda0000031703c03801f0fe00006ce8cc06f803800c1fffccda0000031703c00001f0fe000073e833063800000c00000cda0000031703c00001f0fe000073e833063800000c00000cda0000031602c00001fdff00ece8cc06f800000c00000cda0000031602c00001fdff00ece8cc06f800000c00000cda00000308daff00fcda00000308daff00fcda0000030600c0b30000030600c0b300000302b1ff02b1ff00a0008f00a0008300ff}\par}}}{Well, the time has come to actually run your first C program.  Pull down the Debug menu and select Go.  This tells the compiler to compile, link, and execute your program.  The first thing you will see is the shell window.  After some whirring of the ORCA/C disk, you will see a message printed by the linker as it links the program.  The compiler doesn't print anything unless it finds an error.  Finally, your program runs, and the characters "Hello, world." appear in the window.\par It may seem like all of this took a long time, and it did.  The first time you compile a program after booting the computer, several very large files are loaded from disk.  The process is much faster the second time, since these files will stay in memory.\par Go ahead \endash  give yourself a cheap thrill.  You've earned it.  Select Go again, and run the program a second time.  Maybe even a third!\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {\lang1024 {\*\bkmkstart _Toc496344373}{\shp{\*\shpinst\shpleft0\shptop330\shpright4464\shpbottom2634\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz4\shplid1136{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 5308416}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s22\qc\sa200\nowidctlpar\adjustright \b\f4\fs20\cgrid {Sizing the Program Window\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {If you forget to resize your program window, it may not look like anything worked.  Once the program finishes executing, though, you can resize the program window to uncover the shell window.  You will find that the program ran correctly, but that you just didn't see the text until you resized the window.\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8196\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s22\qc\sa200\nowidctlpar\adjustright \b\f4\fs20\cgrid {Sizing the Program Window\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {If you forget to resize your program window, it may not look like anything worked.  Once the program finishes executing, though, you can resize the program window to uncover the shell window.  You will find that the program ran correctly, but that you just didn't see the text until you resized the window.\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx0\dpy330\dpxsize4464\dpysize2304\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{A Close Look at Hello World{\*\bkmkend _Toc496344373}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Now that you have actually run a program, let's stop and spend some time talking about what happened.  We'll start by examining the program in detail.  The first step is to take a look at the words that make up the program\par }{\lang1024 {\shp{\*\shpinst\shpleft4752\shptop-12469\shpright9360\shpbottom-3973\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz5\shplid1137{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 5242880}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s22\qc\sa200\nowidctlpar\adjustright \b\f4\fs20\cgrid {Program Didn't Run?\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {If something else happened, check each step to see what you did wrong.  One of the most common programmer mistakes is to assume that any mistake is the computer's fault.  Sorry, it just ain't so.  If things didn't work it's because, in order of likelihood:\par \par }\pard \s21\qj\fi-360\li720\widctlpar\adjustright {1.\tab You didn't do exactly what you were told.\par 2.\tab You have set up a large RAM disk, tying up so much memory that ORCA/C could not work.   Get rid of the RAM disk.  Be sure and power down and back up after setting the size of the RAM  disk to zero.\par 3.\tab You don't have the correct hardware.\par 4.\tab You have a bad disk.\par 5.\tab You have bad hardware.\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par Just for the record, you should know that absolutely every program we will show you in this course has been mechanically moved from the word processor to ORCA/C and executed.  If you encounter a problem, the chances are very, very high that you did something wrong.  It isn't unheard of to find a bug in the development software, but we get far more bug reports that turn out to be programmer errors than bug reports that actually turn out to be a bug in ORCA/C.\par To correct a problem, go back over each step in the text.  If the program cannot be compiled, the compiler will give you an error message telling why.  It also puts the flashing insertion-point near the place in the program where the error occurred.  Check your typing in the area very carefully; a typing error is the most common cause of errors at this stage.\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8197\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s22\qc\sa200\nowidctlpar\adjustright \b\f4\fs20\cgrid {Program Didn't Run?\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {If something else happened, check each step to see what you did wrong.  One of the most common programmer mistakes is to assume that any mistake is the computer's fault.  Sorry, it just ain't so.  If things didn't work it's because, in order of likelihood:\par \par }\pard \s21\qj\fi-360\li720\widctlpar\adjustright {1.\tab You didn't do exactly what you were told.\par 2.\tab You have set up a large RAM disk, tying up so much memory that ORCA/C could not work.   Get rid of the RAM disk.  Be sure and power down and back up after setting the size of the RAM  disk to zero.\par 3.\tab You don't have the correct hardware.\par 4.\tab You have a bad disk.\par 5.\tab You have bad hardware.\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par Just for the record, you should know that absolutely every program we will show you in this course has been mechanically moved from the word processor to ORCA/C and executed.  If you encounter a problem, the chances are very, very high that you did something wrong.  It isn't unheard of to find a bug in the development software, but we get far more bug reports that turn out to be programmer errors than bug reports that actually turn out to be a bug in ORCA/C.\par To correct a problem, go back over each step in the text.  If the program cannot be compiled, the compiler will give you an error message telling why.  It also puts the flashing insertion-point near the place in the program where the error occurred.  Check your typing in the area very carefully; a typing error is the most common cause of errors at this stage.\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx4752\dpy-12469\dpxsize4608\dpysize8496\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{Like sentences in a book, programs are made up of a series of words and punctuation marks.  Some of the words have special meaning, while some are words we pick to name parts of the program.  We'll dissect our first program to look at some of these rules.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par printf("Hello, world.\\n");\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par One of the things about C that you will become very familiar with in this course is the C library.  The C library is a huge collection of subroutines that do a wide variety of things for you.  The size and standardization of the C library is one of the major strengths of the C programming language.\par }{\lang1024 {\shp{\*\shpinst\shpleft0\shptop-473\shpright4608\shpbottom8743\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz6\shplid1138{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 5177344}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s22\qc\sa200\nowidctlpar\adjustright \b\f4\fs20\cgrid {What is a Compiler?\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {In several places, I have mentioned a thing called a compiler.  A compiler is a program that translates the program you write into something the machine can execute.  You see, your Apple IIGS does not understand C, or Pascal, or BASIC, or even assembly language.  All it understands are the individual bits stuffed into bytes that computer types call machine language.  No one in his right mind actually programs in machine language if given a choice.  Instead, they program in some language, like C, then use a program called a compiler.  The compiler reads the program you type, and figures out what the program is supposed to do.  The compiler then writes a machine language program that does the same thing.  It's a lot like taking a translator with you to Japan.  You tell the translator that you desperately need to find a good Italian restaurant.  The translator takes your words and reforms them in Japanese, asking the bell clerk at the hotel.  In computer terms, the translator would be called a compiler.  If you spoke German instead of English, you would need a different translator.  The same is true with compilers.  If you want to write the program in Pascal instead of C, you need a different compiler.\par One of the advantages of a language like C is that it does not depend on the computer you are using.  On the Apple IIGS, you are using ORCA/C, which translates C programs into machine language programs the Apple IIGS can run.  A Macintosh computer cannot run this program, but you could use MPW C on the Macintosh.  MPW C can read the same program we have typed, and create a machine language program for the Macintosh.  This program will do exactly the same thing on the Macintosh that it does on the Apple IIGS.\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8198\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s22\qc\sa200\nowidctlpar\adjustright \b\f4\fs20\cgrid {What is a Compiler?\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {In several places, I have mentioned a thing called a compiler.  A compiler is a program that translates the program you write into something the machine can execute.  You see, your Apple IIGS does not understand C, or Pascal, or BASIC, or even assembly language.  All it understands are the individual bits stuffed into bytes that computer types call machine language.  No one in his right mind actually programs in machine language if given a choice.  Instead, they program in some language, like C, then use a program called a compiler.  The compiler reads the program you type, and figures out what the program is supposed to do.  The compiler then writes a machine language program that does the same thing.  It's a lot like taking a translator with you to Japan.  You tell the translator that you desperately need to find a good Italian restaurant.  The translator takes your words and reforms them in Japanese, asking the bell clerk at the hotel.  In computer terms, the translator would be called a compiler.  If you spoke German instead of English, you would need a different translator.  The same is true with compilers.  If you want to write the program in Pascal instead of C, you need a different compiler.\par One of the advantages of a language like C is that it does not depend on the computer you are using.  On the Apple IIGS, you are using ORCA/C, which translates C programs into machine language programs the Apple IIGS can run.  A Macintosh computer cannot run this program, but you could use MPW C on the Macintosh.  MPW C can read the same program we have typed, and create a machine language program for the Macintosh.  This program will do exactly the same thing on the Macintosh that it does on the Apple IIGS.\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx0\dpy-473\dpxsize4608\dpysize9216\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{The C compiler doesn't know about the C library.  In our C programs, we have to tell the C compiler about the library.  The first line of our program tells the compiler about the subroutines in a library called stdio, which is short for Standard Input/Output.  This library contains most of the text formatting, console input and output, and disk input and output subroutines.  In particular, it defines a subroutine called printf, which can be used to print text.\par Technically, #include is part of the preprocessor.  That's an idea you will become more familiar with a little later in the course.  This preprocessor command tells the compiler to find another C program file, and to process that file first.  The C compiler goes to the library folder and looks for a file called stdio.h; you can look at the file, too.  To see what the compiler saw, pull down the File menu and select Open.  Click on the disk button until you see the ORCA.C disk.  Open the LIBRARIES folder, then open the ORCACDEFS folder that you find inside of the LIBRARIES folder.  Inside of this folder, towards the bottom of a long list of files, you will find one called STDIO.H.  Open that file.  What you will see is an impressive collection of gibberish.  There is no particular reason for you to understand it all at the moment.  The point is that the #include preprocessor command tells the compiler to process a simple text file.  You can put anything you like in the text file.  Later, you will learn how to use this capability to split large programs up into several small, manageable files.\par Right below the #include command is a blank line.  The blank line is for our convenience; the C compiler really doesn't care if there is a blank line there or not.  You can remove it, or put in several more, and the program will do exactly the same thing.  We use the blank line to make the program easier to read.  It's sort of like putting the chapter in books at the top of a new page.  The book says the same thing if we don't, but it is easier to find the start of the chapter if we know it will be on a page by itself.  You will find a lot of conventions like this described in the course.\par C programs are made up of a series of variable declarations, preprocessor commands and functions.  These can be freely mixed, with just a few rules we will learn later.  Our simple program doesn't have any variable declarations.  It does, however, have a function.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {void main(void)\par \par \{\par printf("Hello, world.\\n");\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Each function in a C program has several distinct parts.  The first part, which we generally put on a single line, tells the compiler the name of the function, what it returns, and what we need to pass to the function when it is called.  The name of this function is main.  Every C program must have a function called main; this is the first function executed when the program starts.  This function doesn't return anything.  We tell the compiler that it doesn't return anything by putting void right before the name of the function.  Right after the name of the function, we put any parameters that will be passed to the function when it is called.  Again, void is used to tell the compiler that there aren't any parameters.  This is the simplest kind of function:  it does something, but no parameters are passed, and it doesn't return anything.\par The last three lines,\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\{\par printf("Hello, world.\\n");\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {are the lines that tell the compiler what the function actually does.  The \{ character and \} character mark the start and end of the statements in the function.  Between these characters is the only line in the program that actually does anything, the call to the printf function.  printf is a library function, defined in the stdio library.  The characters that we want the program to print are placed in a string constant.  In C, string constants are enclosed in quote marks.  You can put any character you like in a string constant, although there are some tricks to using a few of them; we'll look at the tricks in the next section.  The string constant is a parameter that is passed to the printf function.  Like all parameters, it is enclosed in parenthesis, and comes right after the name of the function.  The line ends with a semicolon.  All C statements end with a semicolon; this tells the compiler where the statement ends.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344374}Escape Sequences{\*\bkmkend _Toc496344374}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {You may have noticed one slightly strange thing about the program.  Supposedly, printf prints all of the characters in the string constant.  On the other hand, you can see two characters, \\ and n, at the end of the string constant \endash  these were not printed.\par The \\ character has special meaning inside of a string constant, where it is used to mark the start of something called an escape sequence.  Escape sequences give you a way to put characters into the program that you normally can't see, and in many cases, can't even type.  The \\n escape sequence puts a line feed character in the string.  When the line feed character is printed, it starts a new line in the shell window.\par To see how this works, make a small change to your program and run it again.  The change is to replace the space between Hello and world with a \\n escape sequence.  Your program will look like this after you make the change:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par printf("Hello,\\nworld.\\n");\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Run this program, and look at the results in the shell window.  This time, Hello and word appear on different lines.\par There are quite a few escape sequences in C.  As you go through the course, you will learn about most of the escape sequences, and it will make more sense to see them as they are used, rather than simply looking at a list of the various codes.  You can find a list of the escape sequences in your compiler reference manual, though.  C is a large language, and to use it effectively, you will need to learn to use your compiler reference manual well, too.  Take a moment and find the escape sequences in the compiler reference manual.  If you are curious (and I hope you are!) you should read the section of the reference manual that describes them.  Some of the information may already make sense to you, while some will not; that's to be expected.  Like I said, you will see most of the escape sequences in real programs in this course, where they will probably make a lot more sense.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 1.1.}{  Rewrite the hello world program so it says hello to you.  For example, my name is Mike, so I rewrote the program to say "Hello, Mike."  Save this program as NAME.CC.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Note:  When you name a program, always choose ten or fewer characters that start with a letter and contain only letters and spaces.  Append a .CC onto the end.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344375}Reserved Words{\*\bkmkend _Toc496344375}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Like English text, C programs are made up of words and punctuation marks.  You have already seen a few of the punctuation marks, including the # character, which starts a preprocessor command; the ; character, which marks the end of a line; the ( and ) characters, which mark the start and end of a parameter list; and the \{ and \} characters, which mark the start and end of the statements in a function.  The words in the first program were include, void, main, and printf.  You also saw a quoted string, which is called a string constant in C.\par There is one major difference between words in English and words in C, though.  Some words in C can only be used for very specific purposes.  These are called reserved words.  In our first program, void was the only reserved word we used.  As you learn to program in C, you will eventually encounter all of the reserved words, and find out what they are.  You will also start to use words to define your own functions and variables, though, and you have to know what the reserved words are so you won't accidentally use one of the reserved words.  While you don't need to memorize them, you do need to know they exist.  If you run into a strange error trying to get a program to work, you can refer back to this list of reserved words to see if misusing a reserved word is the cause of the problem.  (The same list is in your compiler reference manual, too.)\par \par }\pard \s21\qj\fi360\keepn\widctlpar\adjustright {Reserved Words in ORCA/C\par \par }\pard\plain \s23\qj\li360\keepn\widctlpar\tx1440\tx2520\tx3600\adjustright \f6\fs20\cgrid {\fs18 auto\tab asm\tab break\tab case\par char\tab comp\tab const\tab continue\par default\tab do\tab double\tab else\par enum\tab extended\tab extern\tab float\par for\tab goto\tab if\tab inline\par int\tab long\tab pascal\tab register\par return\tab segment\tab short\tab signed\par sizeof\tab static\tab struct\tab switch\par typedef\tab union\tab unsigned\tab void\par }\pard \s23\qj\li360\widctlpar\tx1440\tx2520\tx3600\adjustright {\fs18 volitile\tab while\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344376}Case Sensitivity{\*\bkmkend _Toc496344376}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {C is case sensitive.  That means that there is a difference between two words that are spelled the same, but have different cases in the letters.  For example, Void is not a reserved word in C, but void is.  The name of the function that always gets executed first is main, with no capitol letters.  Main is not the same thing, and the compiler will get confused if you try to use it for the name of the main function.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {\lang1024 {\*\bkmkstart _Toc496344377}{\shp{\*\shpinst\shpleft0\shptop19\shpright9360\shpbottom3619\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz7\shplid1139{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 5111808}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 1.1\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par printf("There was an old man with a beard\\n");\par printf("Who said, \\"It is just as I feared!\\"\\n");\par printf("    Two Owls and a Hen,\\n");\par printf("    Four Larks and a Wren,\\n");\par printf("Have all built their nests in my beard.\\n");\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8199\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 1.1\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par printf("There was an old man with a beard\\n");\par printf("Who said, \\"It is just as I feared!\\"\\n");\par printf("    Two Owls and a Hen,\\n");\par printf("    Four Larks and a Wren,\\n");\par printf("Have all built their nests in my beard.\\n");\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx0\dpy19\dpxsize9360\dpysize3600\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{How Programs Execute{\*\bkmkend _Toc496344377}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {With what we know now, we can start to write larger programs.  Our first step will be to modify the hello, world program to write five lines instead of one.\par Type in the program in listing 1.1 and save it on your program disk as LIMERICK.CC.  When you type the program, pay special attention to the \\ characters in the strings, and what follows.  You already knew about the \\n escape sequence; it starts a new line in the shell window.  The \\" escape sequence is new, though.  We needed a quote mark in our string, but a quote mark is used to mark the end of a string, too.  The \\" escape sequence puts a quote mark in the string without marking the end of the string.\par Use the Go command in the Debug menu to run the program.  Did the program do what you expected?  It does bring up an obvious point.  Like sentences in a book, the compiler reads and processes your program in the order it is written.  The first line is executed first, the second is executed second, and so on.\par We will introduce a new capability to see this a bit better.  Pull down the Debug menu again, but this time, choose the Step command.  Instead of executing, everything stops.  The only menu that is not highlighted is the Debug menu, so that is the only one that you can select anything from.  You may have noticed the menu bar flashing through this state before and wondered why.  This indicates that your program is still running.  You can't use anything but the Debug menu until the program is finished.\par Now look at your program window.  There is an arrow pointing to the first line of the program.  This arrow shows the next line to be executed.  The program is waiting for you to tell it to go ahead.  Pull down the debug menu again, and select Step a second time.  This tells the program to step to the next line.  The arrow moves down, and the first line of the limerick appears in the shell window.  The keyboard equivalent for Step is }{\outl \u-3\'f0}{[.  Use that keystroke to step through the rest of the program.\par What you have just used is called a source-level debugger.  It lets you step through a program one line at a time to see what the program is actually doing.  You see, computers have one very bad habit:  they do what you tell them to do, instead of what you want them to do.  When your program does something different than you expect, the source level debugger can often help you find out what the computer is actually doing.  Once you know that, it is usually easy to correct the program, so the computer does what you want it to do.  As you learn more about C, you will also learn more about the debugger.  For now, it would be a good idea to use the debugger to step through each of your programs, so you can see what the computer is actually doing.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 1.2.}{  Write a program that prints your name and address.  Print the address on separate lines, just as you would on an envelope.\par \par }{\b Problem 1.3. }{ With a little work, you can create a readable letter by coloring in squares on a sheet of graph paper.  The smallest number of squares that works well for uppercase only letters is seven high by five wide.  This is the idea used to form characters on the computer screen from the small dots called pixels.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Write a program to write your first name to the screen in this form.  Use the * character to fill in the squares.  For example, I would ask the computer to write this to the screen:\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {*   *  ***  *   * *****\par ** **   *   *  *  *\par * * *   *   * *   *\par *   *   *   **    ***\par *   *   *   * *   *\par *   *   *   *  *  *\par }\pard \s23\qj\fi360\widctlpar\adjustright {*   *  ***  *   * *****\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344378}Graphics Programs{\*\bkmkend _Toc496344378}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {There's a lot you can do with text, but the Apple IIGS has some stunning graphics, too.  It's time to start using some of that power.  One word of caution, though:  like most computer languages, C does not have built-in graphics.  The information in this section that deals with graphics is particular to the Apple IIGS.  Other computers may do things a bit differently.\par The Apple IIGS has a large number of built-in subroutines to do complicated tasks for you.  These subroutines are called tools.  They are grouped by function into groups called tool sets.  The entire collection is what people refer to as the toolbox.  The toolbox is a large and wonderful collection which we won't have time to explore fully, but we will use some of the tools to do some work for us from time to time.  Graphics is one of those times.  We will be using a tool set called QuickDraw II, which is the graphics tool set on the Apple IIGS.  QuickDraw II is a powerful collection of low-level graphics routines.  The following program will be our first venture into graphics.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <quickdraw.h>\par \par void main(void)\par \par \{\par SetPenMode(0);\par SetSolidPenPat(0);\par SetPenSize(3,1);\par MoveTo(10,10);\par LineTo(90,10);\par LineTo(90,40);\par LineTo(10,40);\par LineTo(10,10);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Type in this program, and save it as SQAURE.CC, but don't run it yet.  Text programs write characters to the shell window, as you have already learned.  The shell window, though, is for text.  Graphics output is written to a special graphics window.  Before running your program, you must open the graphics window.  Do this now by pulling down the Run menu and selecting the Graphics Window command.  If you need to, resize your program window so you can see the entire graphics window.  Now run the program.  You will see a square, about one inch high and once inch wide, on your screen.  (Depending on the monitor you are using and how it is adjusted, the size of the square may vary a bit.)\par You may have noticed that the #include statement changed in this program.  In our text programs, we were using a library function called printf, which is defined in the stdio.h header file.  We're not using printf in this program, so we don't need that header file.  On the other hand, we are using several functions from the QuickDraw toolbox; these are defined in the quickdraw.h header file.  Remembering which header files you need can quickly become a daunting task.  Later, we'll learn a few tricks to make the compiler help you out.\par When you compile the program, it will take quite a bit longer than when you compiled the text programs.  This may seem strange.  After all, your program isn't much bigger than the ones you have written so far.  The difference is caused by the quickdraw.h header file, which is much longer than the stdio.h header file.\par Looking at the lines in the main function, the first three lines tell QuickDraw II how you want to draw lines.  SetPenMode(0) tells QuickDraw II to replace any existing dots with new dots.  That makes sense, so you might wonder why you need to bother.  QuickDraw II can do other things when it draws, so we need to start by telling it to do the simplest of the alternatives.  The next line, SetPenSize(3,1), tells QuickDraw that lines are three dots wide and one dot high.  You can pick other widths and heights for the line.  Since each dot on the graphics screen is about three times as high as it is wide, the choice in the example gives lines that are about the same thickness, whether they are horizontal or vertical.  Try some other values to see what they look like.  Finally, SetSolidPenPat(0) tells QuickDraw II to draw black lines.\par The next five lines draw a square in the graphics window.  To understand how they work, we need to start by examining the coordinate system used by QuickDraw II.  To QuickDraw, the top left dot in any window is at 0,0.  As you move to the right, the first number increases.  In other words, 90,0 is 90 dots to the right of 0,0, but on the same line.  As you move down, the second number increases.  The point 0,40 is 40 dots below 0,0.  You can use numbers so large they go outside of the graphics window.  In that case, you can't see the lines, but QuickDraw II will still draw all of the line that is in the window.  Give this a try by extending the square so the lower-right corner is at 500,500, rather than 90,40.\par Incidentally, if you didn't try stepping through the program with the debugger, I highly recommend doing that now.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 1.4.}{  In the 640 mode that ORCA/Pascal runs in, there are a total of four colors that you can use.  The SetSolidPenPat call is used to choose from these colors.  In our example, we used color 0 to draw the square in black.  The other three colors are 1, 2 and 3.  Try these.  What happens when the pen color is set to 3?\par \par }{\b Problem 1.5.}{  An equilateral triangle is a triangle where each of the three sides are the same length.  Write a new program to draw an equilateral triangle with 1 inch sides in the graphics window.  Make the bottom flat, with one point on the top.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {If you are having trouble with your program, be sure and use the debugger.  That way, you can see the lines drawn one at a time.  If only one line is out of place, this will help you nail the offending line.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }{\b Problem 1.6. }{ Modify the program in problem 1.5 to draw a six sided star by drawing two equilateral triangles, one pointed up and one pointed down, and overlapping the triangles.  Make the star green, and use thick lines.\par \par }{\b Problem 1.7.}{  Write your name in the graphics window by drawing lines.  If your name has letters with curves, use a few short lines to approximate the shape of the letter.\par \par }\pard\plain \widctlpar\adjustright \f4\cgrid {\b\fs36 \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \qc\nowidctlpar\adjustright \f4\cgrid {\b\fs36 {\*\bkmkstart _Toc496343276}Lesson One{\*\bkmkend _Toc496343276}\par }\pard \qc\widctlpar\adjustright {\b\fs36 Solutions to Problems\par }\pard \qj\widctlpar\adjustright {\b\fs28 \par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344379}Solution to problem 1.1.{\*\bkmkend _Toc496344379}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par printf("Hello, Mike.\\n");\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344380}Solution to problem 1.2.{\*\bkmkend _Toc496344380}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par printf("Mike Westerfield\\n");\par printf("4700 Irving Blvd. NW, Suite 207\\n");\par printf("Albuquerque, NM  87114\\n");\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344381}Solution to problem 1.3.{\*\bkmkend _Toc496344381}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par printf("*   *  ***  *   * *****\\n");\par printf("** **   *   *  *  *    \\n");\par printf("* * *   *   * *   *    \\n");\par printf("*   *   *   **    ***  \\n");\par printf("*   *   *   * *   *    \\n");\par printf("*   *   *   *  *  *    \\n");\par printf("*   *  ***  *   * *****\\n");\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344382}Solution to problem 1.4.{\*\bkmkend _Toc496344382}\par }\pard\plain \s21\qj\fi360\keepn\widctlpar\adjustright \f4\fs20\cgrid {The four colors available in 640 mode without changing the color palettes are:\par \par }\pard \s21\qj\fi360\li360\keepn\widctlpar\adjustright {0\tab black\par 1\tab purple\par 2\tab light green\par }\pard \s21\qj\fi360\li360\widctlpar\adjustright {3\tab white\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par When the pen color is set to 3 (white), the program still draws a square, but the square is the same color as the background of the window, and does not show up.\par Here is the program to draw the purple square:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <quickdraw.h>\par \par void main(void)\par \par \{\par SetPenMode(0);\par SetSolidPenPat(1);\par SetPenSize(3,1);\par MoveTo(10,10);\par LineTo(90,10);\par LineTo(90,40);\par LineTo(10,40);\par LineTo(10,10);\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Here is the program to draw the green square:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <quickdraw.h>\par \par void main(void)\par \par \{\par SetPenMode(0);\par SetSolidPenPat(2);\par SetPenSize(3,1);\par MoveTo(10,10);\par LineTo(90,10);\par LineTo(90,40);\par LineTo(10,40);\par LineTo(10,10);\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Here is the program to draw the white square:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <quickdraw.h>\par \par void main(void)\par \par \{\par SetPenMode(0);\par SetSolidPenPat(3);\par SetPenSize(3,1);\par MoveTo(10,10);\par LineTo(90,10);\par LineTo(90,40);\par LineTo(10,40);\par LineTo(10,10);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344383}Solution to problem 1.5.{\*\bkmkend _Toc496344383}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <quickdraw.h>\par \par void main(void)\par \par \{\par SetPenMode(0);\par SetSolidPenPat(0);\par SetPenSize(3,1);\par MoveTo(110,50);\par LineTo(190,50);\par LineTo(150,24);\par LineTo(110,50);\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344384}Solution to problem 1.6.{\*\bkmkend _Toc496344384}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <quickdraw.h>\par \par void main(void)\par \par \{\par SetPenMode(0);\par SetSolidPenPat(2);\par SetPenSize(6,2);\par MoveTo(110,50);\par LineTo(190,50);\par LineTo(150,24);\par LineTo(110,50);\par MoveTo(110,33);\par LineTo(190,33);\par LineTo(150,59);\par LineTo(110,33);\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344385}Solution to problem 1.7.{\*\bkmkend _Toc496344385}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <quickdraw.h>\par \par void main(void)\par \par \{\par SetPenMode(0);\par SetSolidPenPat(0);\par SetPenSize(3,1);\par \par MoveTo(20,70);\par LineTo(20,20);\par LineTo(45,45);\par LineTo(70,20);\par LineTo(70,70);\par \par MoveTo(90,20);\par LineTo(100,20);\par MoveTo(90,70);\par LineTo(100,70);\par MoveTo(95,20);\par LineTo(95,70);\par \par MoveTo(120,20);\par LineTo(120,70);\par MoveTo(170,20);\par LineTo(120,45);\par LineTo(170,70);\par \par MoveTo(240,20);\par LineTo(190,20);\par LineTo(190,70);\par LineTo(240,70);\par MoveTo(190,45);\par LineTo(220,45);\par \}\par }\pard\plain \qj\fi360\widctlpar\adjustright \f4\cgrid {\par }\pard \widctlpar\adjustright {\sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s1\qc\nowidctlpar\outlinelevel0\adjustright \b\f4\fs36\cgrid {{\*\bkmkstart _Toc496343284}{\*\bkmkstart _Toc496344386}Lesson Two{\*\bkmkend _Toc496343284}{\*\bkmkend _Toc496344386}\par {\*\bkmkstart _Toc496344387}Variables and Loops{\*\bkmkend _Toc496344387}\par }\pard\plain \qj\widctlpar\adjustright \f4\cgrid {\b\fs28 \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344388}Integer Variables{\*\bkmkend _Toc496344388}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {You have probably heard that computers are very good at dealing with numbers.  This is quite true.  In this lesson, we will start to use numbers and variables in our programs.  If you aren't a math whiz, though, don't panic; we won't be dealing with anything more complicated than simple arithmetic in this chapter.  Let's start by typing in the program shown in listing 2.1.\par One of the first things you will see in our program is a comment.  Comments start with a /* character sequence and end with a */ character sequence.  It is very, very important to put the characters together.  You can't put a space or any other character between the slash and asterisk.  You can type anything you want except the */ character sequence inside of a comment, though.  The compiler ignores comments completely.  You can always replace a comment with a space, and the compiler will produce exactly the same program as it did when the comment was there.  Why, then, do we bother?\par }{\lang1024 {\shp{\*\shpinst\shpleft0\shptop-794\shpright9360\shpbottom6406\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz8\shplid1140{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 5046272}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 2.1\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* This program prints a table of numbers and squares of the numbers */\par \par #include <stdio.h>\par \par int i,s;                       /* i is a number, s is its square */\par \par void main (void)\par \par \{\par i = 1;\par s = i*i;\par printf("%10d%10d\\n", i, s);\par i = i+1;\par s = i*i;\par printf("%10d%10d\\n", i, s);\par i = i+1;\par s = i*i;\par printf("%10d%10d\\n", i, s);\par i = i+1;\par s = i*i;\par printf("%10d%10d\\n", i, s);\par i = i+1;\par s = i*i;\par printf("%10d%10d\\n", i, s);\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8200\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 2.1\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* This program prints a table of numbers and squares of the numbers */\par \par #include <stdio.h>\par \par int i,s;                       /* i is a number, s is its square */\par \par void main (void)\par \par \{\par i = 1;\par s = i*i;\par printf("%10d%10d\\n", i, s);\par i = i+1;\par s = i*i;\par printf("%10d%10d\\n", i, s);\par i = i+1;\par s = i*i;\par printf("%10d%10d\\n", i, s);\par i = i+1;\par s = i*i;\par printf("%10d%10d\\n", i, s);\par i = i+1;\par s = i*i;\par printf("%10d%10d\\n", i, s);\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx0\dpy-794\dpxsize9360\dpysize7200\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{If your memory was as good as the computer's, and if no one else ever read your programs, you wouldn't need comments.  Comments are for your benefit, as well as the benefit of all those poor lost souls who will have to figure out what you did later.  There are two places where you should put a comment in every program you write.  The first is at the beginning of the program, identifying quickly what the program is for.  It's not a bad idea to put your name and the date the program was written there, too.  Finally, you will notice that I put a comment after the variables to tell what they are for.  This, too, is a very good habit to form.\par Computers can work with a vast array of number formats, each of which has a special purpose.  The two most common number formats are integer and floating-point.  Integers are whole numbers, like 4, -100, or 1989.  Floating-point numbers include the integers, plus all of the numbers between the whole numbers, like 1.25 or 3.14159.\par The memory of a computer is made up of a vast series of numbers, but in a language like C, we don't have to deal with them the same primitive way the computer does.  Instead, we can define variables.  A variable is just a place where you can put a numeric value.  In our program, we define two integer variables called i and s.  Within certain limits, we can put any integer number we like in these variables.  It's exactly like putting two names for numbers on a sheet of paper and continuously erasing the number to replace it with a new one.\par C is very flexible about where it lets you define things.  In this program, we defined the two integers before the function main.  Later, you will learn how to define variables inside of a function.  Variables defined outside of a function, like the ones in our sample program, can be used from any function that comes after the variable.  These are called global variables.  Variables defined inside of a function can only be used from within the function; they are called local variables.  You can mix variables and functions in any order, as long as you make sure you put the variable definitions before the first function that uses the variable.  In all of our programs, we will adopt the common style of putting all variables before the start of the first function.  That makes the variable definitions easier to find and change later on.\par In C, when you define something, you start by telling the compiler what type of thing you are defining.  We are defining two integers.  In C, we use the abbreviation int to tell the compiler we want to define an integer variable.  The variables are listed next.  If there are more than one, like there are in our program, we can use commas to separate them.  At the end of the definition, we type a semicolon to tell the compiler where the definition ends.\par These variables are put to use in the function main.  The first thing we need to do is learn to put a number in a variable.  We do this with something called an assignment statement.  The line\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {i = 1;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {tells the computer to place the number 1 in the variable i.  The = character is called the assignment operator.  The very next line puts this value to use.\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {s = i*i;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {Here, we multiply i by itself and put the result in the second variable, s.  The * character is used in computer languages for multiplication because a computer would confuse x in "i x i" with a variable named x.  The result is saved in the location named s.  Finally, we write the values.\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {printf("%10d%10d\\n", i, s);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }{\lang1024 {\shp{\*\shpinst\shpleft-108\shptop2396\shpright4500\shpbottom10028\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz9\shplid1141{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 4980736}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s22\qc\sa200\nowidctlpar\adjustright \b\f4\fs20\cgrid {Cut and Paste\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {If you look closely at the sample program, you will see that many of the lines are repeated more than one time.  You can use a technique called cutting and pasting to make it easier to type in the program.\par Start by typing the program through the first printf call.  Now move the mouse so the cursor is just to the left of the statement\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {i = 1;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Press the mouse button.  The entire line will switch to white letters on a black background.  Holding the mouse button down, drag the mouse down until the three lines ending with the printf statement are shown in inverse (white letters against a black background), then let up on the mouse.  The inverted lines are now selected.  One of the things you can do with selected text is to copy the text into an internal buffer called the scrap buffer.  Do that now by pulling down the Edit menu and selecting Copy.\par The next step is to move the insertion point to the end of the program.  Move the mouse to the start of the first blank line after the printf statement and click.  The selected text will go away, and the familiar blinking insertion point will appear, ready to type a new line.  This time, though, pull down the Edit menu and select Paste.  The lines you copied into the scrap buffer are written into the program file.\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8201\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s22\qc\sa200\nowidctlpar\adjustright \b\f4\fs20\cgrid {Cut and Paste\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {If you look closely at the sample program, you will see that many of the lines are repeated more than one time.  You can use a technique called cutting and pasting to make it easier to type in the program.\par Start by typing the program through the first printf call.  Now move the mouse so the cursor is just to the left of the statement\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {i = 1;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Press the mouse button.  The entire line will switch to white letters on a black background.  Holding the mouse button down, drag the mouse down until the three lines ending with the printf statement are shown in inverse (white letters against a black background), then let up on the mouse.  The inverted lines are now selected.  One of the things you can do with selected text is to copy the text into an internal buffer called the scrap buffer.  Do that now by pulling down the Edit menu and selecting Copy.\par The next step is to move the insertion point to the end of the program.  Move the mouse to the start of the first blank line after the printf statement and click.  The selected text will go away, and the familiar blinking insertion point will appear, ready to type a new line.  This time, though, pull down the Edit menu and select Paste.  The lines you copied into the scrap buffer are written into the program file.\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx-108\dpy2396\dpxsize4608\dpysize7632\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{The call to printf deserves a little more attention, since there are several new concepts here.  We have already used the printf function to write characters to the shell window, but in this case we are writing two numbers.  The printf function can actually print a wide variety of different data types.  To write anything besides a string, though, there are a couple of new ideas to master.  First, we still need to pass a string.  The first parameter to printf is always a string, even if we only want to print numbers.  This string controls the format of the information that will be written to the shell window; it forms a sort of model.  The % character starts something called a conversion specification.  The conversion specification tells printf what to expect in the rest of the parameter list, as well as how to format the various variable values.  In our example, we used %10d.  The 10 tells printf to put the value in a ten character wide field, forcing the value to the right side of the field.  When a 1 is printed, for example, it will be preceded by 9 spaces.  The d tells printf that the value to print is an integer.  Any characters that are not part of a conversion specification are printed as is, which is why we were able to use printf to write a simple string.\par The parameters appear right after the format string.  They are matched with the conversion specification from left to right; all three parameters, the format string and the two variables, are separated from each other with commas.\par It is extremely important that you type the conversion specification exactly as you see it, with no spaces or other characters imbedded among the characters.  You also have to be very careful with conversion specifications.  As you will see, there are a lot of different kinds of variables in C, and many different kinds of conversion specifications, as well.  You have to make sure that the number and kind of the conversion specifications match the number and kind of parameters that come after the format string exactly.  If you don't, it could cause all sorts of trouble, including a crash.  Don't worry \-\endash  it will eventually happen to you, just like it does to every other C programmer.  When it happens, reboot and try again.\par I said there are a lot of conversion specification and data types \endash  you may be wondering what they are.  Eventually, we will cover most of them in the course, but peeking ahead is not only allowed, it is encouraged.  Your first look at a technical description of conversion specifications may be scary, so be prepared.  Your compiler reference manual has a complete list of them, though.  Look up the printf function in the index, and flip to the proper place in the book.  Don't panic.  It's easier than the manual makes it seem.\par You can probably figure out what the rest of the program does on your own, but let's learn to use a new debugger tool.  Later, when our programs are much more complicated, knowing how to use the debugging tools will be much more important.\par Be sure you typed the program in properly by running it one time.  Now pull down the debug menu and select step, but this time, don't step through the program right away.  Instead, pull down the debug menu again and select Variables.  A new window will show up on the desktop; this window is used to look at the values stored in variables while the program is running.  You will be using it a lot to see how programs work and to find out why your own programs fail.\par Click in the body of the new window; you will get a line edit box.  Type the name of the variable i and hit return.  Click below this variable, and add s to the list.  Now step through your program in the normal way.  As you go, the values of the variables are updated, one line at a time.\par In the example, we used a 10 for a width field.  You can leave it out, using "%d%d" as the format string, but if you do, the two numbers will be crammed together.  To separate them, just put a space between the two conversion specification.  Remember, you can't put spaces inside of the conversion specification, but you can put anything you like around the conversion specification.  As an example, try to figure out what this printf statement will do.  After you think you know (or after you give up), try this format string in your program to see if you were right!\par \par }\pard\plain \s23\qj\widctlpar\adjustright \f6\fs20\cgrid {printf("%d squared is %d.\\n", i, s);\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }{\b Problem 2.1:}{  The Fibonacci series is a sequence of numbers obtained by adding the two previous numbers in the series.  The series starts with 0 and 1.  Write a program with three integer variables named last, current, and next.  Set last to 0 and current to 1.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Now do the following steps five times:\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\fi-360\li720\widctlpar\adjustright {1.  Compute next by adding current to last and saving the result in next.\par 2.  Print next.\par 3.  Assign current to last.\par 4.  Assign next to current.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {The result should be the numbers 1, 2, 3, 5 and 8, all on a different line.  Be sure to run your program through the debugger.  It is important that you understand how we are using sequential execution and variables to gradually step through the sequence of Fibonacci numbers.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Fibonacci numbers seem to occur frequently in nature; no one is quite sure why.  The number of petals in a flower and the number or leaflets on a compound leaf are often Fibonacci numbers.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344389}The For Loop{\*\bkmkend _Toc496344389}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {So far, all of our programs have executed one statement at a time, starting with the first and proceeding to the last.  In our last sample and problem, this started to get a little tedious, as we repeated the same thing over and over, incrementing a number by one each time.  Computers are real good at doing tedious things, but most people are not.  The for loop is the first in a series of statements we will look at that help remove some of the tediousness of writing a program.\par Type in the sample program below and run it.  Before you read further, take a crack at figuring out what it is doing on your own.  Be sure and use the debugger.  Also, since this program draws in the graphics window, be sure you open the graphics window and resize all of your windows so you can see the graphics window before running the program.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* Draw a fan shape in the     */\par /* graphics window             */\par \par #include <quickdraw.h>\par \par int i;        /* loop variable */\par \par void main (void)\par \par \{\par /* set up for graphics */\par SetPenMode(0);\par SetSolidPenPat(2);\par SetPenSize(2,1);\par \par /* draw the fan */\par for (i = 1; i <= 25; ++i) \{\par    MoveTo(160, 70);\par    LineTo(i*12-10, 10);\par    \}\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par We use a for loop whenever we need to do something a specific number of times.  This could be calculating ten values, or drawing twenty-five vanes of a fan, as our program does.  The for loop starts with the reserved word }{\f6 for}{.  Right after this are three expressions, separated from each other by semicolons, and enclosed in parentheses.  To understand what all of this means, let's step back and look at the for statement in a symbolic way, putting names in for the various expressions.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {for (start; stop; loop)\par    statement;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The for loop actually does quite a number of rather complicated things:\par \par }\pard \s21\qj\fi-360\li720\widctlpar\adjustright {1.\tab The first thing it does is to execute the start expression; that's the first one in the parentheses.  You have seen an expression like this before; in our example program, the start expression stores a 1 in the variable i.\par \par 2.\tab Next, the for statement executes the stop expression; that's the one in the middle.  The stop condition looks a little odd.  What it does is to compare i to 25.  If i is less than or equal to 25, the for loop will keep going.  If i is greater than 25, the for loop will stop, never having gone through the loop at all.\par \par 3.\tab The third step is to execute the statement that comes after the closing parenthesis.  The statement could be assigning a value to a variable, calling the printf function to write a value, or something a little more complicated.  The for loop only executes one statement, though.  We'll talk about this point more in a moment.\par \par 4.  The next step is to execute the loop statement.  In the example, you saw something else that is new; ++i.  The ++ is actually an operator in C.  An operator in a compiler isn't the person who answers the phone; it's a symbol that means "do something!"  You have already used the + and * operators, which were probably familiar from math class.  The ++ operator means to add one to the variable.  The expression ++i means exactly the same thing as i = i+1, but it is a little easier to type.  This sort of thing pops up time and again in C, so get used to it!\par \par 5.  The last step is to go back to step 2, checking to see if we are finished with the loop.\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par You have to be careful with the for loop, since C is a trusting language.  It gives you plenty of rope; it's up to you to hang yourself or build a rope bridge.  For example, you can put an assignment in for the loop condition.  Let's say you type\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {for (i = 1; i <= 10; i = 4)\par    printf("Hello, world.\\n");\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {This loop will never stop, since i is never greater than 10.\par }\pard \s21\qj\fi360\widctlpar\adjustright {I mentioned earlier that the for loop executes one statement, then loops.  In our sample, though, we wanted to execute two statements, MoveTo and LineTo.  To do this, we have to have a friendly talk with the compiler about what a single statement is.  We use the familiar symbols, \{ and \}, around the two statements.  This tells the compiler to treat the group of lines between the \{ and \} as a single statement, so both the MoveTo and the LineTo get executed as part of the loop.  To see the difference, try removing the \{ and \} characters, like this:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {for (i = 1; i <= 25; ++i)\par    MoveTo(160, 70);\par }\pard \s23\qj\fi360\widctlpar\adjustright {   LineTo(i*12-10, 10);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Use the debugger to trace through the program both ways.  Watch the arrow as the program gets executed.  As you can plainly see, the second line is not executed as part of the loop unless you use the \{ and \} characters.  That's one advantage of the debugger, and a good reason to use it on all of your programs:  you can plainly see what happens.  When a program doesn't work, it isn't always easy to tell why by looking at the source code.  The debugger can show you what the computer is actually doing, rather than what you think the computer is doing.\par Technically, a series of statements grouped together by a \{ and \} is called a compound statement.  Whether you remember that or not won't make you a better or worse programmer, but when you read books about C, the authors will talk about compound statements instead of continually saying "those statements grouped together with the characters \{ and \}."  Saying it's a compound statement just takes a little less room.  It also makes you sound like you know something, impressing the natives who can't program.\par There is one very common mistake to watch out for with the for loop.  You are getting used to the fact that C statements end with a semicolon.  So does the statement after the for loop.  This is perfectly valid in C:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {for (i = 1; i <= 10; ++i) ;\par }\pard \s23\qj\fi360\widctlpar\adjustright {   printf("Hello, world.\\n");\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {It loops 10 times, doing nothing, then calls printf once.  The reason is that the ; after the for statement is a legal statement that does nothing.  Watch out for those extra semicolons!  Here's how to call the printf function 10 times:\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {for (i = 1; i <= 10; ++i)\par }\pard \s23\qj\fi360\widctlpar\adjustright {   printf("Hello, world.\\n");\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {The difference is small, but very, very important.\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 2.2:}{  Our first sample in this chapter created a table of numbers and squares.  It did this in a fairly clumsy way, by using separate statements to step from 1 to 5.  Rewrite this sample using a for loop.\par \par }{\b Problem 2.3:}{  In the last chapter, we drew a square by drawing its sides with constant integers.  We could also draw the rectangle using variables, like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {top = 10;\par bottom = 70;\par left = 10;\par right = 100;\par MoveTo(left, top);\par LineTo(right, top);\par LineTo(right, bottom);\par LineTo(left, bottom);\par LineTo(left, top);\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {Use a for loop to draw five rectangles, one inside the other.  Set top, bottom, left and right before the for loop starts.  Inside the for loop, draw the rectangle, then add six to top and left, and subtract six from bottom and right.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344390}Indenting:  Programmers Do It With Style{\*\bkmkend _Toc496344390}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {In the last section, our for loop looked like this:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* draw the fan */\par for (i = 1; i <= 25; ++i) \{\par    MoveTo(160, 70);\par    LineTo(i*12-10, 10);\par }\pard \s23\qj\fi360\widctlpar\adjustright {   \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {You no doubt noticed that we moved over three spaces on each line that is in the for loop.  This is called indenting.  The compiler really doesn't care if you indent or not.  As far as the compiler is concerned, these lines do exactly the same thing:\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\li360\widctlpar\adjustright \f6\fs20\cgrid {for (i = 1; i <= 25; ++i) \{ MoveTo(160, 70); LineTo(i*12-10, 10);\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {Most folks, though, find it easier to read the first loop.\par }\pard \s21\qj\fi360\widctlpar\adjustright {You also didn't need to indent at all.  It is almost as easy to read\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {\par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {/* draw the fan */\par for (i = 1; i <= 25; ++i) \{\par MoveTo(160, 70);\par LineTo(i*12-10, 10);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {as it was to read the first loop.  The reason we indent is to make it easy to see which lines are in the loop.  This makes it easier to read the program and tell what it is doing.  On the other hand, you should never depend on indenting.  When I removed the \{ and \} characters to show you that the for loop only executes one statement at a time, and how the \{ and \} characters convince the compiler to treat two lines as a single statement, I wrote\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {for (i = 1; i <= 25; ++i)\par    MoveTo(160, 70);\par }\pard \s23\qj\fi360\widctlpar\adjustright {   LineTo(i*12-10, 10);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {From the indenting, you would expect the second line to be part of the loop.  The compiler doesn't care about indenting, though.  In short, if your mommy was a programmer, she would have told you never to depend on comments or indenting when you are trying to find a problem in a program.  The comments or the indenting may be wrong.\par }\pard \s21\qj\fi360\widctlpar\adjustright {There is more than one right way to do almost anything in programming, and indenting is one of those places where this is particularly true.  I always use three spaces when I indent.  I always put the \{ character on the same line as the for statement.  Here, though, are some alternate indenting styles.  All of them work, and all serve the same purpose.  I like mine because it presents more information in fewer lines using fewer columns than the others do, but other people defend their style with vigor, too.  The long and short of it is that it really doesn't matter what style you use, as long as you find one you like and use it consistently.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {for (i = 1; i <= 25; ++i)\par    \{\par    MoveTo(160, 70);\par    LineTo(i*12-10, 10);\par }\pard \s23\qj\fi360\widctlpar\adjustright {   \}\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {for (i = 1; i <= 25; ++i)\par    \{\par       MoveTo(160, 70);\par       LineTo(i*12-10, 10);\par }\pard \s23\qj\fi360\widctlpar\adjustright {   \}\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {for (i = 1; i <= 25; ++i)\par \{\par         MoveTo(160, 70);\par         LineTo(i*12-10, 10);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344391}Operator Precedence{\*\bkmkend _Toc496344391}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {By now, you are getting used to the idea that computers step through a program in a fairly orderly way.  Statements are executed top to bottom, left to right, the same way you read.  Try the following program, but see if you can figure out what will be printed before you run the program.\par \par }\pard\plain \s23\qj\widctlpar\adjustright \f6\fs20\cgrid {/* A look at operator precedence */\par \par #include <stdio.h>\par \par void main(void)\par \par \{\par printf("%d\\n", 1+2*3);\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par There are two perfectly reasonable ways to compute a value from the expression\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {1+2*3\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {The first is to work left-to-right:\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {1+2*3\par 3*3\par }\pard \s23\qj\fi360\widctlpar\adjustright {9\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {The second is to follow the rules you may remember from algebra class, and do the multiply first.\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \qj\fi360\keepn\widctlpar\adjustright \f4\cgrid {\f6\fs20 1+2*3\par 1+6\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 7\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par As you can see from running the program, C uses the same rules as algebra teachers.  Not all languages follow these rules; APL, for example, does work left to right.  The way a language determines what order to do operations in is called operator precedence.  We might as well call it the operator pecking order; it means the same thing.  Computer types like to sound official, though, so we better stick to precedence.\par Operator precedence is complicated in C because there are so many operators.  In fact, there are 16 levels of precedence in C!  Most C programmers don't even try to remember what all of the precedence rules are.  Even if you could, your programs would confuse other people when they tried to read them.  In C, remember that multiply and divide (* and /) have a higher precedence than add and subtract (+ and -).  The ++ operator has an even higher precedence:  it is done even before a multiply or divide.  Beyond that, use parenthesis.  For example, (1+2)*3 forces the compiler to do the addition first, giving 9.  Parenthesis are a good way to make sure that you, the compiler, and anyone else who reads your program are all sure what the expression really means.\par Of course, you may want to peek ahead to see what an awesome list of operators C really has, and see that complete, 16 level list of operator precedence.  Go for it.  You'll find the list in your language reference manual, as well as any decent C reference manual.  We'll also keep you posted on the precedence of new operators as they are introduced in the course.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344392}The Maximum Integer{\*\bkmkend _Toc496344392}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Growing up with a last name like Westerfield, I quickly learned that computers had limits.  It seemed like all of the people who programmed had names like Wirth, or Ritchie, or Steele.  All of those silly forms that asked me to put each letter into a separate block had ten blocks.  It upset me:  my name isn't Westerfiel, it's Westerfield.  The protests of a seven year old are seldom heeded, though.\par Computers have become a lot more friendly since then, perhaps in part due to the fellow protests of people like Joe Jabinoslowski, but they still have fixed limits on just about everything.  The limit may be very large, but it is there, and integers are no exception.  Every C compiler imposes some upper limit on integers \endash  some largest number that can be stored in an integer variable.  On most microcomputer based Cs, this value is... but wait, there is a better way to find out.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* Find the largest integer */\par \par #include <stdio.h>\par #include <limits.h>\par \par void main(void)\par \par \{\par printf("%d\\n", INT_MAX);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par INT_MAX is a constant you can find in the library of most C compilers; it is in limits.h.  It tells you the largest number you can save in an integer variable.  Running this program, you find out that the largest integer is 32767.  There is a good reason for that.  It has to do with the way numbers are stored in a computer.  We really don't need to delve into that at the moment, though.  The important thing is that you know that there is a maximum.\par There is a minimum integer, too.  It's name is MIN_INT.  It is usually either -32767 or -32768.  In ORCA/C, the value is -32767.\par C books will tell you that the "result is undefined" if you do something that will create a number too big to store in an integer and try to store it there.  That's a polite way to say that the compiler can do whatever it feels like.  That makes it tough for your program to work well.  In short, don't use numbers that big.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344393}Integers Come in Several Sizes{\*\bkmkend _Toc496344393}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {C actually has several different kinds of integers.  The one we have been using so far is called int; that one is supposed to be the "natural" size for an integer on the machine you are using.  There are two other types of integers, though, called long and short.  You can define integers using int, long, short, or even the combinations short int or long int.  In ORCA/C, short means exactly the same thing as int, while long integers give you a larger range of values.  With ORCA/C, long integers can range from -2147483647 to 2147483647.  The limits.h header file defines constants for the size of long and short integers, too.  You can use these constants to find out how big integers are on any other C compiler you might someday use.\par \par }\pard \s21\qj\fi360\keepn\widctlpar\tx1800\tx2700\adjustright {\ul constant}{\tab }{\ul type}{\tab }{\ul value in ORCA/C}{\par SHRT_MIN\tab short\tab -32767\par SHRT_MAX\tab short\tab 32767\par INT_MIN\tab int\tab -32767\par INT_MAX\tab int\tab 32767\par LONG_MIN\tab long\tab -2147483647\par }\pard \s21\qj\fi360\widctlpar\tx1800\tx2700\adjustright {LONG_MAX\tab long\tab 2147483647\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par When C was originally defined, there weren't any limits on the range of integers each of the types could hold.  In fact, it was perfectly legal to use the same range for all three kinds of integer, although that was rarely done.  Even today, with the ANSI C standard, it is still legal for a C compiler to make all three kinds of integers hold the same range of numbers, but the values shown in the table are now the minimum sizes.  In other words, in any ANSI C compiler, you can count on the fact that short and int variables can hold values from -32767 to 32767.  The allowed range can be bigger, but not smaller.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344394}Integers Can be Signed or Unsigned{\*\bkmkend _Toc496344394}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Just to keep things interesting, C not only has three different sizes of integers (actually four; you'll learn about char variables later), it also has two different kinds of each of these sizes of integer.  There are some cases where you need an integer, but you don't need one that can represent a negative value.  In fact, we haven't used a negative value in any of our programs, yet.  C defines a kind of integer called unsigned as an integer with a low value of 0.  It turns out that there are two distinct advantages to unsigned integers on many computers, and this is especially true on the Apple IIGS.  First, unsigned integers can hold larger values in the same amount of space.  For example, unsigned int values can be as large as 65535.  The other advantage is that many operations are faster with unsigned integers than they are with signed integers.  Addition and subtraction take the same amount of time, at least on the Apple IIGS.  Multiplication and division, though, are a little faster.  The difference isn't usually enough to be important, but in some very time-critical applications, a slight improvement in speed could help a lot.  The most important difference, though is for compares.  Comparing two signed values takes a long time on an Apple IIGS, while comparing two unsigned integers is very easy, and very fast.\par To define an unsigned integer, you put the word unsigned right before the normal definition, like this:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {unsigned short s;\par unsigned int i,j,k;\par }\pard \s23\qj\fi360\widctlpar\adjustright {unsigned long l;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The most common size of integer in C programs is int, so C has a short cut for unsigned int variables.  You can leave off the int, like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {unsigned i,j,k;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {This definition means the same thing as the definition of i, j and k in the original example, but it takes a few less keystrokes to type it in.\par }\pard \s21\qj\fi360\widctlpar\adjustright {As with the signed integers, limits.h defines the size of unsigned integers, too.  For unsigned integers, though, only the largest value is given, since the smallest value the variable can hold is always 0.\par }\pard \s21\qj\fi360\widctlpar\tx1800\tx2700\adjustright {\par }\pard \s21\qj\fi360\keepn\widctlpar\tx1800\tx2700\adjustright {\ul constant}{\tab }{\ul type}{\tab }{\ul value in ORCA/C}{\par USHRT_MAX\tab short\tab 65535u\par UINT_MAX\tab int\tab 65535u\par }\pard \s21\qj\fi360\widctlpar\tx1800\tx2700\adjustright {ULONG_MAX\tab long\tab 4294967295ul\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard \s21\qj\widctlpar\adjustright {The u after the number tells the compiler the number is unsigned.  It's good practice to put the u on the end of unsigned numbers, although it won't make any difference if the number is smaller than the largest legal signed integer of the same type.  You can also put an l after an integer constant to tell the compiler the value is long.  If the integer is too big to fit in an integer variable, the compiler will promote it to long automatically, but there are a few places where leaving off something as simple as an l to indicate a long integer can actually cause a program to crash.  Again, it is a good habit to use l when appropriate.\par }\pard \s21\qj\fi360\widctlpar\adjustright {One of the reasons for using C instead of a safer language, like Pascal, is that there are several areas in the C language where a complicated idea like three sizes of integers and two kinds of integers can help you write smaller, faster programs.  Standard Pascal, for example, only has one size and one kind of integer, although most real compilers have two sizes of integers.  Getting used to which kind of integer to use can be a little intimidating, though.  The basic rule of thumb is to use unsigned whenever you can.  Use int variables if the values you will be using will fit in an int variable; int variables require half the room used by the same number of long variables, and calculations with int variables are two to four times faster than calculations with long variables.  Use long or unsigned long when you need to handle values too big for int variables.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344395}More Conversion Specifications{\*\bkmkend _Toc496344395}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The printf subroutine is pretty picky about matching up format specifiers with the appropriate type of parameter.  If you use the wrong number of parameters, or you tell printf that you are printing an integer by using the %d conversion specification, and then pass a long variable, the program could even crash.  (In version 1.0 of ORCA/C, the program would crash or hang.  In version 1.1, the program will not, unless you ask the compiler to optimize the program.  You'll learn more about optimizations later.)  Even if the values are the same size, you may not get the result you want.\par For example, in this program, we obviously want to print 40000, which is a perfectly valid unsigned int value.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* try printing a large */\par /* unsigned int         */\par \par #include <stdio.h>\par \par void main (void)\par \par \{\par printf("%d\\n", 40000u);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {When you run this program, it will print -25536; that's a far cry from 40000!  The reason, of course, is that the conversion specification %d tells printf to expect an int value, but the program passes an unsigned int.  By changing the letter to u, like this:\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* try printing a large */\par /* unsigned int         */\par \par #include <stdio.h>\par \par void main (void)\par \par \{\par printf("%u\\n", 40000u);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {you can tell printf to expect an unsigned int.\par }\pard \s21\qj\fi360\widctlpar\adjustright {Long values are handled a little differently.  To tell printf to expect a long value, rather than an int value, you put an l right before the d.  An unsigned long is indicated with lu, rather than u.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* sample of printf with long */\par /* and unsigned long values   */\par \par #include <stdio.h>\par \par void main (void)\par \par \{\par long l;\par unsigned long ul;\par \par l = 5000000l;\par ul = 100ul;\par \par printf("%lu\\n", 123456lu);\par printf("%ld\\n", -100000l);\par printf("%ld\\n", l);\par printf("%lu\\n", ul);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Just to keep things interesting, short values use the same conversion specification as int values.\par Here's a table that summarizes the conversion specifications for printf up to this point.  Only the letter is shown in the table, but in all cases, the conversion specification starts with a % character.  You can also use a number between the % character and the letter for the conversion specification to force the numbers into columns with any of the conversion specification.\par \par }\pard \s21\qj\fi720\keepn\widctlpar\tx2340\adjustright {variable\tab conversion\par }{\ul type      }{\tab }{\ul specification}{\par short\tab d\par unsigned short\tab u\par int\tab d\par unsigned int\tab u\par long\tab ld\par }\pard \s21\qj\fi720\widctlpar\tx2340\adjustright {unsigned long\tab lu\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344396}Floating-Point Numbers{\*\bkmkend _Toc496344396}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {As everyone knows, programmers drive Porches.  At least, many of the folks I meet seem to have that impression.  I have never met a programmer that drove a Porche myself.  Still, you may be aspiring to high goals, so let's see how long you will be paying off your dream car.  We will assume that you want a new car, but not necessarily a fancy one.  We'll spend $24,000 on our car.  We'll assume that you know a banker real well, and can get your car loan at 10% APR, which works out to a monthly interest rate of about 0.83%.  That would make the initial interest payment for the first month\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {24000*0.0083\par }\pard \s23\qj\fi360\widctlpar\adjustright {$199.20\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {Let's assume you are generous and want to pay $250 a month.  The program in listing 2.2 finds out how many months you will be paying.\par }\pard \s21\qj\fi360\widctlpar\adjustright {Be sure you have typed the format string in the call to printf }{\i exactly}{ as it is shown, then go ahead and run the program.  The negative number after the last payment shows that you didn't quite have to pay $250.00 the last month to pay off the loan.  The number of months this takes shows why I own a Datsun.  An old one.\par }{\lang1024 {\shp{\*\shpinst\shpleft0\shptop2262\shpright9360\shpbottom9462\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz10\shplid1142{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 4915200}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s21\qj\fi360\keepn\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 2.2\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Why I don't own a Porche */\par \par #include <stdio.h>\par \par #define COST 24000.0              /* initial cost of the car */\par #define APR 10.0                  /* annual percentage rate */\par #define PAYMENT 250.0             /* monthly payment */\par \par unsigned month;                   /* number of months */\par float principal;                  /* amount left to pay */\par \par void main (void)\par \par \{\par month = 0;                        /* no payments made, yet */\par principal = COST;                 /* we start owing this much */\par while (principal > 0.0) \{       /* keep going until we're out of debt */\par    ++month;                       /* it's a new month */\par    principal += principal*        /* add in this month's interest */\par       APR/100.0/12.0;\par    principal -= PAYMENT;          /* make the payment */\par                                   /* write the status */\par    printf("month = %3u   principal = %.2f\\n", month, principal);\par    \}\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8202\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s21\qj\fi360\keepn\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 2.2\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Why I don't own a Porche */\par \par #include <stdio.h>\par \par #define COST 24000.0              /* initial cost of the car */\par #define APR 10.0                  /* annual percentage rate */\par #define PAYMENT 250.0             /* monthly payment */\par \par unsigned month;                   /* number of months */\par float principal;                  /* amount left to pay */\par \par void main (void)\par \par \{\par month = 0;                        /* no payments made, yet */\par principal = COST;                 /* we start owing this much */\par while (principal > 0.0) \{       /* keep going until we're out of debt */\par    ++month;                       /* it's a new month */\par    principal += principal*        /* add in this month's interest */\par       APR/100.0/12.0;\par    principal -= PAYMENT;          /* make the payment */\par                                   /* write the status */\par    printf("month = %3u   principal = %.2f\\n", month, principal);\par    \}\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx0\dpy2262\dpxsize9360\dpysize7200\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{This program builds on your previous knowledge, but it also introduces a wealth of new ideas.  The first is a new preprocessor directive called define.  The #define statement defines something called a macro.  The word that comes right after #define is the name of the macro; the characters that come after the macro name are called the macro body.  The compiler remembers this macro definition, and any time it finds the name of the macro in the program, it uses the characters from the macro body instead of the name of the macro.  Macros are very powerful, but for now we will only use them to define constants.  Constants have several uses.  Like comments, they make a program easier to read, understand, and change.  For example, it is very easy to change the interest rate in this program.  It is also very easy to change the price of the car and the size of the payment.  It also gives you a chance to label a number.  For example, it is easy to see that 250.0 is the monthly payment on the car, but it isn't as easy to see what is happening in the program shown in listing 2.3.\par This program does exactly the same thing as the original, but the first is easier to change and understand.  In addition, if a number is used more than one time in the program, using a constant lets us change it in one place, rather than searching through the entire program for all of the places the number is used.\par C is case sensitive, so you must type the name of the macro in uppercase if it is defined that way.  As long as the case of the letters is the same, the compiler really doesn't care if you use uppercase letters or lowercase letters for your macro names, but it is traditional in C to use uppercase characters for macro names.  We'll follow that tradition in this course.\par }{\lang1024 {\shp{\*\shpinst\shpleft0\shptop-710\shpright9360\shpbottom5482\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz11\shplid1143{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 4849664}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 2.3\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Why I don't own a Porche */\par \par #include <stdio.h>\par \par unsigned month;                   /* number of months */\par float principal;                  /* amount left to pay */\par \par void main (void)\par \par \{\par month = 0;                        /* no payments made, yet */\par principal = 24000.0;              /* we start owing this much */\par while (principal > 0.0) \{       /* keep going until we're out of debt */\par    ++month;                       /* it's a new month */\par    principal += principal*        /* add in this month's interest */\par       10.0/100.0/12.0;\par    principal -= 250.0;            /* make the payment */\par                                   /* write the status */\par    printf("month = %3u   principal = %.2f\\n", month, principal);\par    \}\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8203\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 2.3\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Why I don't own a Porche */\par \par #include <stdio.h>\par \par unsigned month;                   /* number of months */\par float principal;                  /* amount left to pay */\par \par void main (void)\par \par \{\par month = 0;                        /* no payments made, yet */\par principal = 24000.0;              /* we start owing this much */\par while (principal > 0.0) \{       /* keep going until we're out of debt */\par    ++month;                       /* it's a new month */\par    principal += principal*        /* add in this month's interest */\par       10.0/100.0/12.0;\par    principal -= 250.0;            /* make the payment */\par                                   /* write the status */\par    printf("month = %3u   principal = %.2f\\n", month, principal);\par    \}\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx0\dpy-710\dpxsize9360\dpysize6192\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{C is full of short-cuts, and this program introduces a new one.  It turns out that there are a lot of cases in programming where you want to add something to a variable, or multiply a variable by some value.  For most of the operators you will learn called binary operators \endash  that is, for all of the ones like +, -, * and / that have a value on each side \endash  you can shorten an expression that does something to a variable and stores the result back in the variable.  In our program, we needed to subtract PAYMENT from the principal.  That's easy enough to do like this:\par \par }\pard\plain \s23\qj\widctlpar\adjustright \f6\fs20\cgrid {   principal = principal - PAYMENT;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {but you can also do exactly the same thing like this:\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\widctlpar\adjustright \f6\fs20\cgrid {   principal -= PAYMENT;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {The program does the same thing either way, but the second statement takes less typing, and can reduce the chance of typing something incorrectly.  In some compilers (although not in ORCA/C), the second statement might execute a bit faster, too.\par }\pard \s21\qj\fi360\widctlpar\adjustright {The difference between floating-point numbers and integers is that floating-point numbers can have values other than whole numbers, but they don't have to.  In our constant declarations, for example, all of the values happen to be whole numbers.  We need a way to tell the compiler the difference between a whole number that is an integer and a whole number that is a floating-point number, because they are very different things to the computer.  We do that by including a decimal point in the number.  The value 250.0 is a floating-point number, but 250 is an integer.  In C, the decimal point can come at the beginning or end of a number, as long as there is a number on one side or the other.  For example, all of these are legal constants in C:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\tx1800\tx3240\adjustright \f6\fs20\cgrid {3.14159\tab 10.0\tab 0.0\par }\pard \s23\qj\fi360\widctlpar\tx1800\tx3240\adjustright {0.001\tab 1.\tab .1\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par We are also using a completely new way to loop over a group of statements.  The while loop executes a statement (or, in this case, a compound statement) as long as a condition is true.  In our while loop,\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {while (principal > 0.0)\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {the condition is that the principal must be greater than zero.  The loop continues to execute the statements as long as the condition is true.  In our program, the program continues until the car is paid off, at which time the principal is less than zero or equal to zero.\par }\pard \s21\qj\fi360\widctlpar\adjustright {There are a total of six comparison operators, one of which you saw earlier in the for loop.  The table below lists the operators and what they test for.\par \par }\pard \s21\qj\fi360\keepn\widctlpar\tx1800\adjustright {\ul operator}{\tab }{\ul test for...}{\par a < b\tab a less than b\par a > b\tab a greater than b\par a <= b\tab a less than or equal to b\par a >= b\tab a greater than or equal to b\par a = b\tab a equal to b\par }\pard \s21\qj\fi360\widctlpar\tx1800\adjustright {a <> b\tab a not equal to b\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par For loops and while loops have much in common.  Both are used to execute a statement more than one time.  In fact, you can define a for loop in terms of a while loop.  Back when you first saw the for loop, I wrote it this way to make it easier to talk about what the for loop was doing:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {for (start; stop; loop)\par    statement;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {We can do the same thing for the while loop.\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {start;\par while (stop) \{\par    statement;\par    loop;\par    \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {This for loop and while loop do }{\i exactly}{ the same thing.  In general, we use the for loop when we know in advance how many times we will execute the loop, or when the number of times can be expressed as a simple mathematical expression.  The while loop is usually used when we want to loop while some condition is true, as we did here by looping while we still needed to pay on the car.\par }\pard \s21\qj\fi360\widctlpar\adjustright {As with strings and integers, we can write a floating-point number by calling printf.  Like the conversion specification for an integer, the conversion specification for a floating-point number starts with the % character.  Instead of a d, though, we use f.  The basic conversion specification for a floating-point number, then, is %f.\par With integers, you put a number right after the % character to tell printf to put the numbers in a column.  You can do the same thing with floating-point numbers, although we didn't in this case.  With a floating-point number there is another value, though.  Our program is supposed to print a dollar amount, so we want two digits after the decimal point.  The %.2f conversion specification tells printf exactly that:  the .2 tells printf to print exactly two digits after the decimal point, rounding the number if needed.  To get a ten character wide column of dollar and cents amounts, we could use the conversion specification %10.2f.  As with integers, if you leave the field width (the first number) off, the number is printed without leading spaces.  If you don't tell the compiler how many digits to put after the decimal point, it will use a value of six.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 2.4: }{ Modify the sample program to find out how big the payments need to be to pay off the car in four years.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Hint:  Start with a payment of $600, then increase or decrease the payment to get to a solution.  You are playing a guess-the-payment game.  If you pay off the loan in less than 48 months, or if you need to pay a lot less than the payment on the 48th month, you need to decrease the payment size.  If it takes longer than 48 months, make the payment larger.  You should only go to the nearest cent, since the amount will not work out exactly.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }{\b Problem 2.5:}{  Let's assume that you are working with the planning board of the local city government.  You live in a pleasant city, but due to the local geography, the city can't expand indefinitely.  You don't want the city to become too crowded, either.  The current population size is 30,000 people.  Everyone seems to agree that if the city gets any bigger than 50,000 people, it will be overcrowded.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {One councilman has proposed new legislation to prevent the city from growing at more than 10% per year.  At this rate, how long will it be before the city hits the limit of 50,000 people?  Use a program very much like the sample program, but with a growing population instead of a shrinking principal to find out.  Do you feel this is acceptable?\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {This is not an idle problem.  While the numbers were different, this is exactly the same situation faced several years ago by the city of Boulder, Colorado.  The answer they found caused some changes in the thinking of the city planners, and affected the outcome of some zoning legislation.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }{\b Problem 2.6: }{ Inflation has been running at about 4% for the past few years.  On average, then, something that costs $1.00 at the beginning of the year will cost $1.04 by the end of the year.  Assuming a gallon of gas costs $1.00 today, what will it cost in ten years if inflation continues at 4%?  Now try the same problem with a $100,000 house.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {A few years ago, inflation was running at about 12%.  Try this inflation figure.  Is this rate a problem?\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344397}The Trace and Stop Commands{\*\bkmkend _Toc496344397}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\lang1024 {\shp{\*\shpinst\shpleft0\shptop3228\shpright9360\shpbottom10428\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz12\shplid1144{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 4784128}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 2.4\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* I owe, I owe, ... */\par \par #include <stdio.h>\par \par #define COST 24000.0              /* initial cost of the car */\par #define APR 15.0                  /* annual percentage rate */\par #define PAYMENT 250.0             /* monthly payment */\par \par unsigned month;                   /* number of months */\par float principal;                  /* amount left to pay */\par \par void main (void)\par \par \{\par month = 0;                        /* no payments made, yet */\par principal = COST;                 /* we start owing this much */\par while (principal > 0.0) \{       /* keep going until we're out of debt */\par    ++month;                       /* it's a new month */\par    principal += principal*        /* add in this month's interest */\par       APR/100.0/12.0;\par    principal -= PAYMENT;          /* make the payment */\par                                   /* write the status */\par    printf("month = %3u   principal = %.2f\\n", month, principal);\par    \}\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8204\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 2.4\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* I owe, I owe, ... */\par \par #include <stdio.h>\par \par #define COST 24000.0              /* initial cost of the car */\par #define APR 15.0                  /* annual percentage rate */\par #define PAYMENT 250.0             /* monthly payment */\par \par unsigned month;                   /* number of months */\par float principal;                  /* amount left to pay */\par \par void main (void)\par \par \{\par month = 0;                        /* no payments made, yet */\par principal = COST;                 /* we start owing this much */\par while (principal > 0.0) \{       /* keep going until we're out of debt */\par    ++month;                       /* it's a new month */\par    principal += principal*        /* add in this month's interest */\par       APR/100.0/12.0;\par    principal -= PAYMENT;          /* make the payment */\par                                   /* write the status */\par    printf("month = %3u   principal = %.2f\\n", month, principal);\par    \}\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx0\dpy3228\dpxsize9360\dpysize7200\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{If you have been running the debugger on the past few programs, you may have noticed a disturbing trend.  It takes a lot more steps to make it through one of our recent samples than it took to get through the samples in the last lesson.  You may, in fact, want to step through a program a bit faster.  The trace command will help you do this.  The trace command does all of the things that the step command does.  It moves the arrow in the source code window.  It updates the variables window if you have one open.  The difference is that the step command stops and waits after it executes a statement, while the trace command keeps on going.  You can use the two commands together, starting off in step mode, then switching to a trace to execute several lines in a row.  You can switch back to single-stepping at any time by selecting the step command again.\par The trace command gives you one quick way to trace through to the end of a program.  You can also select go, which runs even faster, since the computer does not draw the arrow or update the variables window.  There is one case, however, when none of this will do any good.  Type in the program shown in listing 2.4, but don't run it until you have read the entire section.\par You may notice that the only change from our previous sample was to change the interest rate to 15%.  What is wrong with this program?  Try to figure it out by doing the calculations through the end of the first loop by hand.\par When you run this program, you will find that the monthly payment does not cover the interest.  The principal begins to grow, rather than shrinking.  The result is that the program will never stop.  This is one form of the infamous infinite loop.  Once you realize that your program is in an infinite loop, trace or go won't get you to the end; there is no end.  Instead, in cases like this, pull down the Debug menu and select the Stop command.  That will stop the program in its tracks.  Other than turning the computer off or resetting it, it is the only way out of an infinite loop.  Considering how long it takes to boot from floppy disks, it's nice to know the way out.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344398}Exponents{\*\bkmkend _Toc496344398}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Integers were limited to a specific size.  Floating-point numbers have limits, too, but the limits are of a slightly different nature.  This is because floating-point numbers use exponents to represent very large and very small numbers.\par Exponents are the computers way of dealing with something called scientific notation.  An exponent is a power of ten that follows the floating-point number.  For example,\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {2.5e2\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {means 2.5 times 10 raised to the power of two.  You can also think of the power as the number of zeros to add to the 1.  Ten to the power two is 100, for example.  One-hundred times 2.5 is 250, so 2.5e2 is 250.\par }\pard \s21\qj\fi360\widctlpar\adjustright {Exponents can also be zero.  An exponent of zero means a 1 with no zeros, or just 1.  Multiplying by one gives the original number, so 2.5e0 is just 2.5.\par Finally, exponents can be negative.  A negative exponent means to divide by ten to the indicated power, so 2.5e-3 means to divide 2.5 by 1000, giving 0.0025.\par A quick way to work with exponents is to move the decimal point to the right for positive exponents, or to the left for negative exponents.\par Floating-point numbers can get quite large and quite small, but there is a limit to the size.  In ORCA/C, floating-point numbers can have exponents in the range 1e-38 to 1e38.  There is also a limit to the number of digits that can be handled.  It's a lot like a calculator with a ten-digit display.  If you need numbers with more than ten digits of accuracy, you have to get a different calculator.  ORCA/C floating-point numbers have seven digits of accuracy.  In other Cs, you would have to check the manual to find out how accurate the numbers are, but these are fairly common values.\par If you need larger exponents or more digits of accuracy in your floating-point numbers, you can use variables with a type of double, instead of float.  They work the same way \endash  double numbers even use the same conversion specification as float numbers \endash  but double variables take up twice the space as float variables, giving you exponents from 1e-308 to 1e308.  Double variables can display seventeen digits accurately.  Again, these are common values for C compilers, but there is nothing to prevent a particular compiler from making float and double variables the same size.\par With integers, using a longer integer meant accepting a speed penalty.  The same is true on some computers when dealing with floating-point numbers, but due to a peculiarity in the way floating-point calculations are done on the Apple IIGS (and most other microcomputers, as it turns out), calculations with float variables take about the same amount of time as calculations with double variables.  The only thing float saves you is space.\par The example in listing 2.5 shows how to use floating-point numbers to represent very large numbers.  By using e instead of f in the conversion specification, we are telling the compiler to write the value in exponent format.  This is also the format used by the debugger to display floating-point numbers.\par If you look closely at this program, you will see something that looks a little odd.  We want to print "At 3% growth...," but as you know, the % character marks the start of a conversion specification.  The printf function has to use a special convention so that you can use the % character as a conversion specification, and still be able to print the character when you want to.  Technically, % is another conversion specification that prints a single % character without requiring a parameter after the format string; I generally find it easier to just remember that % is a special character in a format string, so I need to write two of the % character whenever I want tp print one of them.\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }{\b Problem 2.7: }{ Some germs can reproduce every twenty minutes.  They reproduce by fission, where one germ splits in half to make two new germs.  Assuming nothing stopped their growth, how many germs would there be after one day, starting with a single germ?\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344399}Don't Panic!{\*\bkmkend _Toc496344399}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {By now, your head is probably spinning.  With six types of integers and two types of floating-point numbers, plus a variety of conversion specification, some of which work with some values, and some of which don't, things may be getting a little confusing.  Don't worry.  It happens to everyone.\par The important thing at this point isn't to memorize all of the number types, conversion specifications, and so forth, the important point is to realize that they exist, and why.  You should know that unsigned integers exist because they can store larger numbers than signed integers of the same size, and that calculations with unsigned values are faster than calculations with signed values.  You should know that integers let you represent whole numbers, and that floating-point values are used when values between the whole numbers are needed, or when the values are very large or very small.  You don't have to remember that lu is the conversion specification for unsigned long values \endash  you can look that up in this lesson or in your compiler reference manual if you forget.\par }{\lang1024 {\shp{\*\shpinst\shpleft0\shptop-2366\shpright9360\shpbottom2674\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz13\shplid1145{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 4718592}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 2.5\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/*  There are about 5 billion people in the world.  Assuming     */\par /*  a growth rate of 3% per year, how many people will there     */\par /*  be in 100 years?                                             */\par \par #include <stdio.h>\par \par float people;                     /* number of people */\par unsigned year;                    /* current year */\par \par void main (void)\par \par \{\par people = 5e9;                     /* 5e9 is 5000000000, or 5 billion */\par for (year = 1989; year < 2090; ++year)\par    people *= 1.03;\par printf("At 3%% growth, there will be %e people in 2089.\\n", people);\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8205\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 2.5\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/*  There are about 5 billion people in the world.  Assuming     */\par /*  a growth rate of 3% per year, how many people will there     */\par /*  be in 100 years?                                             */\par \par #include <stdio.h>\par \par float people;                     /* number of people */\par unsigned year;                    /* current year */\par \par void main (void)\par \par \{\par people = 5e9;                     /* 5e9 is 5000000000, or 5 billion */\par for (year = 1989; year < 2090; ++year)\par    people *= 1.03;\par printf("At 3%% growth, there will be %e people in 2089.\\n", people);\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx0\dpy-2366\dpxsize9360\dpysize5040\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{As the course progresses, you will see each of these number formats used again and again.  Gradually, you will get used to them.  By the end of the course, this lesson will seem pretty easy, instead of being the blur of facts it probably is now.  As long as you keep the concepts in mind, you'll do fine.\par \par }\pard\plain \qc\widctlpar\adjustright \f4\cgrid {\b\fs36 \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \qc\widctlpar\adjustright \f4\cgrid {\b\fs36 Lesson Two\par Solutions to Problems\par }\pard \qj\widctlpar\adjustright {\b\fs28 \par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344400}Solution to problem 2.1.{\*\bkmkend _Toc496344400}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Write out five Fibonacci numbers */\par \par #include <stdio.h>\par \par int last;                               /* last number */\par int current;                            /* current number */\par int next;                               /* new number */\par \par void main(void)\par \par \{\par last = 0;\par current = 1;\par \par next = last+current;\par printf("%d\\n", next);\par last = current;\par current = next;\par \par next = last+current;\par printf("%d\\n", next);\par last = current;\par current = next;\par \par next = last+current;\par printf("%d\\n", next);\par last = current;\par current = next;\par \par next = last+current;\par printf("%d\\n", next);\par last = current;\par current = next;\par \par next = last+current;\par printf("%d\\n", next);\par last = current;\par current = next;\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344401}Solution to problem 2.2.{\*\bkmkend _Toc496344401}\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* write a table of squares */\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par #include <stdio.h>\par \par int i;                          /* loop variable */\par int s;                          /* square of i */\par \par void main(void)\par \par \{\par for (i = 1; i <= 5; ++i) \{\par    s = i*i;\par    printf("%10d%10d\\n", i, s);\par    \}\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344402}Solution to problem 2.3.{\*\bkmkend _Toc496344402}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* draw five concentric rectangles */\par \par #include <quickdraw.h>\par \par int i;                          /* loop variable */\par int top, bottom, left, right;   /* sides of the rectangle */\par \par void main(void)\par \par \{\par SetPenMode(0);\par SetSolidPenPat(0);\par SetPenSize(3,1);\par \par top = 10;\par bottom = 70;\par left = 10;\par right = 100;\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {for (i = 1; i <= 5; ++i) \{\par    MoveTo(left, top);\par    LineTo(right, top);\par    LineTo(right, bottom);\par    LineTo(left, bottom);\par    LineTo(left, top);\par \par    left = left+6;\par    right = right-6;\par    top = top+6;\par    bottom = bottom-6;\par    \}\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344403}Solution to problem 2.4.{\*\bkmkend _Toc496344403}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Why I don't own a Porche */\par \par #include <stdio.h>\par \par #define COST 24000.0              /* initial cost of the car */\par #define APR 10.0                  /* annual percentage rate */\par #define PAYMENT 608.71            /* monthly payment */\par \par unsigned month;                   /* number of months */\par float principal;                  /* amount left to pay */\par \par void main (void)\par \par \{\par month = 0;                        /* no payments made, yet */\par principal = COST;                 /* we start owing this much */\par while (principal > 0.0) \{         /* keep going until we're out of debt */\par    ++month;                       /* it's a new month */\par    principal += principal*        /* add in this month's interest */\par       APR/100.0/12.0;\par    principal -= PAYMENT;          /* make the payment */\par                                   /* write the status */\par    printf("month = %3u   principal = %.2f\\n", month, principal);\par    \}\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344404}Solution to problem 2.5.{\*\bkmkend _Toc496344404}\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* See how long it will take to reach a population of 50,000 */\par \par #include <stdio.h>\par \par #define CURRENTPOPULATION 30000.0     /* initial population of the city */\par #define GROWTH 10.0                     /* population growth rate */\par \par unsigned year;                          /* year */\par float population;                       /* population during year */\par \par void main(void)\par \par }\pard \s23\qj\fi360\widctlpar\adjustright {\{\par year = 1990;                            /* current year */\par population = CURRENTPOPULATION;         /* initialize the population */\par while (population < 50000.0) \{        /* keep going until we hit 50,000 */\par    ++year;                              /* new year */\par    population +=                        /* add in this year's growth */\par       population*GROWTH/100.0;\par                                         /* write the status */\par    printf("The population in %u will be %.0f.\\n", year, population);\par    \}\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344405}Solution to problem 2.6.{\*\bkmkend _Toc496344405}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par By writing the solution to the first part of the problem carefully, you can reuse most of the program to answer the second two parts of the problem.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* gas cost at 4% inflation */\par \par #include <stdio.h>\par \par #define CURRENTCOST 1.00                /* current cost of the item */\par #define INFLATION 4.0                   /* inflation rate */\par \par unsigned year;                          /* number of years */\par float cost;                             /* cost of the item */\par \par void main(void)\par \par \{\par cost = CURRENTCOST;\par for (year = 1990; year <= 1999; ++year)\par    cost += cost*INFLATION/100.0;\par printf("Cost of a $%.2f item after 10 years is $%.2f.\\n",\par    CURRENTCOST, cost);\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par All we have to change now is the starting cost of the item.\par }{\f6 \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* house cost at 4% inflation */\par \par #include <stdio.h>\par \par #define CURRENTCOST 100000.0            /* current cost of the item */\par #define INFLATION 4.0                   /* inflation rate */\par \par unsigned year;                          /* number of years */\par float cost;                             /* cost of the item */\par \par void main(void)\par \par \{\par cost = CURRENTCOST;\par for (year = 1990; year <= 1999; ++year)\par    cost += cost*INFLATION/100.0;\par printf("Cost of a $%.2f item after 10 years is $%.2f.\\n", \par    CURRENTCOST, cost);\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par For part 3, we need to change the inflation rate.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* house cost at 12% inflation */\par \par #include <stdio.h>\par \par #define CURRENTCOST 100000.0            /* current cost of the item */\par #define INFLATION 12.0                  /* inflation rate */\par \par unsigned year;                          /* number of years */\par float cost;                             /* cost of the item */\par \par void main(void)\par \par \{\par cost = CURRENTCOST;\par for (year = 1990; year <= 1999; ++year)\par    cost += cost*INFLATION/100.0;\par printf("Cost of a $%.2f item after 10 years is $%.2f.\\n", \par    CURRENTCOST, cost);\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344406}Solution to problem 2.7.{\*\bkmkend _Toc496344406}\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* Starting with 1 germ and assuming that each germ divides by */\par /* fusion every 20 minutes, producing two new germs, how many  */\par /* germs will there be after 24 hours?                         */\par \par #include <stdio.h>\par \par float germs;                            /* number of germs */\par unsigned time;                          /* time loop counter */\par \par void main(void)\par \par \{\par germs = 1;\par for (time = 1; time <= (24*3); ++time)\par    germs *= 2.0;\par printf("After 24 hours, there will be %e germs!\\n", germs);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \widctlpar\adjustright \f4\cgrid {\par \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s1\qc\nowidctlpar\outlinelevel0\adjustright \b\f4\fs36\cgrid {{\*\bkmkstart _Toc496343305}{\*\bkmkstart _Toc496344407}Lesson Three{\*\bkmkend _Toc496343305}{\*\bkmkend _Toc496344407}\par {\*\bkmkstart _Toc496344408}Input, Loops and Conditions{\*\bkmkend _Toc496344408}\par }\pard\plain \qj\widctlpar\adjustright \f4\cgrid {\b\fs28 \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344409}Input{\*\bkmkend _Toc496344409}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {So far, all of your programs have only done one thing.  No matter how many times you ran the program, unless you changed the program itself, it always did the same thing.  The reason, of course, is that the programs could never ask you for any information.  It's time to start controlling our programs a bit more through the use of input.\par Your first program was a pretty simple one; it used the printf function to write a string to the shell window.  You have already learned to write integers and real numbers using printf.  The scanf library function is the counterpart to printf: it is used in much the same way to read numbers and strings.  Like printf, scanf is defined in the stdio.h header file, so you don't have to include any new libraries to read values from the keyboard.\par Type in the following program and run it.  Be sure to shrink the program window to less than half the width of the screen before you run the program, so you will be able to see the entire shell window.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* Read an integer and write   */\par /* it to the screen.           */\par \par #include <stdio.h>\par \par int i;\par \par void main (void)\par \par \{\par scanf(" %d", &i);\par printf("%d\\n", i);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par When the program gets to the scanf function call, it stops.  In the shell window, you can see an inverse box, which is the input cursor; your program is waiting for you to type a number and press the return key.  Go ahead and do that.  When you do, the program reads the value, placing it in the variable i, and then writes it back to the screen using printf.\par Like printf, scanf is controlled with a format string, and the format string is still the first parameter.  This time, though, the format string is used as a pattern for the characters that scanf reads.  There are basically three things that you can put in scanf's format string: a conversion specifier, like the %d you see in the sample program; whitespace (more on that later); and other characters.\par The conversion specifier is used when you want to read something, like a number, from the input stream.  (In C, we talk about steams a lot.  Later, you will learn more about streams, but for now, keep in mind that the phrase "input stream" just means the characters you type from the keyboard.)  The conversion specifiers used by the scanf function work pretty much like the conversion specifiers used by printf, and generally mean the same thing.  As you learn more about C, you will start to find out what all of the exceptions are, but all of the conversion specifiers you have learned so far work the same way in scanf and printf.  The %d conversion specifier, for example, reads an integer value from the input stream, converts it into the internal format used to store numbers on a computer, and stuffs the result into the integer variable i.  As with printf, each conversions specification needs exactly one parameter.  With printf, though, the idea was to print a value, so you could put a wide variety of things in the parameter list for the function, including constant numbers like 1 or 500, variables like i or interest, and even expressions like interest/2.  The scanf function, though, is reading a value and storing it someplace.  As a result, the parameter must be a variable name.  In addition, scanf needs to know where the variable is, not it's value.  In C, when you want to tell a function where a variable is, you pass the address of the variable by putting an & character right before the name of the variable.  What you are doing is passing a pointer to the variable.  Over the next few lessons we will spend a great deal of time discussing pointers, what they are, and how they are used, but you need to know a lot more about programming in general, and C in particular, before they will make sense.  For now, just remember to put a & character before all of the variables you pass to the scanf function.\par When you use a pencil and paper to write text, columns of numbers, and so forth, you generally use blank space to help organize the information.  You also use blank space to organize information when you type things from a keyboard, but as you may have noticed, there is more than one way to get blank space with a computer.  For example, you can use the space bar to insert some spaces; or the TAB key to insert several spaces or a tab character, depending on the editor you are using.  When you type responses to a program, you generally expect to be able to use whichever method you feel like using at the moment, and you probably don't want the program to be sensitive to exactly how many spaces you type.  C solves this problem by grouping several characters together, calling all of them whitespace characters.  The idea is that the whitespace characters are the ones that look like spaces on the computer screen, although different printers, the operating system, and the toolbox may all treat these characters a little differently.  The whitespace characters in C are the space, the end-of-line character, vertical and horizontal tabs, and form feeds.  So far, you have only seen two of these characters in your C programs: the space bar, and the end-of-line character, which you put into a string using the \\n character.  Tabs are available, too, but you generally won't use them in desktop programs, since the Apple IIGS toolbox ignores tab characters.\par The scanf function treats these whitespace characters in a special way to help you create programs that work the way the user wants to use the program without much effort on your part.  In our sample program, the format string started with a space.  Here's that string again:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {" %d"\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {When scanf sees a whitespace character in the format string, it skips over all whitespace characters in the input stream, stopping when it gets to the first non-whitespace character.  It doesn't matter how many whitespace characters are in the input, what kind of whitespace character they are, or even if they are mixed; all of them get skipped.\par }\pard \s21\qj\fi360\widctlpar\adjustright {Finally, you can put other characters in the format string.  If you do, the scanf function expects to find exactly the same character in the input stream.\par If scanf hits something it doesn't expect, it stops.  That's bad news, of course, since with some compilers and optimizations, the resulting C program might crash or hang if it gets input that it can't handle.  Later in the course, you will learn how to write bullet-proof C programs that won't crash or hang with any compiler; for now, ORCA/C 1.1 will protect you from crashes when your input is bad as long as you don't optimize the code.  We haven't covered how to use the optimizer yet \-\endash  this is just a warning to those of you who are adventurous enough to be looking ahead in the ORCA/C manual and trying new things before they are covered in the course.  (That's a practice I highly recommend, by the way.)\par The number you type from the keyboard follows the same rules as numbers you type in a C program; namely, they must consist entirely of digits, and they must not have imbedded whitespace.  You can also start the number with a + or - sign.  scanf stops when it gets to the first character that is not a part of a legal number, returning whatever has been typed so far.\par Something very interesting happens if the number you type is too big.  In lesson 2, you learned that integer variables have an upper limit on size; this limit is 32767.  If you type a number bigger than 32767, scanf will truncate the number in a way that doesn't make much sense unless you know a lot about how binary numbers are stored in the computer.  The number printed by printf will definitely not be the same number you type, though!\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 3.1.}{  Try predicting what the program will write when you type in each of the following strings.  Try running the program to see if you are right.\par \par }\pard \s24\qj\fi-360\li720\widctlpar\adjustright {a.  }{\f6 3}{\par b.  }{\f6 4+9}{\par c.  }{\f6 3.14159}{\par d.  }{\f6 three}{\par e.  }{\f6 -8}{\par f.  }{\f6 +6 9}{\par g.  }{\f6 - 9}{\par h.  press the RETURN key, then type: }{\f6 7}{\par i.  }{\f6 8,536,912}{\par j.  }{\f6 8536912}{\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344410}Our First Game... er, Computer Aided Simulation{\*\bkmkend _Toc496344410}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Well, let's have some fun.  Now that we can hold a simple conversation with the computer, we can write our first simple computer game, shown in listing 3.1.\par There are a lot of new concepts in this program, and we will spend a lot of time examining it in detail, but first type it in and run it.  As with your first program, be sure and shrink the program window so you can see the shell window before running the program.  You can't change the size of windows or stop the program while it is waiting for you to type a number, so this is an important step to remember.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344411}The Do-While Loop{\*\bkmkend _Toc496344411}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {One of the new things in our program is a new statement, called the do-while loop, or sometimes just the do loop.  This is the third looping statement you have learned in C.  The first two, of course, are the for loop and the while loop.  The do loop is also the last looping statement in C!  You're getting there...\par }{\lang1024 {\shp{\*\shpinst\shpleft0\shptop-473\shpright9360\shpbottom9463\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz14\shplid1146{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 4653056}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 3.1\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Guess a number */\par \par #include <stdio.h>\par #include <stdlib.h>\par \par int i;                               /* input value */\par int value;                           /* the number to guess */\par \par void main(void)\par \par \{\par /* Introduce the game */\par printf("In this game, you will try to\\n");\par printf("guess a number.  I need a hint to\\n");\par printf("help me pick numbers, though.\\n\\n");\par \par /* get a seed for the random number generator */\par printf("Please type a number between 1\\nand 30000: ");\par scanf(" %d", &i);\par srand(i);\par \par /* pick a number from 1 to 100 */\par value = rand() % 100 + 1;\par \par /* let the player guess the number */\par do \{\par    printf("Your guess: ");           /* get the guess */\par    scanf(" %d", &i);\par    if (i > value)                    /* check for too high */\par       printf("%d is to high.\\n", i);\par    if (i < value)                    /* check for too low */\par       printf("%d is to low.\\n", i);\par    \}\par while (i != value);               /* if the guess was wrong then loop */\par printf("%d is correct!\\n", i);\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8206\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 3.1\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Guess a number */\par \par #include <stdio.h>\par #include <stdlib.h>\par \par int i;                               /* input value */\par int value;                           /* the number to guess */\par \par void main(void)\par \par \{\par /* Introduce the game */\par printf("In this game, you will try to\\n");\par printf("guess a number.  I need a hint to\\n");\par printf("help me pick numbers, though.\\n\\n");\par \par /* get a seed for the random number generator */\par printf("Please type a number between 1\\nand 30000: ");\par scanf(" %d", &i);\par srand(i);\par \par /* pick a number from 1 to 100 */\par value = rand() % 100 + 1;\par \par /* let the player guess the number */\par do \{\par    printf("Your guess: ");           /* get the guess */\par    scanf(" %d", &i);\par    if (i > value)                    /* check for too high */\par       printf("%d is to high.\\n", i);\par    if (i < value)                    /* check for too low */\par       printf("%d is to low.\\n", i);\par    \}\par while (i != value);               /* if the guess was wrong then loop */\par printf("%d is correct!\\n", i);\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx0\dpy-473\dpxsize9360\dpysize9936\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{Like the while loop, the do loop loops while some condition is satisfied.  Unlike the while loop, the condition is tested after the body of the loop has been executed at least one time.  This means that the statements in the do loop are always executed at least one time, while the statements in the while loop can be skipped altogether.  This is an important difference, and the key to why there are two loops instead of just one.  To understand this difference, let's look at while loops and do loops from some of our programs, and compare the two.\par In the last lesson, we wrote a program that showed how many payments were needed to buy a car. The source code is shown in listng 3.2.\par In this case, we needed to loop until the amount we needed to pay off was zero.  It would be possible, although in this case not very likely, for the principal to be zero before the loop was ever executed.  This is the key test for a while loop: you must ask yourself if it is possible for the condition that stops the loop to be true before you start.  In other words, you want to know if it is possible that you may not want to execute the statements in the loop at all.  If that is the case, a while loop should be used.\par }{\lang1024 {\shp{\*\shpinst\shpleft0\shptop5390\shpright9360\shpbottom8126\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz17\shplid1149{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 4456448}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 3.4\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {while (i != value) \{\par    printf("Your guess: ");           /* get the guess */\par    scanf(" %d", &i);\par    if (i > value)                    /* check for too high */\par       printf("%d is to high.\\n", i);\par    if (i < value)                    /* check for too low */\par       printf("%d is to low.\\n", i);\par    \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8209\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 3.4\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {while (i != value) \{\par    printf("Your guess: ");           /* get the guess */\par    scanf(" %d", &i);\par    if (i > value)                    /* check for too high */\par       printf("%d is to high.\\n", i);\par    if (i < value)                    /* check for too low */\par       printf("%d is to low.\\n", i);\par    \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx0\dpy5390\dpxsize9360\dpysize2736\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}{\shp{\*\shpinst\shpleft0\shptop2222\shpright9360\shpbottom5246\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz16\shplid1148{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 4521984}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 3.3\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {do \{\par    printf("Your guess: ");           /* get the guess */\par    scanf(" %d", &i);\par    if (i > value)                    /* check for too high */\par       printf("%d is to high.\\n", i);\par    if (i < value)                    /* check for too low */\par       printf("%d is to low.\\n", i);\par    \}\par while (i != value);               /* if the guess was wrong then loop */\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8208\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 3.3\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {do \{\par    printf("Your guess: ");           /* get the guess */\par    scanf(" %d", &i);\par    if (i > value)                    /* check for too high */\par       printf("%d is to high.\\n", i);\par    if (i < value)                    /* check for too low */\par       printf("%d is to low.\\n", i);\par    \}\par while (i != value);               /* if the guess was wrong then loop */\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx0\dpy2222\dpxsize9360\dpysize3024\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}{\shp{\*\shpinst\shpleft0\shptop-946\shpright9360\shpbottom2078\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz15\shplid1147{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 4587520}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 3.2\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {while (principal > 0.0) \{         /* keep going until we're out of debt */\par    ++month;                       /* it's a new month */\par    principal += principal*        /* add in this month's interest */\par       APR/100.0/12.0;\par    principal -= PAYMENT;          /* make the payment */\par                                   /* write the status */\par    printf("month = %3u   principal = %.2f\\n", month, principal);\par    \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8207\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 3.2\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {while (principal > 0.0) \{         /* keep going until we're out of debt */\par    ++month;                       /* it's a new month */\par    principal += principal*        /* add in this month's interest */\par       APR/100.0/12.0;\par    principal -= PAYMENT;          /* make the payment */\par                                   /* write the status */\par    printf("month = %3u   principal = %.2f\\n", month, principal);\par    \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx0\dpy-946\dpxsize9360\dpysize3024\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{The do loop looks very similar.  The only real difference is that the condition is evaluated at the end of the loop, not the beginning. An example of this is shown in listing 3.3.\par The do loop is generally used in cases where the condition doesn't make sense until after the statements in the body of the loop have been executed at least one time.  For example, it would seem to make sense to use a while loop that looks like the one in listing 3.4 to do the same job.\par There is a major problem with this code, though.  Before the loop is executed, you don't know what the value of i is.  In fact, the random number generator has a one in 65536 chance of returning i itself for the first number, so your program will actually fail every once in a while.  That, in computer terms, is called a bug.  This is the worst kind of bug, because the program will work most of the time.  When it does fail, you may be inclined to thing that the person who tells you about it is wrong.  After all, you may have used the program several thousand times without seeing a problem!\par There is a solution, though.  You can start off by initializing i to a number different from value, as shown in listing 3.5.\par }{\lang1024 {\shp{\*\shpinst\shpleft0\shptop0\shpright9216\shpbottom3312\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz18\shplid1150{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 4390912}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 3.5\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {i = value-1;                         /* make sure we get into the loop */\par while (i != value) \{\par    printf("Your guess: ");           /* get the guess */\par    scanf(" %d", &i);\par    if (i > value)                    /* check for too high */\par       printf("%d is to high.\\n", i);\par    if (i < value)                    /* check for too low */\par       printf("%d is to low.\\n", i);\par    \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8210\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 3.5\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {i = value-1;                         /* make sure we get into the loop */\par while (i != value) \{\par    printf("Your guess: ");           /* get the guess */\par    scanf(" %d", &i);\par    if (i > value)                    /* check for too high */\par       printf("%d is to high.\\n", i);\par    if (i < value)                    /* check for too low */\par       printf("%d is to low.\\n", i);\par    \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx0\dpy0\dpxsize9216\dpysize3312\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{This will work; the test will always fail the first time, so the person guessing the number always gets at least one chance to guess the number.  On the other hand, the do loop works, to, but it doesn't require that you set the initial value before you start into the loop.\par The acid test for when to use a do loop, then, is whether or not the test that ends the loop makes sense before the statements in the loop have been executed one time.  In our example program, the test uses the number i, which is read inside the loop.  The test doesn't make sense until the number has been read at least one time, so we use a do loop.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344412}How C Divides{\*\bkmkend _Toc496344412}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Everyone knows that when you divide 3 by 2, the answer is 1.5.  Unfortunately, the computer doesn't know that, at least not when you are using integers.  An integer can't have the value 1.5: integers can only be whole numbers.  You could use real numbers most of the time, but real numbers take more space, and it takes a lot more time to do an operation using real numbers than using integers.  The program shown in listing 3.6 will help us explore this, and many other curiosities about the / (divide) and % (mod) operators.\par }{\lang1024 {\shp{\*\shpinst\shpleft0\shptop-5836\shpright4608\shpbottom2228\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz19\shplid1151{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 4325376}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s22\qc\sa200\nowidctlpar\adjustright \b\f4\fs20\cgrid {The Computer Bug\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {If you think about it, it's pretty peculiar that an error in a program would be called a bug.  After all, it makes about as much sense to call an error an elephant, or a car.  How did this happen?\par Well, it all started back in the old days of computing.  This was before microprocessors put an entire computer on a chip.  It was before transistors put an entire computer in a small room.  It was even before vacuum tubes allowed a calculator to fill only a small building (and allowed the operators to fry eggs on the hot components).  This was in the good old days, when computers used relays.\par For the fortunate uninitiated, a relay is a switch that uses a small electromagnet to control the flow of current.  When electricity flows through the electromagnet, the electromagnet pulls on a small piece of metal, closing a switch so current can flow.  When the electricity stops, a spring pulls the switch back open.\par Back in those days, some intrepid souls had a program that didn't work.  The darn thing should work; they went over the code again and again by hand.  Finally, they decided that the program would fail if a particular bit in the computer would not work.  A bit in the machine they were using was a relay, so they sent a repairman back to fix the broken component.  Lo and behold, the component wasn't broken at all, but a miller moth had chosen the relay as a place to expire.  It's body prevented the switch from closing.  From that day on, a program that doesn't work is said to have a bug.\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8211\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s22\qc\sa200\nowidctlpar\adjustright \b\f4\fs20\cgrid {The Computer Bug\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {If you think about it, it's pretty peculiar that an error in a program would be called a bug.  After all, it makes about as much sense to call an error an elephant, or a car.  How did this happen?\par Well, it all started back in the old days of computing.  This was before microprocessors put an entire computer on a chip.  It was before transistors put an entire computer in a small room.  It was even before vacuum tubes allowed a calculator to fill only a small building (and allowed the operators to fry eggs on the hot components).  This was in the good old days, when computers used relays.\par For the fortunate uninitiated, a relay is a switch that uses a small electromagnet to control the flow of current.  When electricity flows through the electromagnet, the electromagnet pulls on a small piece of metal, closing a switch so current can flow.  When the electricity stops, a spring pulls the switch back open.\par Back in those days, some intrepid souls had a program that didn't work.  The darn thing should work; they went over the code again and again by hand.  Finally, they decided that the program would fail if a particular bit in the computer would not work.  A bit in the machine they were using was a relay, so they sent a repairman back to fix the broken component.  Lo and behold, the component wasn't broken at all, but a miller moth had chosen the relay as a place to expire.  It's body prevented the switch from closing.  From that day on, a program that doesn't work is said to have a bug.\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx0\dpy-5836\dpxsize4608\dpysize8064\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{Here are the results from running this program.  If you run the program, you won't be able to see all of the output in the shell window at one time.  You can see most of it, though, if you resize the shell window.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {first       :-10\par last        :10\par }\pard \s23\qj\fi360\widctlpar\adjustright {denominator :4\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {     a      b       a/b       a%b\par    -10      4        -2         2\par     -9      4        -2         3\par     -8      4        -2         0\par     -7      4        -1         1\par     -6      4        -1         2\par     -5      4        -1         3\par     -4      4        -1         0\par     -3      4         0         1\par     -2      4         0         2\par     -1      4         0         3\par      0      4         0         0\par      1      4         0         1\par      2      4         0         2\par      3      4         0         3\par      4      4         1         0\par      5      4         1         1\par      6      4         1         2\par      7      4         1         3\par      8      4         2         0\par      9      4         2         1\par }\pard \s23\qj\fi360\widctlpar\adjustright {    10      4         2         2\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }{\lang1024 {\shp{\*\shpinst\shpleft0\shptop589\shpright9360\shpbottom6925\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz20\shplid1152{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 4259840}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 3.6\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Exploring / and % */\par \par #include <stdio.h>\par \par int n;                            /* the "top" number in the division */\par int d;                         /* the "bottom" number in the division */\par int first,last;                   /* the first/last number to divide */\par \par void main(void)\par \par \{\par printf("first       :");          /* get the first/last numbers */\par scanf(" %d", &first);\par printf("last        :");\par scanf(" %d", &last);\par printf("denominator :");          /* get the number to divide by */\par scanf(" %d", &d);\par                                   /* write the table */\par printf("\\n     a      b       a/b       a%%b\\n");\par for (n = first; n <= last; ++n)\par    printf("%6d %6d %9d %9d\\n", n, d, n/d, n%d);\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8212\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 3.6\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Exploring / and % */\par \par #include <stdio.h>\par \par int n;                            /* the "top" number in the division */\par int d;                         /* the "bottom" number in the division */\par int first,last;                   /* the first/last number to divide */\par \par void main(void)\par \par \{\par printf("first       :");          /* get the first/last numbers */\par scanf(" %d", &first);\par printf("last        :");\par scanf(" %d", &last);\par printf("denominator :");          /* get the number to divide by */\par scanf(" %d", &d);\par                                   /* write the table */\par printf("\\n     a      b       a/b       a%%b\\n");\par for (n = first; n <= last; ++n)\par    printf("%6d %6d %9d %9d\\n", n, d, n/d, n%d);\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx0\dpy589\dpxsize9360\dpysize6336\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{When you use the / operator to divide two integers, it always gives an integer result.  Of course, that means that the answer isn't 1.25 when you divide 5 by 4, since 1.25 isn't an integer.  Instead, C chops off any digits to the right of the decimal place, and returns the integer part that is left.  The same is true when the answer is a negative number, as you can see from the table.  When you divide -5 by 4, the answer is -1.\par There are times when you need to know the remainder from an integer division.  The % operator is used to get the remainder.  The % operator only works with integers, and always gives an integer for the answer.  When both numbers are positive, the % operator returns the remainder from the division.  For example, 7 divided by 4 is 1 with a remainder of 3, so 7 / 4 is 1, and 7 % 4 is 3.\par Looking at the table from our sample program, you can see that the % operator behaves a little strangely when one number is negative.  For example, (-1) % 4 is 3, not 1 or -1, as you might expect.  The reasons for this are tied up in an obscure branch of mathematics called modular arithmetic.  To figure out what the % operator will give you when the first number is negative, take a close look at our table.  The numbers repeat a series over and over again, even for negative arguments.\par As you may know, it is not legal to divide by zero.  This restriction is due to the nature of numbers.  If you try to divide by 0 in C, the results are undefined, which means the compiler can return anything it wants to.  Modular arithmetic also imposes an additional restriction on the % operator.  You can use a negative number on the left-hand side of the operator, as our sample program does, but you cannot use a negative number (or zero) on the right-hand side of the % operator.\par All of this may seem a bit obscure and theoretical, and it really is.  We can use this information to do some pretty neat stuff, though.  Looking at the table from our sample program, you can see that the % operator always returned a value from 0 to 3.  In our number guessing game, we used the % operator to restrict the value returned by the random number generator to a small range of numbers.\par  \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {value = ran() % 100 + 1;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The rand function returns a number from -32767 to 32767.  We could just expand the range of numbers that the game will let you guess to the full range of values returned by rand, but it might get boring trying to track down a number in that range.  The result of\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {rand() % 100\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {is always in the range 0 to 99, though.  By adding 1, we get a number in the range 1 to 100.  To change our game so that you have to guess a number from 1 to 500, then, we just change this line to\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {value = rand % 500 + 1;\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344413}Empty Parameter Lists{\*\bkmkend _Toc496344413}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The call to rand in our program looks a bit odd.  You have seen function calls before, and you have seen parameter lists, but the call to rand is the first time you have seen a call to a function that doesn't need any parameters.  In C, though, you have to put the ( and ) characters that mark the parameter list after the function name, even if the function doesn't need any parameters.  The reason for this curious requirement is tied up in the way C defines functions and handles expressions.  It turns out that C needs to see the ( and ) characters so it knows that the name is a call to a function, and not a reference to a variable.  Later, when you learn a little more about how to create your own functions in C, and after you have learned more about something called scoping rules, we will return to this topic and explain why the ( and ) characters are needed.  For now, just remember that you always have to have ( and ) characters after the function name for any function call, even if you aren't passing any parameters.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344414}Nesting Loops{\*\bkmkend _Toc496344414}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {If you are very sharp at logic, know a lot about probability, and remembered that the range of integers is -32767 to 32767, you may have noticed that our number guessing program has a slight flaw.  It isn't one most people would ever notice, but it is there.\par The problem is that not all numbers have an equal chance of being the number picked by the game.  You see, there are 327 possible ways to pick each of the numbers 0 through 99 from the positive integers 0 to 32699, and 327 possible ways to pick the same numbers from the negative integers -32700 to -1.  You can see why by looking at the results of the % operator in the table in the last section.  The result of rand() % 100 will be zero when rand returns 0, 100, 200, and so forth, up to 32600.  All together, that's 327 ways to get a result of 0.  The result will be 1 when rand returns 1, 101, 201, and so on.  The same thing happens for negative numbers, where there are 327 more ways to get each of the numbers from 0 to 99.\par But there is also another way to get the integers 0 to 67 from the positive numbers 32700 to 32767, and an extra way to get the integers 33 to 99 from the negative integers -32767 to -32701.  If you play poker, and you know there is an extra ace of spades in the deck, you know it can effect the outcome of the game.  Having a few extra ways to get some of the numbers from 0 to 99 also effects our number-guessing game.\par The table below summarizes this, showing the chance that each number will be picked.\par \par }\pard \s21\qj\keepn\widctlpar\tx900\tx2340\adjustright {\ul guess}{\tab }{\ul ways to get it}{\tab }{\ul probability it is the guess}{\par 0 to 32\tab 327+327+1\tab 0.0099947\par 33 to 67\tab 327+327+1+1\tab 0.0100099\par }\pard \s21\qj\widctlpar\tx900\tx2340\adjustright {68 to 99\tab 327+327+1\tab 0.0099947\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par Ideally, each number should have a 0.01 chance (one in a hundred) of being chosen.  As you can see, the difference isn't all that great, but in some simulations it might just be important.  A simulation of a roulette wheel, a craps game, or a poker game is one case where the difference could be critical.\par One way to even out the chances that each number will be picked is to eliminate any answer that isn't in the range 1 to 100.  The versatile do loop can be used to do this.  We haven't learned how to test for one condition }{\i and}{ another yet, but by nesting two do loops, we can get the same effect.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* pick a number from 1 to 100 */\par do\par    do\par       value = rand();\par    while (value <= 0);\par }\pard \s23\qj\fi360\widctlpar\adjustright {while (value > 100);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {Looking at this another way, the outside loop does this:\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {do\par    <get a number>\par }\pard \s23\qj\fi360\widctlpar\adjustright {while (value > 100);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {This loop loops until the statements in the loop return a number less than or equal to 100.  This guarantees that the number isn't over 100, but it doesn't prevent numbers less than 1, like -2000.\par }\pard \s21\qj\fi360\widctlpar\adjustright {The interior loop,\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {   do\par       value = rand();\par }\pard \s23\qj\fi360\widctlpar\adjustright {   while (value <= 0);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {picks random numbers that are greater than zero.  It loops, getting numbers, until it finds one that satisfies the condition.  When it finds one, the outside loop does its test.  Together, the loops guarantee that value will have a result between 1 and 100.  It also evens out the chances that each number will be picked.\par }\pard \s21\qj\fi360\widctlpar\adjustright {The point here isn't really to pick better random numbers for our simple guessing game; the numbers were really good enough for our program already.  The point is that you can put anything inside of a do loop \-\endash  even another do loop.  You can also put a for loop inside a while loop, a while loop in a do loop, a for loop inside of a while loop that is inside of a do loop, and so on.\par When you put one loop inside of another, programmers call it a nested loop.  There is no theoretical limit to how many times you can nest loops.  You can, for example, put a for loop inside of a for loop that is inside of a for loop that... well, you get the idea.  In ORCA/C, you will eventually run out of memory if you nest too many loops.  You can generally count on nesting to 20 or 30 levels, though.  In real programs, three or four nested loops are pretty unusual, so the limit isn't very important.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 3.2. }{ In this problem, we will go a little crazy with do loops.  We will also be making several changes to our existing guessing game.  Rather than making all of the changes at once, make each change, run the program, make sure it works, and then move on.  That way, if you make a mistake, you know exactly where the mistake is.  This concept, called stepwise refinement, is a big help in developing programs quickly.  The reason is that finding bugs is generally the hardest part of correcting a bad program.  If you make a small change, and the program fails, you know exactly where to look for the problem.  If you make a lot of changes, you have a lot more places to look for the error.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {The first step is to use the two nested do loops outlined above to pick the random number, rather than the % operator.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Next, add a do loop around the part of the program that picks a number and lets the player guess it.  This do loop should loop until a new integer, named done, is zero.  Initialize done to three before the loop starts, and subtract one from it inside the loop.  At this point, the player gets to play the game three times, rather than one.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Remove the statement that initializes done to three, as well as the statement that subtracts one from the value.  Instead, at the end of the loop, put in yet another set of nested do loops.  Inside the loops, print a blank line, followed by\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {Play again?  Enter 0\par for no, 1 for yes:\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {and read a number.  Use the two do loops to make sure the answer is either a zero or one, using the same technique used earlier to make sure a value was between 1 and 100.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {At this point, you have an impressive set of nested statements, each doing a specific job.  One large do loop plays the game until the player wants to stop.  Inside of this loop are two sets of nested do loops that make sure a number is in a particular range.  There was already one do loop in the program, looping until the player guesses the right number.  All together, that's six do loops.  It sounds complicated, but by building the program up little by little, you have accomplished a complicated task without straining too many little grey cells.  This technique of stepwise refinement is one of the most important ideas in modern programming practice.  Simply put, you break a problem down by only worrying about a little of it at a time.  You will see this idea over and over in this course.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }{\b Problem 3.3. }{ In the text, there is an innocent looking statement: "it takes a lot more time to do an operation using real numbers than using integers."  Write a program to test this statement.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Your program should use two nested for loops; this is necessary because programs run so fast on the Apple IIGS.  The first loop should loop from 1 to 10000, while the interior loop should loop from 1 to 25.  Just put a semicolon after the second for loop, like this:\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {for (i = 1; i <= 10000; ++i)\par    for (j = 1; j <= 25; ++j)\par }\pard \s23\qj\fi360\widctlpar\adjustright {      ;\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {The body of the loop does nothing, which is legal.  Altogether, this means that the code in the loop (none at this point) will be executed 250000 times \-\endash  a quarter of a million times!\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {One other step you should take is too turn off debug code.  ORCA/C generates code to make the step-and-trace debugger work; this extra code takes extra time to execute.  Your programs will execute faster if you turn off the debug code.  (You will not be able to debug the programs, though, nor will you be able to stop them using the Stop command.)  Turn off the debug code by selecting Compile from the Run menu, and clicking on the check box labeled "Generate debug code."  (There should not be an X in the box when you are done.)  Click on the Set Options button to accept the change.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Start by timing the program using a watch with a second hand, or a stopwatch if you have one.  This is the time it takes the computer to do the nested for loops.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Next, define three integers, a, b and c.  Before the first for loop, set a to 3, and b to 5.  In the body of the loop, add a to b and save the result in c.  Execute the program, and time it.  You can figure out how long it takes to do a single integer add by subtracting the time for the empty loop from this time, and dividing by 250000.  If you don't have a calculator handy, you can write a short program to do the math.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Repeat the process, but this time, define a, b and c as real numbers.  The program will take a lot longer when you use real numbers, so be sure and change the value in the first for loop to 100, rather than 10000.  (If you don't, the program will run for several }{\i hours}{!)  The loop will look like this:\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {for (i = 1; i <= 100; ++i)\par    for (j = 1; j <= 25; ++j)\par }\pard \s23\qj\fi360\widctlpar\adjustright {      c = a+b;\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {The time needed to do one math operation is small for both integers and real numbers; less time than it takes to blink your eye.  On the other hand, it takes a lot longer to add two real numbers than to add two integers.  You can find out how much longer by dividing one result by the other.  The answer is why programmers use integers whenever they can, and one reason why computers bother with having two different kinds of numbers, instead of using real numbers for everything.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {You have already learned the point of this problem, but if you are curious, you might also see how long it takes to subtract, multiply and divide numbers.  Also, for everything but integer addition and subtraction, the amount of time required varies depending on what the numbers are.  You might try a few numbers to get an idea how much the difference can be.  If you are just a little curious, but not curious enough to change the program and run it for each operation, you can find the times for the numbers used in this problem in the solutions.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344415}Random Numbers{\*\bkmkend _Toc496344415}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {One of the new concepts used in our sample program is the random number.  You have probably heard that computers are very precise, and that is certainly true.  In our number guessing game, though, the last thing we want is for the computer to be precise.  If we know beforehand what number the computer will pick, this game just won't be much fun.  The program uses something called a random number generator to get around this problem.\par A random number generator is basically a way for the computer to generate a number, or series of numbers, that seem to be random.  Since the computer can only do very specific things, the numbers aren't really random, but they are very hard to predict, and that is good enough for a lot of programs.  Since the numbers really aren't random, they are technically called pseudo-random numbers.  That's a real mouthful, though, so we will continue to call them random numbers.\par To learn more about random numbers, we will write a simpler program.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* A closer look at      */\par /* pseudo-random numbers */\par \par #include <stdio.h>\par #include <stdlib.h>\par \par unsigned i;  /* loop variable */\par int seed;    /* seed */\par \par void main(void)\par \par \{\par printf("Random number seed = ");\par scanf(" %d", &seed);\par srand(seed);\par for (i = 1; i <= 10; ++i)\par    printf("%d\\n", rand());\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Type this program in and run it.  It will ask you for a random number seed, and then print ten pseudo-random numbers based on the seed value you give the program.  One of the things you should try is giving the program the same seed value more than one time.  When you do, you will always get the same ten numbers.  You should also try giving the program several different numbers.  These will produce a different series of ten numbers.  Within each group of ten numbers, though, it is hard to predict what the next one will be by looking at the numbers that come before it.  This is the heart of a good random number generator.\par We will use random numbers in many of our example programs.  Random numbers help us to write programs that don't do exactly the same thing each time we use them; that's something we will need over and over again.  Here are some places where random numbers are commonly used:\par \par }\pard \s21\qj\fi-360\li720\widctlpar\adjustright {1.\tab Random numbers are used in games like Chess.  Games work by scoring moves; the move with the best score is the one the computer makes.  If two moves have the same score, random numbers can be used to choose between them so the computer doesn't play exactly the same way each time.  In a game like chess or checkers, there are also many good ways to make the first few moves; these are called opening books.  Random number generators are used to pick an opening from the opening book.\par \par 2.\tab Many dungeon and dragon style computer games work based on probabilities.  For example, a character with a particular set of characteristics might have a probability of 0.4 of killing a giant ant with a broadsword.  The ant, conversely, might have a 0.2 chance of damaging the player.  A random number generator can be used to generate a number between 0 and 99, as our number-guessing game did.  The player kills the ant if the number is less than 40.  Next, another number is chosen, and the ant hurts the player if the number is less than 20.\par \par 3.\tab Computers are often used to do serious simulations.  Computer simulations are used to study traffic patterns, wars, and the spread of diseases.  As an example, let's assume that you are trying to protect Yellow Stone National Park from forest fires.  You could choose to "let it burn," letting nature take its course.  You could choose to fight all fires aggressively, but that would lead to a gradual build-up of weeds and wood to burn.  You might choose to cut fire lanes through the forest.  All of these possibilities can be examined using computer simulations.\par \par 4.\tab Random number generators are used in card games to shuffle cards.  The random number generator is used to pick which card will be taken from the deck next, taking one card from the remaining cards that have not been dealt.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 3.4.}{  Write a program to throw two six-sided dice twenty times.  Use the same ideas used in the number-guessing game.  Write the number of spots showing on each of the dice to the screen.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Be sure and use constants for the number of dice and the number of sides on the dice.  That way, if you want to use the program to throw fifty twenty sided dice, you can.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }{\b Problem 3.5.}{  You can draw a dot in the graphics window by doing first a MoveTo, then a LineTo the same spot.  For example,\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {MoveTo(10,10);\par }\pard \s23\qj\fi360\widctlpar\adjustright {LineTo(10,10);\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {draws a dot a 10,10.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Write a program that gradually blackens the rectangle with a left edge of 10, a top of 10, a right edge of 200, and a bottom of 70.  Do this using a for loop that loops from 1 to MAX, where MAX is defined at the top of your program as a constant.  Use a value of 11651 for MAX.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Inside the for loop, pick two random numbers.  The first should be in the range 10 to 200; assign this value to an integer variable called x.  The second should be in the range 10 to 70; assign this one to the variable y.  Draw a dot at this point using a MoveTo-LineTo sequence.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {The result is a program that gradually fills the area with black snow.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {There are 11651 dots in the area you are filling, but when the program finishes, not all dots are black.  Why?\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }{\b Problem 3.6. }{ Change the program from problem 3.5 to create multicolored snow by picking the color of the dot randomly.  The color should be in the range 0 to 3.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344416}Multiple Reads with scanf{\*\bkmkend _Toc496344416}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Up to this point, our use of scanf has been pretty minimal.  All we have used scanf for is to read a single integer.  Like printf, though, scanf can read more than one thing at a time.  It can also read real numbers or even strings.\par To look at how scanf reads more than one value at a time, we'll use another short program.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* Multiple reads */\par \par #include <stdio.h>\par \par int n1,n2,n3,n4;\par \par void main(void)\par \par \{\par scanf(" %d %d", &n1, &n2);\par scanf(" %d %d", &n3, &n4);\par printf("%d %d %d %d\\n",\par    n1,n2,n3,n4);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par At the beginning of this lesson, you learned that scanf skips all whitespace characters if the format string has a whitespace character.  When it reads a number, it reads all digits (the characters 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9 are digits) until a non-digit character is found.  A space or the end of a line counts as a non-digit character, since either is a whitespace character.  If there are two numbers to read, as in our program, scanf again skips blanks and end of line marks in search of a number, reading the new number using the same rules as the first number.  If there is more than one call to scanf, the second call picks right up with the first character that was not used by the first call to scanf.\par You should try problem 3.7 to make sure you really understand all of the fine points and implications of what was just said.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 3.7.}{  What will our test program print out for each of the following sets of input?  After you decide, run the program and see if you are right.\par \par }\pard \s24\qj\fi-360\li720\keepn\widctlpar\adjustright {first set:\par }{\f6 1   2\par }\pard \s24\qj\fi-360\li720\widctlpar\adjustright {\f6 3   4\par }{\par }\pard \s24\qj\fi-360\li720\keepn\widctlpar\adjustright {second set:\par }{\f6 1   2   3\par }\pard \s24\qj\fi-360\li720\widctlpar\adjustright {\f6 4   5   6\par }{\par }\pard \s24\qj\fi-360\li720\keepn\widctlpar\adjustright {third set:\par }\pard \s24\qj\fi-360\li720\widctlpar\adjustright {\f6 1   a   2   3   4\par }{\par }\pard \s24\qj\fi-360\li720\keepn\widctlpar\adjustright {fourth set:\par }{\f6 1\par 2   3\par }\pard \s24\qj\fi-360\li720\widctlpar\adjustright {\f6 4   5\par }{\par }\pard \s24\qj\fi-360\li720\keepn\widctlpar\adjustright {fifth set:\par }{\f6 1\par \par 2\par \par 3\par \par }\pard \s24\qj\fi-360\li720\widctlpar\adjustright {\f6 4\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344417}Reading Floating-Point Numbers{\*\bkmkend _Toc496344417}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {So far, we have used the scanf function to read integers.  It's just as easy to read floating-point numbers like 1.5, or 10.0.  The only difference, in fact, is that the variable you are reading should be declared as a floating-point number, rather than an integer, and you use a different conversion specification.\par When your program reads a floating-point number, you have a considerable amount of freedom concerning how you type the number.  You can type it as an integer, in which case the number will be automatically converted to a floating-point number.  You can type the number with a leading decimal point, a trailing decimal point, or a decimal point imbedded in the number.  You can also type an exponent, with or without a sign, with either an uppercase E or lowercase e.  In fact, all of the following numbers are valid floating-point numbers when you are typing a number as input to a program.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\tx1620\tx2880\adjustright \f6\fs20\cgrid {1\tab 10.0\tab 10.\par .1\tab 3.14159\tab 1e10\par 2.56E+2\tab -16e004\tab 327541e-1\par }\pard \s23\qj\fi360\widctlpar\tx1620\tx2880\adjustright {.1e1\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par There are two different kinds of floating-point numbers in standard C (and two more in Apple based implementations of C), and each type of floating-point number has a unique format specifier.  This is because each of the floating-point number formats is stored a different way in memory, and you need to tell scanf which number format to use.  Back in lesson 2, you used two difference conversion specifiers with floating-point numbers; f was used to print the number without an exponent, while e printed a value with an exponent.  When you are reading numbers, you don't have to worry about the distinction.  scanf will accept either conversion specifier and read any kind of floating-point number you choose to type.  If you are reading a value into a double number, though, you need to put an l right before the f or e character.  The l character is short for long float, which is an older way of telling C that you want a double value.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 3.8.}{  Modify the first sample program from this lesson to read floating-point numbers, rather than integers.  To do this, all you have to do is change the variable i from an int to a float variable, and change the conversion specifiers in the scanf and printf calls.  Run the program, giving it the numbers shown in the table, above.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344418}The If Statement{\*\bkmkend _Toc496344418}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Computer programs can make decisions.  You have already written some programs that use this capability in the form of loops that keep going until some condition is satisfied.  In some cases, though, we may only need to do something once, or we may not need to do it at all.  That's where the if statement comes in.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {if (<condition>)\par }\pard \s23\qj\fi360\widctlpar\adjustright {   <statement>;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The if statement evaluates the same kind of condition that you have already used in the do and while statements.  If the condition is true, the next statement is executed.  If not, the statement is skipped.  In a way, the if statement is like a while loop that doesn't loop.\par As with the while loop and for loop, the if statement only executes one statement.   If more than one statement must be executed, you use the \{ and \} characters to group more that one statement into a compound statement, just as you do with the for loop, do loop and while loop.\par To see how all of this works, let's try a simple example.  In this example, we will use the if statement, along with the % operator you met earlier in the lesson, to write a program that can count change.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* count change */\par \par #include <stdio.h>\par \par int change;\par \par void main(void)\par \par \{\par /* get the amount */\par printf("How many cents? ");\par }\pard \s23\qj\fi360\widctlpar\adjustright {scanf(" %d", &change);\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {/* write the header */\par printf(\par }\pard \s23\qj\fi360\widctlpar\adjustright {   "Your change consists of:\\n");\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {/* count out the dollars */\par if (change >= 100) \{\par    printf("%d dollars\\n",\par       change / 100);\par    change %= 100;\par }\pard \s23\qj\fi360\widctlpar\adjustright {   \}\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {/* count out the quarters */\par if (change >= 25) \{\par    printf("%d quarters\\n",\par       change / 25);\par    change %= 25;\par }\pard \s23\qj\fi360\widctlpar\adjustright {   \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {/* count out the dimes */\par if (change >= 10) \{\par    printf("%d dimes\\n",\par       change / 10);\par    change %= 10;\par }\pard \s23\qj\fi360\widctlpar\adjustright {   \}\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {/* count out the nickles */\par if (change >= 5) \{\par    printf("%d nickles\\n",\par       change / 5);\par    change %= 5;\par }\pard \s23\qj\fi360\widctlpar\adjustright {   \}\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {/* count out the pennies */\par if (change != 0)\par    printf("%d pennies\\n",\par       change);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par In this program, each if statement is used to see if the number of pennies left is large enough to give the customer at least one coin of a given size.  For example, the first if statement checks to see how many dollars are in the change.  Since we need to do two things \-\endash  write the number of dollars and adjust the amount of change \-\endash  the statements are enclosed in \{ and \} characters.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {if (change >= 100) \{\par    printf("%d dollars\\n",\par       change / 100);\par    change %= 100;\par }\pard \s23\qj\fi360\widctlpar\adjustright {   \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par If there are more than 100 pennies due, then we can start by giving out some number of dollars.  Since the / operator automatically truncates the result, it gives us the dollar amount with no hassles.  (The automatic rounding can be useful, as well as a pain, depending on the application.)  For example, if the number of pennies due in change is 536, then change will certainly be greater than or equal to 100.  In that case, the program writes 536 / 100, which is 5, as the number of dollars.  The % operation then strips off the dollar amount: 536 % 100 is 36.  The program goes on from there.\par It would be a good idea to run this program, using the debugger to step through it line by line until you are sure you know how the if statement works.  Be sure and use the variables window to track the value of the variable change.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344419}The Else Clause{\*\bkmkend _Toc496344419}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {There are many times when you need to do one thing or another, depending on some condition.  In that case, you could use two different if statements, one after the other, but you can also use an else statement.  As a simple example, let's say you are printing the number of tries it took to guess the number in our number guessing game.  It's sort of tacky to print out "1 tries," or worse still, "2 try."  With an if-then-else statement, you can print something a bit prettier:\par \par }\pard\plain \s23\qj\keepn\widctlpar\adjustright \f6\fs20\cgrid {if (tries == 1)\par    printf("You got it in 1 try!\\n");\par else\par    printf("It took you %d tries.\\n",\par }\pard \s23\qj\widctlpar\adjustright {      tries);\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }{\b Problem 3.9. }{ Modify the program from lesson 2 that showed payments for purchasing a car.  Allow the user of the program to enter the cost of the car, the interest rate and the number of payments as real numbers.  Use an if statement to see if the payment is larger than the amount of interest that will accumulate in one month.  If not, print an appropriate error message.  If the payment is large enough, execute the program as it worked before.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344420}Those Darn Semicolons{\*\bkmkend _Toc496344420}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {There is one very important point to keep in mind.  The semicolon in C is a statement terminator, not a statement separator.  In plain English, this means that the semicolon is used after every statement in a C program, even if the statement comes right before the else clause of an if statement.  "Of course," you say, "how else would it work?"  If you already know Pascal, Ada, Modula, or virtually any other language that uses semicolons, you know that these languages won't accept a semicolon before an else!  It doesn't matter a whole lot which way the semicolon works, since both methods are in common use in various programming languages and both work just fine, but you should know that there is a difference.\par Just for the record, the \} character marks the end of a compound statement.  What that means is that a semicolon is not needed after the \} character.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344421}Nesting If Statements{\*\bkmkend _Toc496344421}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {You can put any statement you want in an if or else clause, including another if statement.  This can be useful when you have several possibilities that you need to choose from.  For example, let's assume that you want to print out a message like "that was your 3rd try."  You can print the number of tries, followed by "rd," but that only works for some numbers.  You would want to print\par \par }\pard \s21\qj\fi360\keepn\widctlpar\adjustright {1st\par 2nd\par 3rd\par 4th\par }\pard \s21\qj\fi360\widctlpar\adjustright {5th\par \par }\pard \s21\qj\widctlpar\adjustright {and so on.  One way to go about it is to print "that was your," followed by a series of if statements, followed by printing "try."  The if statements can be used to decide the suffix for the number of tries.  Here's a code fragment that does the job.\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {printf("That was your ");\par if (try == 1)\par    printf("1st");\par else if (try == 2)\par    printf("2nd");\par else if (try == 3)\par    printf("3rd");\par else\par    printf("%dth", try);\par }\pard \s23\qj\fi360\widctlpar\adjustright {printf(" try!\\n");\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Note the indenting structure.  It would be perfectly reasonable to indent this code fragment like this:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {printf("That was your ");\par if (try == 1)\par    printf("1st");\par else\par    if (try == 2)\par       printf("2nd");\par    else\par       if (try == 3)\par          printf("3rd");\par       else\par          printf("%dth", try);\par }\pard \s23\qj\fi360\widctlpar\adjustright {printf(" try!\\n");\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The second method shows more accurately what C does to evaluate the statement.  It starts by checking to see if try is 1.  If so, "1st" is written.  If not, it moves on to another check, and so on.  The original method, though, with "else if (<condition>)" all on one line, shows the logical flow of the program better.  It clearly shows that we are choosing one of several alternatives, while this isn't exactly clear from the second example.  The compiler doesn't care how, or even if you indent \endash   it will create the same program either way.  Indenting is for your benefit, not the compilers.  For that reason, I would recommend the first method.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 3.10.}{  In this problem, you will write a bouncing ball program.  You will move a small spot across the graphics window.  When the spot gets to the edge of the graphics window, it will bounce off.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Compared to some of the programs you have written, this is a fairly long one, so we will develop it in steps.  To make a ball bounce around in the graphics window, you will need to animate the ball.  Start out by writing a short program that moves a spot from 0,0 to 50,50.  You will start by initializing two integer variables, x and y, to 0.  In a for loop, you will then set the pen color to white (a color of 3) and draw a spot using a MoveTo-LineTo pair, as we did earlier.  Next, you increment both x and y by one, change the pen color to black (a color of 0), and draw the dot again.  Get this program to work first: it should move the dot across the screen in a diagonal line.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {One problem with this program is that the ball moves too fast.  To slow it down, put a for loop inside the for loop that moves the ball.  The new for loop should step from 1 to 1000, but doesn't need to do anything.  To do nothing, you just code an empty statement by putting a semicolon in the program, like this:\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {for (i = 1; i <= 1000; ++i) ;\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {Surprisingly, it really is important that you put the semicolon on the same line as the for statement.  The C language really doesn't care, but in ORCA/C with debug code on, the debugger is called for each separate line to update the arrow in the program's window, and that takes quite a bit of time.  If the semicolon is on the same line as the for statement, the debugger is not called.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Once the second step is complete and tested, it is time to move on to the third step.  At this point, you should change the program so it asks the user for its inputs.  The program should ask for a starting value for x and y, as well as starting values for three new variables, xSpeed, ySpeed and iter.  iter is the number of times to move the ball; you should adjust the for loop accordingly.  xSpeed and ySpeed are the distance to move the ball in the x and y direction each time through the loop.  You should change the statements that add one to x and y so xSpeed and ySpeed are added, instead.  Be sure and get the program working before you move on to the next step.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {At this point, stop and run the program with x and y set to 10, xSpeed set to 3, ySpeed set to 1, and iter set to 100.  The ball will certainly move \endash  it moves right off of the graphics window!  The final step in developing the bounce program is to detect when this happens, and handle it.  We'll look at how to do this for the x direction, and you can fill in the proper code for the y direction on your own.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {   if (x < 0) \{\par       x = 0;\par       xSpeed = -xSpeed;\par       \}\par    else if (x > MAXX) \{\par       x = MAXX;\par       xSpeed = -xSpeed;\par }\pard \s23\qj\fi360\widctlpar\adjustright {      \}\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {These statements should come right after the point where you update x by adding xSpeed.  If the resulting value for x is less than zero, the you must have just moved the ball off of the left side of the graphics window.  If the ball moved off of the left side of the graphics window, then of course, xSpeed must be negative.  To bounce the ball back towards the middle of the graphics window, you need to set x to zero (putting the ball back on the screen) and reverse xSpeed (so the ball will move to the right).  The next check does essentially the same thing, checking to see if x has moved past MAXX, which we set to 316 (the right side of the graphics window).\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {This program is probably more that you could have handled at this point if you had tried to write it all at once, and it probably wasn't easy to write even in small steps.  This points out, once again, how important stepwise refinement is to the process of programming.  Using stepwise refinement, you can break an impossible task up into smaller tasks that are merely difficult.\par \par }\pard\plain \widctlpar\adjustright \f4\cgrid {\b\fs36 \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \qc\widctlpar\adjustright \f4\cgrid {\b\fs36 Lesson Three\par Solutions to Problems\par }\pard \qj\widctlpar\adjustright {\b\fs28 \par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344422}Solution to problem 3.1.{\*\bkmkend _Toc496344422}\par }\pard\plain \s21\qj\fi360\widctlpar\tx1800\adjustright \f4\fs20\cgrid {\ul input}{\tab }{\ul value read by scanf}{\par 3\tab 3\par 4+9\tab 4\par 3.14159\tab 3\par three\tab 0\par -8\tab -8\par +6 9\tab 6\par - 9\tab 0\par (RETURN)7\tab 7\par 8,536,912\tab 8\par 8536912\tab Not what you typed!  (17232)\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344423}Solution to problem 3.2.{\*\bkmkend _Toc496344423}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The first step uses do loops to pick a number between 1 and 100, rather than the % operator:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Guess a number */\par \par #include <stdio.h>\par #include <stdlib.h>\par \par int i;                               /* input value */\par int value;                           /* the number to guess */\par \par void main(void)\par \par \{\par /* Introduce the game */\par printf("In this game, you will try to\\n");\par printf("guess a number.  I need a hint to\\n");\par printf("help me pick numbers, though.\\n\\n");\par \par /* get a seed for the random number generator */\par printf("Please type a number between 1\\nand 30000: ");\par scanf(" %d", &i);\par srand(i);\par \par /* pick a number from 1 to 100 */\par do\par    do\par       value = rand();\par    while (value <= 0);\par while (value > 100);\par \par /* let the player guess the number */\par do \{\par    printf("Your guess: ");           /* get the guess */\par    scanf(" %d", &i);\par    if (i > value)                    /* check for too high */\par       printf("%d is to high.\\n", i);\par    if (i < value)                    /* check for too low */\par       printf("%d is to low.\\n", i);\par    \}\par while (i != value);                 /* if the guess was wrong then loop */\par printf("%d is correct!\\n", i);\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par In the second step, we add a do loop to let the player play three games, rather that one:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Guess a number */\par \par #include <stdio.h>\par #include <stdlib.h>\par \par int done;                            /* are we done, yet? */\par int i;                               /* input value */\par int value;                           /* the number to guess */\par \par void main(void)\par \par \{\par /* Introduce the game */\par printf("In this game, you will try to\\n");\par printf("guess a number.  I need a hint to\\n");\par printf("help me pick numbers, though.\\n\\n");\par \par /* get a seed for the random number generator */\par printf("Please type a number between 1\\nand 30000: ");\par scanf(" %d", &i);\par srand(i);\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {done = 3;\par do \{\par    /* pick a number from 1 to 100 */\par    do\par       do\par          value = rand();\par       while (value <= 0);\par    while (value > 100);\par    \par    /* let the player guess the number */\par    do \{\par       printf("Your guess: ");           /* get the guess */\par       scanf(" %d", &i);\par       if (i > value)                    /* check for too high */\par          printf("%d is to high.\\n", i);\par       if (i < value)                    /* check for too low */\par          printf("%d is to low.\\n", i);\par       \}\par    while (i != value);              /* if the guess was wrong then loop */\par    printf("%d is correct!\\n", i);\par    done -= 1;\par    \}\par while (done != 0);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Finally, we let the player decide if he wants to play again, using nested do loops to make sure the number is in the correct range:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Guess a number */\par \par #include <stdio.h>\par #include <stdlib.h>\par \par int done;                            /* are we done, yet? */\par int i;                               /* input value */\par int value;                           /* the number to guess */\par \par void main(void)\par \par \{\par /* Introduce the game */\par printf("In this game, you will try to\\n");\par printf("guess a number.  I need a hint to\\n");\par printf("help me pick numbers, though.\\n\\n");\par \par /* get a seed for the random number generator */\par printf("Please type a number between 1\\nand 30000: ");\par scanf(" %d", &i);\par srand(i);\par \par do \{\par    /* pick a number from 1 to 100 */\par    do\par       do\par          value = rand();\par       while (value <= 0);\par    while (value > 100);\par    \par    /* let the player guess the number */\par    do \{\par       printf("Your guess: ");           /* get the guess */\par       scanf(" %d", &i);\par       if (i > value)                    /* check for too high */\par          printf("%d is to high.\\n", i);\par       if (i < value)                    /* check for too low */\par          printf("%d is to low.\\n", i);\par       \}\par    while (i != value);              /* if the guess was wrong then loop */\par    printf("%d is correct!\\n", i);\par \par    do\par       do \{\par          printf("Play again?  Enter 0\\nfor no, 1 for yes:");\par          scanf(" %d", &done);\par          \}\par       while (done > 1);\par    while (done < 0);\par    \}\par while (done != 0);\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344424}Solution to problem 3.3.{\*\bkmkend _Toc496344424}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Empty timing loop */\par \par /* Note: be sure to run this program with debug turned off! */\par \par #include <stdio.h>\par \par unsigned i,j;                           /* loop variables */\par \par void main(void)\par \par \{\par printf("Start timer...\\n");\par for (i = 1; i <= 10000; ++i)\par    for (j = 1; j <= 25; ++j)\par       ;\par printf("Stop timer.\\n");\par \}\par \par \par /* Time 250,000 integer additions */\par \par /* Note: be sure to run this program with debug turned off! */\par \par #include <stdio.h>\par \par unsigned i,j;                           /* loop variables */\par int a,b,c;                              /* test values */\par \par void main(void)\par \par \{\par a = 3;\par b = 5;\par printf("Start timer...\\n");\par for (i = 1; i <= 10000; ++i)\par    for (j = 1; j <= 25; ++j)\par       c = a+b;\par printf("Stop timer.\\n");\par \}\par \par \par /* Time 250,000 floating-point additions */\par \par /* Note: be sure to run this program with debug turned off! */\par \par #include <stdio.h>\par \par unsigned i,j;                           /* loop variables */\par float a,b,c;                            /* test values */\par \par void main(void)\par \par \{\par a = 3.0;\par b = 5.0;\par printf("Start timer...\\n");\par for (i = 1; i <= 100; ++i)\par    for (j = 1; j <= 25; ++j)\par       c = a+b;\par printf("Stop timer.\\n");\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par \par Here are the results of the timing tests.  All times are in seconds.  The first column shows the operation that was performed in the loop.  The raw time column shows the number of seconds it takes to execute the program.  For real operations, the value has been multiplied by 100 to account for the smaller number of operations done.  This means the times shown are for loops of 10000 and 25, not 100 and 25.  The time per operation is the raw time minus the time for an empty loop divided by the number of times the loop executed.  The ratio shows how much longer it takes to do the real operation as compared to the integer operation.  For example, it takes 411 times longer to add the two real numbers than it takes to add the same two numbers if they are integers.\par \par }\pard \s21\qj\fi360\widctlpar\tx1800\tx3240\tx4680\adjustright {\ul operation}{\tab }{\ul raw time}{\tab }{\ul time per operation}{\tab }{\ul real to integer ratio}{\par (none)\tab 3.67\tab 0.00001468\par 3+5\tab 5.35\tab 0.00000672\par 3-5\tab 5.35\tab 0.00000672\par 3 / 5\tab 64.30\tab 0.00024252\par 3*5\tab 61.76\tab 0.00023236\par 3.0+5.0\tab 694.00\tab 0.00276132\tab 411\par 3.0-5.0\tab 695.00\tab 0.00276532\tab 412\par 3.0/5.0\tab 1102.00\tab 0.00439332\tab 18\par 3.0*5.0\tab 731.00\tab 0.00290932\tab 13\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344425}Solution to problem 3.4.{\*\bkmkend _Toc496344425}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Throw two six-sided dice twenty times */\par \par #include <stdio.h>\par #include <stdlib.h>\par \par #define SIDES 6                         /* # of sides on the dice */\par #define NUMDICE 2                       /* # of dice to throw */\par \par unsigned i,j;                           /* loop variables */\par int seed;                               /* random number seed */\par \par void main(void)\par \par \{\par printf("Random number seed = ");\par scanf(" %d", &seed);\par srand(seed);\par \par printf("\\n");\par for (i = 1; i <= 20; ++i) \{\par    for (j = 1; j <= NUMDICE; ++j)\par       printf("%4d", rand() % SIDES + 1);\par    printf("\\n");\par    \}\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344426}Solution to problem 3.5.{\*\bkmkend _Toc496344426}\par }\pard\plain \s21\qj\fi360\keepn\widctlpar\adjustright \f4\fs20\cgrid {While the program draws enough dots to completely blacken the area, the dots are drawn in random locations.  Occasionally, a dot will be drawn where one already exists.  Of course, every time this happens, you will end up with one dot that doesn't get filled in.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* Gradually fill an area of the screen with black dots */\par \par #include <quickdraw.h>\par #include <stdlib.h>\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par #define MAX 11651                       /* # of dots to fill */\par \par unsigned i;                             /* loop counter */\par unsigned x,y;                           /* coordinates of the point */\par \par void main(void)\par \par \{\par srand(5463);                            /* initialize for rand */\par SetPenMode(0);                          /* set up for graphics */\par SetSolidPenPat(0);\par SetPenSize(1,1);\par \par for (i = 1; i <= MAX; ++i) \{\par    x = rand() % 191 + 10;\par    y = rand() % 60 + 10;\par    MoveTo(x,y);\par    LineTo(x,y);\par    \}\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344427}Solution to problem 3.6.{\*\bkmkend _Toc496344427}\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* Gradually fill an area of the screen with colored dots */\par \par #include <quickdraw.h>\par #include <stdlib.h>\par \par #define MAX 11651                       /* # of dots to fill */\par \par unsigned i;                             /* loop counter */\par unsigned x,y;                           /* coordinates of the point */\par \par void main(void)\par \par \{\par srand(5463);                            /* initialize for rand */\par SetPenMode(0);                          /* set up for graphics */\par SetPenSize(1,1);\par \par for (i = 1; i <= MAX; ++i) \{\par    x = rand() % 191 + 10;\par    y = rand() % 60 + 10;\par    SetSolidPenPat(rand() % 4);\par    MoveTo(x,y);\par    LineTo(x,y);\par    \}\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344428}Solution to problem 3.7.{\*\bkmkend _Toc496344428}\par }\pard\plain \s21\qj\fi360\widctlpar\tx1800\adjustright \f4\fs20\cgrid {first set\tab 1  2  3  4\par second set\tab 1  2  3  4\par third set\tab 1  0  0  0\par fourth set\tab 1  2  3  4\par fifth set\tab 1  2  3  4\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344429}Solution to problem 3.8.{\*\bkmkend _Toc496344429}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Read a float and write      */\par /* it to the screen.           */\par \par #include <stdio.h>\par \par float i;\par \par void main (void)\par \par \{\par scanf(" %f", &i);\par printf("%f\\n", i);\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344430}Solution to problem 3.9.{\*\bkmkend _Toc496344430}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Car Payment Calculator */\par \par #include <stdio.h>\par \par float APR;                              /* annual percentage rate */\par float minPayment;                       /* minimum allowed payment */\par unsigned month;                         /* number of months */\par float payment;                          /* monthly payment */\par float principal;                        /* amount left to pay */\par \par void main (void)\par \par \{\par month = 0;                              /* no payments made, yet */\par printf("Cost of the car       ?");      /* get the cost of the car */\par scanf(" %f", &principal);\par printf("Annual percentage rate?");      /* get the interest rate */\par scanf(" %f", &APR);\par printf("Monthly payments      ?");      /* get the payment */\par scanf(" %f", &payment);\par minPayment = principal*APR/100.0/12.0;\par if (payment <= minPayment)\par    printf("Your minimum payment is %.2f\\n", minPayment);\par else\par    while (principal > 0.0) \{      /* keep going until we're out of debt */\par       ++month;                          /* it's a new month */\par       principal += principal*           /* add in this month's interest */\par          APR/100.0/12.0;\par       principal -= payment;             /* make the payment */\par                                         /* write the status */\par       printf("month = %3u   principal = %.2f\\n", month, principal);\par       \}\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344431}Solution to problem 3.10.{\*\bkmkend _Toc496344431}\par }\pard\plain \s21\qj\fi360\keepn\widctlpar\adjustright \f4\fs20\cgrid {\b step 1\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <quickdraw.h>\par \par #define MAXX 316                        /* graphics window size */\par #define MAXY 83\par \par unsigned i;                             /* loop counter */\par unsigned x,y;                           /* coordinates of the point */\par \par void main(void)\par \par \{\par SetPenMode(0);                          /* set up for graphics */\par SetPenSize(6,2);\par \par x = 0;                                  /* initialize the ball position */\par y = 0;\par \par for (i = 0; i <= 50; ++i) \{\par    SetSolidPenPat(3);                   /* animate the ball */\par    MoveTo(x,y);\par    LineTo(x,y);\par    ++x;\par    ++y;\par    SetSolidPenPat(0);\par    MoveTo(x,y);\par    LineTo(x,y);\par    \}\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b \par }\pard \s21\qj\fi360\keepn\widctlpar\adjustright {\b step 2\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <quickdraw.h>\par \par #define MAXX 316                        /* graphics window size */\par #define MAXY 83\par \par unsigned i,j;                           /* loop counters */\par unsigned x,y;                           /* coordinates of the point */\par \par void main(void)\par \par \{\par SetPenMode(0);                          /* set up for graphics */\par SetPenSize(6,2);\par \par x = 0;                                  /* initialize the ball position */\par y = 0;\par \par for (i = 0; i <= 50; ++i) \{\par    SetSolidPenPat(3);                   /* animate the ball */\par    MoveTo(x,y);\par    LineTo(x,y);\par    ++x;\par    ++y;\par    SetSolidPenPat(0);\par    MoveTo(x,y);\par    LineTo(x,y);\par    for (j = 1; j <= 1000; ++j) ;         /* pause */\par    \}\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b \par }\pard \s21\qj\fi360\keepn\widctlpar\adjustright {\b step 3\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <quickdraw.h>\par \par #define MAXX 316                        /* graphics window size */\par #define MAXY 83\par \par unsigned i,j;                           /* loop counters */\par int x,y;                                /* coordinates of the point */\par int xSpeed,ySpeed;                      /* ball's speed */\par unsigned iter;                          /* loop counter */\par \par void main(void)\par \par \{\par printf("Start x     :");                /* initialize the ball position */\par scanf(" %d", &x);\par printf("Start y     :");\par scanf(" %d", &y);\par printf("X speed     :");                /* initialize the ball speed */\par scanf(" %d", &xSpeed);\par printf("Y speed     :");\par scanf(" %d", &ySpeed);\par printf("iterations  :");                /* initialize the loop counter */\par }\pard \s23\qj\fi360\widctlpar\adjustright {scanf(" %d", &iter);\par \par SetPenMode(0);                          /* set up for graphics */\par SetPenSize(6,2);\par \par x = 0;                                  /* initialize the ball position */\par y = 0;\par \par for (i = 0; i <= iter; ++i) \{\par    SetSolidPenPat(3);                   /* animate the ball */\par    MoveTo(x,y);\par    LineTo(x,y);\par    x += xSpeed;\par    y += ySpeed;\par    SetSolidPenPat(0);\par    MoveTo(x,y);\par    LineTo(x,y);\par    for (j = 1; j <= 1000; ++j) ;         /* pause */\par    \}\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b \par }\pard \s21\qj\fi360\keepn\widctlpar\adjustright {\b step 4\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <quickdraw.h>\par \par #define MAXX 316                        /* graphics window size */\par #define MAXY 83\par \par unsigned i,j;                           /* loop counters */\par int x,y;                                /* coordinates of the point */\par int xSpeed,ySpeed;                      /* ball's speed */\par }\pard \s23\qj\fi360\widctlpar\adjustright {unsigned iter;                          /* loop counter */\par \par void main(void)\par \par \{\par printf("Start x     :");                /* initialize the ball position */\par scanf(" %d", &x);\par printf("Start y     :");\par scanf(" %d", &y);\par printf("X speed     :");                /* initialize the ball speed */\par scanf(" %d", &xSpeed);\par printf("Y speed     :");\par scanf(" %d", &ySpeed);\par printf("iterations  :");                /* initialize the loop counter */\par scanf(" %d", &iter);\par \par SetPenMode(0);                          /* set up for graphics */\par SetPenSize(6,2);\par \par x = 0;                                  /* initialize the ball position */\par y = 0;\par \par for (i = 0; i <= iter; ++i) \{\par    SetSolidPenPat(3);                   /* animate the ball */\par    MoveTo(x,y);\par    LineTo(x,y);\par    x += xSpeed;\par    y += ySpeed;\par    if (x < 0) \{\par       x = 0;\par       xSpeed = -xSpeed;\par       \}\par    else if (x > MAXX) \{\par       x = MAXX;\par       xSpeed = -xSpeed;\par       \}\par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {   if (y < 0) \{\par       y = 0;\par       ySpeed = -ySpeed;\par       \}\par }\pard \s23\qj\fi360\widctlpar\adjustright {   else if (y > MAXY) \{\par       y = MAXY;\par       ySpeed = -ySpeed;\par       \}\par    SetSolidPenPat(0);\par    MoveTo(x,y);\par    LineTo(x,y);\par    for (j = 1; j <= 1000; ++j) ;         /* pause */\par    \}\par \}\par \par }\pard\plain \widctlpar\adjustright \f4\cgrid {\sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s1\qc\nowidctlpar\outlinelevel0\adjustright \b\f4\fs36\cgrid {{\*\bkmkstart _Toc496344432}Lesson Four{\*\bkmkend _Toc496344432}\par {\*\bkmkstart _Toc496344433}Functions{\*\bkmkend _Toc496344433}\par }\pard\plain \qj\widctlpar\adjustright \f4\cgrid {\b\fs28 \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344434}Subroutines Avoid Repetition{\*\bkmkend _Toc496344434}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {In the first few lessons of this course, all of the programs we are writing are fairly short.  Many useful programs are short, but as you start to make your programs more sophisticated, the programs will get longer and longer.  A simple game on the Apple IIGS, for example, is generally 1,000 to 3,000 lines long; most of the programs we have written so far are 20 to 60 lines long.  As the size of your programs increase, you will need some new concepts and tools to write the programs.  One of the most important of these is the subroutine.\par For our first look at subroutines, we will start with a program that draws three rectangles on the graphics screen, filling each with a different color.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Draw three rectangles */\par \par #include <quickdraw.h>\par \par unsigned i;  /* loop variable */\par \par void main(void)\par \par \{\par /* set up for graphics */\par SetPenMode(0);\par SetSolidPenPat(0);\par SetPenSize(3,1);\par \par /* draw a black rectangle */\par for (i = 10; i <= 60; ++i) \{\par    MoveTo(10,i);\par    LineTo(250,i);\par    \}\par \par /* draw a green rectangle */\par SetSolidPenPat(1);\par for (i = 31; i <= 49; ++i) \{\par    MoveTo(220,i);\par    LineTo(270,i);\par    \}\par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {/* outline it in black */\par SetSolidPenPat(0);\par MoveTo(220,30);\par }\pard \s23\qj\fi360\widctlpar\adjustright {LineTo(220,50);\par LineTo(270,50);\par LineTo(270,30);\par LineTo(220,30);\par \par /* draw a purple rectangle */\par SetSolidPenPat(2);\par for (i = 41; i <= 79; ++i) \{\par    MoveTo(50,i);\par    LineTo(300,i);\par    \}\par /* outline it in black */\par SetSolidPenPat(0);\par MoveTo(50,40);\par LineTo(50,80);\par LineTo(300,80);\par LineTo(300,40);\par LineTo(50,40);\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par If you look at this program closely, you will see that there is very little difference between the parts that draw the green and purple rectangles.  In fact, if we put the coordinates of the rectangles in variables called left, right, top and bottom, and put the color in a variable called color, we could use exactly the same lines of code to draw the green and purple rectangles.  The code would look like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* draw a rectangle */\par SetSolidPenPat(color);\par for (i = top+1; i <= bottom-1;\par    ++i) \{\par    MoveTo(left,i);\par    LineTo(right,i);\par    \}\par /* outline it in black */\par SetSolidPenPat(0);\par MoveTo(left,top);\par LineTo(left,bottom);\par LineTo(right,bottom);\par LineTo(right,top);\par LineTo(left,top);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\lang1024 {\shp{\*\shpinst\shpleft0\shptop0\shpright9360\shpbottom10944\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz21\shplid1153{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 4194304}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 4.1\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Draw three rectangles */\par \par #include <quickdraw.h>\par \par void Rectangle (int left, int right, int top, int bottom, int color)\par \par /* This subroutine draws a colored rectangle and outlines it    */\par /* in black.                                                    */\par /*                                                              */\par /* Parameters:                                                  */\par /*    left,right,top,bottom - edges of the rectangle            */\par /*    color - interior color of the rectangle                   */\par \par \{\par unsigned i;                     /* loop variable */\par \par SetSolidPenPat(color);          /* draw a rectangle */\par for (i = top+1; i <= bottom-1; ++i) \{\par    MoveTo(left,i);\par    LineTo(right,i);\par    \}\par SetSolidPenPat(0);              /* outline it in black */\par MoveTo(left,top);\par LineTo(left,bottom);\par LineTo(right,bottom);\par LineTo(right,top);\par LineTo(left,top);\par \}\par \par void main(void)\par \par \{\par SetPenMode(0);                  /* set up for graphics */\par SetSolidPenPat(0);\par SetPenSize(3,1);\par \par Rectangle(10,250,10,60,0);      /* draw a black rectangle */\par Rectangle(220,270,30,50,1);     /* draw a green rectangle */\par Rectangle(50,300,40,80,2);      /* draw a purple rectangle */\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8213\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 4.1\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Draw three rectangles */\par \par #include <quickdraw.h>\par \par void Rectangle (int left, int right, int top, int bottom, int color)\par \par /* This subroutine draws a colored rectangle and outlines it    */\par /* in black.                                                    */\par /*                                                              */\par /* Parameters:                                                  */\par /*    left,right,top,bottom - edges of the rectangle            */\par /*    color - interior color of the rectangle                   */\par \par \{\par unsigned i;                     /* loop variable */\par \par SetSolidPenPat(color);          /* draw a rectangle */\par for (i = top+1; i <= bottom-1; ++i) \{\par    MoveTo(left,i);\par    LineTo(right,i);\par    \}\par SetSolidPenPat(0);              /* outline it in black */\par MoveTo(left,top);\par LineTo(left,bottom);\par LineTo(right,bottom);\par LineTo(right,top);\par LineTo(left,top);\par \}\par \par void main(void)\par \par \{\par SetPenMode(0);                  /* set up for graphics */\par SetSolidPenPat(0);\par SetPenSize(3,1);\par \par Rectangle(10,250,10,60,0);      /* draw a black rectangle */\par Rectangle(220,270,30,50,1);     /* draw a green rectangle */\par Rectangle(50,300,40,80,2);      /* draw a purple rectangle */\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx0\dpy0\dpxsize9360\dpysize10944\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{\par While we don't really need to redraw the outline of the square for the black square, the same code could even be used to draw the black square.  A few extra lines get executed when the outline is drawn (the outline is black, and so is the color that is filled in), but the same code could be used.  One of the of the most common uses for a subroutine is just this situation.  When your program needs to do essentially the same thing in several different places, you can write a subroutine to do the thing, and call it from more than one place.  Let's try this in a program, and then look at what is happening in detail.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344435}The Structure of a Function{\*\bkmkend _Toc496344435}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {In one sense, the overall structure of the function Rectangle should look pretty familiar to you.  After all, all of your programs have had at least one function, called main.  There are a couple of new things here, though, so we'll take a very close look at this program.\par Like the main function that you are familiar with, the Rectangle function doesn't return a value, so we start the definition with void.  The name that comes next can be anything you like, so long as it isn't a reserved word, and so long as you haven't used the name in your program for something else.  I like to capitalize the name of my functions like a title, but like all conventions, you can do anything you like.  The one exception, of course, is main.  Since C is a case sensitive language, I can't spell it as Main.  Of course, whatever convention you use, you should be consistent.\par The main function's parameter list is pretty simple.  Since we don't pass any parameters to main, we use void between the parenthesis for the main function, and you would do that with your own subroutines if they did not have any parameters.  The parameter list for Rectangle, though, is more complicated than the one in the main function, so we will need to spend a little more time talking about it.  In the Rectangle function, the parameter list looks like this:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {int left, int right, int top,\par }\pard \s23\qj\fi360\widctlpar\adjustright {int bottom, int color\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {It is no accident that this looks suspiciously like a series of variable declarations.  In fact, if you separate the variables with semicolons instead of commas, and moved the parameters to the top of the program, the compiler would be happy to take this parameter list as a series of variable declarations.  What the parameter list actually does, in fact, is to define these variables within the function.  Any statement within the function can use these variables.  You can change them using an assignment statement, or use them in an expression, as we do in our program.  A very important point to keep in mind, though, is that the variables actually go away after you leave the subroutine.  We will see this more clearly in a moment with the debugger.\par }\pard \s21\qj\fi360\widctlpar\adjustright {There is one major difference between the way that we define variables and the way that we write a parameter list.  When you define variables, you know that you can define several at the same time with a single type, like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {int left,right,top,bottom,color;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {In a parameter list, the comma is used to separate the parameters themselves, so you have to specify the type again for each of the parameters.\par }\pard \s21\qj\fi360\widctlpar\adjustright {The parameter list forms a sort of model that tells us how to call the function, as you can see by comparing the function declaration with a call from our sample program.\par \par }\pard\plain \fi360\widctlpar\adjustright \f4\cgrid {\f6\fs20 void Rectangle (int left, \par    int right, int top, int bottom,\par    int color)\par }\pard \qj\fi360\widctlpar\adjustright {\f6\fs20 \par }\pard \fi360\widctlpar\adjustright {\f6\fs20      Rectangle (10,    \par    250,       10,      60,      \par    0);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {On the top lines, you see the function declaration.  The following lines show a call to the function, with spaces inserted to line up the matching components.  C knows you are calling the function from the name itself.  Since the compiler has already seen the definition of the function, it knows that Rectangle is a function, and that it needs five integer parameters.  The compiler expects the values you pass as parameters to appear after the function name, enclosed in parenthesis, and separated by commas.  If you forget one of the these parameters, put in too many, or use a parameter that isn't an integer, the compiler will complain.\par }\pard \s21\qj\fi360\widctlpar\adjustright {When the function is called, the compiler starts by assigning the values you put in the parameter list to the variables you defined in the parameter list.  In effect, for the call we are using as an example, the compiler does the following five assignments before the first statement of the function is executed:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* in effect, what the */\par /* compiler does       */\par left = 10;\par right = 250;\par top = 10;\par bottom = 60;\par }\pard \s23\qj\fi360\widctlpar\adjustright {color = 0;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {When the function starts, then, the variables from the parameter list already have an initial value.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344436}Local Variables{\*\bkmkend _Toc496344436}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Right at the top of the Rectangle function, just after the \{ character that marks the start of the body of the function, you see the line\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {unsigned i;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {In a sense, there is nothing new about this line; you have used lines just like it to define variables in all of your programs.  The difference between this line and the variables you have defined in the past rests entirely with where the line is found.  Instead of defining the variable before the start of the Rectangle function, this one is defined inside of the function itself.  Variables defined inside of a function are called local variables.\par }\pard \s21\qj\fi360\widctlpar\adjustright {There are several differences between local variables and global variables.  Local variables are created when the function starts to execute, and the space that has been allocated for them goes away after the program leaves the function.  Exactly how this is done is something we will cover later, but there is an important implication you should understand from the very beginning: if you assign a value to a local variable, the value will not necessarily be the same when you call the function again.  (Later, you will learn how to get around this limitation.)\par You might wonder why there are two different kinds of variables at all.  The most important reason is that local variables give you more power in organizing your program into individual units.  The local variable i in the Rectangle function belongs solely to that function; no other function sees it, no other function can change it, and other functions can have their own local variables, also called i, without interfering with Rectangle.  A global variable, on the other hand, is available to all of the functions in your program.  Global variables give you one way to share information between the various functions in the program.\par In general, you should use local variables whenever you can, and global variables only when you have to.  Global variables should only be used when a particular piece of information needs to be shared among several different functions.  As your programming skills develop, the reason for this rule of thumb will become more and more clear.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344437}How Functions are Executed{\*\bkmkend _Toc496344437}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {There are some subtle points about how functions are executed, how variables are created, and how they go away that I have mentioned, but that may not have sunk in so far.  To drive these points home, we will fire up the debugger.\par If you haven't already tried the program, go ahead and type it in now, and run it to see what it does.\par The first thing we will do with the debugger is to look at what happens when a function is called.  Pull down the debug menu and select the Step command to start the program.  By now, you are probably familiar with the arrow appearing on the first statement in the program.  Step up to the point where the arrow is on the first call to the Rectangle function (Figure 4.1).  The next statement executed is the call to the function itself.  When you step, the arrow jumps to the first line of the subroutine (Figure 4.2).  As you continue to step, the statements in the function are executed just as they would be if they were in main.  After the last statement is executed, you return to the first statement after the function call in the function main.\par The point of all of this is that the function call transfers control to the statements in the function.  The function acts just like main, executing each statement in turn.  When all of the statements in the function have been executed, the program continues on with the first statement after the function.\par You can define variables in a function by declaring them as parameters or by declaring them right after the \{ character that marks the beginning of the function body.  These variables are created when the function is called, and vanish when the function has finished executing.  To see this, stop the program, or use Trace or Go to finish it up.  Bring up the variables window, and move it over the shell window (which we aren't using at the moment).  Step to the first line of the program.  Since there are no global variables in main, you will find that you cannot look at a variable.  You might try looking at the variable left, from the Rectangle function's parameter list, or i, defined with the function, to see this.  The debugger will tell you that no such variable exists.\par Continue stepping until you get to the first line of the function Rectangle.  Watch the variables window as you enter the function: the name at the top of the variables window will change from main to Rectangle.  At this point, you can look at any of the variables from the parameter list, or you can look at the loop variable, i.  It is sometimes entertaining to look at i before the loop has been executed.  Since i has not been assigned a value, the number you see is just whatever value the memory location the compiler is using for i happened to contain before the function was called.  It brings home the point that a variable should never be used before you assign a value to it.\par While you are looking at the variables from any function, you cannot look at the global variables, or at the variables in another function.  Technically speaking, these variables are located in separate areas, called stack frames, and the debugger only lets you look at one stack frame at a time.  To look at the global variables, or at the variables in another function, you click on the up arrow to move "up" one stack frame.  To look at the variables from the function again, you click on the down arrow to move "down" one stack frame.\par If you have been using the arrows to switch between the stack frames, move back to the Rectangle function, so you are looking at the variables from that function.  Continue stepping until you leave the function.  As soon as you do, the variables window shifts back to main.  The arrow can no longer be used to look at the variables from the function Rectangle.  In fact, the variables literally do not exist anymore; the memory the compiler was using for the variables while the function was executing can be used for other purposes.  When you step into the function again, new memory is allocated for the variables.  By chance, it might happen to be the same memory that was used on the last call, but that isn't something you can count on.  One side effect of this is that the value of a variable does not usually survive between function calls.  For example, the value of the variable i may or may not be the same as it was at the end of the last call; certainly, you should not write a program that depends on the value being the same.  Later, we will learn how to write programs when you need to keep a value between calls.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344438}Comments and Function Names{\*\bkmkend _Toc496344438}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {A program with one or two functions isn't likely to be too confusing, but as our programs use more and more functions, there are some conventions that will help make the programs easier to read.  One convention I use in virtually every programming language has to do with the way I choose names.  If you look at the sample program, you will see that all variable names start with a lowercase letter, while the name of the function starts with a capitol letter.  This helps remind me about the kind of identifier I am looking at when I read a program.\par By far the most important convention, though, is how the function is commented.  Right after the function declaration, and before the body of the function, I always put in a block comment.  This block of comments tells what the function does.  I use a very rigid format with up to four sections to comment a function.  These sections are:\par \par }\pard\plain \qj\fi360\widctlpar\adjustright \f4\cgrid {\sect }\sectd \sbknone\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par 1.\tab A description of the function, telling what the function does.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* This subroutine draws a colored rectangle and outlines it    */\par /* in black.                                                    */\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par 2.\tab A parameter declaration section that describes the meaning of each parameter that appears in the function declaration.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Parameters:                                                  */\par /*    left,right,top,bottom - edges of the rectangle            */\par /*    color - interior color of the rectangle                   */\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par 3.  A variables section that lists any global variables used by the function.  Our program did not use any global variables, but the sample below shows how I would define one.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Variables:                                                   */\par /*    x,y - the current location of the ball                    */\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par 4.\tab A notes section that gives any pertinent information about how the subroutine is implemented, and describes any unusual properties of the subroutine.  Our function did not need a notes section, but the sample below shows what one looks like.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Notes:                                                       */\par /*    1. For a description of the insertion sort, see           */\par /*       "Algorithms + Data Structures = Programs," p. 85.      */\par \par }\pard\plain \qj\fi360\widctlpar\adjustright \f4\cgrid {\par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {As with the other formatting and commenting conventions mentioned in this course, there are many correct ways to comment a function that are different from the ones I have shown you.  The important point isn't which one you use; the important point is to find one you like that supplies the same information and use it consistently.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344439}Functions Let You Create New Commands{\*\bkmkend _Toc496344439}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {We have seen that a subroutine can be used to take a series of similar, repetitious commands and place them in a single subroutine, making our program shorter and easier to understand.  Subroutines can also be used to create new commands, which helps organize the program, making it easier to read.  The Rectangle subroutine we have already created is one example.  Once you know what the Rectangle function does, it is a lot easier to read the lines\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {Rectangle(10,250,10,60,0);\par Rectangle(220,270,30,50,1);\par }\pard \s23\qj\fi360\widctlpar\adjustright {Rectangle(50,300,40,90,2);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {than it was to read the original program.  The idea of using subroutines to neatly package our program is a very powerful one.  It takes some getting used to, but once mastered, the technique will help you write programs faster and find errors in programs easier.\par }\pard \s21\qj\fi360\widctlpar\adjustright {There is another advantage, too.  Most people tend to write a few general types of programs.  For example, an engineer might write several programs to deal with complicated matrix manipulation, but never deal with graphics to any great degree.  Another person might use his computer to write adventure games.  Any time you start writing programs that fall into broad groups like this, you will find that there are sections of your program that get repeated over and over again.  By packaging these ideas into subroutines, you can quickly move the proper sections of code from one program to another.\par As an example, let's look at a small section of code that seems to appear at the beginning of nearly all of our graphics programs.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {SetPenMode(0);\par SetSolidPenPat(0);\par }\pard \s23\qj\fi360\widctlpar\adjustright {SetPenSize(3,1);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {We can package these three lines into a function called InitGraphics, like this:\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {\sect }\sectd \sbknone\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {\par void InitGraphics(void)\par \par /* Standard graphics initialization.                            */\par \par \{\par SetPenMode(0);               /* pen mode = copy */\par SetSolidPenPat(0);           /* pen color = black */\par SetPenSize(3,1);             /* use a square pen */\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {With this new function, our program becomes even easier to read:\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {void main(void)\par \par \{\par InitGraphics;                   /* set up the graphics window */\par Rectangle(10,250,10,60,0);      /* draw a black rectangle */\par Rectangle(220,270,30,50,1);     /* draw a green rectangle */\par Rectangle(50,300,40,80,2);      /* draw a purple rectangle */\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {It may not be obvious yet, but there is still one more advantage to packaging even these three simple commands into a function.  At some point, you may decide that you want to set up the graphics screen a bit differently.  For example, you will eventually learn to resize the graphics window, or quickly color the entire window with a background color.  With the graphics initialization in a neat little package, it will be easy to redo the package and quickly update all of your programs.  You will also learn faster ways to color in a rectangle.  If all of your programs use the Rectangle function, you can easily update the function, quickly bringing all of your programs up to date.  If the code to draw rectangles is scattered throughout your programs, though, it would be a daunting task to change them all, simply because it would be hard to find all of the places that need to be changed.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 4.1. }{ One use of the Rectangle function is to draw game boards.  For example, a board for a Reversi game would consist of eight rows and eight columns of green squares with black outlines.  A chess or checker board can be drawn as eight rows and eight columns of alternating black and white squares.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Use the Rectangle function to draw a checker board in the graphics window.  Make each square 20 pixels wide and 8 pixels high, with the top left square at 30,12.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Hint: Use one for loop nested within another to loop over the rows and columns, like this:\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {for (row = 1; row <= 8; ++row)\par    for (column = 1; column <= 8;\par       ++column)\par       <draw a square>\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {This way, you can locate the top of each square as (row-1)*8+12.  The bottom of each square will be at row*8+12.  The same idea can be used to find the left and right edge of each square.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344440}More About Debugging Functions{\*\bkmkend _Toc496344440}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {By now, you have probably become good friends with the source-level debugger.  By stepping through a program, you can quickly see why a program does not work, or how a program does what it does.  You may have also noticed that single stepping through a long program can get very tedious.\par There are two debugger features that are designed specifically to help debug programs that use lots of functions.  The first is called "Go to Next Return."  Like the other debug commands, it is found in the Debug menu.  To see how it works, start by single stepping through our example program until you are inside of the Rectangle function.  In a real debugging session, you might step carefully through the first few lines of a subroutine, tracking some action.  Having learned what you need to know, you now want to continue stepping through the main program.  Rather than single stepping through the remainder of the subroutine, you can choose the Go to Next Return command.  The program is executed at full speed until you return from the subroutine, after which you are returned to single step mode.\par Once you are back in the main program, you may find many more calls to the same function.  In our sample, for example, there are three calls to the Rectangle function.  Having satisfied yourself that the function works, there is no need to step through it for the next two calls.  The Step Through command can be used in situations like this.  The Step Through command executes the entire function at full speed, returning you to single step mode after you get back to the main program.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344441}Functions Can Return a Value{\*\bkmkend _Toc496344441}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {In the last lesson, we used a pseudo-random number generator in several programs to create simulations.  One common theme in these simulations was to restrict the range of the random number.  For example, in our number guessing game, we selected numbers from 1 to 100.  To roll dice, on the other hand, we used the same idea to select a random number from 1 to 6.  With what we have learned about functions, it would seem that this would be an ideal candidate for packaging.  There is a problem, though.  The whole point of the random number code is to produce a number, so we need a way to get a value back from the function.  To accomplish this, we need to do two things: declare a return type for the function, and return a value from the function.  The program in listing 4.2 demonstrates this idea by packaging our random number generator.\par There are really only two differences in the way you write a function that returns a value, and a function that returns void.  The first shows up in the function declaration, which starts with the type unsigned, rather than the type void that you are used to.  This type tells the compiler what it is that the function returns.  You could tell the compiler that the function returns an int, a float, a double, a long int, or any other type you choose.\par At some point, you need to specify what value the function should return.  This is the second difference between a function that returns a value and a function that returns void.  So far, all of our functions have exited at the bottom, after all of the statements in the function have been executed.  To return a value from a function, though, you use the return statement.  The return statement is followed by an expression that calculates the value you want to return.  In our function, this is fairly complicated, but the value you return could simply be a variable, or even a constant.\par You can put as many return statements in your function as you like, but you should be careful to create your function so that it will always exit via a return statement.  If you mess up, the function will still return after it executes the last statement in the function, but the value that is returned is completely unpredictable.\par }{\lang1024 {\shp{\*\shpinst\shpleft0\shptop-710\shpright9360\shpbottom10090\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz22\shplid1154{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 4128768}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 4.2\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* This program rolls two dice 20 times.                           */\par \par #include <stdio.h>\par #include <stdlib.h>\par \par #define SIDES 6                 /* sides on a die */\par #define ROLLS 20                /* times to roll */\par #define NUMDICE 2               /* number of dice to roll */\par \par \par unsigned RandomValue (unsigned max)\par \par /* Return a pseudo-random number in the range 1..max.              */\par /*                                                                 */\par /* Parameters:                                                     */\par /*    max - largest number to return                               */\par /*    color - interior color of the rectangle                      */\par \par \{\par return rand() % max + 1;\par \}\par \par \par void main(void)\par \par /* main program                                                    */\par \par \{\par unsigned i,j;                  /* loop variables */\par unsigned sum;                  /* number of spots showing */\par \par srand(1234);                /* initialize the random number generator */\par for (i = 1; i <= ROLLS; ++i) \{\par    sum = 0;\par    for (j = 1; j <= NUMDICE; ++j)\par       sum += RandomValue(SIDES);\par    printf("%d\\n", sum);\par    \}\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8214\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 4.2\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* This program rolls two dice 20 times.                           */\par \par #include <stdio.h>\par #include <stdlib.h>\par \par #define SIDES 6                 /* sides on a die */\par #define ROLLS 20                /* times to roll */\par #define NUMDICE 2               /* number of dice to roll */\par \par \par unsigned RandomValue (unsigned max)\par \par /* Return a pseudo-random number in the range 1..max.              */\par /*                                                                 */\par /* Parameters:                                                     */\par /*    max - largest number to return                               */\par /*    color - interior color of the rectangle                      */\par \par \{\par return rand() % max + 1;\par \}\par \par \par void main(void)\par \par /* main program                                                    */\par \par \{\par unsigned i,j;                  /* loop variables */\par unsigned sum;                  /* number of spots showing */\par \par srand(1234);                /* initialize the random number generator */\par for (i = 1; i <= ROLLS; ++i) \{\par    sum = 0;\par    for (j = 1; j <= NUMDICE; ++j)\par       sum += RandomValue(SIDES);\par    printf("%d\\n", sum);\par    \}\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx0\dpy-710\dpxsize9360\dpysize10800\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{You can use a function anywhere you could use a value within the C language.  In our program, we use the function in the statement\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {sum += RandomValue(sides);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {When the program gets to this statement, it calls the function.  The function calculates a value, and returns it.  The value is added to sum, just as the number 4 would be in the statement\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {sum += 4;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 4.2.}{  You can use a function anywhere you can use a value in C.  In particular, you can use a function to set the value of a parameter for another function call.\par \tab Use this idea to create a program that will draw a random number of rectangles, not to exceed 30, in the graphics window.  The rectangles should have a left and right value between 1 and 316, and a top and bottom value between 1 and 83.  Use an if statement and a temporary variable to make sure the left side is less than or equal to the right side, and that the top is less than or equal to the bottom, like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {if (left > right) \{\par    temp = left;\par    left = right;\par    right = temp;\par    \}\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {If you are not certain why these statements will insure that left is less that right, try tracing the code by hand or with the debugger for several values of left and right.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Finally, the color of the rectangle should be chosen at random, and should be in the range 0 to 3.  You can get a value from 0 to 3 from the RandomValue function like this:\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {RandomValue(4)-1\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {The call to RandomValue to get the color of the rectangle should appear in the parameter list of the call to Rectangle.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344442}More about void and return{\*\bkmkend _Toc496344442}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The return statement you just used in the Rectangle function is obviously necessary when you need to return a value from a function, but it can also be used in functions that return void.  In fact, now is a good time to stop and think about what it means to "return void" from a function.\par In many programming languages, there are two completely separate kinds of subroutines.  In Pascal, for example, they are called functions and procedures; in FORTRRAN, they are subroutines and functions.  C only has one kind of subroutine, the function.  Conceptually, every C subroutine returns something.  Pascal's procedures and FORTRAN's subroutines are the equivalent of a C function returning void; in C, then, void is used to tell the compiler that there really isn't anything to return.\par That may seem a bit strange, and in a way it is, but there are some advantages to the way functions are defined in C.  In C, you don't have to do anything with the value a function returns.  For example, the printf function you have been using actually returns an integer; this integer is the number of characters actually printed by printf.  You don't usually need to know this value, so in our programs, we don't assign the value returned by printf to anything.  If we wanted to check to see how many characters had actually been written, though, we could.  In a language like Pascal or FORTRAN, the language always checks to be sure we did something with the value returned by the function.  In those languages, if you want an output subroutine that can return the number of characters written, but you also want an output subroutine that you can use without assigning the result to a variable, you would have to have two different subroutines.  In C, we only need one.\par In early versions of C, that's the way it was left.  You could (and still can) choose to use the return statement with an expression, or without an expression.  If you return from a function by dropping out of the bottom after executing the last statement, or from a return statement with no expression after it, the value returned by the function is unpredictable.  If you return from a function by executing a return statement that is followed by an expression, the value of the expression itself is returned.\par The idea of a function returning void is actually fairly new in the C language.  There are two reasons for giving every function a type like this.  First off, the compiler is able to do a few more checks that it could do before, preventing some programming errors.  For example, if you try to assign the value returned by a void function to a variable, the compiler can flag an error.  Calling the InitGraphics function from earlier like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {i = InitGraphics;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {would generate an error, since the compiler recognizes that you defined InitGraphics as returning void (or nothing), but clearly, your are trying to assign the value returned by the function to an integer variable.\par }\pard \s21\qj\fi360\widctlpar\adjustright {A less important reason to use void, but one that is still crucial in some time-critical applications, is that ORCA/C must create some code to return something from a function.  If you define a function as returning void, ORCA/C recognizes this fact, and doesn't create the machine language instructions to return the value.  This may not be true on other compilers, and the difference in size and speed between a function returning int and a function returning void isn't enormous, but there is a difference.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344443}A First Look at Pointers{\*\bkmkend _Toc496344443}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {There are some places where we want to package some code that changes more than one value.  A good example of this is the ball bouncing program from the last problem in lesson 3.  It would be nice to package the code that updates the position of the ball into a function, and return the new position of the ball.  There is a problem, though: a function can only return one value, but we need to update both an X and Y coordinate.\par To handle this situation, we will need to learn a whole new way of getting at a value.  Up until now, all of the values we have used have been stored in variables.  To define a variable, we list the type of the variable, and then its name.  To use a variable in an expression, we type the name of the variable.  To assign a value to a variable, we use it's name on the left-hand side of an equal sign.  In all of these cases, we are being very specific about exactly which variable we want to define, use or set.\par Pointers are used for many things, but one of them is to create subroutines that can set the value of several different variables, depending on what variable we pass to the function.  The idea of a pointer is really fairly simple.  Instead of accessing a variable by name, we access it by the address.\par Let's try a simple program to see how this works.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par int i, j, *ptr;\par \par i = 4;\par ptr = &i;\par j = *ptr;\par printf("%d %d\\n", *ptr, j);\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The first line in main defines a total of three variables, i, j and ptr.  The first two, i and j, look just like the countless other int variables you have defined.  The last one, ptr, is a bit different, though.  The * character that comes right before the variable name tells us that we aren't really defining an int variable at all; instead, we are defining a }{\i pointer to int}{.  ptr doesn't hold an integer value, like i and j do.  Instead, ptr holds the address of an integer value.\par The line\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {ptr = &i;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {assigns a value to ptr.  Since ptr is a pointer to an integer, we need to give it the address of an integer value.  Remember the scanf function from the last lesson?  In scanf, we also needed the address of a variable, since scanf wanted to store something at the address.\par }\pard \s21\qj\fi360\widctlpar\adjustright {The next line assigns a value to j, which is an int variable, so we need to assign an integer value.  The pointer ptr points to an integer, though; ptr is not itself an integer.  To get at the integer ptr points to, we again use the * character right before the variable name, just like we did in the variable declaration.  In fact, as with a function declaration, a pointer declaration is also a model showing you how to use the pointer in a statement.  To access the pointer, whether you want to set it or copy it, you use the name of the variable.  To access the value the variable points to, put the * character right before the variable name.\par At this point, j is also 4, since we first set i to 4, then set ptr to point to i, then set j to whatever ptr pointed to.  The printf statement confirms this, printing the value ptr points to and the value of j.\par As the course progresses, you will learn to use pointers for more and more things, but the reason for bringing them up now is to show you how to write your own functions that, like scanf, change the value of a variable, instead of just using the value.  You see, when you pass an int value like i to a function, the compiler actually passes the value in the variable i to the function.  The function itself has no idea where it came from, and never changes the original value you passed.  By passing the address, though, in the form of a pointer, the function can change the value the pointer points to.  To see how this works, we'll redo the program from problem 3.10 that bounced a ball around the graphics window.  In this program, though, we'll encapsulate the code to move a ball into a function called MoveBall, and pass this function the position and velocity of the ball.  The function will then change these values and return.\par \par }{\b \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b \par }\pard \s21\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {\b Listing 4.3\par \par }\pard\plain \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright \f6\fs20\cgrid {/* Bounce a ball */\par \par #include <quickdraw.h>\par #include <stdio.h>\par \par #define MAXX 316                   /* size of the screen */\par #define MAXY 83\par \par \par void MoveBall(int *x, int *y, int *vx, int *vy)\par \par /* Move a ball in the graphics window.  If the ball   */\par /* hits one of the sides (defined by the constants    */\par /* MAXX and MAXY), the direction of the ball is       */\par /* changed.                                           */\par /*                                                    */\par /* Parameters:                                        */\par /*    x,y - position of the ball                      */\par /*    vx,vy - velocity of the ball                    */\par \par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {\{\par SetSolidPenPat(3);                 /* erase the ball */\par MoveTo(*x,*y);\par LineTo(*x,*y);\par *x += *vx;                         /* move in the x direction */\par if (*x < 0) \{                      /* check for off the edge */\par    *x = 0;\par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {   *vx = -*vx;\par    \}\par else if (*x > MAXX) \{\par    *x = MAXX;\par    *vx = -*vx;\par    \}\par *y += *vy;                         /* move in the y direction */\par if (*y < 0) \{                      /* check for off the edge */\par    *y = 0;\par    *vy = -*vy;\par    \}\par else if (*y > MAXY) \{\par    *y = MAXY;\par    *vy = -*vy;\par    \}\par SetSolidPenPat(0);                 /* draw the ball in the new spot */\par MoveTo(*x,*y);\par LineTo(*x,*y);\par \}\par \par \par void main(void)\par \par /* main program                                       */\par \par \{\par unsigned i,j;                      /* loop counters */\par unsigned iter;                     /* # of movements of the ball */\par int x,y;                           /* coordinates of the point */\par int xSpeed,ySpeed;                 /* speed the ball */\par \par SetPenMode(0);                     /* set up for graphics */\par SetPenSize(6,2);\par \par printf("Start x     :");           /* initialize the ball position */\par scanf(" %d", &x);\par printf("Start y     :");\par scanf(" %d", &y);\par printf("X speed     :");           /* initialize the ball speed */\par scanf(" %d", &xSpeed);\par printf("Y speed     :");\par scanf(" %d", &ySpeed);\par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {printf("iterations  :");           /* initialize the loop counter */\par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {scanf(" %d", &iter);\par \par if (x < 0)                        /* restrict the initial ball position */\par    x = 0;\par else if (x > MAXX)\par    x = MAXX;\par if (y < 0)\par    y = 0;\par else if (y > MAXY)\par    y = MAXY;\par \par for (i = 1; i <= iter; ++i) \{      /* animate the ball */\par    for (j = 1; j <= 1000; ++j) ;   /* pause for a bit */\par    MoveBall(&x,&y,&xSpeed,&ySpeed); /* move the ball */\par    \}\par \}\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {In our program, the MoveBall function is used to update the position of the ball on the screen.  We pass four values to the MoveBall function; the current x and y position of the ball, and the current velocity of the ball.  Each of these four variables can be changed by the function, so they are all declared as pointers when MoveBall is declared, and we actually pass the address of the variable, not the variable itself, when MoveBall is called.  Just as with scanf, when we need to pass the address of a variable, we put a & character right before the name of the variable.  Inside of MoveBall, each time we use one of the values, we put a * before the name of the pointer, telling the compiler that we want the value the pointer points to, not the address contained in the pointer variable itself.\par Run the program in step mode, and step up to the first line of the MoveBall function.  Bring up the variables window, and take a look at the values for x, y, vx and vy in the function.  You will see a strange value in the display.  What you are seeing is the actual address passed as a parameter, shown in a form of notation called hexadecimal.  (We'll look closer at hexadecimal numbers later.)  To see the value the pointer points to, place a ^ character after the name of the variable in the variables window.  As you step through the function, changing the values for the parameters, switch back to the main program to check the value of the corresponding variables in the program.  As you can see, the variables in the program change at the same time as the variables in the subroutine.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 4.3. }{ By using our neatly packaged subroutine, you can quickly write a program to bounce more than one ball around on the screen.  Modify the sample program to bounce 10 balls simultaneously.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Use the RandomValue function to choose the initial positions and speeds of the balls.  Move the balls 100 times.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Because you are bouncing 10 balls instead of 1, you will not need a delay loop.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344444}Some Archaic Features of C{\*\bkmkend _Toc496344444}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {In this section, we will take a first look at some ancient C.  If you were ever to write a new program using any of these techniques, and happened to do it in a Catholic school, some nun would take a swing at your knuckles with a yardstick.  Like all other proponents of structured programming, I would sit in the back and cheer her on.  Why, then, do you need to know all of this stuff?  Why, in fact, does C allow it at all?\par Let's look at the issue of why these things even exist in C first.  While C's popularity is fairly recent, the language itself has been around for a long time, and the earliest versions of C were based on a language (B, believe it or not) that is even older.  C was originally developed for computers that were very small by today's standards, too, so the original language had to be small.  As C has grown in popularity, it has also grown in size, with many new features added fairly recently.  On the other hand, there are a lot of programs laying around that are still very useful that were written with these early versions of C.  The modern C language has been extended very carefully so that almost all of these old programs, assuming they were written well, can still be compiled from a modern C compiler.  The older versions of C are collectively referred to as K&R C, taken from the authors of the first good reference manual for the C language, Kernighan and Ritchie.  The modern C language is generally referred to as ANSI C, after the name of the standard for the language, published by ANSI (the American National Standards Institute).\par In K&R C, there was no such thing as void.  In other words, all functions returned some value.  Just as with ANSI C, though, you could use a return statement with no value, or simply drop out of the bottom of the function without returning a value.  And, just as with ANSI C, you didn't have to make use of the value that was returned.  By convention, when a function didn't return anything, people defined the function as returning int.  In fact, the type of a function is optional \endash  if you leave the type off entirely, C compilers assume you want a function that returns int.\par In K&R C, you also can't specify the types of the parameters in the parameter list, or even put void in the parameter list if there are no parameters.  If there are parameters, you list the names of the parameters in the parameter list, then define the variables between the declaration of the function and the \{ character that starts the body of the function.  For example, with the statements and comments removed, the MoveBall function would look like this in K&R C:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {MoveBall(x, y, vx, vy)\par \par int *x, *y, *vx, *vy;\par \par \{\par /* statements go here */\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Functions also don't have to be defined before they are used, as long as the function returns an int.  In all of your programs that used printf, for example, you have included the header file stdio.h, which defines printf.  The printf function returns an integer, though, so the program will actually work the same way if you leave the include out.  Taking this all the way, our original program that wrote "Hello, world" to the screen looks like this:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {main()\par \par \{\par printf("Hello, world.\\n");\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Go ahead and type it in and try the program \endash  even though it is written in the older, K&R C style, ORCA/C will still compile the program, just as the old C compilers did.\par In some ways, all of this must seem a lot simpler than typing void everywhere, remembering to include the correct header files, and remembering to define functions before they are used.  There are some serious problems with K&R C, though.  Take a look at the following program, but don't type it in or run it.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {main()\par \par \{\par foo(65536L);\par \}\par \par foo(a,b)\par \par int a,b;\par \par \{\par printf("%d %d\\n", a, b);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Although someone who writes good, structured code would shudder a bit reading this program, it is actually legal C, in the sense that any C compiler will accept it and create a program from it.  On the vast majority of C compilers that, like ORCA/C, store integers in two bytes, and long values in four bytes, the program will even work, and do something almost sensible: it breaks the long integer into two int values, printing the two halves of the four-byte long integer as two two-byte integers.\par Just because it works, though, doesn't mean it is a good program.  What this program points out is that programs written with K&R style function declarations are dangerous.  The compiler can't check to make sure you are passing the correct size value to a function, or that the function returns the correct type of result.  In fact, the compiler can't even check to make sure you pass the correct }{\i number}{ of parameters!  And what happens if you make a mistake?  According to all of the C standards, from the original description by Kernighan and Ritchie to the most recent ANSI C standard, the results are undefined.  That's a polite way of saying that the compiler can do whatever it wants, including producing a program that crashes.\par There are some good reasons why a very advanced system programmer might want to make use of some of these peculiarities of C.  When they are needed, these freedoms can be used by a clever programmer to do things that literally can't be done in other programming languages.  For example, C's printf function literally can't be written in Pascal, FORTRAN, or BASIC, but it can be written in C.  On the other hand, for the vast majority of programming situations, it is comforting to have the compiler checking to make sure that we don't do stupid things, like passing the wrong number of parameters to a function.  That's why ANSI C includes void and the ability to define the number and types of parameters explicitly.  Unless you have a very, very good reason for using the freedom of K&R parameters, and know exactly what you are doing, you should always define the type of every function, declare the parameters explicitly in the parameter list, and define the function before you use it.\par That is, of course, if you value your knuckles.\par \par }\pard\plain \widctlpar\adjustright \f4\cgrid {\b\fs36 \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \qc\widctlpar\adjustright \f4\cgrid {\b\fs36 Lesson Four\par Solutions to Problems\par }\pard \qj\widctlpar\adjustright {\b\fs28 \par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344445}Solution to problem 4.1.{\*\bkmkend _Toc496344445}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Draw a checker board                                         */\par \par #include <quickdraw.h>\par \par unsigned color;                         /* color of the square */\par \par \par void InitGraphics(void)\par \par /* Standard graphics initialization.                            */\par \par \{\par SetPenMode(0);                          /* pen mode = copy */\par SetSolidPenPat(0);                      /* pen color = black */\par SetPenSize(3,1);                        /* use a square pen */\par \}\par \par \par void Rectangle (int left, int right, int top, int bottom, int color)\par \par /* This subroutine draws a colored rectangle and outlines it    */\par /* in black.                                                    */\par /*                                                              */\par /* Parameters:                                                  */\par /*    left,right,top,bottom - edges of the rectangle            */\par /*    color - interior color of the rectangle                   */\par \par \{\par unsigned i;                             /* loop variable */\par \par SetSolidPenPat(color);                  /* draw a rectangle */\par for (i = top+1; i <= bottom-1; ++i) \{\par    MoveTo(left,i);\par    LineTo(right,i);\par    \}\par SetSolidPenPat(0);                      /* outline it in black */\par MoveTo(left,top);\par LineTo(left,bottom);\par LineTo(right,bottom);\par LineTo(right,top);\par LineTo(left,top);\par \}\par \par \par void SwapColor(void)\par \par /* Changes the color between black and white.                   */\par /*                                                              */\par /* Variables:                                                   */\par /*    color - color to change                                   */\par \par \{\par if (color == 3)\par    color = 0;\par else\par    color = 3;\par \}\par \par \par void main(void)\par \par \{\par unsigned row,column;                    /* position of the square */\par \par InitGraphics;                           /* set up the graphics window */\par \par color = 3;                              /* start with a white square */\par for (row = 1; row <= 8; ++row) \{\par    for (column = 1; column <= 8; ++column) \{\par                                         /* draw one square */\par       Rectangle(column*20+10, column*20+30, row*8+4, row*8+12, color);\par       SwapColor();                      /* flip the color */\par       \}\par    SwapColor();                         /* flip the color */\par    \}\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344446}Solution to problem 4.2.{\*\bkmkend _Toc496344446}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Draw a random number of rectangles */\par \par #include <quickdraw.h>\par #include <stdlib.h>\par \par #define MAXX 316                   /* size of the screen */\par #define MAXY 83\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {unsigned RandomValue (unsigned max)\par \par /* Return a pseudo-random number in the range 1..max.              */\par /*                                                                 */\par /* Parameters:                                                     */\par /*    max - largest number to return                               */\par /*    color - interior color of the rectangle                      */\par \par \{\par return rand() % max + 1;\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par \par \par void Rectangle (int left, int right, int top, int bottom, int color)\par \par /* This subroutine draws a colored rectangle and outlines it    */\par /* in black.                                                    */\par /*                                                              */\par /* Parameters:                                                  */\par /*    left,right,top,bottom - edges of the rectangle            */\par /*    color - interior color of the rectangle                   */\par \par \{\par int i;                                  /* loop variable */\par \par SetSolidPenPat(color);                  /* draw a rectangle */\par for (i = top+1; i <= bottom-1; ++i) \{\par    MoveTo(left,i);\par    LineTo(right,i);\par    \}\par SetSolidPenPat(0);                      /* outline it in black */\par MoveTo(left,top);\par LineTo(left,bottom);\par LineTo(right,bottom);\par LineTo(right,top);\par LineTo(left,top);\par \}\par \par \par void InitGraphics(void)\par \par /* Standard graphics initialization.                            */\par \par \{\par SetPenMode(0);                          /* pen mode = copy */\par SetSolidPenPat(0);                      /* pen color = black */\par SetPenSize(3,1);                        /* use a square pen */\par \}\par \par \par void main(void)\par \par \{\par unsigned numRects;                      /* # of rectangles to draw */\par unsigned i;                             /* loop variable */\par unsigned left,right,top,bottom;         /* sides of the rectangle */\par unsigned temp;                          /* used to swap values */\par \par InitGraphics;                           /* set up the graphics window */\par srand(234);                   /* initialize the random number generator */\par \par numRects = RandomValue(30);            /* decide how many rects to draw */\par for (i = 1; i <= numRects; ++i) \{\par    left = RandomValue(MAXX);            /* get the left, right */\par    right = RandomValue(MAXX);\par    if (left > right) \{\par       temp = left;\par       left = right;\par       right = temp;\par       \}\par    top = RandomValue(MAXY);             /* get the top, bottom */\par    bottom = RandomValue(MAXY);\par    if (top > bottom) \{\par       temp = top;\par       top = bottom;\par       bottom = temp;\par       \}\par                                         /* draw the rectangle */\par    Rectangle(left,right,top,bottom,RandomValue(4)-1);\par    \}\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344447}Solution to problem 4.3.{\*\bkmkend _Toc496344447}\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* Bounce a ball */\par \par #include <quickdraw.h>\par #include <stdlib.h>\par \par #define MAXX 316                   /* size of the screen */\par #define MAXY 83\par \par \par unsigned RandomValue (unsigned max)\par \par /* Return a pseudo-random number in the range 1..max.              */\par /*                                                                 */\par /* Parameters:                                                     */\par /*    max - largest number to return                               */\par /*    color - interior color of the rectangle                      */\par \par \{\par }\pard \s23\qj\fi360\widctlpar\adjustright {return rand() % max + 1;\par \}\par \par \par void MoveBall(int *x, int *y, int *vx, int *vy)\par \par /* Move a ball in the graphics window.  If the ball   */\par /* hits one of the sides (defined by the constants    */\par /* MAXX and MAXY), the direction of the ball is       */\par /* changed.                                           */\par /*                                                    */\par /* Parameters:                                        */\par /*    x,y - position of the ball                      */\par /*    vx,vy - velocity of the ball                    */\par \par \{\par SetSolidPenPat(3);                 /* erase the ball */\par MoveTo(*x,*y);\par LineTo(*x,*y);\par *x += *vx;                         /* move in the x direction */\par if (*x < 0) \{                      /* check for off the edge */\par    *x = 0;\par    *vx = -*vx;\par    \}\par else if (*x > MAXX) \{\par    *x = MAXX;\par    *vx = -*vx;\par    \}\par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {*y += *vy;                         /* move in the y direction */\par if (*y < 0) \{                      /* check for off the edge */\par }\pard \s23\qj\fi360\widctlpar\adjustright {   *y = 0;\par    *vy = -*vy;\par    \}\par else if (*y > MAXY) \{\par    *y = MAXY;\par    *vy = -*vy;\par    \}\par SetSolidPenPat(0);                 /* draw the ball in the new spot */\par MoveTo(*x,*y);\par LineTo(*x,*y);\par \}\par \par \par void main(void)\par \par /* main program                                       */\par \par \{\par unsigned i,j;                      /* loop counters */\par unsigned iter;                     /* # of movements of the ball */\par \par int x1,x2,x3,x4,x5,x6,x7,x8,x9,x10; /* x coordinates of the ball */\par int y1,y2,y3,y4,y5,y6,y7,y8,y9,y10; /* y coordinates of the ball */\par                                    /* ball velocities */\par int vx1,vx2,vx3,vx4,vx5,vx6,vx7,vx8,vx9,vx10;\par int vy1,vy2,vy3,vy4,vy5,vy6,vy7,vy8,vy9,vy10;\par \par SetPenMode(0);                     /* set up for graphics */\par SetPenSize(6,2);\par srand(1234);                  /* initialize the random number generator */\par \par                                    /* set the initial ball positions */\par x1 = RandomValue(MAXX);   y1 = RandomValue(MAXY);\par x2 = RandomValue(MAXX);   y2 = RandomValue(MAXY);\par x3 = RandomValue(MAXX);   y3 = RandomValue(MAXY);\par x4 = RandomValue(MAXX);   y4 = RandomValue(MAXY);\par x5 = RandomValue(MAXX);   y5 = RandomValue(MAXY);\par x6 = RandomValue(MAXX);   y6 = RandomValue(MAXY);\par x7 = RandomValue(MAXX);   y7 = RandomValue(MAXY);\par x8 = RandomValue(MAXX);   y8 = RandomValue(MAXY);\par x9 = RandomValue(MAXX);   y9 = RandomValue(MAXY);\par x10 = RandomValue(MAXX);  y10 = RandomValue(MAXY);\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {                                   /* set the initial ball velocities */\par vx1 = RandomValue(19)-10;  vy1 = RandomValue(7)-3;\par vx2 = RandomValue(19)-10;  vy2 = RandomValue(7)-3;\par vx3 = RandomValue(19)-10;  vy3 = RandomValue(7)-3;\par vx4 = RandomValue(19)-10;  vy4 = RandomValue(7)-3;\par vx5 = RandomValue(19)-10;  vy5 = RandomValue(7)-3;\par vx6 = RandomValue(19)-10;  vy6 = RandomValue(7)-3;\par vx7 = RandomValue(19)-10;  vy7 = RandomValue(7)-3;\par vx8 = RandomValue(19)-10;  vy8 = RandomValue(7)-3;\par vx9 = RandomValue(19)-10;  vy9 = RandomValue(7)-3;\par }\pard \s23\qj\fi360\widctlpar\adjustright {vx10 = RandomValue(19)-10; vy10 = RandomValue(7)-3;\par \par \par for (i = 1; i <= 100; ++i) \{\par    MoveBall(&x1,&y1,&vx1,&vy1);\par    MoveBall(&x2,&y2,&vx2,&vy2);\par    MoveBall(&x3,&y3,&vx3,&vy3);\par    MoveBall(&x4,&y4,&vx4,&vy4);\par    MoveBall(&x5,&y5,&vx5,&vy5);\par    MoveBall(&x6,&y6,&vx6,&vy6);\par    MoveBall(&x7,&y7,&vx7,&vy7);\par    MoveBall(&x8,&y8,&vx8,&vy8);\par    MoveBall(&x9,&y9,&vx9,&vy9);\par    MoveBall(&x10,&y10,&vx10,&vy10);\par    \}\par \}\par }\pard\plain \widctlpar\adjustright \f4\cgrid {\par \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s1\qc\nowidctlpar\outlinelevel0\adjustright \b\f4\fs36\cgrid {{\*\bkmkstart _Toc496344448}Lesson Five{\*\bkmkend _Toc496344448}\par {\*\bkmkstart _Toc496344449}Arrays and Strings{\*\bkmkend _Toc496344449}\par }\pard\plain \qj\widctlpar\adjustright \f4\cgrid {\b\fs28 \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344450}Groups of Numbers as Arrays{\*\bkmkend _Toc496344450}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Computers can deal with very large amounts of data.  On the Apple IIGS, you can easily write programs that will deal with thousands of numbers, names, zip codes, or whatever.  So far, though, the methods we have for dealing with these values are fairly limited.  A database of a hundred friends, each of whom has a name, street address, a city, a state, and a zip code would be a daunting task if each value had to be placed in a separate variable.\par One way we have to deal with large amounts of data is called an array.  An array is a group of values, each of which is the same type.  For example, an array can hold 1000 int values, or 200 float values, but an array cannot hold both int and float values at the same time.  We use an index to determine which of the values we want to access at a given time.\par For our first look at an array, let's do a simulation of rolling dice.  We've done this several times before, on a small scale, but this time we're going to roll the dice 10000 times, and keep track of how many times we get a 2, how many times we get a 3, and so forth.  We could, of course, use a separate variable for each of the totals, but that would get to be a bit tedious.  Instead, we will use an array.\par To define an array, you need to specify how many things you want in the array, and what kind they are.  In our case, we are adding up the number of times a particular value shows up on a pair of dice.  We can get any value from 2 to 12 from a pair of dice, so we need an array of eleven integers.  In C, when you define an array, you specify how many things you want the array to hold \endash  in this case, 11.  The array is defined like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {   int totals[11];\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par This is very similar to the way we define integers.  In fact, the only difference is that we have inclosed a number in brackets right after the name of the variable.  As you might guess, this means that the array holds integers.  It's just as easy to define an array that holds 100 double variables, though:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {   double values[100];\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par In the last lesson, you saw how to define a pointer to an integer by placing an * character before a variable name, and you even saw a definition where integers and pointers to int were mixed on the same line.  You can also mix arrays of int with these other types, like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {   int totals[11], i, *iptr;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {This line defines a total of three variables.  The first, totals, is an array of 11 int values.  The variable i is a simple int variable, like the ones you have used since the second lesson of the course, while the final variable is a pointer to int, like the ones you saw in the last lesson.\par }\pard \s21\qj\fi360\widctlpar\adjustright {To get at a particular entry in the array, we need to specify both the name of the array and the element of the array that we want to access.  All arrays have indexes that start from 0 and count up to the number of elements in the array minus one.  To set the first element of the array to zero, for example, we would write\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {totals[0] = 0;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The value between the brackets can be an expression as well as a specific integer.  We can use this fact to set all of the values in the array to zero with a loop, rather than eleven separate assignment statements.  The loop variable can then be used as the array index.  This technique of using a loop to deal with all of the elements of an array as a group is one of the reasons arrays are so handy for large amounts of data.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {for (i = 0; i < 11; ++i)\par }\pard \s23\qj\fi360\widctlpar\adjustright {   totals[i] = 0;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par You can use an element of an array anywhere that you could use an integer variable.  You can, for example, write an element of an array, use it in an expression, or pass it as a parameter to a function.  There are very few cases, though, where you can use the entire array.  You can't write an array using printf, for example.  We will explore when and how you can use an entire array as we get to know arrays better.\par Before you run the program in listing 5.1, I want to let you know that it will take a long time.  In fact, this program will run for nearly five minutes!  We will look at the reasons in a moment.\par \par }{\b \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright \f4\fs20\cgrid {\b Listing 5.1\par \par }\pard\plain \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright \f6\fs20\cgrid {/* This program simulates rolling dice.  It counts the number of   */\par /* times each value appears, printing a summary after the run is   */\par /* complete.                                                       */\par \par #include <stdio.h>\par #include <stdlib.h>\par \par #define ROLLS 10000             /* times to roll */\par \par int totals[11];                 /* number of spots showing */\par \par \par unsigned RandomValue (unsigned max)\par \par /* Return a pseudo-random number in the range 1..max.              */\par /*                                                                 */\par /* Parameters:                                                     */\par /*    max - largest number to return                               */\par /*    color - interior color of the rectangle                      */\par \par \{\par return rand() % max + 1;\par \}\par \par \par void Simulation(void)\par \par /* Roll the dice rolls times, saving the result.                   */\par /*                                                                 */\par /* Variables:                                                      */\par /*    totals - array holding the total number of rolls             */\par \par \{\par unsigned i;                         /* loop variable */\par unsigned sum;                       /* # of spots on this roll */\par \par for (i = 0; i < 11; ++i)            /* set the totals to zero */\par    totals[i] = 0;\par for (i = 1; i <= ROLLS; ++i) \{\par    sum = RandomValue(6)+RandomValue(6); /* roll the dice */\par    ++totals[sum-2];                 /* increment the correct total */\par    \}\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {void WriteArray(void)\par \par /* Write the results.                                              */\par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {/*                                                                 */\par /* Variables:                                                      */\par /*    totals - array holding the total number of rolls             */\par \par \{\par unsigned i;                         /* loop variable */\par \par printf("   spots   times\\n");\par for (i = 0; i < 11; ++i)\par    printf("%8d%8d\\n", i+2, totals[i]);\par \}\par \par \par void main(void)\par \par /* Main program.                                                   */\par \par \{\par srand(1234);                  /* initialize the random number generator */\par Simulation();                  /* do the dice simulation */\par WriteArray();                  /* write the dice array */\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {When you run this program, you should be sure and trace through a few loops with the debugger to see how values are assigned to an array.  You can't look at an entire array with the debugger, though.  Instead, you must enter each element of the array individually.  For example, to look at all of the elements of the totals array in this sample program, you need to enter totals[0], totals[1], and so forth as separate variables in the variables window.  There isn't enough room in the variables window to display all of the elements of the array when the variables window first shows up, but you can use the grow box to expand the variables window, just as you would with a program window.\par As I pointed out a moment ago, and as you have no doubt noticed, the program runs for nearly five minutes.  In fact, it runs for 4 minutes, 48 seconds.  While it is very true that this program is doing a fair amount of work, rolling two dice 10,000 times, that is still a very long time.  To see why, pull down the Run menu and select the Compile dialog.  Turn the debug code off, and run the program again.  This time, the program runs in 10.06 seconds.  That's quite a difference.  In fact, that is over 28 times faster than with debug code on.  This brings home, again, a point raised in an earlier lesson.  The debugger is a wonderful tool for finding errors in a program, but once the program is debugged, you should turn the debug code off for best performance.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344451}Be Careful With Arrays!{\*\bkmkend _Toc496344451}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Arrays are a wonderfully powerful way to handle large numbers of variables, but arrays do have some drawbacks in C.  As an example, let's look at a very short program, and try to understand what it is doing.  Don't run this program, though, until you have read the explanation of what it does.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* Don't run this program yet! */\par \par int a[2];\par \par void main(void)\par \par \{\par int i;\par \par for (i = 0; i < 32767; ++i)\par    a[i] = 0;\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par In this program, you are filling an array with zeros.  The array a, defined at the top of the program, is made up of two int values; each of these requires two bytes of storage.\par In the function main, the for loop starts off with i set to 0.  This stores a 0 into the first two bytes that the compiler set aside for the array when it was defined.  The next time through the loop, a[1] is set to zero, using the last two bytes the compiler set aside.  Unfortunately, the loop doesn't stop.  It goes right on to set a[2] to zero, changing the two bytes that come right after the array.  These bytes were not reserved by the compiler for use in the array.  In fact, they make up part of your program.  As the program continues to run, you wipe out more and more of your program, perhaps along with some of the operating system, a desk accessory or two, the text that the development environment is displaying in your source window, and so forth.  Eventually, the program will crash \endash  probably by entering the monitor, which will display a confusing text screen that shows some information about the state of the 65816 processor the Apple IIGS uses, as well as a little about the contents of the memory; or by hanging, where the computer simply stops responding to you.\par This is something that will happen to you over and over again as you program, so you might as well see it happen once now, while you are expecting it.  Go ahead and type this program in and run it.  Be sure you save anything on your desktop before you run it, though \endash  once you crash, there is no practical way to recover, other than rebooting.\par The point is that you can define an array to be whatever size you want, but the C language does not have a mechanism for making sure that you don't make mistakes.  It's up to you to make sure that you keep the array subscript in the proper range.  If you make a mistake, the results can be, well, dramatic.\par The error you just saw was a pretty obvious one, but there is a similar mistake that, in practice, is made far more often.  Let's take a look at an example:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {int a[2];\par \par void main(void)\par \par \{\par int i;\par \par for (i = 1; i <= 2; ++i)\par    a[i] = 0;\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par To a BASIC programmer, this looks like a pretty reasonable program.  You define an array with two elements, then fill in a[1] and a[2] with a zero.  Remember, though, that C starts all arrays with a first index of 0, not 1!  In addition, the 2 in a[2] is really the size of the array, not the value of the largest valid subscript.  For this array, the proper way to initialize it looks like this:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {int a[2];\par \par void main(void)\par \par \{\par int i;\par \par for (i = 0; i < 2; ++i)\par    a[i] = 0;\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {Take a close look at the for loop: it starts off with i set to 0, loops with i set to 1, and then stops, because, on the next loop, i would be 2, but in that case i is not less than 2.  This is a very common C programming technique.  It recognizes our natural tendency to want to use the size of the array in the condition that stops the for loop, but it also recognizes that a[2] does not exist.  You can see this technique used in our dice program, for example, when the totals array is initialized:\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {for (i = 0; i < 11; ++i)\par }\pard \s23\qj\fi360\widctlpar\adjustright {   totals[i] = 0;\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344452}Why Programmers are Humble \endash  At Least, in Private!{\*\bkmkend _Toc496344452}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {By now, you probably feel like this issue is being beat to death, but it is a very common source of errors in C programs, so I would like for you to try one other thing.  Here's the sample program that indexes one array element too far again:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {int a[2];\par \par void main(void)\par \par \{\par int i;\par \par for (i = 1; i <= 2; ++i)\par    a[i] = 0;\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {At this point, I want you to type the program in and run it.  Don't worry \endash  you won't have to reboot again!\par }\pard \s21\qj\fi360\widctlpar\adjustright {So what happened?  Nothing, right?  If this is such a bad error, why didn't anything happed?\par The answer is simple, and it also shows just how careful you have to be as a programmer.  The program did, in fact, wipe out two very important bytes in your program, but as it happened, the bytes had already been used, and were no longer needed.  If, by chance, the bytes had been critical, the program would have crashed.  If you were to add a call to printf right after initializing the array, for example, the program might crash.\par The point this illustrates is that a bug doesn't always show up right after you make the mistake.  In C, it is very possible for a bug like this one to stay hidden by chance arrangements of memory until you make an apparently innocent change to your program at some later date.  The natural tendency of all beginning programmers (yes, I did it, too) is to look at the new code, correctly note that it looks just fine, and maybe even test it in a separate program.  When the new code checks out, the claim is:  "The computer made a mistake!"  Or, perhaps one of the other variations:  "The compiler/operating system has a bug!"\par Right.  The Apple IIGS operating system is not perfect, and neither is ORCA/C, but if your program crashes, the best place to start to look for the problem is in the mirror.  This is a hard and humbling lesson for all new programmers to learn, but it is worth learning it quickly.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344453}Strings are Arrays{\*\bkmkend _Toc496344453}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {You may have noticed that a string was the first data type we ever dealt with, but you haven't seen much of them.  Back in lesson 1, our very first program wrote a string constant to the screen.  Since then, we have made extensive use of integers and real numbers, but we have never defined a string variable.  The reason is that strings in C are actually arrays of characters.  Now that you are learning about arrays, you can also learn a great deal about strings.\par In C, a string is simply an array of characters.  Characters are a new data type; in C, you use the name char for characters to save some typing, just as you use int instead of integer.  For example, the array\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {char name[10];\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {could be used to hold a name.  It can hold Wirth, Jobs or Allred, but it is limited to names with 9 or fewer characters.  This string can't hold Westerfield, since that name has 11 characters.\par }\pard \s21\qj\fi360\widctlpar\adjustright {OK, you've learned your lesson about arrays, and you know that the array can only hold 10 char values, so why did I say that the longest string this array can hold is 9 characters long?  The answer lies in how C represents a string internally.  When printf prints a string, or when any of the functions you will eventually learn about use a string, they need to know how long the string is.  The functions don't have any idea how big the array itself is, so C uses a special character called the null character to mark the end of the string.  The null character is generally put into strings by C automatically, but you have to remember to leave room for it, which is why an array that holds ten char values is only long enough to hold a string with 9 characters.  You have to leave one extra character so there is room for the null character that marks the end of the string.\par Let's take a look at a string in a real program, as shown in listing 5.2.\par \par }\pard\plain \qj\fi360\widctlpar\adjustright \f4\cgrid {\sect }\sectd \sbknone\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b \par }\pard \s21\qj\fi360\keepn\widctlpar\brdrt\brdrs\brdrw10\brsp20 \brdrl\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \adjustright {\b Listing 5.2\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\brdrt\brdrs\brdrw10\brsp20 \brdrl\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \adjustright \f6\fs20\cgrid {/* This program reads in a string, reverses the order of the       */\par /* characters, and writes the string back to the shell window.     */\par \par #include <stdio.h>\par #include <string.h>\par \par #define MAX 256                 /* max length of the input string */\par \par }\pard \s23\qj\fi360\widctlpar\brdrt\brdrs\brdrw10\brsp20 \brdrl\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \adjustright {char inString[MAX],             /* input string */\par      outString[MAX];            /* output string */\par \par \par void Reverse()\par \par /* Reverse a string                                   */\par /*                                                    */\par /* Variables:                                         */\par /*    inString - string to reverse                    */\par /*    outString - reversed string                     */\par \par \{\par int i;                          /* loop variable */\par int index;                      /* index into the reversed string */\par int len;                        /* length of the input string */\par \par len = strlen(inString);         /* find the length of the input string */\par index = len;                    /* reverse the string's characters */\par for (i = 0; i < len; ++i) \{\par    --index;\par    outString[index] = inString[i];\par    \}\par outString[len] = 0;             /* set the terminating null character */\par \}\par \par \par void main(void)\par \par /* Main program.                                      */\par \par \{\par printf("String  :");            /* get a string */\par scanf("%s", inString);\par Reverse();                      /* reverse the string */\par printf("Reversed:%s\\n", outString); /* write the reversed string */\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {There are close to a whole bunch of new things in this program, but before we start to explore them, go ahead and run the program so you know what it does.\par Back already?  OK, let's start by looking at the main program.  In particular, I'd like for you to take a close look at the scanf call:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {scanf("%s", inString);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par At first glance, this call looks innocent enough, but on closer inspection there are some peculiarities that point out some subtleties about the C language.  The first is the absence of the & operator before the name of the string.  By now, you know that all parameters to scanf, except for the original format string, of course, must be addresses, and you are used to using the & operator to get the address of a variable.  In C, though, arrays and pointers have a unique relationship.  This isn't something I'd like to confuse you with all at once, but the first thing that you should learn is that when you pass an array as a parameter to a function in C, the C language automatically converts the name of the array to the address of the array.  In other words, you don't need the & operator before the name of an array, and in fact, it is a mistake to put it there.  Fortunately, this is one mistake a C compiler can catch, so if you forget, you will be warned.\par The other new things about this call are considerably more predictable.  Since the program is reading a string, there must be a new conversion specifier, and in fact you see %s.  The %s conversion specification also appears in the printf format string, when outString is written.\par The last difference between this scanf call and the ones you have made before is that there is no whitespace character before the conversion specifier.  This is because the %s conversion specifier actually skips whitespace on its own before it starts to read a string.  When it is reading a string, scanf starts by skipping all whitespace characters, then it reads characters until it gets to the next whitespace character.  In other words, it will read symbols from the input line one word at a time.\par Inside the Reverse function is a call to a new library function, strlen.  The strlen function is part of a very powerful string processing library called string.h.  At the top of the program, you see a new include directive to include the header file that defines all of the functions in this library.  This powerful, standardized string library makes C the best choice of any of the common high-level languages for string processing.  You will see several functions from this library in the course.\par The strlen function finds the length of a string and returns it.  It works by counting all of the characters in the string up to the terminating null character.  The string "hello", for example, would have a length of five, since there are five characters before the terminating null character that C puts at the end of all strings (yes, even at the end of string constants!).\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344454}Characters and Integers are Related{\*\bkmkend _Toc496344454}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The characters you use in an array to form a string variable are more closely related to integers in C that in most languages.  In fact, as far as the C language is concerned, a character }{\i is}{ an integer.  The only difference between a char variable and an int variable is that characters take up less room than integers, and therefore have a smaller range.  In fact, char variables can hold integer values from -128 to 127.  (This can change from compiler to compiler, but this range for characters is the most common one.  The other common alternative is a range of 0 to 255, which you can get in ORCA/C by using the type unsigned char instead of char.)  You can even use the %d conversion specification in printf to print the integer value of a character!  To print an integer as a character, you can use the conversion specifier %c, which is the conversion specifier normally used to print char variables.\par This special relationship between characters and integers really comes into play when you ask what it means to compare two characters.  The integer value associated with each character changes from computer to computer, but some definition is essential.  After all, you can get pretty good agreement from most people whether the character a is less than the character b, but things get a little less definite when you ask if the character ^ is less than the character *.  On the Apple IIGS, and most other desktop computers, the integer that is associated with each character is defined by the ASCII character set.  The ASCII character set also lists all of the characters you can use.  It has one character for each of the values from 0 to 127.  Some of these values are known as printing characters; for example, the numeric value 65 is used to represent an uppercase A, while the lowercase a is represented by 97.  Some of the values in the ASCII character set are non-printing characters.  These are used for special purposes.  The character whose ordinal value is 13, for example, is used to separate lines in files of characters and to move to a new line on the text screen.\par Table 5.1 shows the complete ASCII character set in tabular form.  Non-printing characters are shown as the name of the value.  To obtain the integer value used to represent one of the characters, add the number at the top of the column to the number at the start of the row.\par }{\lang1024 {\shp{\*\shpinst\shpleft-144\shptop-473\shpright9360\shpbottom4423\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz23\shplid1155{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 4063232}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s22\qc\sa200\nowidctlpar\adjustright \b\f4\fs20\cgrid {Table 5.1\par }\pard\plain \qj\li1440\nowidctlpar\tx1800\adjustright \f4\cgrid {\fs20 \tab }{\fs20\ul \tab 0\tab 16\tab 32\tab 48\tab 64\tab 80\tab 96\tab 112\par }\pard \qj\li1440\nowidctlpar\tb1800\adjustright {\fs20 0\tab nul\tab dle\tab \tab 0\tab @\tab P\tab `\tab p\par 1\tab soh\tab dc1\tab !\tab 1\tab A\tab Q\tab a\tab q\par 2\tab stx\tab dc2\tab "\tab 2\tab B\tab R\tab b\tab r\par 3\tab etx\tab dc3\tab #\tab 3\tab C\tab S\tab c\tab s\par 4\tab eot\tab dc4\tab $\tab 4\tab D\tab T\tab d\tab t\par 5\tab enq\tab nak\tab %\tab 5\tab E\tab U\tab e\tab u\par 6\tab ack\tab syn\tab &\tab 6\tab F\tab V\tab f\tab v\par 7\tab bel\tab etb\tab '\tab 7\tab G\tab W\tab g\tab w\par 8\tab bs\tab can\tab (\tab 8\tab H\tab X\tab h\tab x\par 9\tab ht\tab em\tab )\tab 9\tab I\tab Y\tab i\tab y\par 10\tab lf\tab sub\tab *\tab :\tab J\tab Z\tab j\tab z\par 11\tab vt\tab esc\tab +\tab ;\tab K\tab [\tab k\tab \{\par 12\tab ff\tab fs\tab ,\tab <\tab L\tab \\\tab l\tab |\par 13\tab cr\tab gs\tab -\tab =\tab M\tab ]\tab m\tab \}\par 14\tab co\tab rs\tab .\tab >\tab N\tab ^\tab n\tab ~\par 15\tab si\tab us\tab /\tab ?\tab O\tab _\tab o\tab rub\par }\pard \nowidctlpar\adjustright {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8215\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s22\qc\sa200\nowidctlpar\adjustright \b\f4\fs20\cgrid {Table 5.1\par }\pard\plain \qj\li1440\nowidctlpar\tx1800\adjustright \f4\cgrid {\fs20 \tab }{\fs20\ul \tab 0\tab 16\tab 32\tab 48\tab 64\tab 80\tab 96\tab 112\par }\pard \qj\li1440\nowidctlpar\tb1800\adjustright {\fs20 0\tab nul\tab dle\tab \tab 0\tab @\tab P\tab `\tab p\par 1\tab soh\tab dc1\tab !\tab 1\tab A\tab Q\tab a\tab q\par 2\tab stx\tab dc2\tab "\tab 2\tab B\tab R\tab b\tab r\par 3\tab etx\tab dc3\tab #\tab 3\tab C\tab S\tab c\tab s\par 4\tab eot\tab dc4\tab $\tab 4\tab D\tab T\tab d\tab t\par 5\tab enq\tab nak\tab %\tab 5\tab E\tab U\tab e\tab u\par 6\tab ack\tab syn\tab &\tab 6\tab F\tab V\tab f\tab v\par 7\tab bel\tab etb\tab '\tab 7\tab G\tab W\tab g\tab w\par 8\tab bs\tab can\tab (\tab 8\tab H\tab X\tab h\tab x\par 9\tab ht\tab em\tab )\tab 9\tab I\tab Y\tab i\tab y\par 10\tab lf\tab sub\tab *\tab :\tab J\tab Z\tab j\tab z\par 11\tab vt\tab esc\tab +\tab ;\tab K\tab [\tab k\tab \{\par 12\tab ff\tab fs\tab ,\tab <\tab L\tab \\\tab l\tab |\par 13\tab cr\tab gs\tab -\tab =\tab M\tab ]\tab m\tab \}\par 14\tab co\tab rs\tab .\tab >\tab N\tab ^\tab n\tab ~\par 15\tab si\tab us\tab /\tab ?\tab O\tab _\tab o\tab rub\par }\pard \nowidctlpar\adjustright {\par }}\dpx-144\dpy-473\dpxsize9504\dpysize4896\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 5.1. }{ In this section, two claims were made: first, that you could use %c to print the character that corresponds to an integer, and second, that the integer associated with the letter A is 65.  Test these facts by writing a program that prints the integer value 65, but uses the conversion specifier for a character.  (To save you from searching through the text, the conversion specifier for a character is %c.)\par \par }{\b Problem 5.2.}{  The ASCII character set consists of two kinds of characters, called the printing characters and special characters.  The special characters are used for special purposes which you will learn about gradually.  The printing characters are the characters starting with the space character (with an integer value of 32) and continuing through the ~ character (with an integer value of 126).\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Write a program that prints the printing ASCII characters in the shell window.  Your program should print sixteen characters on each line except the last line, which will have fifteen characters.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {(Hint: Use two nested for loops, one of which ranges from 0 to 5, and the other of which loops from 0 to 15.  Use an if statement to make sure you don't print the character for 127, which is not a printing character.)\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344455}A Bit About Memory{\*\bkmkend _Toc496344455}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {It might help you to understand some of the information about C's various variables if we stop and take a quick look at how the memory in your computer is organized and used.  Basically, all of the memory in your computer is divided up into a series of bytes, each of which is made up of eight little electronic devices which can store either a one or a zero; these are called bits.  The byte is the smallest unit of memory you can address, and the smallest unit of memory C can set aside for any particular use.  Each of these bytes can hold 256 different values.\par Talking about bytes in terms of how many bits there are makes as much sense to most people as discussing sex in terms of birds and bees.  The parts involved just aren't the ones we are familiar with.  From the C programers' viewpoint, a much more reasonable way to look at the byte is in terms of how many bytes it takes to hold certain kinds of values.  An integer variable, for example, needs two bytes of storage, while a char variable only uses one byte.  Float numbers and long integers each require four bytes of storage, while a double number needs eight bytes of storage.\par To find out how big an array is in bytes, multiply the number of things in the array by the number of bytes required for one of the array variables.  For example, the array of integers in our dice sample has 11 array elements.  The elements are integers, so each needs two bytes of storage.  The entire array, then, uses 22 bytes of storage.\par The amount of memory in your computer is usually given in terms of kilobytes.  A good background in metric units would tell you that a kilobyte is 1000 bytes, but unfortunately, that isn't quite correct.  Internally, modern computers are built around powers of two, so computer types define the kilobyte as 1024 bytes, which is 2 raised to the 10th power.  A megabyte is a kilo-kilobyte, or 1048576 bytes.  We use K to indicate a kilobyte, and M to indicate a megabyte.\par Depending on which model of the Apple IIGS you have, you are using, as a minimum, 1.25M or 1.125M, most of which is free and can be used by your program.  ORCA/C can access all of the memory you have, although there are a few tricks you have to know to access more than 64K.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344456}Character Constants and String Constants{\*\bkmkend _Toc496344456}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Way back in lesson 1, you learned that\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {"Hello, world.\\n"\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {is a string constant.  A string constant consists of zero or more characters enclosed in quote marks.  As a special case, two quote marks with no characters represents a string with no characters in it at all; this is called a null string.  A character constant is very similar: a character constant is a single character enclosed in single quote marks.  As with strings, to get the single quote mark as a character, we use an escape sequence; in this case, \\'.  All of the following are legal character constants.\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\tx900\tx1440\tx1980\tx2520\tx3060\tx3600\adjustright \f6\fs20\cgrid {'a'\tab ' '\tab '\\''\tab '6'\tab '!'\tab 'A'\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par From your standpoint, character constants and string constants are very similar, but you need to keep in mind that the C language does not share your viewpoint.  In the C languages, character constants and strings are very, very different from each other.  In fact, a character constant is really just another way of writing an integer value: the C compiler doesn't care one bit whether you write the character constant 'A' or the integer constant 65; the program the compiler creates will be exactly the same, either way.\par A string constant, on the other hand, is treated just like an array by the compiler.  When you use a string constant as a parameter to a function, for example, the compiler actually stores the string in your program, and passes the address of the array to the function \endash  just as it would pass the address of an array to the function if you were to put an array name in the parameter list of a function.\par Since character constants and string constants are so different in C, the C language has two different ways of representing these two kinds of constants.  A character constant uses single quote marks around the character, while a string constant uses double quote marks.  For example, 'A' is a character constant, but "A" is a string constant.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344457}Another Look at strlen{\*\bkmkend _Toc496344457}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {C has a wide variety of functions in the standard library string.h that help you manipulate strings \endash  so many, in fact, that we aren't going to look at all of them in this course.  There are a few basic ones, though, that you will want to use again and again, so we'll stop and take a look at them now.  For all of these string functions, you should include string.h at the start of your program.\par You have already seen one string function, strlen.  The strlen function finds out how many characters are in a string by counting the non-null characters that come before the terminating null character.  The maximum length that strings can be varies from compiler to compiler, but in ANSI C, the maximum length is at least as big as a pointer, assuming you have that much memory in your computer.  In other words, strings can be as big as the memory you have in your computer!\par As it happens, that means that the length of a string is actually a long value on the Apple IIGS, so you need to make sure that when you print the result returned by strlen, you use the %ld conversion specification, not the %d conversion specification.  When you assign the length of the string to an int value, though, C takes care of converting the value from a long integer to an int value for you.  As long as the value is not too big to store in an int variable, you will get the correct answer.  You will generally know if you are dealing with huge strings, since you have to allocate arrays big enough to hold them, though, so there is rarely any confusion about which size variable to use.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344458}Copying Strings with strcpy and strncpy{\*\bkmkend _Toc496344458}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The most basic thing you will want to do with a string is to assign one string to another.  Strings are arrays, though, and you can't assign one array to another in C.  The strcpy function lets you copy one string to another.  Here's a quick example showing how it is used.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par #include <string.h>\par \par void main(void)\par \par \{\par char string1[20], string2[20];\par \par strcpy(string1,\par    "Hello, world.\\n");\par strcpy(string2, string1);\par printf(string1);\par printf(string2);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par As you can see, you can copy string constants to a string, or one string to another.  The order of the strings is important \endash  you put them in the same order you would for an assignment operation: the first string is the one you are setting, and the second string is the one you are copying into the first.\par The strcpy function trusts you, so you need to be sure you know what you are doing.  strcpy copies characters from the second string into the first until it hits the null character at the end of the second string.  After copying the null character, strcpy stops.  Counting the terminating null character, the string "Hello, world.\\n" is a total of 15 characters long.  In our sample program, the string arrays are 20 characters long, so they will hold the value with room to spare, but if you were to change the arrays to 10 character arrays, strcpy would copy right over top of the five bytes that follow the string in memory.  In C, it's programmer beware, so you need to be sure your strings are long enough.\par While the strcpy function is very useful, the fact that it can write past the end of an array makes it dangerous in some cases.  For example, if you are writing a function that works on a string that is passed as a parameter, you may need to guard against the possibility that the string is longer that you are allowing for.  You could use strlen to check, but there is also a variation of strcpy called strncpy that can be used.  The strncpy function uses one more parameter, a maximum length, to make sure the array doesn't overflow.  If the limit is hit, though, your string won't have a terminating null character, so you still have to check to see if there is one \endash  or you can simply tell strncpy to use one fewer than the maximum size of the array, and fill in a null terminator on your own, as this sample program does.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par #include <string.h>\par \par void main(void)\par \par \{\par char string1[10], string2[10];\par \par string1[9] = 0;\par string2[9] = 0;\par strncpy(string1,\par    "Hello, world.\\n", 9);\par strncpy(string2, string1, 9);\par printf(string1);\par printf(string2);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Incidentally, the null character in C is always the character whose integer value is zero; the first two statements in the program are simply making sure there is a null character in the last byte of the string.\par Like most C library functions, strcpy and strncpy return something.  In this case, they return a copy to the destination string \endash  the one you copied things into.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 5.3. }{ Use the fact that you can print a character as an integer using the %d conversion specification to find out what integer value is used in C to mark the end of a line (the \\n escape sequence) and the null character.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Hint: Use strcpy to copy the string "\\n" into a char array, then print the first two elements of the array.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344459}Putting Strings Together with strcat and strncat{\*\bkmkend _Toc496344459}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Putting two strings together is accomplished with a function called strcat, for string concatenation.  strcat takes two strings, and tacks the second one onto the first.  As with strcpy, there is a close cousin of strcat called strncat that uses one additional parameter to prevent array overflows.  Here's a sample of strcat and strncat in action.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par #include <string.h>\par \par void main(void)\par \par \{\par char string[20];\par \par strcpy(string, "Hello, ");\par strcat(string, "world");\par strncat(string, ".\\n", 20);\par printf(string);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }{\b Problem 5.4.}{  As the examples have been showing, you can use a string variable as a format string for printf instead of a string constant.  Use this fact to build a format string to write a character to the shell window, then change the format specifier and use it again to write the same value as an integer.  You can use the value 65 for both printf statements.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {While this is a pretty simple example, it points out one of the more powerful aspects of C's format string: you can change it on the fly to adapt a small subroutine to do a wide variety of different situations.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344460}Comparing Strings with strcmp and strncmp{\*\bkmkend _Toc496344460}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The strcmp function is used to compare two strings.  Basically, strcmp compares the characters in each string, starting with the first, until it finds two characters that are not the same.  If the character in the first string is less than the character in the second string, strcmp returns a negative int value; if it is greater, strcmp returns a positive int value.  If all of the characters up to the terminating null character match exactly, strcmp returns zero.  Finally, if one string is shorted than the other, but all of the characters up to the end of the shorter string match, strcmp acts like the shorter string is less than the longer string.\par Combining all of this gibberish with the fact that the Apple IIGS uses the ASCII character set, in which letters are ordered right after each other, all of this means that strcmp works just the way you want it to.  Assuming all of the characters are uppercase or lowercase, strcmp works the same way you would alphabetize strings.  For example, "APPLES" is less than "ORANGES", while "TEDDY" is greater than "TED".\par In fact, if you treat the ASCII character set as an extended alphabet, strcmp acts like strings are in alphabetical order for any string.  For example, "100" is less than "120", since the character '0' is less than the character '2', and "apples" is greater than "Apples", since a lowercase 'a' character comes after 'A' in the ASCII character set.\par Like most of the other string functions, strcmp has a cousin called strncmp.  The strncmp function has one addition parameter, which is the maximum number of characters the function will compare.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 5.5.}{  The exact value strcmp will return when one string is less than another is negative in all C compilers, but it can be any negative number.  The value returned when the first string is larger than the second is positive, but again, it can be any positive number.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Write a program that prints the actual values returned by both strcmp and strncmp when the first string is less than the second, and when the first string is greater than the second.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }{\b Problem 5.6. }{ What will strcmp return for strcmp(s1, s2), when the strings in s1 and s2 are taken from the following table?  Assume strcmp uses -1 for a negative value, and 1 for a positive value.\par \par }\pard \s24\qj\li720\widctlpar\tx1440\tx2880\adjustright {\tab }{\ul s1}{\tab }{\ul s2}{\par }{\f6 a.\tab "APPLES"\tab "ORANGES"\par b.\tab "50"\tab "200"\par c.\tab "Mike"\tab "Michael"\par d.\tab "Apple"\tab "Apple"\par e.\tab " space"\tab "space"\par f.\tab "happy"\tab "Happy"\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344461}Passing Strings as Parameters{\*\bkmkend _Toc496344461}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {You've used a lot of library functions that can handle strings; now it's time to find out how to do that for yourself.  Listing 5.3 shows a program that implements one of the few functions C doesn't already have: it converts all of the characters in a string from uppercase to lowercase.\par The main program should be old hat by now, so we won't worry too much about it.  There are several interesting points about the strlower function that we need to look at, though.  The first is that I have violated one of my formatting conventions.  As I mentioned a few lessons ago, and as you have seen over and over, I use an uppercase letter for the first letter in my function names, but in this program, I violated that convention.  You have to keep in mind that formatting conventions are not rules, they are mental aids to help you program faster and make fewer mistakes.  Since all of the string library functions start with str, I choose to make this function look as much like them as possible.  For me, that will cause me to make fewer mistakes.\par }{\lang1024 {\shp{\*\shpinst\shpleft0\shptop-1183\shpright9360\shpbottom8033\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz24\shplid1156{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 3997696}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 5.3\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par #include <string.h>\par #include <ctype.h>\par \par void strlower (char str[1])\par \par /* Convert a string to lowercase                                   */\par /*                                                                 */\par /* Parameters:                                                     */\par /*    str - string to convert                                      */\par \par \{\par unsigned i;                     /* array index */\par \par i = 0;\par while (str[i] != 0) \{\par    str[i] = tolower(str[i]);\par    ++i;\par    \}\par \}\par \par \par void main(void)\par \par /* Main program.                                                   */\par \par \{\par char string[40];\par \par strcpy(string, "Apples are red, aren't they?\\n");\par strlower(string);\par printf(string);\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8216\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 5.3\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par #include <string.h>\par #include <ctype.h>\par \par void strlower (char str[1])\par \par /* Convert a string to lowercase                                   */\par /*                                                                 */\par /* Parameters:                                                     */\par /*    str - string to convert                                      */\par \par \{\par unsigned i;                     /* array index */\par \par i = 0;\par while (str[i] != 0) \{\par    str[i] = tolower(str[i]);\par    ++i;\par    \}\par \}\par \par \par void main(void)\par \par /* Main program.                                                   */\par \par \{\par char string[40];\par \par strcpy(string, "Apples are red, aren't they?\\n");\par strlower(string);\par printf(string);\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx0\dpy-1183\dpxsize9360\dpysize9216\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{Going beyond the formatting, you can see that, to pass an array, you can simply declare the parameter as an array.  The index may seem strange, but we'll deal with that issue in a moment.  First, let's stop and think about what it means to pass an array.  As you already know, C automatically converts an array to a pointer to the first element of the array (or the address of the array, which is another way of saying the same thing) when the array is passed as a parameter.  Why, then, do we still declare the parameter as an array?  Shouldn't it be declared as char *str, declaring the parameter as a pointer to a character?\par Strangely enough, the answer is that it could be.  In C, a function parameter that is an array can be treated in the C function as a pointer to an element of the array.  If you pass a pointer to a character, you can also treat it as an array of characters in the function.  In short, when you are passing a parameter, a pointer to a value and an array of values are completely interchangeable.  In fact, later on you will learn how to use pointers to access values in arrays, and arrays to access values pointed to by a pointer.  This is a powerful but strange concept that you will see developed gradually in the course.\par For the most part, though, if we are passing an array, we declare the parameter as an array, and we use the parameter as an array in the function.  Even though C lets us do some tricks with pointers and arrays, it is usually easier to understand the program if you stick to one or the other.  For now, just keep in mind that C knows what to do when you pass an array as a parameter, and declare the parameter as an array, even though the array is converted to a pointer in the mean time.  We'll resolve all of the sticky questions about this issue later, after you learn a little more about expressions and pointers.\par At the start of this lesson, you saw how dangerous it can be to index past the end of the array, and you saw that C doesn't check to make sure you don't do that in your programs.  It may have seemed pretty crude of the language not to make a simple check to prevent such a disastrous error, but now you can see one place when this comes in handy.  You see, the strlower function does not know, in advance, how long the string will be \endash  and, since it can index past the end of the array, it doesn't care.  We declare the array as having two characters, and then proceed to index into the array until we get to the terminating null character.\par It may offend your sensibilities a little to do this.  After all, the string we are passing has 40 characters, so why not define the parameter the same way?  Go ahead: C doesn't care.  But what happens if you call strlower again, in another place, with a string that is 80 characters long?  Do you define the parameter with an index of 40, or 80?  Sensibilities could be offended either way.  In general, you might just pick some number to represent the size of an array parameter and stick with it, since you really can't tell in advance how large the array will be, anyway.\par Of course, you might be wondering how much space C is using for this array.  Keep in mind, though, that the parameter isn't really an array at all \endash  it is a pointer to an array, so the pointer is the same size no matter how big the array is.  The space for the array is allocated somewhere else.\par All of this may seem a bit odd, but it gives quite a bit of power to C that doesn't exist in some other languages.  The function we just defined can, in fact, be called with strings of several different lengths.  You can't do that in Pascal.  The trade off is that Pascal has checks to prevent array overflows.  You have to be more careful in C, since C doesn't do that kind of checking, but the reward is that you can do some things in C that can't be done in Pascal.\par While the standard C libraries don't have a function to convert a string to all uppercase or lowercase, they do have functions to convert characters from lowercase to uppercase, called tolower and toupper.  The sample program uses tolower to convert the characters in the array to lowercase characters.  Both functions take a character as a parameter, and return a character as a result.  As you can see, they do not change characters unless they are, in fact, uppercase characters.  C's character manipulation functions are contained in the ctype library; you can see the proper include for ctype.h at the top of the program.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 5.7. }{ Using the sample program in this section as a model, create a program to convert strings to all uppercase characters.  You can use the character function toupper to help you do this.  Test your function with two different string arrays, one of which is 20 characters long, and the other 30 characters long, to verify that you can, in fact, pass strings of different lengths.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344462}Returning Strings as Function Results{\*\bkmkend _Toc496344462}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The name of this section is a little misleading, in a way, since like most languages, C does not let you return a string as the result of a function.  On the other hand, you can return a pointer to a char value, and as you are starting to discover, that's almost the same thing in C as returning an array.  Listing 5.4 shows a reworked version of our last sample program that does just that.\par The return statement sure looks like it's returning an array, but then, it looked like we were passing an array as a parameter, too, when in fact we were passing the address of the array.  The main function shows why the string functions return a pointer to the array they change, too, instead of just changing the parameter.  In this program, we can use printf to print the value returned by the function.  Of course, the string has also been changed, as you saw in the last section.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 5.8. }{ The strlower function changes the string you pass it.  In some cases, we don't want to do that.  Create a function that prints the lowercase equivalent of the string without changing the string you pass to the function.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {The program you create will have one serious drawback compared to the programs that change the string.  What is the drawback?\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344463}The string.h and ctype.h Libraries{\*\bkmkend _Toc496344463}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The standard C library is large and powerful.  In fact, it is so large that we won't get a chance to cover all of the functions in the C library, nor do most C programmers know all of them.  It isn't important that you remember all of them, either, but you should have a good idea of what is available, and a general idea of how to find descriptions of the functions when you need to.  In the long run, it will save you quite a bit of work.\par }{\lang1024 {\shp{\*\shpinst\shpleft0\shptop-946\shpright9360\shpbottom8270\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz25\shplid1157{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 3932160}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 5.4\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par #include <string.h>\par #include <ctype.h>\par \par char *strlower (char str[1])\par \par /* Convert a string to lowercase                                   */\par /*                                                                 */\par /* Parameters:                                                     */\par /*    str - string to convert                                      */\par \par \{\par unsigned i;                     /* array index */\par \par i = 0;\par while (str[i] != 0) \{\par    str[i] = tolower(str[i]);\par    ++i;\par    \}\par return str;\par \}\par \par \par void main(void)\par \par /* Main program.                                                   */\par \par \{\par char string[40];\par \par strcpy(string, "Apples are red, aren't they?\\n");\par printf(strlower(string));\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8217\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 5.4\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par #include <string.h>\par #include <ctype.h>\par \par char *strlower (char str[1])\par \par /* Convert a string to lowercase                                   */\par /*                                                                 */\par /* Parameters:                                                     */\par /*    str - string to convert                                      */\par \par \{\par unsigned i;                     /* array index */\par \par i = 0;\par while (str[i] != 0) \{\par    str[i] = tolower(str[i]);\par    ++i;\par    \}\par return str;\par \}\par \par \par void main(void)\par \par /* Main program.                                                   */\par \par \{\par char string[40];\par \par strcpy(string, "Apples are red, aren't they?\\n");\par printf(strlower(string));\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx0\dpy-946\dpxsize9360\dpysize9216\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{The tables below give you a quick summary of the functions in string.h and ctype.h, the string and character libraries we have used in this lesson.  You know all that you need to to use any of these functions, and you know enough to understand the descriptions of them.  Read through the list of functions and pick out a couple that interest you.  Make sure you can find them in the ORCA/C reference manual, or whatever C reference manual you happen to prefer.  You might even want to try a couple of them in a real program.\par One thing you should notice about the table is that there are often several ways of doing the same thing.  In all of these situations, the actual functions differ a bit.  You have already seen some examples of this: strcpy and strncpy, for example, both copy a string into another string array, but they each have different options for doing so.\par This may sound like a make-work exercise, but it really isn't.  C is a big language, with a huge library, so very few people ever learn it completely.  If you know how your reference manual is laid out, and basically where everything is, there's a good chance that you'll grab it to look up a function like strcpy when you need to.  If you are not familiar with your manual, you might avoid it \endash  and your C programs will be larger, less efficient, and perhaps have more bugs than they would if you had used the reference manual.\par \par \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {\b string.h\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par c2pstr\tab (ORCA/C specific.)  Convert a C string to a p-string.\par memchr\tab Find a byte.\par memcmp\tab Compare memory.\par memcpy\tab Copy memory.\par memmove\tab Copy memory.\par memset\tab Set memory to a value.\par p2cstr\tab (ORCA/C specific.)  Convert a p-string to a C string.\par strcat\tab Concatenate strings.\par strchr\tab Find a character.\par strcmp\tab Compare strings.\par strcpy\tab Copy a string.\par strcspn\tab Scan for one of a set of characters.\par strerror\tab Return a run-time error message.\par strlen\tab Find the length of a string.\par strncat\tab Concatenate strings.\par strncmp\tab Compare strings.\par strpbrk\tab Scan for one of a set of characters.\par strpos\tab Find a character.\par strrchr\tab Find a character.\par strrpbrk\tab Scan for one of a set of characters.\par strrpos\tab Find a character.\par strspn\tab Scan for one of a set of characters.\par strstr\tab Find one string in another.\par strtok\tab Break a string into tokens.\par \par }\pard \s21\qj\widctlpar\adjustright {\b ctype.h\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par isalnum\tab Is the character alpha-numeric?\par isalpha\tab In the character alphabetic?\par isascii\tab In the character in the ASCII character set?\par iscntrl\tab In the character a control character?\par iscsym\tab In the character one that can appear in a C symbol?\par iscsymf\tab In the character one that can appear as the first character in a C symbol?\par isdigit\tab In the character a digit?\par isgraph\tab In the character a graphic character?\par islower\tab In the character lowercase?\par isodigit\tab In the character an octal digit?\par isprint\tab In the character a printing character?\par ispunct\tab In the character a punctuation character?\par isspace\tab In the character a whitespace character?\par isupper\tab In the character uppercase?\par isxdigit\tab In the character a hexadecimal digit?\par toascii\tab Convert the character to ASCII.\par toint\tab Convert a digit to an integer value.\par tolower\tab Convert a character to lowercase.\par toupper\tab Convert a character to uppercase.\par _tolower\tab Convert a character to lowercase.\par _toupper\tab Convert a character to uppercase.\par \par }\pard\plain \widctlpar\adjustright \f4\cgrid {\b\fs36 \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \qc\widctlpar\adjustright \f4\cgrid {\b\fs36 Lesson Five\par Solutions to Problems\par }\pard \qj\widctlpar\adjustright {\b\fs28 \par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344464}Solution to problem 5.1.{\*\bkmkend _Toc496344464}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par printf("%c\\n", 65);\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344465}Solution to problem 5.2.{\*\bkmkend _Toc496344465}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par unsigned row, col;\par unsigned ch;\par \par ch = 32;\par for (row = 0; row <= 5; ++row) \{\par    for (col = 0; col <= 15; ++col) \{\par       if (ch != 127)\par          printf("%c", ch);\par       ++ch;\par       \}\par    printf("\\n");\par    \}\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344466}Solution to problem 5.3.{\*\bkmkend _Toc496344466}\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par #include <string.h>\par \par void main(void)\par \par \{\par char string[10];\par \par strcpy(string, "\\n");\par \par printf("The \\\\n character is %d.\\n", string[0]);\par printf("The null character is %d.\\n", string[1]);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344467}Solution to problem 5.4.{\*\bkmkend _Toc496344467}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par #include <string.h>\par \par void main(void)\par \par \{\par char format[10];\par \par strcpy(format, "%c\\n");\par \par printf(format, 65);\par format[1] = 'd';\par printf(format, 65);\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344468}Solution to problem 5.5.{\*\bkmkend _Toc496344468}\par }\pard\plain \s23\qj\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par #include <string.h>\par \par void main(void)\par \par \{\par printf("strcmp returns %d if the first string is less than the second.\\n",\par    strcmp("apple", "orange"));\par printf("strcmp returns %d if the first string is greater than the second.\\n",\par    strcmp("orange", "apple"));\par printf("strncmp returns %d if the first string is less than the second.\\n",\par    strncmp("apple", "orange", 10));\par printf("strncmp returns %d if the first string is greater than the second.\\n",\par    strncmp("orange", "apple", 10));\par }\pard \s23\qj\widctlpar\adjustright {\}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344469}Solution to problem 5.6.{\*\bkmkend _Toc496344469}\par }\pard\plain \s21\qj\fi360\widctlpar\tx1440\tx3600\adjustright \f4\fs20\cgrid {\tab s1\tab s2\par }{\f6 a.\tab "APPLES"\tab "ORANGES"\tab -1\par b.\tab "50"\tab "200"\tab  1\par c.\tab "Mike"\tab "Michael"\tab  1\par d.\tab "Apple"\tab "Apple"\tab  0\par e.\tab " space"\tab "space"\tab -1\par f.\tab "happy"\tab "Happy"\tab  1\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344470}Solution to problem 5.7.{\*\bkmkend _Toc496344470}\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par #include <string.h>\par #include <ctype.h>\par \par void strupper (char str[1])\par \par /* Convert a string to uppercase                                   */\par /*                                                                 */\par /* Parameters:                                                     */\par /*    str - string to convert                                      */\par \par \{\par unsigned i;                     /* array index */\par \par i = 0;\par while (str[i] != 0) \{\par    str[i] = toupper(str[i]);\par    ++i;\par    \}\par \}\par \par \par void main(void)\par \par /* Main program.                                                   */\par \par \{\par char shortString[20], longString[30];\par \par strcpy(shortString, "Short Test.\\n");\par strupper(shortString);\par printf(shortString);\par strcpy(longString, "A somewhat longer string.\\n");\par strupper(longString);\par printf(longString);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344471}Solution to problem 5.8.{\*\bkmkend _Toc496344471}\par }\pard\plain \s21\qj\fi360\keepn\widctlpar\adjustright \f4\fs20\cgrid {The drawback in this program is that there is a maximum length beyond which the program cannot convert a string.  In the solution, the longest string that can be handled is 79 characters.  You could certainly extend this value, but using this technique, there will always be some maximum string length.  The other versions of the subroutines were limited only by the size of the index variable, and even that could have been turned into a long value, so that the subroutines would only be limited by available memory.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par #include <string.h>\par #include <ctype.h>\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par char *strlower (char str[1])\par \par /* Convert a string to lowercase                                   */\par /*                                                                 */\par /* Parameters:                                                     */\par /*    str - string to convert                                      */\par \par \{\par unsigned i;                     /* array index */\par char str2[80];                  /* string to return */\par \par i = 0;\par while (str[i] != 0) \{\par    str2[i] = tolower(str[i]);\par    ++i;\par    \}\par str2[i] = 0;\par return str2;\par \}\par \par \par void main(void)\par \par /* Main program.                                                   */\par \par \{\par char string[40];\par \par strcpy(string, "Apples are red, aren't they?\\n");\par printf(strlower(string));\par printf(string);\par \}\par }\pard\plain \widctlpar\adjustright \f4\cgrid {\par \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s1\qc\nowidctlpar\outlinelevel0\adjustright \b\f4\fs36\cgrid {{\*\bkmkstart _Toc496344472}Lesson Six{\*\bkmkend _Toc496344472}\par {\*\bkmkstart _Toc496344473}More About Arrays{\*\bkmkend _Toc496344473}\par }\pard\plain \qj\widctlpar\adjustright \f4\cgrid {\b\fs28 \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344474}The Shell Sort{\*\bkmkend _Toc496344474}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {There are a few basic tasks that show up over and over when you are writing real programs.  One of these is sorting.  If you use a program to keep track of your Christmas list, for example, you might want to sort the list by zip code so the Post office will let you send the Christmas cards out by bulk mail.  If you want to check your Christmas list to see who's been naughty and nice, though, and are trying to find E. Scrooge, you may want the same list sorted alphabetically by name.  This kind of information is often stored in an array, the new way of organizing information you learned in the last lesson.  In this section, you will learn how to sort an array so you can do things like put a mailing list in zip code order.\par There are many ways to sort an array; each has its advantages and disadvantages.  You will learn about other ways to sort an array later in the course, but we will start out now with one of the classic sorting methods.  While there are faster ways to sort large arrays, the shell sort is very easy to understand, very easy to implement, and actually works better on short arrays than the more complicated sorts you will learn later.\par The idea behind the shell sort is very simple.  You start by scanning the array from front to back.  At each step, you look to see if the value that comes after the current one in the array is smaller than the current array element.  If it is, you change them and continue scanning.  As an example, we will sort the following array by hand.\par \par }\pard \s21\qj\fi360\keepn\widctlpar\tx1080\tx2160\adjustright {\tab }{\ul index}{\tab }{\ul value}{\par }{\f6 \tab 0\tab 6\par \tab 1\tab 43\par \tab 2\tab 1\par }\pard \s21\qj\fi360\widctlpar\tx1080\tx2160\adjustright {\f6 \tab 3\tab 6\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par We start off with the first array element, and check to see if the value is smaller than the value in the second element of the array.  (The arrow shows which element of the array we are working on.)\par \par }\pard \s21\qj\fi360\keepn\widctlpar\tx1080\tx2160\adjustright {\tab }{\ul index}{\tab }{\ul value}{\par }{\f6 --->\tab 0\tab 6\par \tab 1\tab 43\par \tab 2\tab 1\par }\pard \s21\qj\fi360\widctlpar\tx1080\tx2160\adjustright {\f6 \tab 3\tab 6\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard \s21\qj\widctlpar\adjustright {In this case, 6 is smaller than 43, so we do nothing.  Moving on, we check the next element.\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard \s21\qj\fi360\keepn\widctlpar\tx1080\tx2160\adjustright {\tab }{\ul index}{\tab }{\ul value}{\par }{\f6 \tab 0\tab 6\par --->\tab 1\tab 43\par \tab 2\tab 1\par }\pard \s21\qj\fi360\widctlpar\tx1080\tx2160\adjustright {\f6 \tab 3\tab 6\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard \s21\qj\widctlpar\adjustright {This time, 1 is smaller than 43, so we exchange the values in the second and third spots, ending up with this array:\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard \s21\qj\fi360\keepn\widctlpar\tx1080\tx2160\adjustright {\tab }{\ul index}{\tab }{\ul value}{\par }{\f6 \tab 0\tab 6\par --->\tab 1\tab 1\par \tab 2\tab 43\par }\pard \s21\qj\fi360\widctlpar\tx1080\tx2160\adjustright {\f6 \tab 3\tab 6\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard \s21\qj\widctlpar\adjustright {Checking the third element, we find that 6 is also smaller than 43, so we again make a swap.\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard \s21\qj\fi360\keepn\widctlpar\tx1080\tx2160\adjustright {\tab }{\ul index}{\tab }{\ul value}{\par }{\f6 \tab 0\tab 6\par \tab 1\tab 1\par --->\tab 2\tab 6\par }\pard \s21\qj\fi360\widctlpar\tx1080\tx2160\adjustright {\f6 \tab 3\tab 43\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard \s21\qj\widctlpar\adjustright {We don't check the last element of the array, since there is nothing that follows it.\par }\pard \s21\qj\fi360\widctlpar\adjustright {At this point, we have successfully moved 43 to the last spot in the array, where it belongs, but the array is still not completely sorted.  To sort the array completely, we need to keep track of whether or not we swapped any array entries.  If we didn't need to swap any entries, then the array is sorted.  If we did swap two of the array elements, though, we need to make another pass over the array.  Our second pass makes one swap, moving 1 to the first array element.\par \par }\pard \s21\qj\fi360\keepn\widctlpar\tx1080\tx2160\adjustright {\tab }{\ul index}{\tab }{\ul value}{\par }{\f6 \tab 0\tab 1\par \tab 1\tab 6\par \tab 2\tab 6\par }\pard \s21\qj\fi360\widctlpar\tx1080\tx2160\adjustright {\f6 \tab 3\tab 43\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par Notice that we only want to swap elements of the array if the next element is actually less than the one we are inspecting.  If we swap elements when the values are equal, we would loop over our sample array over and over, swapping 6 with itself on each pass.\par Before diving into an example program that shows an actual sort, let's take a moment to examine one new concept that we will use that has nothing to do with arrays.  While we are sorting the array, one of the things we need to keep track of is whether or not we have swapped any entries in the array.  If we have, we need to make another pass through the array; if we have not swapped any entries, the sort is complete, and we can stop.  The normal way to do this in C is to set an int or unsigned value to 0 before you start through the loop, then set it to 1 (or some other non-zero value) if you make a swap.  You can then test this value directly in C's do-while loop, since C treats an integer value of 0 as false, and any non-zero integer value as true.  That's a pretty powerful concept, and we'll look at it more closely in a moment. \par \par }{\b \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b \par }\pard \s21\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {\b Listing 6.1\par \par }\pard\plain \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright \f6\fs20\cgrid {/* This program reads in an array of up to 100 float numbers.  It  */\par /* then sorts the array, and prints the numbers in order.  Numbers */\par /* are read until a zero is found.                                 */\par \par #include <stdio.h>\par \par #define MAX 100                 /* max # of floats to sort */\par \par float numbers[MAX];             /* array to sort */\par unsigned num;                   /* # of numbers actually read */\par \par \par void ReadEm (void)\par \par /* Read the list of numbers.                                    */\par /*                                                              */\par /* Variables:                                                   */\par /*    numbers - array of numbers read                           */\par /*    num - number of numbers read                              */\par \par \{\par float rval;                     /* number read from the keyboard */\par \par num = 0;\par do \{\par    scanf(" %f", &rval);\par    if (rval != 0.0) \{\par       numbers[num] = rval;\par       ++num;\par       \}\par    \}\par while (rval != 0.0);\par \}\par \par \par void Sort (void)\par \par /* Sort the list of numbers.                                    */\par /*                                                              */\par /* Variables:                                                   */\par /*    numbers - array of numbers read                           */\par /*    num - number of numbers read                              */\par \par \{\par float temp;                     /* temp variable; used for swapping */\par unsigned swap;                  /* has a swap occurred? */\par unsigned i;                     /* loop variable */\par \par do \{                            /* loop until the array is sorted */\par    swap = 0;                    /* no swaps, yet */\par    for (i = 0; i < num-1; ++i) \{ /* check each element but the last */\par                                  /*  if a swap is needed then...    */\par       if (numbers[i+1] < numbers[i]) \{\par          swap = 1;              /* note that there was a swap */\par          temp = numbers[i];     /* swap the entries */\par          numbers[i] = numbers[i+1];\par          numbers[i+1] = temp;\par          \}\par       \}\par    \}\par while (swap);\par \}\par \par \par void WriteEm (void)\par \par /* Write the list of numbers.                                   */\par /*                                                              */\par /* Variables:                                                   */\par /*    numbers - array of numbers read                           */\par /*    num - number of numbers read                              */\par \par \{\par unsigned i;                     /* loop variable */\par \par for (i = 0; i < num; ++i)\par    printf("%f\\n", numbers[i]);\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {void main (void)\par \par /* main program                                                 */\par \par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {\{\par ReadEm();                       /* read the list of numbers */\par Sort();                         /* sort the numbers */\par WriteEm();                      /* write the list of numbers */\par \}\par }\pard\plain \qj\fi360\widctlpar\adjustright \f4\cgrid {\par \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Listing 6.1 is your first sort, so it is well worth your time to study how it works carefully with the debugger.  Bring up the variables window while you are in the Sort subroutine, and display the first five entries or so.  (Remember, you can click on the arrows to show the global variables while you are in a subroutine, and to switch back to the local variables to monitor the temp and swap variables.)  Try the program with a list of five numbers that are the same.  Try a list of five numbers that are already sorted.  You might also try the values from the sorting example we worked at the start of this section; the values will be handled internally as real numbers, but as you learned in lesson 3, the scanf function can read an integer and convert it to a real number.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 6.1.}{  As you learned in the last lesson, the comparison operators can work on characters as well as they can on integers or real numbers.  Use this fact to modify the Reverse sample from lesson 5 so it will sort the characters, rather than printing them in reverse order.\par \par }{\b Problem 6.2.}{  The sample program from this section sorts an array so that the smallest number comes first.  Sometimes we want the largest number first.  Change the sample to it sorts the values with the larges first, proceeding to the smallest.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344475}Boolean Values{\*\bkmkend _Toc496344475}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {In the sort sample, you got a first look at the way C actually deals with values that are either true or false, something programmers call boolean values.  In C, boolean values are handled using integers.  When you test to see if a is less than 4 with the statement\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {if (a < 4)\par }\pard \s23\qj\fi360\widctlpar\adjustright {   ...\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {C is actually comparing a to 4, and returning an integer result, just as a+4 would return an integer result.  If a is, in fact, less than 4, C returns a non-zero value (1 in most implementations of C, including ORCA/C), and if a is greater than or equal to 4, the result is zero.  In C, then, 0 is false, and anything else is true.\par }\pard \s21\qj\fi360\widctlpar\adjustright {While the values are just integers, programmers often refer to expressions that are returning a true or false result as boolean expressions.  To make things a little more obvious in the program, you may also see definitions like\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#define BOOLEAN int\par #define FALSE 0\par #define TRUE 1\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {in a C program.  This just gives you a slightly more mnemonic way of dealing with integers that are being used as boolean values; it's a mental crutch, like comments, that makes the program a little easier to read and understand.\par }\pard \s21\qj\fi360\widctlpar\adjustright {Now we can put some of these ideas together to rapidly expand what we can do with the C language.  For example,\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {numbers[i+1] < numbers[i]\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {is a boolean expression, returning an integer value, so we can assign it to an integer variable.  If less is an int variable, then the assignment\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {less = numbers[i+1] < numbers[i];\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {works perfectly well in C.  Also, as you saw briefly in the sort sample, you can use this int variable, or any other integer, for that matter, as the condition in a do-while loop, while loop, or if statement.\par }\pard \s21\qj\fi360\widctlpar\adjustright {Unless it is an election year, most people wouldn't think that it makes much sense to add true to false, or subtract true from true.  (Since C handles boolean values as integers, though, you can actually do this in C, but good programmers tend not to do this sort of thing.)  On the other hand, it makes perfect sense to ask if rich and thin are true, or if tall or slim is true.  It also makes sense to say that something is not false.  These easy to understand concepts give rise to three operators that work on integers in a way that is consistent with the way we think about true and false.  These operators are || (logical or), && (logical and) and ! (logical negation, often thought of as not).  Note that the or operator is two | characters, not one, and the and operator is two & characters, not one.  It is very important that you remember to use || and &&, since C also has & and | operators that do something else.  The single-character operators, & and |, are called bitwise operators.  You will learn about these later.\par Like the familiar math operators +, -, * and /, the && and || operators work on two values.  These values can actually be just about any type you have learned so far \endash  any type, in fact, except for an array or a function.  To be more specific, the types can be any of the signed or unsigned integers, float, double, char, or even a pointer.  Each of these values is treated as false if it is 0 (0.0 for float and double, and NULL for pointers), and true if it is not zero.  The && operator (and operator) returns true if both of the operands are true.  This is the same way we use the word and in the English language when we are talking about logical consequences.  For example, I will drive a Porsche if I get rich }{\i and}{ if my wife says it's OK.  If either condition is not met, there is grave doubt about my future as a street racer, at least in a Porsche.  The || operator (or operator) also works the way we use the word or in the English language.  For example, Dan Quale will be president if he is elected in an election }{\i or}{ if George Bush dies in office.  Both the && and || operators return an int value that is 0 if the result is false, and non-zero if the result is true.  Expressing these concepts in C, we get:\par \par }\pard\plain \s23\qj\widctlpar\adjustright \f6\fs20\cgrid {getAPorsche = rich && wifeApproves;\par presidentQuale = \par    QualeElected || BushDies;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The ! operator (not operator) is the boolean form of negation.  It returns the opposite of the argument.  Again, it works just like the word not is used in English, and again, it also works on any of the types that the && or || operators support.  I'm sure you have heard someone say, "that is not true!"  Well, in C, as in English, not true is the same as false.  For example, !a will be 0 if a started out as non-zero, and it will be some non-zero value if a started out as zero.  The not operator is very handy in conditions.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {if (!rich)\par }\pard \s23\qj\fi360\widctlpar\adjustright {   printf("Keep the Datsun.\\n");\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par As with math operators, boolean operators use operator precedence to determine the order they are applied to the arguments.  The ! operator has the highest precedence, and is applied first.  Next comes &&, followed by ||.  The precedence of the operators, and their relationship with the other operators, can be found in the ORCA/C reference manual, or any other good C reference manual.\par Frankly, though, I don't recommend that you depend on precedence when you are writing boolean expressions.  Most people who are familiar with programming languages or algebra are not surprised (which, as you now know, means they are unsurprised) to find out that\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {1+2*3\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {is 7, rather than 9.  On the other hand, there is no general agreement on what\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {truth || beauty && justice\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {means.  For that reason, I would recommend using parenthesis in your boolean expressions, even when they are not technically necessary, as a form of comment.  With the parenthesis in the expression, it is easy for anyone to read the expression and see what you mean.\par }\pard \s21\qj\fi360\widctlpar\adjustright {In addition to &&, || and !, there are six other hybrid operators you are already familiar with that take numeric arguments and return a boolean result.  The result of these operators can be used in an expression anywhere an int variable can be used, and, like the other boolean operators, the result is a zero for false, and some non-zero value for true.  The operators, of course, are the six comparison operators:\par \par }\pard\plain \s23\qj\fi360\widctlpar\tx900\tx1440\tx1980\tx2520\tx3060\tx3600\adjustright \f6\fs20\cgrid {<\tab >\tab <=\tab >=\tab !=\tab ==\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par I mentioned that ORCA/C, like most C compilers, will return 1 for the result of a boolean operator if the result is true, but you may have noticed that I was very careful to say "0 for false, and non-zero for true" in all of the places where I described the result of a boolean operator.  This is one of those places that separates the good C programmers from the not-so-good programmers, and one of the reasons why C programs are only portable if you work at it a bit.  While ANSI C requires a value of 1 for true, not all compilers are ANSI compilers.  Historically, the value -1 has also been used a lot for true.  In good programs, you should handle boolean values the same way C does:  0 is false, and anything else is true.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 6.3.}{  Back in lesson 3, we used two do-while loops to choose a random number, like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {do\par    do\par       value = rand();\par    while (value <= 0);\par while (value > 100);\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {While this was a good way to learn a little about nested do-while loops, it is terrible C.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Use what you now know about boolean expressions to combine the two do-while loops into a single do-while loop.  With this accomplished, write a program that selects and prints ten random integers in the range 1 to 100.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }{\b Problem 6.4. }{ The printf library function doesn't have a way to write a boolean value as true or false.  Write a function called PrintBool that will print the string false if you pass it a zero, and true if you pass anything but a zero.  Test your function by calling it with the values 0, 1, and -1.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344476}Arrays of Arrays{\*\bkmkend _Toc496344476}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {So far, we have looked at arrays of integers, arrays of reals, and arrays of characters, but you can actually define an array of any type in C, even an array of arrays.  For example, as the following program shows, we can have an array of strings, which is actually an array of arrays of characters.\par This may seem a bit complicated at first, but the idea is actually very simple and very powerful at the same time.  C allows you to have an array of absolutely anything that you can define as a variable.  Putting these ideas together, it is easy to create a program that can sort an array of names, rather than an array of numbers.  For example, a string that can hold up to 10 characters is defined in C as\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {char str[11];\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par To define an array of 20 strings, each of which is able to hold 10 characters, we just add another array subscript before the first:\par \par }{\f6 char strings[20][11];\par }{\par You can access either the strings or the individual characters, depending on how many subscripts you specify.  For example, to compare the third string in the array to "Mike", you could use\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {strcmp(strings[2], "Mike");\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {To print the fourth character of the second string, you would use\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {printf("%c", strings[1][3]);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par These ideas are put to use in the program shown in listing 6.2.  With these simple additions to your knowledge of arrays, there isn't anything really new about the program, but you should certainly take the time to use the debugger for a closer look at it.  The first problem in this section will give you some things to try.\par \par }{\b \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b \par }\pard \s21\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {\b Listing 6.2\par \par }\pard\plain \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright \f6\fs20\cgrid {/* This program reads in an array of up to 100 strings, each of    */\par /* which can have up to 100 characters.  It then sorts the array,  */\par /* and prints the numbers in order.                                */\par /*                                                                 */\par /* Strings consist of whitespace separated words.  Once you have   */\par /* typed all of the words you want to sort, enter the string "#".  */\par \par #include <stdio.h>\par #include <string.h>\par \par #define MAX 100                 /* max # of strings to sort */\par #define SIZE 100                /* max size of a string */\par \par char strings[MAX][SIZE+1];      /* strings to sort */\par unsigned num;                   /* # of strings actually read */\par \par \par void ReadEm (void)\par \par /* Read the list of strings.                                    */\par /*                                                              */\par /* Variables:                                                   */\par /*    strings - array of strings read                           */\par /*    num - number of strings read                              */\par \par \{\par char sval[SIZE+1];              /* string read from keyboard */\par \par num = 0;\par do \{\par    scanf("%s", sval);\par    if (strcmp(sval, "#")) \{\par       strcpy(strings[num], sval);\par       ++num;\par       \}\par    \}\par while (strcmp(sval, "#"));\par \}\par \par \par void Sort (void)\par \par /* Sort the strings                                             */\par /*                                                              */\par /* Variables:                                                   */\par /*    strings - array of strings to sort                        */\par /*    num - number of strings in the array                      */\par \par \{\par char temp[SIZE+1];              /* temp variable; used for swapping */\par unsigned swap;                  /* has a swap occurred? */\par unsigned i;                     /* loop variable */\par \par do \{                            /* loop until the array is sorted */\par    swap = 0;                    /* no swaps, yet */\par    for (i = 0; i < num-1; ++i) \{ /* check each element but the last */\par                                  /*  if a swap is needed then...    */\par       if (strcmp(strings[i+1], strings[i]) < 0) \{\par          swap = 1;              /* note that there was a swap */\par          strcpy(temp, strings[i]); /* swap the entries */\par          strcpy(strings[i], strings[i+1]);\par          strcpy(strings[i+1], temp);\par          \}\par       \}\par    \}\par while (swap);\par \}\par \par \par void WriteEm (void)\par \par /* Write the list of strings.                                   */\par /*                                                              */\par /* Variables:                                                   */\par /*    strings - array of strings read                           */\par /*    num - number of strings read                              */\par \par \{\par unsigned i;                     /* loop variable */\par \par for (i = 0; i < num; ++i)\par    printf("%s\\n", strings[i]);\par \}\par \par \par void main (void)\par \par /* Main program                                                 */\par \par \{\par ReadEm();                       /* read the list of strings */\par Sort();                         /* sort the strings */\par WriteEm();                      /* write the list of strings */\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard\plain \qj\widctlpar\adjustright \f4\cgrid {\sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }{\b Problem 6.5.}{  Try to apply the rules for comparing strings to sort the following array of strings by hand.  After you give it your best shot, use the sample program to sort the strings.  If you were wrong, review the rules until you understand why.\par \par }\pard \s24\qj\fi-360\li720\widctlpar\adjustright {\f6 Ran\par Mike\par 123\par Run\par microphone\par 1212\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\f6 \par }{\b Problem 6.6.}{  In this problem, you will develop a program to play the game Hangman.  This is a hard problem, easily the hardest so far in this course, and you should expect to take quite a bit of time on it.  You will need to spend some time planning the program and thinking about what it will do before you start writing it.  In addition, plan on reading this problem at least twice: once to get an idea about what is going on, and once more to fill in the details.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Just in case you grew up somewhere where this game wasn't played, or you grew up long enough ago that your little grey cells have dumped the rules of the game in favor of more recent information, we'll start off by giving the rules of the game.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Hangman is a word guessing game.  When the game starts, you are told how many letters are in the word.  The computer will tell you this by displaying one dash for every letter in the word.  You then guess a character.  If the character is in the word, you are told where.  If the letter appears more than one time in the word, you are told about all of the places where the character appears, not just the first.  The computer game will show you the positions by writing the word after each guess, showing any characters you have guessed correctly, and displaying a dash for any you still have not guessed.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {If the character you guess is not in the word, your player gets one step closer to a meeting with Jack Ketch.  On the first wrong guess, your head is in the noose.  The second wrong guess adds a body to the figure.  The next four wrong guesses add two arms and two legs.  After six wrong guesses, the game ends with the character hung.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Your program will be developed in stages.  I suggest that you write the program and get it to work after each of the following steps, rather than trying to write the entire program all at once.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\fi-360\li720\widctlpar\adjustright {1.\tab Start your program with a procedure that fills in the array of words that the player can guess.  The array should be declared globally.  Use a #define to declare a constant called MAXWORDS to indicate how many words are in the array.  Another global constant called MAXCHARS tells how many characters can be in each word.  Add a subroutine to print the array and run the program.  The subroutine to print the array is only used to check the results so far; once you are sure that you are filling the array correctly, remove the subroutine that prints the array.\par \par 2.\tab Create a subroutine that asks for a random number seed, and use it to initialize the random number generator by calling the srand() function.  Add the RandomValue subroutine from lesson 4 to your program.  Test your work so far by calling RandomValue with a maximum value of MAXWORDS, and printing the corresponding word in the word list.\par \par 3.\tab Add a new subroutine that plays hangman.  You can try this on your own, or follow this basic outline:\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\fi-360\li1080\widctlpar\adjustright {a.\tab Declare an array of integers called found that is MAXCHARS long.  You will use this array to keep track of which characters have actually been found by the player.  Start by initializing each element of the array to false (0).  The proper use of this array is central to getting your program to work, so we will take a closer look at it.\par \par }\pard \s24\qj\li1080\widctlpar\adjustright {To understand how the found array is used, let's play a short game of hangman, using the word "oops".  The word will be in an array of strings called words, and we will assume that the particular word we want has an index of w.  We'll also assume that we have already called strlen to find out how long the word is, and saved the result: in our example, though, we'll gloss over this by just dealing with the first four elements of word[w] and found.  Once found is initialized, then, our arrays look like this:\par }\pard \s24\qj\fi-360\li1080\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {found[0] = 0\tab word[w][0] = 'o'\par found[1] = 0\tab word[w][1] = 'o'\par found[2] = 0\tab word[w][2] = 'p'\par found[3] = 0\tab word[w][3] = 's'\par }\pard\plain \s24\qj\fi-360\li1080\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li1080\widctlpar\adjustright {Let's say the player guesses 'p'.  We would scan the array, setting found[2] to 1, indicating that the character has been found.  If the player guesses a letter that is not in the array, like 'e', we do nothing.  If the player guesses a letter like 'o' that is in the array more than one time, we set all of the corresponding elements of found to the proper value; in this case, found[0] and found[1] would be set to 1.\par }\pard \s24\qj\fi-360\li1080\widctlpar\adjustright {\par b.\tab Declare a variable called wrong, and initialize it to zero.  This variable is used to keep track of how many wrong guesses the player has made.\par \par c.\tab Declare a variable called done, which you initialize to 0 (false).  This variable controls a do-while loop that you should create; this is where the action takes place.  The do-while loop should loop until the done variable is set to true.\par \par d.\tab Choose a word, using the same ideas developed in the last step.\par \par e.\tab At the start of the do-while loop, print the word.  You will loop over the array containing the word, printing the letter in the word if the corresponding element of the found array is true, and printing a '-' character if it is false.  The effect is to print one character for each character in the word the player is trying to guess.  If the player has already correctly guessed the letter, you print it; if not, you print a '-' as a place holder.\par \par f.\tab Get a character from the player.  Scan the string to see if the character is in the word the player is trying to guess.  If so, you need to set the proper elements of the found array to indicate that the character has been found.  If not, you need to increment the variable wrong.\par \par g.\tab Scan your found array to see if there are any more characters to find.  If not, the game is over: print the word, along with a congratulatory statement, and set done to true so the program will drop out of the loop.\par \par h.\tab If you incremented wrong, you need to print some sort of message.  Do this with a series of if statements: if wrong is one, print something like "<ch> is not in the word: your head is in the noose!" and move on.  If wrong is 6, the game is over.  Print something like "Sorry, Jack Ketch got you!" followed by the correct word, then set done to true so you drop out of the loop.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\fi-360\li720\widctlpar\adjustright {4.\tab Add a loop in your main program that lets the player play more than one time by asking if they want to continue whenever the program returns from the subroutine written in step 3.  Do this by creating a function called PlayAgain that asks the player if he wants to play another game, and returns true (non-zero) or false (zero), as appropriate.  Use boolean expressions to handle character responses of 'y', 'Y', 'n', or 'N'.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344477}Trigonometry Functions{\*\bkmkend _Toc496344477}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {In the next section, we are going to put arrays to use by looking at how objects are rotated in the graphics window.  In the process, we will be making use of some trigonometry functions.  Trigonometry is complicated enough by itself.  Tossing it at you with no warning in the process of talking about arrays seems a bit unfair, so we will discuss the trigonometry now.\par Before we go any further, though, I want to stop the panic rising in those of you who don't like math.  It's only fair to point out to those who do like math, or at least, who have learned some math and deal with it from time to time, how to do the math in C.  If you don't know trigonometry, and don't really care, then don't worry too much about this section.  Go ahead and read it to get an idea what we are talking about, but if you don't know what a sine is, it isn't that important to your understanding of the programming portions of the next three sections.\par In all of the samples and problems in the rest of this lesson, all of the math will be done for you.  If you understand it, great.  If not, treat it as a pure programming problem, and just implement the equations you are given.\par Trigonometry is the algebra of angles.  For example, you can use trigonometry to figure out how tall a building is based on how far away from the building you are, and what the angle is between the ground and the top of the building.  (Assuming, of course, that the building is straight and the ground level.)\par When most of us think of angles, we think in terms of degrees.  Ninety degrees, for example, is a right angle, or the angle between the sides of a box.  A full circle is 360 degrees.  Unfortunately, C uses radians to deal with angles, not degrees.  The reason for this is tied up in the way the basic trigonometry functions are calculated; it's not really important to know why C uses radians, only to remember that it does.  In radians, a full circle is 2\u960\'b9 radians, or about 6.28319 radians.  A right angle (90 degrees) is \u960\'b9/2 radians, or about 1.57080 radians.\par One of the first things we must do, then, is figure out how to convert from the degrees of every day life to the radians used by C, and back again.  To convert from degrees to radians, we can multiply by \u960\'b9, and divide by 180.  The opposite operation converts back.  The following two subroutines package these ideas neatly; we can use them in our programs to do all of our conversions.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {float DtoR(float degrees)\par \par /* Convert from degrees to */\par /* radians.                */\par \par \{\par return 0.01745329 * degrees;\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {float RtoD(float radians)\par \par /* Convert from radians to */\par /* degrees.                */\par \par \{\par return radians * 57.295780;\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par  The basic trigonometry functions are sine, cosine, tangent, and the inverses of these functions, arcsine, arccosine, and arctangent.  C gives you these functions, calling them sin, cos, tan, asin, acos and atan.  There is even a special, two-argument form of the arctangent function that can handle the entire unit circle, rather than the 180 degrees you are limited to by a single argument.  All of the functions are defined in the math.h header file, which has quite a few other trigonometric, logarithmic, and general use functions besides these basic ones.\par The sin, cos and tan functions accept an angle, expressed in radians, as the argument.  They return the sine, cosine or tangent of the argument.  The following program makes use of the tan function to determine the height of a building.  The program assumes that the building is straight (it would not work on some buildings in Pizza, Italy), and that the observer is an the same height as the bottom of the building.  This assumption means that there is a right angle between the side of the building and the line from the person who measures the angle and the base of the building.  The distance to the building is the distance from the person measuring the angle.\par I have used the same idea in a hand-held calculator to find the approximate altitude reached by a model rocket, so you can see that there are some extremely important applications awaiting this program!\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Find the height of a    */\par /* building.               */\par \par #include <stdio.h>\par #include <math.h>\par \par float DtoR(float degrees)\par \par /* Convert from degrees to */\par /* radians.                */\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {\{\par }\pard \s23\qj\fi360\widctlpar\adjustright {return 0.01745329 * degrees;\par \}\par \par \par void main(void)\par \par /* main program */\par \par \{\par float distance; /* distance to */\par                 /*building     */\par float angle;  /* angle between */\par               /* base & top    */\par \par \par printf("This program finds "\par    "the height of\\n"\par    "a building.  You must supply"\par    " the\\n"\par    "distance to the building and"\par    "the\\n"\par    "angle between the base and"\par    " top of\\n"\par    "the building (in degrees)."\par    "\\n\\ndistance=");\par scanf(" %f", &distance);\par printf("angle=");\par scanf(" %f", &angle);\par printf("height = %f\\n",\par    tan(DtoR(angle))*distance);\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par There is one new programming trick shown here: in C, you can actually create a big string by coding a number of short strings one right after the other.  The first printf statement shows this.  You can use this idea as I have, to fit long strings into a limited amount of space, or you can use the idea to break a number of lines up on separate lines of your program while still making your program efficient.  After all, it takes time to call the printf function, and by creating this long string, we only have to call printf once, instead of one time for each line.\par The legal range for the trigonometry functions, as well as the range of values returned, has more to do with mathematics than with programming, so we won't go into them here.  You can check the C reference manual for details.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344478}Converting Types{\*\bkmkend _Toc496344478}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {As you start to use float values more and more, you will occasionally come across situations where you need to convert from one type to another.  The next section presents one of these situations, so we are going to take a moment to look at type conversions now.  For example, you may have a float value, and want to convert it to an integer.  For the most part, C does this sort of thing for you automatically.  For example, if f is a float variable, i is an integer variable, and l is a long variable, then all of these assignments are legal:\par \par }{\f6 i = f;\par f = l;\par l = i;\par i = l;\par }{\par What C does in each of these cases is about what you would expect and hope.  When you assign an integer value to another integer that is a different size, C quietly converts the integer from one type to another.  If you assign a long integer to an integer, and the long integer is too big to fit in an integer, C can't do the conversion, but it does still do the assignment, lopping off part of the larger number.  This can be a bit of a problem, but like all aspects of C, it is just something you have to be aware of, and check for if there is a possibility of a mistake.\par When you assign an integer \-\endash  long or normal sized \endash  to a float value, C does an exact conversion, assuming that is possible.  There are a few cases, of course, where it is not possible.  For example, if you convert a long value of 123456789 to a float value, you will loose the last two digits, since float numbers are only accurate to seven significant figures.\par When C converts a float value to a long or int value, the float value is rounded to the integer closest to the float value.  Assigning 1.2 to an int would set the int to 1, while assigning 1.7 to an int would set it to 2.  Again, of the number is too large to fit in the variable, the result is not valid.\par In most situations, you can just let C take care of these details for you.  There are a few programming situations, though, when you want to force the conversion for yourself.  In these situations, you can use a type cast.  A type cast is coded as a type, enclosed in parenthesis, appearing right before a value, like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {(type) value\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {Type casts convert values using the same rules that C uses when you assign one type of value to another type of variable.\par }\pard \s21\qj\fi360\widctlpar\adjustright {For example, to convert a float value to an integer, so you can print it using the %d conversion specification, you would write this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {printf("%d\\n", (int) f);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par There are three relatively common reasons for using a type cast to convert between number types, as well as a few other reasons for type casts of other types you will run across later.  The first situation is to prevent a number overflow.  As an example, let's assume you are going to multiply two int values, and store the results in a long value.  If you write the program like this:\par \par l = i*j;\par \par the program will work fine if the result is small enough to fit in an integer, but C is doing an int multiply, so if i contained 10000, and j contained 10, the answer would not be correct.  Casting one of the integers to a long, like this:\par \par }{\f6 l = i * (long) j;\par }{\par }\pard \s21\qj\widctlpar\adjustright {gives an entirely different result.  This time, j is converted to a long value, and since one of the values is long, C uses a long multiply.\par }\pard \s21\qj\fi360\widctlpar\adjustright {You might remember a problem from lesson 3, where you compared the speed of float math with the speed of int math, and found out how much faster integer calculations can be performed.  This is the second reason to use type casting: to force the conversion from a float type to an int type quickly, so that the resulting calculations are also quicker.  For example,\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {i = ((int) f) / 10;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {is faster than letting C do the calculation with no guidance.  In this statement, the float value f is converted to an integer right away, then an integer divide is used.  Without the type cast, you would get the same answer, but it would take longer, since a floating-point divide would be performed, and the result converted to an integer.  This isn't always the correct thing to do, of course, since not all calculations give the same answer when you use integer calculations, but the trick is worth keeping in mind for the situations where it does work.  If you need some extra convincing, refer back to lesson 3 and check out the execution times again.\par }\pard \s21\qj\fi360\widctlpar\adjustright {Finally, we come to the situation you will face in the next section.  The toolbox .h files define the tool calls using K&R parameters, as discussed at the end of lesson 4.  As a result, you must make sure that you pass exactly the type of parameters the toolbox calls expect.  If you calculate a coordinate for the graphics screen using float variables, for example, these values must be converted to int values before being used as parameters to the familiar graphics calls MoveTo and LineTo.  If x and y are float variables, this would be the correct way to plot a point at x, y:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {MoveTo ((int)x, (int)y);\par }\pard \s23\qj\fi360\widctlpar\adjustright {LineTo ((int)x, (int)y);\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344479}Rotation{\*\bkmkend _Toc496344479}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Over the past three lessons, you have learned a data type \-\endash  character \endash  and two powerful new concepts \endash  arrays and subroutines.  You also learned a powerful programming idea, the sort.  In this section, we are going to put some of those new ideas to use to develop an equally powerful idea for dealing with pictures: rotation.  Rotation is a very powerful concept in graphics programs.  Using rotation, you can create beautiful spiral shapes, draw circles, spin a shape, or flip characters around to a new orientation.\par The method we will use to rotate an object is to rotate each of the points in the object individually.  In fact, we use a separate formula to calculate the new horizontal coordinate and vertical coordinate.  If you know enough trigonometry to figure out why the following formulas work, it might be fun for you to work them out for yourself.  If you are curious, but don't already know how to get the formulas on your own, there are many fine books on computer graphics that can point you in the right direction.  Deriving the formulas is a bit beyond the scope of this course, though.\par Of course, even if you don't know why the math works, it is important for you to be able to picture what the subroutine does.  Basically, to rotate and object, we rotate each of the points in the object.  To understand how a point is rotated, imagine that we attach the point to the origin with a rigid rod.  (The origin is the place in the graphics window where both the horizontal and vertical coordinates are zero.  In all of our programs, that is the top left corner of the graphics window.)  We will let the point move, and we will let the rod spin around the origin, but the rod keeps the point exactly the same distance from the origin no matter where we move the point.  Spinning the point completely around the origin would move the point in a circle.\par To rotate the point, then, we need to know where the point is, and what angle we should rotate the point through.\par }\pard \s21\qc\fi360\widctlpar\adjustright {\f12 {\pict{\*\picprop\shplid1027{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 268435473}}{\sp{\sn fFilled}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex99\picscaley99\piccropl1475\piccropr0\piccropt1269\piccropb0\picw258\pich222\picwgoal5160\pichgoal4440\macpict\bliptag-473854302\blipupi72{\*\blipuid e3c18ea272e7a9268484674f9899abaa}05740007000700e501091101a0008201000a0007000700e50109500013001c00a400ad0a000000000000000034000a0013005c00bf09000000000000000038a000a0a000a5840134005b0066007f00d0005b006600d07fff005c006600697fff005d0069006c7fff005e006c006f7fff005f006f00727fff0060007200757fff0061007500787fff00620078007b7fff0063007b007e7fff0064007e00817fff0065008100847fff0066008400877fff00670087008a7fff0068008a008d7fff0069008d00907fff006a009000937fff006b009300967fff006c009600997fff006d0099009c7fff006e009c009f7fff006f009f00a27fff007000a200a57fff007100a500a87fff007200a800ab7fff007300ab00ae7fff007400ae00b17fff007500b100b47fff007600b400b77fff007700b700ba7fff007800ba00bd7fff007900bd00c07fff007a00c000c37fff007b00c300c67fff007c00c600c97fff007d00c900cc7fff007e00cc00cf7fff007f00cf00d07fff7fff22005b00646c242300dc239400a000a1a000a0a000a584029c005b006400b500b5005b006400657fff005c006500667fff005d006600677fff005e006700687fff005f006800697fff00600069006a7fff0061006a006b7fff0062006b006c7fff0063006c006d7fff0065006d006e7fff0066006e006f7fff0067006f00707fff0068007000717fff0069007100727fff006a007200737fff006b007300747fff006c007400757fff006d007500767fff006f007600777fff0070007700787fff0071007800797fff00720079007a7fff0073007a007b7fff0074007b007c7fff0075007c007d7fff0076007d007e7fff0077007e007f7fff0079007f00807fff007a008000817fff007b008100827fff007c008200837fff007d008300847fff007e008400857fff007f008500867fff0080008600877fff0081008700887fff0083008800897fff00840089008a7fff0085008a008b7fff0086008b008c7fff0087008c008d7fff0088008d008e7fff0089008e008f7fff008a008f00907fff008b009000917fff008d009100927fff008e009200937fff008f009300947fff0090009400957fff0091009500967fff0092009600977fff0093009700987fff0094009800997fff00950099009a7fff0097009a009b7fff0098009b009c7fff0099009c009d7fff009a009d009e7fff009b009e009f7fff009c009f00a07fff009d00a000a17fff009e00a100a27fff009f00a200a37fff00a100a300a47fff00a200a400a57fff00a300a500a67fff00a400a600a77fff00a500a700a87fff00a600a800a97fff00a700a900aa7fff00a800aa00ab7fff00a900ab00ac7fff00ab00ac00ad7fff00ac00ad00ae7fff00ad00ae00af7fff00ae00af00b07fff00af00b000b17fff00b000b100b27fff00b100b200b37fff00b200b300b47fff00b300b400b57fff00b5006400b57fff7fff23515a23af002300a6a000a1340052000a00d100653809ffffffffffffffff2100e2006420005b0064005b0106a100960006050000000232a1009a0008fffd000000090000a000980300140d000a2b5c550528302c3029a00099a000970affffffffffffffff3400ac00ac00b600b63822005b0064485122005b00646c24a000a0a000a5840058007300a2007b00aa007300a700a97fff007400a500a77fff007500a300a57fff007600a200a300a900aa7fff007700a200a47fff007800a400a57fff007900a500a77fff007a00a700a97fff007b00a900aa7fff7fff22007200a9f80423090523fff7a000a1a100960006050000000232a1009a0008fffd0000000c0000a000982b696005706f696e74a00099a00097a100960006050000000232a1009a0008fffd0000000a0000a0009828008a00aa05616e676c65a00099a00097a00083ff00}}{\par }\pard\plain \qc\fi360\widctlpar\adjustright \f4\cgrid {\par }\pard\plain \s21\qc\fi360\widctlpar\adjustright \f4\fs20\cgrid {Figure 6.1:  How a Point is Rotated\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par Once we know the coordinates of the point and the angle, we can figure out where the new point is using these formulas, shown here in C:\par \par }\pard\plain \s23\qj\widctlpar\adjustright \f6\fs20\cgrid {\fs18 newX = oldX*cos(angle) + oldY*sin(angle);\par newY = oldY*cos(angle) - oldX*sin(angle);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Of course, this would be pretty worthless if we could only rotate a point around the top left corner of the graphics window.  What we really want to do is to be able to rotate the point around some other point we provide the rotation subroutine.  Just to make it easier to talk about what we are doing, we will call the point we want to rotate P, and the point we want to rotate P around O.  To rotate the point, then, we can subtract O from each of the points.  This effectively moves O to the origin, and P to a place that is in the same direction and at the same distance from O that it was when we started.  Since O is now the origin, we can rotate the point, then move them back to their new locations by adding O to each point again.  In the actual subroutine, we don't really need to move the original point around, but the idea is the same.\par There is one last problem that we have to deal with to rotate an object.  As you have already found out, a pixel on the Apple IIGS graphics screen is taller than it is wide.  We are going to deal with this important issue by keeping track of our object using real variables in a perfect, imaginary graphics window where moving one unit horizontally looks the same as moving one unit vertically.  We will use two constants, XSCALE and YSCALE, to convert one of our perfect points to the coordinate system used in the graphics window.  Of course, we also need to convert the real number to an integer, something C will not do for us automatically.\par These ideas are (finally!) put to use in the program in listing 6.3, which spins a square in the graphics window.\par }{\lang1024 {\shp{\*\shpinst\shpleft-144\shptop0\shpright9360\shpbottom3168\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz26\shplid1158{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 3866624}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s21\qc\fi360\widctlpar\adjustright \f4\fs20\cgrid {{\pict{\*\picprop\shplid1035{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 268435473}}{\sp{\sn fFilled}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex100\picscaley100\piccropl0\piccropr0\piccropt0\piccropb0\picw365\pich120\picwgoal7300\pichgoal2400\macpict\bliptag-201354868\blipupi72{\*\blipuid f3ff918ce79873af86bed6b5c9138093}01b400070007007f01741101a0008201000a00070007007f017422000a000a005a22000a000a5a0022000a0088005a22000a00885a0022000a0106005a22000a01065a0034003c002a0041002f3834004e004e005300533834000a00880010008e3834000a00ac001000b23834003c01260041012b3834003c014a0041014f38a000aa610000000100140015007a0030220040002ee0d1a000ada000aa610012002500260039007a00302200520052e0d1a000ada000ab61000000a8001400bc009c003022001200b1000fa000ada000ab6100360121004a0135012e00302200390126e0d1a000ada000ab6100360145004a0159012e0030220039014ae0d1a000ada100960006050000000232a1009a0008fffd000000330000a000980300140d000a2b0b79175374657020313a204d6f76652074686520506f696e7473a00099a00097a100960006050000000232a1009a0008fffd0000001f0000a00098297e0e5374657020323a20526f74617465a00099a00097a100960006050000000232a1009a0008fffd000000350000a00098297e165374657020333a204d6f7665205468656d204261636ba00099a00097a00083ff00}}{\par \par Figure 6.2:  Rotating About An Arbitrary Point\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8218\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s21\qc\fi360\widctlpar\adjustright \f4\fs20\cgrid {{\pict{\*\picprop\shplid1035{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 268435473}}{\sp{\sn fFilled}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex100\picscaley100\piccropl0\piccropr0\piccropt0\piccropb0\picw365\pich120\picwgoal7300\pichgoal2400\macpict\bliptag-201354868\blipupi72{\*\blipuid f3ff918ce79873af86bed6b5c9138093}01b400070007007f01741101a0008201000a00070007007f017422000a000a005a22000a000a5a0022000a0088005a22000a00885a0022000a0106005a22000a01065a0034003c002a0041002f3834004e004e005300533834000a00880010008e3834000a00ac001000b23834003c01260041012b3834003c014a0041014f38a000aa610000000100140015007a0030220040002ee0d1a000ada000aa610012002500260039007a00302200520052e0d1a000ada000ab61000000a8001400bc009c003022001200b1000fa000ada000ab6100360121004a0135012e00302200390126e0d1a000ada000ab6100360145004a0159012e0030220039014ae0d1a000ada100960006050000000232a1009a0008fffd000000330000a000980300140d000a2b0b79175374657020313a204d6f76652074686520506f696e7473a00099a00097a100960006050000000232a1009a0008fffd0000001f0000a00098297e0e5374657020323a20526f74617465a00099a00097a100960006050000000232a1009a0008fffd000000350000a00098297e165374657020333a204d6f7665205468656d204261636ba00099a00097a00083ff00}}{\par \par Figure 6.2:  Rotating About An Arbitrary Point\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx-144\dpy0\dpxsize9504\dpysize3168\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{\par }{\b \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b \par }\pard \s21\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {\b Listing 6.3\par \par }\pard\plain \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright \f6\fs20\cgrid {/* Rotate a square in the graphics window.       */\par /*                                               */\par /* This program makes use of two constants,      */\par /* XSCALE and YSCALE, to decide how to convert   */\par /* from the real numbers used to represent the   */\par /* points of the cube into the integer           */\par /* coordinates used by QuickDraw.  These values  */\par /* will convert from inches to pixels in 640     */\par /* mode on a 12" monitor.                        */\par \par #include <quickdraw.h>\par #include <math.h>\par \par #define XSCALE 86               /* x conversion factor */\par #define YSCALE 33               /* y conversion factor */\par #define pi 3.1415927            /* circumference of a circle */\par \par \par void InitGraphics (void)\par \par /* Standard graphics initialization            */\par \par \{\par SetPenMode(0);                  /* pen mode = copy */\par SetSolidPenPat(0);              /* pen color = black */\par SetPenSize(3,1);                /* use a square pen */\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {void Rotate (float *x, float *y, float angle, float ox, float oy)\par \par /* Rotate the point x,y about ox,oy through   */\par /* the angle given.                           */\par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {/*                                            */\par /* Parameters:                                */\par /*    x,y - point to rotate                   */\par /*    angle - angle to rotate (in radians)    */\par /*    ox,oy - point to rotate around          */\par \par \{\par float cosAngle,sinAngle;        /* sin and cos of angle */\par float nx;                       /* new x */\par \par *x -= ox;                       /* move the point */\par *y -= oy;\par cosAngle = cos(angle);          /* this takes time - save the results */\par sinAngle = sin(angle);\par nx = *x * cosAngle + *y * sinAngle; /* rotate the point */\par *y = *y * cosAngle - *x * sinAngle;\par *x = nx+ox;                     /* move the point back */\par *y = *y+oy;\par \}\par \par \par void RotateSquare (float x[4], float y[4])\par \par /* Rotate the square 9 degrees                */\par /*                                            */\par /* Parameters:                                */\par /*    x,y - coordinates of square             */\par \par \{\par unsigned i;                     /* loop variable */\par \par for (i = 0; i < 4; ++i)\par    Rotate(&x[i], &y[i], pi/20.0, 1.5, 1.5);\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {void DrawSquare (int color, float x[4], float y[4])\par \par /* Draw the square                            */\par /*                                            */\par /* Parameters:                                */\par /*    color - color to draw                   */\par /*    x,y - coordinates of the square         */\par \par \{\par SetSolidPenPat(color);       /* set the pen color */\par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {                             /* draw the square */\par MoveTo((int) (x[0]*XSCALE), (int) (y[0]*YSCALE));\par LineTo((int) (x[1]*XSCALE), (int) (y[1]*YSCALE));\par LineTo((int) (x[2]*XSCALE), (int) (y[2]*YSCALE));\par LineTo((int) (x[3]*XSCALE), (int) (y[3]*YSCALE));\par LineTo((int) (x[0]*XSCALE), (int) (y[0]*YSCALE));\par \}\par \par \par void main(void)\par \par /* Main program                               */\par \par \{\par float x[4],y[4],oldX[4],oldY[4]; /* points in the square */\par unsigned i,j;                   /* loop variables */\par \par InitGraphics();                 /* set up the graphics window */\par x[0] = 1.0;   y[0] = 1.0;       /* initialize the square */\par x[1] = 2.0;   y[1] = 1.0;\par x[2] = 2.0;   y[2] = 2.0;\par x[3] = 1.0;   y[3] = 2.0;\par DrawSquare(0, x, y);            /* draw the square */\par \par for (i = 0; i < 10; ++i) \{\par    for (j = 0; j < 4; ++j) \{    /* save the current location */\par       oldX[j] = x[j];\par       oldY[j] = y[j];\par       \}\par    RotateSquare(x, y);          /* rotate */\par    DrawSquare(3, oldX, oldY);   /* erase the old square */\par    DrawSquare(0, x, y);         /* draw the square */\par    \}\par \}\par }\pard\plain \qj\fi360\widctlpar\adjustright \f4\cgrid {\par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {When I was taking Physics classes, one of the things instructors used to delight in doing was to start a one semester course by writing a few equations on the board.  "There," they would say.  "That's all you need to learn this semester."\par Well, in a way they were right, of course.  From a few basic principals, we learned to do some amazing things.  The same thing happens in C.  You already know all of the basic principals involved in this program, but some of them are being put to very new uses.  Let's step through them and explain what is happening.\par First, this program is another good example of using subroutines to organize and simplify a program.  For example, we have packaged the idea of drawing and rotating a square into subroutines.  We have also reused our InitGraphics function to get ready to draw to the graphics window.\par One of the things you see in the main program that is a little new is two assignment statements on one line.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {x[0] = 1.0;   y[0] = 1.0;\par x[1] = 2.0;   y[1] = 1.0;\par x[2] = 2.0;   y[2] = 2.0;\par x[3] = 1.0;   y[3] = 2.0;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {While tastes vary among programmers, there are many people who find that putting two statements on the same line like this can make a program easier to read.  In this program, the organization shows more clearly that points are being set up, not just two separate arrays.\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 6.7.}{  The sample program rotated a square about its center, erasing the old square as it went.  This animated the square, giving a low-quality movie of a moving square.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {One of the surprising things about computers is that they can be used to create computer art.  With just a few small changes, the sample program can create a very pretty picture.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Change the program so that it rotates about the point 1.25, 1.25 instead of 1.5, 1.5.  This will give the square an off-center rotation.  Remove the code that erases the old square, and increase the loop counter from 10 to 40 so the square rotates through a complete circle.  Finally, change the color from black to green to purple as the square is drawn.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Getting rid of the animation will also let you clean up the loop in the main program.  In particular, you should eliminate the oldX and oldY variables.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }{\b Problem 6.8. }{ Rotation can be used to create some very interesting shapes.  One simple one is a circle.  Instead of rotating a square, you can rotate an individual point.  Then, by connecting the points, you can draw a circle.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Create a function that draws a circle using this method.  The function should accept four parameters:\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\fi-720\li1080\widctlpar\adjustright {cx, cy\tab The location of the center of the circle, in inches.  The location is measured from the top left corner of the graphics window.  Use the scaling mechanism shown in the sample program to convert from inches to screen coordinates.\par radius\tab The radius of the circle, in inches.  The radius is the distance from the center of the circle to the edge.\par color \tab The color of the circle.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {The following pseudo-code outlines the steps you must take.  Note that the pseudo-code assumes that moveto and lineto will work with real coordinates.  Naturally, you need to scale the coordinates and convert them to integers using the methods shown in the sample.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {x = cx;\par y = cy+radius;\par moveto(x,y);\par for (i = 1; i <= 40; ++i) \{\par    Rotate(x,y,pi/20.0,1.5,1.5);\par    lineto(x,y);\par    \}\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {Use this function to draw a green circle.  The center should be at 1.5, 1.5, and the radius should be 0.5.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }{\b Problem 6.9.}{  You can quickly convert the function from the last problem to draw a star, rather than a circle.  Change the function to draw a five pointed star, with the points of the star on the edges of the old circle.  To do this, start with a point at (2.0, 0.5) and rotate it around the point at the top of the circle.  You will need to rotate the point four times, by an angle of pi*2.0/5.0, which is one-fifth of a circle.  Next, draw lines from point-to-point to form the star, using the same method you use to draw a five-pointed star by hand.\par }\pard \s24\qj\li360\widctlpar\adjustright {\par Test this procedure with a program that draws a purple star with a center at 1.5, 1.5, and a radius of 0.5.\par \par }\pard\plain \widctlpar\adjustright \f4\cgrid {\b\fs36 \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \qc\widctlpar\adjustright \f4\cgrid {\b\fs36 Lesson Six\par Solutions to Problems\par }\pard \qj\widctlpar\adjustright {\b\fs28 \par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {Solution to problem 6.1.\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* This program reads in a string, sorts the characters, and       */\par /* writes the string back to the shell window.                     */\par \par #include <stdio.h>\par #include <string.h>\par \par #define MAX 255                 /* max length of a string */\par \par char inString[MAX];             /* input string */\par char outString[MAX];            /* output string */\par \par \par void Sort (void)\par \par /* Sort the characters in a string                              */\par /*                                                              */\par /* Variables:                                                   */\par /*    inString - string to sort                                 */\par /*    outString - sorted string                                 */\par \par \{\par unsigned swap;                  /* has a swap occurred? */\par unsigned i;                     /* loop variable */\par unsigned index;                 /* length of the reversed string */\par char temp;                      /* used to swap entries */\par \par strcpy(outString,inString);     /* make a copy of the string */\par index = strlen(outString);      /* get the length */\par do \{                            /* loop until the array is sorted */\par    swap = 0;                    /* no swaps, yet */\par    for (i = 0; i < index-1; ++i) \{ /* check each element but the last */\par                                    /*  if a swap is needed then...    */\par       if (outString[i+1] < outString[i]) \{\par          swap = 1;              /* note that there was a swap */\par          temp = outString[i];   /* swap the entries */\par          outString[i] = outString[i+1];\par          outString[i+1] = temp;\par          \}\par       \}\par    \}\par while (swap);\par \}\par \par \par void main (void)\par \par /* main program                                                 */\par \par \{\par printf("String :");\par scanf("%s", inString);\par Sort();\par printf("Sorted: %s\\n", outString);\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344480}Solution to problem 6.2.{\*\bkmkend _Toc496344480}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* This program reads in an array of up to 100 float numbers.  It  */\par /* then sorts the array, and prints the numbers in reverse order.  */\par /* Numbers are read until a zero is found.                         */\par \par #include <stdio.h>\par \par #define MAX 100                 /* max # of floats to sort */\par \par float numbers[MAX];             /* array to sort */\par unsigned num;                   /* # of numbers actually read */\par \par \par void ReadEm (void)\par \par /* Read the list of numbers.                                    */\par /*                                                              */\par /* Variables:                                                   */\par /*    numbers - array of numbers read                           */\par /*    num - number of numbers read                              */\par \par \{\par float rval;                     /* number read from the keyboard */\par \par num = 0;\par do \{\par    scanf(" %f", &rval);\par    if (rval != 0.0) \{\par       numbers[num] = rval;\par       ++num;\par       \}\par    \}\par while (rval != 0.0);\par \}\par \par \par void Sort (void)\par \par /* Sort the list of numbers.                                    */\par /*                                                              */\par /* Variables:                                                   */\par /*    numbers - array of numbers read                           */\par /*    num - number of numbers read                              */\par \par \{\par float temp;                     /* temp variable; used for swapping */\par unsigned swap;                  /* has a swap occurred? */\par unsigned i;                     /* loop variable */\par \par do \{                            /* loop until the array is sorted */\par    swap = 0;                    /* no swaps, yet */\par    for (i = 0; i < num-1; ++i) \{ /* check each element but the last */\par                                  /*  if a swap is needed then...    */\par       if (numbers[i+1] > numbers[i]) \{\par          swap = 1;              /* note that there was a swap */\par          temp = numbers[i];     /* swap the entries */\par          numbers[i] = numbers[i+1];\par          numbers[i+1] = temp;\par          \}\par       \}\par    \}\par while (swap);\par \}\par \par \par void WriteEm (void)\par \par /* Write the list of numbers.                                   */\par /*                                                              */\par /* Variables:                                                   */\par /*    numbers - array of numbers read                           */\par /*    num - number of numbers read                              */\par \par \{\par unsigned i;                     /* loop variable */\par \par for (i = 0; i < num; ++i)\par    printf("%f\\n", numbers[i]);\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void main (void)\par \par /* main program                                                 */\par \par \{\par }\pard \s23\qj\fi360\widctlpar\adjustright {ReadEm();                       /* read the list of numbers */\par Sort();                         /* sort the numbers */\par WriteEm();                      /* write the list of numbers */\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344481}Solution to problem 6.3.{\*\bkmkend _Toc496344481}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par #include <stdlib.h>\par \par #define NUM 10                  /* # of integers to print */\par \par \par unsigned RandomValue (unsigned max)\par \par /* Return a pseudo-random number in the range 1..max.              */\par /*                                                                 */\par /* Parameters:                                                     */\par /*    max - largest number to return                               */\par \par \{\par int value;\par \par do\par    value = rand();\par while ((value <= 0) || (value > max));\par return value;\par \}\par \par \par void main(void)\par \par /* Main program.                                                   */\par \par \{\par unsigned i;\par \par \par srand(1234);                  /* initialize the random number generator */\par for (i = 0; i < NUM; ++i)       /* print NUM random integers */\par    printf("%d\\n", RandomValue(100));\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344482}Solution to problem 6.4.{\*\bkmkend _Toc496344482}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Test a function that prints boolean values */\par \par #include <stdio.h>\par \par void PrintBool (int bool)\par \par /* Print a boolean string                                          */\par /*                                                                 */\par /* Parameters:                                                     */\par /*    bool - boolean value                                         */\par \par \{\par if (bool)\par    printf("true");\par else\par    printf("false");\par \}\par \par \par void main(void)\par \par /* Main program.                                                   */\par \par \{\par PrintBool(-1); printf("\\n");\par PrintBool( 0); printf("\\n");\par PrintBool( 1); printf("\\n");\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344483}Solution to problem 6.5.{\*\bkmkend _Toc496344483}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The list will be sorted to this order:\par \par }\pard \s21\qj\fi360\li720\widctlpar\adjustright {\f6 1212\par 123\par Mike\par Ran\par Run\par microphone\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344484}Solution to problem 6.6.{\*\bkmkend _Toc496344484}\par }\pard\plain \s21\qj\fi360\keepn\widctlpar\adjustright \f4\fs20\cgrid {\b Part 1\par }\pard\plain \fi360\keepn\widctlpar\adjustright \f4\cgrid {\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* Hangman                                              */\par /*                                                      */\par /* This program plays the game of Hangman.  When the    */\par /* game starts, you are given a word to guess.  The     */\par /* program displays one dash for each letter in the     */\par /* word.  You guess a letter.  If the letter is in the  */\par /* word, the computer prints the word with all letters  */\par /* you have guessed correctly shown in their correct    */\par /* positions.  If you do not guess the word, you move   */\par /* one step closer to being hung.  After six wrong      */\par /* guesses, you loose.                                  */\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par #include <stdio.h>\par #include <string.h>\par \par #define MAXWORDS 10             /* possible words */\par #define MAXCHARS 8              /* number of characters in each word */\par \par char words[MAXWORDS][MAXCHARS+1]; /* word array */\par \par \par void FillArray (void)\par \par /* Fill the word array.                               */\par /*                                                    */\par /* Variables:                                         */\par /*    words - word array                              */\par \par \{\par strcpy(words[0], "computer");\par strcpy(words[1], "whale");\par strcpy(words[2], "megabyte");\par strcpy(words[3], "modem");\par strcpy(words[4], "chip");\par strcpy(words[5], "online");\par strcpy(words[6], "disk");\par strcpy(words[7], "monitor");\par strcpy(words[8], "window");\par strcpy(words[9], "keyboard");\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void PrintArray (void)\par \par /* Print the word array                               */\par /*                                                    */\par }\pard \s23\qj\fi360\widctlpar\adjustright {/* Variables:                                         */\par /*    words - word array                              */\par \par \{\par unsigned i;                     /* loop variable */\par \par for (i = 0; i < MAXWORDS; ++i)\par    printf("%s\\n", words[i]);\par \}\par \par \par void main (void)\par \par /* Main program                                       */\par \par \{\par FillArray();                    /* fill the word array */\par PrintArray();                   /* print the word array */\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }{\b Part 2\par }{\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Hangman                                              */\par /*                                                      */\par /* This program plays the game of Hangman.  When the    */\par /* game starts, you are given a word to guess.  The     */\par /* program displays one dash for each letter in the     */\par /* word.  You guess a letter.  If the letter is in the  */\par /* word, the computer prints the word with all letters  */\par /* you have guessed correctly shown in their correct    */\par /* positions.  If you do not guess the word, you move   */\par /* one step closer to being hung.  After six wrong      */\par /* guesses, you loose.                                  */\par \par #include <stdio.h>\par #include <string.h>\par #include <stdlib.h>\par \par #define MAXWORDS 10             /* possible words */\par #define MAXCHARS 8              /* number of characters in each word */\par \par char words[MAXWORDS][MAXCHARS+1]; /* word array */\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void FillArray (void)\par \par }\pard \s23\qj\fi360\widctlpar\adjustright {/* Fill the word array.                               */\par /*                                                    */\par /* Variables:                                         */\par /*    words - word array                              */\par \par \{\par strcpy(words[0], "computer");\par strcpy(words[1], "whale");\par strcpy(words[2], "megabyte");\par strcpy(words[3], "modem");\par strcpy(words[4], "chip");\par strcpy(words[5], "online");\par strcpy(words[6], "disk");\par strcpy(words[7], "monitor");\par strcpy(words[8], "window");\par strcpy(words[9], "keyboard");\par \}\par \par \par void GetSeed (void)\par \par /* Initialize the random number generator             */\par \par \{\par int val;                        /* seed value */\par \par printf("Please enter a random number seed:");\par scanf(" %d", &val);\par srand(val);\par \}\par \par \par unsigned RandomValue (unsigned max)\par \par /* Return a pseudo-random number in the range 1..max.              */\par /*                                                                 */\par /* Parameters:                                                     */\par /*    max - largest number to return                               */\par /*    color - interior color of the rectangle                      */\par \par \{\par return rand() % max + 1;\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void main (void)\par \par /* Main program                                       */\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par \{\par FillArray();                    /* fill the word array */\par GetSeed();                    /* initialize the random number generator */\par \par printf("%s\\n", words[RandomValue(MAXWORDS)-1]); /* write a random word */\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }{\b Part 3\par }{\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Hangman                                              */\par /*                                                      */\par /* This program plays the game of Hangman.  When the    */\par /* game starts, you are given a word to guess.  The     */\par /* program displays one dash for each letter in the     */\par /* word.  You guess a letter.  If the letter is in the  */\par /* word, the computer prints the word with all letters  */\par /* you have guessed correctly shown in their correct    */\par /* positions.  If you do not guess the word, you move   */\par /* one step closer to being hung.  After six wrong      */\par /* guesses, you loose.                                  */\par \par #include <stdio.h>\par #include <string.h>\par #include <stdlib.h>\par \par #define MAXWORDS 10             /* possible words */\par #define MAXCHARS 8              /* number of characters in each word */\par \par char words[MAXWORDS][MAXCHARS+1]; /* word array */\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void FillArray (void)\par \par /* Fill the word array.                               */\par /*                                                    */\par /* Variables:                                         */\par /*    words - word array                              */\par \par \{\par strcpy(words[0], "computer");\par strcpy(words[1], "whale");\par strcpy(words[2], "megabyte");\par strcpy(words[3], "modem");\par strcpy(words[4], "chip");\par strcpy(words[5], "online");\par strcpy(words[6], "disk");\par }\pard \s23\qj\fi360\widctlpar\adjustright {strcpy(words[7], "monitor");\par strcpy(words[8], "window");\par strcpy(words[9], "keyboard");\par \}\par \par \par void GetSeed (void)\par \par /* Initialize the random number generator             */\par \par \{\par int val;                        /* seed value */\par \par printf("Please enter a random number seed:");\par scanf(" %d", &val);\par srand(val);\par \}\par \par \par unsigned RandomValue (unsigned max)\par \par /* Return a pseudo-random number in the range 1..max. */\par /*                                                    */\par /* Parameters:                                        */\par /*    max - largest number to return                  */\par /*    color - interior color of the rectangle         */\par \par \{\par return rand() % max + 1;\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void Play (void)\par \par /* Play a game of hangman.                            */\par }\pard \s23\qj\fi360\widctlpar\adjustright {/*                                                    */\par /* Variables:                                         */\par /*    words - word array                              */\par \par \{\par int allFound;                   /* used to test for unknown chars */\par char ch;                        /* character from player */\par int done;                       /* is the game over? */\par char found[MAXCHARS];           /* characters found by player */\par unsigned len;                   /* length of word; for efficiency */\par unsigned i;                     /* loop variable */\par int inString;                   /* is ch in the string? */\par char word[MAXCHARS+1];          /* word to guess */\par int wrong;                      /* number of wrong guesses */\par \par for (i = 0; i < MAXCHARS; ++i)  /* no letters guessed, so far */\par    found[i] = 0;\par wrong = 0;                      /* no wrong guesses, yet */\par done = 0;                       /* the game is not over, yet */\par                                 /* pick a word */\par strcpy(word, words[RandomValue(MAXWORDS)]); \par len = strlen(word);             /* record the length of the word */\par do \{\par    printf("\\nThe word is: \\""); /* write the word */\par    for (i = 0; i < len; ++i)\par       if (found[i])\par          printf("%c", word[i]);\par       else\par          printf("-");\par    printf("\\"\\nGuess a character:"); /* get the player's choice */\par    scanf(" %c", &ch);\par    inString = 0;                /* see if ch is in the string */\par    for (i = 0; i < len; ++i)\par       if (word[i] == ch) \{\par          found[i] = 1;\par          inString = 1;\par          \}\par    if (inString)                /* handle a correct guess */\par       printf("%c is in the string.\\n", ch);\par \par    else \{                       /* handle an incorrect guess */\par       printf("%c is not in the string.\\n", ch);\par       ++wrong;                  /* one more wrong answer... */\par       printf("Your ");          /* tell the player how they are doing */\par       if (wrong == 1)\par          printf("head");\par       else if (wrong == 2)\par          printf("body");\par       else if (wrong == 3)\par          printf("left arm");\par       else if (wrong == 4)\par          printf("right arm");\par       else if (wrong == 5)\par          printf("left leg");\par       else /* if (wrong == 6) */\par          printf("right leg");\par       printf(" is now in the noose!\\n");\par       \}\par \par    if (wrong == 6) \{            /* see if the player is hung */\par       printf("\\n\\nSorry, Jack Ketch got you!\\nThe word was \\"%s\\".\\n",\par          word);\par       done = 1;\par       \}\par    allFound = 1;                /* check for unknown characters */\par    for (i = 0; i < len; ++i)\par       if (!found[i])\par          allFound = 0;\par    if (allFound) \{              /* see if the player got the word */\par       printf("You got it!  The word is \\"%s\\".\\n", word);\par       done = 1;\par       \}\par    \}\par while (!done);\par \}\par \par \par void main (void)\par \par /* Main program                                       */\par \par \{\par FillArray();                    /* fill the word array */\par GetSeed();                    /* initialize the random number generator */\par Play();                         /* play a game */\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\fi360\keepn\widctlpar\adjustright {\b Part 4\par }{\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* Hangman                                              */\par /*                                                      */\par /* This program plays the game of Hangman.  When the    */\par /* game starts, you are given a word to guess.  The     */\par /* program displays one dash for each letter in the     */\par /* word.  You guess a letter.  If the letter is in the  */\par /* word, the computer prints the word with all letters  */\par /* you have guessed correctly shown in their correct    */\par /* positions.  If you do not guess the word, you move   */\par /* one step closer to being hung.  After six wrong      */\par /* guesses, you loose.                                  */\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par #include <stdio.h>\par #include <string.h>\par #include <stdlib.h>\par \par #define MAXWORDS 10             /* possible words */\par #define MAXCHARS 8              /* number of characters in each word */\par \par char words[MAXWORDS][MAXCHARS+1]; /* word array */\par \par \par void FillArray (void)\par \par /* Fill the word array.                               */\par /*                                                    */\par /* Variables:                                         */\par /*    words - word array                              */\par \par \{\par strcpy(words[0], "computer");\par strcpy(words[1], "whale");\par strcpy(words[2], "megabyte");\par strcpy(words[3], "modem");\par strcpy(words[4], "chip");\par strcpy(words[5], "online");\par strcpy(words[6], "disk");\par strcpy(words[7], "monitor");\par strcpy(words[8], "window");\par strcpy(words[9], "keyboard");\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void GetSeed (void)\par \par /* Initialize the random number generator             */\par \par \{\par }\pard \s23\qj\fi360\widctlpar\adjustright {int val;                        /* seed value */\par \par printf("Please enter a random number seed:");\par scanf(" %d", &val);\par srand(val);\par \}\par \par \par unsigned RandomValue (unsigned max)\par \par /* Return a pseudo-random number in the range 1..max. */\par /*                                                    */\par /* Parameters:                                        */\par /*    max - largest number to return                  */\par /*    color - interior color of the rectangle         */\par \par \{\par return rand() % max + 1;\par \}\par \par \par void Play (void)\par \par /* Play a game of hangman.                            */\par /*                                                    */\par /* Variables:                                         */\par /*    words - word array                              */\par \par \{\par int allFound;                   /* used to test for unknown chars */\par char ch;                        /* character from player */\par int done;                       /* is the game over? */\par char found[MAXCHARS];           /* characters found by player */\par unsigned len;                   /* length of word; for efficiency */\par unsigned i;                     /* loop variable */\par int inString;                   /* is ch in the string? */\par char word[MAXCHARS+1];          /* word to guess */\par int wrong;                      /* number of wrong guesses */\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {for (i = 0; i < MAXCHARS; ++i)  /* no letters guessed, so far */\par    found[i] = 0;\par wrong = 0;                      /* no wrong guesses, yet */\par done = 0;                       /* the game is not over, yet */\par                                 /* pick a word */\par strcpy(word, words[RandomValue(MAXWORDS)]); \par }\pard \s23\qj\fi360\widctlpar\adjustright {len = strlen(word);             /* record the length of the word */\par do \{\par    printf("\\nThe word is: \\""); /* write the word */\par    for (i = 0; i < len; ++i)\par       if (found[i])\par          printf("%c", word[i]);\par       else\par          printf("-");\par    printf("\\"\\nGuess a character:"); /* get the player's choice */\par    scanf(" %c", &ch);\par    inString = 0;                /* see if ch is in the string */\par    for (i = 0; i < len; ++i)\par       if (word[i] == ch) \{\par          found[i] = 1;\par          inString = 1;\par          \}\par    if (inString)                /* handle a correct guess */\par       printf("%c is in the string.\\n", ch);\par \par    else \{                       /* handle an incorrect guess */\par       printf("%c is not in the string.\\n", ch);\par       ++wrong;                  /* one more wrong answer... */\par       printf("Your ");          /* tell the player how they are doing */\par       if (wrong == 1)\par          printf("head");\par       else if (wrong == 2)\par          printf("body");\par       else if (wrong == 3)\par          printf("left arm");\par       else if (wrong == 4)\par          printf("right arm");\par       else if (wrong == 5)\par          printf("left leg");\par       else /* if (wrong == 6) */\par          printf("right leg");\par       printf(" is now in the noose!\\n");\par       \}\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {   if (wrong == 6) \{            /* see if the player is hung */\par       printf("\\n\\nSorry, Jack Ketch got you!\\nThe word was \\"%s\\".\\n",\par          word);\par       done = 1;\par       \}\par    allFound = 1;                /* check for unknown characters */\par }\pard \s23\qj\fi360\widctlpar\adjustright {   for (i = 0; i < len; ++i)\par       if (!found[i])\par          allFound = 0;\par    if (allFound) \{              /* see if the player got the word */\par       printf("You got it!  The word is \\"%s\\".\\n", word);\par       done = 1;\par       \}\par    \}\par while (!done);\par \}\par \par \par int PlayAgain (void)\par \par /* See if the player wants to play another game.      */\par /*                                                    */\par /* Returns:                                           */\par /*    True to play again, false to quit.              */\par \par \{\par char ch;                        /* player's response */\par \par printf("\\n\\n");\par do \{\par    printf("Would you like to play again (y or n)?");\par    scanf(" %c", &ch);\par    \}\par while ((ch != 'y') && (ch != 'Y') && (ch != 'n') && (ch != 'N'));\par return (ch == 'y') || (ch == 'Y');\par \}\par \par \par void main (void)\par \par /* Main program                                       */\par \par \{\par FillArray();                    /* fill the word array */\par GetSeed();                    /* initialize the random number generator */\par do\par    Play();                      /* play a game */\par while (PlayAgain());            /* loop if he wants to play again */\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344485}Solution to problem 6.7.{\*\bkmkend _Toc496344485}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Use rotation to draw a "flower"               */\par \par #include <quickdraw.h>\par #include <math.h>\par \par #define XSCALE 86               /* x conversion factor */\par #define YSCALE 33               /* y conversion factor */\par #define pi 3.1415927            /* circumference of a circle */\par \par \par void InitGraphics (void)\par \par /* Standard graphics initialization            */\par \par \{\par SetPenMode(0);                  /* pen mode = copy */\par SetSolidPenPat(0);              /* pen color = black */\par SetPenSize(3,1);                /* use a square pen */\par \}\par \par \par void Rotate (float *x, float *y, float angle, float ox, float oy)\par \par /* Rotate the point x,y about ox,oy through   */\par /* the angle given.                           */\par /*                                            */\par /* Parameters:                                */\par /*    x,y - point to rotate                   */\par /*    angle - angle to rotate (in radians)    */\par /*    ox,oy - point to rotate around          */\par \par \{\par float cosAngle,sinAngle;        /* sin and cos of angle */\par float nx;                       /* new x */\par \par *x -= ox;                       /* move the point */\par *y -= oy;\par cosAngle = cos(angle);          /* this takes time - save the results */\par sinAngle = sin(angle);\par nx = *x * cosAngle + *y * sinAngle; /* rotate the point */\par *y = *y * cosAngle - *x * sinAngle;\par *x = nx+ox;                     /* move the point back */\par *y = *y+oy;\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void RotateSquare (float x[4], float y[4])\par \par }\pard \s23\qj\fi360\widctlpar\adjustright {/* Rotate the square 9 degrees                */\par /*                                            */\par /* Parameters:                                */\par /*    x,y - coordinates of square             */\par \par \{\par unsigned i;                     /* loop variable */\par \par for (i = 0; i < 4; ++i)\par    Rotate(&x[i], &y[i], pi/20.0, 1.25, 1.25);\par \}\par \par \par void DrawSquare (int color, float x[4], float y[4])\par \par /* Draw the square                            */\par /*                                            */\par /* Parameters:                                */\par /*    color - color to draw                   */\par /*    x,y - coordinates of the square         */\par \par \{\par SetSolidPenPat(color);       /* set the pen color */\par                              /* draw the square */\par MoveTo((int) (x[0]*XSCALE), (int) (y[0]*YSCALE));\par LineTo((int) (x[1]*XSCALE), (int) (y[1]*YSCALE));\par LineTo((int) (x[2]*XSCALE), (int) (y[2]*YSCALE));\par LineTo((int) (x[3]*XSCALE), (int) (y[3]*YSCALE));\par LineTo((int) (x[0]*XSCALE), (int) (y[0]*YSCALE));\par \}\par \par \par void main(void)\par \par /* Main program                               */\par \par \{\par float x[4],y[4],oldX[4],oldY[4]; /* points in the square */\par unsigned i,j;                   /* loop variables */\par unsigned color;\par \par InitGraphics();                 /* set up the graphics window */\par x[0] = 1.0;   y[0] = 1.0;       /* initialize the square */\par x[1] = 2.0;   y[1] = 1.0;\par x[2] = 2.0;   y[2] = 2.0;\par x[3] = 1.0;   y[3] = 2.0;\par color = 0;                      /* draw the square */\par DrawSquare(color, x, y);\par \par for (i = 0; i < 40; ++i) \{\par    for (j = 0; j < 4; ++j) \{    /* save the current location */\par       oldX[j] = x[j];\par       oldY[j] = y[j];\par       \}\par    RotateSquare(x, y);          /* rotate */\par    color = (color + 1) % 3;     /* draw the square */\par    DrawSquare(color, x, y);\par    \}\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344486}Solution to problem 6.8.{\*\bkmkend _Toc496344486}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Create a circle using rotation                */\par \par #include <quickdraw.h>\par #include <math.h>\par \par #define XSCALE 86               /* x conversion factor */\par #define YSCALE 33               /* y conversion factor */\par #define pi 3.1415927            /* circumference of a circle */\par \par \par void InitGraphics (void)\par \par /* Standard graphics initialization            */\par \par \{\par SetPenMode(0);                  /* pen mode = copy */\par SetSolidPenPat(0);              /* pen color = black */\par SetPenSize(3,1);                /* use a square pen */\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void Rotate (float *x, float *y, float angle, float ox, float oy)\par \par /* Rotate the point x,y about ox,oy through   */\par /* the angle given.                           */\par /*                                            */\par /* Parameters:                                */\par /*    x,y - point to rotate                   */\par /*    angle - angle to rotate (in radians)    */\par /*    ox,oy - point to rotate around          */\par \par \{\par float cosAngle,sinAngle;        /* sin and cos of angle */\par float nx;                       /* new x */\par \par *x -= ox;                       /* move the point */\par }\pard \s23\qj\fi360\widctlpar\adjustright {*y -= oy;\par cosAngle = cos(angle);          /* this takes time - save the results */\par sinAngle = sin(angle);\par nx = *x * cosAngle + *y * sinAngle; /* rotate the point */\par *y = *y * cosAngle - *x * sinAngle;\par *x = nx+ox;                     /* move the point back */\par *y = *y+oy;\par \}\par \par \par void DrawCircle (float cx, float cy, float radius, int color)\par \par /* Draw a circle                                      */\par /*                                                    */\par /* Parameters:                                        */\par /*    color - color to draw                           */\par /*    cx,cy - center of the circle                    */\par /*    radius - radius of the circle                   */\par \par \{\par float x,y;                      /* point on the circle */\par unsigned i;                     /* loop variable */\par \par SetSolidPenPat(color);          /* set the pen color */\par x = cx;                         /* set the initial coordinates */\par y = cy+radius;\par                                 /* move to the initial point */\par MoveTo((int) (x*XSCALE), (int) (y*YSCALE));\par for (i = 0; i < 40; ++i) \{      /* draw the circle */\par    Rotate(&x, &y, pi/20.0, cx, cy);\par    LineTo((int) (x*XSCALE), (int) (y*YSCALE));\par    \}\par \}\par \par \par void main(void)\par \par /* Main program                               */\par \par \{\par InitGraphics();                 /* set up the graphics window */\par \par DrawCircle(1.5, 1.5, 0.5, 2);   /* draw the circle */\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344487}Solution to problem 6.9.{\*\bkmkend _Toc496344487}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Create a star using rotation                */\par \par #include <quickdraw.h>\par #include <math.h>\par \par #define XSCALE 86               /* x conversion factor */\par #define YSCALE 33               /* y conversion factor */\par #define pi 3.1415927            /* circumference of a circle */\par \par \par void InitGraphics (void)\par \par /* Standard graphics initialization            */\par \par \{\par SetPenMode(0);                  /* pen mode = copy */\par SetSolidPenPat(0);              /* pen color = black */\par SetPenSize(3,1);                /* use a square pen */\par \}\par \par \par void Rotate (float *x, float *y, float angle, float ox, float oy)\par \par /* Rotate the point x,y about ox,oy through   */\par /* the angle given.                           */\par /*                                            */\par /* Parameters:                                */\par /*    x,y - point to rotate                   */\par /*    angle - angle to rotate (in radians)    */\par /*    ox,oy - point to rotate around          */\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {\{\par float cosAngle,sinAngle;        /* sin and cos of angle */\par float nx;                       /* new x */\par \par *x -= ox;                       /* move the point */\par *y -= oy;\par cosAngle = cos(angle);          /* this takes time - save the results */\par }\pard \s23\qj\fi360\widctlpar\adjustright {sinAngle = sin(angle);\par nx = *x * cosAngle + *y * sinAngle; /* rotate the point */\par *y = *y * cosAngle - *x * sinAngle;\par *x = nx+ox;                     /* move the point back */\par *y = *y+oy;\par \}\par \par \par void DrawStar (float cx, float cy, float radius, int color)\par \par /* Draw a star                                        */\par /*                                                    */\par /* Parameters:                                        */\par /*    color - color to draw                           */\par /*    cx,cy - center of the star                      */\par /*    radius - distance from the center to a point    */\par \par \{\par int h[5],v[5];                  /* points of the star; QD coordinates */\par float x,y;                      /* point on the circle */\par unsigned i;                     /* loop variable */\par \par SetSolidPenPat(color);          /* set the pen color */\par x = cx;                         /* set the top point */\par y = cy-radius;\par h[0] = (int) (x*XSCALE);        /* convert it to screen coordinates */\par v[0] = (int) (y*YSCALE);\par for (i = 1; i < 5; ++i) \{       /* find the other 4 points */\par    Rotate(&x, &y, pi*2.0/5.0, cx, cy);\par    h[i] = (int) (x*XSCALE);\par    v[i] = (int) (y*YSCALE);\par    \}\par MoveTo(h[2], v[2]);             /* draw the star */\par LineTo(h[0], v[0]);\par LineTo(h[3], v[3]);\par LineTo(h[1], v[1]);\par LineTo(h[4], v[4]);\par LineTo(h[2], v[2]);\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void main(void)\par \par }\pard \s23\qj\fi360\widctlpar\adjustright {/* Main program                               */\par \par \{\par InitGraphics();                 /* set up the graphics window */\par \par DrawStar(1.5, 1.5, 0.5, 1);     /* draw the star */\par \}\par }\pard\plain \qj\fi360\widctlpar\adjustright \f4\cgrid {\par }\pard \widctlpar\adjustright {\sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s1\qc\nowidctlpar\outlinelevel0\adjustright \b\f4\fs36\cgrid {{\*\bkmkstart _Toc496344488}Lesson Seven{\*\bkmkend _Toc496344488}\par {\*\bkmkstart _Toc496344489}Types{\*\bkmkend _Toc496344489}\par }\pard\plain \qj\widctlpar\adjustright \f4\cgrid {\b\fs28 \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344490}Defining Types{\*\bkmkend _Toc496344490}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {You have already learned about several different types of variables.  So far, we have used character, integer, and float variables.  While you probably didn't think about it at the time, int, float, unsigned long, and so forth are all types.  In fact, every variable in your C program has a type, although what C means by a type may not be exactly what you expect.  To see how the C language thinks of a type, let's look at a variable declaration that looks a lot like some you have defined yourself:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {char ch, str[40];\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {As you know, this line declares two variables, ch and str.  The type of ch is easy enough; it is char.  The type of str, though, is slightly more complicated.  The type of string is array of char.  Technically, you might say that it is an array of 40 char variables, but the fact that the array has 40 elements in only important to the C compiler in a few places.  When the compiler reserves space for str in memory, for example, it needs to know how many characters are in the array so it can reserve the right amount of space.  In other cases, the C language treats an array with 40 characters the same way it treats an array with 4 characters or 400 characters.  As you have already learned from bitter experience, it is up to you to make sure your program doesn't index past the end of the array.\par }\pard \s21\qj\fi360\widctlpar\adjustright {Defining an array this way is pretty clear, but you will soon start to use more complicated types.  To use them effectively, and still write programs that are easy to read (which also tends to make them easier to debug, and less likely to have bugs in the first place), it helps to use something called a typedef that actually lets you define a new type that you can use the same way you use char or unsigned long.  A typedef looks a lot like a variable declaration.  In fact, the only real difference between the way you create a type and the way you create a variable is that a type starts with the reserved word typedef.  Here's a couple of examples to get started with:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {typedef unsigned boolean;\par typedef char string[80];\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par In the last lesson, you learned that C uses integers to hold boolean values.  (Boolean values are true or false, represented in C as non-zero numbers and zero, respectively.)  In some strongly typed languages, there is a whole separate type for boolean variables, even though the computer stores them as integers.  In C, where character variables are really just a short form of an integer, you would not expect to see a separate type for boolean variables, but your programs may still be easier to read if you use boolean for the type of a variable.  The first typedef allows you to do just that, by defining a new type, called boolean.  With this typedef in place, you can define boolean variables, arrays of boolean variables, and so forth, just like you define variables with any other type.  For example, you can define the variable done, which we used as a loop terminator in an earlier program, like this:\par \par }{\f6 boolean done;\par }{\par Underneath it all, done is still an unsigned integer, and any C compiler would create exactly the same program if you defined it that way.  On the other hand, when you look at the declaration of done, you can tell a little more about the variable and what it is used for.  You can tell at a glance, for example, that done is used to hold a true or false value.\par Our second type is even more useful in many respects, because it gives us something new, not just a new name for something that already exists.  After the second typedef, string becomes a new type, just like boolean, but this time it defines an array of 80 characters.  With this type, we can define things like\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {string name, friends[47];\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par With these more complicated types, you have to pay attention to keep track of the type of an individual variable.  In one sense, the type of name is string, but as far as C is concerned, the type of name is array of char.  The second variable, friends, is an array of array of char.  Like the arrays of arrays you have already defined, you can specify a string by using one subscript, or an individual character by listing both subscripts.\par The reason that types are important, and how you should use them in your programs, is something you shouldn't expect to understand from reading a few paragraphs in a lesson.  Instead, you are going to learn about types the same way you have learned about for loops, if statements, && operators, and so forth:  by seeing them in sample programs, and using them in your own programs.  Gradually, over the next few lessons, I hope you will start to see just why types are so important, and why they truly make a language like Pascal, C, or Ada enormously more useful for real programming than the older, virtually typeless languages like FORTRAN and BASIC.  It is the concept of types, and the ability to freely define them, along with the idea of structures and pointers that makes C such a good choice as a programming language.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 7.1. }{ The sample program at the end of lesson 6 used an array of four float variables to keep track of the sides of a square.  Modify this program by using a typedef to define a new type, called square, and declare the variables with this new type.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344491}Enumerations{\*\bkmkend _Toc496344491}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {In many older programming languages, like BASIC and FORTRAN, the only type you can define is an array.  Arrays and the types that are built into the language are all you can use.  This isn't a criticism of those two languages.  They were designed to let scientists and engineers write programs to deal with mathematical equations, and they do that very well.  C, though, is designed for a broader range of programming jobs, so dealing with numbers and arrays of numbers just isn't enough.  C lets you define a wide range of complicated types to express your ideas in a more natural way.  The first of these that we will look at is the enumeration.\par An enumeration consists of one or more named items.  These names become the values that can be assigned to to any variable you could assign an integer to; in fact, the enumeration names are really just another way of specifying an integer.  For example, you can define an enumeration of weekdays for a calendar program like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {enum weekDay \{sunday, monday, \par               teusday, wednesday, \par               thursday, friday, \par               saturday\};\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The integer values associated with each of the enumerated names start with zero, and increase by one with each name.  For example,\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {printf("%d %d\\n", sunday, \par }\pard \s23\qj\fi360\widctlpar\adjustright {   teusday);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {is perfectly legal, and will print 0 and 2.\par }\pard \s21\qj\fi360\widctlpar\adjustright {While you can define an int or unsigned variable to hold the various weekdays, it is considered good form to define variables that are of the same type as the enumeration, like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {enum weekDay dayOff, thanksgiving;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {This brings up a subtle, but very important point.  You have defined a new type, but the name of the type is not weekDay; the type is enum weekDay.\par }\pard \s21\qj\fi360\widctlpar\adjustright {Values can be assigned to the variables just like they are assigned to the variables you are familiar with.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {thanksgiving = thursday;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par While it is legal in C to assign an integer value to an enum variable, and to assign an enum constant (like thursday) to an int or unsigned variable, doing so is considered very poor form.  You may occasionally write programs that make use of the fact that enumerations are, in fact, integers, just as you occasionally make use of the fact that characters are integers (by comparing or incrementing them, for example), but your programs will be a lot easier to read and understand if you keep your enumerations separate from your integers.\par To get a good grasp on how enumerations can be used, we will use a deck of cards as an example.  There are a lot of new concepts in the program in listing 7.1; these will be explained in detail in the next few sections.\par \par }{\b \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b \par }\pard \s21\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {\b Listing 7.1\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright \f6\fs20\cgrid {/* This program shuffles a deck of cards, then prints the       */\par /* results.                                                     */\par /*                                                              */\par /* The deck of cards is represented by a pair of arrays.  Each  */\par /* array has one position for each of the 52 cards in a         */\par /* standard deck of playing cards.  One array gives the value   */\par /* of the card (see the value enumeration), while the other     */\par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {/* gives the suit (see the suit enumeration).                   */\par \par #include <stdio.h>\par #include <stdlib.h>\par \par                                         /* suits of cards */\par enum suit \{spades, diamonds, clubs, hearts\};\par                                         /* face value of cards */\par enum value \{two, three, four, five, six, seven, eight, nine, ten,\par             jack, queen, king, ace\};\par \par enum suit suitDeck[52];                 /* these two arrays define */\par enum value valueDeck[52];               /* a deck of cards         */\par \par \par unsigned RandomValue (unsigned max)\par \par /* Return a pseudo-random number in the range 1..max.              */\par /*                                                                 */\par /* Parameters:                                                     */\par /*    max - largest number to return                               */\par /*    color - interior color of the rectangle                      */\par \par \{\par return rand() % max + 1;\par \}\par \par \par void InitializeDeck (enum suit suits[52], enum value values[52])\par \par /* Fills in the values to define a sorted deck of cards         */\par /*                                                              */\par /* Parameters:                                                  */\par /*    suits - array of the card suits                           */\par /*    values - array of the card values                         */\par \par \{\par unsigned i;                             /* loop variable */\par \par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {for (i = 0; i < 13; ++i) \{              /* initialize the suit array */\par    suits[i] = spades;\par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {   suits[i+13] = diamonds;\par    suits[i+26] = clubs;\par    suits[i+39] = hearts;\par    \}\par \par values[0] = two;                        /* initialize the first suit */\par values[1] = three;\par values[2] = four;\par values[3] = five;\par values[4] = six;\par values[5] = seven;\par values[6] = eight;\par values[7] = nine;\par values[8] = ten;\par values[9] = jack;\par values[10] = queen;\par values[11] = king;\par values[12] = ace;\par for (i = 13; i < 52; ++i)               /* copy the first suit to the */\par    values[i] = values[i-13];            /* remaining suits            */\par \}\par \par \par void Shuffle (enum suit suits[52], enum value values[52])\par \par /* Shuffles the deck of cards                                   */\par /*                                                              */\par /* Parameters:                                                  */\par /*    suits - array of the card suits                           */\par /*    values - array of the card values                         */\par \par \{\par unsigned i;                             /* loop variable */\par unsigned j;                           /* card to swap with current card */\par enum value tvalue;                      /* temp value; used for swap */\par enum suit tsuit;                        /* temp suit; used for swap */\par \par for (i = 0; i < 52-1; ++i) \{\par    j = RandomValue(52 - i) + i - 1;\par    tsuit = suits[i];\par    suits[i] = suits[j];\par    suits[j] = tsuit;\par    tvalue = values[i];\par    values[i] = values[j];\par    values[j] = tvalue;\par    \}\par \}\par \par \par void PrintValue (enum value v)\par \par /* Print the value of a card                                 */\par /*                                                           */\par /* Parameters:                                               */\par /*    v - value of the card                                  */\par \par \{\par if (v == two)\par    printf("two");\par else if (v == three)\par    printf("three");\par else if (v == four)\par    printf("four");\par else if (v == five)\par    printf("five");\par else if (v == six)\par    printf("six");\par else if (v == seven)\par    printf("seven");\par else if (v == eight)\par    printf("eight");\par else if (v == nine)\par    printf("nine");\par else if (v == ten)\par    printf("ten");\par else if (v == jack)\par    printf("jack");\par else if (v == queen)\par    printf("queen");\par else if (v == king)\par    printf("king");\par else if (v == ace)\par    printf("ace");\par \}\par \par \par void PrintSuit (enum suit s)\par \par /* Print the suit of a card                                  */\par /*                                                           */\par /* Parameters:                                               */\par /*    s - suit of the card                                   */\par \par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {\{\par if (s == spades)\par    printf("spades");\par else if (s == diamonds)\par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {   printf("diamonds");\par else if (s == clubs)\par    printf("clubs");\par else if (s == hearts)\par    printf("hearts");\par \}\par \par void PrintDeck (enum suit suits[52], enum value values[52])\par \par /* Prints the cards in order                                    */\par /*                                                              */\par /* Parameters:                                                  */\par /*    suits - array of the card suits                           */\par /*    values - array of the card values                         */\par \par \{\par unsigned i;                             /* loop variable */\par \par for (i = 0; i < 52; ++i) \{\par    PrintValue(values[i]);\par    printf(" of ");\par    PrintSuit(suits[i]);\par    printf("\\n");\par    \}\par \}\par \par \par void main (void)\par \par /* Main program                                                 */\par \par \{\par srand(1234);                  /* initialize the random number generator */\par InitializeDeck(suitDeck, valueDeck);/* get a new (sorted) deck of cards */\par Shuffle(suitDeck, valueDeck);         /* shuffle the deck */\par PrintDeck(suitDeck, valueDeck);       /* print the shuffled deck */\par \}\par }\pard\plain \qj\fi360\widctlpar\adjustright \f4\cgrid {\par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Right at the top of the program, you see the types and variables that we are using to represent a deck of cards.  Instead of using numbers to represent the cards, we can actually use the natural name of the value of the card and the suit of the card.  There is a problem, though.  As with the square in the last lesson, where each point on the square required two coordinates (x and y), each card in the deck of cards needs a value and a suit.  We solve the problem the same way, by using two parallel arrays, one of which holds the suit of the card, while the other holds the face value of the card.\par The next thing I want you to notice about this program is how, once again, we are using subroutines to break a complicated task up into several simple tasks.  If you are asked to shuffle a deck of cards and print the results, it might seem to be a difficult task.  Stated that way, it is.  To write the program, though, we just break this complicated task up into three simple tasks.  First, we set up the arrays, filling in the array values with a sorted deck of cards.  This is initializing a deck of cards.  It's the same thing you would do to play a game of cards in real life:  open the box of cards.  Next, we shuffle the cards.  Finally, we deal them, printing the cards to the shell window.  It is these three natural steps that you find in the body of the program:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {InitializeDeck(suitDeck,\par    valueDeck);\par Shuffle(suitDeck, valueDeck);\par }\pard \s23\qj\fi360\widctlpar\adjustright {PrintDeck(suitDeck, valueDeck);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par From a programming standpoint, there is nothing new in the InitializeDeck or Shuffle functions.  All of the statements and concepts have been dealt with before.  The arithmetic in Shuffle is a bit involved, though, so we will look at the function in detail.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {for (i = 0; i < 52-1; ++i) \{\par    j = RandomValue(52 - i) + i-1;\par    tsuit = suits[i];\par    suits[i] = suits[j];\par    suits[j] = tsuit;\par    tvalue = values[i];\par    values[i] = values[j];\par    values[j] = tvalue;\par }\pard \s23\qj\fi360\widctlpar\adjustright {   \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The idea is to shuffle the deck of cards, choosing each card randomly.  To do this, we step through the deck of cards using the for loop.  On each step, we want to pick one of the cards from the remaining ones, and swap it with the card in the current spot.  Comparing this to a real deck of cards, what we are doing is picking a card at random from the deck, and placing it in a new pile.  We then pick another card randomly from the deck and place it on top of the first card in the pile, and so forth.\par To pick the card, we need to choose a card from the remaining ones.  The first time, when i is 0, we want to pick from 52 cards.  The next time, when i is 1, we want to pick from 52-1 cards, and so forth.  This explains the parameter to the RandomValue call.\par The card we pick must come from the remainder of the deck.  When i is 0, Random will return a value from 1 to 52, but we need a value from 0 to 51, since we are using the value as an array index.  After subtracting 1 to convert to an array index (remember, i is 0), we swap the card with the current card, and continue on.  When i is 1, Random is returning a value from 1 to 51.  In this case, adding i and subtracting 1 leave the value unchanged, so we pick a card from the remainder of the deck, leaving out the first card.  The process continues through the rest of the deck.\par Reading the explanation may not make much sense.  This is pretty common the first time you see a new algorithm (a fancy way of saying a new process for doing something).  To get a better handle on this program, we'll do something that you will find yourself doing over and over: trying something in real-life to see how a program works.  What we will do is to use this algorithm to sort a short deck of cards, tracing through what happens by hand.  In our example, though, instead of shuffling 52 cards, we will shuffle 6, and instead of using a random number generator, we'll use a standard, six-sided die.\par To start the thought experiment, take a sheet of paper and tear it into six roughly equal pieces, numbering these 1 to 6.  Lay these out on the table, like this:\par \par }\pard\plain \qj\widctlpar\adjustright \f4\cgrid {\f12\fs20 {\pict{\*\picprop\shplid1028{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 268435473}}{\sp{\sn fFilled}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex72\picscaley72\piccropl0\piccropr0\piccropt0\piccropb0\picw312\pich60\picwgoal6240\pichgoal1200\macpict\bliptag-259930205\blipupi72{\*\blipuid f081c7a3ed51cbbea02e6f61ec6d1620}0171000700070043013f1101a00082a0008c01000a000700070043013f0a00000000000000000b001b001b44000a000a0041002f48a10096000606000000022da1009a0008fffa000000060000a000980300140d00182b172b0131a00099a00097a0008da0008c44000a00400041006548a10096000606000000022da1009a0008fffa000000060000a0009829360132a00099a00097a0008da0008c44000a00760041009b48a10096000606000000022da1009a0008fffa000000060000a0009829360133a00099a00097a0008da0008c44000a00ac004100d148a10096000606000000022da1009a0008fffa000000060000a0009829360134a00099a00097a0008da0008c44000a00e20041010748a10096000606000000022da1009a0008fffa000000060000a0009829360135a00099a00097a0008da0008c44000a01180041013d48a10096000606000000022da1009a0008fffa000000060000a0009829360136a00099a00097a0008da00083ff00}}{\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par To shuffle the deck, we'll roll the dice to generate random numbers.  We'll do this one time for each card except the last one, starting with the first card.  Just in case you don't have a die handy, I used a short program to generate some appropriate random numbers.  The first one is a four, so we'll switch the first card with the one four cards later (card number 4), with this result:\par \par }\pard\plain \qj\widctlpar\adjustright \f4\cgrid {\f12\fs20 {\pict{\*\picprop\shplid1029{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 268435473}}{\sp{\sn fFilled}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex72\picscaley72\piccropl0\piccropr0\piccropt0\piccropb0\picw312\pich60\picwgoal6240\pichgoal1200\macpict\bliptag299933345\blipupi72{\*\blipuid 11e09ea1542aa9b2b8a668f054c71495}0177000700070043013f1101a00082a0008c01000a000700070043013f0a00000000000000000b001b001b44000a00ac004100d148a10096000606000000022da1009a0008fffa000000060000a000980300140d00182bb92b0131a00099a00097a0008da0008c44000a00400041006548a10096000606000000022da1009a0008fffa000000060000a0009828002b004d0132a00099a00097a0008da0008c44000a00760041009b48a10096000606000000022da1009a0008fffa000000060000a0009829360133a00099a00097a0008da0008c44000a000a0041002f48a10096000606000000022da1009a0008fffa000000060000a0009828002b00170134a00099a00097a0008da0008c44000a00e20041010748a10096000606000000022da1009a0008fffa000000060000a0009829d80135a00099a00097a0008da0008c44000a01180041013d48a10096000606000000022da1009a0008fffa000000060000a0009829360136a00099a00097a0008da00083ff00}}{\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The next step is to move on to the second card.  This time, my handy little program gives me a 1.  This is an interesting case: we don't do anything at all, and simply move on.  "But wait," you say, "the card should be switched with something!"  It was, in a sense: it was switched with itself.  This may seem a bit odd, but if you think about it, there is always a chance that a particular card will end up in its original place when you shuffle a deck of cards.  In fact, the chances are pretty good that at least one card ends up back in its original location.\par Moving on to the third card, our electronic die comes up with 3, so we switch the third card with card 5, ending up with this:\par \par }\pard\plain \widctlpar\adjustright \f4\cgrid {\f12\fs20 {\pict{\*\picprop\shplid1030{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 268435473}}{\sp{\sn fFilled}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex71\picscaley71\piccropl0\piccropr0\piccropt0\piccropb0\picw312\pich60\picwgoal6240\pichgoal1200\macpict\bliptag240629997\blipupi72{\*\blipuid 0e57b8edbc8516cad2289e6aa04d7a52}0177000700070043013f1101a00082a0008c01000a000700070043013f0a00000000000000000b001b001b44000a00ac004100d148a10096000606000000022da1009a0008fffa000000060000a000980300140d00182bb92b0131a00099a00097a0008da0008c44000a00400041006548a10096000606000000022da1009a0008fffa000000060000a0009828002b004d0132a00099a00097a0008da0008c44000a00e20041010748a10096000606000000022da1009a0008fffa000000060000a0009829a20133a00099a00097a0008da0008c44000a000a0041002f48a10096000606000000022da1009a0008fffa000000060000a0009828002b00170134a00099a00097a0008da0008c44000a00760041009b48a10096000606000000022da1009a0008fffa000000060000a00098296c0135a00099a00097a0008da0008c44000a01180041013d48a10096000606000000022da1009a0008fffa000000060000a0009829a20136a00099a00097a0008da00083ff00}}{\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Next we get a 2, so we switch the fourth card with the one right after it.  In this case, we're switching the 1 card with the 3 card.  They've both been moved before, but that doesn't hurt anything.\par \par }\pard\plain \qj\widctlpar\adjustright \f4\cgrid {\f12\fs20 {\pict{\*\picprop\shplid1031{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 268435473}}{\sp{\sn fFilled}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex71\picscaley71\piccropl0\piccropr0\piccropt0\piccropb0\picw312\pich60\picwgoal6240\pichgoal1200\macpict\bliptag-1571046415\blipupi72{\*\blipuid a25bbbf12db0841cea6afcd3e71418af}0177000700070043013f1101a00082a0008c01000a000700070043013f0a00000000000000000b001b001b44000a00e20041010748a10096000606000000022da1009a0008fffa000000060000a000980300140d00182bef2b0131a00099a00097a0008da0008c44000a00400041006548a10096000606000000022da1009a0008fffa000000060000a0009828002b004d0132a00099a00097a0008da0008c44000a00ac004100d148a10096000606000000022da1009a0008fffa000000060000a00098296c0133a00099a00097a0008da0008c44000a000a0041002f48a10096000606000000022da1009a0008fffa000000060000a0009828002b00170134a00099a00097a0008da0008c44000a00760041009b48a10096000606000000022da1009a0008fffa000000060000a00098296c0135a00099a00097a0008da0008c44000a01180041013d48a10096000606000000022da1009a0008fffa000000060000a0009829a20136a00099a00097a0008da00083ff00}}{\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Finally, we get to the fifth card, which is the last one we will switch.  This time, though, the computer popped off with a 6, which we can't use.  Our program will need a way to make sure that the numbers we get aren't too big, since we don't want to step past the end of an array in a C program.  In our case, we just roll again \endash  and Murphy strikes, giving a 3, which is about as useful as the 6.  Finally, the computer coughs up a 2, and we switch the last two cards.\par \par }\pard\plain \qj\widctlpar\adjustright \f4\cgrid {\f12\fs20 {\pict{\*\picprop\shplid1032{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 268435473}}{\sp{\sn fFilled}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex71\picscaley71\piccropl0\piccropr0\piccropt0\piccropb0\picw312\pich60\picwgoal6240\pichgoal1200\macpict\bliptag21388226\blipupi72{\*\blipuid 01465bc2fb615689879cc5f85fe7b1ba}0179000700070043013f1101a00082a0008c01000a000700070043013f0a00000000000000000b001b001b44000a01180041013d48a10096000606000000022da1009a0008fffa000000060000a000980300140d001828002b01250131a00099a00097a0008da0008c44000a00400041006548a10096000606000000022da1009a0008fffa000000060000a0009828002b004d0132a00099a00097a0008da0008c44000a00ac004100d148a10096000606000000022da1009a0008fffa000000060000a00098296c0133a00099a00097a0008da0008c44000a000a0041002f48a10096000606000000022da1009a0008fffa000000060000a0009828002b00170134a00099a00097a0008da0008c44000a00760041009b48a10096000606000000022da1009a0008fffa000000060000a00098296c0135a00099a00097a0008da0008c44000a00e20041010748a10096000606000000022da1009a0008fffa000000060000a00098296c0136a00099a00097a0008da00083ff00}}{\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The result is a reasonably well-shuffled deck of six cards.  You can also see why we only switched five of the cards, instead of six: there's nothing to swap the last card with, anyway, so there is no use in taking the time to do it.\par This, in a nutshell, is what the program does, only it uses math to do it instead of using a human to keep track of which card is next, or a die to see what cards to switch.  With this though experiment complete, go back and take another look at the program: you should be able to figure out what it does, now, since it is doing the same thing you just finished doing.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 7.2.}{  Acey Ducey is a card game played between two players.  Your task is to write a program that will play the game.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {The game is very simple.  The computer starts by drawing two cards from the deck.  You have to decide if the next card will have a value between the first two.  A tie does not count.  For example, if the two cards are the two of diamonds and the ten of clubs, the ten of hearts does not lie between the other two.  If you think the next card will be between the first two, you place a bet.  If not, you can pass by placing a bet of zero.  If you are right, you get back double the bet.  If you are wrong, you loose the bet.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Your program should start by giving you 50 dollars.  It should ask for a random number seed, then initialize and shuffle the deck, as the sample program did.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {You then draw the first two cards from the deck, using a variation on the PrintDeck function to print the values of the cards.  Next, ask for a bet from the player.  If the bet is negative, stop the game and print the amount of money the player has.  Otherwise, draw another card and print its value.  Compare the new card to the first two.  If its value lies between them, add the appropriate amount to the player's pile; otherwise, subtract the amount.  Print the results and continue.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {You should not allow the player to bet more money that he has.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {If the player's pot goes to zero, stop the game.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Reshuffle the deck after 17 hands.  Seventeen hands will use 51 cards from the deck, so another hand would use more cards than you have.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344492}Structures Store More than One Type{\*\bkmkend _Toc496344492}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Programs are written to manipulate information of one sort or another.  We have already found two places where the information we were dealing with consisted of more than one piece of information representing a single item.  The most recent example was our card playing games, where a card had a suit and a value.  We had to use two parallel arrays to keep track of a deck of cards.  This, to say the least, is messy, confusing, and makes a program hard to read.\par I wouldn't say things like that, of course, unless C had an elegant way to solve the problem.  What we need is a way to declare a variable that is made up of more than one thing.  Unlike arrays, though, we don't want to force each thing to be the same type: we want to be able to put any type we want into the variable.  In C, we do this with structures.\par Structures are declared a lot like enumerations.  Let's take a look at an example to see how they are actually declared, then discuss the example in detail.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {struct card \{\par    enum suit s;\par    enum value v;\par }\pard \s23\qj\fi360\widctlpar\adjustright {   \};\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Like an enumeration, a structure creates a new type, but also like an enumeration, the name of the structure is not, itself, a type.  In the structure we just defined, the type is struct card, not card.  To define a variable of this type, we would do something like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {struct card deck[52];\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Again, just as with enumerations, the contents of the structure are surrounded by brackets.  Inside of the brackets is a series of variable declarations, just like those you would use to declare variables anywhere else.  These variables can be literally any type of variable you like, including enumerations, as shown, or even another structure.\par When you use a struct variable, you can do almost anything with it that you would do with any other variable.  For example, you can assign one structure to another, pass a structure to a function, return a structure as the result of a function, declare arrays of structures, or use structures within another structure.  There are limits, though.  You can't add two structures together, or do any other math operation on a structure.  You also can't print a structure with printf, nor can you read a structure from the keyboard.  There are also some limits on structures that don't appear in other parts of C.  Structures are strongly typed, so you can't assign one structure to another unless they are the same type of structure, and you can't pass a structure as a parameter to a function that is expecting some other type of structure.\par One of the things you need to be able to do, of course, is to use and set the various variables that are inside of the structure.  You need a way to specify which field (variables inside a structure are called fields) of the structure you want to access, just as we specify which element of an array we want with an index.  With structures, we use the name of the struct variable, followed by a dot, and the name of the variable within the structure.  If we define myCard as a card, like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {struct card myCard;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {we can assign values to the structure, test the structure, and so forth, using the methods we have already learned, and by specifying the individual field of the structure using the dot operator.  The examples below show how this is done.\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {myCard.s = diamonds;\par myCard.v = ace;\par \par if ((myCard.v >= jack)\par    && (myCard.v <= king))\par    printf("face card\\n");\par \par }\pard \s23\qj\fi360\widctlpar\adjustright {PrintCard(myCard.s, myCard.v);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par You can handle even more complicated situations by building expressions up from the basic rules you already know.  To get at the value of a card in the deck of cards that we defined as an array of card structures, you have to access an element of a structure that is in an array of structures.  The first thing you have to name, then, is the array.  We'll call it deck.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {deck\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {Next, you want a specific card within the array, so you name the card by giving an array index.\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \qj\fi360\widctlpar\adjustright \f4\cgrid {\f6\fs20 deck[i]\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {Finally, you want a field within the structure.  We'll assume you are after the value field.  You end up with this:\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {deck[i].v\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {Since the resulting type is value, you can use this anywhere you could use a value variable.  You can assign a value to it, assign it to another value, or pass it as a parameter, for example.  So, from simple concepts you already know, you can build up very complicated expressions.\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 7.3. }{ Modify the card shuffling sample to use records.  Define a card and a deck of cards as we have done in this section.  Change the various functions so you can pass an individual deck of cards, rather than two separate arrays.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344493}Defining Variables Right Away with struct and enum{\*\bkmkend _Toc496344493}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {C is a pretty flexible language.  If you look at what you have been doing, you may notice that the definition of an enumeration or structure, and the declaration of a variable for one of them, look a lot alike.  You may also have noticed by trial and error that you can mix struct and enum definitions with variable declarations, defining an enum, then a variable, then another enum, for example.  It turns out that you can combine them, too.  Instead of defining an enumeration and then declaring a variable, like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {enum weekDay \{sunday, monday, \par               teusday, wednesday, \par               thursday, friday, \par               saturday\};\par enum weekDay dayOff, thanksgiving;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {you could put them together, like this:\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {enum weekDay \{sunday, monday, \par               teusday, wednesday, \par               thursday, friday, \par               saturday\}\par    dayOff, thanksgiving;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par I personally think this makes a program a bit harder to read, but we can put this ability to very good use in combination with typedef, as you will see in the next section.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344494}Using typedef with struct and enum{\*\bkmkend _Toc496344494}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {I've tried to make the point that the name of a struct or enum is not, by itself, a type.  This is an important concept, since, if you forget to say struct or enum at just the right place, you drive the compiler nuts.  The compiler, in turn, spits error messages at you instead of creating a useful program, and you get frustrated.\par Well, you wouldn't be alone.  As it turns out, though, there is a surprising convention that you can use to get around this problem.  You probably know by now that the C compiler doesn't like it if you define two variables that have the same name.  As it happens, though, the C language has several different classes of variables, called overloading classes.  Within certain limits, you can actually use the same name for two different purposes.  In general, that's a rotten idea, but in the case of a struct or enum definition, it comes in handy.  To see how, let's redefine our first enum and struct using typedef.  As with the other types you have defined with typedef, defining a struct or enum type looks just like a variable declaration, but with a typedef out front.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {typedef struct card \{\par    enum suit s;\par    enum value v;\par    \} card;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par At this point, though, card is both the name of a structure and a new type.  You can still use struct card to define variables, but you can also use card as a type, which is a lot easier, and more natural.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {card deck[52];\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par If the idea of having card declared twice offends your sensibilities, you can also leave off the name of the structure entirely, creating a nameless structure, but defining a type that you can use, instead.  This statement defines a type called card; the type is a structure containing two enum variables, but the structure itself has no name.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {typedef struct \{\par    enum suit s;\par    enum value v;\par    \} card;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par While this last form is probably closest to the way other languages use structures, the form with card defined both as a structure and as a type is more common among C programmers, so that is how we will define structures and enumerations in the sample programs and solutions.\par \par Problem 7.4.  Try these ideas out by writing a short program that defines an enumeration for the days of the week, but declare the enumeration as both an enum name and as a type.  Put the enumeration to use by writing a function that will print a the day you pass it; in other words, if you pass the enum value sunday, your function should write the string "Sunday" using a printf statement.  Test your function using a loop in the main function to print each of the days in the week.  Naturally, the loop variable and the parameter to your function that prints the day of the week should both be declared as the enumeration type, not using enum or as an integer.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344495}The switch Statement{\*\bkmkend _Toc496344495}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {While this lesson has dealt with types, you may have noticed a few places where our new fountain of types makes coding a bit more cumbersome.  With all of these new types, there were a couple of placed where we had to evaluate a long series of if statements.  A good example is the PrintValue subroutine, which we used to print the face value of a card.\par \par }\pard\plain \s23\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 void PrintValue (enum value v)\par \par /* Print the value of a card           */\par /*                                     */\par /* Parameters:                         */\par /*    v - value of the card            */\par \par \{\par if (v == two)\par    printf("two");\par else if (v == three)\par    printf("three");\par else if (v == four)\par    printf("four");\par else if (v == five)\par    printf("five");\par else if (v == six)\par    printf("six");\par else if (v == seven)\par    printf("seven");\par else if (v == eight)\par    printf("eight");\par else if (v == nine)\par    printf("nine");\par else if (v == ten)\par    printf("ten");\par else if (v == jack)\par    printf("jack");\par else if (v == queen)\par    printf("queen");\par else if (v == king)\par    printf("king");\par else if (v == ace)\par    printf("ace");\par }\pard \s23\widctlpar\adjustright {\fs18 \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par It's pretty hard to read this subroutine.  In particular, it is very hard to see at a glance if we left out a check for seven.  Not only that, the compiler has to generate an enormous number of machine language instructions to do all of the if checks, making the program large and slow.\par C has a special statement, called the switch statement, that is used in situations like this.  The switch statement is like a multiple branch.  You give it an expression that can be any integer type, including char or enum, and then list the various values the expression can take on, followed by a colon, and the statement to execute.  After evaluating the condition, the switch statement jumps to something called a case label, which must appear in the statement (usually a compound statement) that follows the switch condition.  Using a switch statement, the PrintValue function becomes\par \par }\pard\plain \s23\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 void PrintValue (enum value v)\par \par /* Print the value of a card           */\par /*                                     */\par /* Parameters:                         */\par /*    v - value of the card            */\par \par \{\par switch (v) \{\par    case two:   printf("two");\par                break;\par    case three: printf("three");\par                break;\par    case four:  printf("four");\par                break;\par    case five:  printf("five");\par                break;\par    case six:   printf("six");\par                break;\par    case seven: printf("seven");\par                break;\par    case eight: printf("eight");\par                break;\par    case nine:  printf("nine");\par                break;\par    case ten:   printf("ten");\par                break;\par    case jack:  printf("jack");\par                break;\par    case queen: printf("queen");\par                break;\par    case king:  printf("king");\par                break;\par    case ace:   printf("ace");\par                break;\par    \}\par }\pard \s23\widctlpar\adjustright {\fs18 \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par There is another new thing in the switch statement that you probably noticed, but to understand why it is there, you need to know a little more about how the switch statement works.  We'll use this short program to explore the details of the switch statement:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main (void)\par \par \{\par unsigned i;\par \par for (i = 1; i <= 5; ++i) \{\par    switch (i) \{\par       case 1: printf("*");\par       case 2: printf("**");\par       case 3: printf("***");\par       case 4: printf("****");\par       case 5: printf("*****");\par       \}\par    printf("\\n");\par    \}\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par A simple look at this program might lead you to believe that it would print this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {*\par **\par ***\par ****\par *****\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {After all, the idea behind the switch statement is to evaluate the switch condition, and branch to the appropriate line in the switch statement.  Try running it, though.  What really gets printed is this:\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {***************\par **************\par ************\par *********\par *****\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par To see why, fire up the debugger, and trace through the program.  The first loop tells the whole story.  When i is 1, the program does, in fact, execute the printf that prints a single * character, but then it continues right on, executing the next four printf statements, too.\par Now add break statements after each printf statement, like this, and try the program again.  Once again, be sure you try the debugger.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main (void)\par \par \{\par unsigned i;\par \par for (i = 1; i <= 5; ++i) \{\par    switch (i) \{\par       case 1: printf("*");\par               break;\par       case 2: printf("**");\par               break;\par       case 3: printf("***");\par               break;\par       case 4: printf("****");\par               break;\par       case 5: printf("*****");\par       \}\par    printf("\\n");\par    \}\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par This time, right after each printf, the program hits a break statement.  The break statement tells the compiler to get out of the switch statement right away.\par If you look closely at the program, you may notice that there is no break statement right after the last printf statement.  If you were to put one in, it would not cause any harm, but the program ends up doing the same thing either way.  In one case, the break statement jumps out of the switch; without the break statement, the program falls through the end of the switch statement.  Either way, the program ends up executing the printf that writes the \\n character as the next statement.\par In some compilers, the program will be a tiny bit shorter and faster if you leave out that last break, while other compilers will create the same program either way.  Even if the compiler happens to create a slightly less efficient program, though, the difference is rarely important.  You may want to put a break after every series of statements in the switch statement, just as an anti-bug habit.  Frankly, I do.\par If there is a label for the switch value, it is easy to see what the switch statement does, but what if there isn't?  What if, for example, you looped from 1 to 6 in the sample program, instead of 1 to 5?  If this happens, the program bypasses all of the statements in the switch statement, almost as if a break were executed right away.\par There are sometimes situations in a program where you want to handle a few cases, but not all.  There are also many situations when it makes sense to have a default handler.  In this situation, you can use a special switch statement label called default.  It looks just like the other switch statement labels, but statement after the default label is executed whenever no other label is matched.  It's a lot like an else at the end of a long series of if-else statements.  The following example, coded both as a series of if statements and as a switch statement, shows how the default label is used.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {for (i = 1; i < 10; ++i)\par    if (i == 1)\par       printf("1st\\n");\par    else if (i == 2)\par       printf("2nd\\n");\par    else if (i == 3)\par       printf("3rd\\n");\par    else\par }\pard \s23\qj\fi360\widctlpar\adjustright {      printf("%dth\\n", i);\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {for (i = 1; i < 10; ++i)\par    switch (i) \{\par       case 1: printf("1st\\n");\par               break;\par       case 2: printf("2nd\\n");\par               break;\par       case 3: printf("3rd\\n");\par               break;\par      default: printf("%dth\\n",\par                      i);\par }\pard \s23\qj\fi360\widctlpar\adjustright {      \}\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }{\b Problem 7.5. }{ Change the card shuffle sample to use switch statements instead of repeated if statements.\par \par }{\b Problem 7.6.}{  The fact that you have to remember to put a break statement after each and every series of statements in a switch loop has caused endless bugs down though the ages, but the way C's switch statement works can be put to good use, too.  Rewrite the simple sample from this section that prints a series of asterisks on separate lines so that it still prints one, then two, and so forth asterisks, but figure out a way to do it without break statements.  The idea you discover can occasionally save you a lot of code in a C program.\par \par }\pard\plain \qc\widctlpar\adjustright \f4\cgrid {\b\fs36 \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \qc\widctlpar\adjustright \f4\cgrid {\b\fs36 Lesson Seven\par Solutions to Problems\par }\pard \qj\widctlpar\adjustright {\b\fs28 \par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {Solution to problem 7.1.\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Rotate a square in the graphics window.       */\par /*                                               */\par /* This program makes use of two constants,      */\par /* XSCALE and YSCALE, to decide how to convert   */\par /* from the real numbers used to represent the   */\par /* points of the cube into the integer           */\par /* coordinates used by QuickDraw.  These values  */\par /* will convert from inches to pixels in 640     */\par /* mode on a 12" monitor.                        */\par \par #include <quickdraw.h>\par #include <math.h>\par \par #define XSCALE 86               /* x conversion factor */\par #define YSCALE 33               /* y conversion factor */\par #define pi 3.1415927            /* circumference of a circle */\par \par typedef float square[4];        /* type for a square */\par \par \par void InitGraphics (void)\par \par /* Standard graphics initialization            */\par \par \{\par SetPenMode(0);                  /* pen mode = copy */\par SetSolidPenPat(0);              /* pen color = black */\par SetPenSize(3,1);                /* use a square pen */\par \}\par \par \par void Rotate (float *x, float *y, float angle, float ox, float oy)\par \par /* Rotate the point x,y about ox,oy through   */\par /* the angle given.                           */\par /*                                            */\par /* Parameters:                                */\par /*    x,y - point to rotate                   */\par /*    angle - angle to rotate (in radians)    */\par /*    ox,oy - point to rotate around          */\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {\{\par }\pard \s23\qj\fi360\widctlpar\adjustright {float cosAngle,sinAngle;        /* sin and cos of angle */\par float nx;                       /* new x */\par \par *x -= ox;                       /* move the point */\par *y -= oy;\par cosAngle = cos(angle);          /* this takes time - save the results */\par sinAngle = sin(angle);\par nx = *x * cosAngle + *y * sinAngle; /* rotate the point */\par *y = *y * cosAngle - *x * sinAngle;\par *x = nx+ox;                     /* move the point back */\par *y = *y+oy;\par \}\par \par \par void RotateSquare (square x, square y)\par \par /* Rotate the square 9 degrees                */\par /*                                            */\par /* Parameters:                                */\par /*    x,y - coordinates of square             */\par \par \{\par unsigned i;                     /* loop variable */\par \par for (i = 0; i < 4; ++i)\par    Rotate(&x[i], &y[i], pi/20.0, 1.5, 1.5);\par \}\par \par \par void DrawSquare (int color, square x, square y)\par \par /* Draw the square                            */\par /*                                            */\par /* Parameters:                                */\par /*    color - color to draw                   */\par /*    x,y - coordinates of the square         */\par \par \{\par SetSolidPenPat(color);       /* set the pen color */\par                              /* draw the square */\par MoveTo((int) (x[0]*XSCALE), (int) (y[0]*YSCALE));\par LineTo((int) (x[1]*XSCALE), (int) (y[1]*YSCALE));\par LineTo((int) (x[2]*XSCALE), (int) (y[2]*YSCALE));\par LineTo((int) (x[3]*XSCALE), (int) (y[3]*YSCALE));\par LineTo((int) (x[0]*XSCALE), (int) (y[0]*YSCALE));\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void main(void)\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par /* Main program                               */\par \par \{\par square x,y,oldX,oldY;           /* points in the square */\par unsigned i,j;                   /* loop variables */\par \par InitGraphics();                 /* set up the graphics window */\par x[0] = 1.0;   y[0] = 1.0;       /* initialize the square */\par x[1] = 2.0;   y[1] = 1.0;\par x[2] = 2.0;   y[2] = 2.0;\par x[3] = 1.0;   y[3] = 2.0;\par DrawSquare(0, x, y);            /* draw the square */\par \par for (i = 0; i < 10; ++i) \{\par    for (j = 0; j < 4; ++j) \{    /* save the current location */\par       oldX[j] = x[j];\par       oldY[j] = y[j];\par       \}\par    RotateSquare(x, y);          /* rotate */\par    DrawSquare(3, oldX, oldY);   /* erase the old square */\par    DrawSquare(0, x, y);         /* draw the square */\par    \}\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344496}Solution to problem 7.2.{\*\bkmkend _Toc496344496}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* This program plays Acey Ducey                                */\par /*                                                              */\par /* Acey Ducey is a card game played, in this case, between the  */\par /* computer and the human.  The computer draws and displays two */\par /* cards.  The player then decides how much to bet, and a third */\par /* card is drawn.  If it is between the first two, the player   */\par /* wins, and gets back double the bet.  If it is not between    */\par /* the two cards, the computer wins, and the player looses the  */\par /* bet.  The game continues until the player looses all of his  */\par /* money, or until the player signals the end of the game with  */\par /* a negative bet.                                              */\par /*                                                              */\par /* The deck of cards is represented by a pair of arrays.  Each  */\par /* array has one position for each of the 52 cards in a         */\par /* standard deck of playing cards.  One array gives the value   */\par /* of the card (see the value enumeration), while the other     */\par /* gives the suit (see the suit enumeration).                   */\par \par #include <stdio.h>\par #include <stdlib.h>\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {                                        /* suits of cards */\par }\pard \s23\qj\fi360\widctlpar\adjustright {enum suit \{spades, diamonds, clubs, hearts\};\par                                         /* face value of cards */\par enum value \{two, three, four, five, six, seven, eight, nine, ten,\par             jack, queen, king, ace\};\par \par typedef unsigned boolean;               /* set up boolean logic */\par #define TRUE 1\par #define FALSE 0\par \par typedef enum suit suitDeck[52];         /* these two arrays define */\par typedef enum value valueDeck[52];       /* a deck of cards         */\par \par suitDeck suits;                         /* our deck of cards */\par valueDeck values;\par boolean done;                           /* is the game over? */\par unsigned hands;                      /* # of hands played from the deck */\par float money;                            /* amount of money left */\par unsigned nextCard;                      /* next card in the deck */\par \par \par unsigned RandomValue (unsigned max)\par \par /* Return a pseudo-random number in the range 1..max.              */\par /*                                                                 */\par /* Parameters:                                                     */\par /*    max - largest number to return                               */\par /*    color - interior color of the rectangle                      */\par \par \{\par return rand() % max + 1;\par \}\par \par \par void InitializeDeck (suitDeck suits, valueDeck values)\par \par /* Fills in the values to define a sorted deck of cards         */\par /*                                                              */\par /* Parameters:                                                  */\par /*    suits - array of the card suits                           */\par /*    values - array of the card values                         */\par \par \{\par unsigned i;                             /* loop variable */\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {for (i = 0; i < 13; ++i) \{              /* initialize the suit array */\par    suits[i] = spades;\par    suits[i+13] = diamonds;\par    suits[i+26] = clubs;\par    suits[i+39] = hearts;\par }\pard \s23\qj\fi360\widctlpar\adjustright {   \}\par \par values[0] = two;                        /* initialize the first suit */\par values[1] = three;\par values[2] = four;\par values[3] = five;\par values[4] = six;\par values[5] = seven;\par values[6] = eight;\par values[7] = nine;\par values[8] = ten;\par values[9] = jack;\par values[10] = queen;\par values[11] = king;\par values[12] = ace;\par for (i = 13; i < 52; ++i)               /* copy the first suit to the */\par    values[i] = values[i-13];            /* remaining suits            */\par \}\par \par \par void Shuffle(suitDeck suits, valueDeck values)\par \par /* Shuffles the deck of cards                                   */\par /*                                                              */\par /* Parameters:                                                  */\par /*    suits - array of the card suits                           */\par /*    values - array of the card values                         */\par \par \{\par unsigned i;                             /* loop variable */\par unsigned j;                           /* card to swap with current card */\par enum value tvalue;                      /* temp value; for swap */\par enum suit tsuit;                        /* temp suit; for swap */\par \par for (i = 0; i < 52-1; ++i) \{\par    j = RandomValue(52 - i) + i - 1;\par    tvalue = values[i];\par    values[i] = values[j];\par    values[j] = tvalue;\par    tsuit = suits[i];\par    suits[i] = suits[j];\par    suits[j] = tsuit;\par    \}\par \}\par \par \par void PrintValue (enum value v)\par \par /* Print the value of a card                                 */\par /*                                                           */\par /* Parameters:                                               */\par /*    v - value of the card                                  */\par \par \{\par if (v == two)\par    printf("two");\par else if (v == three)\par    printf("three");\par else if (v == four)\par    printf("four");\par else if (v == five)\par    printf("five");\par else if (v == six)\par    printf("six");\par else if (v == seven)\par    printf("seven");\par else if (v == eight)\par    printf("eight");\par else if (v == nine)\par    printf("nine");\par else if (v == ten)\par    printf("ten");\par else if (v == jack)\par    printf("jack");\par else if (v == queen)\par    printf("queen");\par else if (v == king)\par    printf("king");\par else if (v == ace)\par    printf("ace");\par \}\par \par \par void PrintSuit (enum suit s)\par \par /* Print the suit of a card                                  */\par /*                                                           */\par /* Parameters:                                               */\par /*    s - suit of the card                                   */\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {\{\par if (s == spades)\par    printf("spades");\par else if (s == diamonds)\par    printf("diamonds");\par }\pard \s23\qj\fi360\widctlpar\adjustright {else if (s == clubs)\par    printf("clubs");\par else if (s == hearts)\par    printf("hearts");\par \}\par \par void PrintCard (enum suit s, enum value v)\par \par /* Print a card                                                 */\par /*                                                              */\par /* Parameters:                                                  */\par /*    s - suit                                                  */\par /*    v - values                                                */\par \par \{\par PrintValue(v);\par printf(" of ");\par PrintSuit(s);\par printf("\\n");\par \}\par \par \par void PlayHand (void)\par \par /* Play one hand of Acey Ducey.                                 */\par /*                                                              */\par /* Variables:                                                   */\par /*    done - game over flag                                     */\par /*    money - amount of money the player has                    */\par /*    nextCard - next card to draw from the deck                */\par /*    suits,values - deck of cards                              */\par \par \{\par float bet;                              /* player's bet */\par enum value v1,v2,v3;                    /* value of the three cards */\par \par printf("\\nI draw:\\n");\par v1 = values[nextCard];                  /* draw the first card */\par PrintCard(suits[nextCard], v1);\par ++nextCard;\par v2 = values[nextCard];                  /* draw the second card */\par PrintCard(suits[nextCard], v2);\par ++nextCard;\par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {if (v2 < v1) \{                          /* sort the values */\par    v3 = v2;\par }\pard \s23\qj\fi360\widctlpar\adjustright {   v2 = v1;\par    v1 = v3;\par    \}\par do \{                                    /* get the bet */\par    printf("You have %.2f left.\\nYour bet:", money);\par    scanf(" %f", &bet);\par    if (bet < 0.0)\par       done = TRUE;\par    else if (bet > money)\par       printf("Sorry, you don't have that much.\\n");\par    \}\par while (bet > money);\par if (! done) \{\par    v3 = values[nextCard];               /* draw the third card */\par    printf("Your card is:\\n");\par    PrintCard(suits[nextCard], v3);\par    ++nextCard;\par    if ((v1 < v3) && (v3 < v2)) \{\par       money += bet;                     /* player wins */\par       printf("You win!\\n");\par       \}\par    else \{\par       money -= bet;                     /* player looses */\par       printf("Sorry, you loose.\\n");\par       if (money <= 0.0) \{               /* see if he's broke */\par          printf("You are out of money.  So long!\\n");\par          done = TRUE;\par          \}\par       \}\par    \}\par \}\par \par \par void GetSeed (void)\par \par /* Initialize the random number generator                       */\par \par \{\par int i;                                  /* integer from keyboard */\par \par printf("Please enter a number from\\n1000 to 30000:");\par scanf(" %d", &i);\par srand(i);\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void main (void)\par \par }\pard \s23\qj\fi360\widctlpar\adjustright {/* Main program                                                 */\par \par \{\par money = 50.0;                    /* player starts with $50 */\par GetSeed();                    /* initialize the random number generator */\par \par InitializeDeck(suits, values);   /* get a new (sorted) deck of cards */\par hands = 17;                      /* this forces an immediate shuffle */\par done = FALSE;                    /* not done, yet */\par do \{\par    if (hands = 17) \{             /* reshuffle after 17 hands */\par       Shuffle(suits, values);    /* shuffle the deck */\par       hands = 0;                 /* no hands played from the deck */\par       nextCard = 1;              /* next card to draw */\par       \}\par    PlayHand();                   /* play one hand of Acey Ducey */\par    ++hands;                      /* update the # of hands played */\par    \}\par while (!done);\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344497}Solution to problem 7.3.{\*\bkmkend _Toc496344497}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* This program shuffles a deck of cards, then prints the       */\par /* results.                                                     */\par /*                                                              */\par /* The deck of cards is represented by a pair of arrays.  Each  */\par /* array has one position for each of the 52 cards in a         */\par /* standard deck of playing cards.  One array gives the value   */\par /* of the card (see the value enumeration), while the other     */\par /* gives the suit (see the suit enumeration).                   */\par \par #include <stdio.h>\par #include <stdlib.h>\par \par                                         /* suits of cards */\par enum suit \{spades, diamonds, clubs, hearts\};\par                                         /* face value of cards */\par enum value \{two, three, four, five, six, seven, eight, nine, ten,\par             jack, queen, king, ace\};\par \par struct card \{                           /* one card in a deck */\par              enum value v;\par              enum suit s;\par             \};\par \par struct card deck[52];                   /* our deck of cards */\par \par \par unsigned RandomValue (unsigned max)\par \par /* Return a pseudo-random number in the range 1..max.              */\par /*                                                                 */\par /* Parameters:                                                     */\par /*    max - largest number to return                               */\par /*    color - interior color of the rectangle                      */\par \par \{\par return rand() % max + 1;\par \}\par \par \par void InitializeDeck (struct card deck[52])\par \par /* Fills in the values to define a sorted deck of cards         */\par /*                                                              */\par /* Parameters:                                                  */\par /*    deck - array of cards                                     */\par \par \{\par unsigned i;                             /* loop variable */\par \par for (i = 0; i < 13; ++i) \{              /* initialize the suit array */\par    deck[i].s = spades;\par    deck[i+13].s = diamonds;\par    deck[i+26].s = clubs;\par    deck[i+39].s = hearts;\par    \}\par \par deck[0].v = two;                        /* initialize the first suit */\par deck[1].v = three;\par deck[2].v = four;\par deck[3].v = five;\par deck[4].v = six;\par deck[5].v = seven;\par deck[6].v = eight;\par deck[7].v = nine;\par deck[8].v = ten;\par deck[9].v = jack;\par deck[10].v = queen;\par deck[11].v = king;\par deck[12].v = ace;\par for (i = 13; i < 52; ++i)               /* copy the first suit to the */\par    deck[i].v = deck[i-13].v;            /* remaining suits            */\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void Shuffle(struct card deck[52])\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par /* Shuffles the deck of cards                                   */\par /*                                                              */\par /* Parameters:                                                  */\par /*    deck - array of cards                                     */\par \par \{\par unsigned i;                             /* loop variable */\par unsigned j;                           /* card to swap with current card */\par struct card tcard;                      /* temp card; for swap */\par \par for (i = 0; i < 52-1; ++i) \{\par    j = RandomValue(52 - i) + i - 1;\par    tcard = deck[i];\par    deck[i] = deck[j];\par    deck[j] = tcard;\par    \}\par \}\par \par \par void PrintValue (enum value v)\par \par /* Print the value of a card                                 */\par /*                                                           */\par /* Parameters:                                               */\par /*    v - value of the card                                  */\par \par \{\par if (v == two)\par    printf("two");\par else if (v == three)\par    printf("three");\par else if (v == four)\par    printf("four");\par else if (v == five)\par    printf("five");\par else if (v == six)\par    printf("six");\par else if (v == seven)\par    printf("seven");\par else if (v == eight)\par    printf("eight");\par else if (v == nine)\par    printf("nine");\par else if (v == ten)\par    printf("ten");\par else if (v == jack)\par    printf("jack");\par else if (v == queen)\par    printf("queen");\par else if (v == king)\par    printf("king");\par else if (v == ace)\par    printf("ace");\par \}\par \par \par void PrintSuit (enum suit s)\par \par /* Print the suit of a card                                  */\par /*                                                           */\par /* Parameters:                                               */\par /*    s - suit of the card                                   */\par \par \{\par if (s == spades)\par    printf("spades");\par else if (s == diamonds)\par    printf("diamonds");\par else if (s == clubs)\par    printf("clubs");\par else if (s == hearts)\par    printf("hearts");\par \}\par \par void PrintDeck (struct card deck[52])\par \par /* Prints the cards in order                                    */\par /*                                                              */\par /* Parameters:                                                  */\par /*    deck - array of cards                                     */\par \par \{\par unsigned i;                             /* loop variable */\par \par for (i = 0; i < 52; ++i) \{\par    PrintValue(deck[i].v);\par    printf(" of ");\par    PrintSuit(deck[i].s);\par    printf("\\n");\par    \}\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void main (void)\par \par /* Main program                                                 */\par \par \{\par }\pard \s23\qj\fi360\widctlpar\adjustright {srand(1234);                  /* initialize the random number generator */\par InitializeDeck(deck);           /* get a new (sorted) deck of cards */\par Shuffle(deck);                  /* shuffle the deck */\par PrintDeck(deck);                /* print the shuffled deck */\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344498}Solution to problem 7.4.{\*\bkmkend _Toc496344498}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* This program demonstrates typedef used with enum */\par \par #include <stdio.h>\par \par typedef enum weekDay \{\par                       sunday, monday, teusday, wednesday, thursday,\par                       friday, saturday\par                      \} weekDay;\par \par void PrintDay (weekDay day)\par \par /* Print the day of the week                            */\par /*                                                      */\par /* Parameters:                                          */\par /*    day - day of the week                             */\par \par \{\par if (day == sunday)\par    printf("Sunday");\par else if (day == monday)\par    printf("Monday");\par else if (day == teusday)\par    printf("Teusday");\par else if (day == wednesday)\par    printf("Wednesday");\par else if (day == thursday)\par    printf("Thursday");\par else if (day == friday)\par    printf("Friday");\par else if (day == saturday)\par    printf("Saturday");\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void main(void)\par \par \{\par }\pard \s23\qj\fi360\widctlpar\adjustright {weekDay day;\par \par for (day = sunday; day <= saturday; ++day) \{\par    PrintDay(day);\par    printf("\\n");\par    \}\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344499}Solution to problem 7.5.{\*\bkmkend _Toc496344499}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* This program shuffles a deck of cards, then prints the       */\par /* results.                                                     */\par /*                                                              */\par /* The deck of cards is represented by a pair of arrays.  Each  */\par /* array has one position for each of the 52 cards in a         */\par /* standard deck of playing cards.  One array gives the value   */\par /* of the card (see the value enumeration), while the other     */\par /* gives the suit (see the suit enumeration).                   */\par \par #include <stdio.h>\par #include <stdlib.h>\par \par                                         /* suits of cards */\par enum suit \{spades, diamonds, clubs, hearts\};\par                                         /* face value of cards */\par enum value \{two, three, four, five, six, seven, eight, nine, ten,\par             jack, queen, king, ace\};\par \par enum suit suitDeck[52];                 /* these two arrays define */\par enum value valueDeck[52];               /* a deck of cards         */\par \par \par unsigned RandomValue (unsigned max)\par \par /* Return a pseudo-random number in the range 1..max.              */\par /*                                                                 */\par /* Parameters:                                                     */\par /*    max - largest number to return                               */\par /*    color - interior color of the rectangle                      */\par \par \{\par return rand() % max + 1;\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void InitializeDeck (enum suit suits[52], enum value values[52])\par \par }\pard \s23\qj\fi360\widctlpar\adjustright {/* Fills in the values to define a sorted deck of cards         */\par /*                                                              */\par /* Parameters:                                                  */\par /*    suits - array of the card suits                           */\par /*    values - array of the card values                         */\par \par \{\par unsigned i;                             /* loop variable */\par \par for (i = 0; i < 13; ++i) \{              /* initialize the suit array */\par    suits[i] = spades;\par    suits[i+13] = diamonds;\par    suits[i+26] = clubs;\par    suits[i+39] = hearts;\par    \}\par \par values[0] = two;                        /* initialize the first suit */\par values[1] = three;\par values[2] = four;\par values[3] = five;\par values[4] = six;\par values[5] = seven;\par values[6] = eight;\par values[7] = nine;\par values[8] = ten;\par values[9] = jack;\par values[10] = queen;\par values[11] = king;\par values[12] = ace;\par for (i = 13; i < 52; ++i)               /* copy the first suit to the */\par    values[i] = values[i-13];            /* remaining suits            */\par \}\par \par \par void Shuffle (enum suit suits[52], enum value values[52])\par \par /* Shuffles the deck of cards                                   */\par /*                                                              */\par /* Parameters:                                                  */\par /*    suits - array of the card suits                           */\par /*    values - array of the card values                         */\par \par \{\par unsigned i;                             /* loop variable */\par unsigned j;                           /* card to swap with current card */\par enum value tvalue;                      /* temp value; used for swap */\par enum suit tsuit;                        /* temp suit; used for swap */\par \par for (i = 0; i < 52-1; ++i) \{\par    j = RandomValue(52 - i) + i - 1;\par    tsuit = suits[i];\par    suits[i] = suits[j];\par    suits[j] = tsuit;\par    tvalue = values[i];\par    values[i] = values[j];\par    values[j] = tvalue;\par    \}\par \}\par \par \par void PrintValue (enum value v)\par \par /* Print the value of a card                                 */\par /*                                                           */\par /* Parameters:                                               */\par /*    v - value of the card                                  */\par \par \{\par switch (v) \{\par    case two:   printf("two");\par                break;\par    case three: printf("three");\par                break;\par    case four:  printf("four");\par                break;\par    case five:  printf("five");\par                break;\par    case six:   printf("six");\par                break;\par    case seven: printf("seven");\par                break;\par    case eight: printf("eight");\par                break;\par    case nine:  printf("nine");\par                break;\par    case ten:   printf("ten");\par                break;\par    case jack:  printf("jack");\par                break;\par    case queen: printf("queen");\par                break;\par    case king:  printf("king");\par                break;\par    case ace:   printf("ace");\par                break;\par    \}\par \}\par \par \par void PrintSuit (enum suit s)\par \par /* Print the suit of a card                                  */\par /*                                                           */\par /* Parameters:                                               */\par /*    s - suit of the card                                   */\par \par \{\par switch (s) \{\par    case spades:    printf("spades");\par                    break;\par    case diamonds:  printf("diamonds");\par                    break;\par    case clubs:     printf("clubs");\par                    break;\par    case hearts:    printf("hearts");\par                    break;\par    \}\par \}\par \par void PrintDeck (enum suit suits[52], enum value values[52])\par \par /* Prints the cards in order                                    */\par /*                                                              */\par /* Parameters:                                                  */\par /*    suits - array of the card suits                           */\par /*    values - array of the card values                         */\par \par \{\par unsigned i;                             /* loop variable */\par \par for (i = 0; i < 52; ++i) \{\par    PrintValue(values[i]);\par    printf(" of ");\par    PrintSuit(suits[i]);\par    printf("\\n");\par    \}\par \}\par \par \par void main (void)\par \par /* Main program                                                 */\par \par \{\par srand(1234);                  /* initialize the random number generator */\par InitializeDeck(suitDeck, valueDeck);/* get a new (sorted) deck of cards */\par Shuffle(suitDeck, valueDeck);         /* shuffle the deck */\par PrintDeck(suitDeck, valueDeck);       /* print the shuffled deck */\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344500}Solution to problem 7.6.{\*\bkmkend _Toc496344500}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Demonstrates that leaving out the break statement    */\par /* can occasionally result in shorter programs.         */\par \par #include <stdio.h>\par \par void main (void)\par \par \{\par unsigned i;\par \par for (i = 1; i <= 5; ++i) \{\par    switch (i) \{\par       case 5: printf("*");\par       case 4: printf("*");\par       case 3: printf("*");\par       case 2: printf("*");\par       case 1: printf("*");\par       \}\par    printf("\\n");\par    \}\par \}\par }\pard\plain \widctlpar\adjustright \f4\cgrid {\par \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s1\qc\nowidctlpar\outlinelevel0\adjustright \b\f4\fs36\cgrid {{\*\bkmkstart _Toc496344501}Lesson Eight{\*\bkmkend _Toc496344501}\par {\*\bkmkstart _Toc496344502}Pointers and Lists{\*\bkmkend _Toc496344502}\par }\pard\plain \qj\widctlpar\adjustright \f4\cgrid {\b\fs28 \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344503}What is a Pointer?{\*\bkmkend _Toc496344503}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {By now, you have used two very powerful techniques to organize information in C.  Arrays are use to handle a large amount of information when all of the pieces are the same type, while structures are used to collect different kinds of information into a single variable.\par While these types are very powerful, there is one situation they do not handle well.  In many programs, you don't know in advance how many pieces of information you need to deal with.  For example, a program to manage a mailing list may have a few hundred entries when one person uses it, but several thousand for another person.  One solution is to allocate an array that will be big enough to hold some maximum number, and leave it at that.  Of course, that presents a problem, too.  If one person has a computer with 1.25M of memory, they may be able to handle a mailing list with 7000 or 8000 entries.  Unfortunately, the program would be to large to run on a computer with 768K, and would not make effective use of all of the memory in a 2M machine.\par Of course, you may not ever intend to write a commercial application.  On your own machine, you know how much memory you have, right?  Well, that could be true, but fixed size arrays present other problems.  Many programs have to handle more than one kind of data at the same time.  For example, an adventure game might need one array for handling the rooms in a castle, and another array for keeping track of the various inhabitants.  You can try to make effective use of memory by guessing in advance how big each array needs to be, but if you guess wrong, you could overflow one array while there is still plenty of room in the other.\par In all of these situations, the problem is that you know there is a lot of memory out there, but you don't always know, in advance, how much memory is available or exactly what you will need to use it for when the program runs.  The amount of memory used by an array or structure is determined when the program is written, and cannot be changed without recompiling the program.  What we need is a way to ask for a chunk of memory while the program is running.  Programmers call this }{\i dynamically allocated memory}{.  Since the compiler doesn't know where the memory will be when you compile the program, or even how much will be allocated, you need some way of keeping track of the memory.  That is one of the most common uses for the pointer, a data type you have already seen used to pass variables to functions.  A pointer }{\i points to}{ a memory location.  In terms of the C program, a pointer points to a variable.  The variable can be a simple variable, like an integer or a floating-point number; a structure; an array; or even another pointer.  In short, a pointer can point to a variable of absolutely any type.\par I don't want to scare you off, but pointers tend to give beginners a lot of trouble.  Part of the reason people have trouble with pointers is that the idea of dynamically allocated memory is foreign to those of you who cut your teeth on BASIC.  If pointers are a new concept for you, you should expect it to take some time before you become comfortable with them.  Another factor is that pointers have their own operator, the * operator, which is easy to confuse with the multiplication operator.  A lot of people get confused by this operator, which controls when you are dealing with a pointer, and when you are dealing with the thing it is pointing to.  Finally, there is a bit of magic about pointers in a high-level language.  The other data types we have dealt with were definite, fixed structures.  You could get a handle on what they do, and how they work.  From a language like C, there are some mysteries to how pointers work, since the language takes care of a lot of details.  It is only from assembly language that you really see how pointers work \endash  and, if you ever learn enough assembly language to learn how pointers work, you will probably follow in the footsteps of the vast majority of programmers, and return to a language like C that handles all of those mucky details for you!\par A realistic example of how pointers and dynamic memory are used in a real program is well beyond what you are likely to understand at this point, so some of the first few examples will seem very simplistic and contrived.  You will look at them and wonder why we are using pointers at all, when you can easily see better ways to write the program without a pointer.  Well, you are right, but we will use some simple programs to get used to the mechanics of pointers.  By the end of the lesson, though, you will be dealing with data structures that you could not handle with arrays.  In the next few lessons, we will start doing things with pointers that are very difficult to do with arrays.  In some cases, in C at least, some of the things we will do can't be done any other way than by the use of pointers.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344504}Pointers are Variables, Too!{\*\bkmkend _Toc496344504}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {You have already had one brief look at pointers, back when we discussed how to use them to pass a value to a function in such a way that the function could change the variable we passed.  In that case, though, you only defined a pointer as a parameter.  It turns out that you can use the same idea to declare pointers as either global or local variables.  No matter where you define a pointer, though, and no matter what it points to, the general mechanism is the same: you put an * character right before the name of the variable.  The variable is then a pointer to the type that it would have been without the * character in place.  For example, to define a pointer to a char, you could use the declaration\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {char *cptr;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par A pointer is a strange, hybrid type.  The type of the variable cptr is pointer to char, and a pointer is a very real thing, so you can set a pointer to point to a variable, set a pointer to point to some dynamically allocated piece of memory, set a pointer to point to nothing in particular, or even set a pointer to point to the same thing as some other pointer.  In all of these cases, you use the name of the pointer, just as you would use the name of a variable to set or access the variable.  In the end, though, you will want to get at the thing the pointer points to, not the pointer itself.  To do that, you put the * character right before the variable name, just as you did when the pointer was declared.  Any time the * comes before the variable name, C will load or store to the value the pointer points at, not to the pointer itself.\par For example, the assignments shown in the following program are legal, although the program itself has some problems.  (Do not run this program!)\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par int i, j, *ip;\par \par j = 4;\par *ip = j;\par i = *ip;\par printf("%d\\n", i);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Let's step through the program, looking at what it is doing.  First, we assign the value 4 to j.  Nothing is new there; you've done that sort of thing dozens of times.  The next line, though, assigns the integer j to the value pointed to by ip.  Keep in mind that we are not assigning a value to the variable ip, we are assigning a value to the variable }{\i pointed at}{ by the variable ip.  That's what the * operator does for us; it tells the compiler that we want the value pointed at, not the pointer.\par The next line,\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {i = *ip;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par uses the same idea to assign the value pointed to by ip to the variable i.  Finally, the value of i is printed.  The value should be 4.\par Unfortunately, this program has a very, very serious flaw.  In is a very common error in programs that use pointers.  In fact, it is one of the most common causes of crashes on the Apple IIGS, in any kind of program.  Did you catch the flaw?\par }{\i What does ip point to?}{\par What if ip points to the location in memory that turns on your floppy disk drive?  The disk drive would start to spin.\par What if ip happens to point to memory allocated by the GS/OS operating system that holds a block of a data file?  When you save the file, it will have some garbage information in it.\par What if ip points into the middle of your program?  Your program may crash.\par What if ip points to the locations PRIZM is using to store the characters in your source file?  You will see garbage in the file.\par Worst of all, what if ip points to some memory that isn't being used for anything?  You might think the program works, and pass it around to friends.  It could then do all of these nasty things to }{\i their}{ computer.  This, of course, is not a good way to keep friends.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344505}Allocating and Deallocating Memory{\*\bkmkend _Toc496344505}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {In short, pointers are no good without a way to get some memory for them to point to.  You have used the address operator in the past to set the value of a pointer, but we need to learn a new way to set up a pointer, now.  The C standard library gives us a function called malloc to get some new memory.  When you are finished with the memory, the function free can be used to get rid of the memory.  Both functions are declared in the header file stdlib.h, but you have to be careful here: some older C compilers declare malloc in other header files, and a few don't declare it at all.  If you are moving your program from system to system, you need to be sure you read the documentation for each compiler to see how malloc is implemented in the other compilers.  If the compiler follows the ANSI C standard, though, malloc and free will be in stdlib.h.\par We can change our program from the last section into a safe one using these function.  This program is one you can run!\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par #include <stdlib.h>\par \par void main (void)\par \par }{\lang1024 {\shp{\*\shpinst\shpleft4752\shptop226\shpright9360\shpbottom9874\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz27\shplid1159{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 3801088}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s22\qc\sa200\nowidctlpar\adjustright \b\f4\fs20\cgrid {How malloc and free Work\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The process used to allocate and deallocate dynamic memory is a bit involved, and has nothing in particular to do with the way you write your C program, but it is interesting.\par One of the basic parts of the Apple IIGS operating system is the memory manager.  The memory manager is responsible for finding free memory and giving it to the various programs in the computer.  Even if your program is the only one you think is running, it turns out that many other programs are calling the memory manager to get memory, too.  The GS/OS disk operating system calls the memory manager, as do many of the toolkits.  PRIZM is calling the memory manager to get space for your program.  Many desk accessories call the memory manager.  Some of them may even install interrupt handlers, which can be running while your program is doing something else.\par When you call malloc for the first time, the program makes a call to the memory manager to get a 4K block of memory.  This memory is then subdivided into smaller and smaller pieces, dividing the block in half each time, until the program gets a chunk of memory of about the right size.  In our program you need two bytes to hold the integer, and the library subroutine allocating the memory needs four bytes to keep track of all of the small pointers, so a total of eight bytes is actually taken from the 4K chunk of memory.  (Remember, the number of bytes will be a power of two.)  This method tends to waste a few bytes of memory now and then, but it turns out that it is very fast.  It has some other technical advantages, too, that we won't go into here.\par When you call free at the end of the program, the small block of memory is deallocated.  Since it was the only piece of memory being used in the 4K block, the 4K block is also returned to the memory manager, where it can be reused by other programs.\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8219\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s22\qc\sa200\nowidctlpar\adjustright \b\f4\fs20\cgrid {How malloc and free Work\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The process used to allocate and deallocate dynamic memory is a bit involved, and has nothing in particular to do with the way you write your C program, but it is interesting.\par One of the basic parts of the Apple IIGS operating system is the memory manager.  The memory manager is responsible for finding free memory and giving it to the various programs in the computer.  Even if your program is the only one you think is running, it turns out that many other programs are calling the memory manager to get memory, too.  The GS/OS disk operating system calls the memory manager, as do many of the toolkits.  PRIZM is calling the memory manager to get space for your program.  Many desk accessories call the memory manager.  Some of them may even install interrupt handlers, which can be running while your program is doing something else.\par When you call malloc for the first time, the program makes a call to the memory manager to get a 4K block of memory.  This memory is then subdivided into smaller and smaller pieces, dividing the block in half each time, until the program gets a chunk of memory of about the right size.  In our program you need two bytes to hold the integer, and the library subroutine allocating the memory needs four bytes to keep track of all of the small pointers, so a total of eight bytes is actually taken from the 4K chunk of memory.  (Remember, the number of bytes will be a power of two.)  This method tends to waste a few bytes of memory now and then, but it turns out that it is very fast.  It has some other technical advantages, too, that we won't go into here.\par When you call free at the end of the program, the small block of memory is deallocated.  Since it was the only piece of memory being used in the 4K block, the 4K block is also returned to the memory manager, where it can be reused by other programs.\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx4752\dpy226\dpxsize4608\dpysize9648\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{\{\par int i, j, *ip;\par \par ip = (int *) malloc (sizeof(int));\par j = 4;\par *ip = j;\par i = *ip;\par printf("%d\\n", i);\par free(ip);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par When this program runs, it starts by making a call to malloc.  This simple call shows a lot of new concepts, so we need to stop and spend some time looking at it closely.  The malloc function needs to know how much memory you want, in bytes.  Since you are allocating a pointer to an integer, you need to allocate two bytes, but the size of an integer can vary from one C compiler to another.  Worse yet, later you will be allocating memory for structures, and it can be pretty easy to make a mistake on the size of a structure, even if you know your compiler well.  C solves this problem with a special operator called sizeof.  The sizeof operator returns the size of any type in the same units malloc uses (bytes, in our case).  If you move this program to another compiler that uses a different size of integer, it will still work, because the new compiler's sizeof function will know how big integers are in that implementation.\par The sizeof operator is something that has changed a bit over the years, so it is also something you should be careful of if you are moving your programs between computers or typing in C programs from another book.  In older implementations of C, the value returned by sizeof was generally an int or unsigned value.  The problem with this is that you could never use sizeof on a really big structure or array, since this effectively limits the value returned by sizeof to 64K-1 on most computers, and as you know, you have a lot more memory at your disposal on the Apple IIGS.  In ANSI C implementations, the value returned is of type size_t, which is an unsigned integer big enough to hold a pointer value.  In ORCA/C, this means the integer is an unsigned long, not an unsigned int.  The main place this comes up is when you want to print the result of the sizeof function: many people try to use the %d conversion specifier to do this, and that is simply not correct, since the %d conversion specifier is only valid with two-byte values in ORCA/C.  Instead, you need to use the %ld conversion specifier.  On other compilers, though, this could be different.\par The malloc function performs some advanced magic and, after the call, two bytes of memory have been obtained.  The exact process involved in getting this memory is a bit involved, and not particularly important to you, the C programmer.  If you are curious, the sidebar gives an overview of the process.  In any case, this memory is safe.  It belongs to your program, and no other correctly written program will disturb it.  The type of the pointer that is returned is then cast to the type of the pointer we want, just to keep things neat.  This isn't actually required in ORCA/C, but neatness never hurts, and this type cast may be necessary in other implementations of C.  To cast one pointer to another type, you just put the type in parenthesis in front of the pointer value.\par Just before the program ends, you see a call to free.  This function goes through a complicated mechanism that gets rid of the two bytes of memory.  After calling free, the memory does not belong to your program anymore.  It could be reused within 1/60th of a second by an interrupt routine, such as the software that controls the mouse and keyboard in PRIZM.  Even if it isn't reused, because of the process used to allocate and deallocate memory, the location ip points to doesn't contain 4, anymore.  In short, once you call free, the memory isn't yours anymore, and you should not access or change the value pointed at by ip.\par This is a very short program, but it is worth typing it in and running it through the debugger.  Start the program in step mode and bring up the variables window.  Go ahead and enter i and j if you like, but be sure and enter ip.  This will show you the value of the pointer itself.  Like all variables declared at the program level in ORCA/C, it starts with a value of zero.  The value is displayed in hexadecimal notation, but it is still zero.  Now add ip^ to the variables window.  (In the variables window, you look at the value of a pointer by placing a ^ after the name, instead of a * before the name.  The effect is the same.)  The debugger will display the value being pointed to by ip.  Again, the important point is that ip is a variable, but the value you really want to see and make use of is what it points to.  That, as you know, is *ip, or, to the debugger, ip^.  Stepping through the program, you can see malloc allocate new memory, and you can see the assignment setting the value being pointed to.  Free doesn't change the value of ip, but you will see the value of ip^ change.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 8.1.}{  A pointer can point to any variable type.  Use that fact to change the program shown in this section to allocate a pointer to a floating-point number.  Assign the value 1.2 to the location pointed to by the pointer, and print the result.  Do all of this without an intermediate floating-point variable; in other words, assign the value directly to the value pointed at by the pointer, and use the pointer with the * operator in the printf call.\par \par }{\b Problem 8.2.}{  You can, of course, use *ip anywhere that you could use an integer variable.  Making use of that fact, write a program to add two numbers and print the result.  The only variables you should define are three pointers, ip, jp, and kp.  Be sure and allocate memory for all of them using malloc, then assign 4 to the first, and 6 to the second.  Add the two values together and save them at *kp, then print the result.  Be sure and follow your mother's advice, and clean up after yourself by calling free to deallocate the memory areas reserved by the calls to malloc.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344506}Linked Lists{\*\bkmkend _Toc496344506}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {So far, all of our programs have used a pointer to a single variable.  That's about as useful as your mother on a hot date.  A simple variable is easier to use, takes less space, produces a smaller program, the resulting program runs faster, and there is no chance of stepping on someone else's memory because you forgot to use malloc to allocate the memory.  We used arrays to organize a fixed number of values into a data structure that was easier to use.  The equivalent for a pointer is one of the many forms of a linked list.\par Basically, a linked list is a series of connected structures.  Each of the structures in the linked list contains, among other things, a pointer.  The pointer points to another structure in the list.  A single pointer variable in the program points to the first structure in the linked list.\par For our first look at a linked list, we will create a list of integers.  The structure, then, must have a pointer to the next record, and an integer.  It looks like this:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {typedef struct listElement \{\par    struct listElement *next;\par    int i;\par    \} listElement;\par \par }\pard \s23\qj\fi360\widctlpar\adjustright {listElement *list, *temp;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par With these definitions, we can start to create a linked list.  For each element in the list, we will need to call malloc to get space for a new record, and then place a value into the integer, like this:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {temp = (listElement *) \par    malloc(sizeof listElement);\par }\pard \s23\qj\fi360\widctlpar\adjustright {(*temp).i = 4;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The assignment that places a 4 in the integer variable looks a bit odd.  You might not think about putting parenthesis in a C expression to tell the compiler in what order to apply the * and . operators, but it actually does work.  As with the other examples of * and . that you have seen, the * operator applied to temp tells the compiler to look at the thing temp points to, not the pointer temp.  Applying the . operator and the variable name i, you are telling the compiler to look at a variable i, contained within a struct pointed at by the pointer temp.  That's a mouthful, but if you look at it closely and apply the old principals you already know one after the other, it makes some sense.\par The assignment is, however, a bit confusing, not to mention hard to type, and it turns out that you need to do this sort of thing a lot in real programs.  C has another operator, ->, which does the job of the * and . operators put together, and makes the line a little easier to read at the same time:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {temp->i = 4;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {The -> operator, used instead of the . operator, tells the compiler that the variable temp is a pointer to a structure, rather than a structure, and to do the right things on its own.\par }\pard \s21\qj\fi360\widctlpar\adjustright {At this point, we have a dynamically allocated record with an integer value in it.  The pointer in the record still does not point to anything.  The next step is to add this record to the list of records that the variable list points to.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {temp->next = list;\par }\pard \s23\qj\fi360\widctlpar\adjustright {list = temp;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par On the first line, we are assigning a value to the pointer in our new record.  The value we are assigning is list; list points to the first element currently in the list.  We really don't know how many things are in the list at this point.  There may not be any, or there may be several thousand.  The beauty of the linked list, though, is that we don't have to know!  It doesn't matter at all how many things are already in the linked list.\par The second line assigns temp to list.  The first thing in the list, at this point, is our new record.  Our record contains an integer variable with a value of 4, and a pointer to the rest of the list.\par The next thing we need to learn is how to take something out of the list.  Let's say that we want to remove the first item.  Basically, then, we reverse the process of putting a record into the list, like this:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {temp = list;\par }\pard \s23\qj\fi360\widctlpar\adjustright {list = temp->next;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par There is one more detail that we need to deal with before we can use these ideas to write a program.  So far, we have ignored the issue of the end of the list.  How do we know when we get to the end of the list?  We could keep a counter, but actually, there is a better way.  It involves the use of a predefined pointer constant called NULL, defined in stddef.h.  NULL has a type of void *, which means a pointer to some unspecified object, and so is type compatible with any pointer.    You can set a pointer to NULL or compare a pointer to NULL.  By convention, NULL is used to mean that the pointer doesn't point to anything, and that is how we mark the end of our list.  By initializing list to NULL at the start of the program, and checking to see if list is NULL before removing an item from the list, we can tell when there is nothing in the list.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344507}Stacks{\*\bkmkend _Toc496344507}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Using what we now know about linked lists, we can create our first program, shown in listing 8.1.\par \par }{\b \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b \par }\pard \s21\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {\b Listing 8.1\par \par }\pard\plain \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright \f6\fs20\cgrid {/* This program reads in a list of integers, and then prints    */\par /* them in reverse order.  The program stops when a zero value  */\par /* is read.                                                     */\par \par #include <stdio.h>\par #include <stdlib.h>\par #include <stddef.h>\par \par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {typedef struct listElement \{\par    struct listElement *next;\par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {   int i;\par    \} listElement;\par \par listElement *list;\par \par \par void GetList (void)\par \par /* Read a list from the keyboard.                            */\par /*                                                           */\par /* Variables:                                                */\par /*    list - pointer to the head of the list                 */\par \par \{\par int i;                               /* variable read from the keyboard */\par listElement *temp;                      /* work pointer */\par \par list = NULL;                            /* initialize the list pointer */\par \par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {do \{\par    scanf(" %d", &i);                    /* read a value */\par    if (i != 0) \{                    /* if not at the end of the list... */\par                                         /* allocate a structure */\par       temp = (listElement *) malloc (sizeof(listElement));\par       temp->i = i;                      /* place i in the structure */\par       temp->next = list;               /* put the structure in the list */\par       list = temp;\par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {      \}\par    \}\par while (i != 0);\par \}\par \par \par void PrintList (void)\par \par /* Print a list.                                             */\par /*                                                           */\par /* Parameters:                                               */\par /*    list - pointer to the head of the list                 */\par \par \{\par listElement *temp;                      /* work pointer */\par \par while (list != NULL) \{\par    temp = list;                         /* remove an item from the list */\par    list = temp->next;\par    printf("%d\\n", temp->i);             /* write the value */\par    free(temp);                          /* free the memory */\par    \}\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {void main (void)\par \par \{\par GetList();                              /* read a list */\par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {PrintList();                            /* print a list */\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard\plain \s33\qj\fi360\widctlpar\adjustright \f4\cgrid {\sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {We have already talked about all of the ideas in this program, this is just the first time you have seen them all in one place.  Looking through the program, the first step is to get a list of numbers.  GetList does this, reading numbers using familiar methods until you enter 0.  For each number, GetList allocates a new structure, saves the number in the structure, and puts the structure in the list.\par PrintList loops for as long as there are entries left in the list.  Each time through the loop, the top structure in the list is removed from the list, the value is printed, and the memory used by the structure is dumped.  Notice how the PrintList procedure cleans up after itself.  The memory used by every record is carefully disposed of after we are finished with the record.  This is an important step in a program that uses dynamic memory.  If you forget to dispose of some of the memory in a few places, the memory areas will eventually fill up, and there won't be any unused memory for the malloc calls.\par It is very important to understand exactly how this program works, since the ideas used in this program form the basis for many of the fundamental techniques in modern programming practice.  Stop now, and type in the program.  Run the program with the following input:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {1 2 3 4 0\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {The program responds with this:\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {       4\par        3\par        2\par }\pard \s23\qj\fi360\widctlpar\adjustright {       1\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par This may not have been exactly what you expected.  What happened is this:  when the program creates the list, each new element is added on top of the old list.  As the program retrieves records from the list, the last one added is removed first.  This mechanism is called a stack.  The common analogy is to think of it like a stack of plates.  You pile the list elements up on top of one another.  To get one back, you pull the top record off of the stack.\par Just as a footnote, I should warn you about terminology buffs.  Many high school teachers, a few college professors, and even an occasional book author figure that the way to become a good programmer is to learn a bunch of arcane words.  It is true that you need some new words, like dynamically allocated memory, to describe new concepts, but these terminology buffs want you to know that a stack is called a LIFO data structure, for Last In, First Out.  Let's face it, they write the tests, so you better know the term if you want to get a good grade in a class.  Be warned, though:  if you walk up to a group of programmers at a conference and start babbling about LIFO data structures, you will find a wide gap forming around you.  A few people will glance at your shirt pocket, looking for the pencil holder, or examine the thickness of your glasses.  In real life, these things are called stacks.\par Stacks are a very flexible data structure, used in a wide variety of applications.  A stack is appropriate any time you need to collect a large amount of information, especially if you don't particularly care in what order you use the information, or for the occasional case when you want to handle the most recent piece of information first.  Stacks are used in such diverse applications as burglar alarms, data bases, mailing lists, operating systems, and arcade games.\par There are many variations on the basic ideas covered in this section.  Some of these are explored in the problems.  I highly recommend that you work both of these problems.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 8.3.}{  Many applications require you to process the information in a list from back to front.  In some cases, you know this in advance, and a slightly different form of a list is used, called a queue.  That situation is covered in the next section.  In other cases, though, you may not know that the list needs to be reversed in advance, or you may need to process the list in both orders in different parts of the program.  In a case like that, you need to be able to reverse the list.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Reversing a list is really quite easy.  To do it, you use two lists.  The new list starts out empty.  You then loop through the old list, just like we do in the PrintList procedure, but instead of printing the value and disposing of the record, you add the record to the new list.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Change the sample program from this section by adding a new function called ReverseList that reverses the list.  Use this function to reverse the list before it is printed.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }{\b Problem 8.4.}{  In some applications, we read in a list, then scan the list repeatedly, looking for structures with certain characteristics.  For example, in a burglar alarm, we might use one function to add new alarms to a list.  Another might repeatedly scan the list, looking for fires.  If no fires were found, the list could be rechecked for broken windows, and so on.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Implement this idea in our sample program by counting the number of times a particular number appears in the list.  Scan the list, incrementing a counter in an array when you find a value in the range 1 to 5, and ignoring all other entries.  Print a table of the results.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Try this program at least two times.  The first time, enter zero immediately.  The second time, use this data:\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {1 2 3 4 5 2 3 4 5 3 4 5 4 5 5 0\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {The results should be one one, two twos, and so forth.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Hint:  To scan a list, set a pointer to the head of the list.  Use a while loop to loop until this pointer is NULL.  At the end of the while loop, set the pointer to the next record, like this:\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {temp = temp->next;\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344508}Queues{\*\bkmkend _Toc496344508}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Another commonly used form of a list is the queue.  A queue looks just like a stack, but it is formed differently.  A queue is used when you want to process information in the same order it is read, so instead of adding new records to the beginning of the list, you want to add them to the end of the list.  In a sense, the structures are lined up, and processed on a first-come, first served basis.  The terminology freaks call a queue a FIFO list, for First In, First Out, but again, don't embarrass yourself in a crowd by talking about stuff like that.\par There are three basic ways to form a queue.  If all of the information is read in first, then processed, you could just use the simple stack to read the data, then reverse the order of the list, like we did in problem 8.3.  In many programming situations, though, you read some data, process a little bit, read some more, and so forth.  In those cases, you need to build the list in the proper order.\par One way to build a queue is to keep a second pointer, which we will call last.  This pointer starts at NULL, like the pointer that points to the first member of the list.  When we add the first element to the list, the pointer last is set to the value of the new pointer.  The next pointer in the new structure is always set to NULL.  From then on, we add a new structure by setting the next pointer in the structure pointed to by last to point to the new structure, and then set last to point to the new structure.  In C code, then, we set the list up like this:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {list = NULL;\par }\pard \s23\qj\fi360\widctlpar\adjustright {last = NULL;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par To add a record to the end of the list, we check to see if the structure is the first one in the list.  If so, we set both last and list to point to the new record.  If not, we chain the record to the end of the list.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {if (list == NULL) \{\par    list = temp;\par    last = temp;\par    \}\par else \{\par    last->next = temp;\par    last = temp;\par }\pard \s23\qj\fi360\widctlpar\adjustright {   \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Of course, since both branches of the if statement assign temp to last, we can make the program shorter, and still do the same thing, by pulling the assignment outside of the if statement, like this:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {if (list == NULL)\par    list = temp;\par else\par    last->next = temp;\par }\pard \s23\qj\fi360\widctlpar\adjustright {last = temp;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par We also don't actually make use of last before it is assigned a value for the first time, so setting it to NULL when we initialize the list is also unnecessary.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 8.5.}{  Change the GetList procedure from the sample in the last section so it forms a queue instead of a stack.  Use the mechanism described in this section to do it.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344509}Running Out Of Memory{\*\bkmkend _Toc496344509}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {What happens if you ask for more memory, but none is available?  If this happens, malloc returns NULL instead of a pointer to the new memory.  You can \endash  and should \endash  check for this possibility in your program, and handle the situation if it arises.  Here's a sample program that allocates chunks of 10,000 bytes of memory at a time.  It will give you some idea about how much memory you actually have available when your program runs, and give you a good example of handling an out of memory situation, too.  Of course, the amount of memory you have available can change due to a number of factors.  The memory you can allocate will go up if you add more memory, make any RAM disk smaller, or run the program from the Finder or text shell instead of from the desktop development environment.  The amount of memory you can allocate can go up or down as the version of the operating system or compiler change, and even as you add, delete, or change the desk accessories you use.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par #include <stdlib.h>\par #include <stddef.h>\par \par void main (void)\par \par \{\par unsigned count;\par int *p;\par \par count = 0;\par \par do \{\par    p = (int *) malloc (10000);\par    ++count;\par    \}\par while (p != NULL);\par printf("%d 10000 byte areas"\par    " allocated.\\n", count-1);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par One interesting point about this program is that we aren't using free to dispose of the memory we allocate.  In this rare case, that does no harm, since the operating system will free the memory once the program stops running.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344510}The & Operator Returns an Address{\*\bkmkend _Toc496344510}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {It may have struck you as a little odd that we went through all of those contortions with malloc to allocate space for an integer value when you already know how to create an integer by simply declaring it.  Well, the biggest reason was to prepare you for using malloc to create lists, but as it turns out, you can actually get the address of a normal variable, and use that address to set the pointer.  The method used is exactly the same as when you pass the address of a variable as a parameter to functions like scanf.  &i, for example, is the address of i, and you can use this to set a pointer.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 8.6.}{  The very first sample program in this section was:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par int i, j, *ip;\par \par j = 4;\par *ip = j;\par i = *ip;\par printf("%d\\n", i);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {Change this program by setting ip to point to j, rather than setting the value ip points to to the value of j, then run the program.  Be sure to use the debugger to see what is happening. \par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344511}The Special Relationship Between Pointers and Arrays{\*\bkmkend _Toc496344511}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {In C, there is a very close relationship between arrays and pointers.  In fact, if a is an array of integers, the type of a in an expression isn't really array at all \endash  it is a pointer!  Let's use a simple program to get a first look at how this works.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main (void)\par \par \{\par int a[2], *ip;\par \par a[0] = 4;\par ip = a;\par printf("%d\\n", *ip);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The first line is simple enough \endash  it assigns 4 to the first element of the array.  The next line is where the neat stuff happens.  Here, we assign a to ip.  What does this mean?  Well, since a is an array of integers, C treats it as a pointer to an integer in this case, and ip ends up pointing to the first element of the array a.  When you print *ip, the value printed is 4 \endash  the same value you placed at the start of the array.\par It is this special relationship that we put to use a few lessons back to pass an array as a parameter to a function.  C didn't really pass the array at all \endash  instead, C passed a pointer to the first element in the array.\par The relationship works the other way around, too.  You can actually use an array subscript after a pointer to access the value the pointer points to.  For example, you can look at the value ip points to using *ip, as you normally would, or by using ip[0], which means exactly the same thing in C.  That's why you were able to use array subscripts inside of the subroutine to access values in the array that C passed as a pointer.  You can even index past the value ip currently points to; ip[1] is the integer after the one *ip points to, for example.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 8.7.}{  Use the idea that array indexes can be used with a pointer to modify the sample program from this section.  Start by declaring an array with three values, and set these values to 1, 2 and 3.  Next, set a pointer to the first element of the array.  Finally, print the values in the array by indexing 0, 1 and 2 past the pointer.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344512}Pointer Math{\*\bkmkend _Toc496344512}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The fact that arrays and pointers enjoy such a close relationship in C becomes a powerful new programming technique when combined with another factor.  You can actually do some math with pointers in C, too.  The math is limited to the things that make sense with a pointer, which basically means that you can add or subtract an integer value, or increment or decrement a pointer.  C handles all of this very gracefully, too.  When you add one to a pointer, the result is a pointer to the next item of the same type after the original pointer!\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main (void)\par \par \{\par int a[5], *ip, i;\par \par for (i = 0; i < 5; ++i)\par    a[i] = i+1;\par \par ip = a;\par i = 0;\par for (i = 0; i < 5; ++i) \{\par    printf("%d\\n", *ip);\par    ++ip;\par    \}\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par This program shows how this ability is used most often in C.  You see, it takes a fair amount of time to calculate the location of a value in an array, like a[4].  It takes even longer if the array is subscripted multiple times, like a[i][j][k].  This sort of multiple indexing may seem a bit strange, but it comes up a lot in some kinds of engineering programs.  While it takes a long time to compute array indices, though, incrementing the value of a pointer is a very fast operation by comparison, and accessing the value a pointer points to is also a very fast operation.  In short, you can use this idea of pointer math to create some very short, fast programs in C \endash  programs whose speed is much greater than a similar program in other high-level languages.\par Let's explore this concept further by writing a function that will work like strcmp, but will do a case insensitive compare \endash  i.e., one where the characters 'A' and 'a' are treated as being equal.  Using arrays, our function looks like this:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {int strcmp2 (char str1[1],\par              char str2[1])\par \par \{\par unsigned i;\par \par i = 0;\par while ((str1[i] != 0)\par        && (str2[i] != 0)) \{\par    if (toupper(str1[i]) !=\par        toupper(str2[i])) \{\par       if (toupper(str1[i]) <\par           toupper(str2[i]))\par          return -1;\par       return 1;\par       \}\par    ++i;\par    \}\par if (str1[i] != 0)\par    return 1;\par if (str2[i] != 0)\par    return -1;\par return 0;\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par This subroutine has one distinct advantage: you can see the rules that strcmp uses to compare strings layed out very clearly.  The subroutine scans the strings, checking to see if it has reached the null character in either string, and stopping if it has.  Assuming both strings still have characters, the subroutine enters the while loop, and checks to see if the uppercase equivalent of these character is the same; if not, it checks to see which is smaller, and returns -1 or 1, as appropriate.  If the characters match, the subroutine increments i and continues on to the next position in the strings.\par Assuming the end of one or the other string is reached without finding a mismatch, the subroutine drops out of the do loop, and checks to see if one string is shorter than the other.  If so, an appropriate value is returned.  If not, the strings are the same, and a 0 is returned.\par C doesn't care if you declare the parameters to this function as arrays, as we have done, or pointers: the compiler will let you call the function with the same sort of arguments either way.  Using this fact, we can convert this subroutine to use pointers instead of arrays.  The first effect is that we no longer need the variable i.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {int strcmp2 (char *p1, char *p2)\par \par \{\par while ((*p1 != 0) && (*p2 != 0))\par    \{\par    if (toupper(*p1) !=\par        toupper(*p2)) \{\par       if (toupper(*p1) <\par           toupper(*p2))\par          return -1;\par       return 1;\par       \}\par    ++p1;\par    ++p2;\par    \}\par if (*p1 != 0)\par    return 1;\par if (*p2 != 0)\par    return -1;\par return 0;\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par This seems a little shorter, and in fact, it is faster, too.  We'll continue to refine this program, using our knowledge of C to continue improving on the size and, as it turns out, the speed of this subroutine.  This process of iterative refinement of a subroutine is a very common one.  The next step is to recognize that, in C, 0 is false and anything else is true, so all of those comparisons to 0 are really unnecessary.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {int strcmp2 (char *p1, char *p2)\par \par \{\par while (*p1 && *p2)\par    \{\par    if (toupper(*p1) !=\par        toupper(*p2)) \{\par       if (toupper(*p1) <\par           toupper(*p2))\par          return -1;\par       return 1;\par       \}\par    ++p1;\par    ++p2;\par    \}\par if (*p1)\par    return 1;\par if (*p2)\par    return -1;\par return 0;\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par We could carry this process even further, but it would take some ideas about the C language that you haven't seen yet.  In any case, the process can be taken to the point where the subroutine is very efficient, but also very hard to follow.  (Maybe you think this is already true!)  This brings up an interesting philosophical point.  In many cases, like the sample programs in this course, it is very important that programs be easy to follow and understand.  This helps a lot when you are debugging a program, too.  In other situations, you need to milk as much speed as possible from your computer, and that sometimes means going over code again and again to make it smaller and more efficient.  The result may be very difficult for anyone, even yourself, to decipher later.  Some people will get stuck in one more or the other.  A teacher, for example, might get stuck in the "write it clearly" mode, while a professional programmer writing tight animation code in C might get caught up in obscure techniques to cut a few percent from the execution time, producing unreadable code.  I hope you can be flexible enough to see that both views are correct, and both have a place.  My advice is to start by writing clear, easy to understand subroutines.  If the program is too slow, go back and change individual subroutines that are taking up too much time to get more efficiency.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 8.8.}{  Write a short program to test the last version of strcmp2.  Write your program so that it passes each of the following at least one time:\par \par }\pard \s24\qj\fi-360\li720\widctlpar\adjustright {a.\tab A string constant.\par b.\tab A character array.\par c.\tab A pointer to a character.  (The pointer can be initialized to point to the character array.)\par \par }\pard\plain \widctlpar\adjustright \f4\cgrid {\b\fs36 \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \qc\widctlpar\adjustright \f4\cgrid {\b\fs36 Lesson Eight\par Solutions to Problems\par }\pard \qj\widctlpar\adjustright {\b\fs28 \par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344513}Solution to problem 8.1.{\*\bkmkend _Toc496344513}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par #include <stdlib.h>\par \par void main (void)\par \par \{\par float *fp;\par \par fp = (float *) malloc (sizeof(float));\par *fp = 1.2;\par printf("%f\\n", *fp);\par free(fp);\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344514}Solution to problem 8.2.{\*\bkmkend _Toc496344514}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par #include <stdlib.h>\par \par void main (void)\par \par \{\par int *ip, *jp, *kp;\par \par ip = (int *) malloc (sizeof(int));\par jp = (int *) malloc (sizeof(int));\par kp = (int *) malloc (sizeof(int));\par \par *ip = 4;\par *jp = 6;\par *kp = *ip + *jp;\par \par printf("%d\\n", *kp);\par \par free(ip);\par free(jp);\par free(kp);\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344515}Solution to problem 8.3.{\*\bkmkend _Toc496344515}\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* This program reads in a list of integers, and then prints    */\par /* them.  The program stops when a zero value is read.          */\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par #include <stdio.h>\par #include <stdlib.h>\par #include <stddef.h>\par \par typedef struct listElement \{\par    struct listElement *next;\par    int i;\par    \} listElement;\par \par listElement *list;\par \par \par void GetList (void)\par \par /* Read a list from the keyboard.                            */\par /*                                                           */\par /* Variables:                                                */\par /*    list - pointer to the head of the list                 */\par \par \{\par int i;                               /* variable read from the keyboard */\par listElement *temp;                      /* work pointer */\par \par list = NULL;                            /* initialize the list pointer */\par \par do \{\par    scanf(" %d", &i);                    /* read a value */\par    if (i != 0) \{                    /* if not at the end of the list... */\par                                         /* allocate a structure */\par       temp = (listElement *) malloc (sizeof(listElement));\par       temp->i = i;                      /* place i in the structure */\par       temp->next = list;                /* put the record in the list */\par       list = temp;\par       \}\par    \}\par while (i != 0);\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void ReverseList (void)\par \par /* Reverse a list                                            */\par /*                                                           */\par /* Parameters:                                               */\par /*    list - pointer to the head of the list                 */\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par \{\par listElement *temp;                      /* work pointer */\par listElement *nlist;                     /* new list pointer */\par \par nlist = NULL;                           /* start out with an empty list */\par \par while (list != NULL) \{\par    temp = list;                         /* remove an item from the list */\par    list = temp->next;\par    temp->next = nlist;                  /* add it to the new list */\par    nlist = temp;\par    \}\par list = nlist;                           /* switch to the new list */\par \}\par \par \par void PrintList (void)\par \par /* Print a list.                                             */\par /*                                                           */\par /* Parameters:                                               */\par /*    list - pointer to the head of the list                 */\par \par \{\par listElement *temp;                      /* work pointer */\par \par while (list != NULL) \{\par    temp = list;                         /* remove an item from the list */\par    list = temp->next;\par    printf("%d\\n", temp->i);             /* write the value */\par    free(temp);                          /* free the memory */\par    \}\par \}\par \par \par void main (void)\par \par \{\par GetList();                              /* read a list */\par ReverseList();                          /* reverse the list */\par PrintList();                            /* print a list */\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344516}Solution to problem 8.4.{\*\bkmkend _Toc496344516}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* This program reads in a list of integers, then scans the     */\par /* list, printing the number of times each of the integers 1 to */\par /* 5 appear in the list.                                        */\par \par #include <stdio.h>\par #include <stdlib.h>\par #include <stddef.h>\par \par typedef struct listElement \{\par    struct listElement *next;\par    int i;\par    \} listElement;\par \par listElement *list;\par \par \par void GetList (void)\par \par /* Read a list from the keyboard.                            */\par /*                                                           */\par /* Variables:                                                */\par /*    list - pointer to the head of the list                 */\par \par \{\par int i;                               /* variable read from the keyboard */\par listElement *temp;                      /* work pointer */\par \par list = NULL;                            /* initialize the list pointer */\par \par do \{\par    scanf(" %d", &i);                    /* read a value */\par    if (i != 0) \{                    /* if not at the end of the list... */\par                                         /* allocate a structure */\par       temp = (listElement *) malloc (sizeof(listElement));\par       temp->i = i;                      /* place i in the structure */\par       temp->next = list;                /* put the record in the list */\par       list = temp;\par       \}\par    \}\par while (i != 0);\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void CountList (void)\par \par /* Count the elements in the list                            */\par /*                                                           */\par /* Variables:                                                */\par }\pard \s23\qj\fi360\widctlpar\adjustright {/*    list - pointer to the head of the list                 */\par \par \{\par listElement *temp;                      /* work pointer */\par unsigned counts[5];                     /* array of frequency counts */\par unsigned i;                             /* loop counter */\par \par for (i = 0; i < 5; ++i)                 /* initialize the array */\par    counts[i] = 0;\par temp = list;                            /* do the count */\par while (temp != NULL) \{\par    if ((temp->i >= 1) && (temp->i <= 5))\par       ++counts[temp->i - 1];\par    temp = temp->next;\par    \}\par for (i = 0; i < 5; ++i)                 /* print the results */\par    printf("%8d%8d\\n", i+1, counts[i]);\par \}\par \par \par void main (void)\par \par \{\par GetList();                              /* read a list */\par CountList();                            /* count the items in the list */\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344517}Solution to problem 8.5.{\*\bkmkend _Toc496344517}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* This program reads in a list of integers, placing them in a  */\par /* queue, then prints the numbers in the resulting linked list. */\par \par #include <stdio.h>\par #include <stdlib.h>\par #include <stddef.h>\par \par typedef struct listElement \{\par    struct listElement *next;\par    int i;\par    \} listElement;\par \par listElement *list;\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void GetList (void)\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par /* Read a list from the keyboard.                            */\par /*                                                           */\par /* Variables:                                                */\par /*    list - pointer to the head of the list                 */\par \par \{\par int i;                               /* variable read from the keyboard */\par listElement *temp;                      /* work pointer */\par listElement *last;                      /* ptr to the end of the list */\par \par list = NULL;                            /* initialize the list pointer */\par last = NULL;                            /* no end item, yet */\par \par do \{\par    scanf(" %d", &i);                    /* read a value */\par    if (i != 0) \{                    /* if not at the end of the list... */\par                                         /* allocate a structure */\par       temp = (listElement *) malloc (sizeof(listElement));\par       temp->i = i;                      /* record the value */\par       temp->next = NULL;                /* nothing comes after it */\par       if (list == NULL)                 /* add the struct to the list */\par          list = temp;\par       else\par          last->next = temp;\par       last = temp;                      /* record the new end of list */\par       \}\par    \}\par while (i != 0);\par \}\par \par \par void PrintList (void)\par \par /* Print a list.                                             */\par /*                                                           */\par /* Parameters:                                               */\par /*    list - pointer to the head of the list                 */\par \par \{\par listElement *temp;                      /* work pointer */\par \par while (list != NULL) \{\par    temp = list;                         /* remove an item from the list */\par    list = temp->next;\par    printf("%d\\n", temp->i);             /* write the value */\par    free(temp);                          /* free the memory */\par    \}\par \}\par \par \par void main (void)\par \par \{\par GetList();                              /* read a list */\par PrintList();                            /* print a list */\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344518}Solution to problem 8.6.{\*\bkmkend _Toc496344518}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main (void)\par \par \{\par int i, j, *ip;\par \par j = 4;\par ip = &j;\par i = *ip;\par printf("%d\\n", i);\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344519}Solution to problem 8.7.{\*\bkmkend _Toc496344519}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main (void)\par \par \{\par int a[3], *ip;\par \par a[0] = 1;\par a[1] = 2;\par a[2] = 3;\par ip = a;\par printf("%d\\n%d\\n%d\\n", ip[0], ip[1], ip[2]);\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344520}Solution to problem 8.8.{\*\bkmkend _Toc496344520}\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* Test strcmp2 */\par \par #include <ctype.h>\par #include <stdio.h>\par #include <string.h>\par \par int strcmp2 (char *p1, char *p2)\par \par }\pard \s23\qj\fi360\widctlpar\adjustright {\{\par while (*p1 && *p2)\par    \{\par    if (toupper(*p1) !=\par        toupper(*p2)) \{\par       if (toupper(*p1) <\par           toupper(*p2))\par          return -1;\par       return 1;\par       \}\par    ++p1;\par    ++p2;\par    \}\par if (*p1)\par    return 1;\par if (*p2)\par    return -1;\par return 0;\par \}\par \par \par void main (void)\par \par \{\par char string1[20], *cp;\par \par strcpy(string1, "HO");\par cp = string1;\par \par printf("%d %d\\n",  1, strcmp2("ho", "HI"));\par printf("%d %d\\n", -1, strcmp2("hi", string1));\par printf("%d %d\\n",  0, strcmp2("ho", cp));\par printf("%d %d\\n",  1, strcmp2("hoh", "HO"));\par printf("%d %d\\n", -1, strcmp2("ho", "HOH"));\par \}\par }\pard\plain \widctlpar\adjustright \f4\cgrid {\par \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s1\qc\nowidctlpar\outlinelevel0\adjustright \b\f4\fs36\cgrid {{\*\bkmkstart _Toc496344521}Lesson Nine{\*\bkmkend _Toc496344521}\par {\*\bkmkstart _Toc496344522}Files{\*\bkmkend _Toc496344522}\par }\pard\plain \qj\widctlpar\adjustright \f4\cgrid {\b\fs28 \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344523}The Nature of Files in C{\*\bkmkend _Toc496344523}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {A lot of fun and useful programs never save a file to disk or read from a disk file.  Arcade games, some adventure games, many scientific and engineering calculations, and all of the programs you have written so far in this course all read data from the keyboard, or do calculations based on internal values.  On the other hand, the vast majority of programs do read and write disk files.  Spread sheets, word processors, data base programs, many games, ORCA/C itself \endash  all of these programs read and write files.  This lesson introduces files as used in the C language.\par C has an enormous variety of different ways to deal with disk files, all of which are accessed through functions defined in the stdio.h header file you already use for reading the keyboard and writing information to the shell window.  The functions you will learn are actually designed to work with a wide variety of output devices.  For example, the fprintf function works almost exactly like the printf function you are used to, but it writes to a file.  With the proper device drivers installed in the operating system, the fprintf function could also be used to write to modems, printers, the shell window, or even tape drives.  There is also an fscanf function that can be used to read from files.  In other words, one of the methods for accessing files is going to look very similar to the way you access the keyboard and shell window.  In fact, C can even treat the keyboard and shell window as a file.\par Some of the functions in stdio.h will seem a little dated on the Apple IIGS.  The rewind function is a good example: it was included in the library from the early days of C programming, when the most common form of mass storage was the tape drive, not the floppy disk.  With all of these functions lying around, stdio.h is a very large (and very capable) library.  We won't even try to cover all of these features of stdio.h; instead, we will concentrate on a few of the basic functions that are useful for general purpose file input and output.  As you read this lesson, though, I would recommend that you keep the ORCA/C reference manual handy, and refer to it often to learn about functions that we are not covering, and to read about the many features that we won't cover in some of the functions we do use.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344524}What is a File?{\*\bkmkend _Toc496344524}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The way we normally think of files, a file is basically a collection of information stored somewhere.  For floppy disks and hard disks, which is what we will deal with in this lesson, that definition fits very well.  As I mentioned a moment ago, though, the file access functions in C use a looser definition of the term.  With this looser definition, a file becomes a place that you can send information to, or a place that you can get information from.  You can't always read what you write, nor can you always back up and read something a second time.  In fact, some files can be read, but not written to, and other can be written to, but not read.  Two good examples of this are stdin and stdout, two files that you have been using all along without realizing it.  The file stdin is the standard input device \endash  in our case, the keyboard.  You can read the keyboard, but you can't back up and reread a line if you missed something.  Of course, you can't write to the keyboard; that just doesn't make any sense.  stdout is the standard output device.  If you are using the PRIZM desktop development environment, the standard output device is the shell window; from the text development environment, the standard output device is the text screen.  Once again, it is easy to see why you can write to the stdout file, but you can't read from it.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344525}The Four Basic Operations{\*\bkmkend _Toc496344525}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {As you deal with files, there are basically four operations that you will learn.  There are a lot of different functions defined in stdio.h, but most of them do one of these four basic operations.  Before you can read from a file or write to a file, you must open it.  Opening a file, then, is the first of the four basic operations.  Opening a file is a lot like opening a file folder in a file cabinet: it tells C to find the file, creating a new one in some circumstances, and to get the file ready for reading, writing, or both.  Once you open a file, you will either read from it or write to it; these are the second and third of the basic operations.  Finally, when you are finished with a file, you need to close it.  This cleans up, taking care of any operating system dependent tasks needed to get the file ready for the next program that will open the file.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344526}File Variables{\*\bkmkend _Toc496344526}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The four basic operations are scattered across a number of different function calls.  In our first few examples, we will use fopen to open a file, fprintf and fscanf to write to and read from a file, and fclose to close the file when we are finished with it.  C can, of course, deal with more than one open file at a time, so we need a way to tell all of these functions exactly what file we want the function to work on.  This is done with a file variable, defined like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {FILE *f;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The type FILE is defined in stdio.h; file variables are always a pointer to this type.  There is nothing special about the variable name.  You pick it just like you would for any other variable.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344527}Writing to a File{\*\bkmkend _Toc496344527}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {In theory, files can be of any length.  Basically, that means that there is no fixed limit to the number of things you can put in a file.  Of course, there's no free lunch.  The information you stuff into a file has to be saved somewhere.  In the case of the Apple IIGS, it is saved on one of the devices GS/OS handles.  This is usually a floppy disk or hard disk, but it can also be a network, a printer, a tape drive, or anything else that GS/OS recognizes.\par To write a value to a file, you need to open the file for output.  This is done with the fopen function.  For a file variable f, the fopen call looks like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {f = fopen("myfile", "w");\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The two parameters to fopen are the file name (myfile in this case) and a flags string that tells fopen what the characteristics are for the file (in this case, "w" tells fopen to open the file for output).  As we go on through the lesson, you will see more and more options for the flags.  You can also find a complete description in the ORCA/C reference manual, listed under the description of fopen.  The fopen function returns a pointer to a file variable it creates, which, of course, you need to store in the file variable f for the file calls you will make to write to the file and close the file.\par To write to the file, you use the function fprintf.  The fprintf function is almost identical to printf; the only difference is that you pass a new parameter right before the format string.  The new parameter, of course, is the file variable.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {fprintf(f, "%d\\n", i);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Once you have written everything you need to write, you close the file using fclose.  The fclose function takes a single parameter, the file variable to close.  Once you close the file you cannot write to it with fprintf.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {fclose(f);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Putting these ideas together, we can create a small program to write the integers 1 to 10 to disk, like this:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* Write some numbers to a */\par /* file.                   */\par \par #include <stdio.h>\par \par void main(void)\par \par \{\par FILE *f;\par int i;\par \par f = fopen("myfile", "w");\par for (i = 1; i <= 10; ++i)\par    fprintf(f, "%d\\n", i);\par fclose(f);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Type this program in and run it.  The file the program creates is a standard text file; there is nothing special about it at all.  You can use the Open command from the File menu to open the file, just as you would open any text file.  When you do that, you will see the numbers 1 to 10, on separate lines, just like you would if you ran the same program with printf to write the values to the shell window.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 9.1.}{  The fprintf function has all of the formatting abilities you have learned for printf.  Use this fact to create a set of multiplication tables showing values up to 10x10.  The numbers 1 to 10 should appear across the top of the table, while 1 to 10 also label the rows.  Use the _ and | characters to put dividing lines along the top and left sides of the table, as shown in the sample output.  The results should be saved in a file called multable.\par \par }\pard\plain \s23\qj\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs16         1   2   3   4   5   6   7   8   9  10\par      ________________________________________\par   1 |   1   2   3   4   5   6   7   8   9  10\par   2 |   2   4   6   8  10  12  14  16  18  20\par   3 |   3   6   9  12  15  18  21  24  27  30\par   4 |   4   8  12  16  20  24  28  32  36  40\par   5 |   5  10  15  20  25  30  35  40  45  50\par   6 |   6  12  18  24  30  36  42  48  54  60\par   7 |   7  14  21  28  35  42  49  56  63  70\par   8 |   8  16  24  32  40  48  56  64  72  80\par   9 |   9  18  27  36  45  54  63  72  81  90\par }\pard \s23\qj\widctlpar\adjustright {\fs16  10 |  10  20  30  40  50  60  70  80  90 100\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344528}Reading from a File{\*\bkmkend _Toc496344528}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Reading a file is just as easy.  To read from a file, you first have to open it for input.  You do this with the fopen function, just as you did when you wrote a file.  The only difference is that you use a flags string of "r" instead of "w".  The following program reads the file of ten integers you created in the last section, writing the values that are read to the shell window.  Be sure you have already run the program from the last section to create myfile before you run this program, since we haven't dealt with error checking yet!\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* Read some numbers from a */\par /* file.                    */\par \par #include <stdio.h>\par \par void main(void)\par \par \{\par FILE *f;\par int i, num;\par \par f = fopen("myfile", "r");\par do \{\par    num = fscanf(f, "%d", &i);\par    if (num == 1)\par       printf("%d\\n", i);\par    \}\par while (num != EOF);\par fclose(f);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par When we wrote the file, we knew exactly how many numbers we were going to write.  We could write this program to read in the same number of numbers, but then we would have to change both programs to read a file of a different size.  In addition, in many real-world programming situations, you don't know in advance how big a file is, so instead of relying on a fixed files size, this program adapts automatically to the size of the file.  It does this by using the value returned by fscanf.  When you use fscanf, it returns the number of things it reads and formats \endash \~in our example, this would normally be 1, since fscanf is trying to read one integer.  If fscanf runs into some other character, like a q, it will return 0, since it could not read an integer.  If fscanf tries to read a number, though, and sees that there are no more characters in the file at all, it returns a value that is equal to the constant EOF; this constant is defined in stdio.h.  By checking the value returned by fscanf to see if it is EOF, the program can skip printing the value, then drop out of the do loop.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 9.2.}{  The fscanf function has all of the formatting abilities you have learned for scanf.  Use this fact to write a program that reads strings from a file, rather than integers.  As with the sample program, you should echo the strings to the shell window.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {The file name is just a string, so you can read it in just like any other string.  In this program, ask the user for the file name.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Try your program on two files, the file of integers you created in the last section, and the source for your solution to this problem.  The result should tell you a lot about how fscanf breaks characters up into strings.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }{\b Problem 9.3.}{  At this point, you have the tools to merge two files.  The basic method is simple:  you open one file for input  and another for output.  You read values from one file, writing them to the other, until you get to the end of the first file.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Start by writing a program that writes the integers 1 to 10 to a file called FILE1.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Write a second program to create a second file, called FILE2, that contains the integers 11 to 20.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Write a third program, to read FILE1, writing it to a file called FILE3.  It should then read FILE2, adding the contents of FILE2 to FILE3.  The program should not depend on knowing the length of either file.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {The portion of the program that opens a file for input, reads the file, writes to the output file, and closes the input file should be encapsulated in a function that takes the name of a file as its only input.  The output file variable should be a global variable.  Open the output file once, before calling the function that will copy the contents of a file to the output file, and close the output file once just before the program stops.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Check your work by editing file3.  It should contain the numbers 1 to 20.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {The process of combining two files, or adding information to an existing file, is a very common one.  It is used by text editors to combine files, data bases to add records, and adventure games to add new characters.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344529}File Names{\*\bkmkend _Toc496344529}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The file names we have been using for our C programs have been pretty simple.  As with any name, there are some rules you must follow in choosing a file name.  There is a problem, though: as you know, C is used on many different computers, and unfortunately, the way you pick a file name differs from computer to computer.  If you are trying to write programs that will run on several different computers, this is something you will have to keep in mind.  On the Apple IIGS, file names obey the following rules:\par \par }\pard \s21\qj\fi-360\li720\widctlpar\adjustright {1.\tab A file name starts with an alphabetic character.\par 2.\tab The remainder of the file name is made up of alphabetic characters, numeric digits, and periods.\par 3.\tab A file name must have at least one character, and no more than 15 characters.\par 4.\tab GS/OS does not distinguish between uppercase characters and lowercase characters.  In other words, the file names MYFILE, MyFile and myfile all refer to the same file on disk.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344530}Directories, Path Names and Folders{\*\bkmkend _Toc496344530}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {You may have bought your Apple IIGS because it has that wonderful, easy to use desktop interface that Apple is famous for, but unlike the Macintosh, you can own an Apple IIGS for less than the price of a car, and still get color.  If so, good choice.  You may not ever want to deal with icky text-based systems like those found on the hard-to-use IBM PC and its cousins.  Good choice, again.  Unfortunately, when you are programming, you still have to deal with files using names \endash  you can't "point and click" inside of a program.  This section gives you a brief overview of how those names work, in terms of the icons and folders you are used to in desktop programs.  If you already know how files are named, what a path name is, and so forth, feel free to skip to the next section.\par I will assume that you are already familiar enough with your computer to move around using a desktop program like the Finder.  In the Finder, the first thing you see on the desktop is a list of the disks, lined up along the right-hand side of the screen.  Below each disk is a name.  To give the name of a disk in a C program, you use exactly the same name, but you start it off with a slash character.  For example, the disk where the C compiler is located is called ORCA.C.  In a file name, you would type\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/ORCA.C\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Double-click on the disk icon and the Finder will open a window showing the various files and folders.  For example, one of the folders is called SAMPLES.  If you want to look at a file in the samples folder, you add the name of the folder to the disk name, separating the two with another slash, like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/ORCA.C/SAMPLES\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par If the folder contains other folders, you can repeat this process, adding the new folder name to the name you have already accumulated.\par Eventually, you will get to the right folder, and you will see the file you want to read.  Let's assume that you want to read the file BULLSEYE.CC from the samples folder.  Once again, you tack the file name onto the names you already have, using a slash to separate the file name from the name of the disk and folder.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/ORCA.C/SAMPLES/BULLSEYE.CC\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The result is called a full path name.  It specifies exactly what file you want to read or write.\par In our examples, we just gave a file name.  Of course, the computer still writes to a specific place on the disk.  When you leave off the name of the disk and any folders, the file name is added to a default directory called prefix 0, also called the default prefix.  In a desktop program, you set the default prefix by using one of the file related commands, like open.  When you click on the disk button, it changes the default prefix to the name of a new disk.  Opening a folder on the disk adds the name of the folder to the default prefix.  Closing a folder, of course, removes the name of the folder from the default prefix.  The computer remembers this location, and uses it for all files that only have a file name.  That's why, for example, your executable program usually shows up in the same folder as the source file.  Since you probably just loaded or saved the source file, the default prefix is the folder where the source file is located, and the compiler saves the executable program in the same place.  The files created by the sample programs showed up in the same folder, too.\par Finally, if you want to get at a file in a folder that is located in the default prefix, you can use a partial path name.  For example, if the default prefix is the ORCA.C disk, and you want to access the BULLSYS.CC file, you can use\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {SAMPLES/BULLSEYE.CC\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The process of forming names for the fopen command, then, is fairly simple.  To get at a file in the default prefix, just use the file name.  If the file is in a folder in the default prefix, give the name of the folder, followed by the file name, using a slash to separate the two.  If you need to give the name of the disk, too, start off with a slash and the name of the disk, then add the folders and file names, again separated by slashes.\par If this is new to you, the best thing to do is to practice.  The easiest way to practice is with the CAT, EDIT and PREFIX commands, which you can use from the shell window.  The PREFIX command sets the default prefix.  To set the default prefix to /ORCA.C, for example, you would use\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {prefix /orca.c\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The CAT command catalogs the current prefix, showing you what files and folders are there.  Folders are marked with a file type of DIR in the second column.\par Finally, the EDIT command is another way to open a source window.  The command\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {edit /orca.c/samples/bullseye.cc\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {will open a new window and read in the file.  Unlike the Open command from the File menu, though, the EDIT command does not change the current prefix.\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 9.4.}{  Move to the shell window, and use the PREFIX command to set the current prefix to /ORCA.C/SAMPLES.  Verify that you did it right by using this command to open the BULLSEYE.CC program:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {edit bullseye.cc\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {Move to the libraries folder using the prefix command.  Use the CAT command to make sure you are in the right spot.  If you are, you will see the files ORCALIB and SYSLIB, and a folder called ORCACDEFS.  Close the BULLSEYE.CC window, and, without changing the default prefix, edit the file again.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344531}Reading Text Files One Line at a Time{\*\bkmkend _Toc496344531}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {You already know the basics of reading and writing files, but there are a lot of variations on the basic theme.  In the rest of this lesson, we will look at a variety of different programming situations that use files or formatted input and output, learning how to process information a little more effectively.  The first thing we need to cover is a way to read a file a line at a time.\par Of course, you have already learned how to read strings with scanf, and the same idea will work with fscanf, but when you use the %s conversion specifier, the scan functions treat a string as a blank-delimited string, not as a line of text.  For example, if you use scanf or fscanf to read the line\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {How, now, brown cow.\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {they will return four strings, not one.  (The four strings will be "How,", "now,", "brown" and "cow.".)\par }\pard \s21\qj\fi360\widctlpar\adjustright {To get around this problem, we need a new and very peculiar conversion specifier, [].  The bracket conversion specifier tells C to read characters as long as the characters being read match one of the characters inside of the brackets.  For example, we could read the entire line above with this scanf call:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {scanf("%[How, nbrc.]", string);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {where string is an array of char.  scanf will read characters until it gets to the \\n that marks the end of the line.  (The \\n character marks the end of input lines in C, just as you write an \\n character at the end of a line with printf.)\par }\pard \s21\qj\fi360\widctlpar\adjustright {Of course, this is pretty useless for our purposes, since you have no idea what characters might actually appear in a given input line.  We can solve this trifling difficulty by using the ^ character right after the [ character, which tells scanf to read all characters }{\i except}{ those that follow the ^ character.  The new call looks like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {scanf("%[^\\n]", string);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Only one difficulty remains.  This call to scanf reads up to the \\n character, but it does not read the \\n character itself.  If you are reading more then one line, you will need to skip the \\n character so that the next call to scanf will start with the first character of the next line.  The completed call to scanf looks like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {scanf("%[^\\n]%*1[\\n]", string);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Some of that new conversion specifier you can pick up on right away from what you have learned so far.  A conversion specifier of %[\\n] would scan for a \\n character, but by itself, this presents a problem, since the file might have several blank lines after the one you are reading, and you don't want to skip them.  Putting a 1 in the conversion specifier, so that you have %1[\\n], tells scanf to read at most 1 character.  The * is a store suppressor.  In this case, you know you will read a \\n character, and you don't want to waste the time and space to create a dummy char variable and store the \\n in the variable.  By placing the * after the %, you are telling scanf to read the \\n from the file, but }{\i not}{ to store it anywhere.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 9.5.}{  Write a simple program to echo a file to the screen.  Your program should start by asking for a file name, then use the name it reads as the name supplied to fopen.  Read the file one line at a time using fscanf and the format string you just learned about, writing the lines using printf.\par \par }{\b Problem 9.6.}{  Write a program that asks for a file name.  The program should open the file for input, read lines from the file, convert the characters to uppercase, and write them to the shell window.  Be sure and test your program!  One way to do this is to create an uppercase only version of the program itself.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344532}Bullet-proof Input{\*\bkmkend _Toc496344532}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {What's wrong with this program?\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par char string[81];\par \par printf("String:");\par scanf("%[^\\n]%*1[\\n]", string);\par printf("%s\\n", string);\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par If you don't see the problem, don't feel too bad.  Most of the time, the program works just fine.  What happens, though, if some user types in a line that is 90 characters long?  (Ever notice how user is a four-letter word for most programmers?  Frustration, I guess.)  The answer is that, in all likelihood, the program will crash, since the string array is only large enough to hold 80 characters in the string.  We need some way to prevent crashes like this, and the way to do it is with a maximum length field.  Just as we use a 1 to tell scanf to read at most one line feed, we can also use a value to tell scanf the maximum number of characters we want to read and place in the array, like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {scanf("%80[^\\n]%*1[\\n]", string);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par This idea is the basis for bullet-proof input in C.  By limiting the number of characters the program will read, you can prevent an array overflow and the sometimes disastrous after-effects.  If the user types more characters than allowed, scanf simply stops.  Of course, that means you are no longer guaranteed that the next character will be a \\n character, so some adjustments need to be made in the way you read lines.  One good way to handle this situation is to check to see if you read the maximum number of characters.  If so, you can process the characters so far, then go back and read more of the line, without reading the \\n character.  Another way to handle the situation is to artificially break long lines up into several smaller lines; this might be a good choice for a program that will write the results to the screen, anyway.  Finally, you might want to just stop and print an error message.\par Another problem with scanning input occurs when you expect one thing, like a number, and get something else, like a character.  So far, the solution is to stop the program and start over.  That's fine for you when you are learning to program, but in a good program that others will use, you need to handle things a bit better.  A popular way to do this is to read the line, as we just did, and use yet another form of scanf to read the characters, called sscanf.  Like fscanf, the difference between sscanf and the scanf function you already know about is simply where sscanf takes the characters from.  In this case, the characters are read from an input string, which is the first parameter you specify.  Naturally, this input string can be the string you just read as a whole line from the keyboard or a file, using one of the other forms of the scanf function.\par You need one other piece of information to turn all of this into a genuinely flexible way to read and process text input, and that is a new conversion specifier for scanf, called %n.  This conversion specifier is a bit of an oddball, in that no characters are read from the input stream.  Instead, scanf expects a pointer to an integer in the parameter list, and stores the number of characters read so far.  This can be used to tell you whether any characters were read at all, and if so, how far you need to skip into the string to find the start of the next integer.\par Nothing helps firm up arcane details like the ones we've been discussing like an example, so let's stop now and look at a program that puts all of these ideas together.  This program will perform a fairly simple task, but it will do it very, very well.  All our program does is read integer values from a file.  The thing that distinguishes this program from all of the others we have written in the past is that it can detect and recover from absolutely any kind of error, some of which we haven't even talked about before now.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par #include <string.h>\par \par #define BOOLEAN unsigned\par #define TRUE 1\par #define FALSE 0\par \par int main(void)\par \par \{\par char string[81];\par BOOLEAN done;\par int num, i, startch, numch, val;\par FILE *f;\par \par /* open the file */\par f = fopen("myfile", "r");\par if (f == NULL) \{\par    fprintf(stderr,\par       "Could not open myfile\\n");\par    return -1;\par    \}\par \par do \{\par    /* read a line */\par    num = fscanf(f,\par       "%80[^\\n]%*1[\\n]", string);\par    if (strlen(string) == 80) \{\par       fprintf(stderr,\par          "Line too long.");\par       return -1;\par       \}\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {   /* process the numbers */\par }\pard \s23\qj\fi360\widctlpar\adjustright {   if (num != EOF) \{\par       done = FALSE;\par       i = 0;\par       do \{\par          numch = 0;\par          startch = 0;\par          sscanf(&string[i],\par             " %n%d%n",\par             &startch, &val, \par             &numch);\par          if (numch <= startch) \{\par             if (i == \par                strlen(string))\par                done = TRUE;\par             else \{\par                fprintf(stderr,\par                   "Invalid: %s\\n",\par                   &string[i]);\par                return -1;\par                \}\par             \}\par          else \{\par             printf("%d\\n", val);\par             i += numch;\par             \}\par          \}\par       while (!done);\par       \}\par    \}\par while (num != EOF);\par \par if (fclose(f) == EOF) \{\par    fprintf(stdout,\par       "Could not close myfile");\par    return -1;\par    \}\par return 0;\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid { \par The first difference pops up right away.  When you learned to use fopen to open a file for input, I mentioned that you should be sure the file actually existed, since your program was not checking for errors.  Well, here's how to check for errors:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {f = fopen("myfile", "r");\par if (f == NULL) \{\par    fprintf(stderr,\par       "Could not open myfile\\n");\par }\pard \s23\qj\fi360\widctlpar\adjustright {   return -1;\par    \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {When the fopen function opens a file, it returns a file pointer; if it can't open the file, it returns NULL.  If you want to get fancy, you can even look at the global variable errno to get some idea as to why the file could not be opened, but we won't go into exactly how this is done in the course.  If you would like to explore this idea, read about errno and perror in the ORCA/C reference manual.\par }\pard \s21\qj\fi360\widctlpar\adjustright {Assuming an error is found, an error message is printed.  That's no surprise, but using fprintf with the file name stderr presents something new.  In C, there are two ways to write to the shell window: you can write to stdout (as printf does, by default) or you can write to stderr.  The reason for the second output file is because you can redirect the output from a text program when you run the program from the shell window.  Redirected output is a very powerful idea; it lets you trap any characters that would have been written to the shell window in another file without making any change to the program.  The problem is that you want to see any error messages printed by the program, so C gives you a second way to print text by writing it to stderr.  Even when output is redirected, the characters written to stderr still show up in the shell window.  Even if you don't use the text shell, and don't quite grasp why all of this is important, you should get in the habit of writing error messages to stderr.\par If an error occurs, we also want to quit.  We do that by returning right away from the program, passing back a value of -1.  It turns out that main is allowed to return an integer, and in text programs, it is a good idea to do that.  When your program finishes normally, you should return a zero; if it fails, you should return some non-zero value, generally -1.  The reason for this is again tied up in the way the text shell works, and again, you don't really have to worry about it unless you will be writing new commands and utilities for the shell.  As with stderr, the important point is to remember that you can return an error code from main, in case you start writing utilities later.\par The heart of the program is the do loop that actually processes the lines once the file is open.  This do loop starts off by reading a line using the techniques we discussed right before the program.  In this example, we use an extra character to detect lines that are too long, and if we find one, we again quit with an error.\par Once a line is read, another do loop scans the lines for numbers.  There are a lot of things that can go wrong, so the logic to handle all of the various cases is pretty involved.  Here's the loop that reads the numbers from the line:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {done = FALSE;\par i = 0;\par do \{\par    numch = 0;\par    startch = 0;\par    sscanf(&string[i],\par       " %n%d%n",\par       &startch, &val, &numch);\par    if (numch <= startch) \{\par       if (i == strlen(string))\par          done = TRUE;\par       else \{\par          fprintf(stderr,\par             "Invalid: %s\\n",\par             &string[i]);\par          return -1;\par          \}\par       \}\par    else \{\par       printf("%d\\n", val);\par       i += numch;\par       \}\par    \}\par while (!done);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The idea behind this loop is to scan a text line that is supposed to contain only numbers.  The program will work if the line is blank, but it will stop with an error if anything except a number appears on a line.  To handle this situation, we use sscanf to scan the string, along with the new conversion specifier that was mentioned a while back, %n.  Instead, %d writes the number of characters that have been read so far to an integer.  The lines\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {   sscanf(&string[i],\par       " %n%d%n",\par }\pard \s23\qj\fi360\widctlpar\adjustright {      &startch, &val, &numch);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {do the bulk of the work.  The initial whitespace tells scanf to skip over any whitespace that comes before the number.  We then use %d to store the starting index of the characters that we will read in startch; read the number, placing it in val; and record the number of characters read in numch.  If the line contained a numeric value, numch would be larger than startch, and the if condition right after the sscanf call would test false, so we would drop down to the else clause, print the number, remember where we need to start to scan for the next number, and loop.  If numch and startch are the same, we have skipped some whitespace and arrived at the end of the line.\par }\pard \s21\qj\fi360\widctlpar\adjustright {This explains everything except the lines\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {   numch = 0;\par }\pard \s23\qj\fi360\widctlpar\adjustright {   startch = 0;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {and the fact that the if statement checks to see if numch is }{\i less than}{ or equal to startch, not simply equal to.  The reason is tied up in the fact that sscanf stops scanning if it hits an error or the end of the line.  If sscanf hits the end of the line right away, as would happen if we read an integer, then looped, but found nothing else in the line, then startch, val and numch will not be set at all.  In this situation, the program recovers nicely, since numch and startch are preset to 0, and therefore test as equal.  If startch is read, though, and we the hit a non-numeric character, like a q, numch will not be set at all.  In that case, startch will be greater than numch, but we have not read a number.\par }\pard \s21\qj\fi360\widctlpar\adjustright {Once we reach the end of the line, the if condition will test true, and we drop through for one final check: we make sure that we reached the end of the line, and didn't just hit a bad character.\par The last section closes the file, again checking for errors.  Assuming there are no errors, the program returns 0, which tells the shell that no errors were found.\par As a footnote, I would like to point out that there is an equivalent to sscanf for the printing family of functions, called sprintf, which you can use to format text just as you do with printf, but place the text in a string instead of writing it to a file.  While we won't use this function in the course, it is often useful in toolbox programming, where you might want to format some information before using one of the toolbox calls to write the string to a graphics window or use the formatted string in a dialog.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 9.7.}{  The program you just looked at is fairly short, but it is very involved.  To make sure you understand exactly what it does, step through the program by hand with the following input.  To step through the program, actually write down the names of the variables on a sheet of paper, and "play computer," stepping through line-by-line keeping track of what the variables are.  This will take some time, but you will see very clearly how the program works.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {If you have problems, you can call on the most patient helper in the world: your computer.  The debugger can be used to step through the actual program.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {1\par 2 3\par   4\par 5  stop\par 6\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {Since this is a pen and paper exercise, there is no solution given in the solutions.  You will know if you did it right!\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344533}Binary Files{\*\bkmkend _Toc496344533}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {So far, we have been creating text files that could be edited with an editor.  This is a good way to get familiar with file handling in C, since you already know how to use printf and scanf.  It also has the advantage that you can edit the file you create to see exactly what your program did.  Finally, in many programs, text files are also what you want to create.\par On the other hand, not all files on your computer are text files, and there are some very good reasons for this.  If you stop and think about it, you already know one of the biggest reasons: space.  After all, when you use fprintf to write a floating-point number, you could get something like\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {3.1416e00\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {This number is 9 characters long, with each character taking up one byte of space in the file.  Variables of type float, though, only take up four bytes.  The first reason to use a binary file instead of a text file, then, is that binary files often take up less room on disk.\par }\pard \s21\qj\fi360\widctlpar\adjustright {Something you may not know is that converting a number from the internal format used by the computer to characters, or converting from characters to the internal format, takes a lot of time.  There are about ten to twenty floating-point operations, as well as several integer operations, involved in converting a floating-point number from one format to the other.  If you write the four bytes that are used internally to represent a floating-point number, though, no conversion is involved at all.  The same argument holds for integers, although the difference in speed is not as great as it is with floating-point numbers.  Speed is the second reason to use binary files instead of text files.\par The last reason to use a binary file is convenience.  You already know that you can't use printf to write some kinds of data, like structures or arrays (other than string, of course).  Using binary files, you can write structures or arrays directly to a file, and read them back from a file.\par To investigate binary file, we'll use two short sample programs, one of which writes a file containing 10 float values, while the other reads the same file and echoes it to the shell window.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* create a binary file */\par \par #include <stdio.h>\par \par void main(void)\par \par \{\par float x;\par FILE *f;\par \par f = fopen("myfile", "wb");\par for (x = 1.0; x <= 10.0; ++x)\par    fwrite(&x, sizeof(x), 1, f);\par fclose(f);\par \}\par \par \par /* read a binary file */\par \par #include <stdio.h>\par \par void main(void)\par \par \{\par float x;\par FILE *f;\par int num;\par \par f = fopen("myfile", "rb");\par do \{\par    num = fread(&x, sizeof(x), 1,\par       f);\par    if (num)\par       printf("%f\\n", x);\par    \}\par while (num);\par fclose(f);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par When you create a file with fopen, tacking a b onto the w in the flags string tells fopen that you want to create a binary file, rather than a text file.  The resulting file has a file type of BIN, and, of course, it cannot be loaded into the editor like a text file.  When you open the file to read it in the second program, you can also put the b in the string, but fopen actually ignores the character in this case.  You can open any file type you like for input.\par The biggest difference between the way we handle text files and binary files, though, is the way we read and write information.  Instead of fprintf, which formats information, creating strings, we use fwrite.  The fwrite function writes a series of bytes directly from memory to the disk file.  The first parameter is the address of the first of the bytes to write; in our case, we pass the address of the floating-point value we are writing to disk.  The next parameter is the number of bytes to write; using sizeof is the best way to find out what this value is.  The third parameter is the number of things to write.  If you were writing an array of ten float values, you could still pass the size of a single float value, and then pass 10 as the second parameter.  For writing an entire array, it might make just as much sense to pass the size of the array, and then pass 1 (which does the same thing), but this feature does come in handy when you want to write }{\i part}{ of an array, instead of the whole thing.  Finally, you pass the file variable for the file you want to write the bytes to.\par The second program shows that fread works pretty much the same way.  It uses the same parameters, in the same order, to do the same thing, but fread reads values from an open file instead of writing values to the file.  Making all of the parameters the same is a great aid in remembering the functions.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 9.8.}{  Create a binary file with an array of 12 integer values, 1 to 12.  In this program, fill in an array first, then write the array with a single fwrite call.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Write another program to read the same file.  In the second program, use an array of integer values that can hold 5 integers at a time, and use a single fread statement to read in up to 5 integers.  Keep track of the value returned by fread to decide how many elements of the array to write and when to drop out of the read loop.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344534}Random Access{\*\bkmkend _Toc496344534}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Let's say you have a file with five numbers, 1, 2, 3, 3, and 5.  Of course, we want a file with a 4 in the fourth spot.  On a short file like this one, we could just read the entire file into an array or linked list, make any changes we want, and write the modified file.  If you know you have enough memory to work on the file that way, it's a good choice in any language.\par Of course, in real life, we may not have enough memory to handle a file.  It isn't uncommon to work with a mailing list with several thousand entries, for example.  A reasonable sized record for handling the entries would be about 100 bytes long.  A 10,000 person mailing list, then, would take 1,000,000 bytes, which is more free memory than you are likely to find on most Apple IIGS computers.  In a situation like that, you really want to open the file for both input and output, and you want to be able to skip around in the file.  That way, you can skip to a particular entry, read the entry, and write the change back to the disk.\par So far, we have always used the fopen function to open a file for either input or output, but you can also open a file for both.  To open a file for input and output, you use a flag of a, rather than r or w.  Of course, you can still use this flag in conjunction with b to open a binary file instead of a text file.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {f = fopen("myfile", "ab");\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par When you open a file for input and output, fopen will open an existing file if there is one, setting up things so you will read the first value from the file, or write over the first value if you start writing right away.  If the file doesn't already exist, a new one is created.\par To skip around in the file, you use the fseek function.  To skip to the fourth entry in a file with integer values, you would use:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {fseek(f, sizeof(int)*3, 0);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Putting these two techniques together, it is a simple matter to change a file.  The following program resets the fourth element of a file called NUMBERS to 4, making the change discussed above.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par FILE *f;\par int i;\par \par f = fopen("numbers", "ab");\par if (f == NULL) return;\par fseek(f, sizeof(int)*3, 0);\par i = 4;\par fwrite(&i, sizeof(int), 1, f);\par fclose(f);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }{\b Problem 9.9.}{  Test the update program by writing a program to create a file with the five integers\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {1  2  3  3  5\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {Create a second program that can read this file, printing the values to the shell window.  Run the new program once to make sure the file has the values you wrote.  Next, run the sample program to update the file.  Finally, run the update program again to check to make sure the file has been changed properly.\par \par }\pard\plain \qc\widctlpar\adjustright \f4\cgrid {\b\fs36 \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \qc\widctlpar\adjustright \f4\cgrid {\b\fs36 Lesson Nine\par Solutions to Problems\par }\pard \qj\widctlpar\adjustright {\b\fs28 \par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344535}Solution to problem 9.1.{\*\bkmkend _Toc496344535}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Generate 10x10 multiplication tables */\par \par #include <stdio.h>\par \par void main(void)\par \par \{\par FILE *f;\par int i,j;\par \par f = fopen("multable", "w");\par fprintf(f, "        1   2   3   4   5   6   7   8   9  10\\n"\par            "     ________________________________________\\n");\par for (i = 1; i <= 10; ++i) \{\par    fprintf(f, "%3d |", i);\par    for (j = 1; j <= 10; ++j)\par       fprintf(f, "%4d", i*j);\par    fprintf(f, "\\n");\par    \}\par fclose(f);\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344536}Solution to problem 9.2.{\*\bkmkend _Toc496344536}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Read a file and break it into strings */\par \par #include <stdio.h>\par \par void main(void)\par \par \{\par FILE *f;                                /* file variable */\par char str[100];                          /* file name and input string */\par int num;                                /* value returned by fscanf */\par \par /* get a file name and open the file */\par printf("File name:");\par scanf("%s", str);\par f = fopen(str, "r");\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {/* read strings from the file, echoing to the shell window */\par }\pard \s23\qj\fi360\widctlpar\adjustright {do \{\par    num = fscanf(f, "%s", str);\par    if (num == 1)\par       printf("%s\\n", str);\par    \}\par while (num != EOF);\par \par /* close the file */\par fclose(f);\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344537}Solution to problem 9.3.{\*\bkmkend _Toc496344537}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Program 1: create file1.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Write 1 to 10 to file1 */\par \par #include <stdio.h>\par \par void main(void)\par \par \{\par FILE *f;\par int i;\par \par f = fopen("file1", "w");\par for (i = 1; i <= 10; ++i)\par    fprintf(f, "%d\\n", i);\par fclose(f);\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b \par Program 2: create file2.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Write 11 to 20 to file2 */\par \par #include <stdio.h>\par \par void main(void)\par \par \{\par FILE *f;\par int i;\par \par f = fopen("file2", "w");\par for (i = 11; i <= 20; ++i)\par    fprintf(f, "%d\\n", i);\par fclose(f);\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\fi360\keepn\widctlpar\adjustright {\b Program 3: merge the files.\par }{\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* Merge two files to create a third file */\par \par }\pard \s23\qj\fi360\widctlpar\adjustright {#include <stdio.h>\par \par FILE *outFile;                          /* output file variable */\par \par /* Add the contents of a file to outFile                */\par /*                                                      */\par /* Parameters:                                          */\par /*    name - input file name                            */\par /*                                                      */\par /* Variables:                                           */\par /*    outFile - output file (opened for output)         */\par \par void AddFile (char name[1])\par \par \{\par FILE *inFile;                           /* input file variable */\par int i;                                  /* value read from the file */\par int num;                                /* # items read */\par \par inFile = fopen(name, "r");              /* open the file */\par do \{                                    /* read & echo the file */\par    num = fscanf(inFile, "%d", &i);\par    if (num == 1)\par       fprintf(outFile, "%d\\n", i);\par    \}\par while (num != EOF);\par fclose(inFile);                         /* close the file */\par \}\par \par \par /* main program */\par \par void main(void)\par \par \{\par outFile = fopen("file3", "w");          /* open the output file */\par AddFile("file1");                      /* copy in the contents of file1 */\par AddFile("file2");                      /* copy in the contents of file2 */\par fclose(outFile);                        /* close the output file */\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344538}Solution to problem 9.4.{\*\bkmkend _Toc496344538}\par }\pard\plain \s21\qj\fi360\keepn\widctlpar\adjustright \f4\fs20\cgrid {The commands needed are:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {prefix /orca.c/samples\par edit bullseye.cc\par prefix /orca.c/libraries\par cat\par }\pard \s23\qj\fi360\widctlpar\adjustright {edit /orca.c/samples/bullseye.cc\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344539}Solution to problem 9.5.{\*\bkmkend _Toc496344539}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Echo a file to the screen */\par \par #include <stdio.h>\par \par void main (void)\par \par \{\par FILE *f;                                /* input file variable */\par char line[100];                         /* input string */\par int num;                                /* # of inputs */\par \par printf("File name:");                   /* open the file */\par scanf("%s", line);\par f = fopen(line, "r");\par \par do \{\par    num = fscanf(f, "%[^\\n]%*1[\\n]", line); /* read a line */\par    if (num != EOF)                      /* print the line */\par       printf("%s\\n", line);\par    \}\par while (num != EOF);\par \par fclose(f);                              /* close the file */\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344540}Solution to problem 9.6.{\*\bkmkend _Toc496344540}\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* Convert a file to uppercase */\par \par #include <stdio.h>\par #include <ctype.h>\par \par void main (void)\par \par \{\par FILE *f;                                /* input file variable */\par char line[100];                         /* input string */\par int num;                                /* # of inputs */\par }\pard \s23\qj\fi360\widctlpar\adjustright {int i;                                  /* loop variable */\par \par printf("File name:");                   /* open the file */\par scanf("%s", line);\par f = fopen(line, "r");\par \par do \{\par    num = fscanf(f, "%[^\\n]%*1[\\n]", line); /* read a line */\par    for (i = 0; i < strlen(line); ++i)   /* convert to uppercase */\par       line[i] = toupper(line[i]);\par    if (num != EOF)                      /* print the line */\par       printf("%s\\n", line);\par    \}\par while (num != EOF);\par \par fclose(f);                              /* close the file */\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344541}Solution to problem 9.8.{\*\bkmkend _Toc496344541}\par }\pard\plain \s21\qj\fi360\keepn\widctlpar\adjustright \f4\fs20\cgrid {\b Program 1: create the file.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par int a[12];                              /* array to write */\par int i;                                  /* loop variable */\par FILE *f;                                /* file variable */\par \par f = fopen("myfile", "wb");              /* open the file */\par for (i = 0; i < 12; ++i)                /* fill the array */\par    a[i] = i+1;\par fwrite(a, sizeof(int), 12, f);          /* write the array */\par fclose(f);                              /* close the array */\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }{\b Program 2: read the file.\par }{\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par int a[5];                               /* array to write */\par int i;                                  /* loop variable */\par FILE *f;                                /* file variable */\par int num;                                /* # items read */\par \par f = fopen("myfile", "rb");              /* open the file */\par do \{\par    num = fread(a, sizeof(int), 5, f);   /* read up to 5 values */\par    if (num) \{\par       for (i = 0; i < num; ++i)         /* print the values read */\par          printf("%d\\n", a[i]);\par       \}\par    \}\par while (num);\par fclose(f);                              /* close the file */\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344542}Solution to problem 9.9.{\*\bkmkend _Toc496344542}\par }\pard\plain \s21\qj\fi360\keepn\widctlpar\adjustright \f4\fs20\cgrid {\b Program 1: create the test file.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par \{\par FILE *f;                               /* file variable */\par int i;                                 /* loop variable */\par int a[5];                              /* array of values */\par \par f = fopen("numbers", "wb");            /* open the file */\par for (i = 0; i < 5; ++i)                /* set up the array */\par    a[i] = i+1;\par a[3] = 3;\par fwrite(a, sizeof(int), 5, f);          /* write the array */\par fclose(f);                             /* close the file */\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\fi360\keepn\widctlpar\adjustright {\b Program 2: read the file.\par }{\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par \{\par FILE *f;                               /* file variable */\par int i;                                 /* loop variable */\par int a[5];                              /* array of values */\par \par f = fopen("numbers", "rb");            /* open the file */\par fread(a, sizeof(int), 5, f);           /* read the array */\par for (i = 0; i < 5; ++i)                /* write the array */\par    printf("%d\\n", a[i]);\par fclose(f);                             /* close the file */\par \}\par }\pard\plain \s16\widctlpar\adjustright \f4\cgrid {\par \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s1\qc\nowidctlpar\outlinelevel0\adjustright \b\f4\fs36\cgrid {{\*\bkmkstart _Toc496344543}Lesson Ten{\*\bkmkend _Toc496344543}\par {\*\bkmkstart _Toc496344544}Miscellaneous Useful Stuff{\*\bkmkend _Toc496344544}\par }\pard\plain \qj\widctlpar\adjustright \f4\cgrid {\b\fs28 \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344545}A Look at this Lesson{\*\bkmkend _Toc496344545}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {As you have probably gathered by now, this course is organized around presenting the principles of programming, not just teaching you the C language.  In the first few lessons, the emphasis was on teaching you enough about the C language and the ORCA development environment so you could write simple programs.  Gradually the emphasis shifted, so that the last few lessons have concentrated on specific programming goals and ideas that are common in many programs, presenting the parts of the C language that were needed to accomplish these tasks.  Starting with Lesson 13, we will shift completely over to learning about programming concepts and techniques.  You will have learned as much of the C language as this course will teach you, and the emphasis will instead be on learning how to use the C language you already know to solve common programming problems.\par C is a big language, though, and there are many other details about the language that have not been covered in this course.  The purpose of this lesson and the next one is to give you a quick tour of some of the parts of the language that have not been used in the course so far.  You will see many of these features used in the lessons that follow, but for various reasons, it is a good idea to stop and cover these parts of the C language here, so we can concentrate on the programming later, and not on the mechanics of a few new features of the C language.\par Some of the features you will see described in this lesson and the next one are key parts of the C language that you will find used over and over.  Initializers, which let you assign an initial value to a variable when it is defined, are a good example.  The only reason you haven't seen them so far is that it would have interrupted some of the thought process in the early lessons, when the emphasis was on developing an orderly flow in the programs, and because you need to know more about storage classes (the various ways variables are stored) before you could understand when it is appropriate to use initializers, and when it is a waste of time.  Other features of the language are rarely used.  The goto statement is a great example of this: there is only one situation in C that I can thing of when the goto statement should be used, and even then, there are ways to avoid it.  There are some features that are very useful in some kinds of programs, but which some programmers rarely, if ever, use.  Writing numbers in other bases is a good example: for some kinds of toolbox programming, and many bit or byte manipulation programs, the ability to write a number in a new base is very handy, yet for many other kinds of programs, you just don't need the feature.  Finally, some of the sections expand on features you have already seen briefly, filling you in on the details.  The descriptions of the break statement (which you used to get out of the switch statement) is one good example.\par In short, this lesson and the next one are a miscellaneous collection of features of the C language.  Some are neat, some you just need to know about in case you run across them in a book or magazine, and some may seem very useful to you, and worthless to someone else taking the course.  In any case, this lesson will certainly give you some of the flavor of the C language as it is used by experienced programmers. \par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344546}Number Bases{\*\bkmkend _Toc496344546}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Most people who deal with numbers at all are very familiar with what mathematicians call the decimal number system, or base 10.  The reason, of course, is right in front of you: you probably have 10 fingers.  Computers, on the other hand, have one "finger": everything they do is based on internal switches.  As a result, computers do math using what mathematicians call binary arithmetic, where there are only two digits, 0 and 1.  When you want to write the number after 9, which is the largest one you can represent with a single digit in base 10, you write a 1 followed by a zero: the 1 is in the tens column, and the zero in the ones column.  The same thing happens in base two.  To write one, you write 1.  One is the largest available digit, so to write two in binary, we write 10.\par Binary math quickly becomes tedious, both for us and for the computer.  Because of the way computers are built, we rarely deal with individual bits; instead, we group bits together to form bytes.  In the very early days of computers, there were two common sizes for a byte: six bits and eight bits.  Other sizes have also been tried, but these two have a direct impact on the C language.  With a little work, you can convince yourself that you can represent 64 distinct values with 6 bits, and 256 distinct values with 8 bits.  We could, of course, develop numbering systems for base 64 and base 256 to deal with this situation, but that gets cumbersome for another reason: you would have to learn either 64 or 256 different symbols to represent a number.  In both cases, the way we really deal with the values of a byte is to split the byte up into two pieces, popularly called nibbles.  The competing size for the nibbles is 3 bits for a 6 bit byte, which allows up to 8 values to be represented by one nibble; and 4 bits for an 8 bit byte, which allows up to 16 values to be represented by one nibble.\par Finally, we get to the point: as you would expect, and as you already know from experience, C lets you code numbers as decimal values.  For example,\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {printf("%d\\n", 12);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {prints 12.  I expect you would be rather shocked if it printed anything else.  Try this program, though:\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par printf("%d\\n", 012);\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The only change we made was to put a leading 0 in front of the number, something you probably wouldn't expect to make a difference.  In all of the common programming languages except C, it doesn't make a difference, but C will print the value 10.\par To understand why, we have to go back to the early days of C, when it was used to develop a fledgling operating system known as UNIX on a small DEC computer.  DEC computers happen to print the values of bytes in three bit groups (even 8 bit bytes, strangely enough), and the authors of C undoubtedly wanted an easy way to represent numbers the way they were used to representing them.  They arrived at the convention of using a leading zero to tell the computer that a number was in base 8, rather than base 10.  In base 8, 012 is 1*8 + 2, just as 12 in base 10 is 1*10 + 2.  Adding up the values of the digits, you can see that 012 is, in fact, 10.  This peculiar way of representing base 8 numbers is the reason that you were warned back at the start of the course not to start numbers with a zero digit!\par Most modern general purpose computers, and virtually all desktop computers, put eight bits in a byte.  The natural way to deal with eight bits in a byte is to use base 16, or hexadecimal notation.  Of course, you need six extra digits to represent the values 10 to 15, since all of these values become a single digit in hexadecimal notation.  For once, everyone arrived at a single solution: the letter A is used to represent 10, B for 11, and so forth.  In C, to tell the compiler that you are using hexadecimal notation, you start the number with the characters 0x.  The 'x' can be either an uppercase or lowercase letter, and you can use either case for the digits that are represented by a letter, too.  I tend to use a lowercase x, and uppercase letters for the digits, just to keep them straight.  This convention is common, but certainly not universal.\par Here's our sample program again, this time with a hexadecimal value.  See if you can figure out the value before running the program.  Remember, the rightmost column is the 1's column, the next column to the left will be the 16's column, the next one is the 256's column, and so on.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par printf("%d\\n", 0xBAD);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The answer is B*256 + A*16 + D, or 11*256 + 10*16 + 13, which is 2989.\par When you read a number with scanf using the %d conversion specifier, it expects a decimal value.  Scanf has another conversion specifier called %i which can handle octal and hexadecimal values, though.  It works just like %d, but, like the C compiler, it treats numbers that start with a 0 as octal numbers, and numbers that start with 0x as hexadecimal numbers.  The printf function also has two conversion specifiers, %o and %x, which allow you to print octal or hexadecimal values directly to the screen.  Problem 10.1 explores these conversion specifiers.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 10.1.}{  Read about the %o and %x conversion specifiers for printf, and the %i conversion specifier for scanf in your ORCA/C reference manual.  Use what you learn to write a simple base conversion program.  You program should accept }{\i long integer}{ values from the keyboard in decimal, octal, or hexadecimal notation, and print the number in all three bases.  It should loop until the person using the program enters 0.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Test your program by converting the following numbers to all three bases:\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\fi-360\li720\widctlpar\adjustright {a.\tab 100000\par b.\tab 0xBAD\par c.\tab 0xBAD0\par d.\tab 012\par e.\tab 01\par f.\tab 010\par g.\tab 0100\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344547}The Bitwise And Operation{\*\bkmkend _Toc496344547}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {In the last section, we mentioned again that your computer's memory is made up of a series of bytes, with 8 bits grouped together to form each of the bytes.  Advanced programmers and people writing programs to deal directly with hardware often need to deal with these bits individually.  C has a series of four bit manipulation operators that make this possible.  In the next few sections, we'll explore these bit manipulation operators.\par Bit manipulation is a fairly advanced topic for a beginning programming course.  If you have already learned how to manipulate bits in another language, these sections may seem a bit slow to you, but if you have never seen bit manipulation before, these sections will be challenging.  While you should certainly take a crack at the information you find here, you won't use the bit manipulation operations much in the rest of the course.  If some of the information doesn't sink in right away, you won't be lost in the other lessons.\par Bit manipulation operators perform the same logical operations you already know, plus one new one.  You already know the && and || operators, used to test two logical values to see if they are both true (the and operator, &&) or to see if either is true (the or operator, ||).  The first two of the bit manipulation operators correspond directly to these two logical operators.  The operators are & and |; they are called the bitwise and operator and the bitwise or operator.\par When you use the && operator, it tests two integers, returning 1 if both of the integers are true, and 0 if either or both of the integers are false.  The bitwise and operator does something similar, but it does it with the individual bits in the number.  To see how this works, we'll try a few examples with four-bit values, specified in binary.  In the last section, you saw how to convert from one number base to another, but this may be new to you, so the values are also shown in hexadecimal and decimal notation, too.\par For the first example, we'll look at how the & operator works when the numbers are either 0000 or 0001.\par \par }\pard \s21\qj\fi360\keepn\widctlpar\tx720\tx1800\tx2880\adjustright {\tab binary\tab decimal\tab hexadecimal\par \par }{\f6 \tab 0000\tab 0\tab 0\par &\tab }{\f6\ul 0000}{\f6 \tab }{\f6\ul 0}{\f6 \tab }{\f6\ul 0}{\f6 \par \tab 0000\tab 0\tab 0\par \par \tab 0000\tab 0\tab 0\par &\tab }{\f6\ul 0001}{\f6 \tab }{\f6\ul 1}{\f6 \tab }{\f6\ul 1}{\f6 \par \tab 0000\tab 0\tab 0\par \par \tab 0001\tab 1\tab 1\par &\tab }{\f6\ul 0000}{\f6 \tab }{\f6\ul 0}{\f6 \tab }{\f6\ul 0}{\f6 \par \tab 0000\tab 0\tab 0\par \par \tab 0001\tab 1\tab 1\par &\tab }{\f6\ul 0001}{\f6 \tab }{\f6\ul 1}{\f6 \tab }{\f6\ul 1}{\f6 \par }\pard \s21\qj\fi360\widctlpar\tx720\tx1800\tx2880\adjustright {\f6 \tab 0001\tab 1\tab 1\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par In this example, the & operator does exactly the same thing as the && operator, but in reality, it is only working on a single bit.  This is a very handy table, though, because it shows exactly how the & operator works: in any given bit position, if both bits are 1, the bit in the answer is also 1.  If either bit is zero, though, the answer is 0, too.\par The same ideas that you saw in that example apply to the other bit positions, as these examples show.\par \par }\pard \s21\qj\fi360\keepn\widctlpar\tx720\tx1800\tx2880\adjustright {\tab binary\tab decimal\tab hexadecimal\par \par }{\f6 \tab 0011\tab  3\tab 3\par &\tab }{\f6\ul 1010}{\f6 \tab }{\f6\ul 10}{\f6 \tab }{\f6\ul A}{\f6 \par \tab 0010\tab  2\tab 2\par }{\par }{\f6 \tab 1100\tab 12\tab C\par &\tab }{\f6\ul 1010}{\f6 \tab }{\f6\ul 10}{\f6 \tab }{\f6\ul A}{\f6 \par }\pard \s21\qj\fi360\widctlpar\tx720\tx1800\tx2880\adjustright {\f6 \tab 1000\tab  8\tab 8\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par The four bits we have been working with so far represent a single hexadecimal digit, which is one-half of a byte.  An int variable is made up of two bytes in ORCA/C, and it must be at least two bytes long in all other ANSI implementations of C.  In other words, an int (or an unsigned int, which is the same size) is made up of four hexadecimal digits.  Here's a short program that will extend the operations we were just doing to a full four hexadecimal digits.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par int a,b;\par \par a = 0x3C3C;\par b = 0xAAAA;\par printf("%04X & %04X = %04X\\n",\par    a, b, a&b);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\} \par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par When you run this program, the result is 2828.  Take a close look at the last example, and match up the digits in the numbers used in the program.  Do you see a pattern?  You can find the result by hand by anding the hexadecimal digits, using the results from anding individual digits in the example.\par The & operator can also be used with char variables, which are really just another form of int variable as far as the & operator is concerned, or with long or unsigned long variables, which work the same way but give you eight digits to play with instead of four.  The & operator cannot be used with float variables.  The same thing is true for all of the other bitwise operators we will explore.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 10.2.}{  In the sample program, the conversion specifier used was %04X.  What do the 0 and 4 do?  (Hint: each of these digits has a special meaning.  You can either experiment with the program to find out what they do, or look up the printf function in the ORCA/C reference manual.)\par \par }{\b Problem 10.3.}{  The & operator is often used as a mask to detect the presence of individual bits.  You can use this idea to write a function that writes numbers in binary format.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Your function should take an integer parameter and print the integer as a binary number, printing all 16 bits.  Making use of the fact that C treats any non-zero value as true, you can write one digit like this:\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {if (num & 0x8000)\par    printf("1");\par else\par    printf("0");\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {Use this function to create a table showing the values 0 to 15 in binary, hexadecimal and decimal notation.  This table will be very handy in the sections that deal with bit manipulation!\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }{\b Problem 10.4.}{  Testing individual bits can be used for a number of programming tricks.  One of these tricks is a quick test to see if a number is negative or positive.  The piece of information you need to make this work is that negative numbers always have the most significant bit set, so anding the number with 0x8000 will always yield a non-zero number for negative numbers, and 0 for positive numbers.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Use this trick to implement a function that returns true if a number is negative, and false if it is positive.  Test your program with inputs of 1, 0, -1, -32767 and 32767.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {While mathematicians treat 0 as a number that is neither negative or positive, programmers treat 0 as a positive number.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {This trick depends on a particular internal number representation called two's complement notation.  Most modern digital computers use two's complement notation, but technically, it is possible that this programming trick will not work with some implementations of C.  It is also possible that int values will be larger than two bytes, which would mean that the value of 0x8000 would have to be changed on some machines for this trick to work.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344548}The Bitwise Or Operator{\*\bkmkend _Toc496344548}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Just as the & operator is a bit-by-bit implementation of the && operator, the | bitwise or operator is a bitwise implementation of the || logical or operator.  The | operator works across the bit, setting each bit in the answer to 1 if either of the corresponding bits in the operands were 1, and setting the bit in the answer to 0 if both of the corresponding bits in the operands were 0.  To see how this works, let's take another look at the same example we used in the last section to explore the & operator.  This also gives you a good way to compare the two operators.\par \par }\pard \s21\qj\fi360\keepn\widctlpar\tx720\tx1800\tx2880\adjustright {\tab binary\tab decimal\tab hexadecimal\par \par }{\f6 \tab 0011\tab  3\tab 3\par |\tab }{\f6\ul 1010}{\f6 \tab }{\f6\ul 10}{\f6 \tab }{\f6\ul A}{\f6 \par \tab 1011\tab 11\tab B\par }{\par }{\f6 \tab 1100\tab 12\tab C\par |\tab }{\f6\ul 1010}{\f6 \tab }{\f6\ul 10}{\f6 \tab }{\f6\ul A}{\f6 \par }\pard \s21\qj\fi360\widctlpar\tx720\tx1800\tx2880\adjustright {\f6 \tab 1110\tab 14\tab E\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par You saw one of the most common uses of the & operator in the problems from the last section, namely to detect if certain bits are set.  One of the main uses of the bitwise or operator is to set a bit.  The problems will look at one of the many practical uses of this idea.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 10.5.}{  In the last section, we used a small program to test the & operator with the operands 0x3C3C and 0xAAAA.  Rewrite this program so it reads two hexadecimal values and prints the result of anding the values with the bitwise and operator, and oring the values with the bitwise or operator.  Test the program with several values, including 0x3C3C and 0xAAAA.\par \par }{\b Problem 10.6.}{  If you look closely at the ASCII character set, you will find that the values of each of the lowercase alphabetic characters is exactly 32 greater than the value of the corresponding uppercase character.  For example, the value of 'A' is 65, and the value of 'a' is 77, which is 32 greater than 65.  As it turns out, 32 in hexadecimal is 0x0020, which has exactly one bit set.  In other words, you can convert from uppercase to lowercase by setting the sixth bit, counting from the right, and you can do that by oring the lowercase character with the value 0x0020.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Use this idea to write your own version of the tolower function.  Your function should be called lower; it should take a char parameter and return a char result.  If the input is an uppercase letter, your function should return the lowercase equivalent.  If the input is not an uppercase letter, your function should return the same value it was passed.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Test your function by passing the following values, and printing both the input and output:\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\tx900\tx1440\tx1980\tx2520\adjustright \f6\fs20\cgrid {A\tab a\tab U\tab 4\tab \{\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344549}The Bitwise Exclusive Or Operator{\*\bkmkend _Toc496344549}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The bitwise exclusive or operator is ^.  There is no corresponding logical operator for the bitwise exclusive or operator, which returns 0 if both input bits are the same, and 1 if the bits are different, as shown in this example:\par \par }\pard \s21\qj\fi360\keepn\widctlpar\tx720\tx1800\tx2880\adjustright {\tab binary\tab decimal\tab hexadecimal\par \par }{\f6 \tab 0011\tab  3\tab 3\par ^\tab }{\f6\ul 1010}{\f6 \tab }{\f6\ul 10}{\f6 \tab }{\f6\ul A}{\f6 \par \tab 1001\tab  9\tab 9\par }{\par }{\f6 \tab 1100\tab 12\tab C\par ^\tab }{\f6\ul 1010}{\f6 \tab }{\f6\ul 10}{\f6 \tab }{\f6\ul A}{\f6 \par }\pard \s21\qj\fi360\widctlpar\tx720\tx1800\tx2880\adjustright {\f6 \tab 0110\tab  6\tab 6\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par This operator is used to change individual bits within an integer.  That's sort of an odd thing to do in most programming situations, but it turns out that there are some interesting applications for this operator.  One use you can put it to is a simple checksum that detects when a file has been changed.  Listing 10.1 shows a program that performs a checksum on a text file.\par The program works by flipping bits in a seemingly random manner.  The result of running the program on a single file is always the same, though.  If you change even one byte in the file, the result will be different.  While it is possible to change a file around and get the same checksum, it is fairly unlikely, especially if the files are close.  To see the program in action, try running it on a test file that you have saved to disk, then change a single character in the file and run the program again.  Be sure you save the file to disk before you run the program, since your program can't read the contents of a window directly.\par This sort of checksum is far from foolproof, but it does have some useful applications.  One is to check to see if files in memory have been stomped on.  Another is to see if you have typed a file into memory correctly: if you have a checksum for the original file, you can generate a checksum for your file and see if they differ.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 10.7.}{  Write a program that reads two integers, computes the exclusive or, and writes the result.  Try this program with the inputs 0x1234 and 0xFFFF.  Try it again with the result of the first run of the program and 0xFFFF again.  What is the result?  Why?\par \par }{\b Problem 10.8.}{  One of the more interesting applications I have ever come across for the exclusive or operator is to write a file encryption program.  The idea behind a file encryption program is to encode }{\lang1024 {\shp{\*\shpinst\shpleft288\shptop3312\shpright9360\shpbottom12816\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz28\shplid1160{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 3735552}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 10.1\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* compute a checksum for a file */\par \par #include <stdio.h>\par \par int main(void)\par \par \{\par FILE *f;                                /* input file variable */\par char name[100];                         /* input string */\par int checkSum;                           /* checksum value */\par int byte;                               /* value read from the file */\par \par printf("File name:");                   /* open the file */\par scanf("%99s", name);\par f = fopen(name, "r");\par if (f == NULL) \{\par    fprintf(stderr, "Could not open %s.\\n", name);\par    return -1;\par    \}\par \par checkSum = 0;                           /* start with a zero checksum */\par do \{                                    /* XOR all bytes in the file */\par    byte = fgetc(f);\par    if (byte != EOF)\par       checkSum = checkSum ^ byte;\par    \}\par while (byte != EOF);\par printf("The checksum is %d.\\n", checkSum); /* print the checksum */\par \par fclose(f);                              /* close the file */\par return 0;\par \} \par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8220\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 10.1\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* compute a checksum for a file */\par \par #include <stdio.h>\par \par int main(void)\par \par \{\par FILE *f;                                /* input file variable */\par char name[100];                         /* input string */\par int checkSum;                           /* checksum value */\par int byte;                               /* value read from the file */\par \par printf("File name:");                   /* open the file */\par scanf("%99s", name);\par f = fopen(name, "r");\par if (f == NULL) \{\par    fprintf(stderr, "Could not open %s.\\n", name);\par    return -1;\par    \}\par \par checkSum = 0;                           /* start with a zero checksum */\par do \{                                    /* XOR all bytes in the file */\par    byte = fgetc(f);\par    if (byte != EOF)\par       checkSum = checkSum ^ byte;\par    \}\par while (byte != EOF);\par printf("The checksum is %d.\\n", checkSum); /* print the checksum */\par \par fclose(f);                              /* close the file */\par return 0;\par \} \par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx288\dpy3312\dpxsize9072\dpysize9504\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{a file so that no one can read it.  The file is encrypted with the aid of a password, which is also needed to read the file again: without the password, the information in the file is useless.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {An easy way to encrypt a file is to use a random number generator like the one you have used in C simulations to generate a string of random numbers, and exclusive or the random numbers with the bytes in a file.  A pseudo-random number generator produces the same sequence of numbers if it is given the same seed, so the password is used as the seed for the random number generator.  To encrypt the file, the bytes are read from the input file and exclusive ored with the values generated by the random number generator, then written to the output file.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Decrypting the file is surprisingly easy: you just run the same program again, using the same password.  The reason this works is that exclusive oring one value with another value two times gives you back the original number, whatever it was, as you saw in problem 10.7.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Write a program that will ask for an input file name, an output file name, and a numeric password.  Use the password as the seed to C's random number generator, then encrypt the input file, writing the bytes to the output file.  When you test your program, the editor will give you some sort of error when you try to load the file, but you can move to the shell window and type the file with the type command, like this:\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {type myfile\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {where myfile is the name of the encrypted file.  Running the encryption program again with a different password should give you back a garbage file, but you should be able to decrypt the file by using the original password.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Hint: Even though the files involved are text files, you don't want to use fscanf and fprintf, since these text input and output functions do some conversions to the values they read and write.  Instead, use fread and fwrite, which do not do any conversions of values.  To make the program faster, you can also read more than one character at a time with fread \endash  the solution reads 64 characters at a time.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {This encryption routine is good enough to stump most people, but someone who is good at breaking codes would not have much trouble with it.  In other words, if you want to protect some private letters from you boss/spouse/parents, go for it, but if you are trying to hide something from the National Security Agency, this won't slow them down much.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344550}The Bitwise Negation Operator{\*\bkmkend _Toc496344550}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The bitwise negation operator, ~, returns the opposite of the bits in the input value.  Like the logical negation operator !, the bitwise negation operator works on a single operand.\par \par }\pard \s21\qj\fi360\keepn\widctlpar\tx720\tx1800\tx2880\adjustright {\tab binary\tab decimal\tab hexadecimal\par \par }{\f6 ~\tab }{\f6\ul 1010}{\f6 \tab }{\f6\ul 10}{\f6 \tab }{\f6\ul A}{\f6 \par }\pard \s21\qj\fi360\widctlpar\tx720\tx1800\tx2880\adjustright {\f6 \tab 0101\tab  5\tab 5\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }{\b Problem 10.9.}{  The bitwise negation operator is sometimes used in graphics applications to reverse images on the screen.  We'll write a simple program to do just that.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Create a function that initializes an int pointer to 0xE12000, which just happens to be the address of the graphics screen on the Apple IIGS.  You will have to cast the integer to a pointer type, of course.  The graphics screen consists of 200 rows of 640 pixels, with each pixel using two bytes.  A little math shows that each row consists of 160 bytes, or 80 integers, and that the entire screen uses 16000 integers.  Fortunately, on the Apple IIGS, these bytes are all in a row.  Your function should use the bitwise negation operator to reverse the bits at the location your pointer points to, storing the bits back in the original spot.  With this accomplished, increment the pointer to advance to the next integer.  Do this 16000 times in a for loop.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {In your main program, call your function, then use a for loop to pause for a while, and call it again. The results can be pretty entertaining.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {With debug code on, the program takes a fair amount of time to flip the screen.  Try it again with debug code turned off.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344551}Escape Sequences{\*\bkmkend _Toc496344551}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {You've been using escape sequences all along in your C programs, but you heard the name so long ago that it might be a good idea to review what they are.  Escape sequences are C's way of putting characters into a character or string constant that can't normally be typed from the keyboard.  The most common example is the newline character which you use in printf to move to the start of a new line, and which you read from scanf when the user types a RETURN character, or when you get to the end of a line in a text file.  Internally, the newline character is coded as the number 10; to get the newline character in a character constant or string, you type \\n.\par There are a lot of other characters that can't be typed from the keyboard that are still used fairly frequently, especially in text programs, that also have escape sequences.  Table 10.1 shows a complete list of the standard C escape sequences, plus \\p, which is unique to Apple-based implementations of C.\par \par }\pard \s21\qj\fi360\keepn\widctlpar\tx1800\tx3240\adjustright {\ul escape seq}{.\tab }{\ul value}{\tab }{\ul meaning}{\par a\tab 7\tab bell\par b\tab 8\tab back space\par f\tab 12\tab form feed\par n\tab 10\tab new line\par p\tab --\tab p-string\par r\tab 13\tab carriage return\par t\tab 9\tab tab\par v\tab 11\tab vertical tab\par \\\tab 92\tab \\ character\par '\tab 96\tab ' character\par "\tab 34\tab " character\par ?\tab 63\tab ? character\par \par }\pard \s21\qc\fi360\widctlpar\tx1800\tx3240\adjustright {Table 10.1: Escape Sequences\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par Many if these escape sequences are only used from text programming environments like the one you can get to by quitting the desktop development environment.  In that environment, \\a beeps the warning sound, \\b moves back one character, \\f moves the cursor to the top left corner of the screen and clears the screen, \\r moves to the start of the current line, and \\v moves up one line.  All of these except \\r are ignored in the shell window, and even in the text environment, tabs (\\t) are ignored, although some printers will do something with the tab key.  Even \\n is ignored by most of the tools in the Apple IIGS toolbox.  In short, how these characters are used depends to some extent on where the text is being written to.  In a text environment, virtually all of these characters have some use, but in graphics programming environments, many of the old techniques for dealing with text and a cursor simply don't make sense anymore.\par The \\p escape sequence is a little odd.  There are two common string formats in use on microcomputers, the so-called p-string and the c-string.  C-strings are the null-terminated character sequences you have been using with C all along; they consist of a sequence of characters followed by a zero value.  P-strings are handled a little differently.  A p-string starts with a one byte number that gives the size of the string, followed by the characters.  The advantage of p-strings is that they can hold any character value, including a character with a value of 0.  The advantage of c-strings is that they are not limited to 255 characters by the value the length byte can hold.\par For the most part, you can ignore p-strings in C programs, but Apple's toolbox uses p-strings extensively.  Many calls accept p-strings, with no corresponding call to accept a c-string.  The \\p escape sequence helps you in these situations.  When you use a \\p as the first character in a string constant, the first character position is filled in with the length of the string, so that the toolbox will recognize the string as a p-string.  The string still has a null terminator (which the tools ignore), so you can still use standard C functions to manipulate the string.  If you are doing this kind of programming, you might also want to look up the c2pstr and p2cstr functions, two non-standard functions that are also common in Apple based C compilers.  They help you switch between these two string formats.\par The last four escape sequences are needed to overcome the syntax of the C language.  You need \\\\ to put a \\ character into a character or string constant, since a single \\ signals the start of an escape sequence.  The \\' escape sequence is needed in character constants so that the C compiler doesn't think the ' character marks the end of the constant, while \\" is needed in string constants for the same reason.  The \\? escape sequence is needed because of trigraphs, a rather odd feature of the C language that lets you enter characters like [ from old keyboards that don't have the character.  All you really have to remember is that you can't put two ? characters in a row without causing problems.  If you need two ? characters in a string, use \\?.  "Say what\\?\\?" is one example.\par While these escape sequences cover the most commonly needed special characters, there are others you may need for peculiar situations.  For example, many printers use the escape character, whose value is 27, to start special command codes to tell the printer to do something, like switch to 17 characters per inch.  You can code any character as an escape sequence by following the \\ character with a one to three digit octal value for the number.  The value 27 is 033 in octal, so you could use \\033 or \\33 to get an escape character.  Be careful, though: C will use three digits if they are there!  If you want to follow the escape character with the character 0, you need to use "\\0330", not "\\330".  The second form gets forced into a single character, since C compilers always grab all three digits when they are there.\par For those of you who, like myself, find hexadecimal to be the natural base for dealing with all numbers, and find octal to be even more peculiar than decimal, you can also code numeric escape sequences with one to three hex digits by following the \\ character with an x, then the digits, like this: "\\x01B".\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 10.10.}{  Write a program that will print the following lines to the shell window:\par \par }\pard \s24\qj\fi-360\li720\widctlpar\adjustright {a.\tab Huh???\par b.\tab C uses \\n for the end of a line.\par c.\tab I said, "Quote me!"\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }{\b Problem 10.11.}{  Try to decode this string the way printf would, then check your work using a C program:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {"\\x54\\145\\x073\\x074\\x69\\156\\x067\\54\\0401\\054\\x0202\\x2c\\x20\\x33\\x2e\\n"\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344552}The goto Statement{\*\bkmkend _Toc496344552}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {One of the most infrequently used statements in good C programs is the goto statement.  Basically, a goto statement is a jump.  The program moves to the destination of the goto, and starts executing with that statement.  The following program gives a very simple example of this idea.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par goto there;\par printf("This gets skipped.\\n");\par there:\par   printf("This gets printed.\\n");\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par As you can see, there isn't much to a goto statement.  In fact, all there is is the reserved word goto, followed by a label.  The label tells the compiler where to go to; a corresponding label must appear somewhere in the function, followed by a colon.\par Give the program a try, especially if you aren't sure exactly what will happen.  This is a great chance to use the step-and-trace debugger, again.\par People who learned to program in BASIC or FORTRAN generally leaned heavily on the goto statement, since those languages don't have the rich flow of control statements that C does.  In fact, for the most part, people who learn these languages first tend to overuse gotos, often creating what is known as spaghetti code.  As structured programming languages and structured programming techniques came into style, there was a strong backlash against this practice.  Many people got to the point where they associated the so-called goto-less programming with structured programming.  In one sense, this was a good idea: overuse of goto statements can make a program very hard to read.  Experience shows that programs that are hard to read are often disorganized and buggy, and bugs (which exist in all programs) are harder to track down and eliminate in programs that are hard to read.  Unfortunately, this backlash went overboard.  Many people now think that the goto statement is evil.  We'll look at this issue again after dealing with two statements, break and continue, which are actually extensions of the concept of the goto statement.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 10.12.}{  The while loop, for loop, and do-while loop in C are all fairly sophisticated statements.  They make programs easier to write and read, but they are also, technically, not needed.  In very early programming languages, and even today in assembly language, you would do the same thing that these statements do with conditional checks like C's if statement and goto statements.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {To get a feel for the goto statement, as well as to gain some appreciation for how much work C does for you, rewrite this loop using if statements and goto statements:\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {for (i = 1, i <= 10; ++i)\par    printf("%d\\n");\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344553}The break Statement{\*\bkmkend _Toc496344553}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {You saw the break statement briefly back when we looked at the switch statement.  The break statement was used to leave the switch statement.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {switch (i) \{\par    case 1: printf("*\\n");\par            break;\par    case 2: printf("**\\n");\par            break;\par    case 3: printf("***\\n");\par            break;\par }\pard \s23\qj\fi360\widctlpar\adjustright {   \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par You can do exactly the same thing with a goto statement, like this:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {switch (i) \{\par    case 1: printf("*\\n");\par            goto out;\par    case 2: printf("**\\n");\par            goto out;\par    case 3: printf("***\\n");\par            goto out;\par    \}\par }\pard \s23\qj\fi360\widctlpar\adjustright {out:\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par You can come up with a lot of reasons for using break instead of goto in this situation, and they are all good.  I would, in fact, strongly encourage the use of break instead of goto.  The point of this example is basically to show you exactly how the break statement works, with all of the secrecy removed.  The break statement, as it turns out, is just a goto statement that jumps out of a loop without the need of a label.\par The switch statement is the most common place for using the break statement in C, but there are others.  Occasionally, you need to get out of a do loop, while loop, or for loop early.  The break statement can be used to leave all of these loops, not just a switch statement.  A good example of a case where you would want to use a break statement in a loop is when you are searching a linked list for a particular item.  As a simple example, let's assume that you want to scan a list of names to see if a particular name exists.  This problem is a very common one in programming:  the list could be a list of names in a customer database, a list of commands that an adventure game recognizes, a dictionary in a spelling checker, or a list of variables in a C program.  If the name is in the list, you want to print true.  If the name is not in the list, you want to print false.\par The most obvious way to write a test of this sort is to loop over the list, testing each element, like this:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {ptr = names;\par found = NULL;\par while (ptr != NULL) \{\par    if (strcmp(ptr->name, name)\par       == 0)\par       found = ptr;\par    ptr = ptr->next;\par    \}\par if (found == NULL)\par    printf("false\\n");\par else\par    printf("true: \\"%s\\"\\n",\par }\pard \s23\qj\fi360\widctlpar\adjustright {      name);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {This will work, all right, but it takes way too much time.  This algorithm will look at each and every element of the list, even if it has already found the one we need.  On average, though, we only need to look at half of the elements in the list before we find the right one.  If there are ten names in a program's list of inputs, the speed won't be an issue, but if you are searching through a list of 30,000 words in a dictionary, the difference is very important.\par }\pard \s21\qj\fi360\widctlpar\adjustright {A break statement, though, can give us the performance we need by leaving the loop as soon as a matching name is found.  It also gets rid of the need for the found variable.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {ptr = names;\par while (ptr != NULL) \{\par    if (strcmp(ptr->name, name)\par       == 0)\par       break;\par    ptr = ptr->next;\par    \}\par if (ptr == NULL)\par    printf("false\\n");\par else\par    printf("true: \\"%s\\"\\n",\par }\pard \s23\qj\fi360\widctlpar\adjustright {      name);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Occasionally, the true goto statement is actually a better choice than the break statement, and keeping in mind that the break statement is really just a goto will help you realize when this is true.  While our search has been improved a lot, the if test after leaving the loop is technically redundant \endash  after all, we knew in the loop whether the value we were looking for had been found.  By making use of this information when it is available, we can avoid the if statement altogether:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {ptr = names;\par while (ptr != NULL) \{\par    if (strcmp(ptr->name, name)\par       == 0) \{\par       printf("true: \\"%s\\"\\n",\par          name);\par       goto out;\par       \}\par    ptr = ptr->next;\par    \}\par printf("false\\n");\par }\pard \s23\qj\fi360\widctlpar\adjustright {out:\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Whether or not you use a goto statement in a situation like this is really a matter of taste.  In general, I would not use a goto statement here; I would use the second form of the loop, with the break statement to exit early.  The if check is not very time consuming, and it is a little easier to follow what is going on.  If the loop appeared inside another loop, or in some other very time-critical place in the program, though, I would certainly take that into account, and might pick the goto statement to save every bit of time I could.\par Here's a complete sample program, shown in listing 10.2, that uses the goto statement to exit a loop early.  It reads a list of names, stopping when you enter a blank string.  You can then ask if a name is in the list.  The program stops if you enter the string "-".\par The goto to exit the loop is exactly what we were showing with the small code fragments.  There is nothing new there, but you do get a chance to see the idea in a complete program.\par \par \par }{\b \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b \par }\pard \s21\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {\b Listing 10.2\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright \f6\fs20\cgrid {/* This program reads a list of names from the keyboard,         */\par /* stopping when you enter the string -.  These names are stored */\par /* in the linked list names.  The program then asks you to enter */\par /* a name, and scans the list.  If the name is in the list, the  */\par /* program prints the name.  If not, false is printed.  Again,   */\par /* this process repeats until you enter the string -.            */\par \par #include <stdio.h>\par #include <string.h>\par #include <stdlib.h>\par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {\par #define NAMELENGTH 20                   /* max length of a name */\par \par typedef struct nameType \{               /* element of the name list */\par    struct nameType *next;\par    char name[NAMELENGTH+1];\par    \}\par    nameType,\par    *namePtr;                            /* name pointer type */\par \par namePtr names;                          /* list of names */\par \par \par /* Read a list of names from the keyboard */\par \par void ReadList (void)\par \par \{\par namePtr ptr;                            /* new name */\par char name[NAMELENGTH+1];                /* name read from keyboard */\par \par names = NULL;                           /* no names so far */\par \par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {do \{\par    printf("Name:");                     /* get a name */\par    scanf("%20s", name);\par    if (strcmp(name, "-") != 0) \{\par       ptr = (namePtr) malloc(sizeof(nameType));/* get a new name record */\par       ptr->next = names;                /* add the record to the list */\par       names = ptr;\par       strcpy(ptr->name, name);          /* put the name in the record */\par       \}\par    \}\par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {while (strcmp(name, "-") != 0);\par \}\par \par \par /* Test to see if names are in the list */\par \par void Test (void)\par \par \{\par namePtr ptr;                            /* used to trace the list */\par char name[NAMELENGTH+1];                /* name read from keyboard */\par \par do \{\par    printf("Name to find:");             /* get a name */\par    scanf("%20s", name);\par    if (strcmp(name, "-") == 0)          /* quit if no name is given */\par       return;\par    ptr = names;                         /* scan for the name */\par    while (ptr != NULL) \{\par       if (strcmp(ptr->name, name) == 0) /* name found -> write it */\par          \{\par          printf("true: \\"%s\\"\\n", name);\par          goto out;\par          \}\par       ptr = ptr->next;\par       \}\par    printf("false\\n");                   /* name not found */\par    out: ;\par    \}\par while (1);                              /* loop forever */\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {/* Main program */\par \par void main (void)\par \par \{\par ReadList();\par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {printf("\\n");\par Test();\par \}\par }\pard\plain \qj\fi360\widctlpar\adjustright \f4\cgrid {\par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s24\qj\fi-360\li360\keepn\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 10.13.  }{In the text, I said that the loop\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {ptr = names;\par found = NULL;\par while (ptr != NULL) \{\par    if (strcmp(ptr->name, name)\par       == 0)\par       found = ptr;\par    ptr = ptr->next;\par    \}\par if (found == NULL)\par    printf("false\\n");\par else\par    printf("true: \\"%s\\"\\n",\par }\pard \s23\qj\fi360\widctlpar\adjustright {      name);\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {looped all the way through the list each time.  That's fairly easy to see.  Computer scientists would say that the algorithm has a run-time of order n, where n is the length of the list.  They write this as a big O, meaning order, then the order in parenthesis, like this:  O(n).\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {I also said that the search with a break statement,\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {ptr = names;\par while (ptr != NULL) \{\par    if (strcmp(ptr->name, name)\par       == 0)\par       break;\par    ptr = ptr->next;\par    \}\par if (ptr == NULL)\par    printf("false\\n");\par else\par    printf("true: \\"%s\\"\\n",\par       name);\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {only had to scan half of the list, on average.  Computer scientists would say that this algorithm has a typical run-time of order n/2, written O(n/2).\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {The reason computer scientists invented this strange way of talking is that you can see at a glance that the second version of the search works twice as fast as the first.  Or does it?  If you have a knack for mathematics, you might want to try to prove it.  While we technically won't prove it, in this problem you will write a program that will demonstrate the idea with a simulation.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Your program should be based on the sample program from the text.  Start by replacing ReadList with a function that builds a list of characters, one for each letter in the alphabet.  To do this, you will need to change the nameType struct so it has a character, rather than a pointer and a string.  Test your program after doing this to make sure you have everything correct up to this point.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Next, change the Test procedure so that it uses RandomValue to create random characters, instead of asking for a character from the keyboard.  Use a for loop to look for a character COUNT times, where COUNT is a constant defined at the top of the program.  For test purposes, set COUNT to 5.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {The last step in developing the program is to change the Test procedure one last time.  Instead of printing whether or not the name is found, use a counter to see how many compares you have to do before finding the correct element of the list.  This counter should be declared globally, and it will need to be a long integer, rather than a standard integer.  After calling ReadList and Test, the main program should print the average number of searches (the total number of searches divided by COUNT).\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {With the program in place and debugged, change count to 10,000 to get a fair sample size, turn debug off so you won't have to wait all day, and run your simulation.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Theoretically, the average number of compares per search should be 13.5.  How close were you?\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344554}The break Statement in Nested Loops{\*\bkmkend _Toc496344554}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {As we said in the last section, the break statement can be used to exit a while loop, do loop, for loop, or case statement.  What happens, though, when you break from a loop that is imbedded inside of another loop?  To find out, let's try breaking from the inside of a for loop nested within another for loop:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par int i,j;\par \par for (i = 1; i <= 10; ++i) \{\par    for (j = 1; j <= 10; ++j) \{\par       printf("%3d", i*10+j);\par       if (i == j)\par          break;\par       \}\par    printf(" ---\\n");\par    \}\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The first thing to notice is that the break is actually imbedded in an if statement that is inside of two for loops.  The if statement, of course, has no effect on the way the break statement works.  When you run the program, it prints 11 on the first line, then skips to a new line, where it prints 21 and 22.  Obviously, the break statement itself will leave the inside for loop, but it only exits one of the loops.  In other words, replacing the break statement with a goto statement, it works like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par int i,j;\par \par for (i = 1; i <= 10; ++i) \{\par    for (j = 1; j <= 10; ++j) \{\par       printf("%3d", i*10+j);\par       if (i == j)\par          goto out;\par       \}\par    out: printf(" ---\\n");\par    \}\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344555}To goto or Not to goto{\*\bkmkend _Toc496344555}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The reason we haven't used the goto statement isn't because it is bad, or has no use.  The reason we haven't used the goto statement is because it isn't needed as much in C as it is in languages that do not have if-then-else statements, while loops, do loops, switch statements, break statements, and so on.\par There is one situation that arises occasionally in C where the goto statement is undeniably necessary.  Exiting early from a loop is a tremendous time-saver, as you saw in problem 10.13.  In fact, there are many cases where you can save even more time with a judiciously placed early exit.  On the other hand, you also just saw that a break can only exit one loop \endash  if that loop is imbedded inside of another loop, and you need to get out of both of them, you need to revert to a goto statement.\par I have tried to make the point that there is nothing inherently bad about the goto statement, but if you find yourself using the goto statement very often, you should stop and recall that the bad reputation of the goto statement comes from the fact that it is often overused and improperly used, not from any inherent fault in the statement itself.  If you have a background in BASIC or FORTRAN, you may be especially prone to overusing the goto statement.  To break these bad habits, I would urge you to avoid the goto statement entirely, with the exception of exiting nested loops, for at least six months.  That way, you will be forced to stop and think about how to organize your programs logically around well-organized flow of control, and not jump haphazardly from one place to another.  After your "training" period, you will be able to look back and realize just how rarely you really need to use the goto statement.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344556}The continue Statement{\*\bkmkend _Toc496344556}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {By now, you might be thinking that the C language just goes on and on, and you'll never see the end.  Take heart: you're getting there!  The very last of the executable C statements is the continue statement, a close relative of break.  Like break, the continue statement can be used inside of a do loop, while loop, or for loop, but unlike break, the continue statement cannot be used from inside of a switch statement.  Of course, if the switch statement itself is inside of one of the loops, you can still use continue, just as you were able to use a break statement that was imbedded in an if statement, as long as the if statement was inside of a loop.\par The continue statement is also a form of a goto statement.  Instead of jumping out of the loop, though, the continue statement jumps to the end of the loop, so that the loop keeps going.  As a quick example, let's look at a simple program that uses the continue statement to skip odd integers.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par int i;\par \par for (i = 1; i <= 10; ++i) \{\par    if (i & 1)\par       continue;\par    printf("%d\\n", i);\par    \}\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The way that we detected odd numbers is itself a bit odd, so lets stop and take a quick look at that technique in passing.  Writing a few numbers in both decimal and binary, you can quickly see a pattern emerge:\par \par }\pard \s21\qj\fi360\keepn\widctlpar\tx2160\adjustright {\ul decimal}{\tab }{\ul binary}{\par 1\tab 000001\par 2\tab 000010\par 3\tab 000011\par 4\tab 000100\par 5\tab 000101\par 6\tab 000110\par 7\tab 000111\par 8\tab 001000\par 9\tab 001001\par }\pard \s21\qj\fi360\widctlpar\tx2160\adjustright {10\tab 001010\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par As you can see, all of the odd values have a rightmost bit of one.  Thinking about how binary numbers are formed, this makes sense: after all, the rightmost column is the one's column.  To detect odd numbers, then, we need to see when the rightmost bit is 1.  We can do that using the & operator, which you saw earlier.  Anding a number with 1 will zero any bits except the 1 bit.  If the number is odd, the result will be 1, and for even numbers, we will end up with 0.  Since 0 is used as false in C, and anything else is true, the statement "if (i & 1) ..." will execute the continue statement for odd numbers, skipping it for even numbers.\par Getting back to the continue statement itself, you probably already see how it works, but here's the same program with a goto statement, so you can see what is happening a bit easier:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par int i;\par \par for (i = 1; i <= 10; ++i) \{\par    if (i & 1)\par       goto loop;\par    printf("%d\\n", i);\par    loop: ;\par    \}\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The loop label would always appear right before the \} character that closes the loop.\par As with the break statement, if two loops are imbedded inside of each other, the continue statement applies to the innermost loop.\par \par }\pard\plain \qc\widctlpar\adjustright \f4\cgrid {\b\fs36 \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \qc\nowidctlpar\adjustright \f4\cgrid {\b\fs36 Lesson Ten\par }\pard \qc\widctlpar\adjustright {\b\fs36 Solutions to Problems\par }\pard \qj\widctlpar\adjustright {\b\fs28 \par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344557}Solution to problem 10.1.{\*\bkmkend _Toc496344557}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Simple base conversion program.  Enter a number */\par /* in decimal (no leading 0), octal (leading       */\par /* zero), or hexadecimal (leading 0x), and the     */\par /* program will echo the value back in all three   */\par /* bases.  Enter 0 in any base to quit.            */\par \par #include <stdio.h>\par \par void main(void)\par \par \{\par long val;\par \par do \{\par    printf("\\nValue: ");                   /* write the prompt */\par    val = 0L;                            /* default (in case of error) */\par    scanf("%li", &val);                  /* read the value */\par    printf("Decimal    : %ld\\n", val);   /* print the value */\par    printf("Octal      : 0%lo\\n", val);\par    printf("Hexadecimal: 0x%lX\\n", val);\par    \}\par while (val);\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344558}Solution to problem 10.2.{\*\bkmkend _Toc496344558}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The 0 in the conversion specifier %04X tells printf to use leading zeros to fill out the number if there aren't enough digits to fill the entire field width.  The 4 is the field width.  So, for example, if the value to print is 0x12, printf will print "0012".  With a conversion specifier of %0X, printf would not need to fill out the field width, so it would print "12", while with a conversion specifier of %4X, printf would print "  12".\par Normally, when a number follows the % character, it is used as a field width, so you might think the 0 would become part of the field width.  The reason there is no confusion is because the leading zero is not used for anything anyway, so removing it does not effect the field width.  Of course, a field width of 0 doesn't make sense, so there is never a need to use just a 0 for the field width.\par \par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344559}Solution to problem 10.3.{\*\bkmkend _Toc496344559}\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* Print a hex-binary-decimal conversion table. */\par \par #include <stdio.h>\par \par /* Print an integer as a 16 digit binary number         */\par }\pard \s23\qj\fi360\widctlpar\adjustright {/*                                                      */\par /* Parameters:                                          */\par /*    val - value to print                              */\par \par void PrintBin (int val)\par \par \{\par if (val & 0x8000)\par    printf("1");\par else\par    printf("0");\par if (val & 0x4000)\par    printf("1");\par else\par    printf("0");\par if (val & 0x2000)\par    printf("1");\par else\par    printf("0");\par if (val & 0x1000)\par    printf("1");\par else\par    printf("0");\par if (val & 0x0800)\par    printf("1");\par else\par    printf("0");\par if (val & 0x0400)\par    printf("1");\par else\par    printf("0");\par if (val & 0x0200)\par    printf("1");\par else\par    printf("0");\par if (val & 0x0100)\par    printf("1");\par else\par    printf("0");\par if (val & 0x0080)\par    printf("1");\par else\par    printf("0");\par if (val & 0x0040)\par    printf("1");\par else\par    printf("0");\par if (val & 0x0020)\par    printf("1");\par else\par    printf("0");\par if (val & 0x0010)\par    printf("1");\par else\par    printf("0");\par if (val & 0x0008)\par    printf("1");\par else\par    printf("0");\par if (val & 0x0004)\par    printf("1");\par else\par    printf("0");\par if (val & 0x0002)\par    printf("1");\par else\par    printf("0");\par if (val & 0x0001)\par    printf("1");\par else\par    printf("0");\par \}\par \par \par /* Main program                                         */\par \par void main(void)\par \par \{\par int i;                                  /* loop variable */\par \par printf("dec hex binary\\n");             /* print the header */\par printf("--- --- ------\\n");\par for (i = 0; i < 16; ++i) \{              /* print the values */\par    printf("%3d 0x%X ", i, i);\par    PrintBin(i);\par    printf("\\n");\par    \}\par \} \par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344560}Solution to problem 10.4.{\*\bkmkend _Toc496344560}\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* Print a hex-binary-decimal conversion table. */\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par #include <stdio.h>\par \par /* Test a number to see if it is negative               */\par /*                                                      */\par /* Parameters:                                          */\par /*    val - number to test                              */\par \par int IsNegative (int val)\par \par \{\par return val & 0x8000;\par \}\par \par \par /* Main program                                         */\par \par void main(void)\par \par \{\par if (IsNegative(1))\par    printf("1 is negative.\\n");\par else\par    printf("1 is positive.\\n");\par if (IsNegative(0))\par    printf("0 is negative.\\n");\par else\par    printf("0 is positive.\\n");\par if (IsNegative(-1))\par    printf("-1 is negative.\\n");\par else\par    printf("-1 is positive.\\n");\par if (IsNegative(-32767))\par    printf("-32767 is negative.\\n");\par else\par    printf("-32767 is positive.\\n");\par if (IsNegative(32767))\par    printf("32767 is negative.\\n");\par else\par    printf("32767 is positive.\\n");\par \}}{\b\fs28 \par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344561}Solution to problem 10.5.{\*\bkmkend _Toc496344561}\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par \{\par int a,b;\par \par a = 0x3C3C;\par b = 0xAAAA;\par printf("%04X & %04X = %04X\\n", a, b, a&b);\par printf("%04X | %04X = %04X\\n", a, b, a|b);\par \} \par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344562}Solution to problem 10.6.{\*\bkmkend _Toc496344562}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* My own tolower function. */\par \par #include <stdio.h>\par \par \par /* Return the lowercase equivalent of the input.                */\par /*                                                              */\par /* Parameters:                                                  */\par /*    ch - character to convert                                 */\par /*                                                              */\par /* Returns: Lowercase equivalent of ch                          */\par \par char lower (char ch)\par \par \{\par if ((ch >= 'A') && (ch <= 'Z'))\par    ch = ch | 0x0020;\par return ch;\par \}\par \par \par /* Main program. */\par \par void main(void)\par \par \{\par printf("The lowercase equivalent of %c is %c.\\n", 'A', lower('A'));\par printf("The lowercase equivalent of %c is %c.\\n", 'a', lower('a'));\par printf("The lowercase equivalent of %c is %c.\\n", 'U', lower('U'));\par printf("The lowercase equivalent of %c is %c.\\n", '4', lower('4'));\par printf("The lowercase equivalent of %c is %c.\\n", '\{', lower('\{'));\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344563}Solution to problem 10.7.{\*\bkmkend _Toc496344563}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Read two integers, then write the exclusive or of    */\par /* the integers.                                        */\par \par #include <stdio.h>\par \par void main(void)\par \par \{\par int a,b;\par \par printf("First value: ");\par scanf("%i", &a);\par printf("Second value: ");\par scanf("%i", &b);\par printf("0x%04X ^ 0x%04X = 0x%04X\\n", a, b, a^b);\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The first time you run the program, the inputs are 0x1234 and 0xFFFF.  Expressing these values as binary numbers, you get 0001001000110100 for 0x1234, and 1111111111111111 for 0xFFFF.  Exclusive oring these two numbers reverses all of the bits in the first value, since all of the bits in the second value are set.  The result is 0xEDCB, which, in binary, is 1110110111001011.  Doing the operation again with the result of the first run and 0xFFFF, you reverse the same bits back to their original values, so the result is 0x1234.  If you run the program with 0xEDCB and 0x1234, the result will be 0xFFFF.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344564}Solution to problem 10.8.{\*\bkmkend _Toc496344564}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Encrypt or decrypt a text file.                      */\par \par #include <stdio.h>\par #include <stdlib.h>\par \par #define BUFFSIZE 64                     /* size of the character buffer */\par \par int main(void)\par \par \{\par char ch[BUFFSIZE];                      /* character from the file */\par int numCh;                              /* # of characters read */\par int i;                                  /* loop variable */\par char name[81];                          /* file name */\par int password;                           /* password value */\par FILE *inFile, *outFile;                 /* file variables */\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {printf("File to encrypt: ");            /* open the input file */\par scanf("%80s", name);\par inFile = fopen(name, "r");\par if (inFile == NULL) \{\par }\pard \s23\qj\fi360\widctlpar\adjustright {   fprintf(stderr, "Could not open %s.\\n", name);\par    return -1;\par    \}\par printf("Output file    : ");            /* open the output file */\par scanf("%80s", name);\par outFile = fopen(name, "w");\par if (outFile == NULL) \{\par    fprintf(stderr, "Could not open %s.\\n", name);\par    fclose(inFile);\par    return -1;\par    \}\par printf("Password       : ");            /* get the password */\par scanf("%d", &password);\par srand(password);                        /* use it to set up rand() */\par \par do \{                                    /* encrypt/decrypt the file */\par    numCh = fread(ch, sizeof(char), BUFFSIZE, inFile);\par    if (numCh > 0) \{\par       for (i = 0; i < numCh; ++i)\par          ch[i] = ch[i] ^ rand();\par       fwrite(ch, sizeof(char), numCh, outFile);\par       \}\par    else\par       break;\par    \}\par while (1);\par \par fclose(inFile);                         /* close the files */\par fclose(outFile);\par return 0;\par \}}{\b\fs28 \par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344565}Solution to problem 10.9.{\*\bkmkend _Toc496344565}\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* Invert the graphics screen */\par \par void InvertScreen(void)\par \par /* Invert all of the bits on the graphics screen */\par \par \{\par int *ptr;                               /* graphics screen pointer */\par int count;                              /* loop counter */\par \par ptr = (int *) 0xE12000;\par for (count = 0; count < 16000; ++count) \{\par }\pard \s23\qj\fi360\widctlpar\adjustright {   *ptr = ~*ptr;\par    ++ptr;\par    \}\par \}\par \par void main(void)\par \par \{\par int loop;\par \par InvertScreen();\par for (loop = 1; loop <= 100; ++loop)\par    ;\par InvertScreen();\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344566}Solution to problem 10.10.{\*\bkmkend _Toc496344566}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par printf("Huh\\?\\?\\?\\n");\par printf("C uses \\\\n for the end of a line.\\n");\par printf("I said, \\"Quote me!\\"\\n");\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344567}Solution to problem 10.11.{\*\bkmkend _Toc496344567}\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 #include <stdio.h>\par \par void main(void)\par \par \{\par printf("\\x54\\145\\x073\\X074\\X69\\156\\x067\\54\\0321\\054\\x0202\\x2c\\x20\\x33\\x2e\\n");\par }\pard \s23\qj\fi360\widctlpar\adjustright {\fs18 \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344568}Solution to problem 10.12.{\*\bkmkend _Toc496344568}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par int i;\par \par i = 1;\par top:\par printf ("%d\\n", i);\par ++i;\par if (i <= 10) goto top;\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344569}Solution to problem 10.13.{\*\bkmkend _Toc496344569}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Find the average number of compares needed to find a character */\par /* from a list of characters that make up the alphabet.           */\par \par #include <stdio.h>\par #include <stdlib.h>\par \par #define NAMELENGTH 20                   /* max length of a name */\par #define COUNT 10000                     /* number of tests */\par \par \par typedef struct listType \{               /* element of the list */\par    struct listType *next;\par    char ch;\par    \}\par    listType,\par    *listPtr;                            /* list pointer type */\par \par long compares;                          /* # of compares done */\par listPtr list;                           /* ptr to the first element */\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {/* Build a list of characters */\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par void BuildList (void)\par \par \{\par listPtr ptr;                            /* new list element */\par char ch;                                /* character for the list */\par \par list = NULL;                            /* no elements so far */\par \par for (ch = 'a'; ch <= 'z'; ++ch) \{\par    ptr = (listPtr) malloc(sizeof(listType)); /* get a new list record */\par    ptr->next = list;                    /* add the record to the list */\par    list = ptr;\par    ptr->ch = ch;                        /* put the char in the struct */\par    \}\par \}\par \par \par /* Check the list */\par \par void Test (void)\par \par \{\par listPtr ptr;                            /* used to trace the list */\par char ch;                                /* character to test for */\par int i;                                  /* loop counter */\par \par srand(23456);                           /* initialize rand() */\par for (i = 0; i < COUNT; ++i) \{\par    ch = (rand() %26) + 'a';             /* create a character */\par    ptr = list;                          /* scan for the character */\par    while (ptr != NULL) \{\par       ++compares;                       /* update the # of compares */\par       if (ptr->ch == ch)                /* found -> exit loop */\par          break;\par       ptr = ptr->next;\par       \}\par    \}\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {/* Main program */\par \par void main (void)\par \par \{\par compares = 0;\par BuildList();\par Test();\par printf("The average # of compares was %.2f.\\n", ((float)compares)/COUNT);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par \par }\pard\plain \widctlpar\adjustright \f4\cgrid {\sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s1\qc\nowidctlpar\outlinelevel0\adjustright \b\f4\fs36\cgrid {{\*\bkmkstart _Toc496344570}Lesson Eleven{\*\bkmkend _Toc496344570}\par {\*\bkmkstart _Toc496344571}More Miscellaneous Useful Stuff{\*\bkmkend _Toc496344571}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344572}Unions{\*\bkmkend _Toc496344572}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Unions are a rather peculiar data type that is used to overlay two different variables, causing them to use the same memory.  There are some good reasons to do this, and we will get to those gradually, but we'll start off by exploring how you create unions, and exactly what they do, with a simple example.\par Type in this program and run it.  We'll talk about what it does in a moment.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par union int_float \{\par    int i;\par    float f;\par    \} u;\par \par u.i = 4;\par printf("u.i = %d\\n", u.i);\par u.f = 1.2;\par printf("u.f = %f\\n", u.f);\par printf("u.i = %d\\n", u.i);\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par As you can see, a union looks a lot like a struct.  In fact, all of the rules you have learned so far that apply to structures also apply to unions.  You define union types the same way that you define struct types; you get at variables inside of a union with the . operator, just like you do with a struct; and you use the -> operator to access variables imbedded in a pointer to a union, again, just as you do with structures.  In fact, if you replace the union in this program with struct, it will do exactly what you expect it to: print 4 for u.i, then print 1.2 for u.f and print the value of u.i a second time.\par Of course, when you run this program as is, it does something different.  The first time u.i is printed, you get 4, just as you expect.  When u.f is printed, you also get 1.2, just as you expect.  In a union, though, variables overlay each other, using the same memory.  In this program, when we store a value in u.f, we wipe out the value in u.i, so the second time this program prints u.i, the value is changed.\par One reason for using unions is to save space.  In a struct that has an int variable and a float variable, each struct needs six bytes (two for the int and four for the float).  In this union, the union variable u only uses four bytes: the size of the union is the same as the size of the largest variable.  By cleverly combining unions and structures, you can create programs that use a lot less space than programs that only use structures.\par Listing 11.1 shows one use of unions.  In this example, we create and then animate 10 shapes.  The shapes can be squares, triangles, or stars.  Each of the shapes does a random walk across the screen, moving one pixel in a random direction on each cycle through the program.\par To animate the shapes, we need to keep track of what kind of a shape it is, and the coordinates for the shape.  Since each shape has a different number of points, we use a union to overlay various structures.  The variable kind is used to keep track of what sort of information is in the union.  Each of the shapes has a color, so, rather than put the color in the union and recreating it several times, we put the union inside of a struct.  This is a very common technique for mixing information that is consistent across several different kinds of things with information that varies from entry to entry.\par Animation is pretty slow with debug code on, so once you get the program to work, try it with debug off.\par \par }{\b \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b \par }\pard \s21\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {\b Listing 11.1\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright \f6\fs20\cgrid {/* Do a random walk with 10 random shapes */\par \par #include <stdlib.h>\par \par #include <quickdraw.h>\par \par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {#define NUMSHAPES 10                    /* # of shapes to animate */\par #define WALKLENGTH 100                  /* # of "steps" in the walk */\par \par #define MAXX 316                        /* size of the graphics screen */\par #define MAXY 83\par \par typedef enum shapeKind \{triangle, square, star\} shapeKind;\par \par typedef struct shapeType \{              /* information about one shape */\par    int color;                           /* color */\par    shapeKind kind;                      /* kind of shape */\par    union \{\par       struct \{                          /* points for a triangle */\par          int x1,x2,x3,y1,y2,y3;\par          \} t;\par       struct \{                          /* points for a square */\par          int x1,x2,x3,x4,y1,y2,y3,y4;\par          \} s;\par       struct \{                          /* points for a star */\par          int x1,x2,x3,x4,x5;\par          int y1,y2,y3,y4,y5;\par          \} p;\par       \} coord;\par    \} shapeType;\par \par \par shapeType shapes[NUMSHAPES];            /* current array of shapes */\par shapeType oldShapes[NUMSHAPES];         /* shapes in last position */\par \par \par void InitGraphics (void)\par \par /* Standard graphics initialization.                            */\par \par \{\par SetPenMode(2);                          /* pen mode = xor */\par SetPenSize(3,1);                        /* use a square pen */\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {void DrawShape (shapeType s)\par \par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {/* This subroutine draws one of the shapes on the screen.       */\par /*                                                              */\par /* Parameters:                                                  */\par /*    s - shape to draw                                         */\par \par \{\par SetSolidPenPat(s.color);             /* set the pen color for the shape */\par \par switch (s.kind) \{\par \par    case triangle:                       /* draw a triangle */\par       MoveTo(s.coord.t.x1, s.coord.t.y1);\par       LineTo(s.coord.t.x2, s.coord.t.y2);\par       LineTo(s.coord.t.x3, s.coord.t.y3);\par       LineTo(s.coord.t.x1, s.coord.t.y1);\par       return;\par \par    case square:                         /* draw a square */\par       MoveTo(s.coord.s.x1, s.coord.s.y1);\par       LineTo(s.coord.s.x2, s.coord.s.y2);\par       LineTo(s.coord.s.x4, s.coord.s.y4);\par       LineTo(s.coord.s.x3, s.coord.s.y3);\par       LineTo(s.coord.s.x1, s.coord.s.y1);\par       return;\par \par    case star:                           /* draw a star */\par       MoveTo(s.coord.p.x1, s.coord.p.y1);\par       LineTo(s.coord.p.x2, s.coord.p.y2);\par       LineTo(s.coord.p.x3, s.coord.p.y3);\par       LineTo(s.coord.p.x4, s.coord.p.y4);\par       LineTo(s.coord.p.x5, s.coord.p.y5);\par       LineTo(s.coord.p.x1, s.coord.p.y1);\par       return;\par    \}\par \}\par \par \par void CreateShape (shapeType *s)\par \par /* This subroutine creates a shape.  The color and initial      */\par /* position of the shape are chosen randomly.  The size of the  */\par /* shape is based on pre-computed values.                       */\par /*                                                              */\par /* Parameters:                                                  */\par /*    s - shape to create                                       */\par \par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {\{\par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {int cx,cy;                              /* center point for the shape */\par \par s->color = rand() % 3 + 1;              /* get a color */\par cx = rand() % (MAXX - 38) + 19;         /* get the center position,   */\par cy = rand() % (MAXY - 16) + 8;          /* picking the points so the  */\par                                         /* shape is in the window     */\par \par switch (rand() % 3) \{                   /* set the initial positions */\par    case 0:                              /* set up a triangle */\par       s->kind = triangle;\par       s->coord.t.x1 = cx-19;\par       s->coord.t.y1 = cy+4;\par       s->coord.t.x2 = cx;\par       s->coord.t.y2 = cy-8;\par       s->coord.t.x3 = cx+19;\par       s->coord.t.y3 = cy+4;\par       return;\par \par    case 1:                              /* set up a square */\par       s->kind = square;\par       s->coord.s.x1 = cx-15;\par       s->coord.s.y1 = cy-6;\par       s->coord.s.x2 = cx+15;\par       s->coord.s.y2 = cy-6;\par       s->coord.s.x3 = cx-15;\par       s->coord.s.y3 = cy+6;\par       s->coord.s.x4 = cx+15;\par       s->coord.s.y4 = cy+6;\par       return;\par \par    case 2:                              /* set up a star */\par       s->kind = star;\par       s->coord.p.x1 = cx-13;\par       s->coord.p.y1 = cy+7;\par       s->coord.p.x2 = cx;\par       s->coord.p.y2 = cy-8;\par       s->coord.p.x3 = cx+13;\par       s->coord.p.y3 = cy+7;\par       s->coord.p.x4 = cx-21;\par       s->coord.p.y4 = cy-3;\par       s->coord.p.x5 = cx+21;\par       s->coord.p.y5 = cy-3;\par       return;\par    \}\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {void UpdateShape (shapeType *s)\par \par /* This subroutine moves a shape across the screen in a random  */\par /* walk.                                                        */\par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {/*                                                              */\par /* Parameters:                                                  */\par /*    s - shape to update                                       */\par \par \{\par int dx,dy;                              /* movement direction */\par \par dx = rand() % 3 - 1;                    /* get the walk direction */\par dy = rand() % 3 - 1;\par \par switch (s->kind) \{                    /* make sure we don't walk off of */\par                                       /* the screen, then update the    */\par                                       /* position                       */\par    case triangle:                       /* check a triangle */\par       if (dx == -1)\par          if (s->coord.t.x1 < 1)\par             dx = 0;\par       if (dx == 1)\par          if (s->coord.t.x3 >= MAXX)\par             dx = 0;\par       if (dy == -1)\par          if (s->coord.t.y2 < 1)\par             dy = 0;\par       if (dy == 1)\par          if (s->coord.t.y3 >= MAXY)\par             dy = 0;\par       s->coord.t.x1 = s->coord.t.x1+dx; /* update a triangle */\par       s->coord.t.y1 = s->coord.t.y1+dy;\par       s->coord.t.x2 = s->coord.t.x2+dx;\par       s->coord.t.y2 = s->coord.t.y2+dy;\par       s->coord.t.x3 = s->coord.t.x3+dx;\par       s->coord.t.y3 = s->coord.t.y3+dy;\par       return;\par \par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {   case square:                         /* check a square */\par       if (dx == -1)\par          if (s->coord.s.x1 < 1)\par             dx = 0;\par       if (dx == 1)\par          if (s->coord.s.x2 >= MAXX)\par             dx = 0;\par       if (dy == -1)\par          if (s->coord.s.y1 < 1)\par             dy = 0;\par       if (dy == 1)\par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {         if (s->coord.s.y3 >= MAXY)\par             dy = 0;\par       s->coord.s.x1 = s->coord.s.x1+dx; /* update a square */\par       s->coord.s.y1 = s->coord.s.y1+dy;\par       s->coord.s.x2 = s->coord.s.x2+dx;\par       s->coord.s.y2 = s->coord.s.y2+dy;\par       s->coord.s.x3 = s->coord.s.x3+dx;\par       s->coord.s.y3 = s->coord.s.y3+dy;\par       s->coord.s.x4 = s->coord.s.x4+dx;\par       s->coord.s.y4 = s->coord.s.y4+dy;\par       return;\par \par    case star:                           /* check a star */\par       if (dx == -1)\par          if (s->coord.p.x4 < 1)\par             dx = 0;\par       if (dx == 1)\par          if (s->coord.p.x5 >= MAXX)\par             dx = 0;\par       if (dy == -1)\par          if (s->coord.p.y2 < 1)\par             dy = 0;\par       if (dy == 1)\par          if (s->coord.p.y1 >= MAXY)\par             dy = 0;\par       s->coord.p.x1 = s->coord.p.x1+dx; /* update a star */\par       s->coord.p.y1 = s->coord.p.y1+dy;\par       s->coord.p.x2 = s->coord.p.x2+dx;\par       s->coord.p.y2 = s->coord.p.y2+dy;\par       s->coord.p.x3 = s->coord.p.x3+dx;\par       s->coord.p.y3 = s->coord.p.y3+dy;\par       s->coord.p.x4 = s->coord.p.x4+dx;\par       s->coord.p.y4 = s->coord.p.y4+dy;\par       s->coord.p.x5 = s->coord.p.x5+dx;\par       s->coord.p.y5 = s->coord.p.y5+dy;\par       return;\par    \}\par \}\par \par \par void main(void)\par \par /* main program                                                 */\par \par \{\par int i,j;                                /* loop variables */\par \par InitGraphics();                         /* set up the graphics window */\par srand(6289);                            /* initialize rand() */\par \par for (i = 0; i < NUMSHAPES; ++i) \{ /* set up and draw the initial shapes */\par    CreateShape(&shapes[i]);\par    DrawShape(shapes[i]);\par    \}\par \par for (i = 0; i < WALKLENGTH; ++i) \{      /* do the random walk */\par    for (j = 0; j < NUMSHAPES; ++j) \{    /* move the shapes */\par       oldShapes[j] = shapes[j];\par       UpdateShape(&shapes[j]);\par       \}\par    for (j = 0; j < NUMSHAPES; ++j) \{    /* redraw the shapes */\par       DrawShape(shapes[j]);\par       DrawShape(oldShapes[j]);\par       \}\par    \}\par \}\par }\pard\plain \qj\fi360\widctlpar\adjustright \f4\cgrid {\f6\fs20  }{\par }\pard \qj\widctlpar\adjustright {\sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 11.1.}{  One common use of unions takes advantage of the fact that the variables in the union overlap.  This fact can be used to examine the values of a complicated variable type.  Of course, programs that do this are not portable.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {One thing that happens over and over in the toolbox is to extract the least significant 16 bits from a long integer, or the most significant 16 bits.  You can do this with math operations if you are very careful, but it is much easier and faster to do it with a union.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Define a union that consists of a long integer and a structure containing two integers.  As you know, an integer variable requires two bytes of storage, while a long variable requires four bytes of storage, so the union puts the two integers in the same memory as the long integer, giving you a way to save a long value and then extract the integer parts.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Write a program that reads long integers from the keyboard, looping until a 0 is entered.  Save this value in the union, then write the two integers.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Experiment with this program a bit.  What you should find is that for values up to 32767, the program prints the same value you entered for the least significant integer (the first one), then a zero for the most significant integer (the second one).  As the numbers get larger, you start to fill in the sign bit, so the first integer is written as a negative number.  Finally, when the numbers exceed 65535, values start to show up in the second integer.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344573}Separate Compilation{\*\bkmkend _Toc496344573}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The programs you are writing in this course are small compared to some of the programs that people regularly write in C.  In programs that are several thousand lines long, organizing the program so you can find things and keep one part of the program from interfering with another part becomes a very serious problem.  In C, the most popular way to organize these large programs is to break them up into smaller pieces.  Each of the pieces is responsible for a particular function or small group of functions within the program.\par To see how this might be done, take a look at the PRIZM desktop development system you are using.  PRIZM is a large program, and, in fact, it is broken up into several parts.  The part of the system that you use most often is the editor.  This is actually separated into two different files.  One of the files is responsible for keeping track of the keys you type and how you use the mouse.  It figures out what you want to do, then calls the second part, which manages the internal buffers that hold text and print this text to the screen.  Yet another part handles the printer, while still another part implements the debugger.  PRIZM actually consists of even more individual pieces than those described here, but you get the idea.\par To see how C handles separate compilation, we will take one of our old programs and split it up into two pieces.  Here's one of the very first programs we wrote that used functions:\par \par }{\b \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b \par }\pard \s21\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {\b Listing 11.2\par \par }\pard\plain \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright \f6\fs20\cgrid {/* Draw three rectangles */\par \par #include <quickdraw.h>\par \par void Rectangle (int left, int right, int top, int bottom, int color)\par \par /* This subroutine draws a colored rectangle and outlines it    */\par /* in black.                                                    */\par /*                                                              */\par /* Parameters:                                                  */\par /*    left,right,top,bottom - edges of the rectangle            */\par /*    color - interior color of the rectangle                   */\par \par \{\par unsigned i;                     /* loop variable */\par \par SetSolidPenPat(color);          /* draw a rectangle */\par for (i = top+1; i <= bottom-1; ++i) \{\par    MoveTo(left,i);\par    LineTo(right,i);\par    \}\par SetSolidPenPat(0);              /* outline it in black */\par MoveTo(left,top);\par LineTo(left,bottom);\par LineTo(right,bottom);\par LineTo(right,top);\par LineTo(left,top);\par \}\par \par \par void InitGraphics(void)\par \par /* Standard graphics initialization.                            */\par \par \{\par SetPenMode(0);               /* pen mode = copy */\par SetSolidPenPat(0);           /* pen color = black */\par SetPenSize(3,1);             /* use a square pen */\par \}\par \par \par void main(void)\par \par \{\par InitGraphics();                 /* set up for graphics */\par Rectangle(10,250,10,60,0);      /* draw a black rectangle */\par Rectangle(220,270,30,50,1);     /* draw a green rectangle */\par Rectangle(50,300,40,80,2);      /* draw a purple rectangle */\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {In a huge program, one of the things we might want to do is separate all of the functions that deal with graphics into a separately compiled module.  There are several advantages to this: the individual files we need to edit are smaller and more manageable; we only need to include quickdraw.h one time, so if we change the part of the program that doesn't use the graphics screen, the compiler won't have to waste time recompiling quickdraw.h; and if the program is moved to another computer that handles graphics differently, all of our graphics routines are in one place, making them easier to find and change.\par Splitting the program into separate files is actually pretty easy in this case.  The function main goes into one source file \-\endash  we'll call it main.cc \endash \~and the rest of the program goes into another source file, which we will call graph.cc.  Compiling the program is a bit harder, though.  To compile this program, we will move to the shell window right away, and use shell commands.  On a really large project, it would pay to learn the shell's scripting language, so you could create a shell program that would create your program in one step, but in this example, we'll do it all by hand.\par There are three steps to creating our program.  The first is to compile graph.cc using the shell's compile command.  The command looks like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {compile main.cc keep=main\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {This command tells the shell to compile the file main.cc, which you just created, and save the output from the compiler in object files that start with the name main.  The C compiler will actually create two files, main.root and main.a.  For the most part, you can ignore the two files, since the name main is the only one you use.\par }\pard \s21\qj\fi360\widctlpar\adjustright {The next step is to compile the second source file, graph.cc, using the command\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {compile graph.cc keep=graph\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par From looking at the shell window as your programs compile, you may already be aware of something called the linker.  The linker is a program that takes the files created by the compiler and combines them with libraries, which contain prewritten functions like printf, to produce the final program.  Now that you are handling all of the steps of creating the program on your own, you must use the shell's link command to get the linker to do its job.  You need to tell the linker the names of the files created by the compiler, using the same name you used when you compiled the file, and give it a name for the executable program, like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {link main graph keep=main\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par You can use the same name for the executable program, as we just did, or use a different one.  The order of the files is important: you need to give the linker the name of the file that has the function main in it first.  The order of any other files is unimportant.\par Now that you have created a program, you can run it by typing the name of the file, main.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 11.2.}{  One of the many advantages of separate compilation is the amount of compile time it can save you.  You know from experience that it takes a long time to compile a program that includes quickdraw.h compared to the time it takes to compile a program that does not use this header file; now you can avoid that time in many cases.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Change the file main.cc so it draws a fourth rectangle with this call:\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {Rectangle(55,305,45,85,1);\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {What commands are needed to create the program?\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344574}Header Files{\*\bkmkend _Toc496344574}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {One of the things the compiler has been doing for you all along is checking to make sure that you call functions correctly.  If you define a function as needing five integer parameters, and then pass two integers, the compiler tells you about your mistake.\par Take a look at the file main.cc from the last section:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {void main(void)\par \par \{\par InitGraphics();\par Rectangle(10,250,10,60,0);\par Rectangle(220,270,30,50,1);\par Rectangle(50,300,40,80,2);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {When the compiler sees this program, it has no way of knowing whether InitGrapics really needs parameters or not, or if Rectangle really needs five integers.  If the program is wrong, the compiler doesn't know it \endash  and your program could crash, corrupt memory, or just not work quite right.\par }\pard \s21\qj\fi360\widctlpar\adjustright {To regain some of the safety we have apparently lost, we need a way to tell the compiler how the functions are declared.  C handles this with something called a function declaration: the first part looks just like the functions you have created all along, but there are no statements.  Instead, the function ends with a semicolon, telling the compiler that nothing else follows.\par Here are the declarations for our graphics.cc module:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {void Rectangle (int left,\par                 int right,\par                 int top,\par                 int bottom,\par                 int color);\par \par void InitGraphics(void);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par You can put these declarations in the file main.cc, and everything would work fine: the compiler would find the declarations and check the function calls, and if you were to make a mistake, the compiler would catch it.  The problem is that in a very large program, several different source files might use the functions defined in graph.cc.  If you change one of the functions, you want to be able to change the function definitions these other files use in one place, not hunt through the files, hoping you find all of the places you need to change.  You might also want a convenient place to find a list of all of the functions in a separately compiled file.\par The traditional way to handle this situation in C is to put the function declarations in a header file.  Also by convention, this file has the same name as the C source file with the .cc removed, and .h added.  For our example, then, you should save the function declarations for Rectangle and InitGraphics in a file called graph.h.  To get access to the header file, you use an include in main.cc, just as you would use an include to get access to the functions in stdio.h.  The only difference is that file names for standard header files like stdio.h are enclosed in brackets, while file names for your own header files are inclosed in parenthesis.\par Putting in the include statement, main.cc looks like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include "graph.h"\par \par void main(void)\par \par \{\par InitGraphics();\par Rectangle(10,250,10,60,0);\par Rectangle(220,270,30,50,1);\par Rectangle(50,300,40,80,2);\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Just to be sure you understand what was just said, stop and try it: make the changes, and run the program.\par As you can see, there is a lot more work involved in creating a program using separate compilation, and you shouldn't do it lightly.  When your programs regularly start to approach 500 lines or so, or when you find yourself constantly reusing the same subroutines in several different programs, it is time to look at separate compilation.  At that point, it would also be a great idea to find a good book on structured programming techniques to learn some of the tricks and ideas that will help you write large programs quickly and accurately.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344575}Storage Classes{\*\bkmkend _Toc496344575}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {One of the things that isn't very obvious from a high-level language like C is that there are a lot of ways to set aside space for a variable.  In a sense, you have already seen two of these: you can allocate a variable, either globally or locally, or you can allocate space for a variable using malloc, and keep track of the variable with a pointer.  It turns out that in most implementations of C, and ORCA/C is no exception, local variables are also allocated a different way than global variables.  The reason for this won't become obvious until a little later, when we study recursion, but the practical implication is something you already know about.  To see how this effects us, let's try a short sample program.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void test1 (int i)\par \par \{\par int j;\par \par if (i)\par    j = i;\par printf("In test1, i = %d, "\par    "j = %d\\n", i, j);\par \}\par \par \par void test2 (int i)\par \par \{\par int j;\par \par if (i)\par    j = i;\par printf("in test2, i = %d, "\par    "j = %d\\n", i, j);\par \}\par \par \par void main(void)\par \par \{\par test1(2);\par test2(3);\par test1(0);\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Let's start by tracing through this program by hand to see what it }{\i looks}{ like it will do.  On the first call to test1, i will be non-zero, so j will be set to 2 (which is the value of i), and the program will print\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {In test1, i = 2, j = 2\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par On the call to test2, pretty much the same thing happens.  This time, the program prints\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {In test2, i = 3, j = 3\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par On the second call to test1, the parameter i is set to 0, so the if condition is false, and j dose not get assigned a value.  You might expect, then, that the program would print\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {In test1, i = 0, j = 2\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par In fact, the value printed for j turns out to be something entirely different!  To say the least, this is a bit weird.  The reason all of this happens is that space for local variables is allocated when the function is called, not when the program is compiled.  There are a number of advantages to this, most of which make a lot more sense to compiler writers than to beginning programmers, but the effect is that the value of j in test1 gets stomped on when test2 runs.  The second time test1 was called, the local variable j wasn't set at all, so the value printed was whatever happened to have been left in memory by the previous operations.\par In C, variables that are allocated off of the stack like this are called auto variables; auto is called the storage class of the variable.  In fact, you could define the function test1 like this, telling the compiler the storage class explicitly:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {void test1 (int i)\par \par \{\par auto int j;\par \par if (i)\par    j = i;\par printf("in test2, i = %d, "\par    "j = %d\\n", i, j);\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {The program will do the same thing, but it takes more typing, and most C programmers don't put the auto in, anyway.  The idea of specifying the storage class is important, though, since there is another storage class that you can use, called static.  When you use the static storage class on a local variable, you tell the compiler that you don't want the variable to come from the stack.  In this case, the compiler actually reserves space in your program for the variable, just like it does for global variables.  The net effect is that the program remembers the values of the variables between function calls, and keeps the various variable values straight.  Going back and changing the variables to static, our test program looks like this:\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void test1 (int i)\par \par \{\par static int j;\par \par if (i)\par    j = i;\par printf("In test1, i = %d, "\par    "j = %d\\n", i, j);\par \}\par \par \par void test2 (int i)\par \par \{\par static int j;\par \par if (i)\par    j = i;\par printf("in test2, i = %d, "\par    "j = %d\\n", i, j);\par \}\par \par \par void main(void)\par \par \{\par test1(2);\par test2(3);\par test1(0);\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {When you run this program, you get the results you probably expected originally.\par }\pard \s21\qj\fi360\widctlpar\adjustright {There is another advantage to static variables that isn't very obvious.  Auto variables are allocated off of the run-time stack, which has a default size of 8192 bytes.  Due to the way the 65816 (the 65816 is the CPU used in the Apple IIGS) and the Apple IIGS are designed, the largest that you can make the stack is about 32768 bytes long.  In other words, if you create a large array as a local variable, you could fill up all of this memory.  When you do this, your program will crash.  With static variables, the memory doesn't come from the stack, and you can fill up all of your memory before you would run out of space.  On the off chance that you did run out of space with a static variable, you would get an error message from the loader, too, instead of just seeing your program crash.  While it probably isn't necessary to worry about stack space for your local scalar variables, if you are declaring large local arrays, you should keep this in mind.\par There is another storage class that you can use with local variables, called register.  Register variables are a special case of the storage class auto.  The register storage class is a hint to the compiler that the variable will be used very frequently, so it should handle the variable as efficiently as possible.  Telling the compiler that all of the variables are register variables is self-defeating.  In addition, the ORCA/C compiler (and many other compilers, too) doesn't do anything with the register storage class, anyway.  Finally, on computers where the register storage class would make a difference, a good compiler will do a better job of figuring out how to handle variables than you can.  In short, unless you are sure you are working on a machine where register variables make a difference, and you are also sure that the compiler you are using is stupid enough not to do the sensible thing on its own, there is no point in using the register storage class.\par Global variables can have a storage class specifier, too, but you can't use auto or register with global variables.  With global variables, you can specify a storage class of extern or static.  Just to keep things interesting, the C language says that the default storage class for a global variable is extern, but that there is a slight difference between actually saying that a global variable is extern, and just leaving the storage class specifier off altogether.\par Before going much further, let's stop and look at why there are different storage class specifiers for global variables at all.  The reason is tied up in the fact that C supports separate compilation, which you saw in the last section.  It is possible for one of the separately compiled files to use a variable in another file, but that presents two problems.  The first is that C insists that you define a variable before using it.  If you define the global variable\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {int i;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {in two separate files, you will actually get a link error: the linker, finding two occurrences of the same global variable, will give you a duplicate label error.  In other words, this declaration really did two things: it told the compiler that the integer variable i exists in the program, and it also told the compiler to set aside space for the variable.  Adding the extern storage class, like this:\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {extern int i;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {tells the compiler something a little different.  In this case, you are still telling the compiler that the integer variable i exists in the program, but you are also telling the compiler that some other source file will reserve space for the variable, so the compiler doesn't need to do it.\par }\pard \s21\qj\fi360\widctlpar\adjustright {Of course, there is another reasonable way to want to handle this situation: it could very well be that you want to have a global variable in both source files called i, but they have nothing to do with one another.  In this case, you want to }{\i hide}{ your global variable from other source files.  That's what the static storage class does.  When you define a global variable with a static storage class, like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {static int i;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {the variable works just like you are used to in the source file where it appears, but it is invisible to all other source files.  The other source files can define a global variable of the same name with no conflict at all.\par }\pard \s21\qj\fi360\widctlpar\adjustright {Incidentally, functions also have a storage class.  In the case of a function, the default storage class is extern, which tells the linker that other source files can use the function.  As with variables, a storage class of static tells the linker that the function is private to the source file it appears in, and that other source files should not be aware that the function exists.  With functions, though, there is no difference between the default storage class of extern and specifying extern explicitly, since the compiler has other ways of telling if you are defining the function: it looks to see if there are any statements to compile!\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 11.3.}{  In this problem, you will experiment with the static and extern storage classes a bit in a separately compiled program.  The point of this problem is to play with storage classes in a very short program, though, so we'll just be writing a short program that doesn't do anything really useful.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {This program will consist of three source files, which we will refer to as main.cc, a.cc, and b.cc.  In main.cc, create the function main, and have it call a function called loop with two integer variables, 1 and 10, then call doit, like this:\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {void main(void)\par \par \{\par loop(1,10);\par doit();\par \}\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {In the source file a.cc, define two global variables, start and stop.  These should have the default storage class, and be defined as int variables.  Also, define a function called loop which also has the default storage class.  This is the function that you called from main.cc; it should set the variable start to the value of its first parameter, and the variable end to the value of the second parameter.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Define the function doit in the source file b.cc.  This function must also have the default storage class of extern, since it is called from main.cc.  The function doit has a single call to another function called loop.  This is a different function from the one that appears in the file a.cc.  This loop function is only called from doit, and should not conflict with the function in the source file a.cc, so this function must be static.  The function should loop from start to stop, printing the integers, like this:\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {for (i = start; i <= stop; ++i)\par    printf("%d\\n", i);\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {Of course, since the function is using the start and stop variables defined in the source file a.cc, you also need to define the same variables in the source file b.cc with a storage class of extern.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Run the program to make sure you got all of the storage classes correct.  If not, you will get either a compiler or linker error.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344576}Initializers{\*\bkmkend _Toc496344576}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {By now you have written several programs where you declare a variable, then initialize it to something almost right away.  C can actually initialize the variable for you so that you don't have to use two different statements, as in this program:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main (void)\par \par \{\par int i = 4;\par \par printf("%d\\n", i);\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par There are some advantages to initializers besides just saving some typing, although the exact advantages may vary from one C compiler to another.  One advantage that is common in all C programs, though, is that an initializer collects the initial value with the variable, which is a sort of comment all by itself: it tells the person reading the program that the variable should start at some specific value, and lists the value.  This may seem like a pretty minor point, but when you are digging through a 10,000 line program, every little bit helps!\par To understand the other advantages and disadvantages of initializers, you have to keep the various storage classes in mind.  In the sample program you just saw, the variable i has auto extent, which means that it is created when the function is called, and goes away when the function returns to the caller.  Naturally, this means that the variable will have to be initialized each time the function is called.  With a simple variable like this integer, the compiler generates exactly the same program if you initialized the variable with a separate assignment statement, like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main (void)\par \par \{\par int i;\par \par i = 4;\par printf("%d\\n", i);\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Local static variables and all global variables, on the other hand, are allocated space by the compiler, and this space is reserved when your program is loaded into memory.  These variables exist until your program finishes.  In these cases, an initialized variable is only initialized one time.  There are both advantages and disadvantages to this.  The advantage is that your program is actually smaller and runs faster if you use an initializer as compared to initializing the variable with an assignment statement.  The other interesting effect could be an advantage or a disadvantage, depending on your outlook.  Since the variable is only initialized one time, if you change the value of the variable in your program, it stays changed.  Try to apply these ideas to the following program, and predict what it will write.  After you decide what you think it will write, give it a try.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par int c = 3;\par \par void fn(void)\par \par \{\par static int a = 1;\par int b = 2;\par \par printf ("%d %d %d\\n", a, b, c);\par a *= 2;\par b *= 2;\par c *= 2;\par \}\par \par void main (void)\par \par \{\par fn();\par fn();\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par You can initialize any C variable except the parameter to a function, regardless of the type of the variable.  Some of the initialization rules for complicated types are pretty messy, and we won't get into them in this introductory course, but a couple of points are worth mentioning.\par First, when you initialize an array or struct, you specify the various values enclosed in braces, like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {int a[3] = \{1,2,3\};\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {You don't have to initialize all of the values, either.  If you only initialize part of an array or struct, the rest of the values are set to 0 for you.  For example, if we only initialize two values, like this:\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {int a[3] = \{1,2\};\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {then a[2] (which is the third element of the array \endash  remember?) is set to 0.  Finally, you can actually specify the }{\i size}{ of an array by initializing it!  This is most useful with initialized strings, where you don't have to keep track of the number of characters in the string.  When you use an initializer to set the length of an array, you just leave out the subscript, like this:\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {char str[] = "Sample";\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par You can use expressions in initializers, too.  The rules get a little complicated, but you can almost always use any expression that evaluates to a constant, like this one:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#define SIZE 3\par int i = 150 - 20*SIZE;\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }{\b Problem 11.4.}{  Use an initializer to initialize a char array to "Hello, world.\\n".  Set the length of the array using the initializer.  Print the string with printf.\par \par }{\b Problem 11.5.}{  An interesting problem from probability theory makes an interesting graphics program, too.  The problem is called the drunkard's walk: you start the drunkard off in the middle of a roof, and assume that he has an equal probability of moving in any direction.  The problem is to figure out how long, on average, it takes to reach the edge.  (In recent and less graphic times, the problem has also been called the random walk.)\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Write a program to implement the drunkard's walk in the graphics window.  Draw a box that extends 20 steps in each direction away from a staring point that is initialized to x = 150, y = 40, and use the random number generator to move the point one step in a random direction.  Do this by animating the point, so the old position is erased after the point moves.  Stop the program and print the number of steps after the point reaches the edge of the square.  Use initializers and static variables wherever appropriate.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Be sure and check your program against the solution to see if you made the best use of static variables and initialized variables.\par \par }\pard\plain \qc\widctlpar\adjustright \f4\cgrid {\b\fs36 \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \qc\widctlpar\adjustright \f4\cgrid {\b\fs36 Lesson Eleven\par Solutions to Problems\par }\pard \qj\widctlpar\adjustright {\b\fs28 \par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344577}Solution to problem 11.1.{\*\bkmkend _Toc496344577}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Break a long value up into words. */\par \par #include <stdio.h>\par \par void main(void)\par \par \{\par union \{                                 /* union to split a long */\par    long l;\par    struct \{\par       int i1, i2;\par       \} i;\par    \} cnv;\par \par do \{\par    printf("long value: ");              /* get a long value */\par    scanf("%ld", &cnv.l);\par                                         /* print the components */\par    printf("least significant word: %d\\n", cnv.i.i1);\par    printf("most significant word : %d\\n\\n", cnv.i.i2);\par    \}\par while (cnv.l);                          /* loop if input is not 0 */\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344578}Solution to problem 11.2.{\*\bkmkend _Toc496344578}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The commands needed are:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {compile main.cc keep=main\par link main graph keep=main\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {You do not need to recompile graph, since it has not changed since the last compile.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344579}Solution to problem 11.3.{\*\bkmkend _Toc496344579}\par }\pard\plain \s21\qj\fi360\keepn\widctlpar\adjustright \f4\fs20\cgrid {\b main.cc\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {void main(void)\par \par \{\par loop(1,10);\par doit();\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b \par a.cc\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {int start, stop;\par \par void loop (int p1, int p2)\par \par \{\par start = p1;\par stop = p2;\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b \par b.cc\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par extern int start, stop;\par \par static void loop (void)\par \par \{\par int i;\par \par for (i = start; i <= stop; ++i)\par    printf("%d\\n", i);\par \}\par \par \par void doit(void)\par \par \{\par loop();\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b \par }\pard \s21\qj\fi360\keepn\widctlpar\adjustright {\b Commands to compile and run the program:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {compile main.cc keep=main\par compile a.cc keep=a\par compile b.cc keep=b\par link main a b keep=main\par }\pard \s23\qj\fi360\widctlpar\adjustright {main\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344580}Solution to problem 11.4.{\*\bkmkend _Toc496344580}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par char str[] = "Hello, world.\\n";\par \par printf(str);\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344581}Solution to problem 11.5.{\*\bkmkend _Toc496344581}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Implement the drunkard's walk */\par \par #include <stdio.h>\par #include <stdlib.h>\par \par #include <quickdraw.h>\par \par #define WIDTH 3                         /* width of a pixel */\par \par void main(void)\par \par \{\par static unsigned left = 150 - 20*WIDTH;  /* dimensions of the walk area */\par static unsigned right = 150 + 20*WIDTH;\par static unsigned top = 40 - 20;\par static unsigned bottom = 40 + 20;\par \par static unsigned x = 150, y = 40;        /* starting position */\par static tx, ty;                          /* temp x, y (for animation) */\par \par static int steps = 0;                   /* # steps taken */\par static rval;                            /* number generated by rand() */\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {srand(12345);                           /* initialize rand() */\par SetPenSize(3,1);                        /* set up the graphics screen */\par SetSolidPenPat(0);                      /* plot the initial point */\par MoveTo(x, y);\par LineTo(x, y);\par }\pard \s23\qj\fi360\widctlpar\adjustright {MoveTo(left, top);                      /* draw the confining box */\par LineTo(right, top);\par LineTo(right, bottom);\par LineTo(left, bottom);\par LineTo(left, top);\par \par do \{\par    tx = x;                              /* save the current point */\par    ty = y;\par    rval = rand() % 3;                   /* update x */\par    if (rval == 0)\par       x -= WIDTH;\par    else if (rval == 2)\par       x += WIDTH;\par    rval = rand() % 3;                   /* update y */\par    if (rval == 0)\par       --y;\par    else if (rval == 2)\par       ++y;\par    SetSolidPenPat(3);                   /* erase the old point */\par    MoveTo(tx, ty);\par    LineTo(tx, ty);\par    SetSolidPenPat(0);                   /* draw the new point */\par    MoveTo(x, y);\par    LineTo(x, y);\par    ++steps;                             /* update the step count */\par    \}                                    /* loop if not at the edge */\par while ((x != left) && (x != right) && (y != top) && (y != bottom));\par \par printf("The walk took %d steps.\\n", steps); /* write the results */\par \}\par }\pard\plain \widctlpar\adjustright \f4\cgrid {\par \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s1\qc\nowidctlpar\outlinelevel0\adjustright \b\f4\fs36\cgrid {{\*\bkmkstart _Toc496344582}Lesson Twelve{\*\bkmkend _Toc496344582}\par {\*\bkmkstart _Toc496344583}Stand-Alone Programs{\*\bkmkend _Toc496344583}\par }\pard\plain \qj\widctlpar\adjustright \f4\cgrid {\b\fs28 \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344584}What is a Stand-Alone Program?{\*\bkmkend _Toc496344584}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {So far, all of your programs have been executed from the PRIZM desktop programming environment.  That's fine for developing and testing programs, but once the program is finished, you probably want to run it from the Finder, or some other program launcher, just like you run other programs.  If you have tried to do that with one of the programs you have written, you found that the Finder doesn't think your program is really a program.\par The reason for this is that there are two basic kinds of executable files on the Apple IIGS.  (There are also several special forms of executable files.)  The two kinds of executable files are S16 files and EXE files.  S16 files are the kind that the Finder and other program launchers recognize; these are the ones we call stand-alone programs.  You can also run S16 programs from ORCA/C, but there is a very important difference between the way an S16 program is handled, and the way an EXE program is handled.  When ORCA/C runs an S16 program, it runs it the same way the Finder does:  ORCA/C shuts itself down, then runs the program.  Once your program finishes, the Apple IIGS's operating system returns to ORCA/C.  When ORCA/C runs an EXE program, it does not shut down.  Because ORCA/C is still there, you can see your source file, use the debugger, and take advantage of the fact that ORCA/C has already started all of the tools you usually need.  That makes it a lot easier to write simple programs, because you have less to worry about.  It also makes the development process faster, since you don't have to wait for ORCA/C to shut itself down before running the program, and start back up when your program is finished.  That's basically why we have two file types.  S16 files can be executed from any environment, like the Finder, but EXE files can only be executed from the safety of a programming environment.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344585}Using StartGraph and EndGraph{\*\bkmkend _Toc496344585}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The simplest kind of stand-alone program that you can write using ORCA/C is a graphics program.  In many ways, stand-alone graphics programs are written just like the graphics programs you have already written that run from the graphics window.  The first, and most important difference, is that a stand-alone program must initialize QuickDraw before making any graphics calls.  Initializing tools from C is not particularly easy, so ORCA/C has a function that will initialize QuickDraw for you.  The function is called startgraph.  When you start a tool, you need to shut it down, too.  ORCA/C has a function called endgraph to do that.  Both of these are declared in orca.h, so you need to put a\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <orca.h>\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {at the start of your program when you are going to use these functions.\par }\pard \s21\qj\fi360\widctlpar\adjustright {The startgraph function can actually do one thing you haven't been able to do from within the programming environment.  The Apple IIGS has two different graphics resolutions.  The PRIZM desktop development environment that you have been using runs in a graphics mode that gives you a screen 640 pixels wide, and 200 pixels high.  Each of the pixels can be one of four different colors.  This is a convenient mode for programs like PRIZM that need to display text.  With 640 pixels to play with, PRIZM can display nearly 80 characters on each line.  If it weren't for the scroll bar, it would actually display a full 80 characters.\par The other graphics mode has half the number of pixels across the width of the text screen; the screen is 320 pixels by 200 pixels.  This just isn't enough room to display text files, but it is great for pictures, because each of the pixels can be any one of 16 colors.\par The startgraph function can set up QuickDraw for either of these two graphics modes.  When you call startgraph, you pass a single integer, either 320 or 640.  The number tells the subroutine which graphics mode to use when it starts QuickDraw.  You can use startgraph and endgraph from PRIZM while you are testing your program.  Since PRIZM must use the 640 by 200 graphics mode, it prevents startgraph from kicking in the 320 by 200 graphics mode.  Your program will work, but everything will be squashed to half its normal width, and only four colors will be displayed.\par The startgraph function does a couple of other things that are a bit different than what you are used to: it clears the graphics screen to black, sets the pen color to white, and sets the pen mode to OR.  The reason for this is that startgraph was designed for engineers who wanted to write stand-alone graphics programs without dealing with the desktop programming environment.  The black screen, white pen, and drawing mode match what they are used to on graphics terminals.  Since that isn't what you are used to, you need to know how to switch everything back.  Our first sample program, shown in listing 12.1, shows you how.  Go ahead and run this like a normal program first; we will talk about how to make it a stand-alone program in a moment.\par }{\lang1024 {\shp{\*\shpinst\shpleft0\shptop308\shpright9360\shpbottom11396\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz29\shplid1161{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 3670016}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 12.1\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Draw an X across the screen */\par \par #include <quickdraw.h>\par #include <orca.h>\par #include <stdio.h>\par \par \par /* Standard graphics initialization. */\par \par void InitGraphics (void)\par \par \{\par Rect r;\par \par startgraph(640);             /* initialize QuickDraw */\par SetPenMode(0);               /* pen mode = copy */\par SetPenSize(3,1);             /* use a square pen */\par SetSolidPenPat(3);           /* paint the screen white */\par GetPortRect(&r);\par PaintRect(&r);\par SetSolidPenPat(0);           /* use a black pen */\par \}\par \par \par /* main program */\par \par void main (void)\par \par \{\par Rect r;                      /* size of the graphics area */\par \par InitGraphics();              /* set up the graphics screen */\par GetPortRect(&r);             /* draw the X */\par MoveTo(r.h1,r.v1);\par LineTo(r.h2,r.v2);\par MoveTo(r.h1,r.v2);\par LineTo(r.h2,r.v1);\par getchar();                   /* wait for the user to press RETURN */\par endgraph();                  /* shut down QuickDraw */\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8221\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 12.1\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Draw an X across the screen */\par \par #include <quickdraw.h>\par #include <orca.h>\par #include <stdio.h>\par \par \par /* Standard graphics initialization. */\par \par void InitGraphics (void)\par \par \{\par Rect r;\par \par startgraph(640);             /* initialize QuickDraw */\par SetPenMode(0);               /* pen mode = copy */\par SetPenSize(3,1);             /* use a square pen */\par SetSolidPenPat(3);           /* paint the screen white */\par GetPortRect(&r);\par PaintRect(&r);\par SetSolidPenPat(0);           /* use a black pen */\par \}\par \par \par /* main program */\par \par void main (void)\par \par \{\par Rect r;                      /* size of the graphics area */\par \par InitGraphics();              /* set up the graphics screen */\par GetPortRect(&r);             /* draw the X */\par MoveTo(r.h1,r.v1);\par LineTo(r.h2,r.v2);\par MoveTo(r.h1,r.v2);\par LineTo(r.h2,r.v1);\par getchar();                   /* wait for the user to press RETURN */\par endgraph();                  /* shut down QuickDraw */\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx0\dpy308\dpxsize9360\dpysize11088\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{When you run this program, one of the peculiar things that happens is that the debugger's menu bar vanishes, to be replaced by a blank menu bar with a foot and a double-arrow.  Any time you initialize any tools for yourself (the startgraph function initializes QuickDraw) the debugger assumes you are trying to write a desktop program with its own menu bar, and it sets up a new one for you.  You can flip back to the debugger's menu bar by clicking on the arrow, or you can single step without switching to the debugger's menu bar by clicking on the foot (to step, of course!).  For the most part, you can ignore this situation, since the debugger's menu bar will come back automatically as soon as your program finishes executing.  If you would like to know more about what is happening, you can refer to the ORCA/C reference manual's description of the debugger.\par There are a couple of new tool calls in this program which could be useful to you in your own programs, so we'll stop now and take a look at them.  In the InitGraphics function, you see the declaration\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {Rect r;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {A Rect is a structure defined in the toolbox, and it is one of the basic structures used by QuickDraw.  Inside this structure, which you can find in the types.h header file in the ORCACDEFS folder, there are four fields: h1, h2, v1 and v2.  These integer fields mark the left, right, top and bottom edges of a rectangle on the graphics screen.\par }\pard \s21\qj\fi360\widctlpar\adjustright {The InitGraphics function makes use of the rectangle to find the size of the graphics window with the call\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {GetPortRect(&r);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par This call fills in the rectangle with the size of the current graphics port.  When you run the program from ORCA/C, the rectangle is filled in with the size of the graphics window, even if you have moved it or changed its size.  The way we use the graphics window, the values of h1 and v1 will always be zero, too, so r.h2 is the width of the graphics window, and r.v2 is the height of the graphics window.  Later, when you run this program as a stand-alone program, this rectangle will get set to the size of the entire graphics screen.\par This information is put to use in the PaintRect call, which fills in the rectangle with the current pen color.  This is a fast way to paint the entire graphics screen.\par There are two steps involved in making this a stand-alone program, and both are very important.  The first is to turn off the debugger.  The source-level debugger is a great help when you are trying to debug a program, but it works by imbedding something called a COP vector throughout your program.  These COP vectors work like subroutine calls, telling the debugger what to do as your program runs.  If you forget to turn debug code off, and leave these COP vectors in your program, the program will crash when you try to run it from the Finder.  In the past, you have turned debug code off to get more speed from your program.  Forgetting to do it now does a bit more than just making your program slow!\par Of course, eventually you will forget.  No real harm is done when the program crashes; you just have to reboot and start again.\par The second step is to tell ORCA/C to produce an S16 file, instead of the EXE file it normally produces.  You should only do this after your program has been written and debugged.  To set the file type, pull down the Run menu and select the Link command.  The link dialog will show up.  In the dialog, you will see a row of four radio buttons, labeled EXE, S16, CDA and NDA.  At the moment, EXE is selected; push S16 to change the file type.  I would also recommend turning off the "Execute after linking" option.  With a stand-alone program, you are better off running it from the Finder.  It takes less time to do it that way.  Once you have made your selections, press Set Options.\par If you were wondering, the other two file type radio buttons help you create classic desk accessories (CDA) and new desk accessories (NDA).  We won't go into these in this course, but your C reference manual does have a tutorial introduction to writing desk accessories.  You have enough background now to write CDAs; you might want to give it a try.  Writing NDAs assumes a pretty good knowledge of the toolbox, though, so you should probably stay away from them until you have written a few standard desktop programs.\par With all of the changes made, you are ready to create your first stand-alone program.  Use Compile to Memory, as you always do.  Since you turned off the Execute after Linking option, though, you only create the program; it does not run.  Get into the Finder (or whatever program launcher you usually use to run commercial programs) and give your program a try!\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 12.1. }{ In the last lesson, there was a fairly long sample program called RandomWalk.  Convert that program to a stand-alone program.  While you are at it, switch it to 320 mode.  You will need to cut the X coordinates for all of the shapes in half.  In addition, change the colors so the program can select any color from 1 to 15 for the shapes, instead of 1 to 3.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344586}Desktop Programs{\*\bkmkend _Toc496344586}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Writing full-blown desktop programs with pull-down menus, windows, and so forth is something that needs a course all to itself, but it is worth pointing out that once you know how to create desktop programs, you make them stand-alone the same way you make a graphics program a stand-alone program.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344587}Mixing Text and Graphics{\*\bkmkend _Toc496344587}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {When you are running a program from the development environment, you have a very clear idea of where things go.  When you use QuickDraw to draw on the screen, the drawings show up in the graphics window.  When you use printf or scanf to deal with text, things happen in the shell window.\par When you write a stand-alone program, though, things aren't quite that well defined.  There isn't a development system to bring up two separate windows, one for text and one for graphics, and keep track of what goes where for you.  If you look through the tool calls that are available from QuickDraw, the font manager, and so forth, you will find a new set of commands to draw text on the screen.  So what happens to printf and scanf?\par The answer, fortunately, is that ORCA/C still handles them in stand-alone graphics programs.  There is some set-up involved, though.  It's done by startgraph, which sets things up for your program so that text output calls are converted to calls to the tools that draw text on the screen.  You can read text from the screen, too.  In fact, the only thing you loose is automatic scrolling.\par Text is rerouted to the graphics screen anytime you use startgraph to start QuickDraw.  In the last section, you saw that we can use startgraph in a program without making it a stand-alone program.  The last section probably convinced you that you want to stay in the development environment while you are working on a program, too, since the development cycle goes much faster that way.  We'll make use of this to try mixing text and graphics without creating a stand-alone program, at least not yet.\par There is one interesting thing you have to know about QuickDraw before we write our first program that puts text on the graphics screen.  When you draw text, QuickDraw can draw it in any of the screen colors.  Naturally, that means you need a way to tell QuickDraw what colors to use.  For the drawing commands, like LineTo, we use SetSolidPenPat to tell QuickDraw what color to use.  For text, there are two colors:  the color of the characters themselves, and the color of the background that the characters appear on.  There are two separate commands to set these colors, SetBackColor, and SetForeColor.  The color numbers are the same as the ones you are used to.\par The program in listing 12.2 gives an example of some of the effects you can get with these colors.  Give it a try as an EXE program.\par There is one important difference between the way this program handles the ends of lines and the way most of your other programs handled the end of a line.  When you are writing to the text screen, the character \\n causes the text to shift to the start of the next line.  On the graphics screen, you should use \\r, instead, as this program does.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 12.2. }{ Make this a stand-alone program, and run it.  The program will return to the Finder too quick to read the screen if you don't put in some sort of pause.  Putting a getchar() right before the call to EndGraph is a good way to handle this situation.  That way, the program doesn't stop until you press the return key.\par }{\b \par }{\sect }\sectd \sbknone\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b \par }\pard \s21\qj\fi360\keepn\widctlpar\brdrt\brdrs\brdrw10\brsp20 \brdrl\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \adjustright {\b Listing 12.2\par \par }\pard\plain \fi360\keepn\nowidctlpar\brdrt\brdrs\brdrw10\brsp20 \brdrl\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \adjustright \f4\cgrid {\f6\fs20 /* Exploring text mixed with graphics. */\par \par #include <quickdraw.h>\par #include <orca.h>\par #include <stdio.h>\par \par \par /* Standard graphics initialization. */\par \par void InitGraphics (void)\par \par \{\par Rect r;\par \par startgraph(640);             /* initialize QuickDraw */\par }\pard \fi360\nowidctlpar\brdrt\brdrs\brdrw10\brsp20 \brdrl\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \adjustright {\f6\fs20 SetPenMode(0);               /* pen mode = copy */\par SetPenSize(3,1);             /* use a square pen */\par SetSolidPenPat(3);           /* paint the screen white */\par GetPortRect(&r);\par PaintRect(&r);\par SetSolidPenPat(0);           /* use a black pen */\par \}\par \par \par /* main program */\par \par void main (void)\par \par \{\par InitGraphics();              /* set up the graphics screen */\par SetForeColor(0);             /* write some text */\par SetBackColor(3);\par MoveTo(10,10);\par printf("You can get\\rsome ");\par SetForeColor(3);\par SetBackColor(0);\par printf("interesting effects\\r");\par SetForeColor(2);\par SetBackColor(3);\par printf("by mixing text\\r");\par SetForeColor(1);\par printf("with graphics!");\par endgraph();                  /* shut down QuickDraw */\par \}\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344588}Stand-Alone Text Programs{\*\bkmkend _Toc496344588}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Other than starting and stopping the text tools, there is no real trick to writing stand-alone text programs.  Just as with the graphics programs, you have to turn off debug code and set the file type to S16, instead of EXE.  The mechanism used to start the text tools is a bit odd, and involves issues with the toolbox that are beyond the scope of this course.  Rather than try to explain what tools are, what the tool locater is, and so forth, just so you can initialize and shut down one tool, I will simply give you text equivalents for startgraph and endgraph, called StartText and EndText.  For a stand-alone text program, call StartText at the very beginning of your program, and EndText at the end of your program.\par Because of the way tools work, you should not call StartText and startgraph in the same program.  For a stand-alone program, you need to pick one screen or the other.  For the same reasons, you must not call StartText from a program that is not stand-alone.  Debug your program without the calls to StartText and EndText, then add the calls when you switch the file type to S16.  You will also need a \par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <texttool.h>\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {at the start of your program.\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* Start the text tools for    */\par /* a stand-alone text program. */\par \par void StartText (void)\par \par \{\par TextStartUp();\par SetErrGlobals(127,0);\par SetErrorDevice(1,3L);\par SetInGlobals(127,0);\par SetInputDevice(1,3L);\par SetOutGlobals(127,0);\par SetOutputDevice(1,3L);\par \}\par \par /* Shut down the text tools    */\par /* for a stand-alone text      */\par /* program.                    */\par \par void EndText (void)\par \par \{\par TextShutDown();\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }{\b Problem 12.3. }{ Pick some text program you have written in the course, and make it a stand-alone program.  The solution to this problem uses hangman, a program you wrote as the solution to problem 6.6.  If you like your solution, or if you typed in the one we provided, use that program.\par \par \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \qc\widctlpar\adjustright \f4\cgrid {\b\fs36 Lesson Twelve\par Solutions to Problems\par }\pard \qj\widctlpar\adjustright {\b\fs28 \par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344589}Solution to problem 12.1.{\*\bkmkend _Toc496344589}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Do a random walk with 10 random shapes */\par \par #include <stdlib.h>\par #include <orca.h>\par \par #include <quickdraw.h>\par \par #define NUMSHAPES 10                    /* # of shapes to animate */\par #define WALKLENGTH 100                  /* # of "steps" in the walk */\par \par #define MAXX 320                        /* size of the graphics screen */\par #define MAXY 200\par \par typedef enum shapeKind \{triangle, square, star\} shapeKind;\par \par typedef struct shapeType \{              /* information about one shape */\par    int color;                           /* color */\par    shapeKind kind;                      /* kind of shape */\par    union \{\par       struct \{                          /* points for a triangle */\par          int x1,x2,x3,y1,y2,y3;\par          \} t;\par       struct \{                          /* points for a square */\par          int x1,x2,x3,x4,y1,y2,y3,y4;\par          \} s;\par       struct \{                          /* points for a star */\par          int x1,x2,x3,x4,x5;\par          int y1,y2,y3,y4,y5;\par          \} p;\par       \} coord;\par    \} shapeType;\par \par \par shapeType shapes[NUMSHAPES];            /* current array of shapes */\par shapeType oldShapes[NUMSHAPES];         /* shapes in last position */\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void InitGraphics (void)\par \par /* Standard graphics initialization.                            */\par \par \{\par }\pard \s23\qj\fi360\widctlpar\adjustright {Rect r;                                 /* graphics screen */\par \par startgraph(320);                        /* set up the graphics screen */\par SetPenMode(0);                          /* pen mode = copy */\par SetPenSize(1,1);                        /* use a square pen */\par SetSolidPenPat(15);                     /* paint the screen white */\par GetPortRect(&r);\par PaintRect(&r);\par SetPenMode(2);                          /* pen mode = xor */\par \}\par \par \par void DrawShape (shapeType s)\par \par /* This subroutine draws one of the shapes on the screen.       */\par /*                                                              */\par /* Parameters:                                                  */\par /*    s - shape to draw                                         */\par \par \{\par SetSolidPenPat(s.color);             /* set the pen color for the shape */\par \par switch (s.kind) \{\par \par    case triangle:                       /* draw a triangle */\par       MoveTo(s.coord.t.x1, s.coord.t.y1);\par       LineTo(s.coord.t.x2, s.coord.t.y2);\par       LineTo(s.coord.t.x3, s.coord.t.y3);\par       LineTo(s.coord.t.x1, s.coord.t.y1);\par       return;\par \par    case square:                         /* draw a square */\par       MoveTo(s.coord.s.x1, s.coord.s.y1);\par       LineTo(s.coord.s.x2, s.coord.s.y2);\par       LineTo(s.coord.s.x4, s.coord.s.y4);\par       LineTo(s.coord.s.x3, s.coord.s.y3);\par       LineTo(s.coord.s.x1, s.coord.s.y1);\par       return;\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {   case star:                           /* draw a star */\par       MoveTo(s.coord.p.x1, s.coord.p.y1);\par       LineTo(s.coord.p.x2, s.coord.p.y2);\par       LineTo(s.coord.p.x3, s.coord.p.y3);\par       LineTo(s.coord.p.x4, s.coord.p.y4);\par       LineTo(s.coord.p.x5, s.coord.p.y5);\par       LineTo(s.coord.p.x1, s.coord.p.y1);\par }\pard \s23\qj\fi360\widctlpar\adjustright {      return;\par    \}\par \}\par \par \par void CreateShape (shapeType *s)\par \par /* This subroutine creates a shape.  The color and initial      */\par /* position of the shape are chosen randomly.  The size of the  */\par /* shape is based on pre-computed values.                       */\par /*                                                              */\par /* Parameters:                                                  */\par /*    s - shape to create                                       */\par \par \{\par int cx,cy;                              /* center point for the shape */\par \par s->color = rand() % 15 + 1;             /* get a color */\par cx = rand() % (MAXX - 19) + 9;          /* get the center position,   */\par cy = rand() % (MAXY - 8) + 4;           /* picking the points so the  */\par                                         /* shape is in the window     */\par \par switch (rand() % 3) \{                   /* set the initial positions */\par    case 0:                              /* set up a triangle */\par       s->kind = triangle;\par       s->coord.t.x1 = cx-10;\par       s->coord.t.y1 = cy+4;\par       s->coord.t.x2 = cx;\par       s->coord.t.y2 = cy-8;\par       s->coord.t.x3 = cx+10;\par       s->coord.t.y3 = cy+4;\par       return;\par \par    case 1:                              /* set up a square */\par       s->kind = square;\par       s->coord.s.x1 = cx-8;\par       s->coord.s.y1 = cy-6;\par       s->coord.s.x2 = cx+8;\par       s->coord.s.y2 = cy-6;\par       s->coord.s.x3 = cx-8;\par       s->coord.s.y3 = cy+6;\par       s->coord.s.x4 = cx+8;\par       s->coord.s.y4 = cy+6;\par       return;\par \par    case 2:                              /* set up a star */\par       s->kind = star;\par       s->coord.p.x1 = cx-7;\par       s->coord.p.y1 = cy+7;\par       s->coord.p.x2 = cx;\par       s->coord.p.y2 = cy-8;\par       s->coord.p.x3 = cx+7;\par       s->coord.p.y3 = cy+7;\par       s->coord.p.x4 = cx-11;\par       s->coord.p.y4 = cy-3;\par       s->coord.p.x5 = cx+11;\par       s->coord.p.y5 = cy-3;\par       return;\par    \}\par \}\par \par \par void UpdateShape (shapeType *s)\par \par /* This subroutine moves a shape across the screen in a random  */\par /* walk.                                                        */\par /*                                                              */\par /* Parameters:                                                  */\par /*    s - shape to update                                       */\par \par \{\par int dx,dy;                              /* movement direction */\par \par dx = rand() % 3 - 1;                    /* get the walk direction */\par dy = rand() % 3 - 1;\par \par switch (s->kind) \{                      /* make sure we don't walk off */\par                                         /* of the screen, then update  */\par                                         /* the position                */\par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {   case triangle:                       /* check a triangle */\par       if (dx == -1)\par          if (s->coord.t.x1 < 1)\par             dx = 0;\par       if (dx == 1)\par          if (s->coord.t.x3 >= MAXX)\par             dx = 0;\par       if (dy == -1)\par          if (s->coord.t.y2 < 1)\par             dy = 0;\par       if (dy == 1)\par          if (s->coord.t.y3 >= MAXY)\par             dy = 0;\par       s->coord.t.x1 = s->coord.t.x1+dx; /* update a triangle */\par       s->coord.t.y1 = s->coord.t.y1+dy;\par }\pard \s23\qj\fi360\widctlpar\adjustright {      s->coord.t.x2 = s->coord.t.x2+dx;\par       s->coord.t.y2 = s->coord.t.y2+dy;\par       s->coord.t.x3 = s->coord.t.x3+dx;\par       s->coord.t.y3 = s->coord.t.y3+dy;\par       return;\par \par    case square:                         /* check a square */\par       if (dx == -1)\par          if (s->coord.s.x1 < 1)\par             dx = 0;\par       if (dx == 1)\par          if (s->coord.s.x2 >= MAXX)\par             dx = 0;\par       if (dy == -1)\par          if (s->coord.s.y1 < 1)\par             dy = 0;\par       if (dy == 1)\par          if (s->coord.s.y3 >= MAXY)\par             dy = 0;\par       s->coord.s.x1 = s->coord.s.x1+dx; /* update a square */\par       s->coord.s.y1 = s->coord.s.y1+dy;\par       s->coord.s.x2 = s->coord.s.x2+dx;\par       s->coord.s.y2 = s->coord.s.y2+dy;\par       s->coord.s.x3 = s->coord.s.x3+dx;\par       s->coord.s.y3 = s->coord.s.y3+dy;\par       s->coord.s.x4 = s->coord.s.x4+dx;\par       s->coord.s.y4 = s->coord.s.y4+dy;\par       return;\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {   case star:                           /* check a star */\par       if (dx == -1)\par          if (s->coord.p.x4 < 1)\par             dx = 0;\par       if (dx == 1)\par          if (s->coord.p.x5 >= MAXX)\par }\pard \s23\qj\fi360\widctlpar\adjustright {            dx = 0;\par       if (dy == -1)\par          if (s->coord.p.y2 < 1)\par             dy = 0;\par       if (dy == 1)\par          if (s->coord.p.y1 >= MAXY)\par             dy = 0;\par       s->coord.p.x1 = s->coord.p.x1+dx; /* update a star */\par       s->coord.p.y1 = s->coord.p.y1+dy;\par       s->coord.p.x2 = s->coord.p.x2+dx;\par       s->coord.p.y2 = s->coord.p.y2+dy;\par       s->coord.p.x3 = s->coord.p.x3+dx;\par       s->coord.p.y3 = s->coord.p.y3+dy;\par       s->coord.p.x4 = s->coord.p.x4+dx;\par       s->coord.p.y4 = s->coord.p.y4+dy;\par       s->coord.p.x5 = s->coord.p.x5+dx;\par       s->coord.p.y5 = s->coord.p.y5+dy;\par       return;\par    \}\par \}\par \par \par void main(void)\par \par /* main program                                                 */\par \par \{\par int i,j;                                /* loop variables */\par \par InitGraphics();                         /* set up the graphics window */\par srand(6289);                            /* initialize rand() */\par \par for (i = 0; i < NUMSHAPES; ++i) \{ /* set up and draw the initial shapes */\par    CreateShape(&shapes[i]);\par    DrawShape(shapes[i]);\par    \}\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {for (i = 0; i < WALKLENGTH; ++i) \{      /* do the random walk */\par    for (j = 0; j < NUMSHAPES; ++j) \{    /* move the shapes */\par       oldShapes[j] = shapes[j];\par       UpdateShape(&shapes[j]);\par       \}\par    for (j = 0; j < NUMSHAPES; ++j) \{    /* redraw the shapes */\par       DrawShape(shapes[j]);\par       DrawShape(oldShapes[j]);\par }\pard \s23\qj\fi360\widctlpar\adjustright {      \}\par    \}\par \par endgraph();                            /* shut down the graphics screen */\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344590}Solution to problem 12.2.{\*\bkmkend _Toc496344590}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Exploring text mixed with graphics. */\par \par #include <quickdraw.h>\par #include <orca.h>\par #include <stdio.h>\par \par \par /* Standard graphics initialization. */\par \par void InitGraphics (void)\par \par \{\par Rect r;\par \par startgraph(640);             /* initialize QuickDraw */\par SetPenMode(0);               /* pen mode = copy */\par SetPenSize(3,1);             /* use a square pen */\par SetSolidPenPat(3);           /* paint the screen white */\par GetPortRect(&r);\par PaintRect(&r);\par SetSolidPenPat(0);           /* use a black pen */\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {/* main program */\par \par void main (void)\par \par \{\par InitGraphics();              /* set up the graphics screen */\par SetForeColor(0);             /* write some text */\par SetBackColor(3);\par MoveTo(10,10);\par printf("You can get\\rsome ");\par }\pard \s23\qj\fi360\widctlpar\adjustright {SetForeColor(3);\par SetBackColor(0);\par printf("interesting effects\\r");\par SetForeColor(2);\par SetBackColor(3);\par printf("by mixing text\\r");\par SetForeColor(1);\par printf("with graphics!");\par                              /* wait for the user to press RETURN */\par printf("\\r\\r\\rPress RETURN to quit.");\par getchar();\par endgraph();                  /* shut down QuickDraw */\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344591}Solution to problem 12.3.{\*\bkmkend _Toc496344591}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Hangman                                              */\par /*                                                      */\par /* This program plays the game of Hangman.  When the    */\par /* game starts, you are given a word to guess.  The     */\par /* program displays one dash for each letter in the     */\par /* word.  You guess a letter.  If the letter is in the  */\par /* word, the computer prints the word with all letters  */\par /* you have guessed correctly shown in their correct    */\par /* positions.  If you do not guess the word, you move   */\par /* one step closer to being hung.  After six wrong      */\par /* guesses, you loose.                                  */\par \par #include <stdio.h>\par #include <string.h>\par #include <stdlib.h>\par \par #include <texttool.h>\par \par #define MAXWORDS 10             /* possible words */\par #define MAXCHARS 8              /* number of characters in each word */\par \par char words[MAXWORDS][MAXCHARS+1]; /* word array */\par \par \par void FillArray (void)\par \par /* Fill the word array.                               */\par /*                                                    */\par /* Variables:                                         */\par /*    words - word array                              */\par \par \{\par strcpy(words[0], "computer");\par strcpy(words[1], "whale");\par strcpy(words[2], "megabyte");\par strcpy(words[3], "modem");\par strcpy(words[4], "chip");\par strcpy(words[5], "online");\par strcpy(words[6], "disk");\par strcpy(words[7], "monitor");\par strcpy(words[8], "window");\par strcpy(words[9], "keyboard");\par \}\par \par \par void GetSeed (void)\par \par /* Initialize the random number generator             */\par \par \{\par int val;                        /* seed value */\par \par printf("Please enter a random number seed:");\par scanf(" %d", &val);\par srand(val);\par \}\par \par \par unsigned RandomValue (unsigned max)\par \par /* Return a pseudo-random number in the range 1..max. */\par /*                                                    */\par /* Parameters:                                        */\par /*    max - largest number to return                  */\par /*    color - interior color of the rectangle         */\par \par \{\par return rand() % max + 1;\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void Play (void)\par \par /* Play a game of hangman.                            */\par }\pard \s23\qj\fi360\widctlpar\adjustright {/*                                                    */\par /* Variables:                                         */\par /*    words - word array                              */\par \par \{\par int allFound;                   /* used to test for unknown chars */\par char ch;                        /* character from player */\par int done;                       /* is the game over? */\par char found[MAXCHARS];           /* characters found by player */\par unsigned len;                   /* length of word; for efficiency */\par unsigned i;                     /* loop variable */\par int inString;                   /* is ch in the string? */\par char word[MAXCHARS+1];          /* word to guess */\par int wrong;                      /* number of wrong guesses */\par \par for (i = 0; i < MAXCHARS; ++i)  /* no letters guessed, so far */\par    found[i] = 0;\par wrong = 0;                      /* no wrong guesses, yet */\par done = 0;                       /* the game is not over, yet */\par                                 /* pick a word */\par strcpy(word, words[RandomValue(MAXWORDS)]); \par len = strlen(word);             /* record the length of the word */\par do \{\par    printf("\\nThe word is: \\""); /* write the word */\par    for (i = 0; i < len; ++i)\par       if (found[i])\par          printf("%c", word[i]);\par       else\par          printf("-");\par    printf("\\"\\nGuess a character:"); /* get the player's choice */\par    scanf(" %c", &ch);\par    inString = 0;                /* see if ch is in the string */\par    for (i = 0; i < len; ++i)\par       if (word[i] == ch) \{\par          found[i] = 1;\par          inString = 1;\par          \}\par    if (inString)                /* handle a correct guess */\par       printf("%c is in the string.\\n", ch);\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {   else \{                       /* handle an incorrect guess */\par       printf("%c is not in the string.\\n", ch);\par       ++wrong;                  /* one more wrong answer... */\par       printf("Your ");          /* tell the player how they are doing */\par       if (wrong == 1)\par          printf("head");\par       else if (wrong == 2)\par }\pard \s23\qj\fi360\widctlpar\adjustright {         printf("body");\par       else if (wrong == 3)\par          printf("left arm");\par       else if (wrong == 4)\par          printf("right arm");\par       else if (wrong == 5)\par          printf("left leg");\par       else /* if (wrong == 6) */\par          printf("right leg");\par       printf(" is now in the noose!\\n");\par       \}\par \par    if (wrong == 6) \{            /* see if the player is hung */\par       printf("\\n\\nSorry, Jack Ketch got you!\\nThe word was \\"%s\\".\\n",\par          word);\par       done = 1;\par       \}\par    allFound = 1;                /* check for unknown characters */\par    for (i = 0; i < len; ++i)\par       if (!found[i])\par          allFound = 0;\par    if (allFound) \{              /* see if the player got the word */\par       printf("You got it!  The word is \\"%s\\".\\n", word);\par       done = 1;\par       \}\par    \}\par while (!done);\par \}\par \par \par int PlayAgain (void)\par \par /* See if the player wants to play another game.      */\par /*                                                    */\par /* Returns:                                           */\par /*    True to play again, false to quit.              */\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {\{\par char ch;                        /* player's response */\par \par printf("\\n\\n");\par do \{\par    printf("Would you like to play again (y or n)?");\par }\pard \s23\qj\fi360\widctlpar\adjustright {   scanf(" %c", &ch);\par    \}\par while ((ch != 'y') && (ch != 'Y') && (ch != 'n') && (ch != 'N'));\par return (ch == 'y') || (ch == 'Y');\par \}\par \par \par void StartText (void)\par \par /* Start the text tools for a stand-alone text        */\par /* program.                                           */\par \par \{\par TextStartUp();\par SetErrGlobals(127, 0);\par SetErrorDevice(1, 3L);\par SetInGlobals(127, 0);\par SetInputDevice(1, 3L);\par SetOutGlobals(127, 0);\par SetOutputDevice(1, 3L);\par \}\par \par \par void EndText (void)\par \par /* Shut down the text tools for a stand-alone text    */\par /* program.                                           */\par \par \{\par TextShutDown();\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void main (void)\par \par /* Main program                                       */\par \par \{\par StartText();                    /* start the text toolbox */\par FillArray();                    /* fill the word array */\par GetSeed();                    /* initialize the random number generator */\par do\par    Play();                      /* play a game */\par while (PlayAgain());            /* loop if he wants to play again */\par }\pard \s23\qj\fi360\widctlpar\adjustright {EndText();                      /* shut down the text tool set */\par \}\par }\pard\plain \widctlpar\adjustright \f4\cgrid {\par \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s1\qc\nowidctlpar\outlinelevel0\adjustright \b\f4\fs36\cgrid {{\*\bkmkstart _Toc496344592}Lesson Thirteen{\*\bkmkend _Toc496344592}\par {\*\bkmkstart _Toc496344593}Scanning Text{\*\bkmkend _Toc496344593}\par }\pard\plain \qj\widctlpar\adjustright \f4\cgrid {\b\fs28 \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344594}The Course of the Course{\*\bkmkend _Toc496344594}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {This lesson, and the three that follow, mark a changing point in the Learn to Program course.  Instead of springing it on you with no warning, I thought it would be best to stop and look at what we have done so far, and what is left.\par The first twelve lessons were concerned primarily with teaching you the mechanics of programming.  In those lessons, you learned most of the features of C.  While we used a number of real programs to illustrate the features of the C language, and frequently discussed principals of good programming practice, crafting a program was not the primary topic.\par It turns out that a few tasks turn up repeatedly in many different kinds of programs.  The next four lessons deal with some of these basic techniques.  In the process, you will get a chance to hone your programming skills.\par Because the nature of the material is changing, we will also change our approach a bit.  In the first part of the course, the text was laced with complete programs to illustrate the basic ideas.  As the topics have changed, we have gradually moved away from that technique.  Starting with this lesson, we will abandon it almost completely.  Instead, we will talk about the concepts behind a particular algorithm.  Many times, complete subroutines will be shown.  The problems, for the most part, will involve using these ideas to create complete programs.  As always, the solutions are given, so if you get stuck you can always refer to the complete solution.\par There are a number of reasons for changing to this approach.  One is that you know how to create a program, now, but you still need lots of practice to get really good at it.  Another is that we will be able to cover a lot more material this way.  Finally, when the course is over, I want you to know how to read intermediate computer science books \endash  the kind of books that teach you about data structures, compiler theory, animation, and so on.  Most of these books also give algorithms.  If you are used to learning about programming methods by studying algorithms when you see these books for the first time, you will get a lot more out of them.  I think it is better to learn to read an algorithm in a setting like this course, when complete programs are at least provided as part of the solution to a problem.  In the algorithm books, you won't generally find any complete programs at all.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344595}Manipulating Text{\*\bkmkend _Toc496344595}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {In today's world of graphically based computers, it might seem that manipulating text just isn't important anymore.  As it turns out, though, that simply isn't true.  Stop and think about it for a moment.  The editor you use to type in programs manipulates text.  The dialogs you use to enter search strings handle text.  The C compiler that creates programs starts with a text file.  From word processors to spread sheets to adventure games, text is still the most common way to store information in a computer, so programs still have to manipulate text.  That means that, as a programmer, you should know some of the basic techniques used to deal with text.\par Programs that deal with text generally divide the task up into well-defined subtasks.  These are called scanning, parsing, and semantics.  A compiler is a classic example of a program that manipulates text, so we will start by looking at each of these tasks from the standpoint of a C compiler.  Later, we will see how many other programs use these same ideas.\par Scanning, also called lexical analysis, is the process of collecting characters from the text and forming the characters into words.  It's not that hard to do, but the idea is a very powerful one.  As a quick example, let's look at a simple C program, and see how a scanner would break it up into words.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par void main(void)\par \par \{\par printf("Hello, world.\\n");\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par It is tempting to look at this program as a collection of characters, but if you stop and think about it for a minute, that isn't the way you read it.  Instead of individual letters, you group the program into words.  Compilers do the same thing.  The scanner is responsible for reading the characters and forming words from the characters.  These words are called tokens.  The main driver for the compiler never even looks at the characters.  Instead, it calls a subroutine, which we will call GetToken, that reads characters until a complete word is formed, then returns a single value that indicates what the word is.  The scanner would break our short sample program down into reserved words and reserved symbols, like void and ); constants, like the string written by printf; and identifiers, like main.  In the case of the identifiers, the scanner also returns a string variable with the name of the identifier.  For constants, it returns the value of the constant.\par Scanner's aren't limited to compilers.  Virtually any program that deals with words uses a scanner of some sort.  Spelling checkers, text adventure games, and even some advanced database programs that accept English-like questions are just a few of the programs that use a scanner.\par The next step in the process is called parsing.  The parser looks at a sequence of tokens to see if they fit certain preconceived patters.  For example, the C compiler knows that void starts a function, and that this should be followed by a symbol.  Compilers, grammar checkers and adventure games are all examples of programs that use parsers.\par The last step is called semantic analysis.  That's a fancy way of saying that the program figures out what the words mean.  In the case of a compiler, semantic analysis is when the compiler decides what machine code instructions will do what you want the program to do.  In an adventure game, semantic analysis is when the game decides that "I want to go north" means that the character should be moved from his current location to another location.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344596}Building a Simple Scanner{\*\bkmkend _Toc496344596}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The first step in writing a scanner is to decide, in very precise terms, what we mean by a token.  In the case of a spelling checker, we could define a token as any stream of characters that starts with a letter, and contains only letters.  Any other characters, such as punctuation marks or numbers, can be ignored, since you can't misspell a number or a comma.  You can misuse them, of course, but not misspell them.  A C compiler can't afford to skip commas or numbers, but it can skip comments, spaces, and end of line marks.  In other words, one of the jobs of the scanner is to skip characters that are not relevant to the main program.\par Let's start with a scanner for a spelling checker.  We will skip characters until we get to an alphabetic character, then collect the characters into a string until we get to a non-alphabetic character.  There are two problems that have to be dealt with.  The first is how to know how big a word can be, while the second is how to tell the main program that there are no more words.\par To solve the first problem, we will use a bit of trivia.  The longest word in the English language is antidisestablishmentarianism.  It has 28 characters.  If we allow 29 characters in a word, then, we can hold any legitimate word in the English language.  (We need 29 characters instead of 28 so that we will have room for an erroneous character at the end of an otherwise legitimate 28 character word.)  Anything else must be misspelled.  In the scanner for our spelling checker, we will collect up to 29 characters, and return those characters.  Any other characters will be ignored.\par The second problem can be solved in a variety of ways.  For a spelling checker, though, we will use a particularly simple one.  When we get to the end of the file, we will return a null string.\par All of this can be expressed in a very short subroutine called GetToken.\par \par }\pard\plain \s23\qj\widctlpar\adjustright \f6\fs20\cgrid {\fs18 void GetToken(void)\par \par /* Read a word from the source file    */\par /*                                     */\par /* Variables:                          */\par /*    f - source file                  */\par /*    token - string read              */\par \par \{\par /* length of the string */\par int len = 0;   \par \par /* skip to the first character */\par while ((! isalpha(ch)) && (ch != EOF))\par    ch = fgetc(f);\par \par /* read the word */\par while ((ch != EOF) && (isalpha(ch))) \{  \par    if (len < MAXLENGTH-1) \{\par       token[len] = ch;\par       ++len;\par       \}\par    ch = fgetc(f);\par    \}\par \par /* set the null terminator */\par token[len] = (char) 0;\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Take a close look at how the subroutine works.  Think it through by writing the values of len, ch and token on a sheet of paper, and tracing through the subroutine by hand for a short text sample.  Make sure you understand how it meets our basic requirements to collect words, skip unneeded characters, return a null string at the end of the file, and handle words longer than MAXLENGTH.  (Naturally, MAXLENGTH is a constant; it is defined in the main part of the program.  For this program, MAXLENGTH is set to 30 instead of 29, leaving space for the terminating null character.)\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 13.1.}{  Write a program based on GetToken that will scan a text file and write a list of the words in the file, one word per line.  As a test, try the program on the source code for the program itself.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Testing a program for unusual conditions is a very important part of the programming process.  In this program, the unusual condition is a word that is too long.  One way to test for a word that is too long is with a special test file, but there is another way, too.  Since the maximum length of a word is a constant, you can change the constant to 8, or some other small value, and try the program again.  Use this method to make sure your program handles words longer than MAXLENGTH correctly.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344597}Symbol Tables{\*\bkmkend _Toc496344597}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {One way to write a spelling checker is to collect each word and search for it in a dictionary.  Depending on how the spelling checker works, if you find a word that is not in the dictionary, you could print it, display it and let the user correct or accept it, or save it and print a list of words later.  This approach works pretty well for interactive spelling checkers.  Not so long ago, though, spelling checkers were generally not built right into word processors.  Instead, they were separate programs.  In this kind of spelling checker, instead of looking up a word as soon as it is found, the words are saved in a linked list.  Only one copy of each word is saved.  After the entire document has been scanned, each word is looked up in the dictionary.  This drastically cuts the number of times the program needs to look up a word.  As a result, the spelling checker is a lot faster than one that looks up each word when it is read from the source file.\par This list of words has a name:  it is called a symbol table.  Finding words in a symbol table is such a common task that an enormous amount of effort has gone into finding very fast ways to look up a word.  We'll look at some of these later.  For now, though, we will use a linked list.\par To keep things simple, we generally don't put a word in a symbol table in the GetToken subroutine.  Instead, the main program repeatedly calls GetToken, then another subroutine which we will call Insert.  Insert creates the symbol table.\par In most real programs, we put more than just the symbol itself in the symbol table.  In our program, we will also keep track of how many times the word appeared in the file.  The Insert procedure shows how this is done.  It uses a structure called symbolStruct, which defines a single entry in the symbol table.  This struct is defined globally, so that we can also use a global variable to point to the first element of the linked list.  The structure looks like this:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {typedef struct symbolStruct \{\par    struct symbolStruct *next;\par    int count;\par    char symbol[MAXLENGTH];\par    \}\par    symbolStruct;\par \par }\pard \s23\qj\fi360\widctlpar\adjustright {typedef symbolStruct *symbolPtr;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The function that actually inserts a value into the symbol table is shown in listing 13.1.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 13.2. }{ Using GetToken and Insert, create a program that will count the number of words in a file, and print the number of times each word appears in the file.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344598}Parsing{\*\bkmkend _Toc496344598}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {At one time or another, you have probably played one of the adventure games that lets you type text commands.  Did you ever wonder how they worked?  Some of them can recognize all of these sentences, and in each case they will move the character to the north:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {Go north.\par Run to the north.\par I want to move north, now.\par North is the direction that I\par }\pard \s23\qj\fi360\widctlpar\adjustright {   would like to go.\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Many of these programs are pretty small, so they can't be doing anything particularly difficult.  How do they work?\par There is one surprisingly simple way to create a program that can recognize and act on all of these commands.  It involves building a verb and subject table.  Look carefully at the sentences.  In each of our examples, there is a verb that indicates you want to move, like go or run.  There is also a direction, north.  The simple parsers used in the adventure games scan a sentence, looking for a verb and subject the program recognizes.  All of the other words are simply discarded.  The parser returns the verb and subject, and the program takes some action.\par }{\lang1024 {\shp{\*\shpinst\shpleft0\shptop0\shpright9504\shpbottom7920\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz30\shplid1163{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 3604480}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 13.1\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {void Insert (void)\par \par /* Insert a word in the symbol table                            */\par /*                                                              */\par /* Variables:                                                   */\par /*    token - symbol                                            */\par /*    table - pointer to the first element in the symbol        */\par /*       table                                                  */\par \par \{\par symbolPtr ptr;                       /* work pointer */\par int len;                             /* length of the string */\par \par ptr = table;                       /* see if the symbol already exists */\par while (ptr != NULL) \{\par    if (strcmp(ptr->symbol, token) == 0) \{\par       ++ptr->count;                /* yes -> update the count and exit */\par       return;\par       \}\par    ptr = ptr->next;\par    \}\par                                      /* no -> create a new entry */\par ptr = (symbolPtr) malloc(sizeof(symbolStruct));\par ptr->next = table;\par table = ptr;\par ptr->count = 1;\par strcpy(ptr->symbol, token);\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8222\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 13.1\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {void Insert (void)\par \par /* Insert a word in the symbol table                            */\par /*                                                              */\par /* Variables:                                                   */\par /*    token - symbol                                            */\par /*    table - pointer to the first element in the symbol        */\par /*       table                                                  */\par \par \{\par symbolPtr ptr;                       /* work pointer */\par int len;                             /* length of the string */\par \par ptr = table;                       /* see if the symbol already exists */\par while (ptr != NULL) \{\par    if (strcmp(ptr->symbol, token) == 0) \{\par       ++ptr->count;                /* yes -> update the count and exit */\par       return;\par       \}\par    ptr = ptr->next;\par    \}\par                                      /* no -> create a new entry */\par ptr = (symbolPtr) malloc(sizeof(symbolStruct));\par ptr->next = table;\par table = ptr;\par ptr->count = 1;\par strcpy(ptr->symbol, token);\par \}\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx0\dpy0\dpxsize9504\dpysize7920\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{Games aren't the only place this method is used.  The same basic idea is used in a program called Eliza, the first computer psychologist.  This simple demonstration program is surprisingly effective at giving almost human-like responses, yet it is only a few dozen lines long.  An even more direct application of this technology is found in some database query programs written for people who don't normally use computers.  For example, you might type\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {Where can I find information\par }\pard \s23\qj\fi360\widctlpar\adjustright {about Kansas and wheat crops?\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The database program scans the line, finding just a few relevant words.  The verb is find.  There are two subjects, Kansas and wheat, separated by a boolean operator, and.  The database program scans its list of articles and books, looking for all of the ones that have both Kansas and wheat in the list of key words.\par Let's put these ideas to work in a simple parser to move a spot around on the screen.  The parser is shown in listing 13.2. We are creating a simple robotic control language to move an object around.  It would be natural for a person to use a variety of words to describe a direction, and a variety of words to describe movement.  For movement, our parser will recognize go and move.  For directions, it will recognize left, right, up, down, north, south, east and west.  It is the parser's job to make things easy for the main program, so it will report only one value for each direction.  We also need a way to quit, so we will add the verb quit to the parser.  Quit does not have a subject; it simply means that we are finished.  Stop will also be recognized as another form of quit.  Our parser assumes that the scanner is converting all characters to uppercase, and that the scanner reads and processes one line at a time, rather than an entire file.  In the GetAction subroutine that does the parsing, pay special attention to how none and nada are used to indicate that nothing has been found yet.  These "empty" values simplify the program quite a bit.\par \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {\b Listing 13.2\par \par }\pard\plain \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright \f6\fs20\cgrid {                                        /* command subjects */\par typedef enum \{none, up, down, left, right\} subjectType;\par typedef enum \{nada, go, stop\} verbType; /* commands */\par \par void GetAction (void)\par \par /* Find out what the player wants to do                         */\par /*                                                              */\par /* Variables:                                                   */\par /*    verb - action to take                                     */\par /*    subject - what we do the action to or with                */\par \par \{\par int done = 0;                       /* loop exit variable */\par \par do \{\par    scanf("%255[^\\n]%*1[\\n]", cline); /* get a line */\par    lineIndex = 0;\par    verb = nada;                     /* start with no subject,verb */\par    subject = none;\par    do \{\par       GetToken();                   /* get a token */\par                                     /* handle a subject */\par       if ((strcmp(token, "NORTH") == 0)\par          || (strcmp(token, "UP") == 0))\par          subject = up;\par       else if ((strcmp(token, "SOUTH") == 0)\par          || (strcmp(token, "DOWN") == 0))\par          subject = down;\par       else if ((strcmp(token, "EAST") == 0)\par          || (strcmp(token, "RIGHT") == 0))\par          subject = right;\par       else if ((strcmp(token, "WEST") == 0)\par          || (strcmp(token, "LEFT") == 0))\par          subject = left;\par                                     /* handle a verb */\par       else if ((strcmp(token, "QUIT") == 0)\par          || (strcmp(token, "STOP") == 0))\par          verb = stop;\par       else if ((strcmp(token, "GO") == 0)\par          || (strcmp(token, "MOVE") == 0))\par          verb = go;\par       \}\par    while (strlen(token));\par \par    switch (verb) \{                 /* make sure the input is consistent */\par       case nada:\par          printf("Please tell me what to do (go or stop).\\n");\par          break;\par \par       case stop:\par          done = 1;\par          break;\par \par       case go:\par          if (subject == none)\par             printf("Please tell me which way to go.\\n");\par          else\par             done = 1;\par          break;\par       \}\par    \}\par while (!done);\par \}\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par }\pard\plain \qj\fi360\widctlpar\adjustright \f4\cgrid {\par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {This is a simple example of a parser.  As the number of subjects and verbs increases, the number of rules that are used to combine them also goes up.  Some subjects will apply only to certain verbs.  In our program, we have an example of a verb, quit, that doesn't even have a subject.  Some programs also allow subjects with no verb.  For example, the adventure game Zork lets you type north, with no verb, to move north.  As the possibilities grow, programmers start to use other techniques besides writing if statements for each possibility.  Arrays can be used for moderate numbers of subjects and verbs.  You index into the array by the subject and verb to find out which subroutine to call.  For even more complex programs, techniques for writing rule-based programs can be used.  In short, this subroutine gives you some basic ideas you can use to write a program that reads text.  If you will be writing large programs using these ideas, though, you should spend some time looking at the more advanced techniques before starting your program.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 13.3. }{ Write a program to move a spot in the graphics window.  The program should use a modified form of the GetToken parser that reads characters from a line, instead of a file.  GetToken should also uppercase all of the characters in a token.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {With these changes in mind, the business end of the main program should include a main loop that looks like this:\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {do\par    GetAction();\par    if (verb == go) \{\par       DrawPoint(x,y,3);\par       switch (subject) \{\par          case up:\par             y -= MOVEY;\par             break;\par          case down:\par             y += MOVEY;\par             break;\par          case left:\par             x -= MOVEX;\par             break;\par          case right:\par             x += MOVEX;\par             break;\par          \}\par       DrawPoint(x,y,0);\par       \}\par    \}\par while (verb != stop);\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {DrawPoint, of course, is the subroutine that actually draws the spot you are moving.  You pass the location and color of the spot.  MOVEX and MOVEY are constants that tell how far to move the spot.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Be sure you remember to initialize x and y, and draw the initial spot, before the program starts.\par }\pard\plain \qc\widctlpar\adjustright \f4\cgrid {\b\fs36 \par \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \qc\widctlpar\adjustright \f4\cgrid {\b\fs36 Lesson Thirteen\par Solutions to Problems\par }\pard \qj\widctlpar\adjustright {\b\fs28 \par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344599}Solution to problem 13.1.{\*\bkmkend _Toc496344599}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Write the words in a file */\par \par #include <stdio.h>\par #include <ctype.h>\par \par #define MAXLENGTH 30                    /* length of a word */\par #define FNAME "prob.13.1.cc"            /* file name to scan */\par \par char token[MAXLENGTH];                  /* last word read */\par char ch = ' ';                          /* last character read */\par FILE *f;                                /* source file */\par \par \par void GetToken(void)\par \par /* Read a word from the source file                             */\par /*                                                              */\par /* Variables:                                                   */\par /*    f - source file                                           */\par /*    token - string read                                       */\par \par \{\par int len = 0;                            /* length of the string */\par \par while ((! isalpha(ch)) && (ch != EOF))  /* skip to the first character */\par    ch = fgetc(f);\par while ((ch != EOF) && (isalpha(ch))) \{  /* read the word */\par    if (len < MAXLENGTH-1) \{\par       token[len] = ch;\par       ++len;\par       \}\par    ch = fgetc(f);\par    \}\par token[len] = (char) 0;                  /* set the null terminator */\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void main(void)\par \par /* main program                                                 */\par \par \{\par f = fopen(FNAME, "r");                  /* open the file */\par }\pard \s23\qj\fi360\widctlpar\adjustright {if (f == NULL) \{\par    printf("Could not open %s.\\n", FNAME);\par    return;\par    \}\par do \{                                    /* scan the file */\par    GetToken();\par    if (strlen(token))\par       printf("%s\\n", token);\par    \}\par while (strlen(token));\par fclose(f);                              /* close the file */\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344600}Solution to problem 13.2.{\*\bkmkend _Toc496344600}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Write the number of times a word occurs in a file */\par \par #include <stdio.h>\par #include <stdlib.h>\par #include <string.h>\par #include <ctype.h>\par \par #define MAXLENGTH 30                    /* length of a word */\par #define FNAME "prob.13.2.cc"            /* file name to scan */\par \par typedef struct symbolStruct \{           /* symbol table entry */\par    struct symbolStruct *next;           /* ptr to next entry */\par    int count;                           /* # of occurrences */\par    char symbol[MAXLENGTH];              /* symbol */\par    \}\par    symbolStruct;\par \par typedef symbolStruct *symbolPtr;        /* ptr to a symbol table entry */\par \par char token[MAXLENGTH];                  /* last word read */\par char ch = ' ';                          /* last character read */\par symbolPtr table = NULL;                 /* the symbol table */\par FILE *f;                                /* source file */\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void GetToken(void)\par \par /* Read a word from the source file                             */\par /*                                                              */\par }\pard \s23\qj\fi360\widctlpar\adjustright {/* Variables:                                                   */\par /*    f - source file                                           */\par /*    token - string read                                       */\par \par \{\par int len = 0;                            /* length of the string */\par \par while ((! isalpha(ch)) && (ch != EOF))  /* skip to the first character */\par    ch = fgetc(f);\par while ((ch != EOF) && (isalpha(ch))) \{  /* read the word */\par    if (len < MAXLENGTH-1) \{\par       token[len] = ch;\par       ++len;\par       \}\par    ch = fgetc(f);\par    \}\par token[len] = (char) 0;                  /* set the null terminator */\par \}\par \par \par void Insert (void)\par \par /* Insert a word in the symbol table                            */\par /*                                                              */\par /* Variables:                                                   */\par /*    token - symbol                                            */\par /*    table - pointer to the first element in the symbol        */\par /*       table                                                  */\par \par \{\par symbolPtr ptr;                          /* work pointer */\par int len;                                /* length of the string */\par \par ptr = table;                        /* see if the symbol already exists */\par while (ptr != NULL) \{\par    if (strcmp(ptr->symbol, token) == 0) \{\par       ++ptr->count;                 /* yes -> update the count and exit */\par       return;\par       \}\par    ptr = ptr->next;\par    \}\par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {                                        /* no -> create a new entry */\par ptr = (symbolPtr) malloc(sizeof(symbolStruct));\par ptr->next = table;\par table = ptr;\par ptr->count = 1;\par }\pard \s23\qj\fi360\widctlpar\adjustright {strcpy(ptr->symbol, token);\par \}\par \par \par void PrintSymbols (void)\par \par /* Print the symbol table                                       */\par /*                                                              */\par /* Variables:                                                   */\par /*    table - pointer to the first element in the symbol        */\par /*       table                                                  */\par \par \{\par symbolPtr ptr;                          /* work pointer */\par \par ptr = table;\par while (ptr != NULL) \{\par    printf("%10d  %s\\n", ptr->count, ptr->symbol);\par    ptr = ptr->next;\par    \}\par \}\par \par \par void main(void)\par \par /* main program                                                 */\par \par \{\par f = fopen(FNAME, "r");                  /* open the file */\par if (f == NULL) \{\par    printf("Could not open %s.\\n", FNAME);\par    return;\par    \}\par do \{                                    /* scan the file */\par    GetToken();\par    if (strlen(token))\par       Insert();\par    \}\par while (strlen(token));\par PrintSymbols();                         /* print the symbol table */\par fclose(f);                              /* close the file */\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344601}Solution to problem 13.3.{\*\bkmkend _Toc496344601}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Move a "robot" around on the graphics screen */\par \par #include <stdio.h>\par #include <ctype.h>\par #include <string.h>\par \par #include <quickdraw.h>\par \par #define MAXLENGTH 10                    /* length of a word */\par #define MAXLINE 256                     /* max length of a line */\par #define MOVEX 30                        /* distance of one move */\par #define MOVEY 10\par \par                                         /* command subjects */\par typedef enum \{none, up, down, left, right\} subjectType;\par typedef enum \{nada, go, stop\} verbType; /* commands */\par \par char cline[MAXLINE];                    /* command line */\par int lineIndex;                          /* index of next char in line */\par char token[MAXLENGTH];                  /* last word read */\par \par subjectType subject;                    /* subject of the last command */\par verbType verb;                          /* verb of the last command */\par \par \par void GetToken(void)\par \par /* Read a word from the command line                            */\par /*                                                              */\par /* Variables:                                                   */\par /*    f - source file                                           */\par /*    cline - source line                                       */\par /*    lineIndex - index to next char in source line             */\par \par \{\par int len = 0;                            /* length of the string */\par \par                                         /* skip to the first character */\par while ((! isalpha(cline[lineIndex])) && (lineIndex <= strlen(cline)))\par    ++lineIndex;\par                                         /* read the word */\par while ((lineIndex <= strlen(cline)) && (isalpha(cline[lineIndex]))) \{\par    if (len < MAXLENGTH-1) \{\par       token[len] = toupper(cline[lineIndex]);\par       ++len;\par       \}\par    ++lineIndex;\par    \}\par token[len] = (char) 0;                  /* set the null terminator */\par \}\par \par \par void GetAction (void)\par \par /* Find out what the player wants to do                         */\par /*                                                              */\par /* Variables:                                                   */\par /*    verb - action to take                                     */\par /*    subject - what we do the action to or with                */\par \par \{\par int done = 0;                           /* loop exit variable */\par \par do \{\par    scanf("%255[^\\n]%*1[\\n]", cline);    /* get a line */\par    lineIndex = 0;\par    verb = nada;                         /* start with no subject,verb */\par    subject = none;\par    do \{\par       GetToken();                       /* get a token */\par                                         /* handle a subject */\par       if ((strcmp(token, "NORTH") == 0)\par          || (strcmp(token, "UP") == 0))\par          subject = up;\par       else if ((strcmp(token, "SOUTH") == 0)\par          || (strcmp(token, "DOWN") == 0))\par          subject = down;\par       else if ((strcmp(token, "EAST") == 0)\par          || (strcmp(token, "RIGHT") == 0))\par          subject = right;\par       else if ((strcmp(token, "WEST") == 0)\par          || (strcmp(token, "LEFT") == 0))\par          subject = left;\par                                         /* handle a verb */\par       else if ((strcmp(token, "QUIT") == 0)\par          || (strcmp(token, "STOP") == 0))\par          verb = stop;\par       else if ((strcmp(token, "GO") == 0)\par          || (strcmp(token, "MOVE") == 0))\par          verb = go;\par       \}\par    while (strlen(token));\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {   switch (verb) \{                 /* make sure the input is consistent */\par       case nada:\par          printf("Please tell me what to do (go or stop).\\n");\par          break;\par \par }\pard \s23\qj\fi360\widctlpar\adjustright {      case stop:\par          done = 1;\par          break;\par \par       case go:\par          if (subject == none)\par             printf("Please tell me which way to go.\\n");\par          else\par             done = 1;\par          break;\par       \}\par    \}\par while (!done);\par \}\par \par \par void DrawPoint (int x, int y, int color)\par \par /* Draw the robot                                               */\par /*                                                              */\par /* Parameters:                                                  */\par /*    x,y - position of the robot                               */\par /*    color - robot color                                       */\par \par \{\par SetSolidPenPat(color);\par SetPenMode(0);\par SetPenSize(9,3);\par MoveTo(x,y);\par LineTo(x,y);\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void main(void)\par \par /* main program                                                 */\par \par \{\par int x = 60, y = 20;                     /* position of the robot */\par \par DrawPoint(x, y, 0);\par do \{\par    GetAction();                  /* find out what we are supposed to do */\par    if (verb == go) \{                   /* if it is a movement then move */\par       DrawPoint(x, y, 3);               /* erase the old robot */\par       switch (subject) \{                /* move the robot */\par          case up:       y -= MOVEY;\par                         break;\par          case down:     y += MOVEY;\par                         break;\par }\pard \s23\qj\fi360\widctlpar\adjustright {         case left:     x -= MOVEX;\par                         break;\par          case right:    x += MOVEX;\par                         break;\par          \}\par       DrawPoint(x, y ,0);             /* draw the robot in the new spot */\par       \}\par    \}\par while (verb != stop);\par \}\par }\pard\plain \widctlpar\adjustright \f4\cgrid {\par \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s1\qc\nowidctlpar\outlinelevel0\adjustright \b\f4\fs36\cgrid {{\*\bkmkstart _Toc496344602}Lesson Fourteen{\*\bkmkend _Toc496344602}\par {\*\bkmkstart _Toc496344603}Recursion{\*\bkmkend _Toc496344603}\par }\pard\plain \qj\widctlpar\adjustright \f4\cgrid {\b\fs28 \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344604}A Quick Look at Recursion{\*\bkmkend _Toc496344604}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {By now, you are well acquainted with defining and calling functions.  An interesting point about functions that we haven't talked about, and that you may not have noticed, is that a function can call itself.  After all, the definition of the function comes before the statements, so the function has been defined.  The ability of a function to call itself opens up a whole new concept in programming, called recursion.\par We will start our look at recursion using a simple example.  The purpose of this first section is to tell you about the mechanics of recursion.  You will learn a little about stack frames, and use the debugger to investigate how stack frames work.  With the mechanics out of the way, we will look at recursion as a problem solving technique, solving the classic problem of the Towers of Hanoi.  We will then combine recursion with a simple scanner, like the ones you wrote in the last lesson, to create a recursive descent expression evaluator.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344605}How Functions Call Themselves{\*\bkmkend _Toc496344605}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Let's start by looking at a short program.  This program multiplies two positive integers.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par int Mult (int x, int y)\par \par \{\par if (y)\par    return Mult(x, y-1) + x;\par return 0;\par \}\par \par void main(void)\par \par \{\par printf("%d\\n", Mult(4,5));\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Let's face it, that's a pretty weird looking program.  To understand how it works, we will start by tracing through the program.  It would be a great idea to fire up the debugger and follow along on the computer.\par Stepping through the program, the first thing that happens is Mult gets called with x = 4 and y = 5.  After testing to see if y is zero, the subroutine executes this statement:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {return Mult(x, y-1) + x;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {This statement returns x*y, but it does it in a rather strange way.  If you think about it, you know that x*y is the same thing as x*(y-1)+x; for example, 4*5 is the same thing as 4*4+4.  The program is using the fact to gradually make the problem simpler.  It calls itself to find out what 4*4 is, and then adds 4 and returns the answer.\par }\pard \s21\qj\fi360\widctlpar\adjustright {Try running the program again, but this time, when you get into the subroutine, use the debugger to display x and y; the debugger will show 4 and 5, respectively.  Continue to single step through the program until the function calls itself again.  The values for x and y vanish from the variables window.  Enter them again.  This time, the debugger shows that the values are 4 and 4, instead of 4 and 5.\par The reason that the variable names disappeared when Mult called itself is because a new stack frame was created.  A stack frame is a piece of dynamically allocated memory that the program reserves each time a function is called; the stack frame contains all of the auto variables in the function.  This memory has a few housekeeping values that tell the compiler who to return to, as well as the parameters that are passed, and any locally declared variables.  When Mult calls itself, a new stack frame is created.  As with the first time the function is called, you need to tell the compiler which variables you want to look at.\par A very crucial point is that the old stack frame still exists.  In the old stack frame, y has a value of 5.  To see the old stack frame, click on the up arrow in the variables window.\par You can continue this process, single stepping through the subroutine until the final call, when y is set to 0.  At this point, there are a total of six stack frames for the Mult function, each with a different value of y.  Still, nothing has been returned.  This time, though, the function does something different.  Instead of calling itself again, the function returns 0.  After returning, x is added to the zero that is returned, and the function returns again.  This continues until the original stack frame is reached.  At that point, the function returns the result of 20.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 14.1. }{ The example showed you how to do a multiplication using recursion.  Basically, the program made use of the fact that, when n is any number greater than 0, m*n gives the same result as m*(n-1)+m.  You can find the exponent of a number the same way.  For example, 2^3 (2 raised to the power 3) is 8, or 2*2*2.  This is the same as (2^2)*2.  Change the program so it calculates an exponent, given two integers as input.  Use it to verify that 5^4 is 625.  As with the addition example, be sure and step through the program with the debugger.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344606}Recursion is a Way of Thinking{\*\bkmkend _Toc496344606}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Looking at all of those stack frames, I don't think it will be hard to convince you that you can't think about recursion the same way you think about if statements, do loops, and so forth.  You will get so tangled up the the details of keeping track of all of the stack frames that you will forget what you are trying to accomplish.  You may start to think that anyone that understands recursion must have a mind that would have made Einstein envious.  I've watched a number of beginning programmers who would agree as they struggled with recursion, trying to analyze all of those stack frames, and keep track of all of those variables.  It reminds me of the time I opened the course outline for Classical Mechanics in college and saw, on the front page of the outline, in the middle of the page, boldfaced, the following quote:  "Any problem, no matter how difficult, can be made still more difficult by looking at it in the right way."\par No kidding.\par Once you understand that stack frames exist, and that they hold different copies of the variables, you should never trace through a recursive subroutine, trying to follow the stack frames, again.  If you do, you are simply thinking about the problem the wrong way.\par Instead, think about a piece of the problem, not the whole thing.  Instead of thinking about the multiply as a series of function calls, look at what happens on any particular call.  For the multiply function, there are two possibilities:  either y is zero, or it is not.  As you know, zero multiplied by any other number is still zero, so we know it is correct for the function to return zero if y is zero.  If y is not zero, we apply a simple rule:  x*y is the same as x*(y-1) + x.  So, what is x*(y-1)?  We don't know.  More important, we don't care.  The rule works all of the time, so we truly don't have to worry about what x*(y-1) is; a call to a correct multiply routine gives us that answer.  With the answer to x*(y-1) in hand, we add x and return the correct answer for x*y.  The crucial point to remember is that we don't try to trace through the morass of function calls to see what x*(y-1) will give us:  we recognize that if the function returns the correct value for one terminal case, in our example when y = 0, and that if it returns the correct answer for x and y, assuming that x*(y-1) is done correctly, that it must return the correct answer all of the time.  Mathematicians call this a proof by induction.\par A good way to keep this in mind is to remember that any recursive subroutine must satisfy two conditions to work.  First, it has to have a way to stop.  In the case of the multiply subroutine, we stopped when y reached zero.  Second, each call must move you closer to the stopping place than you were when the subroutine was called.  In our multiply subroutine, any call that was made with y greater than 0 reduced y.\par Let's put these ideas to work to solve a classic puzzle, the Towers of Hanoi.  This is a puzzle that quickly befuddles anyone who tries to solve it iteratively, the way you have been writing programs up until this lesson.  The puzzle starts with six disks, all of a different size, sitting on one of three pegs, like this:\par }\pard \s21\qj\widctlpar\adjustright {\par }\pard\plain \li360\ri5040\widctlpar\adjustright \f4\cgrid {\f12\fs20 {\pict{\*\picprop\shplid1025{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 268435473}}{\sp{\sn fFilled}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex54\picscaley54\piccropl0\piccropr0\piccropt0\piccropb0\picw312\pich69\picwgoal6240\pichgoal1380\macpict\bliptag2114089239\blipupi72{\*\blipuid 7e027117cdc0046b0a10753b80d7c720}007d00070007004c013f1101a0008201000a00070007004c013f0700040004220008003e003f22000800bc003f220008013a003f0a000000000000000034003e0008004b00783834003500110042006f3834002c001a003900663834002300230030005d3834001a002c00270054383400110035001e004b38a00083ff00}}{\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {The object is to move all of the disks from the left-hand peg to the right-hand peg.  On each turn, you can move only one disk.  The only other restriction is that you can never cover one disk with a larger disk.  Stop and try this before going on.  You can cut the six disks from pieces of paper, and stack them on your desk instead of using pegs.\par }\pard \s21\qj\fi360\widctlpar\adjustright {So, did you solve the puzzle iteratively?  Even if you didn't make any mistakes, it takes 63 different moves to solve the puzzle.  Can you keep that many moves straight in your head?  If so, you have a better mind than mine.\par The way to solve the puzzle is to turn it around.  Instead of trying to move the top disk, you have to realize that the real problem is to move the bottom disk!  The goal is to move the top five disks from the first peg to the second, like this:\par }\pard\plain \qj\fi360\widctlpar\adjustright \f4\cgrid {\par }\pard \qj\li360\widctlpar\adjustright {\f12\fs20 {\pict{\*\picprop\shplid1026{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 268435473}}{\sp{\sn fFilled}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex57\picscaley57\piccropl0\piccropr0\piccropt0\piccropb0\picw312\pich69\picwgoal6240\pichgoal1380\macpict\bliptag-830821160\blipupi72{\*\blipuid ce7aacd8d8c3c032818bbf6e4280be23}007d00070007004c013f1101a0008201000a00070007004c013f0700040004220008003e003f22000800bc003f220008013a003f0a000000000000000034003e0008004b00783834003e008f004b00ed383400350098004200e43834002c00a1003900db3834002300aa003000d23834001a00b3002700c938a00083ff00}}{\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {The next step is to move the bottom disk to the third peg.\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \qj\li900\widctlpar\adjustright \f4\cgrid {\f12\fs20 {\pict{\*\picprop\shplid1033{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 268435473}}{\sp{\sn fFilled}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex57\picscaley57\piccropl0\piccropr0\piccropt0\piccropb0\picw312\pich69\picwgoal6240\pichgoal1380\macpict\bliptag-2044240256\blipupi72{\*\blipuid 86275e80e3a92d4e34baf6fb1458c52d}007d00070007004c013f1101a0008201000a00070007004c013f07000400042200080008003f2200080086003f2200080104003f0a000000000000000034003e0059004b00b7383400350062004200ae3834002c006b003900a53834002300740030009c3834001a007d002700933834003e00ce004b013e38a00083ff00}}{\par }\pard\plain \s21\qj\widctlpar\adjustright \f4\fs20\cgrid {\par The last step is to move the pile of five disks from the second peg to the third.\par \par }\pard\plain \qj\li900\ri5040\widctlpar\adjustright \f4\cgrid {\f12\fs20 {\pict{\*\picprop\shplid1034{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 268435473}}{\sp{\sn fFilled}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex57\picscaley57\piccropl0\piccropr0\piccropt0\piccropb0\picw312\pich69\picwgoal6240\pichgoal1380\macpict\bliptag-1128558918\blipupi72{\*\blipuid bcbb8ebaa0b82c374b6cd7d188e3ccbb}007d00070007004c013f1101a0008201000a00070007004c013f07000400042200080008003f2200080086003f2200080104003f0a000000000000000034003e00ce004b013e3834003500d7004201353834002c00e00039012c3834002300e9003001233834001a00f20027011a3834001100fb001e011138a00083ff00}}{\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Expressing this as a C function, we get something like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {void Tower (int fromPeg,\par             int toPeg,\par             int sparePeg,\par             int count);\par \par \{\par if (count) \{\par    Tower(fromPeg, sparePeg,\par       toPeg, count-1);\par    Move(fromPeg, toPeg);\par    Tower(sparePeg, toPeg,\par       fromPeg, count-1);\par    \}\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {Move, of course, is a subroutine that takes the top disk from one peg and places it on another.  We could represent the different pegs as three arrays, one for each peg, with six spots in each array.  Each spot could be empty, or it might have one of the disks.\par }\pard \s21\qj\fi360\widctlpar\adjustright {The important thing to recognize is that we haven't worried about how to move five disks from the first peg to the second.  We know that if we can move six disks by first moving the top five, then moving the bottom disk, and finally moving the top five disks again, that we can use exactly the same idea to move the five disks.  After all, to move five disks, we start by moving four of them to the spare peg, then we move the bottom disk, and finally we move the four disks to the correct peg.  To move four disks... well, you get the idea.  Eventually, we end up with the trivial problem of moving one disk.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 14.2. }{ Write a program that solves the Towers of Hanoi problem.  Draw the disks in the graphics window as they are moved around by the call to Move.\par \par }{\b Problem 14.3.}{  Recursion can be used to process a linked list in reverse order.  To see this idea in action, write a program that builds a linked list, stuffing the numbers 1 to 10 in the records, like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {for (i = 1; i <= 10; ++i) \{\par    ptr = (listPtr)\par       malloc(sizeof(listStruct));\par    ptr->next = list;\par    ptr->value = i;\par    list = ptr;\par    \}\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {Next, write a recursive function that prints the values in the list.  On each call, the recursive function should return if the pointer that is passed to it is NULL.  If the pointer is not NULL, the function should call itself, then print the current value, like this:\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {Print(ptr->next);\par printf("%d\\n", ptr->value);\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s24\qj\li360\widctlpar\adjustright {After you write the program, reverse the last two statements, and run it again.  This time, the program prints the numbers in reverse order.  Make sure you understand why, tracing a few iterations with the debugger if you need to.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344607}A Practical Application of Recursion{\*\bkmkend _Toc496344607}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {In the last lesson, we looked briefly at scanners and parsers.  One of the easiest kind of parser to implement is called a recursive descent parser.  To see how recursion can be used in a parser, we will solve a problem that had computer scientists stumped for a long time back in the early days of computing, when they were trying to write the first compilers.  The problem is to solve a mathematically expressed equation.\par For example, you know that\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {(4+5)*(1+2)\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {is evaluated by adding the terms in parenthesis first, then doing the multiply.  How can we write a program that can do this?  It's not an idle problem: over the years I have been asked to write a number of programs that had to solve an equation like this one.  The problem doesn't just crop up in computer languages, either.  You need to solve equations in math programs that graph functions, in spread sheets, and even in some databases.\par }\pard \s21\qj\fi360\widctlpar\adjustright {To see how to solve this problem, we will write a simple expression evaluator that can add, subtract, multiply and divide.  It will accept integer numbers and parenthesis.  Just as in algebra and C, add and subtract will have the same precedence, and multiply and divide will have the same precedence, but multiply and divide have a higher precedence than add or subtract.\par To get a grasp on how the expression evaluator will work, let's look at this expression:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {4*5 + 9/2 - 6\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {To solve this expression by hand, we would first scan through, doing all of the multiply and divide operations, leaving only numbers and the add and subtract operations.\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {20 + 4 - 6\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {This equation can be solved by working from left to right, adding and subtracting each new value to the old value.  Thinking recursively, we can solve this equation by calling a function to do all of the stuff besides addition and subtraction, then checking to see if there is an add or subtract operation, and finally looping.  In true recursive style, not to mention structured programming style, we won't worry about how the subroutine that does the multiplies and divides works.  Instead, we solve the smaller problem.  Here is our solution, a function that calls another function, Factor, to read numbers, do multiplication, and handle parenthesis, does the adds and subtracts that are left over, and returns the result.  Our function assumes that the main program calls GetToken one time to collect the first token from the input line before Expression is called; this is a very common technique in recursive descent parsers.\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {int Expression (void)\par \par \{\par int value, newValue;\par tokenType operation;\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {value = Factor();\par while ((token == add)\par    || (token == subtract)) \{\par    operation = token;\par    GetToken();\par    newValue = Factor();\par    if (operation == add)\par       value += newValue;\par    else\par       value -= newValue;\par    \}\par return value;\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Let's trace through this function with our sample expression,\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {20 + 4 - 6\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {to see how it works.  When the function is called, the main program has already called GetToken, so the global variable token already has a value.  It is holding an integer whose value is 20.  So far, the function Factor doesn't have to do much.  It just checks to be sure that token is an integer value, returns the value, and reads in the next token.  When we get to the start of the while loop, then, value is 20.  The + character has been read, and token has been set to add.\par }\pard \s21\qj\fi360\widctlpar\adjustright {At the start of the while loop, we save the operation in a variable called, surprisingly enough, operation, and read the next number.  If there is an operation, there must be a number after it.  We'll trust Factor to flag an error if the number is missing.  We then call Factor to get the next number, skipping the number token in the process, and do the operation.  At the end of the while loop, value is 24, and token is subtract.  One more pass through the while loop finishes off the expression, and we return a final value of 30.\par The next step is to handle multiplication and division.  That's no trick, really.  They work the same way addition and subtraction do!  In this case, we will call a function called Term to handle numbers and parenthesis.  Everything else is an echo of the function that handles addition and subtraction.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {int Factor (void)\par \par \{\par int value, newValue;\par }\pard \s23\qj\fi360\widctlpar\adjustright {tokenType operation;\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {value = Term();\par while ((token == multiply)\par    || (token == divide)) \{\par    operation = token;\par    GetToken();\par    newValue = Term();\par    if (operation == multiply)\par       value *= newValue;\par    else\par       value /= newValue;\par    \}\par return value;\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Trace through our sample equation\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {4*5 + 9/2 - 6\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {to see how Factor works, and how Factor and Expression work together to make sure the operations are done in the correct order.  For this short example, keeping track of the global variables term and token on a piece of paper should work out well.\par }\pard \s21\qj\fi360\widctlpar\adjustright {The last step is to write the subroutine that handles numbers.  There is one other thing that can appear at this point, though, and that is a parenthesis.  Term handles that particular problem by calling Expression to evaluate whatever appears between the parenthesis!  Expression can then call Factor, which will call Term, and so forth.  This recursive call is what allows our expression handler to handle very complex equations.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {int Term (void)\par \par \{\par int val;\par \par if (token == integer) \{\par    val = tokenValue;\par    GetToken();\par    \}\par else if (token == lparen) \{\par    GetToken();\par    val = Expression();\par    if (token == rparen)\par       GetToken();\par    else\par       printf(") expected\\n");\par    \}\par return val;\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Take a close look at the error message that is printed if Term finds an opening parenthesis, but no closing parenthesis.  Does it look familiar?  If not, you might glance through the list of error messages at the end of the ORCA/C manual.  Now you know where those error messages come from!\par There is one minor detail that you need to deal with at this point.  Looking at our functions, you can see that Expression calls Factor, so it is natural to put Factor before Expression so the compiler can check our parameter lists.  Factor calls Term, so term should go before Factor.  Term calls Expression, so... oops.\par The problem, of course, is that you can't put these functions in any order where each function is declared before it is used.  To solve this problem, we use exactly the same technique that we used with separate compilation: we declare the function Expression before the function Factor, like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {int Expression (void);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {but we still put the body of the Expression function after Factor and Term.  That way, the compiler can check to be sure Expression is called correctly in Term, and it can even check to be sure the parameters for the function definition (the place we put the statements) match the parameters for the function declaration (the line you just saw).\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 14.4. }{ Write a program to evaluate an expression and write the value.  Your program should handle addition, subtraction, multiplication, division, and parenthesis.  All operations should be on integers.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Your program should start by prompting the user for an expression.  It should then call GetToken to fetch the first token from the line, followed by a call to Expression to evaluate the expression.  The program should loop repeatedly, reading new expressions, until the line typed by the user is a null string.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {While the text did not cover writing the GetToken subroutine, all of the concepts were covered in the last lesson.  Try to write GetToken on your own; if you get stuck, refer to the solution.\par }\pard\plain \qc\widctlpar\adjustright \f4\cgrid {\b\fs36 \par \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \qc\widctlpar\adjustright \f4\cgrid {\b\fs36 Lesson Fourteen\par Solutions to Problems\par }\pard \qj\widctlpar\adjustright {\b\fs28 \par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {Solution to problem 14.1.\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#include <stdio.h>\par \par int Exp (int x, int y)\par \par \{\par if (y)\par    return Exp(x, y-1) * x;\par return 1;\par \}\par \par void main(void)\par \par \{\par printf("%d\\n", Exp(5,4));\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {Solution to problem 14.2.\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Graphic solution to the Towers of Hanoi puzzle. */\par \par #include <quickdraw.h>\par \par #define DISKS 6                         /* # of disks to move */\par \par typedef int peg[DISKS];                 /* one peg, with contents */\par \par peg pegs[3];                            /* all three pegs */\par \par \par void DrawDisk (int disk, int peg, int height, int color)\par \par /* Draw a disk on the screen                                    */\par /*                                                              */\par /* Parameters:                                                  */\par /*    disk - disk (i.e. size) to draw                           */\par /*    peg - peg to draw the disk on                             */\par /*    height - distance from the bottom of the pile             */\par /*    color - color to draw the disk                            */\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {\{\par int x,y;                          /* position of the center of the disk */\par \par x = peg*80 + 40;                        /* find the position */\par }\pard \s23\qj\fi360\widctlpar\adjustright {y = 50 - height*4;\par SetSolidPenPat(color);                  /* set the pen color */\par MoveTo(x - disk*5, y);                  /* draw the disk */\par LineTo(x + disk*5, y);\par \}\par \par \par void Move (int fromPeg, int toPeg)\par \par /* Move a disk                                                  */\par /*                                                              */\par /* Parameters:                                                  */\par /*    fromPeg - peg to move the disk from                       */\par /*    toPeg - peg to move the disk to                           */\par \par \{\par int i;                                  /* peg array index */\par int disk;                               /* disk being moved */\par \par i = DISKS-1;                            /* find the disk to move */\par while (pegs[fromPeg][i] == 0)\par    --i;\par disk = pegs[fromPeg][i];                /* remove the disk */\par pegs[fromPeg][i] = 0;\par DrawDisk(disk, fromPeg, i, 3);          /* erase the disk */\par i = 0;                                /* find the new spot for the disk */\par while (pegs[toPeg][i] != 0)\par    ++i;\par pegs[toPeg][i] = disk;                  /* place the disk on the peg */\par DrawDisk(disk, toPeg, i, 0);            /* draw the disk */\par \}\par \par \par void Tower(int fromPeg, int toPeg, int sparePeg, int count)\par \par /* Move count pegs from peg # fromPeg to peg # toPeg            */\par /*                                                              */\par /* Parameters:                                                  */\par /*    fromPeg - peg to move the disks from                      */\par /*    toPeg - peg to move the disks to                          */\par /*    sparePeg - unused peg                                     */\par /*                                                              */\par /* Variables:                                                   */\par /*    pegs - the current content of each peg                    */\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {\{\par }\pard \s23\qj\fi360\widctlpar\adjustright {if (count) \{\par    Tower(fromPeg, sparePeg, toPeg, count-1);\par    Move(fromPeg, toPeg);\par    Tower(sparePeg, toPeg, fromPeg, count-1);\par    \}\par \}\par \par \par void main (void)\par \par /* main program                                                 */\par \par \{\par int i;                                  /* loop variable */\par \par SetPenMode(0);                          /* initialize the graphics pen */\par SetPenSize(8,3);\par for (i = 0; i < DISKS; ++i) \{           /* set up the game */\par    pegs[0][i] = DISKS-i+1;\par    pegs[1][i] = 0;\par    pegs[2][i] = 0;\par    DrawDisk(pegs[0][i], 0, i, 0);\par    \}\par Tower(0, 2, 1, DISKS);                  /* move the disks */\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344608}Solution to problem 14.3.{\*\bkmkend _Toc496344608}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Use recursion to reverse the elements in a linked list */\par \par #include <stdio.h>\par #include <stdlib.h>\par \par typedef struct listStruct \{             /* element in the list */\par    struct listStruct *next;\par    int value;\par    \}\par    listStruct,\par    *listPtr;\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void Print (listPtr ptr)\par \par /* Print the values in the list in reverse order                */\par \par \{\par if (ptr != NULL) \{\par    Print(ptr->next);\par    printf("%d\\n", ptr->value);\par }\pard \s23\qj\fi360\widctlpar\adjustright {   \}\par \}\par \par \par void main (void)\par \par /* main program                                                 */\par \par \{\par int i;                                  /* loop variable */\par listPtr list;                           /* the list */\par listPtr ptr;                            /* work pointer */\par \par for (i = 1; i <= 10; ++i) \{             /* create the list */\par    ptr = (listPtr) malloc(sizeof(listStruct));\par    ptr->next = list;\par    ptr->value = i;\par    list = ptr;\par    \}\par Print(list);                            /* print the list */\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344609}Solution to problem 14.4.{\*\bkmkend _Toc496344609}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* A simple, recursive descent expression evaluator.  This       */\par /* program handles +, -, * and /, as well as parenthesis.  All   */\par /* operations are integer operations.                            */\par \par #include <stdio.h>\par #include <string.h>\par #include <ctype.h>\par \par typedef enum tokenType                  /* tokens in an expression */\par    \{add,subtract,multiply,divide,integer,lparen,rparen,eol\}\par    tokenType;\par \par char ch;                                /* last char read by GetCh */\par int index;                              /* index into str */\par char str[81];                          /* string read from the keyboard */\par tokenType token;                        /* last token read */\par int tokenValue;                         /* value of last integer token */\par \par \par void GetCh (void)\par \par /* Read the next character from str                             */\par /*                                                              */\par /* Variables:                                                   */\par /*    ch - char read; 0 if at the end of the string             */\par /*    index - index into str                                    */\par /*    str - string to read the character from                   */\par \par \{\par if (index >= strlen(str))\par    ch = 0;\par else \{\par    ch = str[index];\par    ++index;\par    \}\par \}\par \par \par void GetToken (void)\par \par /* Read a token from the input string                           */\par \par \{\par while (ch == ' ')                   /* skip to the first real character */\par    GetCh();\par if (ch == 0) \{                          /* handle an end of line */\par    token = eol;\par    return;\par    \}\par if (ch == '+') \{                        /* handle add */\par    token = add;\par    GetCh();\par    return;\par    \}\par if (ch == '-') \{                        /* handle subtract */\par    token = subtract;\par    GetCh();\par    return;\par    \}\par if (ch == '*') \{                        /* handle multiply */\par    token = multiply;\par    GetCh();\par    return;\par    \}\par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {if (ch == '/') \{                        /* handle divide */\par    token = divide;\par    GetCh();\par    return;\par }\pard \s23\qj\fi360\widctlpar\adjustright {   \}\par if (ch == '(') \{                        /* handle ( */\par    token = lparen;\par    GetCh();\par    return;\par    \}\par if (ch == ')') \{                        /* handle ) */\par    token = rparen;\par    GetCh();\par    return;\par    \}\par if (isdigit(ch)) \{                      /* handle a number */\par    token = integer;\par    tokenValue = 0;\par    while (isdigit(ch)) \{\par       tokenValue = tokenValue*10 + ch-'0';\par       GetCh();\par       \}\par    return;\par    \}\par                                         /* handle bad input */\par printf("\\"%c\\" is an illegal character.\\n", ch);\par token = eol;\par \}\par \par \par int Expression (void);                  /* forward dec. of expression */\par \par int Term (void)\par \par /* Handle a number or parenthesis                               */\par \par \{\par int val;                                /* integer value */\par \par if (token == integer) \{                 /* handle an integer */\par    val = tokenValue;\par    GetToken();\par    \}\par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {else if (token == lparen) \{\par    GetToken();                          /* skip the ( */\par    val = Expression();                  /* evaluate the expression */\par    if (token == rparen)                 /* skip the ) */\par       GetToken();\par    else\par       printf(") expected\\n");\par }\pard \s23\qj\fi360\widctlpar\adjustright {   \}\par return val;                             /* return the value */\par \}\par \par    \par int Factor (void)\par \par /* Do multiplies and divides                                    */\par \par \{\par int value, newValue;                    /* values from Term */\par tokenType operation;                    /* type of the operation */\par \par value = Term();                         /* get the first value */\par while ((token == multiply) || (token == divide)) \{\par    operation = token;                   /* skip the operation */\par    GetToken();\par    newValue = Term();                   /* get the second value */\par    if (operation == multiply)           /* do the operation */\par       value *= newValue;\par    else\par       value /= newValue;\par    \}\par return value;                           /* return the result */\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {int Expression (void)\par \par /* Evaluate an expression                                       */\par \par \{\par int value, newValue;                    /* values from Factor */\par tokenType operation;                    /* type of the operation */\par \par value = Factor();                       /* get the first value */\par while ((token == add) || (token == subtract)) \{\par    operation = token;                   /* skip the operation */\par    GetToken();\par    newValue = Factor();                 /* get the second value */\par    if (operation == add)                /* do the operation */\par       value += newValue;\par    else\par }\pard \s23\qj\fi360\widctlpar\adjustright {      value -= newValue;\par    \}\par return value;                           /* return the result */\par \}\par \par \par void main (void)\par \par /* main program                                                 */\par \par \{\par do \{\par    printf("Expression: ");\par    scanf("%80[^\\n]%*1[\\n]", str);\par    if (strlen(str)) \{\par       ch = ' ';\par       index = 0;\par       GetToken();\par       printf("The value is %d\\n\\n", Expression());\par       \}\par    \}\par while (strlen(str));\par \}\par }\pard\plain \widctlpar\adjustright \f4\cgrid {\par \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s1\qc\nowidctlpar\outlinelevel0\adjustright \b\f4\fs36\cgrid {{\*\bkmkstart _Toc496344610}Lesson Fifteen{\*\bkmkend _Toc496344610}\par {\*\bkmkstart _Toc496344611}Sorts{\*\bkmkend _Toc496344611}\par }\pard\plain \qj\widctlpar\adjustright \f4\cgrid {\b\fs28 \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344612}Sorting{\*\bkmkend _Toc496344612}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Way back in Lesson 5, you got your first look at a sort.  Sorting is a pretty common topic in programming courses for a number of reasons.  First, there are many places in real programs where you need to sort some information.  In some cases, it is pretty obvious that a sort is needed.  For example, you may have sorted a database to put a list of people in alphabetical order.  You may have sorted the same database to put the list in zip code order to get ready for a mass mailing.  In other cases, the fact that something is being sorted is not so obvious, but sorts are none-the-less used.  For example, the link editor that creates executable programs from your object files can create a sorted list of the symbols that appear in your program.  A card playing game may sort a deck of cards.\par Another reason sorts are a popular topic is because sorting is a topic that people have spent enough time on to understand fairly well.  Computer scientists who deal with the efficiency of algorithms have studied sorts for a long time.  In the process, they have compiled a rather impressive list of different ways to sort information.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344613}The Shell Sort{\*\bkmkend _Toc496344613}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The shell sort is one of several basic sorting methods that are easy to implement, easy to understand, and reasonably efficient for small amounts of information.  In the shell sort, you loop over the information to be sorted, swapping entries if they are out of order.  If you make a swap, you also set a flag to remind you that you found entries that were out of order.  In that case, you will need to make another pass over the data to make sure it is in the right order.  You keep doing this until you make a pass over the data without finding anything that is out of order.  If you are a little fuzzy about the details, refer back to Lesson 5, where this sort was first performed.  Here's a simple version of the sort that sorts an array of SIZE numbers, where SIZE is a constant or variable telling how many entries are in the array.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {do \{\par    swap = 0;\par    for (i = 0; i < SIZE-1; ++i)\par       if (nums[i] > nums[i+1]) \{\par          temp = nums[i];\par          nums[i] = nums[i+1];\par          nums[i+1] = temp;\par          swap = 1;\par          \}\par    \}\par }\pard \s23\qj\fi360\widctlpar\adjustright {while (swap);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par When we start to worry about how efficient a sort is, we usually look at how many times we have to compare the numbers, since that is often the most time-consuming operation.  Let's trace through this routine for a short example, and find out how efficient it is.  We'll use a size of 5, with starting numbers of 5, 4, 3, 2 and 1, in that order.  You should follow along with a pencil and paper, writing down the values of variables, executing this algorithm by hand, and counting the operations on your own.\par The first time through the loop, we do four compares, and four swaps.  The numbers in the array are ordered like this after the first time through the loop:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {4  3  2  1  5\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {We still have to do four compares each time through the loop.  After the next loop, and four more compares, the array looks like this:\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {3  2  1  4  5\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par This process continues until the numbers are sorted.  We have to do one extra pass after all of the numbers are sorted, since we keep going until swap stays false.  Here are the numbers in the array, along with the total number of compares we have performed, up to and including this time through the loop:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {2  1  3  4  5       12\par 1  2  3  4  5       16\par }\pard \s23\qj\fi360\widctlpar\adjustright {1  2  3  4  5       20\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {While we won't go through a formal mathematical proof, by trying a few cases, you can probably convince yourself that if you are sorting n things, and the numbers start out in reverse order, the number of compares will be n*(n-1).  Starting with the array in reverse order is the worst possible situation for this sort, so we call this the worst case run time.\par }\pard \s21\qj\fi360\widctlpar\adjustright {In a sense, it is pretty unfair to judge anything by the worst case.  This is especially true in computer science, since it turns out that in many situations, the typical run time for an algorithm is very different than the worst case run time.  In fact, there are many situations where the algorithm that has the best worst case run time is not the one with the best typical run time.  On the other hand, you do need to know the worst case time, too, since you may be planning a program that is very time critical.  In other words, it pays to know as much about algorithms and their efficiency as you can take the time to learn.  You may end up picking one method of sorting in one program, and a different method in another.\par For most algorithms you are likely to need, you will be able to find the worst case run time in published books.  What if you can't find out about the algorithm from a book?  Or, what if you find the algorithm, but they don't tell you the typical run time, only the worst case run time?  Well, you've already seen one way to find the worst case run time, by tracing through the program by hand.  You could also do the same thing by machine, of course.  While this doesn't give you a mathematical proof, counting the operations does give you a good handle on the run time of an algorithm.  You can use the same idea to find the typical run time.  These ideas are expanded on in the problems.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 15.1. }{ Write a program that creates an array of integers in reverse order, like the array we looked at in the example in this section.  Be sure and use a constant for the size of the array.  Sort the array using the algorithm shown, but add a counter than counts the number of compares.  Print this value.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Run this program with arrays that have 2, 3, 4, 5, and 10 values.  Do all of the numbers match the value n*(n-1)?\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }{\b Problem 15.2. }{ Finding the typical run time for an algorithm is a lot like finding the worst case run time, like you did in problem 15.1.  If you have some actual samples of numbers you plan to sort, you can use the samples to find the typical run time.  Another way is to use a simulation, filling the arrays with random values several times, then averaging the run time for the various sorts.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Try this method to find the typical run time for the shell sort.  Modify the program from problem 15.1 so it uses a random number generator to fill the array with values between 1 and the size of the array.  To keep things simple, allow duplicates.  In other words, you don't have to check to be sure that the random number generator returns each possible value once; it is fine if the array has some duplicates.  Do this 100 times, and average the number of compares.  Find the values for arrays with 2, 3, 4, 5, and 10 elements.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344614}Quick Sort{\*\bkmkend _Toc496344614}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {There are several ways of sorting information that are a little faster than the shell sort, but these generally still have a run time that is proportional to n*n, or something pretty close to n*n, like the n*(n-1) that we found for the shell sort.  There are also some sorts that have a typical run time proportional to n*log(n)/log(2).  To see what this means, let's stop and think about a fairly common sorting problem, sorting a mailing list to zip-code order.  There are a variety of mailing lists that come in a variety of sizes, but it isn't uncommon to have 100,000 names in a mailing list.  Sorting 100,000 names using the shell sort has a worst case run time of 100,000*(100,000-1), or 9,999,900,000 compares.  To say the least, doing nearly ten billion compares takes some serious computer time, especially if you are comparing floating-point numbers, or worse yet, strings.  The faster sorts that work in n*log(n)/log(2) time, though, would do the same thing using 1,660,964 compares, which is over 6000 times faster!\par The most popular of the fast sorts is a recursive sort called quick sort.  Quick sort uses a divide and conquer technique.  On each step, a pivot value is picked.  Picking a good pivot value is something of a fine art, and it is a very important step.  In most cases, the middle value is a good choice for the pivot value.  For example, if you are sorting an array with indices from 1 to 100, you would use the 50th element as the pivot value.  The routine then moves anything smaller than the pivot value to the left of the pivot, and anything larger than the pivot value to the right of the pivot.  The recursive step comes next:  the quick sort procedure calls itself, passing the part of the array to the left of the pivot, then makes another recursive call to sort the right half of the array.\par Understanding how this works is pretty tricky, so let's get used to it slowly.  Type in the following program and make sure it works.  It uses quick sort to sort a small array with ten values.\par \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {\b Listing 15.1\par \par }\pard\plain \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright \f6\fs20\cgrid {/* A sample of quick sort.                                      */\par \par #include <stdio.h>\par \par #define SIZE 10                         /* size of the array to sort */\par \par int a[SIZE];                            /* array to sort */\par \par \par void Fill (void)\par \par /* Fill an array                                                */\par /*                                                              */\par /* Variables:                                                   */\par /*    a - array to fill                                         */\par \par \{\par int i;                                  /* loop variable */\par \par for (i = 0; i < SIZE; ++i)\par    a[i] = SIZE-i;\par \}\par \par \par void Sort (int left, int right)\par \par /* Sort an array                                                */\par /*                                                              */\par /* Parameters:                                                  */\par /*    left - leftmost part of the array to sort                 */\par /*    right - rightmost part of the array to sort               */\par /*                                                              */\par /* Variables:                                                   */\par /*    a - array to sort                                         */\par \par \{\par int i,j;                                /* array indices */\par int pivot;                              /* pivot value */\par int temp;                               /* used to swap values */\par \par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {if (right > left) \{                  /* quit if there is only 1 element */\par    i = (left-1) + ((right-left+1) / 2); /* find the pivot index */\par    pivot = a[i];                        /* put the pivot at the end */\par    a[i] = a[right];                     /* (remember the pivot, too) */\par    a[right] = pivot;\par    i = left;                            /* set up the start indices */\par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {   j = right-1;\par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {   while (i != j) \{                     /* partition the array */\par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {      while ((a[i] <= pivot) && (i != j))\par          ++i;\par       while ((a[j] >= pivot) && (i != j))\par          --j;\par       temp = a[i];\par       a[i] = a[j];\par       a[j] = temp;\par       \}\par    if (a[i] < pivot)                    /* find the pivot insert point */\par       ++i;\par    temp = a[i];                         /* replace the pivot */\par    a[i] = a[right];\par    a[right] = temp;\par    Sort(left, i-1);                    /* sort to the left of the pivot */\par    Sort(i+1, right);                  /* sort to the right of the pivot */\par    \}\par \}\par \par \par void Print (void)\par \par /* Print the array                                              */\par /*                                                              */\par /* Variables:                                                   */\par /*    a - array to print                                        */\par \par \{\par int i;\par \par for (i = 0; i < SIZE; ++i)\par    printf("%d\\n", a[i]);\par \}\par \par \par void main (void)\par \par /* main program                                                 */\par \par \{\par Fill();\par Sort(0, SIZE-1);\par Print();\par \}\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par }\pard\plain \fi360\widctlpar\adjustright \f4\cgrid {\f6\fs20 \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {We will use the debugger to see how this program works.  Type it in, then run the program once to make sure it is typed in correctly.  Now single-step into the program, and step through the Fill function.  Just before the call to sort, bring up the variables window and type in a[0], a[1], and so forth, so that you can see all of the values in the array.  You will have to resize the variables window to see all ten values at one time.\par For our first look at the Sort function, we will not worry too much about how each statement works.  Instead, let's look closely at what happens on the whole.  The Sort function is really divided into four distinct steps:\par \par }\pard \s21\qj\fi-360\li720\widctlpar\adjustright {1.\tab Find a pivot value.\par 2.  Put everything smaller than the pivot to the left of the pivot value, and everything larger than the pivot value to the right of the pivot.\par 3.\tab Sort the values to the left of the pivot.\par 4.\tab Sort the values to the right of the pivot.\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par This is a classic example of recursion as we saw it in the last lesson.  To understand quick sort, it is very important to look at what happens on one step, not worrying about how we "sort everything to the left of the pivot."\par The first few lines of the function find the pivot value and move it to the right-hand side of the array, where it is out of the way:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {i = (left-1)\par    + ((right-left+1) / 2);\par pivot = a[i];\par a[i] = a[right];\par }\pard \s23\qj\fi360\widctlpar\adjustright {a[right] = pivot;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {It may seem strange to go to all of the work to pluck a pivot from the middle of the array and move it to the right-hand side of the array, but there really is a good reason to do this.  The algorithm to shuffle the values smaller than the pivot to the left, and the values larger than the pivot to the right, is a lot simpler and faster if we move the pivot value out of the way.  It might seem like a good idea to simply use the right-hand value for the pivot, then.  It turns out that this is a rotten idea.  If you pick the right-hand value for the pivot, and start with a sorted array, quick sort gives the worst performance possible.  In practice, picking the middle element of the array for the pivot works very well.\par }\pard \s21\qj\fi360\widctlpar\adjustright {Getting back to the debugger, step into the Sort function.  You will have to click on the up arrow key in the variables window to get the array back.  Step through the lines that choose a pivot; the array will end up looking like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {10 9  8  7  1  5  4  3  2  6\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The next step is to shuffle through the array, moving any value smaller than the pivot to the left end of the array, and any value larger than the pivot to the right of the array.  To do this, we use two array indices, i and j.  They start at opposite ends of the array, working their way towards the middle until they meet (which means we are finished) or they hit a value that is in the wrong spot.  If a value is found that is out of place, it is swapped with another value that is out of place on the other end of the array.  Step through the procedure, watching how this happens.  Here's a summary of what happens to the array; you should see the same thing in the debugger:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {10 9  8  7  1  5  4  3  2  6\par 2  9  8  7  1  5  4  3 10  6\par 2  3  8  7  1  5  4  9 10  6\par 2  3  4  7  1  5  8  9 10  6\par }\pard \s23\qj\fi360\widctlpar\adjustright {2  3  4  5  1  7  8  9 10  6\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par When we drop out of the while loop, we are almost done.  All of the values that are less than the pivot of 6 are in the first 5 elements of the array, while all of the values that are larger than the pivot are in the 4 array elements that follow.  The only value that is out of place is the pivot itself.  The lines right after the while loop put the pivot value in place.  After the pivot is in place, the array looks like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {2  3  4  5  1  6  8  9 10  7\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {At this point, the pivot is in the right place.  The values to the left of the pivot need to be sorted, but they have nothing to do with the values to the right of the pivot.  The values to the right of the pivot also need to be sorted, but they have nothing to do with the values to the left of the pivot.\par }\pard \s21\qj\fi360\widctlpar\adjustright {Let's face it:  quick sort is quite a bit more complicated than the shell sort.  Why is it faster?  After all, if you count the compares in the while loop that partitions the array, we still end up with about n compares.  The trick, though, is that quick sort doesn't have to go through its main loop as many times as the shell sort does.  In this example, we've divided the problem in half.  Thinking about that in terms of the shell sort, where the worst case sort time is n*(n-1), you can see what an advantage this is.  If we are sorting 100 values with the shell sort, the worst case run time is 100*(100-1), or 9900.  If we sort 2 arrays, each with 50 elements, though, the run time is proportional to 2*(50*(50-1)), or 4900.  You can see that the savings would mount up pretty quickly, since quick sort would divide the 50 element arrays in half, too.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 15.3. }{ How many times does the Sort function get called in the example shown in this section?  (Hint:  put a counter in the Sort function and run the program.)\par \par }{\b Problem 15.4. }{ Find the typical run time for quick sort for arrays that have 2, 3, 4, 5 and 10 elements.  Use the same method that you used in problem 15.2.  Count the compares of values in the array, but don't count the compares of array indices.  There are three places in the subroutine where you will need to increment the counter:  inside each of the short while loops, and right after you exit the large while loop.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {How do these values compare to the ones you found in problem 15.2?\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344615}How Fast Are They?{\*\bkmkend _Toc496344615}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {All of this mathematical gobbledy-goop about theoretical efficiency may be making your head spin.  It can also be taken too far.  There are a surprising number of people running around with a degree in computer science who will tell you that quick sort is always faster than a shell sort.  Even in theory, this simply isn't true.  There are some rare cases where the shell sort will outperform the quick sort, if the values in the array happen to be placed just right.\par On average, though, quick sort seems like it should work better than the shell sort.  It turns out that this isn't quite true.  The shell sort has one advantage over quick sort:  it is simpler.  Recursive functions calls take some time; far more time than looping through a while loop.  There are also a lot of compares and tests in the Sort function that aren't needed in the shell sort.  It turns out that the shell sort is actually faster than quick sort for small arrays.  Some sophisticated sorting subroutines take advantage of this fact by using quick sort to sort the array until it is divided into small chunks, then using the shell sort, or one of its close relatives, to sort the small pieces.\par This is where practice meets theory.  A computer scientist who really understands his topic knows all of this, of course.  The theoretical run times are very important, but it is also important to keep the overhead in mind.  Unfortunately, while a computer scientist can use mathematical proofs to find the theoretical run time for an algorithm, there is no easy way to predict the actual run time.  That depends on a lot of variables, like how efficient subroutine calls are (they are more efficient compared to loops on an Apple IIGS, for example, than on an IBM 370 mainframe, which does not have a stack), what kind of information you are comparing (integer compares are much faster than string compares), and how long it takes to swap elements of the array (for arrays of structures, the swap may take longer than the compare!).\par As a programmer, you need a practical way to compare algorithms in a real setting.  ORCA/C has a tool called a profiler which can help you do this.  There are several different kinds of profilers, but basically, all of them tell you how long it takes to actually run a particular subroutine.  The profiler in ORCA/C uses a Monte-Carlo technique.  What that means is that the profiler does a random sample.  Every 60th of a second, the profiler looks to see which subroutine it is in.  A counter is incremented for that subroutine.  After the program finishes, the profiler prints the counters for each subroutine.  It also prints the number of times each subroutine was called, and the amount of time spent in each subroutine as a percentage of the overall time to run the program.\par Like any statistical technique, the profiler gives the best answers when you give it a lot of information.  In the case of the profiler, this means letting the program run for a long time.  For example, the results will be more accurate if you run a subroutine 100 times than if you run the subroutine one time.\par Using the profiler is very easy.  Pull down the Debug menu and select Profile, then run the program like you normally would.  Be sure you leave debug code on \endash  the profiler works with the debugger to time your program.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {Problem 15.5.  Put the shell sort function and the quick sort function into the same program, and write a main program that will call each of these functions to sort a copy of the same array.  Be sure you use a constant to represent the size of the array.  Use a loop in the mail program to repeat the process 10 times, and use a random-number generator to create a new array on each of the 10 loops.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {Use the profiler to find the size of the array that will give roughly equal performance for the shell sort and quick sort.  For example, if you try an array with 3 elements, you will find that the shell sort is faster.  (You can see this by looking at the counter printed by the profiler for each subroutine.)  For an array with 25 elements, quick sort is faster.  Vary the size of the array until they take about the same amount of time.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Would the results be the same if the array used real values instead of integer values in the array?  What about strings?  What does this tell you about theoretical run time?\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344616}Quick Sort Can Fail!{\*\bkmkend _Toc496344616}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {One little point has been ignored up to now.  Quick sort is very fast, especially for large arrays.  Quick sort is a little tougher to implement, but you can modify the Sort function from this lesson fairly easily.  The big problem with quick sort is that it doesn't always work.\par This may come as quite a shock to you.  After all, you stepped through the Sort function fairly carefully.  You saw how it worked.  How could it fail?\par The answer is that there is nothing wrong with the basic idea behind quick sort.  Quick sort will always work unless it runs out of memory.  You see, every time you make a function call, your program uses a small amount of memory from the stack.  The stack is limited in size.  By default, programs written in ORCA/C have an 8192 byte stack.  You can use the stacksize pragma to increase this to about 32K; the exact amount depends on which program launcher you use, what desk accessories you have installed, and what version of the operating system you are using.\par In ORCA/C 1.1, every function call uses 19 byes from the stack frame.  If you call a function several times from a loop, the function uses the same 19 bytes each time you call it, but if a function calls itself recursively, each recursive call uses a new chunk of memory.  You also have to add the space used by the parameters and local variables.  In the case of the Sort function, there are 2 parameters and 4 local variables.  They use an additional 12 bytes of stack space, so that each call uses 31 bytes.  The program has also used some stack space before Sort is called for the first time.  For a variety of reasons, there is no good way to tell in advance exactly how much stack space will be used.  With the default stack size of 8K, and the Sort function we have used in this lesson, it is easy to see that the Sort function cannot safely recur more than 264 levels deep.  In practice, the value is a little smaller.\par If Sort happens to hit a worst-case situation, it will recur as deep as the size of the array.  In the best case, Sort will recur ln(n)/ln(2) levels deep, where n is the size of the array.  This happens when Sort splits the array exactly in half on each call.\par All of this points out that you really have to understand not only the advantages of a particular algorithm, but its disadvantages as well.  Any algorithm has to be viewed with a critical eye.  Quick sort is a lot faster than the shell sort for large arrays, but the shell sort never fails.\par Fortunately, there is a solution to this mess.  You can use a counter to keep track of how deep you have recurred in the Sort function.  If you exceed a preset limit, you can use a shell sort to sort the piece of the array that you are working on, rather than recurring deeper.  As you saw in problem 15.5, the shell sort is also more efficient than quick sort for small arrays, so you can also use the shell sort if the array is small, increasing the overall speed of the sort!\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 15.6. }{ Modify Sort so it uses a shell sort if the number of array elements to sort is smaller than SHELLSIZE, a constant in your Sort function.  Use the results of problem 15.5 to choose a value for SHELLSIZE.  Also, add a new parameter to Sort, a counter that is set to 1 when Sort is called from the main program.  Inside Sort, increment this value, and pass the new value when Sort is called recursively.  This counter will always be the recursion depth.  (If you don't see why, implement the subroutine anyway, and then use the debugger to see how count works.)  Use the shell sort if the counter exceeds MAXDEPTH, a constant you define.  A good value for MAXDEPTH is 100.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344617}Sorting Summary{\*\bkmkend _Toc496344617}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Sorting has given you your first real taste of writing efficient programs.  You can start to see some of the trade-offs that you will have to make when you write programs, as well as some of the techniques you can use to see the impact of these trade-offs.\par You probably know that this lesson has only scratched the surface of sorting.  Complete books \endash  long ones, at that \endash  have been written on the topic of sorting.  The methods covered in this lesson will work in almost any programming situation you are likely to come across, but if you are ever writing a program that is doing a lot of sorting, it would pay to dig into some books to learn about some of the other sorting methods.\par }\pard\plain \qc\widctlpar\adjustright \f4\cgrid {\b\fs36 \par \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \qc\widctlpar\adjustright \f4\cgrid {\b\fs36 Lesson Fifteen\par Solutions to Problems\par }\pard \qj\widctlpar\adjustright {\b\fs28 \par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {Solution to problem 15.1.\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {By changing the value of the constant size in the following program, you can find out how many compares the program does for various sized arrays.  All of the values do, in fact, match the formula n*(n-1).  The values are:\par \par }\pard \s21\qj\fi720\widctlpar\tx2160\adjustright {\ul size}{\tab }{\ul number of compares}{\par 2\tab 2\par 3\tab 6\par 4\tab 12\par 5\tab 20\par 10\tab 90\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Count the compares needed to sort a reverse-order array with */\par /* a shell sort.                                                */\par \par #include <stdio.h>\par \par #define SIZE 2                          /* size of the array to sort */\par \par int count = 0;                          /* number of compares */\par int a[SIZE];                            /* array to sort */\par \par \par void Sort (void)\par \par /* Sort an array                                                */\par /*                                                              */\par /* Variables:                                                   */\par /*    a - array to sort                                         */\par \par \{\par int i;                                  /* loop variable/array index */\par int swap;                               /* was a value swapped? */\par int temp;                               /* temp; used for swapping */\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {do \{\par    swap = 0;\par    for (i = 0; i < SIZE-1; ++i) \{\par       ++count;\par       if (a[i] > a[i+1]) \{\par          temp = a[i];\par          a[i] = a[i+1];\par          a[i+1] = temp;\par          swap = 1;\par          \}\par }\pard \s23\qj\fi360\widctlpar\adjustright {      \}\par    \}\par while (swap);\par \}\par \par \par void Fill (void)\par \par /* Fill an array                                                */\par /*                                                              */\par /* Variables:                                                   */\par /*    a - array to fill                                         */\par \par \{\par int i;                                  /* loop variable */\par \par for (i = 0; i < SIZE; ++i)\par    a[i] = SIZE-i;\par \}\par \par \par void main (void)\par \par /* main program                                                 */\par \par \{\par Fill();\par Sort();\par printf("There were %d compares.\\n", count);\par printf("n*(n-1) is %d\\n", SIZE*(SIZE-1));\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344618}Solution to problem 15.2.{\*\bkmkend _Toc496344618}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {By changing the value of the constant size in the following program, you can find the average number of compares the program does for various sized arrays when the arrays are filled with random values.  The results are:\par \par }\pard \s21\qj\fi720\keepn\widctlpar\tx2160\adjustright {\ul size}{\tab }{\ul number of compares}{\par 2\tab 1.22\par 3\tab 3.46\par 4\tab 7.83\par 5\tab 12.08\par }\pard \s21\qj\fi720\widctlpar\tx2160\adjustright {10\tab 65.16\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Count the compares needed to sort a pseudo-random array with  */\par /* a shell sort.                                                 */\par \par #include <stdio.h>\par #include <stdlib.h>\par \par #define SIZE 2                          /* size of the array to sort */\par #define TRIALS 100                      /* number of trial runs */\par \par int count = 0;                          /* number of compares */\par int a[SIZE];                            /* array to sort */\par \par \par void Sort (void)\par \par /* Sort an array                                                */\par /*                                                              */\par /* Variables:                                                   */\par /*    a - array to sort                                         */\par \par \{\par int i;                                  /* loop variable/array index */\par int swap;                               /* was a value swapped? */\par int temp;                               /* temp; used for swapping */\par \par do \{\par    swap = 0;\par    for (i = 0; i < SIZE-1; ++i) \{\par       ++count;\par       if (a[i] > a[i+1]) \{\par          temp = a[i];\par          a[i] = a[i+1];\par          a[i+1] = temp;\par          swap = 1;\par          \}\par       \}\par    \}\par while (swap);\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void Fill (void)\par \par }\pard \s23\qj\fi360\widctlpar\adjustright {/* Fill an array                                                */\par /*                                                              */\par /* Variables:                                                   */\par /*    a - array to fill                                         */\par \par \{\par int i;                                  /* loop variable */\par \par for (i = 0; i < SIZE; ++i)\par    a[i] = rand() % SIZE;\par \}\par \par \par void main (void)\par \par /* main program                                                 */\par \par \{\par int i;                                  /* loop variable */\par \par srand(2345);                  /* initialize the random number generator */\par for (i = 0; i < TRIALS; ++i) \{          /* do the trial runs */\par    Fill();\par    Sort();\par    \}\par                                         /* print the results */\par printf("The average number of compares is %.2f.\\n",\par    ((float)count)/TRIALS);\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344619}Solution to problem 15.3.{\*\bkmkend _Toc496344619}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The quick sort subroutine is called 13 times.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Determine how many times Sort is called                      */\par \par #include <stdio.h>\par \par #define SIZE 10                         /* size of the array to sort */\par \par int a[SIZE];                            /* array to sort */\par int count = 0;                          /* number of calls */\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void Fill (void)\par \par /* Fill an array                                                */\par /*                                                              */\par }\pard \s23\qj\fi360\widctlpar\adjustright {/* Variables:                                                   */\par /*    a - array to fill                                         */\par \par \{\par int i;                                  /* loop variable */\par \par for (i = 0; i < SIZE; ++i)\par    a[i] = SIZE-i;\par \}\par \par \par void Sort (int left, int right)\par \par /* Sort an array                                                */\par /*                                                              */\par /* Parameters:                                                  */\par /*    left - leftmost part of the array to sort                 */\par /*    right - rightmost part of the array to sort               */\par /*                                                              */\par /* Variables:                                                   */\par /*    a - array to sort                                         */\par \par \{\par int i,j;                                /* array indices */\par int pivot;                              /* pivot value */\par int temp;                               /* used to swap values */\par \par ++count;                                /* update the counter */\par if (right > left) \{                  /* quit if there is only 1 element */\par    i = (left-1) + ((right-left+1) / 2); /* find the pivot index */\par    pivot = a[i];                        /* put the pivot at the end */\par    a[i] = a[right];                     /* (remember the pivot, too) */\par    a[right] = pivot;\par    i = left;                            /* set up the start indices */\par    j = right-1;\par    while (i != j) \{                     /* partition the array */\par       while ((a[i] <= pivot) && (i != j))\par          ++i;\par       while ((a[j] >= pivot) && (i != j))\par          --j;\par       temp = a[i];\par       a[i] = a[j];\par       a[j] = temp;\par       \}\par    if (a[i] < pivot)                    /* find the pivot insert point */\par       ++i;\par    temp = a[i];                         /* replace the pivot */\par    a[i] = a[right];\par    a[right] = temp;\par    Sort(left, i-1);                    /* sort to the left of the pivot */\par    Sort(i+1, right);                  /* sort to the right of the pivot */\par    \}\par \}\par \par \par void Print (void)\par \par /* Print the array                                              */\par /*                                                              */\par /* Variables:                                                   */\par /*    a - array to print                                        */\par \par \{\par int i;\par \par for (i = 0; i < SIZE; ++i)\par    printf("%d\\n", a[i]);\par \}\par \par \par void main (void)\par \par /* main program                                                 */\par \par \{\par Fill();\par Sort(0, SIZE-1);\par Print();\par printf("Sort is called %d times.\\n", count);\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344620}Solution to problem 15.4.{\*\bkmkend _Toc496344620}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {By changing the value of the constant size in the following program, you can find out the average number of compares the program does for various sized arrays when the arrays are filled with random values.  The table below shows the results for both this program and the earlier problem that examined the shell sort.\par \par }\pard \s21\qj\fi720\widctlpar\tx2160\tx3600\adjustright {\ul size}{\tab }{\ul shell sort}{\tab }{\ul quick sort}{\par 2\tab 1.22\tab 1.00\par 3\tab 3.46\tab 4.72\par 4\tab 7.83\tab 8.56\par 5\tab 12.08\tab 12.77\par 10\tab 65.16\tab 39.61\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {/* Check to see how many compares are needed by a typical quicksort */\par \par #include <stdio.h>\par }\pard \s23\qj\fi360\widctlpar\adjustright {#include <stdlib.h>\par \par #define SIZE 10                         /* size of the array to sort */\par #define TRIALS 100                      /* number of trial runs */\par \par int a[SIZE];                            /* array to sort */\par int count = 0;                      /* number of array element compares */\par \par \par void Fill (void)\par \par /* Fill an array                                                */\par /*                                                              */\par /* Variables:                                                   */\par /*    a - array to fill                                         */\par \par \{\par int i;                                  /* loop variable */\par \par for (i = 0; i < SIZE; ++i)\par    a[i] = rand() % SIZE;\par \}\par \par \par void Sort (int left, int right)\par \par /* Sort an array                                                */\par /*                                                              */\par /* Parameters:                                                  */\par /*    left - leftmost part of the array to sort                 */\par /*    right - rightmost part of the array to sort               */\par /*                                                              */\par /* Variables:                                                   */\par /*    a - array to sort                                         */\par \par \{\par int i,j;                                /* array indices */\par int pivot;                              /* pivot value */\par int temp;                               /* used to swap values */\par \par if (right > left) \{                  /* quit if there is only 1 element */\par    i = (left-1) + ((right-left+1) / 2); /* find the pivot index */\par    pivot = a[i];                        /* put the pivot at the end */\par    a[i] = a[right];                     /* (remember the pivot, too) */\par    a[right] = pivot;\par    i = left;                            /* set up the start indices */\par    j = right-1;\par    while (i != j) \{                     /* partition the array */\par       ++count;\par       while ((a[i] <= pivot) && (i != j)) \{\par          ++count;\par          ++i;\par          \}\par       ++count;\par       while ((a[j] >= pivot) && (i != j)) \{\par          ++count;\par          --j;\par          \}\par       temp = a[i];\par       a[i] = a[j];\par       a[j] = temp;\par       \}\par    ++count;\par    if (a[i] < pivot)                    /* find the pivot insert point */\par       ++i;\par    temp = a[i];                         /* replace the pivot */\par    a[i] = a[right];\par    a[right] = temp;\par    Sort(left, i-1);                    /* sort to the left of the pivot */\par    Sort(i+1, right);                  /* sort to the right of the pivot */\par    \}\par \}\par \par \par void main (void)\par \par /* main program                                                 */\par \par \{\par int i;                                  /* loop variable */\par \par srand(2345);                  /* initialize the random number generator */\par for (i = 0; i < TRIALS; ++i) \{          /* do the trial runs */\par    Fill();\par    Sort(0, SIZE-1);\par    \}\par                                         /* print the results */\par printf("The average number of compares is %.2f.\\n",\par    ((float)count)/TRIALS);\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344621}Solution to problem 15.5.{\*\bkmkend _Toc496344621}\par }\pard\plain \s21\qj\fi360\keepn\widctlpar\adjustright \f4\fs20\cgrid {The shell sort and quick sort require almost exactly the same amount of time when the array has 19 elements.  Naturally, the speed of a compare and the time it takes to copy the values from one place in the array to another impact this number.  By changing the array to an array of float, instead of an array of integer, the break-even point changes from 19 elements to 13 elements.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Compare the time for a quick sort to the time for a shell    */\par /* sort.                                                        */\par \par #include <stdio.h>\par #include <stdlib.h>\par \par #define SIZE 10                         /* size of the array to sort */\par #define TRIALS 10                       /* number of trial runs */\par \par int a[SIZE], b[SIZE];                   /* array(s) to sort */\par \par \par void Fill (void)\par \par /* Fill two arrays                                              */\par /*                                                              */\par /* Variables:                                                   */\par /*    a,b - arrays to fill                                      */\par \par \{\par int i;                                  /* loop variable */\par \par for (i = 0; i < SIZE; ++i) \{\par    a[i] = rand() % SIZE;\par    b[i] = a[i];\par    \}\par \}\par \par \par void ShellSort (void)\par \par /* Sort an array                                                */\par /*                                                              */\par /* Variables:                                                   */\par /*    b - array to sort                                         */\par \par \{\par int i;                                  /* loop variable/array index */\par int swap;                               /* was a value swapped? */\par int temp;                               /* temp; used for swapping */\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {do \{\par    swap = 0;\par }\pard \s23\qj\fi360\widctlpar\adjustright {   for (i = 0; i < SIZE-1; ++i) \{\par       if (b[i] > b[i+1]) \{\par          temp = b[i];\par          b[i] = b[i+1];\par          b[i+1] = temp;\par          swap = 1;\par          \}\par       \}\par    \}\par while (swap);\par \}\par \par \par void QuickSort (int left, int right)\par \par /* Sort an array                                                */\par /*                                                              */\par /* Parameters:                                                  */\par /*    left - leftmost part of the array to sort                 */\par /*    right - rightmost part of the array to sort               */\par /*                                                              */\par /* Variables:                                                   */\par /*    a - array to sort                                         */\par \par \{\par int i,j;                                /* array indices */\par int pivot;                              /* pivot value */\par int temp;                               /* used to swap values */\par \par if (right > left) \{                  /* quit if there is only 1 element */\par    i = (left-1) + ((right-left+1) / 2); /* find the pivot index */\par    pivot = a[i];                        /* put the pivot at the end */\par    a[i] = a[right];                     /* (remember the pivot, too) */\par    a[right] = pivot;\par    i = left;                            /* set up the start indices */\par    j = right-1;\par    while (i != j) \{                     /* partition the array */\par       while ((a[i] <= pivot) && (i != j))\par          ++i;\par       while ((a[j] >= pivot) && (i != j))\par          --j;\par       temp = a[i];\par       a[i] = a[j];\par       a[j] = temp;\par       \}\par    if (a[i] < pivot)                    /* find the pivot insert point */\par       ++i;\par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {   temp = a[i];                         /* replace the pivot */\par    a[i] = a[right];\par }\pard \s23\qj\fi360\widctlpar\adjustright {   a[right] = temp;\par    QuickSort(left, i-1);               /* sort to the left of the pivot */\par    QuickSort(i+1, right);             /* sort to the right of the pivot */\par    \}\par \}\par \par \par void main (void)\par \par /* main program                                                 */\par \par \{\par int i;                                  /* loop variable */\par \par srand(2345);                  /* initialize the random number generator */\par for (i = 0; i < TRIALS; ++i) \{          /* do the trial runs */\par    Fill();\par    QuickSort(0, SIZE-1);\par    ShellSort();\par    \}\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344622}Solution to problem 15.6.{\*\bkmkend _Toc496344622}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* A better sort than QuickSort                                 */\par \par #include <stdio.h>\par #include <stdlib.h>\par \par #define SIZE 100                        /* size of the array to sort */\par \par int a[SIZE];                            /* array to sort */\par \par \par void Fill (void)\par \par /* Fill an array                                                */\par /*                                                              */\par /* Variables:                                                   */\par /*    a - array to fill                                         */\par \par \{\par int i;                                  /* loop variable */\par \par for (i = 0; i < SIZE; ++i)\par    a[i] = rand() % SIZE;\par \}\par \par \par void Sort (int left, int right, int depth)\par \par /* Sort an array                                                */\par /*                                                              */\par /* Parameters:                                                  */\par /*    left - leftmost part of the array to sort                 */\par /*    right - rightmost part of the array to sort               */\par /*    depth - recursion depth                                   */\par /*                                                              */\par /* Variables:                                                   */\par /*    a - array to sort                                         */\par \par #define SHELLSIZE 19                /* when a quick sort becomes faster */\par #define MAXDEPTH 100                    /* max recursion depth */\par \{\par int i,j;                                /* array indices */\par int pivot;                              /* pivot value */\par int swap;                               /* was a value swapped? */\par int temp;                               /* used to swap values */\par \par if (((right - left) < SHELLSIZE) || (depth > MAXDEPTH)) \{\par    do \{                                 /* do a shell sort */\par       swap = 0;\par       for (i = left; i < right; ++i) \{\par          if (a[i] > a[i+1]) \{\par             temp = a[i];\par             a[i] = a[i+1];\par             a[i+1] = temp;\par             swap = 1;\par             \}\par          \}\par       \}\par    while (swap);\par    \}\par else \{                                  /* do a quick sort */\par    if (right > left) \{               /* quit if there is only 1 element */\par       i = (left-1) + ((right-left+1) / 2); /* find the pivot index */\par       pivot = a[i];                     /* put the pivot at the end */\par       a[i] = a[right];                  /* (remember the pivot, too) */\par       a[right] = pivot;\par       i = left;                         /* set up the start indices */\par       j = right-1;\par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {      while (i != j) \{                  /* partition the array */\par          while ((a[i] <= pivot) && (i != j))\par             ++i;\par          while ((a[j] >= pivot) && (i != j))\par             --j;\par          temp = a[i];\par          a[i] = a[j];\par }\pard \s23\qj\fi360\widctlpar\adjustright {         a[j] = temp;\par          \}\par       if (a[i] < pivot)                 /* find the pivot insert point */\par          ++i;\par       temp = a[i];                      /* replace the pivot */\par       a[i] = a[right];\par       a[right] = temp;\par       Sort(left, i-1, depth+1);        /* sort to the left of the pivot */\par       Sort(i+1, right, depth+1);      /* sort to the right of the pivot */\par       \}\par    \}\par \}\par \par \par void Print (void)\par \par /* Print the array                                              */\par /*                                                              */\par /* Variables:                                                   */\par /*    a - array to print                                        */\par \par \{\par int i;\par \par for (i = 0; i < SIZE; ++i) \{\par    printf("%4d", a[i]);\par    if ((i % 8) == 7)\par       printf("\\n");\par    \}\par \}\par \par \par void main (void)\par \par /* main program                                                 */\par \par \{\par srand(2345);                            /* initialize rand() */\par Fill();                                 /* fill the array */\par Sort(0, SIZE-1, 1);                     /* sort the array */\par Print();                                /* print the array */\par \}\par \par \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s1\qc\nowidctlpar\outlinelevel0\adjustright \b\f4\fs36\cgrid {{\*\bkmkstart _Toc496344623}Lesson Sixteen{\*\bkmkend _Toc496344623}\par {\*\bkmkstart _Toc496344624}Searches and Trees{\*\bkmkend _Toc496344624}\par }\pard\plain \qj\widctlpar\adjustright \f4\cgrid {\b\fs28 \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344625}Storing and Accessing Information{\*\bkmkend _Toc496344625}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The title for this lesson is "Searches and Trees," but a more down-to-earth description would be "better ways to store and find information."  Why is this important?  Why should the last topic of an introductory programming course be this one, when there are so many more?\par To answer that, let's step back from the trees a bit and look at the forest.  Computers are used for a lot of things, but desktop computers are used most often to display information, make calculations, or store and retrieve information.  That's a pretty broad statement, but I think it is true.  Spread sheets and engineering calculations are obviously applications where we make calculations.  Spread sheets, data bases and spelling checkers are examples of applications where one goal is to store or retrieve information.  Word processors, page layout programs, paint programs, and some database programs display information.  What about an adventure game, though?  Most adventure games are really databases inside, concerned with storing and retrieving information about the adventure world.  A chess program is calculation intensive.  The list goes on and on.\par You already know a few basic ways to store and access information.  You have used arrays when you knew how much information would be stored in advance, or when you could put a reasonable limit on the amount of information that would be stored.  You have used linked lists when the fixed size of an array created problems.  You have even used files when the information had to be written to disk.\par This lesson concentrates on two basic themes.  If the information is stored in an array, linked list, or disk file, how can you find it quickly?  And, what are some better ways to store the information so you can find it even quicker?\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344626}Sequential Searches{\*\bkmkend _Toc496344626}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {If you have an array, linked list, or file, the simplest way to find a particular piece of information is to start at the beginning and scan through the data structure until you find the entry you want.  This is called a sequential search, and it is nothing new to you.  You used a sequential search in Lesson 10 to look for a particular name in a linked list of strings.  Of course, you can use a sequential search to look for something in a file or array, too.  To look for a numeric value in an array of structures, a sequential search would look like this:\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {\par i = 1;\par found = 0;\par do \{\par    if (a[i].age == 40)\par       found = 1;\par    else\par       ++i;\par    \}\par while ((!found)\par    && (i != maxIndex));\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par On average, you will have to look through half of the information to find the record you want.  If the record doesn't exist \endash  if, for example, you are looking for someone who is 40, but there are no 40 year olds in your data base \endash  you will always scan the entire list.  A sequential search, then, has a typical run time of O(n/2) if the item you are looking for is found, and a worst case run time of O(n), where n is the number of things to look at.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344627}The Binary Search{\*\bkmkend _Toc496344627}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The sequential search is a very common kind of search to implement, and it is often the best kind of search to use.  In some cases, though, you know more about the information you are searching.  For example, one common thing that you might know is that the information is sorted in some kind of order.  If you are looking for a man named Smith, for example, you may have ordered your data base so that all of the people are listed in alphabetical order.  If you are looking for hospital patients using a Social Security Number, you may be searching a database that is sorted by Social Security Numbers.\par When you are searching a list of items that is sorted, and you know in advance how many things are in the array, there is a much better way of finding the information than scanning the array sequentially.  The "better way" is called a binary search.  The binary search is basically a divide and conquer method, just like quick sort.  Binary searches are usually not implemented with recursion, though.\par The idea behind a binary search is to start be checking the middle value, rather than the first value.  To see how this works, let's assume we are looking for the number 44 in an array of 100 things.  The array is very simple:  each value is the same as its index, so a[44] is 44.  We'll start by looking at the middle value, a[50].  The value is 50, which is too large.  Since the array is sorted, we know that the value we are looking for must be in the portion of the array from a[1] to a[49], assuming it exists at all.  We split the array in half again, and so forth.  The table below shows our progress.\par \par }\pard \s21\qj\fi720\widctlpar\tx1800\tx2880\adjustright {\ul index}{\tab }{\ul value}{\tab }{\ul result}{\par 50\tab 50\tab too big\par 25\tab 25\tab too small\par 37\tab 37\tab too small\par 43\tab 43\tab too small\par 46\tab 46\tab too big\par 44\tab 44\tab match\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par This divide and conquer search is extremely powerful.  Its worst case run time is O(ln(n)/ln(2)).  For our sample of 100 items, a few seconds with a calculator gives the value of 6.64, which tells us that the search will always succeed after no more than 7 compares.  That's a big improvement over the sequential sort, with a typical run time for the same array of 50 \endash  the binary search is 7 times faster.  The larger the array, the bigger the difference, too.  For an array with 100,000 values, the sequential search will look at an average of 50,000 values.  The binary search will only need to look at 17 values!  For an array with 100,000 elements, the binary search is nearly 3,000 times faster.\par While there are many twists on the sequential search and binary search, these two basic ideas are at the core of many searches in real programs.  Whenever the information you need to search is in no particular order, or is in a linked list, the sequential search is a good choice.  If the information is sorted, the binary search is the best choice.  Most other searching methods depend on organizing the information better to start with.\par \par }\pard\plain \qj\widctlpar\adjustright \f4\cgrid {Problem 16.1.  Develop a binary search algorithm, and test in on a simple array.  The search should be implemented as a function that returns the index into the array if the value you pass it is found, and -1 if it is not.  Use an array of 100 integers, with each array element containing an even number.  For example, a[0] would be 2, a[1] is 4, and so forth.  Test your search by looking for all of the even numbers from 2 to 200.  Make sure the search works when values are not found by passing it 0, 202, and 101.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344628}A Cross Reference Program for C{\*\bkmkend _Toc496344628}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {A binary search is an extremely efficient way of looking for a particular piece of information, but it does have one drawback.  While it works well for arrays, it is impossible to implement an efficient binary search for a linked list, simply because you can't hop into the middle of the linked list.\par The two most common ways of searching records in dynamically allocated memory are called binary trees and hash tables.  Both of these methods use a different way of organizing information to make the search faster.  We're going to use a C cross reference program to look at binary trees.  The purpose of this lesson isn't really to make you write a C cross reference program, so this section gives you one to start with.  This C cross reference program uses a linked list for the symbol table.\par There are two things that the cross reference program will do that are new to you, so lets start by going over these new techniques in short programs.  One of the things that we have always done so far is to prompt the user for a file name.  That works, but if you will be using a program a lot, it isn't the easiest way to get a file name.  Our cross reference program will be a shell program that reads a file name from the command line.  To run the program, you will move to the shell window, and type the name of the program, followed by the name of the file to process.  The C language has a way to do this \endash  when you run a C program from the shell window, the function main actually gets passed two parameters in a very special way, so that if you ignore the parameters, nothing bad happens.  The two parameters are argc, an integer that tells you how many parameters were passed; and argv, an array of pointers to strings.  The things you type in the shell window, including the name of the program itself, are broken up into tokens, splitting the command line wherever a space appears.  The number of tokens are passed in argc, while the array argv contains pointers to the strings, with one extra pointer set to NULL to mark the end of the list.\par Here's a simple program showing how it's done.  The program even asks for a file name if the user forgets to give one.\par \par }\pard\plain \s23\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 /* read a file name */\par \par #include <stdio.h>\par \par char fName[65];                           /* file name */\par char *fNamePtr;                           /* pointer to the file name */\par \par int main (int argc, char *argv[])\par \par \{\par if (argc < 2) \{\par    printf("File to cross reference: ");\par    fNamePtr = fName;\par    scanf("%64s", fName);\par    if (strlen(fName) == 0)\par       return -1;\par    \}\par else \{\par    if (argc > 2)\par       printf("Extra input ignored.\\n");\par    fNamePtr = argv[1];\par    \}\par \par printf("File name = '%s'\\n", fNamePtr);\par }\pard \s23\widctlpar\adjustright {\fs18 \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par You can run this program just like you do any other program.  If you do, it will stop and ask for a file name, just like all of your other programs have.  To run it from the shell window, start by turning off debug code.  You can't use the debugger with a program that you run from the shell window.  With the debug code off, compile the program the way you always do.  I called my program FNAME.CC; if you used a different name, you will need to substitute your program's name in the instructions that follow.  Click on the shell window, and type\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {fname myfile\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {and press the RETURN key.  The program will print the name of the file.  Try it again, but don't give the program a file name.  This time, the program, will ask for a file name.  Finally, put some extra stuff on the end of the line, like this:\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {fname myfile junk\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {The program still prints the file name, but this time it also prints a warning that there were some extra characters on the command line, and these were ignored.\par }\pard \s21\qj\fi360\widctlpar\adjustright {It doesn't take much to turn this into a program that reads a file and echoes it to the shell window.  That's something you have done before, but never in a way that your program looked like a command in the shell window, where you just type the name of the program and the file to echo.  Listing 16.1 shows the program after its next step of development, reading and echoing the file.\par \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\fi360\widctlpar\brdrt\brdrs\brdrw10\brsp20 \brdrl\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \adjustright {\b Listing 16.1\par \par }\pard\plain \s23\qj\fi360\widctlpar\brdrt\brdrs\brdrw10\brsp20 \brdrl\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \adjustright \f6\fs20\cgrid {/* Read a file and echo it to the console */\par \par #include <stdio.h>\par \par char fName[65];                         /* file name */\par FILE *f;                                /* file variable */\par char *fNamePtr;                         /* pointer to the file name */\par \par int main (int argc, char *argv[])\par \par \{\par char ch;                                /* character from the file */\par \par if (argc < 2) \{                         /* get a file name */\par    printf("File to cross reference: ");\par    fNamePtr = fName;\par    scanf("%64s", fName);\par    if (strlen(fName) == 0)\par       return -1;\par    \}\par else \{\par    if (argc > 2)\par       printf("Extra input ignored.\\n");\par    fNamePtr = argv[1];\par    \}\par \par f = fopen(fNamePtr, "r");               /* open the file */\par if (f == NULL) \{\par    printf("Could not open %s.\\n", fNamePtr);\par    return -1;\par    \}\par do \{                                    /* echo the file */\par    ch = fgetc(f);\par    if (ch != EOF)\par       putchar(ch);\par    \}\par while (ch != EOF);\par fclose(f);                              /* close the file */\par return 0;                               /* return with no error */\par \}\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The last step is to tie all of this together into a C cross reference generator.  This program uses the same scanning techniques that we discussed back in Lesson 13, although a few new features have been added to handle comments and to keep track of line numbers.  Once a token is found, the program searches for the token in a symbol table that is a simple linked list.  If the token does not exist, the search routine creates a new entry in the symbol table.  Finally, the program places the line number where the token was found in a linked list in the symbol table.  While both the symbol table itself and the line numbers are simple linked lists, this is the first time you have seen a linked list where each element of the linked list point to yet another linked list.  There are no new concepts involved in creating linked lists this way, but the details are interesting enough to make it worth looking at the program carefully.\par If you have time, you might want to try writing this program on your own before typing in the version you see in listing 16.2.\par \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {\par }\pard\plain \s21\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright \f4\fs20\cgrid {\b Listing 16.2\par \par }\pard\plain \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright \f6\fs20\cgrid {/* XREF                                                         */\par /*                                                              */\par /* This program generates a cross reference of a C program,     */\par /* showing where any symbol is used.  To use XREF, start by     */\par /* selecting the shell window.  Type                            */\par /*                                                              */\par /*    xref filename                                             */\par /*                                                              */\par /* where filename is the name of the program you want to cross- */\par /* reference.                                                   */\par \par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {#include <stdio.h>\par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {#include <ctype.h>\par #include <string.h>\par #include <stdlib.h>\par \par #define symbolLength 80                 /* max length of a symbol */\par \par char fName[65];                         /* file name */\par FILE *f;                                /* file variable */\par char *fNamePtr;                         /* pointer to the file name */\par \par typedef struct lineStruct \{             /* line number list */\par    struct lineStruct *next;\par    int number;\par    \}\par    lineStruct, *linePtr;\par \par typedef struct symbolStruct \{           /* symbol table entry */\par    struct symbolStruct *next;\par    char symbol[symbolLength+1];\par    linePtr lines;\par    \}\par    symbolStruct, *symbolPtr;\par \par \par symbolPtr symbols = NULL;               /* symbol table */\par int lineNumber = 1;                     /* current line number */\par char ch = ' ';                          /* current character */\par char token[symbolLength+1];             /* current token */\par int tokenLine;                         /* line number at start of token */\par \par \par void GetCh (void)\par \par /* Read a character from the file                               */\par /*                                                              */\par /* Variables:                                                   */\par /*    ch - character read                                       */\par /*    lineNumber - current line number                          */\par \par \{\par ch = fgetc(f);\par if (ch == '\\n')\par    ++lineNumber;\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {void SkipComment (void)\par \par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {/* Skip comments in the program                                 */\par \par \{\par do \{\par    GetCh();\par    if (ch == '*') \{\par       GetCh();\par       if (ch == '/')\par          return;\par       \}\par    \}\par while (ch != EOF);\par \}\par \par \par void NextCh (void)\par \par /* Get the next character from the file, skipping comments      */\par \par \{\par GetCh();                                /* get the next character */\par if (ch == '/') \{                        /* skip comments */\par    GetCh();\par    if (ch == '*') \{\par       GetCh();\par       SkipComment();\par       \}\par    \}\par \}\par \par \par void GetToken (void)\par \par /* Read a word from the source file                             */\par /*                                                              */\par /* Variables:                                                   */\par /*    lineNumber - current line number                          */\par /*    token - string read                                       */\par /*    tokenLine - line number at the start of the token         */\par \par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {\{\par int len = 0;                            /* length of the token */\par \par if (ch != EOF) \{\par                                         /* skip to the next token */\par    while ((!iscsymf(ch)) && (ch != EOF))\par       GetCh();\par    tokenLine = lineNumber;              /* record the line number */\par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {                                        /* record the token */\par    while (iscsym(ch) && (ch != EOF)) \{\par       if (len < symbolLength) \{\par          token[len] = ch;\par          ++len;\par          \}\par       GetCh();\par       \}\par    \}\par token[len] = (char) 0;                  /* mark the end of the string */\par \}\par \par \par void Insert (void)\par \par /* Insert a symbol use in the symbol table.  If the symbol does */\par /* not exist, create a new entry.                               */\par /*                                                              */\par /* Variables:                                                   */\par /*    tokenLine - line number at the start of the token         */\par /*    token - symbol to insert                                  */\par /*    symbols - pointer to the first entry in the symbol table  */\par \par \{\par linePtr lPtr;                           /* current line number pointer */\par symbolPtr sPtr;                         /* current symbol pointer */\par \par sPtr = symbols;                         /* try to find the symbol */\par while (sPtr != NULL) \{\par    if (strcmp(token, sPtr->symbol) == 0)\par       goto make;\par    sPtr = sPtr->next;\par    \}\par                                      /* none exists: create a new entry */\par sPtr = (symbolPtr) malloc(sizeof(symbolStruct));\par sPtr->next = symbols;\par symbols = sPtr;\par strcpy(sPtr->symbol, token);\par sPtr->lines = NULL;\par make:\par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {                                        /* enter the line number */\par lPtr = (linePtr) malloc(sizeof(lineStruct));\par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {lPtr->next = sPtr->lines;\par sPtr->lines = lPtr;\par lPtr->number = tokenLine;\par \}\par \par \par void PrintNumber (linePtr nPtr)\par \par /* Recursively print the line numbers in reverse order          */\par /*                                                              */\par /* Parameters:                                                  */\par /*    nPtr - pointer to the remainder of the line number list   */\par \par \{\par if (nPtr != NULL) \{\par    PrintNumber(nPtr->next);\par    printf("%d ", nPtr->number);\par    \}\par \}\par \par \par void PrintSymbols (void)\par \par /* Print the symbols found and line numbers                     */\par /*                                                              */\par /* Variables:                                                   */\par /*    symbols - pointer to the first entry in the symbol table  */\par \par \{\par symbolPtr sPtr;                         /* current symbol pointer */\par \par sPtr = symbols;\par while (sPtr != NULL) \{\par    printf("%16s  ", sPtr->symbol);\par    PrintNumber(sPtr->lines);\par    printf("\\n");\par    sPtr = sPtr->next;\par    \}\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {int main (int argc, char *argv[])\par \par /* Main program                                                 */\par \par \{\par if (argc < 2) \{                         /* get a file name */\par    printf("File to cross reference: ");\par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {   fNamePtr = fName;\par    scanf("%64s", fName);\par    if (strlen(fName) == 0)\par       return -1;\par    \}\par else \{\par    if (argc > 2)\par       printf("Extra input ignored.\\n");\par    fNamePtr = argv[1];\par    \}\par \par f = fopen(fNamePtr, "r");               /* open the file */\par if (f == NULL) \{\par    printf("Could not open %s.\\n", fNamePtr);\par    return -1;\par    \}\par \par do \{                                 /* collect the symbols in the file */\par    GetToken();\par    if (strlen(token))\par       Insert();\par    \}\par while (strlen(token));\par PrintSymbols();                         /* print the symbol table */\par \par fclose(f);                              /* close the file */\par return 0;                               /* return with no error */\par \}\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {There are a couple of problems with the C cross reference program you just tried.  The most subtle problem is that it is a lot slower than it could be, simply because it takes so darn long to deal with a sequential linked list.  This is the main problem we will try to solve in the next section.  The program is even slower if you forget to turn off debug code after the program is finished.  The most obvious problem, though, is that the symbols are printed in the reverse order of when they are first seen in the program.  It would be a lot more convenient if they were printed in alphabetical order.  We will take care of this problem as a side effect of getting rid of the linked list.  The last problem is that any sequence of alphanumeric characters is treated as a symbol.  Your program reports all of the places where you used the reserved word void, for example.  That one you will solve yourself a bit later, as one of the problems.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344629}The Binary Tree{\*\bkmkend _Toc496344629}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The major problem with a sequential search of a linked list is the same as the major problem with a sequential search of an array:  the program has to scan through an average of half of the list to find a particular entry.  If the entry doesn't exist, the program scans through the entire list.  A binary tree is another way of handling dynamically allocated records that essentially does the same thing for linked lists that the binary search did for searches.  At each level, the tree divides the search in half.\par The way this works is to include two pointers to another structure in each structure, rather than one.  In a linked list, each record has a pointer we have called next that points to the next structure in the list.  In a binary tree, each structure has two pointers, which we will call left and right.  If we look at a particular structure, and the one we want is "smaller" that the one we are looking at, we follow the left link.  If the one we want is "larger" than the one we are looking at, we follow the right link.\par To see how this works, we'll use a few short programs.  The first task is to learn to add a new item to a binary tree.  This is a little harder than it was for a linked list, but the same basic ideas are involved.  The program in listing 16.3  reads strings from the keyboard and adds them to a binary tree.\par \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {\b Listing 16.3\par \par }\pard\plain \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright \f6\fs20\cgrid {/* Create a binary tree from keyboard strings */\par \par #include <stdio.h>\par #include <string.h>\par #include <stdlib.h>\par \par typedef struct treeStruct \{             /* tree entry */\par    struct treeStruct *left, *right;\par    char str[20];\par    \}\par    treeStruct, *treePtr;\par \par treePtr tree = NULL;                    /* top of the tree */\par \par \par void Add (treePtr *ptr, treePtr rec)\par \par /* Add a record to the tree                                     */\par /*                                                              */\par /* Parameters:                                                  */\par /*    ptr - next node in the tree                               */\par /*    rec - record to add to the tree                           */\par \par \{\par int cmp;                                /* result of strcmp */\par \par if (*ptr == NULL)\par    *ptr = rec;\par else \{\par    cmp = strcmp(rec->str, (*ptr)->str);\par    if (cmp < 0)\par       Add(&((*ptr)->left), rec);\par    else if (cmp > 0)\par       Add(&((*ptr)->right), rec);\par    \}\par \}\par \par \par void main (void)\par \par /* Main program                                                 */\par \par \{\par char str[20];                           /* work string */\par treePtr tPtr;                           /* work pointer */\par \par do \{\par    printf("string: ");                  /* get a string */\par    scanf("%19[^\\n]%*1[\\n]", str);\par    if (strlen(str)) \{\par                                         /* create a new record */\par       tPtr = (treePtr) malloc(sizeof(treeStruct));\par       tPtr->left = NULL;\par       tPtr->right = NULL;\par       strcpy(tPtr->str, str);\par       Add(&tree, tPtr);                 /* add it to the tree */\par       \}\par    \}\par while (strlen(str));                   /* loop until no string is given */\par \}\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par }\pard\plain \qj\fi360\widctlpar\adjustright \f4\cgrid {\par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Looking at this program, one of the first things you might notice is that we are using a recursive subroutine again.  Just as with any situation where recursion is useful, we can look at the tree as a piecemeal problem.  Let's look at an example to see how this will work.  As an example, let's place four states in the tree.  We'll use Main, Oregon, Texas and Colorado for our states.  Main is simple:  we create a new record, set left and right to NULL, record the string, and call Add.  The procedure Add sees that *ptr is NULL, and records rec there.  The effect on the global variables is to assign tPtr to tree, so tree now points to the first record in our list, Main.  Symbolically, we write the tree like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {\tab \tab \tab Main\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Well, there isn't much there, yet, so our meager tree doesn't look very impressive.  Adding Oregon shapes things up a bit, though.  This time, when we call Add, the function sees that ptr is not NULL, and checks to see if Oregon is less than Main.  It isn't, so it moves on to the next check to be sure that Oregon is greater than Main.  It is, but let's stop for a moment and consider what would happen if it wasn't.  The only way a name could fail both checks is if it matched the name in ptr->str exactly.  The series of checks, then, prevent duplicates.  You can have duplicates in a binary tree, but your search has to take it into account if you do.  We don't need them.\par At this point, Add calls itself, passing ptr->right as the new top of the tree.  ptr->right is NULL, so rec is added as the so-called "right child" of Main.  It makes as much sense to call Oregon a branch of Main, but for historical reasons, we refer to Oregon as the right child of Main, and Main as the parent of Oregon.  Our tree looks like this, now:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {               Main\par                    \\\par                     \\\par }\pard \s23\qj\fi360\widctlpar\adjustright {                     Oregon\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Notice how recursion handled the problem of tracing the tree fairly neatly.  Once we decided that the top node existed, and which way to go, we called Add again, treating ptr->right as a brand-new tree, which in a sense it is.  If you recall, when recursion was first introduced, I said that the way to think about recursion was to think about one part of the problem at a time.  We used that method to solve the Tower of Hanoi problem, where we conceptually moved an entire pile of disks, rather than thinking about the problem as moving individual disks.  The same idea cropped up when we used recursion for quick sort, where the subroutine split the problem in half and called itself to solve each half.  Here we see the same idea again:  Add decides which half of the tree is the important part, then calls itself, precessing the appropriate half of the tree as a new tree.\par The next state to add is Texas, which makes two recursive calls, getting tacked onto the tree as the right child of Oregon.  Follow through the code, writing the steps down on paper if necessary, to see how this is done.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {               Main\par                    \\\par                     \\\par                      Oregon\par                       \\\par                        \\\par }\pard \s23\qj\fi360\widctlpar\adjustright {                        Texas\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The last state is Colorado.  Since Colorado is less than Main, it is added as the left child of Main.  Our final tree looks like this:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {               Main\par               /    \\\par              /      \\\par      Colorado        Oregon\par                       \\\par                        \\\par }\pard \s23\qj\fi360\widctlpar\adjustright {                        Texas\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par By now, you may have noticed one of the problems with binary trees.  To keep the search time to a minimum, you want the tree to be balanced.  What that means is that, when you start at the top, the top element of the tree is also the middle element, so that the compare splits the tree in half.  In this example, if we had started with Colorado, adding the states in alphabetical order, we would have ended up with a pretty poor excuse for a tree:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {     Colorado\par              \\\par               \\\par                Main\par                 \\\par                  \\\par                   Oregon\par                    \\\par                     \\\par }\pard \s23\qj\fi360\widctlpar\adjustright {                     Texas\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par You can add a new structure to the tree and shuffle the tree around at the same time to make sure it stays balanced.  We won't cover how, since it involves some fairly advanced pointer manipulation.  In practical situations, it also isn't necessary to create a perfectly balanced tree.  If structures are added to the tree in a fairly random manner, the savings of using a tree instead of a linked list are still enormous.  Whether the extra effort involved in balancing the tree is worth the time depends on how often the tree will be searched and how random the structures are.  In our application, they are fairly random.\par Searching a binary tree is pretty trivial once you know how to create one.  After all, adding a new structure to the tree searches the tree as a side effect!  Here's a function, based on the Add function, that will search the tree, returning a pointer to the correct structure, or NULL if the structure does not exist:\par \par }\pard\plain \s23\qj\widctlpar\adjustright \f6\fs20\cgrid {\fs18 treePtr Search (treePtr ptr, char str[20])\par \par /* Search the tree for a structure     */\par /*                                     */\par /* Parameters:                         */\par /*    ptr - next node in the tree      */\par /*    str - value to search for        */\par /*                                     */\par /* Returns:                            */\par /*    Pointer to the matching          */\par /*       structure; NULL if the        */\par /*       structure does not exist.     */\par \par \{\par int cmp;   /* result of string compare */\par \par if (ptr == NULL)\par    return NULL;\par cmp = strcmp(rec->str, str);\par if (cmp < 0)\par    return Search(ptr->left, rec);\par else if (cmp > 0)\par    return Search(ptr->right, rec);\par else\par    return ptr;\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par This is one of those subroutines that you might struggle for a long time to come up with on your own, but is so simple that once you see it, it is easy to understand and remember.  Trace through the subroutine, looking for Oregon and Indiana if you aren't sure how it works.\par Finally, we come to a subject that impacts directly on our cross-reference program.  Using a method called recursive tree traversal, we can write a very simple subroutine that will trace through the tree, doing something in order.  In our case, we want to print the symbols found in the C program.  Here's a simple print subroutine that prints the states in our example program; the subroutine in the C cross reference program will have exactly the same structure.\par \par }\pard\plain \s23\qj\widctlpar\adjustright \f6\fs20\cgrid {\fs18 void Print (treePtr ptr)\par \par /* Print a tree                        */\par /*                                     */\par /* Parameters:                         */\par /*    ptr - next node in the tree      */\par \par \{\par if (ptr != NULL) \{\par    Print(ptr->left);\par    printf("%s\\n", ptr->str);\par    Print(ptr->right);\par    \}\par \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Notice how, once again, recursion simplifies the problem.  At any particular place in the tree, we need to print all of the names that come before the one we are working on first, so we call Print to do that.  Next, we need to print the structure we are working on.  Finally, we print all of the names that come after the one we just printed.  The initial check to make sure ptr is not NULL keeps us from stepping off of the "end" of the tree.\par \par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 16.2. }{ Add the print subroutine to the binary tree sample program.  Try the program with a variety of names, using the debugger to see how the program works if you are not sure, yet.\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard\plain \s24\qj\fi-360\li360\widctlpar\adjustright \f4\fs20\cgrid {\b Problem 16.3. }{ Change the XREF program so it builds a binary tree for the symbol table instead of a linked list.  The easy way to do this is to use the Insert subroutine to insert each symbol in the program into the symbol table.  Because of the way the insert subroutine is written, if the symbol already exists, a new symbol is not created.  You then call the Search subroutine to find the correct entry in the symbol table (which must exist, since you just created one if there wasn't one already), and enter the appropriate line number.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {A more challenging, and more efficient way to implement the program is to combine the Search and Insert subroutines, creating a function that returns a pointer to the correct entry in the symbol table, creating one if one did not already exist.  This is the method the solution uses.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {In either case, printing the symbol table is a simple matter of modifying the Print subroutine from the text.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }{\b Problem 16.4. }{ Add a new check to the XREF program that checks to see if the symbol just found is a reserved word in C.  You can find a list of the reserved words in your C reference manual.\par \par }\pard \s24\qj\li360\widctlpar\adjustright {An easy way to handle reserved words is to add a new flag to each symbol table entry that tells if the entry is a reserved word.  If you find a reserved word, you skip adding the line number to the line number list.  When printing the symbol table, you again skip reserved words.\par }\pard \s24\qj\fi-360\li360\widctlpar\adjustright {\par }\pard \s24\qj\li360\widctlpar\adjustright {Creating the reserved word list in the first place is a little tedious.  You will need a subroutine that calls Insert for each of the reserved words.  There is an optimum order to add the reserved words.  See if you can figure it out by thinking about the way trees are created, referring to the example where the names of four states were entered into a tree.\par }\pard\plain \qc\widctlpar\adjustright \f4\cgrid {\b\fs36 \par \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \qc\widctlpar\adjustright \f4\cgrid {\b\fs36 Lesson Sixteen\par Solutions to Problems\par }\pard \qj\widctlpar\adjustright {\b\fs28 \par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {Solution to problem 16.1.\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Implement a binary search                                    */\par \par #include <stdio.h>\par \par #define SIZE 100                        /* size of the array */\par \par int a[SIZE];                            /* array to search */\par \par \par int Find (int val)\par \par /* Find the index of a matching array element                   */\par /*                                                              */\par /* Parameters:                                                  */\par /*    val - value to find                                       */\par /*                                                              */\par /* Returns:                                                     */\par /*    Returns the array index of the matching array value.      */\par /*    If there are no matching array values, -1 is returned.    */\par /*                                                              */\par /* Variables:                                                   */\par /*    a - array to search                                       */\par \par \{\par int left,right,middle;                  /* array indices */\par \par left = 0;\par right = SIZE-1;\par do \{\par    middle = (left+right) / 2;\par    if (val < a[middle])\par       right = middle-1;\par    else\par       left = middle+1;\par    \}\par while ((val != a[middle]) && (left <= right));\par if (val == a[middle])\par    return middle;\par return -1;\par \}\par \par \par void Fill (void)\par \par /* Fill the array                                               */\par /*                                                              */\par /* Variables:                                                   */\par /*    a - array to search                                       */\par \par \{\par int i;                                  /* loop index */\par \par for (i = 0; i < SIZE; ++i)\par    a[i] = (i+1)*2;\par \}\par \par \par void Test (void)\par \par /* Test the Find procedure                                      */\par \par \{\par int i;                                  /* loop index */\par \par for (i = 0; i < SIZE; ++i)  /* check to be sure each value can be found */\par    if (a[Find((i+1)*2)] != (i+1)*2)\par       printf("Failed to find %d\\n", i*2);\par if (Find(0) != -1)     /* check to be sure missing values are not found */\par    printf("Reported \\"found\\" for Find(0)\\n");\par if (Find(101) != -1)\par    printf("Reported \\"found\\" for Find(101)\\n");\par if (Find(202) != -1)\par    printf("Reported \\"found\\" for Find(202)\\n");\par \}\par \par \par void main (void)\par \par /* main program                                                 */\par \par \{\par Fill();                                 /* fill the array */\par Test();                                 /* test the Find procedure */\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344630}Solution to problem 16.2.{\*\bkmkend _Toc496344630}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* Create a binary tree from keyboard strings */\par \par #include <stdio.h>\par #include <string.h>\par #include <stdlib.h>\par \par typedef struct treeStruct \{             /* tree entry */\par    struct treeStruct *left, *right;\par    char str[20];\par    \}\par    treeStruct, *treePtr;\par \par treePtr tree = NULL;                    /* top of the tree */\par \par \par void Add (treePtr *ptr, treePtr rec)\par \par /* Add a record to the tree                                     */\par /*                                                              */\par /* Parameters:                                                  */\par /*    ptr - next node in the tree                               */\par /*    rec - record to add to the tree                           */\par \par \{\par int cmp;                                /* result of strcmp */\par \par if (*ptr == NULL)\par    *ptr = rec;\par else \{\par    cmp = strcmp(rec->str, (*ptr)->str);\par    if (cmp < 0)\par       Add(&((*ptr)->left), rec);\par    else if (cmp > 0)\par       Add(&((*ptr)->right), rec);\par    \}\par \}\par \par \par void Print (treePtr ptr)\par \par /* Print a tree                                                 */\par /*                                                              */\par /* Parameters:                                                  */\par /*    ptr - next node in the tree                               */\par \par \{\par if (ptr != NULL) \{\par    Print(ptr->left);\par    printf("%s\\n", ptr->str);\par    Print(ptr->right);\par    \}\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void main (void)\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par /* Main program                                                 */\par \par \{\par char str[20];                           /* work string */\par treePtr tPtr;                           /* work pointer */\par \par do \{\par    printf("string: ");                  /* get a string */\par    scanf("%19[^\\n]%*1[\\n]", str);\par    if (strlen(str)) \{\par                                         /* create a new record */\par       tPtr = (treePtr) malloc(sizeof(treeStruct));\par       tPtr->left = NULL;\par       tPtr->right = NULL;\par       strcpy(tPtr->str, str);\par       Add(&tree, tPtr);                 /* add it to the tree */\par       \}\par    \}\par while (strlen(str));                   /* loop until no string is given */\par Print(tree);                            /* print the tree in order */\par \} \par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344631}Solution to problem 16.3.{\*\bkmkend _Toc496344631}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* XREF                                                         */\par /*                                                              */\par /* This program generates a cross reference of a C program,     */\par /* showing where any symbol is used.  To use XREF, start by     */\par /* selecting the shell window.  Type                            */\par /*                                                              */\par /*    xref filename                                             */\par /*                                                              */\par /* where filename is the name of the program you want to cross- */\par /* reference.                                                   */\par \par #include <stdio.h>\par #include <ctype.h>\par #include <string.h>\par #include <stdlib.h>\par \par #define symbolLength 80                 /* max length of a symbol */\par \par char fName[65];                         /* file name */\par FILE *f;                                /* file variable */\par char *fNamePtr;                         /* pointer to the file name */\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {typedef struct lineStruct \{             /* line number list */\par    struct lineStruct *next;\par }\pard \s23\qj\fi360\widctlpar\adjustright {   int number;\par    \}\par    lineStruct, *linePtr;\par \par typedef struct symbolStruct \{           /* symbol table entry */\par    struct symbolStruct *left, *right;\par    char symbol[symbolLength+1];\par    linePtr lines;\par    \}\par    symbolStruct, *symbolPtr;\par \par \par symbolPtr symbols = NULL;               /* symbol table */\par int lineNumber = 1;                     /* current line number */\par char ch = ' ';                          /* current character */\par char token[symbolLength+1];             /* current token */\par int tokenLine;                         /* line number at start of token */\par \par \par void GetCh (void)\par \par /* Read a character from the file                               */\par /*                                                              */\par /* Variables:                                                   */\par /*    ch - character read                                       */\par /*    lineNumber - current line number                          */\par \par \{\par ch = fgetc(f);\par if (ch == '\\n')\par    ++lineNumber;\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void SkipComment (void)\par \par /* Skip comments in the program                                 */\par \par \{\par do \{\par    GetCh();\par    if (ch == '*') \{\par       GetCh();\par       if (ch == '/')\par          return;\par       \}\par    \}\par while (ch != EOF);\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par \par \par void NextCh (void)\par \par /* Get the next character from the file, skipping comments      */\par \par \{\par GetCh();                                /* get the next character */\par if (ch == '/') \{                        /* skip comments */\par    GetCh();\par    if (ch == '*') \{\par       GetCh();\par       SkipComment();\par       \}\par    \}\par \}\par \par \par void GetToken (void)\par \par /* Read a word from the source file                             */\par /*                                                              */\par /* Variables:                                                   */\par /*    lineNumber - current line number                          */\par /*    token - string read                                       */\par /*    tokenLine - line number at the start of the token         */\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {\{\par int len = 0;                            /* length of the token */\par \par if (ch != EOF) \{\par                                         /* skip to the next token */\par    while ((!iscsymf(ch)) && (ch != EOF))\par       GetCh();\par    tokenLine = lineNumber;              /* record the line number */\par }\pard \s23\qj\fi360\widctlpar\adjustright {                                        /* record the token */\par    while (iscsym(ch) && (ch != EOF)) \{\par       if (len < symbolLength) \{\par          token[len] = ch;\par          ++len;\par          \}\par       GetCh();\par       \}\par    \}\par token[len] = (char) 0;                  /* mark the end of the string */\par \}\par \par \par void AddUse (symbolPtr ptr)\par \par /* Add a line number to the symbol table entry                  */\par /*                                                              */\par /* Parameters:                                                  */\par /*    ptr - symbol table entry to update                        */\par /*                                                              */\par /* Variables:                                                   */\par /*    tokenLine - line number at the start of the token         */\par \par \{\par linePtr lPtr;                           /* current line number pointer */\par \par lPtr = (linePtr) malloc(sizeof(lineStruct));\par lPtr->next = ptr->lines;\par ptr->lines = lPtr;\par lPtr->number = tokenLine;\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void Insert (symbolPtr *ptr)\par \par /* Insert a symbol use in the symbol table.  If the symbol does */\par /* not exist, create a new entry.                               */\par /*                                                              */\par /* Parameters:                                                  */\par /*    ptr - pointer to the top node of the tree                 */\par /*                                                              */\par /* Variables:                                                   */\par }\pard \s23\qj\fi360\widctlpar\adjustright {/*    token - symbol to insert                                  */\par \par \{\par symbolPtr sPtr;                         /* work pointer */\par int cmp;                                /* result of strcmp */\par \par if (*ptr == NULL) \{                     /* no entry: create one */\par    sPtr = (symbolPtr) malloc(sizeof(symbolStruct));\par    sPtr->left = NULL;\par    sPtr->right = NULL;\par    strcpy(sPtr->symbol, token);\par    sPtr->lines = NULL;\par    *ptr = sPtr;                         /* add it to the tree */\par    AddUse(sPtr);                        /* mark the line number */\par    \}\par else \{\par    cmp = strcmp(token, (*ptr)->symbol);\par    if (cmp < 0)\par       Insert(&((*ptr)->left));          /* follow the left link */\par    else if (cmp > 0)\par       Insert(&((*ptr)->right));         /* follow the right link */\par    else\par       AddUse(*ptr);                     /* found an existing entry */\par    \}\par \}\par \par \par void PrintNumber (linePtr nPtr)\par \par /* Recursively print the line numbers in reverse order          */\par /*                                                              */\par /* Parameters:                                                  */\par /*    nPtr - pointer to the remainder of the line number list   */\par \par \{\par if (nPtr != NULL) \{\par    PrintNumber(nPtr->next);\par    printf("%d ", nPtr->number);\par    \}\par \}\par \par \par void PrintSymbols (symbolPtr ptr)\par \par /* Print the symbols found and line numbers                     */\par /*                                                              */\par /* Parameters:                                                  */\par /*    ptr - pointer to the next node in the symbol table        */\par \par \{\par if (ptr != NULL) \{\par    PrintSymbols(ptr->left);             /* print symbols to the left */\par    printf("%16s  ", ptr->symbol);      /* print this symbol */\par    PrintNumber(ptr->lines);\par    printf("\\n");\par    PrintSymbols(ptr->right);            /* print symbols to the right */\par    \}\par \}\par \par \par int main (int argc, char *argv[])\par \par /* Main program                                                 */\par \par \{\par if (argc < 2) \{                         /* get a file name */\par    printf("File to cross reference: ");\par    fNamePtr = fName;\par    scanf("%64s", fName);\par    if (strlen(fName) == 0)\par       return -1;\par    \}\par else \{\par    if (argc > 2)\par       printf("Extra input ignored.\\n");\par    fNamePtr = argv[1];\par    \}\par \par f = fopen(fNamePtr, "r");               /* open the file */\par if (f == NULL) \{\par    printf("Could not open %s.\\n", fNamePtr);\par    return -1;\par    \}\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {do \{                                 /* collect the symbols in the file */\par    GetToken();\par    if (strlen(token))\par       Insert(&symbols);\par    \}\par while (strlen(token));\par PrintSymbols(symbols);                  /* print the symbol table */\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par fclose(f);                              /* close the file */\par return 0;                               /* return with no error */\par \}\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344632}Solution to problem 16.4.{\*\bkmkend _Toc496344632}\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* XREF                                                         */\par /*                                                              */\par /* This program generates a cross reference of a C program,     */\par /* showing where any symbol is used.  To use XREF, start by     */\par /* selecting the shell window.  Type                            */\par /*                                                              */\par /*    xref filename                                             */\par /*                                                              */\par /* where filename is the name of the program you want to cross- */\par /* reference.                                                   */\par \par #include <stdio.h>\par #include <ctype.h>\par #include <string.h>\par #include <stdlib.h>\par \par #define symbolLength 80                 /* max length of a symbol */\par \par char fName[65];                         /* file name */\par FILE *f;                                /* file variable */\par char *fNamePtr;                         /* pointer to the file name */\par \par typedef struct lineStruct \{             /* line number list */\par    struct lineStruct *next;\par    int number;\par    \}\par    lineStruct, *linePtr;\par \par typedef struct symbolStruct \{           /* symbol table entry */\par    struct symbolStruct *left, *right;\par    char symbol[symbolLength+1];\par    int reserved;\par    linePtr lines;\par    \}\par    symbolStruct, *symbolPtr;\par \par \par symbolPtr symbols = NULL;               /* symbol table */\par int lineNumber = 1;                     /* current line number */\par char ch = ' ';                          /* current character */\par char token[symbolLength+1];             /* current token */\par int tokenLine;                         /* line number at start of token */\par \par \par void GetCh (void)\par \par /* Read a character from the file                               */\par /*                                                              */\par /* Variables:                                                   */\par /*    ch - character read                                       */\par /*    lineNumber - current line number                          */\par \par \{\par ch = fgetc(f);\par if (ch == '\\n')\par    ++lineNumber;\par \}\par \par \par void SkipComment (void)\par \par /* Skip comments in the program                                 */\par \par \{\par do \{\par    GetCh();\par    if (ch == '*') \{\par       GetCh();\par       if (ch == '/')\par          return;\par       \}\par    \}\par while (ch != EOF);\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void NextCh (void)\par \par /* Get the next character from the file, skipping comments      */\par \par \{\par GetCh();                                /* get the next character */\par if (ch == '/') \{                        /* skip comments */\par    GetCh();\par    if (ch == '*') \{\par       GetCh();\par }\pard \s23\qj\fi360\widctlpar\adjustright {      SkipComment();\par       \}\par    \}\par \}\par \par \par void GetToken (void)\par \par /* Read a word from the source file                             */\par /*                                                              */\par /* Variables:                                                   */\par /*    lineNumber - current line number                          */\par /*    token - string read                                       */\par /*    tokenLine - line number at the start of the token         */\par \par \{\par int len = 0;                            /* length of the token */\par \par if (ch != EOF) \{\par                                         /* skip to the next token */\par    while ((!iscsymf(ch)) && (ch != EOF))\par       GetCh();\par    tokenLine = lineNumber;              /* record the line number */\par                                         /* record the token */\par    while (iscsym(ch) && (ch != EOF)) \{\par       if (len < symbolLength) \{\par          token[len] = ch;\par          ++len;\par          \}\par       GetCh();\par       \}\par    \}\par token[len] = (char) 0;                  /* mark the end of the string */\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void AddUse (symbolPtr ptr)\par \par /* Add a line number to the symbol table entry                  */\par /*                                                              */\par }\pard \s23\qj\fi360\widctlpar\adjustright {/* Parameters:                                                  */\par /*    ptr - symbol table entry to update                        */\par /*                                                              */\par /* Variables:                                                   */\par /*    tokenLine - line number at the start of the token         */\par \par \{\par linePtr lPtr;                           /* current line number pointer */\par \par lPtr = (linePtr) malloc(sizeof(lineStruct));\par lPtr->next = ptr->lines;\par ptr->lines = lPtr;\par lPtr->number = tokenLine;\par \}\par \par \par void Insert (symbolPtr *ptr, int reserved)\par \par /* Insert a symbol use in the symbol table.  If the symbol does */\par /* not exist, create a new entry.                               */\par /*                                                              */\par /* Parameters:                                                  */\par /*    ptr - pointer to the top node of the tree                 */\par /*    reserved - is this a reserved word?                       */\par /*                                                              */\par /* Variables:                                                   */\par /*    token - symbol to insert                                  */\par \par \{\par symbolPtr sPtr;                         /* work pointer */\par int cmp;                                /* result of strcmp */\par \par if (*ptr == NULL) \{                     /* no entry: create one */\par    sPtr = (symbolPtr) malloc(sizeof(symbolStruct));\par    sPtr->left = NULL;\par    sPtr->right = NULL;\par    strcpy(sPtr->symbol, token);\par    sPtr->reserved = reserved;\par    sPtr->lines = NULL;\par    *ptr = sPtr;                         /* add it to the tree */\par    if (!reserved)                       /* mark the line number */\par       AddUse(sPtr);\par    \}\par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {else \{\par    cmp = strcmp(token, (*ptr)->symbol);\par    if (cmp < 0)\par }\pard \s23\qj\fi360\widctlpar\adjustright {      Insert(&((*ptr)->left), reserved); /* follow the left link */\par    else if (cmp > 0)\par       Insert(&((*ptr)->right), reserved); /* follow the right link */\par    else if (!(*ptr)->reserved)\par       AddUse(*ptr);                     /* found an existing entry */\par    \}\par \}\par \par \par void PrintNumber (linePtr nPtr)\par \par /* Recursively print the line numbers in reverse order          */\par /*                                                              */\par /* Parameters:                                                  */\par /*    nPtr - pointer to the remainder of the line number list   */\par \par \{\par if (nPtr != NULL) \{\par    PrintNumber(nPtr->next);\par    printf("%d ", nPtr->number);\par    \}\par \}\par \par \par void PrintSymbols (symbolPtr ptr)\par \par /* Print the symbols found and line numbers                     */\par /*                                                              */\par /* Parameters:                                                  */\par /*    ptr - pointer to the next node in the symbol table        */\par \par \{\par if (ptr != NULL) \{\par    PrintSymbols(ptr->left);             /* print symbols to the left */\par    if (!ptr->reserved) \{\par       printf("%16s  ", ptr->symbol);    /* print this symbol */\par       PrintNumber(ptr->lines);\par       printf("\\n");\par       \}\par    PrintSymbols(ptr->right);            /* print symbols to the right */\par    \}\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void ReservedWords (void)\par \par /* Add the C reserved words to the symbol table */\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par \{\par strcpy(token, "if");            Insert(&symbols, 1);\par strcpy(token, "default");       Insert(&symbols, 1);\par strcpy(token, "case");          Insert(&symbols, 1);\par strcpy(token, "asm");           Insert(&symbols, 1);\par strcpy(token, "auto");          Insert(&symbols, 1);\par strcpy(token, "break");         Insert(&symbols, 1);\par strcpy(token, "comp");          Insert(&symbols, 1);\par strcpy(token, "char");          Insert(&symbols, 1);\par strcpy(token, "continue");      Insert(&symbols, 1);\par strcpy(token, "const");         Insert(&symbols, 1);\par strcpy(token, "extended");      Insert(&symbols, 1);\par strcpy(token, "double");        Insert(&symbols, 1);\par strcpy(token, "do");            Insert(&symbols, 1);\par strcpy(token, "enum");          Insert(&symbols, 1);\par strcpy(token, "else");          Insert(&symbols, 1);\par strcpy(token, "float");         Insert(&symbols, 1);\par strcpy(token, "extern");        Insert(&symbols, 1);\par strcpy(token, "goto");          Insert(&symbols, 1);\par strcpy(token, "for");           Insert(&symbols, 1);\par strcpy(token, "sizeof");        Insert(&symbols, 1);\par strcpy(token, "register");      Insert(&symbols, 1);\par strcpy(token, "int");           Insert(&symbols, 1);\par strcpy(token, "inline");        Insert(&symbols, 1);\par strcpy(token, "pascal");        Insert(&symbols, 1);\par strcpy(token, "long");          Insert(&symbols, 1);\par strcpy(token, "segment");       Insert(&symbols, 1);\par strcpy(token, "return");        Insert(&symbols, 1);\par strcpy(token, "signed");        Insert(&symbols, 1);\par strcpy(token, "short");         Insert(&symbols, 1);\par strcpy(token, "union");         Insert(&symbols, 1);\par strcpy(token, "struct");        Insert(&symbols, 1);\par strcpy(token, "static");        Insert(&symbols, 1);\par strcpy(token, "typedef");       Insert(&symbols, 1);\par strcpy(token, "switch");        Insert(&symbols, 1);\par strcpy(token, "void");          Insert(&symbols, 1);\par strcpy(token, "unsigned");      Insert(&symbols, 1);\par strcpy(token, "while");         Insert(&symbols, 1);\par strcpy(token, "volatile");      Insert(&symbols, 1);\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {int main (int argc, char *argv[])\par \par /* Main program                                                 */\par \par }\pard \s23\qj\fi360\widctlpar\adjustright {\{\par if (argc < 2) \{                         /* get a file name */\par    printf("File to cross reference: ");\par    fNamePtr = fName;\par    scanf("%64s", fName);\par    if (strlen(fName) == 0)\par       return -1;\par    \}\par else \{\par    if (argc > 2)\par       printf("Extra input ignored.\\n");\par    fNamePtr = argv[1];\par    \}\par \par f = fopen(fNamePtr, "r");               /* open the file */\par if (f == NULL) \{\par    printf("Could not open %s.\\n", fNamePtr);\par    return -1;\par    \}\par \par ReservedWords();                        /* add the reserved words */\par do \{                                 /* collect the symbols in the file */\par    GetToken();\par    if (strlen(token))\par       Insert(&symbols, 0);\par    \}\par while (strlen(token));\par PrintSymbols(symbols);                  /* print the symbol table */\par \par fclose(f);                              /* close the file */\par return 0;                               /* return with no error */\par \}\par }\pard\plain \widctlpar\adjustright \f4\cgrid {\par \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s1\qc\nowidctlpar\outlinelevel0\adjustright \b\f4\fs36\cgrid {{\*\bkmkstart _Toc496344633}Lesson Seventeen{\*\bkmkend _Toc496344633}\par {\*\bkmkstart _Toc496344634}A Project: Developing a Break-Out Game{\*\bkmkend _Toc496344634}\par }\pard\plain \qj\widctlpar\adjustright \f4\cgrid {\b\fs28 \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344635}Designing a Program{\*\bkmkend _Toc496344635}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {There is a basic difference between how you write a large program, and how you write a small one.  So far, every program you have written in this course has been a small one.  I know, some of them have seemed large, but they are really small compared to what experienced programmers can write, even in a single week.  Because the programs are so small, it is quite possible that you can keep all of the details about the program in your head at one time.  That makes it hard to understand why I stress commenting, breaking programs down into pieces with subroutines, or even a consistent indenting style.  For programs under 500 lines or so, these issues are rarely important.  I can tell you from experience, though, that structured programming is crucial when you set out to write a 10,000 line program.\par This lesson exists for one simple reason: to give you at least one hands-on look at how a real program is developed.  While the program we will write in this lesson is not large compared to most commercial programs, it is enormous compared to anything you have written so far.  Writing this program gives you a chance to see, first hand, how the techniques of structured programming and good style can help to develop a program.  You will also see how a program develops iteratively, and how to use the techniques of top-down and bottom-up design when writing a program.\par There is only one problem in this lesson.  The problem is to write a game.  The text of the lesson concentrates more on the thought process that you need to go through to develop the program than on the details of coding.  As you go, though, you should be writing the game.  A complete listing is, of course, given in the solution to the lesson.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344636}The User: That's Who We Write For{\*\bkmkend _Toc496344636}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Absolutely the first step, and the one most often neglected by programmers, engineers, and virtually every other member of a skilled profession, is to step back and realize why we are writing a program in the first place.  The program is being written for someone to use.  Whether we are writing an arcade game, creating the code to run a pacemaker, or simulating the rise and fall of the Roman Empire, the program exists to serve the need of some person or group of people.  The first step in designing a program is to decide who those people are, and what they really want in a program.  Before you decide on your first algorithm, before you write your first line of code, you need to decide what the program does, who the program does it for, and what they want the program to do.\par Our program is a simple arcade game called Break Out.  It's been around since the dawn of time \endash  in computer terms, that was about 1970 or so.  When the game starts, there are several rows of bricks along the top of the screen.  Along the bottom is a paddle; it shows up as a line about an inch wide.  A ball drops from the vicinity of the bricks; the object is to move the mouse to hit the ball, sending it back up to the bricks.  Each time the ball hits a brick, the brick goes away, and the payer's score goes up.  If all of the bricks get knocked out, a new set of bricks appear, one row closer to the bottom of the screen.  If the player misses a ball, it vanishes, and a new ball drops from the screen.  We will start the player with three balls, and add one more each time all of the bricks are knocked off of the screen.\par This may seem like a pretty simple game, and it is.  It can also be very addicting.  I have spent hours playing Break Out when there were other things to do.  Even my kids enjoy it \endash  when I give them a chance to play!\par The first step in designing the program is to make sure you can visualize the screen, and what will happen at each step of the program.  For a graphics program like this one, a simple, rough sketch is a great aid.  Grab a pencil and paper, and draw a large rectangle to represent the screen.  Along the top, draw six rows of bricks.  These should be in the top quarter of the screen, and there should be a gap above the bricks.\par There are two things a player will want to keep track of while the game is being played: the current score, and the number of balls he has left.  We'll put these along the bottom of the screen, in the left and right corner.  Right above this text information is where the paddle will be.  It is a simple line.\par While the game is being played, the only action the player can take is to move the mouse back and forth, which in turn moves the paddle back and forth on the screen.  Sketch the paddle just above the text that gives the score and number of balls.\par The program itself, of course, is doing a bit more.  In addition to tracking the progress of the mouse, the program is moving the ball across the screen.  There are several things that can happen to the ball.  Outlining these cases clearly now is pretty easy, especially if you imagine the ball bouncing around on your sketch.  If you look at the outline, below, of what the ball does, you can probably visualize what the code to handle the ball will look like, too, in terms of the if statements that will be needed.  Here's a table that describes the various things that can happen as the ball moves around the screen.\par \par }\pard \s21\qj\fi-360\li720\widctlpar\adjustright {1.\tab If the ball hits the paddle, it will rebound toward the top of the screen.  The paddle is restricted to a row along the bottom of the screen, so we can check to see if the ball has hit the paddle by checking the Y coordinate (the Y coordinate is the vertical position) of the ball.  If it matches the Y coordinate of the paddle, we can check to see if the ball has hit the paddle by comparing the X coordinate (the horizontal position) of the ball with the left and right edges of the paddle.\par \par \tab Something that makes the game a lot more interesting is to add some spin to the paddle.  If the ball hits the center of the paddle, we will bounce it straight back up.  If the ball hits a little to one side, we can send it off at a small angle.  If the ball hits near the edge of the paddle, we send it back up at a steep angle.  In all cases, we send the ball back up.  The thing we are changing is the velocity of the ball in the y direction.  You can probably visualize how this will work on paper; later we will work through the details of how to make it happen in the computer.\par \par 2.\tab The next case is if the ball reaches the paddle row, but does not hit the paddle.  In other words, the player missed.  In that case, the ball vanishes, and we go back to the starting point.\par \par 3.\tab The ball could hit the left, right, or top of the screen.  In that case, we bounce the ball back toward the middle.  We actually wrote a sample program to do this once, a long time ago.\par \par 4.\tab The ball could hit a brick.  In that case, we do several things.  First, we erase the brick.  Second, we update the score, adding some points for eliminating the brick.  Finally, the ball bounces back.\par \par \tab An important point to remember here is that the ball can hit a brick from the bottom, the top, or even from the side.  For example, if the player pokes a hole in the bricks, the ball can whiz through at an angle, and start bouncing off of the top of the screen and the top of the highest row of bricks.  If the ball doesn't make it all the way through the hole, it could hit a brick on the side.  We need to make sure that our ball can bounce in an appropriate direction, regardless of which side of the brick it hits.\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par Now that we know how the action part of the game is played, we need to back up and figure out how to start the game.  While a game is being played, the player will eventually miss a ball.  When that happens, it would be nice to give the guy a chance to catch his breath.  One way to do this is to print a message on the screen and wait for the player to press the mouse button.  We'll try that first, and see how it works in our program.\par When the game starts, and after each game is played, we need to print some sort of message.  They player will need two options: playing a game or quitting.  One way to handle this is to write a couple of text messages on the screen, with lines around the messages to make them look like buttons.  We will let the person move the same arrow cursor that you are used to around the screen.  When the player presses the mouse button, the program will check to see if the arrow is inside one of our boxes; if so, the program will either quit or start a game, depending on which box the arrow is in.\par You may notice that this planning process has left out a lot of details.  For example, we haven't decided what all of the text messages will be.  You don't know how to move the mouse, or how to make an arrow cursor move around the screen.  We haven't decided exactly how big the bricks will be, or where they will be placed.\par Some of these details are important at this point, and some are best left until later.  How to deal with the mouse is important: how it is done will shape the design of the program.  That means we need to do a little research, and possibly develop a few subroutines before we really start the program.  What text we write on the screen, how big the bricks and paddle are, and exactly where they go doesn't matter.  You can jot down some ideas now, or just wait until you are working on that part of the program.  The exact size and position of the bricks is sure to be something we change as the program develops.  We'll try several possibilities, and pick the one that works best.  In short, the thing to be sure of right now is that you know how to do all of the things, like moving the mouse, that you will need to do.  The details can, and in some cases must, be left until the program starts to take shape.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344637}Laying the Groundwork{\*\bkmkend _Toc496344637}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The first step in developing the program is to learn how to do the things we don't already know how to do.  The obvious thing, in this case, is to learn to read and handle the mouse.  This is also the stage of development where you might hit the books.  For example, if you are writing an astronomy program, this is the time to dig through books to find the appropriate formulas.  It's a good time to find out what star data bases are available, too, and what format they come in.\par For our program we need to know how Apple IIGS programs deal with the mouse, and how we go about using those abilities.  The way this is done is tied up in the concept of an event loop.\par To understand what an event loop is, and what it has to do with a mouse, let's start by thinking about how our program might work.  Basically, while the game is running, the program needs to do two things: move the ball, handling anything that might happen if the ball hits something, and move the paddle as the player moves the mouse.  The way we do this is to loop over basic calls to subroutines until the ball missed the paddle, something like this:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {do \{\par    MoveBall();\par    MovePaddle();\par    \}\par }\pard \s23\qj\fi360\widctlpar\adjustright {while (balls != 0);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {In the language of the Apple IIGS, this is very, very close to being an even loop.  The idea of an event loop is to loop, waiting for something to happen.  We start the loop with a call to the event manager to get the next event.  An event is basically something the player did.  It could be pressing a mouse button, pressing a key, or clicking in a menu bar.  It can also be a null event, which is a fancy way of saying nothing happened.  No matter what kind of event has occurred, though, the event manager fills in a record and passes some information back to us.  The important part of that information, from our standpoint, is the current position of the mouse.  In a nutshell, that's how we read the mouse.  It only takes a tiny change to turn the main loop we just wrote into an Apple IIGS event loop that reads the location of the mouse for us each time through the loop.\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {do \{\par    event = GetNextEvent(\par       EVENTMASK,\par       &myevent);\par    MoveBall();\par    MovePaddle();\par    \}\par }\pard \s23\qj\fi360\widctlpar\adjustright {while (balls != 0);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The event manager returns a boolean flag that tells us whether an event occurred.  We don't really care: in our game, the player can click on the button, pound on the keyboard, or whatever, and the program will ignore him.  The only thing that is important to us is where the mouse is.  The position of the mouse is returned in myevent, which is a structure with a type of EventRecord.  You need to include event.h, the event manager's header file, in your program to use GetNextEvent; event.h also pulls in the correct header file to define EventRecord.\par When you are learning about a new structure, it is a good idea to actually look at the source code for the toolbox interface files to see how the structure is defined.  Here is the definition for an event record:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {struct EventRecord \{\par    int what;\par    long message;\par    long when;\par    Point where;\par    int modifiers;\par }\pard \s23\qj\fi360\widctlpar\adjustright {   \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Most of these fields are of no interest to us at the moment, although we will use a couple more later.  The what field is filled in with a number that indicates what kind of an event occurred.  There is one number for a key press, another for pressing on the mouse button, still another for letting up on the mouse button, and so on.  We will use this field later, when we try to decide if the player has clicked on a mouse button.\par The meaning of the message field varies, depending on what kind of event occurs.  For a key press, for example, this field tells what key was pressed.\par The when field is a primitive timer.  The Apple IIGS keeps track of how many 1/60ths of a second have elapsed since the event manager was started; the value is returned in this field.  This is a good way to decide if a certain amount of time has passed.\par The field we are really interested in at the moment is the where field.  This field is actually a structure itself.  The structure is a point, which is a structure used by the toolbox to hold both an x and y position at the same time.  The event manager fills in this field with the current position of the mouse.  As you move the mouse across your desktop, the Apple IIGS keeps track of it, changing the position.  The position is reported as a point on the screen; it ranges from 0 to 640 horizontally, and 0 to 200 vertically.  If you start the event manager in the 320 graphics mode, the position for the mouse is adjusted so that the horizontal position varies from 0 to 320.  In other words, a lot of work is being done to keep things simple for you.\par The modifiers field contains still more information about the particular event that the event manager is reporting.\par If you check the EventRecord structure in event.h, you will find a couple of differences between that structure and the one shown here.  The structure in event.h uses types of Word and LongWord for int and long; these are just macros that replace int and long.  You will also find some other fields after the modifiers field; these are used by other tool calls besides GetNextEvent which share the EventRecord structure with GetNextEvent.  Since they are not filled in by GetNextEvent, we won't worry about them in our program.\par There is one minor complication that we will have to deal with.  We are used to writing and debugging graphics programs in the graphics window.  The event manager returns the position of the mouse on the screen, not it's position within our window.  Fortunately, there is a simple call called GlobalToLocal, defined in quickdraw.h, that will change the values of a point so they are given in relation to the current window, rather than the screen as a whole.\par Putting all of this together, the sample program in listing 17.1 moves a paddle back and forth in the graphics window.  Naturally, we have to start the event manager.  This program gives an adaptation of the graphics startup code from lesson 12 that also starts the event manager.  The only other new call is GetPortRect, defined in quickdraw.h, while fills in a rectangle that tells you how big the graphics window is.  This lets the program adapt to whatever size you set the graphics window to, instead of assuming some fixed size.  The rectangle itself is yet another toolbox structure that contains the top, bottom, left and right coordinates of the window you are drawing in \endash  or the entire graphics screen if your program is not using the window manager.\par \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {\b Listing 17.1\par \par }\pard\plain \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright \f6\fs20\cgrid {/* Move a paddle in the graphics window */\par \par #include <quickdraw.h>\par #include <event.h>\par #include <memory.h>\par \par #include <orca.h>\par \par #define EVENTMASK 0x0F6E                /* GetNextEvent event mask */\par #define SIZE 640                        /* graphics mode */\par \par EventRecord myevent;                    /* current event record */\par int maxX;                       /* max X distance the paddle can travel */\par int paddlePosition = 0;             /* current X position of the paddle */\par Rect screen;                            /* port rectangle */\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {void StartTools (void)\par \par /* Start the tools                                              */\par \par \{\par handle memory;                          /* memory returned by NewHandle */\par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {Rect r;                                 /* screen size */\par \par startgraph(SIZE);                       /* initialize QuickDraw */\par SetPenMode(2);                          /* pen mode = xor */\par SetPenSize(1,1);                        /* use a square pen */\par SetSolidPenPat(15);                     /* paint the screen white */\par GetPortRect(&r);\par PaintRect(&r);\par SetSolidPenPat(0);                      /* use a black pen */\par memory = NewHandle(256L,userid(),0xC015,0L); /* start up the event mgr */\par EMStartUp((int) *memory, 0, 0, SIZE, 0, 200, userid());\par FlushEvents(0xFFFF, 0);\par \}\par \par \par void ShutDownTools (void)\par \par /* Shut down the tools                                          */\par \par \{\par EMShutDown();\par endgraph();\par \}\par \par \par void DrawPaddle (int position, int color)\par \par /* Draw the paddle                                              */\par /*                                                              */\par /* Parameters:                                                  */\par /*    position - position to draw the paddle                    */\par /*    color - color of the paddle                               */\par \par #define WIDTH 70                        /* width of the paddle */\par #define HEIGHT 3                        /* height of the paddle */\par \{\par int y;                          /* position of the paddle on the screen */\par \par SetPenSize(WIDTH,HEIGHT);      /* set the pen to draw the entire paddle */\par SetSolidPenPat(color);                  /* set the paddle color */\par SetPenMode(0);                          /* use copy mode */\par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {if (position+WIDTH > maxX)   /* make sure we don't go off of the screen */\par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {   position = maxX-WIDTH;\par }\pard \s23\qj\fi360\keepn\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {if (position < 0)\par }\pard \s23\qj\fi360\widctlpar\box\brdrs\brdrw10\brsp20 \adjustright {   position = 0;\par y = screen.v2-12;                       /* find the paddle's y position */\par MoveTo(position,y);                     /* draw the paddle */\par LineTo(position,y);\par \}\par \par \par void MovePaddle (void)\par \par /* Track and move the paddle                                    */\par /*                                                              */\par /* Variables:                                                   */\par /*    paddlePosition - position of the paddle                   */\par /*    myevent - last event returned by GetNextEvent             */\par \par \{\par /* convert the point to our window */\par GlobalToLocal(&myevent.where);\par \par /* if the mouse moved, move the paddle */\par if (myevent.where.h != paddlePosition) \{\par    DrawPaddle(paddlePosition,3);\par    paddlePosition = myevent.where.h;\par    DrawPaddle(paddlePosition,0);\par    \}\par \}\par \par \par void main (void)\par \par /* Main program                                                 */\par \par \{\par int event;                      /* event flag; returned by GetNextEvent */\par \par StartTools();                           /* start the tools */\par GetPortRect(&screen);                   /* set the limit on the paddle */\par maxX = screen.h2;\par DrawPaddle(paddlePosition,0);           /* draw the initial paddle */\par \par do \{                                    /* event loop */\par    event = GetNextEvent(EVENTMASK, &myevent);\par    MovePaddle();\par    \}\par while (!event);\par \par ShutDownTools();                        /* shut down the tools */\par \}\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par }\pard\plain \qj\fi360\widctlpar\adjustright \f4\cgrid {\sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {There are a couple of new things in this program that deserve special attention.  First off, the hardest thing about initializing a tool by making direct calls to the Apple IIGS toolbox is getting the direct page memory so many of the tools need.  That is one of the main reasons that ORCA/C has built-in calls to help you initialize the tools.  In this program, we need to start the event manager, but we don't want to start any of the other desktop tools that startdesk would initialize.  While we won't go into details about the tools in this course, the example in this program showing how to start the event manager can be used as a model for starting other tools.  If you like, you can look up the calls used in the Apple IIGS Technical Reference Manual to see what was done and why.  For the purposes of this course, though, we'll treat the code to start the event manager as a black box: something you can use without understanding it in detail.\par There is a new animation trick in this program that I want you to notice, too.  The MovePaddle procedure has a check to see if the mouse has moved.  If the mouse has not moved, the paddle is not redrawn.  There is a very good reason to make this check.  Without it, if you leave the mouse in one place, the paddle will flicker slightly as it is continuously erased and redrawn.  You don't notice this flicker as much when the paddle is moving, but it is very annoying when the paddle is standing still.\par Finally, we took a cheap way of exiting the loop.  GetNextEvent returns a boolean value that tells us if some event has taken place.  Moving the mouse isn't considered to be an event, so we can move the mouse (and hence the paddle) back and forth to test the program.  As soon as we click the mouse button or press a key, though, the event manager reports the event, and we drop out of the do-while loop.  Later, our checks will get more sophisticated, but this easy mechanism lets us work on parts of the program without putting a lot of effort into things that will change.  This basic idea of simplifying tasks and leaving work for a later time is a very powerful technique.  It allows you to concentrate on a manageable sized part of the program.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344638}Bottom-Up Design Verses Top-Down Design{\*\bkmkend _Toc496344638}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {If you stop and think about it for a moment, we just wrote a program to move a paddle across the screen.  "Of course we did," you say.  "We are writing a break-out game."  True, but there was a method to our madness.  After all, we were really trying to learn how the mouse was used.  On the other hand, we know we will need to move a paddle across the screen for our game, so we wrote the paddle movement subroutines.  As it turns out, we can use these same subroutines, with a few changes in the constants that control the size and position of the paddle, in our game.  Programmers have a name for this: it is called bottom-up design.\par The idea behind bottom-up design is to look at a program, or any problem, and break it down into small parts.  We then do the parts individually, and assemble the finished parts to get a complete program.  When the parts are well-defined, like moving a paddle, this technique works very well.  We can write and test good sized chunks of the program in small test programs, finding problems and making sure the individual pieces work the way we want them to.  That way, when we put the piece in the program, it is probably going to work fine.  And, since we used a small test program to develop it, we don't have to recompile the entire program each time we make a small change to our piece.  Even more important, if there is a bug, there is a lot less code to search through to find the problem.\par If you have been around programming circles, though, you have probably heard about top-down design.  This is just the opposite of bottom-up design: instead of breaking the problem down into pieces, and working on the individual pieces, we organize the problem, and write the main part of the program.  Any pieces are put in the program as empty subroutines, or maybe as a subroutine that just has a message telling that it was called.  These dummy subroutines are called stubs.  We then write and test the pieces, one after the other, until the program is finished.  The process of writing the pieces is called stepwise refinement.\par So which is better?  Actually, that's the wrong question.  It's like asking if a hammer or a saw is a better tool; the answer depends on what you are doing.  In most large programs, we use both methods.  In fact, we have already used both in this lesson.  We started with a top-down design, laying out the basic goals of the program.  We didn't get far before we discovered that there were some things \endash  namely, reading the mouse \endash  that we needed to learn how to do.  We researched this problem, and in the process wrote some subroutines that we will need in our finished game.  Next, we will return to the top-down design method, writing the shell of the program and gradually refining it.\par Here are some rules of thumb to help you choose between the two methods.  Like all rules of thumb, an experienced programmer will be able to point out exceptions.  These are guidelines, not hard and fast rules.\par \par }\pard \s21\qj\fi-360\li720\widctlpar\adjustright {1.\tab Always start your design process from the viewpoint of the user.  The only way to effectively do this is to use the top-down design method.\par \par 2.\tab While you are doing the initial program design, look for general themes that apply to many problems of the kind you are about to solve.  These are often good targets for bottom-up design.  For example, if you are about to write a program to manipulate matrices, you could develop a matrix inversion subroutine that can be used in your program before starting on the main part of the program.  If you will be writing an arcade game, it might be wise to develop the animation routines before you start.\par \par 3.\tab Once any low-level subroutines are developed, return to the top-down design approach.  Write the main program with stubs.  Gradually fill in the stubs until the program is finished, adding your low-level routines developed in step 2 as needed.\par \par 4.\tab Always skip step 2 if you can.  Unless there is a clear reason for developing a subroutine before you start on the main program, it is probably a good idea to implement it as a stub, and fill it in later.  The reason is simple: it is very easy to miss a detail in your initial design pass that could be very important when the subroutine is written.  If you develop the program from the top down, these kinds of details are obvious by the time you get to the point where you are writing the subroutine.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344639}Starting the Program{\*\bkmkend _Toc496344639}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Now that we have finished the basic design, researched the things we didn't know about, and written the low-level routines that we wanted to write, it is time to start on the program itself.  The program that we used to test the paddle movements is actually a very good place to start.  After all, the paddle does move in the window already!\par The first step, then, is to flesh out the sample, putting in stubs for the various subroutines we will need later.  One stub will be the subroutine that writes a message on the screen, and gives the player a chance to quit or play a game.  We can call this stub PlayAGame, and make it return an integer result.  This stub will handle all of the details of putting the message on the screen and figuring out if the player wants to play a game or quit.  If the player wants to quit, the function will return false; otherwise it will return true.  To handle this stub, we will add a while loop around the game's event loop, like this:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {while (PlayAGame())\par    do \{\par       event = GetNextEvent(\par          EVENTMASK,\par          &myevent);\par       MovePaddle();\par       \}\par }\pard \s23\qj\fi360\widctlpar\adjustright {   while (event);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par This brings up an interesting point, though: does our stub return true or false?  It needs to return true so we can play a game.  We need a way for it to return false, though, so we can get out of our program.  We will solve this problem with some simple "throw-away" code.  This is code that we know doesn't work like we want the final program to work, but does the job well enough that we can concentrate on other parts of the program for a while.  For this stub, add a static variable, and initialize it to true.  PlayAGame should return the value of the static variable, but set it to false.  That way, PlayAGame returns true the first time it is called, but false the second time.\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {void PlayAGame (void)\par \par \{\par static int play = 1;\par int ret;\par \par ret = play;\par play = 0;\par return ret;\par }\pard \s23\qj\fi360\widctlpar\adjustright {\}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par It's embarrassing to finish a program and have dead variables around.  When I add dummy variables or dummy code to a program, I always mark it with a comment that looks like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* <<<>>> */\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {This makes it easy to go back later and search for dummy code.  That way, with one search, I can make sure that there is no dummy code or any unused variables left in the program.\par }\pard \s21\qj\fi360\widctlpar\adjustright {In the event loop we need to move the ball and handle the various situations that pop up when the ball hits something.  Add another stub called MoveBall to your event loop.  We will need some way of stopping the game before it is finished.  MoveBall is where the check will eventually be done, so we will put the dummy check in MoveBall now.  We know this is where the check will eventually be, since MoveBall is where we will test to see if we missed the paddle.  If so, and if there are no more balls left, the game is over.  For now, we will test the last event returned by GetNextEvent to see if the mouse button was released, like this:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {if (myevent.what == mouseUpEvt)\par }\pard \s23\qj\fi360\widctlpar\adjustright {   balls = 0;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {This is the first time we have checked the mouse.  There are two basic mouse events, mouseDownEvt and mouseUpEvt.  The first is when the mouse button is pressed down, while the second is when the mouse button is let up.  Generally, we wait until the mouse is released before performing the action, so this code waits for a mouse up event.  Don't forget to change the exit condition for the event loop at the same time!  In the paddle program, the event loop stops when an event occurs.  In our game, it should stop when balls = 0.\par }\pard \s21\qj\fi360\widctlpar\adjustright {We need to draw the initial screen when we start.  Add one last stub right after the call to PlayAGame, called InitScreen.  InitScreen should start by filling the entire screen with a black background.  Naturally, you should go into the startup code for the tools and remove the lines that fill the initial, black screen with a white background!  Finally, move the initial code that draws the paddle and sets paddlePosition into this subroutine.\par One of the things you are used to seeing in a desktop program is an arrow that moves across the screen when the mouse moves.  This arrow is something you have to initialize.  Right after the tools are started, you should put a call to InitCursor in your program.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {InitCursor();\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par This can be done anytime after QuickDraw is started.  It is pretty annoying, though, to have an arrow on the screen while we are moving a paddle.  You may want to leave the arrow on the screen for now, to make it easier to use the debugger, but eventually you will want to add a call to HideCursor, right after the InitCursor call.  HideCursor, which also has no parameters, makes the arrow invisible.  When we add code to the program that allows the player to click on a mouse button, you will want to make the arrow show up again.  ShowCursor does this.  Like the other two cursor calls, ShowCursor does not have any parameters.\par Before moving on, there is one more topic we need to deal with.  The finished program will be a stand-alone graphics program, of course.  In lesson 12, though, you found out that it is best to work within the programming environment as long as you can.  How can we test the program without leaving the programming environment?  The answer involves some tool calls that let you manipulate the size and location of a window.  It turns out that the graphics window is the current port while your program is running under PRIZM.  Using this fact, the subroutine ExpandGraph, shown in listing 17.2, expands the graphics window to the full size of the screen, and brings it to the front, so it is drawn over all of the other windows.  ShrinkGraph returns the graphics window to a reasonable size.  If you are using the debugger while your program runs, you may want to leave out the call to BringToFront.  That way, the source code window will remain visible while you play the game.  The bricks, ball and paddle will move behind the source code window, making it a bit hard to play the game, but at least you will be able to see the source code.  Also, when you return from the program, you will need to click on the program window to make it the front window.  The menu bar will remind you to do this, since many menu items are not available when the graphics window is the front window.\par Add these to your program as throw-away code.  These subroutines use tool calls defined in the window manager header file, so you will need to add window.h to the list of tool header files you include.  Stop now, and get your entire program to work with the stubs.\par \par \par \sect }\sectd \sbknone\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\fi360\keepn\widctlpar\brdrt\brdrs\brdrw10\brsp20 \brdrl\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \adjustright {\b Listing 17.2\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\brdrt\brdrs\brdrw10\brsp20 \brdrl\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \adjustright \f6\fs20\cgrid {void ExpandGraph (void)\par \par /* Expand the graphics window to full screen                    */\par \par \{\par /* <<<>>> */\par MoveWindow(0, 0, GetPort());  /* move the window to the top left corner */\par SetMaxGrow(640, 200, GetPort());        /* let the window get this big */\par }\pard \s23\qj\fi360\widctlpar\brdrt\brdrs\brdrw10\brsp20 \brdrl\brdrs\brdrw10\brsp80 \brdrb\brdrs\brdrw10\brsp20 \brdrr\brdrs\brdrw10\brsp80 \adjustright {SizeWindow(640, 200, GetPort());        /* make the window this big */\par BringToFront(GetPort());             /* bring the graph window to front */\par \}\par \par \par void ShrinkGraph (void)\par \par /* Put the graphics window back in the corner                   */\par \par \{\par /* <<<>>> */\par MoveWindow(320, 115, GetPort());       /* move graph back to the corner */\par SizeWindow(320, 85, GetPort());    /* make the window a reasonable size */\par \}\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par }\pard\plain \qj\fi360\widctlpar\adjustright \f4\cgrid {\sect }\sectd \sbknone\linex-32767\headery1080\footery1080\cols2\colsx360\endnhere\sectdefaultcl \pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344640}Drawing the Bricks{\*\bkmkend _Toc496344640}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The next step is to draw the initial bricks.  There are several things that we need to do to handle the bricks.  Up until now, we have ignored the details, but at this point it is time to stop and think through the issues carefully.  Putting a word to it, this is stepwise refinement.  What we are doing is to design a mini-program just like we would design a complete program.  The mini-program we will write in this section draws a row of bricks on the screen, and initializes some tables for later use by other parts of the program.\par The program starts with six rows of bricks on the screen.  We will use a total of 16 bricks in each row.  There are four things we will need to know about these bricks: their color, where they are, how many points they are worth, and whether they have been knocked out yet.\par Let's start by deciding where the bricks will be.  The first step is to decide how big each brick will be.  The screen is 640 pixels wide, so if we want 16 bricks per row, each one will be 40 pixels wide.  The six rows of bricks should appear near the top of the screen, say in the top 60 or so pixels.  We want some blank space at the top to give the ball some room to rebound, too.  We'll allow 8 pixels before the top of the first brick.  If we leave two blank lines between each row of bricks, and make each brick six pixels high, we end up using 48 rows of pixels.  Along with the 8 blank pixels, this gives us 56 pixels at the top of the screen, which is about right.\par Stop now and write the subroutine to draw the original set of six rows of bricks on the screen.  For consistency with the solution, call the subroutine DrawBricks; it should be called from InitScreen.  I used a global variable called brickY to decide how high the bricks are.  That way, as the game progresses and the bricks get lower, I only had to change one global value before calling DrawBricks.  Of course, you need to choose some colors for the bricks.  In my program, I made all of the bricks in a single row the same color, and used a black line along the right edge of each brick to separate the bricks.\par Assigning the values to the bricks is somewhat a matter of personal taste, of course.  All of the bricks in a particular row should have the same value.  The bricks in the bottom row should be worth the least, and the bricks in the top row should be worth the most.  If the player is skillful enough to move on to the next level of play by knocking out all of the bricks, the rows move down.  Since it is harder to knock out the bricks at the lower level, they should be worth more, too.  There are several ways to handle all of these factors.  You could create an array that holds the point values for each row, with different point values for each level, like this:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {#define ROWS 6\par #define LEVELS 16\par \par }\pard \s23\qj\fi360\widctlpar\adjustright {int points[ROWS][[LEVELS];\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par I picked 16 as the maximum number of levels here; we may need to vary that later.  This scheme gives you a lot of flexibility when assigning point values to the bricks, but it is pretty complicated, and it will take a lot of code to fill in the array.  I finally decided on a simpler mechanism.  On level 1, the bottom row of bricks is worth 10 points, and each higher row is worth 5 more points.  On level 2, the bottom row is worth 15 points, while each higher row is still worth 5 additional points.  This mechanism is so simple that I can use a formula to find the value of a brick, assuming I know the row and playing level.  The formula I came up with is\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {points = (row+level)*5;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {This is so simple that I don't need to initialize anything in DrawBricks; I just jot the formula down for later use.\par }\pard \s21\qj\fi360\widctlpar\adjustright {The last step is to initialize an array that keeps track of whether a brick has been knocked out or not.  This array will be used when we are tracking the ball.  When the ball is in the area where the bricks are located, we will calculate the row and column number of the brick it is starting to hit.  The row and column number can then be used to index into the brick array.  If the brick exists, we know that we have to remove it, and rebound the ball.  DrawBricks is responsible for drawing the initial rows of bricks on the screen, so it seems like a good place to initialize the array to true.  The array looks like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#define ROWS 6\par #define COLUMNS 16\par \par int stillThere[ROWS][COLUMNS];\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {Put the code into DrawBricks to initialize all of the elements of this array to true, then test your program to make sure everything works.\par }\pard \s21\qj\fi360\widctlpar\adjustright {A lot of the decisions in this lesson probably seemed arbitrary, and you are wondering how I made them.  How do I know, for example, that we want 6 rows of bricks, with 16 bricks in each row?  How do I know that the bricks should be 6 pixels thick, with two blank rows of pixels separating the bricks?  How do I know the point values I assigned to the bricks will give a playable game?\par The answer is, I don't.  I made some reasonable guesses.  If you ask a dozen experienced programmers to make the same choices, you would come up with several different values for each variable.  At this point, though, we can see the bricks on the screen.  We can study them, taking a moment to decide if the bricks are the right size, the right proportion, and the right color.  If not, now is the time to make some changes.  And since you used constants to isolate things like the number of rows and the size of bricks, it is easy to go back and make the changes.\par What?  You didn't use constants?  Well, you should.  That was one of those silly little rules of thumb I pointed out a long time ago.  Now, developing a large program where you need to make fine adjustments to your program, you can start to see some of the value in that silly rule.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344641}Drawing the Score and Balls{\*\bkmkend _Toc496344641}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The next step is to draw the score and number of balls on the screen.  This is pretty easy: just use MoveTo to set the pen position, SetForeColor and SetBackColor to choose appropriate colors for the letters, and write the scores.  I used the following strings and positions, putting green letters near the bottom of the screen.\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {SetBackColor(0);\par SetForeColor(2);\par MoveTo(0,190);\par printf("Score:");\par MoveTo(560,190);\par printf("Balls:");\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The score and number of balls must be updated throughout the game, so I put the code to write these numbers in two subroutines, called WriteScore and WriteBalls.  By writing a few extra blanks after the numeric score, I made sure that any old text was erased.\par You will also need to move the paddle up a bit.  Since we used constants to set the paddle position, this is an easy thing to do.  I raised the paddle to 16 pixels above the bottom of the screen.\par Go ahead and get the program working up to this point.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344642}Bouncing the Ball{\*\bkmkend _Toc496344642}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {We have a complete playing field now.  The next step is to actually start the ball moving.  You have written code to bounce a ball before; now is the time to add the same bouncing ball to our program.\par The ball should start just below the bottom row of bricks, and head down and to the side.  If you move it down two pixels and over four pixels with each movement, it will have a good angle, without being too steep.  The horizontal position that it starts at, and the direction of the initial angle, should be chosen at random.\par In the past, our simulations have used a fixed random number seed, or asked for a seed from the user.  Neither option seems right for the break out game.  If we use a fixed seed, the first ball will always come from the same place and the same direction.  If we ask for a seed, the player can cheat.  We have a pretty good choice for a seed in this program, though.  The when field of the event record is the number of heartbeats since we started the event manager.  This number will rarely be the same when we start the game, since the player has to click the mouse to start.  (Well, not yet, but he will before we are finished.)  In fact, for our purpose, the when field itself is suitably random!  Here is how I chose the position and direction of the ball:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {if (event.when & 0x0001)\par    dx = -4;\par else\par    dx = 4;\par x = event.when % 640;\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par In effect, I have used a tiny part of the when field to decide if the ball should head to the left or right when it starts.  The last line uses the when field again to set the initial horizontal position of the ball.\par If you try your program now, the ball will be moving pretty slow.  You need to turn debug code off to test the program's playability.  The ball will still move too slow; that's something we'll take care of later.  It turns out that QuickDraw isn't quick enough; in the 640 drawing mode, the paddle and ball can't be drawn quickly enough for a playable game.  Later, we will correct this problem by switching to 320 graphics mode.  There is a more serious problem, though.  The ball moves noticeably slower when you move the paddle.  This is because there is more work to do when the paddle is moved.  The way to handle this problem is to put the game on a regular timer.  We can do that by checking the when field, and only moving the ball after the field changes by some fixed amount.  This also solves one other problem that plagues many arcade games.  You may have seen some games that run too fast when they are played on a computer with an accelerator card.  By fixing the speed of the game to the when field, which is updated 60 times per second no matter how fast the computer is, the game will always run at the same speed.\par To use the when field as a timer, we start be recording the value of the when field in a global variable just as the ball starts to move.  We can then check the timer, making sure that a certain amount of time has elapsed since the last time the ball was moved.  The best place to do this is in our main event loop, which now looks like this:\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {   do \{\par       GetNextEvent(EVENTMASK,\par          &myevent);\par       timer = \par          myevent.when-lastWhen;\par       if (timer > PAUSE) \{\par          MoveBall();\par          lastWhen += PAUSE;\par          \}\par       MovePaddle();\par       \}\par    while (balls);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Looking at this loop, what we are doing is to wait until at least PAUSE heartbeats have occurred before we call MoveBall.  We then update the value of lastWhen, but note that we add PAUSE, rather than recording myevent.when.  This will keep the ball movement smooth, even if some spot in our program takes up a bit too much time.  Of course, you must pick a value for PAUSE, which should be declared as a constant.  Start with any value you like, and try hitting the ball with the paddle.  Adjust PAUSE until you like the way the game works.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344643}The Bricks{\*\bkmkend _Toc496344643}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {We have gradually built up to the point where we can almost play a game.  The last step is to keep track of when we hit the bricks, removing them when this happens.\par In order to lower the bricks each time the screen is cleared, you have to record the position of some row of bricks in a global variable; in this program, I recorded the bottom of the lowest row of bricks.  After the screen is cleared, you can add 8 to this value, and redraw the bricks.  This value is also the key to determining if we have hit a brick.\par The first step is to decide if we are even near the bricks, and if so, which row of bricks we are near.  To figure out how to do this, I will assume that you have defined the variables and constants shown in listing 17.3.  If they have different names in your program, you will have to adjust the names used here.  If these variables and constants don't exist in your program \endash  if you are using hard-coded values, for example \endash  now is a good time to repent.  Go back and make the values constants.\par The only value that may seem a little curious is spacing.  We will need to calculate the pixel position for the various rows.  To do that, we need to know the distance from the bottom of one row to the bottom of the next row.  SPACING is that value.  It is the sum of the thickness of the brick, and the number of rows of black pixels that separate each row of bricks.\par Using these values, we can quickly decide if we have hit a brick by calculating the row and column number for the ball.\par \par }\pard\plain \s23\qj\keepn\widctlpar\adjustright \f6\fs20\cgrid {if (y > brickY)\par    return;\par row = (brickY-y) / SPACING;\par dispY = (brickY-y) % SPACING;\par if ((row < ROWS)\par    && (dispY <= THICKNESS) \{\par    column = x / WIDTH;\par    dispX = x % WIDTH ;\par    if (stillThere[row][column]) \{\par       /* <<<remove the brick>>> */\par       /* <<<add in the score>>> */\par       if (dispY == THICKNESS)\par          /* <<<hit from above>>> */\par       else if (dispY == 0)\par          /* <<<hit from below>>> */\par       else if (dispX < (WIDTH / 2))\par          /* <<<hit from left>>> */\par       else\par }{\lang1024 {\shp{\*\shpinst\shpleft0\shptop52\shpright9360\shpbottom3076\shpfhdr0\shpbxcolumn\shpbypara\shpwr1\shpwrk0\shpfblwtxt0\shpz31\shplid1164{\sp{\sn shapeType}{\sv 202}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn lTxid}{\sv 3538944}}{\sp{\sn dyWrapDistTop}{\sv 118745}}{\sp{\sn dyWrapDistBottom}{\sv 118745}}{\shptxt \pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 17.3\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#define ROWS 6         /* # of rows of bricks */\par #define COLUMNS 16     /* # of columns of bricks */\par #define THICKNESS 6    /* thickness of a brick */\par #define WIDTH 40       /* width of a brick */\par #define SPACING 8      /* # of pixels between rows */\par \par int x,y;               /* ball position */\par int dx,dy;             /* ball velocity */\par int brickY;            /* position of the bottom of the lowest brick */\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}}{\shprslt{\*\do\dobxcolumn\dobypara\dodhgt8223\dptxbx\dptxlrtb{\dptxbxtext\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\b Listing 17.3\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#define ROWS 6         /* # of rows of bricks */\par #define COLUMNS 16     /* # of columns of bricks */\par #define THICKNESS 6    /* thickness of a brick */\par #define WIDTH 40       /* width of a brick */\par #define SPACING 8      /* # of pixels between rows */\par \par int x,y;               /* ball position */\par int dx,dy;             /* ball velocity */\par int brickY;            /* position of the bottom of the lowest brick */\par }\pard\plain \nowidctlpar\adjustright \f4\cgrid {\par }}\dpx0\dpy52\dpxsize9360\dpysize3024\dpfillfgcr255\dpfillfgcg255\dpfillfgcb255\dpfillbgcr255\dpfillbgcg255\dpfillbgcb255\dpfillpat1\dplinew15\dplinecor0\dplinecog0\dplinecob0}}}}{         /* <<<hit from right>>> */\par       \}\par }\pard \s23\qj\widctlpar\adjustright {   \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par There is a lot packed into these few lines, so let's take a moment to look them over carefully.  The first if check makes sure that the ball has at least reached the first row of bricks; this gets us out of the subroutine quickly if the ball is below the bricks and simplifies the rest of the calculations, all at the same time.  The next line calculates the row that the ball is in, returning a value greater than the constant ROWS if the ball is above all of the rows.  To see how it works, let's plug in a few sample numbers.  When the game starts, brickY is set to 56.  As the ball approaches the bricks from below, the value of y decreases steadily.  The first if check returns right away until y drops below the value of brickY, so the first value we have to worry about is when y is 56.  The value of brickY-y is 0, so the value of row gets set to 0.  We have reached the first row of bricks, which we have labeled row 0.  Try values of y for 46, 48, and 50 to convince yourself that the formula returns the right value as the ball passes from the first row of bricks to the second.\par The next line calculates dispY, which is the distance, in pixels, from the bottom of the row.  It is 0 if the ball is on the bottom of the row, THICKNESS if the ball is at the top of the brick, and greater than THICKNESS if the ball is in the gap right above the brick, but before the start of the next row.  We use this value twice, once to decide if we are in the gap between rows (in which case we didn't really hit a brick, after all), and again to see if we hit the top or bottom of a brick. \par Figuring out the column number uses the same ideas, but is simpler because the leftmost column of bricks starts when x=0.\par After checking to make sure the brick is still there, we drop into a series of if checks that decide which side of the brick we hit.  Since the ball moves up and down two pixels at a time, and all of our program carefully aligns things to even pixel boundaries, it is easy to check for a hit from above or below: dispY is equal to 0 at the bottom of the brick, and THICKNESS at the top.  If we hit a corner, the program counts it as a hit from above or below.  Checking for a hit from the left or right is tougher, though.  The ball moves sideways at a variable rate, depending on the spin on the ball from the last time it hit the paddle.   To check for a hit from the side, then, we need to allow for the possibility that the ball skipped right over the edge of the brick, imbedding itself in the side of the brick.  Since we already know the ball has, in fact, hit the brick, we can make this check by looking to see if the ball is in the left or right half of the brick.\par When I started filling in the stubs for this subroutine, I realized that you do exactly the same thing if the ball hits the top or the bottom of the brick.  In both cases, the vertical velocity is reversed.  The same was true if the hit was from the left or right: the horizontal velocity gets reversed in both cases.  Keeping an eye out for this sort of simplification is an important part of programming.  It simplifies this particular algorithm a great deal.  Once I was finished, the test looked like this:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {if (y > brickY)\par    return;\par row = (brickY-y) / SPACING;\par dispY = (brickY-y) % SPACING;\par if ((row < ROWS)\par    && (dispY <= THICKNESS) \{\par    column = x / WIDTH;\par    dispX = x % WIDTH ;\par    if (stillThere[row][column]) \{\par       /* <<<remove the brick>>> */\par       /* <<<add in the score>>> */\par       if ((dispY == THICKNESS)\par          || (dispY == 0))\par          dy = -dy;\par       else\par          dx = -dx;\par       \}\par }\pard \s23\qj\fi360\widctlpar\adjustright {   \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par It's pretty straight-forward to fill in the stubs left in this routine, so I will let you do that.  I did encapsulate the functions of removing a brick and adding in the new score into a subroutine, since they did involve a bit of code.  You can remove the brick by drawing a black rectangle over the brick, and setting the proper spot in stillThere to false.  Adding the proper value to the score is accomplished using the formula developed a few pages back.  Don't forget to write the new score to the screen!\par Once you have written all of the code, test your program.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344644}Labarski's Rule of Cybernetic Entomology{\*\bkmkend _Toc496344644}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Yup.  The rule is, "There's always one more bug."  (For more enlightenment when the chips get you down, refer to "Murphy's Law, and Other Reasons Why Things Go Wrong.")\par There is at least one bug in your program at the moment.  Maybe you caught it.  If so, great.  The point, though, is that in a large program you are going to overlook things.  That's why you develop the program in small steps, making adjustments as you go.\par You have probably already decided that a 1 pixel by 1 pixel ball is too small, and adjusted it.  If you play the game for a while, though, you will eventually end up with the ball skimming along beside a brick, not quite touching it.  When the animation routine erases the ball by redrawing it in black, part of the brick gets erased, too.\par There are really two problems here.  The first can be fixed by changing the way you animate the ball.  Back in the sample program where we did a random walk with a variety of shapes, like stars, triangles and squares, you saw a new drawing mode called XOR mode.  In this drawing mode, drawing an object twice erases it, since it is drawn by inverting pixels, not copying them to the screen.  For example, you could lay out a series of 10 by 10 pennies, face up.  XOR drawing mode is like flipping a penny over, showing tails.  To erase the pixel, you flip it back - the same operation you used to draw it in the first place.  By changing the ball so it is drawn in XOR mode, you will no longer erase parts of a brick that you skim over.\par The second problem is that the player will expect the brick to go away if the ball comes in contact with it.  Our routine to check to see if a brick has been hit checks to see if the center of the ball hit the brick.  That's fine for a direct hit, but doesn't account for the grazing hits that we are seeing in the game.  You can handle this situation in one of several ways.  The one I like is to modify the ball movement algorithm so that, if the ball hits the space left by a brick that has already been removed, you check to the left or right, like this:\par \par }\pard\plain \s23\qj\keepn\widctlpar\adjustright \f6\fs20\cgrid {\fs18 if (y > brickY)\par    return;\par row = (brickY-y) / SPACING;\par }\pard \s23\qj\widctlpar\adjustright {\fs18 dispY = (brickY-y) % SPACING;\par if ((row < ROWS)\par    && (dispY <= THICKNESS) \{\par    column = x / WIDTH;\par    dispX = x % WIDTH ;\par    if (stillThere[row][column]) \{\par       HitBrick(row,column);\par       if ((dispY == THICKNESS)\par          || (dispY == 0))\par          dy = -dy;\par       else\par          dx = -dx;\par       \}\par    else if ((dispY == 0)\par       || (dispY == THICKNESS))\par       if (dispX == 0) \{\par          if (stillThere[row][column-1])\par             \{\par             HitBrick(row,column-1);\par             dy = -dy;\par             \}\par          \}\par       else if (dispX == WIDTH)\par          if (stillThere[row][column+1])\par             \{\par             HitBrick(row,column+1);\par             dy = -dy;\par             \}\par    \}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par Making the check this way presents a common problem, though.  We can end up checking column number -1 or column number COLUMNS, neither of which actually exists in the array we have defined.  Rather than adding even more complicated if checks to the program, most programmers will simply extend the array by one column in each direction, so that it goes from 0 to COLUMNS+1, rather than 0 to COLUMNS-1.  The leftmost and rightmost columns represent two fake columns which are not actually on the screen; these are initialized to false, so that the algorithm never reports that a brick has been hit.  This is the way the solution handles the situation.  Of course, if you use this method, you need to adjust all of the places that you have used the array stillThere, since the column numbers have changed; the leftmost column on the screen used to be represented by stillThere[row][0], and is now stillThere[row][1], and so on.\par You might ask why I didn't point out these factors when the original code was written.  The reason was to make a point.  In any large program, you will forget some detail.  If your program is logically laid out, if constants have been defined, and if the program is commented well, it is usually very easy to go back and handle the special case.  If you are not following the basic rules of structured programming, though, going back and making the change can be frightful.\par In fact, programmers often leave out details like this on purpose.  In a complex algorithm, you might want to check to be sure that the basic ideas work before spending a lot of time on little details.  This is the algorithmic equivalent of a stub.  You know what the detail is, but you ignore it for a while so you can concentrate on the overall structure of the algorithm.  Once the basics work, you go back and fill in the details.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344645}Filling in the Last Stubs{\*\bkmkend _Toc496344645}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The program is almost finished.  All that is left is to write the messages that control the start of the game, and missing a ball.\par Let's do the last one first, since it is the easiest.  When the player misses the ball, it would be heartless to toss the next one down right away, as you no doubt know by now!  Instead, you need to stop and print a message, then wait for a mouse click.  Start by writing a message in the middle of the screen, like this:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {MoveTo(300,100);\par printf(\par }\pard \s23\qj\fi360\widctlpar\adjustright {   "Click for the next ball");\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {The next step is to wait for the mouse to be clicked and let back up.  This is a pretty easy check.\par }\pard \s21\qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {do\par    GetNextEvent(EVENTMASK,\par       &myevent);\par while (myevent.what \par }\pard \s23\qj\fi360\widctlpar\adjustright {   != mouseUpEvt);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {This loop keeps going until the player pushes the mouse button, then releases it.\par }\pard \s21\qj\fi360\widctlpar\adjustright {When the game starts, or when a game is finished, you need to print two choices on the screen.  For one choice, use the message, "Play a Game".  For the other choice, use "Quit".  Use MoveTo and LineTo to draw boxes around these choices.  I think it looks best if both boxes are the same size.  With the messages drawn, you can use a loop very much like the last one to wait for a mouse click.  This time, though, you want to make sure the click occurred in one of the buttons you have drawn.  Write a function that returns 0 if the click was not in a button or if the mouse was not released, 1 if the click was in the "play a game" button, and 2 if the click was in the "quit" button.  Your loop now looks like this:\par \par }\pard\plain \s23\qj\fi360\keepn\widctlpar\adjustright \f6\fs20\cgrid {do \{\par    GetNextEvent(EVENTMASK,\par       &myevent);\par    MovePaddle();\par    \}\par }\pard \s23\qj\fi360\widctlpar\adjustright {while (WhichButton() == 0);\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par The only other thing that can happen \endash  rare though it may be \endash  is that the player might knock out all of the bricks.  You can check for that when you erase a brick.  To make the check quickly, you should use a global variable that is set to the number of bricks when they are first drawn.  After that, if a brick gets hit, you can simply subtract 1 from the value and check to see if the value is zero.  If so, you need to update the playing level, redraw all of the bricks, add one ball to the balls that the player has, and wait for the player to click on the mouse before continuing.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344646}Tidy Up{\*\bkmkend _Toc496344646}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {The program is finished now, but some clean up is still left over.  Scan through the program, making sure all of the stubs are filled in.  Remove the throw-away code we put in to expand the graphics window, and change the program to an S16 application.  Try it out to make sure everything still works as expected.\par Unless you have an accelerator card, the program is still a little too slow.  To correct this problem, convert the program from the 640 graphics mode to the 320 graphics mode.  If you have faithfully used constants throughout your program, it will be fairly easy to scan through the program to make the appropriate changes.  With these changes made, the program should be a very playable breakout game.  If you like, you can also add the line\par \par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {#pragma optimize 9\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {\par }\pard \s21\qj\widctlpar\adjustright {before the first function in your program to kick in the most useful of ORCA/C's compiler optimizations, speeding up the program a little more.\par }\pard \s21\qj\fi360\widctlpar\adjustright {At this point, many programmers have the tendency to sit back, claiming the program is finished.  Nonsense.  It's about half to two-thirds there.  The next step is to play the game for a while, adjusting the various features.  I made a number of changes to the colors used in the program at this point.  Once you are satisfied, ask a friend to play the game, and really listen to what he says.  Don't be offended if he doesn't like something.  Instead, write it down and keep it in mind.  If you disagree, ask a few other people.  If it turns out that everyone in the world but you makes the wrong choice, you might want to change the program, anyway.  Sure, you're right \endash  but a lot more people will be happy if you make the change.  Finally, make a last pass through the source code for the program itself, tidying things up and looking for internal improvements.  This is an especially important step if you are not satisfied with the speed of the program.\par }\pard\plain \s2\sb200\sa200\keepn\nowidctlpar\outlinelevel1\adjustright \b\f4\fs28\cgrid {{\*\bkmkstart _Toc496344647}Ruffles and Flourishes{\*\bkmkend _Toc496344647}\par }\pard\plain \s21\qj\fi360\widctlpar\adjustright \f4\fs20\cgrid {Well, a few weeks ago, you couldn't spell recursive tree traversal, and now you know what it is.  Not bad.  Let me be the first to congratulate you on joining the ranks of real programmers, who do it with bytes and nibbles.\par Of course, as I have pointed out so many times that you may be sick of hearing it, programming is a skill.  Like all skills, the more you practice, the easier it gets.  There are also a lot more things to learn about programming.  Where you go from here depends on your own interests.\par ORCA/C conforms to the ANSI standard.  With the exception of a few features that deal specifically with the Apple IIGS, all of the things you have learned in this course will work on any ANSI standard C, and on most other Cs, too.  The reverse is also important: any book that uses ANSI C will work with ORCA/C.  If you would like to learn more about programming, there are many fine books that meet this requirement.  The best way to find books that fit your needs and interests is to visit a well-stocked bookstore and browse for a few hours.\par If you would like to learn to program the toolbox, writing desktop programs with pull down menus and so forth, you need to study books that are specific to the Apple IIGS.  First and foremost are the three volumes of the }{\ul Apple IIGS Toolbox Reference Manual}{, written by Apple's staff of programmers and published by Addison-Wesley.  There are no good introductory books for learning to program the toolbox that use C.  To learn the toolbox, I would suggest reading the front sections of the chapters in the reference manuals, reading magazine articles, and asking a lot of questions on one of the major on-line services, like America Online or GEnie.\par Whatever you decide to do from here, I hope you enjoyed the course, and learned a few things along the way.  Once again, congratulations on completing the course!\par }\pard\plain \qc\widctlpar\adjustright \f4\cgrid {\b\fs36 \par \sect }\sectd \sbkodd\linex-32767\headery1080\footery1080\endnhere\sectdefaultcl \pard\plain \qc\widctlpar\adjustright \f4\cgrid {\b\fs36 Lesson Seventeen\par The Complete Game\par }\pard \qj\fi360\widctlpar\adjustright {\par }\pard\plain \s23\qj\fi360\widctlpar\adjustright \f6\fs20\cgrid {/* This program plays the game of break-out, a classic arcade    */\par /* game.                                                         */\par \par #pragma optimize 9\par \par #include <quickdraw.h>\par #include <event.h>\par #include <memory.h>\par #include <window.h>\par \par #include <orca.h>\par \par #include <stdio.h>\par \par #define EVENTMASK 0x0F6E                /* GetNextEvent event mask */\par #define SIZE 320                        /* graphics mode */\par #define LETTERY 2            /* height of letters for score, ball count */\par #define PAUSE 1                         /* 60ths of a sec. to pause */\par \par EventRecord myevent;                    /* current event record */\par Rect screen;                            /* port rectangle */\par int score;                              /* current score */\par long lastWhen;                          /* event timer */\par \par                                         /* the paddle */\par                                         /*------------*/\par #define PADDLECOLOR 15                  /* paddle color */\par #define PADDLEHEIGHT 3                  /* paddle height */\par #define PADDLEWIDTH 35                  /* paddle width */\par #define PADDLEY 184                     /* y position of the paddle */\par #define EASY 2                          /* x velocity for easy spin */\par #define HARD 3                          /* x velocity for hard spin */\par \par #define AREA1 7                        /* sensitive areas of the paddle */\par #define AREA2 14\par #define AREA3 21\par #define AREA4 28\par \par int maxX;                       /* max X distance the paddle can travel */\par int paddlePosition;                 /* current X position of the paddle */\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {                                        /* the bricks */\par                                         /*------------*/\par #define COLUMNS 16                      /* # of bricks in a row */\par #define ROWS 6                          /* # of rows of bricks */\par #define SPACING 8                       /* spacing of the rows */\par }\pard \s23\qj\fi360\widctlpar\adjustright {#define STARTHEIGHT 56         /* starting distance to bottom of bricks */\par #define THICKNESS 6                     /* thickness of a brick */\par #define WIDTH 20                        /* width of a brick */\par \par int brickY;                         /* disp to the bottom row of bricks */\par int level;                              /* playing level */\par int numBricks;                          /* # of bricks visible */\par int stillThere[ROWS][COLUMNS+2];        /* brick array */\par \par                                         /* the ball */\par                                         /*----------*/\par #define BALLCOLOR 15                    /* ball color */\par #define BALLHEIGHT 3                    /* ball height; should be odd */\par #define BALLWIDTH 3                     /* ball width; should be odd */\par #define BALLDX (BALLWIDTH/2)            /* half width of ball */\par #define BALLDY (BALLHEIGHT/2)           /* half height of ball */\par #define SPEED 2                         /* vertical ball speed */\par \par int balls;                              /* # of balls left */\par int dx,dy;                              /* speed of the ball */\par int x,y;                                /* position of the ball */\par \par                                         /* button sizes */\par                                         /*--------------*/\par #define LEFT 110\par #define RIGHT 210\par #define TOP1 90\par #define BOTTOM1 101\par #define TOP2 105\par #define BOTTOM2 116\par \par /*--------------------------------------------------------------*/\par \par void StartTools (void)\par \par /* Start the tools                                              */\par \par \{\par handle memory;                          /* memory returned by NewHandle */\par \par startgraph(SIZE);                       /* initialize QuickDraw */\par memory = NewHandle(256L,userid(),0xC015,0L); /* start up the event mgr */\par EMStartUp((int) *memory, 0, 0, SIZE, 0, 200, userid());\par FlushEvents(0xFFFF, 0);\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void ShutDownTools (void)\par \par /* Shut down the tools                                          */\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par \{\par EMShutDown();\par endgraph();\par \}\par \par \par void DrawPaddle (int position, int color)\par \par /* Draw the paddle                                              */\par /*                                                              */\par /* Parameters:                                                  */\par /*    position - position to draw the paddle                    */\par /*    color - color of the paddle                               */\par \par \{\par int y;                          /* position of the paddle on the screen */\par \par                                /* set the pen to draw the entire paddle */\par SetPenSize(PADDLEWIDTH,PADDLEHEIGHT);\par SetSolidPenPat(color);                  /* set the paddle color */\par SetPenMode(0);                          /* use copy mode */\par MoveTo(position,PADDLEY);               /* draw the paddle */\par LineTo(position,PADDLEY);\par \}\par \par \par void MovePaddle (void)\par \par /* Track and move the paddle                                    */\par /*                                                              */\par /* Variables:                                                   */\par /*    paddlePosition - position of the paddle                   */\par /*    myevent - last event returned by GetNextEvent             */\par \par \{\par /* convert the point to our window */\par GlobalToLocal(&myevent.where);\par \par /* make sure we don't go off of the screen */\par if (myevent.where.h+PADDLEWIDTH > maxX)\par    myevent.where.h = maxX-PADDLEWIDTH;\par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {/* if the mouse moved, move the paddle */\par if (myevent.where.h != paddlePosition) \{\par }\pard \s23\qj\fi360\widctlpar\adjustright {   DrawPaddle(paddlePosition,0);\par    paddlePosition = myevent.where.h;\par    DrawPaddle(paddlePosition, PADDLECOLOR);\par    \}\par \}\par \par \par void DrawBrick (int row, int column, int color)\par \par /* Draw a brick on the screen                                   */\par /*                                                              */\par /* Parameters:                                                  */\par /*    row,column - brick to draw                                */\par /*    color - color of the brick                                */\par /*                                                              */\par /* Variables:                                                   */\par /*     brickY - distance to the bottom of the bricks            */\par \par \{\par Rect r;                                 /* brick's rectangle */\par \par SetPenMode(0);                          /* get ready to draw */\par SetSolidPenPat(color);\par SetPenSize(1,1);\par r.h1 = column*WIDTH;                    /* set up the brick's rectangle */\par r.h2 = r.h1+WIDTH;\par r.v2 = brickY - row*SPACING;\par r.v1 = r.v2-THICKNESS;\par PaintRect(&r);                          /* draw the brick */\par SetSolidPenPat(0);                /* draw a line to separate the bricks */\par MoveTo(r.h2-1, r.v1);\par LineTo(r.h2-1, r.v2);\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void DrawBricks (void)\par \par /* Draw a set of bricks                                         */\par \par \{\par int colors[ROWS];                       /* brick colors */\par int column;                             /* loop variable */\par int row;                                /* loop variable */\par Rect r;                                 /* brick rectangle */\par \par numBricks = ROWS*COLUMNS;               /* set the brick count */\par colors[0] = 7;                         /* fill in the brick color array */\par colors[1] = 6;\par }\pard \s23\qj\fi360\widctlpar\adjustright {colors[2] = 9;\par colors[3] = 10;\par colors[4] = 13;\par colors[5] = 12;\par for (row = 0; row < ROWS; ++row) \{      /* draw the bricks */\par    for (column = 0; column < COLUMNS; ++column) \{\par       DrawBrick(row, column, colors[row]);\par       stillThere[row][column+1] = 1;\par       \}\par    stillThere[row][0] = 0;\par    stillThere[row][COLUMNS+1] = 0;\par    \}\par \}\par \par \par void WriteBalls (void)\par \par /* Draw the number of balls left                                */\par /*                                                              */\par /* Variables:                                                   */\par /*    balls - number of balls left                              */\par \par #define BALLX 290\par \{\par MoveTo(BALLX, LETTERY);\par printf("%d          ", balls);\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void WriteScore (void)\par \par /* Draw the current score                                       */\par /*                                                              */\par /* Variables:                                                   */\par /*    score - score to draw                                     */\par \par #define SCOREX 50\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par \{\par MoveTo(SCOREX, LETTERY);\par printf("%d          ", score);\par \}\par \par \par void DrawBall (void)\par \par /* Draw a ball at the current position                          */\par /*                                                              */\par /* Variables:                                                   */\par /*    x,y: ball position                                        */\par /*                                                              */\par /* Note: This procedure is used to draw an initial ball or      */\par /*       to erase one after a ball is missed.  MoveBall uses    */\par /*       its own method, which is faster when the ball is       */\par /*       being animated.                                        */\par \par \{\par SetSolidPenPat(BALLCOLOR);\par SetPenMode(2);\par SetPenSize(BALLWIDTH, BALLHEIGHT);\par MoveTo(x-BALLDX, y-BALLDY);\par LineTo(x-BALLDX, y-BALLDY);\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void StartBall (void)\par \par /* Start a ball                                                 */\par /*                                                              */\par /* Variables:                                                   */\par /*    x,y - position of the ball                                */\par /*    dx,dy - speed of the ball                                 */\par \par \{\par if (myevent.when & 0x0001)              /* set the speed, position */\par    dx = -EASY;\par else\par    dx = EASY;\par x = myevent.when % screen.h2;\par }\pard \s23\qj\fi360\widctlpar\adjustright {dy = SPEED;\par y = brickY + 4;\par \par DrawBall();                             /* draw the ball */\par \par GetNextEvent(EVENTMASK, &myevent);      /* set the timer */\par lastWhen = myevent.when;\par \}\par \par \par void WaitForClick (void)\par \par /* Pause until the player is ready for a ball                   */\par \par \{\par static Rect r = \{90, 0, 100, 320\};      /* used to erase the message */\par \par MoveTo(65,100);                         /* write the message */\par printf("Click for the next ball");\par do \{                                    /* wait for the click */\par    GetNextEvent(EVENTMASK, &myevent);\par    MovePaddle();\par    \}\par while (myevent.what != mouseUpEvt);\par SetSolidPenPat(0);\par SetPenMode(0);\par PaintRect(&r);\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void HitBrick (int row, int column)\par \par /* Handle a hit brick                                           */\par /*                                                              */\par /* Parameters:                                                  */\par /*    row,column - brick that was hit                           */\par }\pard \s23\qj\fi360\widctlpar\adjustright {\par \{\par Rect ball;                              /* ball rectangle */\par \par stillThere[row][column+1] = 0;          /* remove the brick */\par ball.h1 = x-BALLDX;                     /* erase the ball */\par ball.h2 = ball.h1+BALLWIDTH;\par ball.v1 = y-BALLDY;\par ball.v2 = ball.v1+BALLHEIGHT;\par SetPenMode(2);\par SetSolidPenPat(BALLCOLOR);\par PaintRect(&ball);\par DrawBrick(row, column, 0);              /* erase the brick */\par SetPenMode(2);                          /* redraw the ball */\par SetSolidPenPat(BALLCOLOR);\par PaintRect(&ball);\par score += (row+1+level)*5;               /* add in the score */\par WriteScore();\par --numBricks;                            /* see if they are all gone */\par if (numBricks == 0) \{\par    DrawBall();\par    ++balls;\par    WriteBalls();\par    brickY += SPACING;\par    ++level;\par    DrawBricks();\par    WaitForClick();\par    StartBall();\par    \}\par GetNextEvent(EVENTMASK, &myevent);      /* reset the timer */\par lastWhen = myevent.when;\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void CheckBricks (void)\par \par /* Move the ball.                                               */\par /*                                                              */\par /* Variables:                                                   */\par /*    x,y - position of the ball                                */\par /*    numBricks - # of bricks left                              */\par \par \{\par int row,column;                         /* brick row,column */\par }\pard \s23\qj\fi360\widctlpar\adjustright {int dispX,dispY;                        /* position along the brick */\par \par if (y > brickY)                  /* quit now if we are below the bricks */\par    return;\par row = (brickY-y) / SPACING;           /* find the vertical brick values */\par dispY = (brickY-y) % SPACING;\par if ((row < ROWS) && (dispY <= THICKNESS)) \{\par    column = x / WIDTH;              /* find the horizontal brick values */\par    dispX = x % WIDTH;\par                                         /* check for a hit */\par    if (stillThere[row][column+1]) \{\par       HitBrick(row,column);\par       if ((dispY == 0) || (dispY == THICKNESS))\par          dy = -dy;\par       else\par          dx = -dx;\par       \}\par    else if ((dispY == 0) || (dispY == THICKNESS))\par       if (dispX == 0) \{\par          if (stillThere[row][column]) \{\par             HitBrick(row,column-1);\par             dy = -dy;\par             \}\par          \}\par       else if (dispX == WIDTH)\par          if (stillThere[row][column+2]) \{\par             HitBrick(row,column+1);\par             dy = -dy;\par             \}\par    \}\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void GetANewBall (Rect *oldBall)\par \par /* Missed; get a new ball                                       */\par /*                                                              */\par /* Parameters:                                                  */\par /*    oldBall - ptr to MoveBall's old ball position             */\par \par }\pard \s23\qj\fi360\widctlpar\adjustright {\{\par --balls;                                /* reduce the number of balls */\par WriteBalls();\par if (balls) \{\par    PaintRect(oldBall);                  /* erase the old ball */\par    WaitForClick();                    /* wait until the player is ready */\par    StartBall();                         /* start a new ball */\par    oldBall->h1 = x-BALLDX;              /* form its rectangle */\par    oldBall->h2 = oldBall->h1+BALLWIDTH;\par    oldBall->v1 = y-BALLDY;\par    oldBall->v2 = oldBall->v1+BALLHEIGHT;\par    \}\par \}\par \par \par void MoveBall (void)\par \par /* Move the ball                                                */\par /*                                                              */\par /* Variables:                                                   */\par /*    x,y - position of the ball                                */\par /*    dx,dy - speed of the ball                                 */\par \par \{\par Rect oldBall, newBall;                  /* ball rectangles */\par int px;                               /* disp of ball on paddle surface */\par \par SetPenMode(2);                          /* get ready to draw */\par SetSolidPenPat(BALLCOLOR);\par oldBall.h1 = x-BALLDX;                  /* form the old ball rectangle */\par oldBall.h2 = oldBall.h1+BALLWIDTH;\par oldBall.v1 = y-BALLDY;\par oldBall.v2 = oldBall.v1+BALLHEIGHT;\par x += dx;                                /* move the ball */\par if (x < 0) \{\par    x = 0;\par    dx = -dx;\par    \}\par else if (x > screen.h2) \{\par    x = screen.h2;\par    dx = -dx;\par    \}\par y += dy;\par if (y < 0) \{\par    y = 0;\par    dy = -dy;\par    \}\par else if (y >= PADDLEY) \{\par    if ((x < paddlePosition) || (x > paddlePosition+PADDLEWIDTH))\par       GetANewBall(&oldBall);\par    else \{\par       px = x-paddlePosition;\par       if (px < AREA1)\par          dx = -HARD;\par       else if (px < AREA2)\par          dx = -EASY;\par       else if (px < AREA3)\par          dx = 0;\par       else if (px < AREA4)\par          dx = EASY;\par       else\par          dx = HARD;\par       dy = -dy;\par       y = PADDLEY;\par       \}\par    \}\par newBall.h1 = x-BALLDX;                  /* form the new ball rectangle */\par newBall.h2 = newBall.h1+BALLWIDTH;\par newBall.v1 = y-BALLDY;\par newBall.v2 = newBall.v1+BALLHEIGHT;\par PaintRect(&newBall);                   /* draw the ball in the new spot */\par PaintRect(&oldBall);                    /* erase the old ball */\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {int WhichButton (void)\par \par /* See which button the mouse is in                             */\par /*                                                              */\par /* Variables:                                                   */\par /*    myevent.where - location of mouse at mouseup              */\par /*    myevent.what - kind of event                              */\par \par \{\par int result = 0;                         /* value to return */\par \par if (myevent.what == mouseUpEvt)\par    if (myevent.where.h >= LEFT)\par       if (myevent.where.h <= RIGHT)\par          if (myevent.where.v >= TOP1)\par             if (myevent.where.v <= BOTTOM2)\par                if (myevent.where.v <= BOTTOM1)\par                   result = 1;\par }\pard \s23\qj\fi360\widctlpar\adjustright {               else if (myevent.where.v >= TOP2)\par                   result = 2;\par return result;\par \}\par \par \par int PlayAGame (void)\par \par /* See if the player wants to play a game or quit.              */\par /*                                                              */\par /* Returns: True to play a game, else false.                    */\par \par \{\par Rect r;                                 /* rect inclosing the buttons */\par \par MoveTo(LEFT+10, BOTTOM1-2);             /* draw the messages */\par printf("Play a Game");\par MoveTo(LEFT+30,BOTTOM2-2);\par printf("Quit");\par SetSolidPenPat(14);                     /* draw the button outlines */\par SetPenMode(0);\par SetPenSize(3,1);\par MoveTo(LEFT,TOP1);\par LineTo(RIGHT,TOP1);\par LineTo(RIGHT,BOTTOM1);\par LineTo(LEFT,BOTTOM1);\par LineTo(LEFT,TOP1);\par MoveTo(LEFT,TOP2);\par LineTo(RIGHT,TOP2);\par LineTo(RIGHT,BOTTOM2);\par LineTo(LEFT,BOTTOM2);\par LineTo(LEFT,TOP2);\par ShowCursor();                           /* wait for a click in a button */\par do \{\par    GetNextEvent(EVENTMASK, &myevent);\par    GlobalToLocal(&myevent.where);\par    MovePaddle();\par    \}\par while (WhichButton() == 0);\par HideCursor();\par r.h1 = LEFT;                            /* erase the messages */\par r.h2 = RIGHT;\par r.v1 = TOP1;\par r.v2 = BOTTOM2;\par SetSolidPenPat(0);\par return WhichButton() == 1;              /* set the return value */\par \}\par \par \par void InitScreen (void)\par \par /* Draw the initial screen                                      */\par \par \{\par SetSolidPenPat(0);                     /* erase the old screen contents */\par SetPenMode(0);\par PaintRect(&screen);\par brickY = STARTHEIGHT;                 /* draw the initial set of bricks */\par DrawBricks();\par paddlePosition = 0;                     /* draw the initial paddle */\par DrawPaddle(0,PADDLECOLOR);\par balls = 3;                              /* give the player 3 balls */\par level = 1;                              /* play level = 1 */\par SetForeColor(11);                 /* draw the initial score, ball count */\par SetBackColor(0);\par MoveTo(0, LETTERY);\par printf("Score:");\par MoveTo(240, LETTERY);\par printf("Balls:");\par score = 0;\par WriteScore();\par WriteBalls();\par \}\par \par \par }\pard \s23\qj\fi360\keepn\widctlpar\adjustright {void main (void)\par \par /* Main program                                                 */\par \par \{\par int time;                               /* timer */\par \par }\pard \s23\qj\fi360\widctlpar\adjustright {StartTools();                           /* start the tools */\par InitCursor();                           /* set up the cursor */\par HideCursor();\par GetPortRect(&screen);                   /* set the limit on the paddle */\par maxX = screen.h2;\par InitScreen();                         /* give them something to look at */\par \par while (PlayAGame()) \{\par    InitScreen();                        /* set up the screen */\par    StartBall();                         /* start a ball */\par    do \{                                 /* event loop */\par       GetNextEvent(EVENTMASK, &myevent);\par       time = myevent.when - lastWhen;\par       if (time > PAUSE) \{\par          MoveBall();\par          CheckBricks();\par          lastWhen += PAUSE;\par          \}\par       MovePaddle();\par       \}\par    while (balls);\par    DrawBall();                          /* erase the last ball */\par    \}\par \par ShutDownTools();                        /* shut down the tools */\par \}\par }\pard\plain \widctlpar\adjustright \f4\cgrid {\par \par \par \par \par \par \par }}