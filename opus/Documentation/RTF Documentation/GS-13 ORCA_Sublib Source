{\rtf1\mac\ansicpg10000\uc1 \deff0\deflang1033\deflangfe1033{\upr{\fonttbl{\f0\fnil\fcharset256\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f4\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Times;}{\f6\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Courier;}{\f7\fnil\fcharset256\fprq2{\*\panose 020b0503030404040204}Geneva;}{\f12\froman\fcharset77\fprq2{\*\panose 02020502060305060204}New York;}}{\*\ud{\fonttbl{\f0\fnil\fcharset256\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f4\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Times;}{\f6\fnil\fcharset256\fprq2{\*\panose 02000500000000000000}Courier;}{\f7\fnil\fcharset256\fprq2{\*\panose 020b0503030404040204}Geneva;}{\f12\froman\fcharset77\fprq2{\*\panose 02020502060305060204}New York;}}}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\widctlpar\adjustright \f4\cgrid \snext0 Normal;}{\*\cs10 \additive Default Paragraph Font;}{\s15\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \f4\cgrid \sbasedon0 \snext15 footer;}{\s16\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \f4\cgrid \sbasedon0 \snext16 header;}{\*\cs17 \additive \sbasedon10 page number;}{\s18\qj\li720\widctlpar\tx1620\tx2250\tx4320\adjustright \f6\fs18\cgrid \sbasedon0 \snext18 code;}}{\info{\title Subroutine Library}{\author Mike Westerfield}{\operator Mike Westerfield}{\creatim\yr2000\mo10\dy5\hr21\min24}{\revtim\yr2000\mo10\dy5\hr21\min24}{\printim\yr2000\mo10\dy5\hr21\min23}{\version2}{\edmins0}{\nofpages14}{\nofwords3435}{\nofchars19585}{\*\company Byte Works, Inc.}{\nofcharsws24051}{\vern99}}\margl1440\margr1440\margt1800\margb1800\gutter360 \facingp\widowctrl\ftnbj\aenddoc\ftnrstpg\hyphhotz0\sprstsp\otblrul\brkfrm\sprstsm\truncex\nolead\msmcap\lytprtmet\hyphcaps0\viewkind1\viewscale100 \fet0\sectd \sbkodd\pgnrestart\linex0\colsx0\endnhere\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \qc\widctlpar\adjustright \f4\cgrid {\b\fs72 Subroutine Library\par Source Code\par }{\b\fs28 \par Version 2.0.1\par \par For ORCA/M 2.0, ORCA/Pascal 1.4.2, ORCA/C 2.0\par Apple II}{\b GS}{\b\fs28  Versions\par }{\b \par }{\f7\fs72 {\pict{\*\picprop\shplid1025{\sp{\sn shapeType}{\sv 75}}{\sp{\sn fFlipH}{\sv 0}}{\sp{\sn fFlipV}{\sv 0}}{\sp{\sn fillColor}{\sv 268435473}}{\sp{\sn fFilled}{\sv 0}}{\sp{\sn fLine}{\sv 0}}}\picscalex85\picscaley91\piccropl0\piccropr0\piccropt0\piccropb0\picw360\pich219\picwgoal7200\pichgoal4380\macpict\bliptag-1555728666\blipupi72{\*\blipuid a34576e68d883ab644b5068fc7c732b9}002900400037011b019f110101000a001d0008011b01e90800090b000a000a4000400037011b019fff}}{\b \par \par }{\b\fs28 By Mike Westerfield\par and Barbara Allred\par \par Copyright 1987, 1988, 1990-1993\par Byte Works}{\b\fs14\up14 \u174\'a8}{\b\fs28 , Inc.\par }\pard \qj\widctlpar\adjustright {\f12\fs20 \sect }\sectd \sbkodd\pgnrestart\linex0\colsx0\endnhere\sectdefaultcl \pard\plain \qj\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \qj\li720\ri720\widctlpar\adjustright {\fs18 Limited Warranty - Subject to the below stated limitations, Byte Works, Inc., hereby warrants that the programs contained in this unit will load and run on the standard manufacturer's configuration for the computer listed for a period of ninety (90) days from date of purchase.  Except for such warranty, this product is supplied on an "as is" basis without warranty as to merchantability or its fitness for any particular purpose.  The limits of warranty extend only to the original purchaser.\par \par Neither Byte Works, Inc., nor the authors of this program are liable or responsible to the purchaser and/or user for loss or damage caused, or alleged to be caused, directly or indirectly by this software and its attendant documentation, including (but not limited to) interruption of service, loss of business, or anticipatory profits.\par \par To obtain the warranty offered, the enclosed purchaser registration card must be completed and returned to the Byte Works, Inc., within ten (10) days of purchase.\par \par Important Notice - This is a fully copyrighted work and as such is protected under copyright laws of the United States of America.  According to these laws, consumers of copywritten material may make copies for their personal use only.  Duplication for any purpose whatsoever would constitute infringement of copyright laws and the offender would be liable to civil damages of up to $50,000 in addition to actual damages, plus criminal penalties of up to one year imprisonment and/or a $10,000 file.\par \par This product is sold for use on a single computer at at a single location.  Contact the publisher for information regarding licensing for use at multiple-work station or multiple-computer installations.\par \par Source code for all subroutine libraries, macros, and programs included in this package are copyrighted and may not be duplicated or redistributed under any circumstances without prior written permission of the publisher.\par \par Use of Libraries - The enclosed subroutine libraries are fully copyrighted works.  It is the policy of Byte Works, Inc., to license these libraries to purchasers of ORCA/M free of charge.  Such licenses are generally restricted to include the libraries of binary files, and do not extend to use of the source code.  A copy of the program, along with any documentation, and a list of the library subroutines used is required at the time of the licensing, and the document must give credit for using libraries from ORCA/M.  For details, please contact the Byte Works, Inc.\par \par ORCA/M, ORCA/Pascal and ORCA/C are trademarks of the Byte Works, Inc.\par Byte Works is a registered trademark of the Byte Works, Inc.\par Apple is a registered trademark of Apple Computer, Inc.\par \par Program, Documentation and Design\par Copyright 1987-1993\par The Byte Works, Inc.\par }\pard \qj\widctlpar\adjustright {\f12\fs20 \sect }\sectd \sbkodd\pgnrestart\linex0\colsx0\endnhere\titlepg\sectdefaultcl {\headerl \pard\plain \s16\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \f4\cgrid {Chapter 1:  Introduction\par }}{\headerr \pard\plain \s16\qr\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \f4\cgrid {Subroutine Libraries\par }}{\footerl \pard\plain \s15\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \f4\cgrid {\field{\*\fldinst { PAGE  }}{\fldrslt {\lang1024 2}}}{\par }}{\footerr \pard\plain \s15\qr\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \f4\cgrid {\field{\*\fldinst { PAGE  }}{\fldrslt {\lang1024 0}}}{\par }}{\headerf \pard\plain \s16\qr\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \f4\cgrid {\par }}\pard\plain \widctlpar\adjustright \f4\cgrid {\b\fs36 Chapter 1 \endash  Introduction\par }\pard \qj\widctlpar\adjustright {\fs20 \par }\pard \qj\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs28 Overview\par }\pard \qj\widctlpar\adjustright {\fs20 \par }\pard \qj\fi360\widctlpar\adjustright {\fs20 The ORCA Subroutine Libraries 2.0.1 is the source code for a collection of assembly-language subroutines which are used by the ORCA/M system macros and as run-time subroutines by ORCA/Pascal and ORCA/C.  You are probably most familiar with these libraries as the ORCALIB, SYSLIB, SYSFLOAT and PASLIB files, located in the library prefix.\par The reason for releasing this source code is partly due to our perceptions of what you need, and partly tradition.  The source code for the subroutine libraries has always been available for ORCA languages; we consider it to be essential to the writing of efficient programs.  To use the subroutine libraries with confidence, it is sometimes necessary to see exactly how they work.  Then, too, bugs are not unheard of.  If you have the source code to the libraries, it is easier for you to be sure that the bug is not in the libraries, or if it is, to track the bug down.  Finally, it may be necessary to write a program for use on another computer, or in an environment other than ORCA.  The libraries are optimized for the text environment of the Apple II}{\fs18 GS}{\fs20  computer, and do not always work in other environments, or on other computers, or in ROM.  With the source code, you can make the necessary modifications.\par We felt that a concrete example of modifying a library subroutine would help you understand how libraries function in the ORCA environment.  Chapter Two gives such an example.\par The remainder of this chapter explains, in a general way, what is on the disk.  All of the programs are thoroughly documented with internal comments, so the internal workings of the code is not elaborated on here.  \par The libraries can be reassembled using ORCA/M 2.0.  The end product is five files: SYSLIB, used with ORCA/M, ORCA/Pascal and ORCA/C, contains the basic I/O subroutines and utility subroutines used across two or more of the languages.  PASLIB, used with ORCA/Pascal, contains the subroutines used only in ORCA/Pascal.  ORCALIB, used with ORCA/C, contains the subroutines used in ORCA/C.  There are two versions of the SYSFLOAT library, which is called by ORCA/Pascal and ORCA/C programs for all calculations and libraries that involve floating-point calculations.  The first of these versions of SYSFLOAT calls Apple's SANE tool set to perform floating-point calculations, while the second makes some direct calls to the Innovative Systems Floating Point Engine (FPE) and some calls to SANE.\par Should you wish to use any of the subroutines or portions of code from this package in a commercial program, please contact us.  Due to the structure of the copyright laws, we must require that all such uses be licensed.  Licensing is free of charge; we simply ask that the source of the routines be acknowledged.  We have not had any reason to refuse to grant a license to date.\par }\pard \qj\widctlpar\adjustright {\fs20 \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw15 \adjustright {\b What You Should Have Received\par }\pard \qj\keepn\widctlpar\adjustright {\fs20 \par }\pard \qj\fi360\widctlpar\adjustright {\fs20 The Subroutine Libraries package includes this manual and two 3.5" disks.  The first disk is labeled "ORCALIB, PASLIB" and contains the source code for the ORCA/C library ORCALIB and the ORCA/Pascal library PASLIB.  The source code for ORCALIB is located in a folder called ORCALIB, which is itself in a folder called SOURCE.  Likewise, the source code for PASLIB is located in a folder called PASLIB.  The second disk is labeled "SYSFLOAT, SYSFPEFLOAT, SYSLIB" and contains two directories, named SOURCE and EXAMPLES.  The SOURCE subdirectory has three subdirectories: SYSLIB has the source code for the SYSLIB library, SYSFLOAT has the source code for the SANE version of the SYSFLOAT library, and SYSFPEFLOAT has the source code for the FPE version of the SYSFLOAT library.\par The EXAMPLES subdirectory contains several source files that will be used in an example in Chapter Two.  These programs will be explained in Chapter Two.\par }\pard \qj\widctlpar\adjustright {\fs20 \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b Rebuilding the Libraries\par }\pard \qj\keepn\widctlpar\adjustright {\fs20 \par }\pard \qj\fi360\widctlpar\adjustright {\fs20 Each of the folders containing source code for one of the libraries has a script file called MAKE.  You can rebuild any of the libraries by setting the current directory to the appropriate folder and typing MAKE from the text shell or the shell window of the PRIZM desktop development environment.   For example, to rebuild ORCALIB, you would use the commands\par \par }{\f6\fs14 prefix /lib.source1/source/orcalib\par make\par }{\fs20 \par Of course, you should only do this with a copy of the distribution disks, never with the original!\par }\pard \qj\widctlpar\adjustright {\f12\fs20 \sect }\sectd \sbkodd\linex0\colsx0\endnhere\titlepg\sectdefaultcl {\headerl \pard\plain \s16\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \f4\cgrid {Chapter 2:  Modifying the Libraries\par }}{\headerr \pard\plain \s16\qr\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \f4\cgrid {Subroutine Libraries\par }}{\footerl \pard\plain \s15\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \f4\cgrid {\field{\*\fldinst { PAGE  }}{\fldrslt {\lang1024 10}}}{\par }}{\footerr \pard\plain \s15\qr\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \f4\cgrid {\field{\*\fldinst { PAGE  }}{\fldrslt {\lang1024 9}}}{\par }}{\headerf \pard\plain \s16\qr\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \f4\cgrid {\par }}\pard\plain \widctlpar\adjustright \f4\cgrid {\b\fs36 Chapter 2 \endash  Modifying the Libraries\par }\pard \qj\widctlpar\adjustright {\fs20 \par }\pard \qj\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs28 Naming Conventions\par }\pard \qj\widctlpar\adjustright {\fs20 \par }\pard \qj\fi360\widctlpar\adjustright {\fs20 The library subroutine names begin with the tilde (~) character.  Names that begin with the ~ character are reserved for system use.  This convention prevents naming conflicts between the libraries and your program.  If you look at the GET4 macro, contained in the file M16.I.O in the ORCA MACROS prefix, you will see the instruction\par }\pard \qj\widctlpar\adjustright {\fs20 \par }\pard \qj\fi720\widctlpar\adjustright {\f6\fs18          JSL   ~GET4\par }\pard \qj\widctlpar\adjustright {\fs20 \par ~GET4 is the library subroutine which receives a four-byte integer from standard input and places the value on the stack.  It is a segment contained in the library source file named IO.ASM.  The GET4 macro then calls another macro, named PL4, which removes the value from the stack and places it in the location specified when invoking the GET4 macro.  Note that macros which are "helpers" for a main macro also begin with the tilde character.\par \par }\pard \qj\keepn\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs28 An Example:  Modifying MUL2\par }\pard \qj\keepn\widctlpar\adjustright {\fs20 \par }\pard \qj\fi360\widctlpar\adjustright {\fs20 The following example demonstrates how to modify the subroutine libraries.   Listed below is the macro MUL2, which performs a signed multiplication of the first two parameters.  The result is stored at the location given by the third parameter if it is coded; otherwise, it is stored at the location specified by the first parameter.  MUL2 is located in the file M16.INT2MATH, in the ORCA MACROS folder.\par }\pard \qj\widctlpar\adjustright {\fs20 \par }\pard \li720\widctlpar\adjustright {\f6\fs14          MACRO\par &LAB     MUL2  &N1,&N2,&N3\par          AIF   C:&N3,.A\par          LCLC  &N3\par &N3      SETC  &N1\par .A\par &LAB     ~SETM\par          LCLC  &C\par &C       AMID  "&N2",1,1\par          AIF   "\{"="&C",.B\par          AIF   "["="&C",.B\par          ~OP   LDX,&N2\par          AGO   .C\par .B\par          ~LDA  &N2\par          TAX\par .C\par          ~LDA  &N1\par          JSL   ~MUL2\par          ~STA  &N3\par          ~RESTM\par          MEND\par }\pard \qj\widctlpar\adjustright {\fs20 \par }\pard \qj\fi360\widctlpar\adjustright {\fs20 Note that the macros ~SETM, ~RESTM, ~OP, ~LDA, and ~STA are all special-purpose macros which are located at the end of the M16.INT2MATH file.\par As you may know, signed arithmetic operations take longer than unsigned operations because of the sign manipulation involved.  Suppose that you'd like to have an unsigned two-byte multiplication routine.  You could obtain one very quickly by making some modifications to the multiply routine contained in the subroutine libraries.  The segment named ~MUL2 in the library file I2.ASM performs the signed multiply; it is given below:\par }\pard \qj\widctlpar\adjustright {\fs20 \par }\pard \fi720\keepn\widctlpar\adjustright {\f6\fs14 ****************************************************************\par *\par *  ~MUL2 - Two Byte Signed Integer Multiply\par *\par *  Inputs:\par *        A - multiplicand\par *        X - multiplier\par *\par *  Outputs:\par *        A - result\par *        V - set if an overflow occurred\par }\pard \fi720\widctlpar\adjustright {\f6\fs14 *\par *  Notes:\par *        1) Assumes long A and X on entry.\par *\par ****************************************************************\par *\par ~MUL2    START\par          LONGA ON\par          LONGI ON\par NUM1     EQU   0\par NUM2     EQU   4\par SIGN     EQU   6\par \par          TAY                            save value\par          PHD                            set up local space\par          TSC\par          SEC\par          SBC   #7\par          TCD\par          DEC   A\par          TCS\par          TYA                            restore value\par          LDY   #0                       make all arguments positive\par          BIT   #$8000                    start with A\par          BEQ   ML1\par          EOR   #$FFFF\par          INC   A\par          INY\par ML1      STA   NUM1+2\par          TXA                            now do X\par          BPL   ML2\par          DEY\par          EOR   #$FFFF\par          INC   A\par ML2      STA   NUM2\par          STY   SIGN\par \par          LDY   #16                      do 16 bit multiply\par          LDA   #0                       set up the high byte of the result\par ML3      LSR   NUM1+2                   test the LSB\par          BCC   ML4                      br if it is off\par          CLC                            add in partial product\par          ADC   NUM2\par ML4      ROR   A                        multiply answer by 2\par          ROR   NUM1\par          DEY                            loop\par          BNE   ML3\par          TAX                            check for overflow\par          BNE   OVFL\par          LDA   NUM1\par          BMI   OVFL\par \par          LDY   SIGN                     if result is to be neg, reverse sign\par          BEQ   ML5\par          EOR   #$FFFF\par          INC   A\par ML5      TAY                            restore stack, DP\par          TDC\par          CLC\par          ADC   #7\par          TCS\par          PLA\par          TCD\par          TYA\par          CLV\par          RTL\par \par OVFL     TDC                            restore stack, DP\par          CLC\par          ADC   #7\par          TCS\par          PLA\par          TCD\par          SEP   #%01000000               SEV\par          RTL\par          END\par }\pard \qj\widctlpar\adjustright {\fs20 \par }\pard \qj\fi360\widctlpar\adjustright {\fs20 To modify ~MUL2 so that it performs unsigned arithmetic, all that is necessary is to remove the portions of the code that deal with the sign.  Since the amount of work space decreased, some changes to the set up code and exit code have also been made.  The required changes are shown in boldface.  Assuming that we'd like to retain our original ~MUL2, we could edit a copy ~MUL2 and use the new one in programs which perform unsigned multiplication.  If ~MUL2 appears in our program, the linker will not include the ~MUL2 from the SYSLIB library.  The sample program below tests our new ~MUL2:\par }\pard \qj\widctlpar\adjustright {\fs20 \par }\pard \qj\li720\widctlpar\tx1620\tx2250\tx4320\adjustright {\f6\fs14 \tab KEEP\tab STUFF\par }\pard\plain \s18\qj\li720\widctlpar\tx1620\tx2250\tx4320\adjustright \f6\fs18\cgrid {\fs14 \tab MCOPY T.MAC\par }\pard\plain \qj\li720\widctlpar\tx1620\tx2250\tx4320\adjustright \f4\cgrid {\f6\fs14 ****************************************************************\par *\par *  TEST - Simple program to test if modified multiply routine\par *         works.\par *\par ****************************************************************\par *\par T\tab START\par \tab PHK\tab Program & data in same bank\par \tab PLB\par \tab MUL2\tab #3,#4,ANS\tab Multiply 3 by 4; store in ANS\par \tab PUTS\tab #'ANS: '\tab Echo multiply result\par \tab PUT2\tab ANS,CR=T\par \tab LDA\tab #0\par \tab RTL\par \par ANS\tab DS\tab 2\par \tab END\par \par ****************************************************************\par *\par *  ~MUL2 - Two-Byte Unsigned Integer Multiply\par *\par *  Inputs:\par *        A - multiplicand\par *        X - multiplier\par *\par *  Outputs:\par *        A - result\par *        V - set if an overflow occurred\par *\par *  Notes:\par *        1) Assumes long A and X on entry.\par *\par ****************************************************************\par *\par ~MUL2\tab START\par \tab LONGA\tab ON\par \tab LONGI\tab ON\par NUM1\tab EQU\tab 1\par NUM2\tab EQU\tab 5\par \par }\pard \li720\widctlpar\tx1620\tx2250\tx4320\adjustright {\b\f6\fs14 \tab PHD\tab \tab set up local data area on the \par }\pard \qj\li720\widctlpar\tx1620\tx2250\tx4320\adjustright {\b\f6\fs14 \tab PHA\tab \tab  stack\par \tab PHX\par \tab PHX\par \tab TSC\par \tab TCD\par }{\f6\fs14 \par \tab LDY\tab #16\tab do 16 bit multiply\par \tab LDA\tab #0\tab set up the high byte of the result\par ML3\tab LSR\tab NUM1+2\tab test the LSB\par \tab BCC\tab ML4\tab br if it is off\par \tab CLC\tab \tab add in partial product\par \tab ADC\tab NUM2\par ML4\tab ROR\tab A\tab multiply answer by 2\par \tab ROR\tab NUM1\par \tab DEY\tab \tab loop\par \tab BNE\tab ML3\par \tab TAX\tab \tab check for overflow\par \tab BNE\tab OVFL\par \tab LDA\tab NUM1\par \tab BMI\tab OVFL\par \par }{\b\f6\fs14 ML5\tab PLY\tab \tab restore stack, DP\par \tab PLY\par \tab PLY\par \tab PLD\par \tab CLV\par \tab RTL\par \par }\pard \qj\li720\keepn\widctlpar\tx1620\tx2250\tx4320\adjustright {\b\f6\fs14 OVFL\tab PLY\tab \tab restore stack, DP\par }\pard \qj\li720\widctlpar\tx1620\tx2250\tx4320\adjustright {\b\f6\fs14 \tab PLY\par \tab PLY\par \tab PLD\par \tab SEP\tab \tab #%01000000               \par \tab RTL\par \tab END\par }\pard \qj\widctlpar\adjustright {\fs20 \par }\pard \qc\widctlpar\adjustright {\b\fs20 File T From EXAMPLES Folder\par }\pard \qj\widctlpar\adjustright {\fs20 \par }\pard \qj\fi360\widctlpar\adjustright {\fs20 To see how much faster unsigned multiplications really are, let's run some benchmarks.  The three programs below all run the same test.  The test performs ten different multiplications, and these ten operations are repeated 10,000 times.  The first test uses our modified ~MUL2.  The second test is exactly the same as the first, except that it uses the library's version of ~MUL2.  The final test calls the integer math toolkit.  The call to the toolkit would generally be put into a macro, but we have included it here to help you understand how a call to the toolkit works.  The EXAMPLES subdirectory also contains the file named TEST.MACROS, which includes the macros used in the three benchmark programs.  It is included so that you can run the tests yourself, without having to use the MACGEN utility to build the macro file first. \par }\pard \qj\widctlpar\adjustright {\fs20 \par }\pard \fi720\widctlpar\adjustright {\f6\fs14          KEEP  UNSIGNED\par          MCOPY TEST.MACROS\par ****************************************************************\par *\par *  This benchmark performs 10 multiplications, saving the result\par *  of each.  The multiplications are repeated 1000 times.  The\par *  UNMUL2 macro calls the routine ~UNMUL2, the unsigned version of\par *  the library segment ~MUL2.\par *\par *  Written by Barbara Allred and Mike Westerfield\par *\par *  By The Byte Works Inc.\par *  Copyright (c) 1986\par *  All rights reserved.\par *\par ****************************************************************\par *\par TEST     START\par          PHK                            Program & data in same bank\par          PLB\par \par          PUTS  #'Start the clock',CR=T\par          LDA   #10000\par          STA   COUNT\par \par TOP1     LDX   #10\par          LDY   #0\par \par TOP2     PHX                            save X and Y registers\par          PHY\par \par          LDA   M1,Y\par          STA   ADDR1\par          LDA   M2,Y\par          STA   ADDR2\par \par          UNMUL2  ADDR1,ADDR2,TEMP       multiply next pair\par \par          PLY                            restore X and Y registers\par          PLX\par          LDA   TEMP                     save result of multiply\par          STA   RES,Y\par \par          INY                            update table index\par          INY\par          DBNE  X,TOP2\par \par          DBNE  COUNT,TOP1               repeat inner loop 1000 times\par          PUTS  #'Stop the clock',CR=T\par \par          LDX   #18                      check results\par TOP3     LDA   RES,X\par          CMP   ANS,X\par          BNE   ERROR\par          DEX\par          DBPL  X,TOP3\par          LDA   #0\par          RTL\par \par }\pard \fi720\keepn\widctlpar\adjustright {\f6\fs14 ERROR    PUTS  #'Error in multiply routine',CR=T\par          LDA   #$FFFF\par }\pard \fi720\widctlpar\adjustright {\f6\fs14          RTL\par \par ADDR1    DS    2\par ADDR2    DS    2\par TEMP     DS    2\par COUNT    DS    2\par RES      DS    20\par M1       DC    I2'0,11,22,33,44,55,66,77,88,99'\par M2       DC    I2'5,76,34,123,654,41,92,18,12,99'\par ANS      DC    I2'0,836,748,4059,28776,2255,6072,1386,1056,9801'\par          END\par \par ****************************************************************\par *\par *  ~UNMUL2 - Two-Byte Unsigned Integer Multiply\par *\par *  Inputs:\par *        A - multiplicand\par *        X - multiplier\par *\par *  Outputs:\par *        A - result\par *        V - set if an overflow occurred\par *\par *  Notes:\par *        1) Assumes long A and X on entry.\par *\par ****************************************************************\par *\par ~UNMUL2  START\par          LONGA ON\par          LONGI ON\par NUM1     EQU   1\par NUM2     EQU   5\par \par          PHD                            set up local data area on the stack\par          PHA\par          PHX\par          PHX\par          TSC\par          TCD\par \par          LDY   #16                      do 16 bit multiply\par          LDA   #0                       set up the high byte of the result\par ML3      LSR   NUM1+2                   test the LSB\par          BCC   ML4                      br if it is off\par          CLC                            add in partial product\par          ADC   NUM2\par ML4      ROR   A                        multiply answer by 2\par          ROR   NUM1\par          DEY                            loop\par          BNE   ML3\par          TAX                            check for overflow\par          BNE   OVFL\par          LDA   NUM1\par          BMI   OVFL\par \par ML5      PLY                            restore stack, DP\par          PLY\par          PLY\par          PLD\par          CLV\par          RTL\par \par OVFL     PLY                            restore stack, DP\par          PLY\par          PLY\par          PLD\par          SEP   #%01000000               SEV\par          RTL\par          END\par }{\f6\fs18 \par }\pard \qc\widctlpar\adjustright {\b\fs20 File UNTEST From EXAMPLES Folder\par \par }\pard \fi720\keepn\widctlpar\adjustright {\f6\fs14          KEEP  SIGNED\par          MCOPY TEST.MACROS\par ****************************************************************\par *\par *  This benchmark performs 10 multiplications, saving the result\par *  of each.  The multiplications are repeated 1000 times.  The\par *  MUL2 macro calls the library routine ~MUL2.\par *\par *  Written by Barbara Allred and Mike Westerfield\par }\pard \fi720\widctlpar\adjustright {\f6\fs14 *\par *  By The Byte Works Inc.\par *  Copyright (c) 1986\par *  All rights reserved.\par *\par ****************************************************************\par *\par T        START\par          PHK                            Program & data in same bank\par          PLB\par \par          PUTS  #'Start the clock',CR=T\par          LDA   #10000\par          STA   COUNT\par \par TOP1     LDX   #10\par          LDY   #0\par \par TOP2     PHX                            save X and Y registers\par          PHY\par \par          LDA   M1,Y\par          STA   ADDR1\par          LDA   M2,Y\par          STA   ADDR2\par \par          MUL2  ADDR1,ADDR2,TEMP         multiply next pair\par \par          PLY                            restore X and Y registers\par          PLX\par          LDA   TEMP                     save result of multiply\par          STA   RES,Y\par \par          INY                            update table index\par          INY\par          DBNE  X,TOP2\par \par          DBNE  COUNT,TOP1               repeat inner loop 1000 times\par          PUTS  #'Stop the clock',CR=T\par \par }\pard \fi720\keepn\widctlpar\adjustright {\f6\fs14          LDX   #18                      check results\par }\pard \fi720\widctlpar\adjustright {\f6\fs14 TOP3     LDA   RES,X\par          CMP   ANS,X\par          BNE   ERROR\par          DEX\par          DBPL  X,TOP3\par          LDA     #0\par          RTL\par \par ERROR    PUTS  #'Error in multiply routine',CR=T\par          LDA   #$FFFF\par          RTL\par \par ADDR1    DS    2\par ADDR2    DS    2\par TEMP     DS    2\par COUNT    DS    2\par RES      DS    20\par M1       DC    I2'0,11,22,33,44,55,66,77,88,99'\par M2       DC    I2'5,76,34,123,654,41,92,18,12,99'\par ANS      DC    I2'0,836,748,4059,28776,2255,6072,1386,1056,9801'\par          END\par }\pard \qc\widctlpar\adjustright {\b\fs20 \par File LIB.TEST From EXAMPLES Folder\par \par }\pard \fi720\keepn\widctlpar\adjustright {\f6\fs14          KEEP  TOOLKIT\par          MCOPY TEST.MACROS\par ****************************************************************\par *\par *  This benchmark program performs 10 multiplications, saving\par *  the result of each.  The 10 multiplications are repeated\par *  1000 times.  The multiplication is performed using the integer\par *  math toolkit.\par *\par *  Written by Barbara Allred and Mike Westerfield\par *\par }\pard \fi720\widctlpar\adjustright {\f6\fs14 *  By The Byte Works Inc.\par *  Copyright (c) 1986\par *  All rights reserved.\par *\par ****************************************************************\par *\par T        START\par          PHK\par          PLB\par \par          PUTS  #'Start the clock',CR=T\par          LDA   #10000\par          STA   COUNT\par \par TOP1     LDY   #0\par          LDX   #10\par \par TOP2     PHY                            save Y and X registers\par          PHX\par \par          PHA                            push room for output\par          PHA\par          LDA   M1,Y                     push first value\par          PHA\par          LDA   M2,Y                     push second value\par          PHA\par \par          LDX   #$090B                   call multiply tool\par          JSL   $E10000\par  \par          PLA                            pull 32-bit result from stack\par          STA   TEMP\par          PLA\par          STA   TEMP+2\par \par          PLX                            restore X and Y registers\par          PLY\par \par }\pard \fi720\keepn\widctlpar\adjustright {\f6\fs14          LDA   TEMP\par }\pard \fi720\widctlpar\adjustright {\f6\fs14          STA   RES,Y\par \par          INY                            get next pair to multiply\par          INY\par          DBNE  X,TOP2\par \par          DBNE  COUNT,TOP1               repeat inner loop 1000 times\par \par          PUTS  #'Stop the clock',CR=T\par \par          LDX   #18                      check results\par TOP3     LDA   RES,X\par          CMP   ANS,X\par          BNE   ERROR\par          DEX\par          DBPL  X,TOP3\par          LDA     #0\par          RTL\par \par ERROR    PUTS  #'Error in multiply routine',CR=T\par          LDA   #$FFFF\par          RTL\par \par TEMP     DS    4\par COUNT    DS    2\par RES      DS    20\par M1       DC    I2'0,11,22,33,44,55,66,77,88,99'\par M2       DC    I2'5,76,34,123,654,41,92,18,12,99'\par ANS      DC    I2'0,836,748,4059,28776,2255,6072,1386,1056,9801'\par          END\par }\pard \qc\widctlpar\adjustright {\b\fs20 \par File TOOL.TEST From EXAMPLES Folder\par }\pard \qj\widctlpar\adjustright {\fs20 \par }\pard \qj\fi360\keepn\widctlpar\adjustright {\fs20 The benchmark times we obtained, in seconds, using a standard Apple II}{\fs18 GS}{\fs20  computer, were:\par }\pard \qj\widctlpar\adjustright {\fs20 \par }\pard \qj\li720\ri720\widctlpar\brdrt\brdrs\brdrw15 \brdrb\brdrs\brdrw15 \tx3600\tx5040\tx6480\adjustright {\fs20 \tab Raw\tab Corrected\tab Per Multiply\par }\pard \qj\li720\ri720\widctlpar\tx3600\tx5040\tx6480\adjustright {\fs20 Loop itself, no multiplies:\tab 2.9\tab 0\tab 0\par Library Multiply:\tab 24.4\tab 21.5\tab 215 microseconds\par Unsigned Multiply:\tab 22.7\tab 19.8\tab 198 microseconds\par Toolkit Multiply:\tab 31.8\tab 28.9\tab 289 microseconds\par }\pard \qj\widctlpar\adjustright {\fs20 \par \par }\pard \qj\fi360\widctlpar\adjustright {\fs20 "Raw" is the time between the messages "Start the clock" and "Stop the clock."  "Corrected" are the execution times minus the loop overhead.  "Per multiply" are the average times for individual multiplications.\par }\pard \qj\widctlpar\adjustright {\fs20 \par }\pard \qj\widctlpar\brdrt\brdrs\brdrw30 \adjustright {\b\fs28 Adding Library Routines\par }\pard \qj\widctlpar\adjustright {\fs20 \par }\pard \qj\fi360\widctlpar\adjustright {\fs20 Suppose we'd like to add our new ~MUL2 to the system library.  First of all, let's rename it so that we may distinguish it from SYSLIB's original ~MUL2.   Let's call it ~UNSMUL2, for unsigned two-byte multiplication.  We can place our ~UNSMUL2 in the library file I2.ASM after ~MUL2 by using the copy and paste commands provided with the ORCA editor.  To rebuild the library, execute the MAKE script, then copy the new SYSLIB library file to your LIBARIES folder, replacing the old SYSLIB.\par One last detail needs to be addressed before we are done.  How are we going to access ~UNSMUL2?  The easiest way to do this is to modify our MUL2 macro.  All we need to do is to rename the macro, change the segment name for the JSL instruction within the macro, and store the new macro in the ORCA MACROS prefix.  Let's call the new macro UNSMUL2.  The new macro is given below:\par }\pard \qj\widctlpar\adjustright {\fs20 \par }\pard\plain \s18\qj\li720\keepn\widctlpar\tx1620\tx2250\tx4320\adjustright \f6\fs18\cgrid {\fs14 \tab MACRO\par &LAB\tab }{\b\fs14 UNSMUL2}{\fs14  &N1,&N2,&N3\par \tab AIF\tab C:&N3,.A\par \tab LCLC\tab &N3\par &N3\tab SETC\tab &N1\par .A\par &LAB\tab ~SETM\par \tab LCLC\tab &C\par &C\tab AMID\tab "&N2",1,1\par \tab AIF\tab "\{"="&C",.B\par \tab AIF\tab "["="&C",.B\par \tab ~OP\tab LDX,&N2\par \tab AGO\tab .C\par .B\par \tab ~LDA\tab &N2\par \tab TAX\par .C\par \tab ~LDA\tab &N1\par }{\b\fs14 \tab JSL\tab ~UNSMUL2\par }{\fs14 \tab ~STA\tab &N3\par \tab ~RESTM\par }\pard \s18\qj\li720\widctlpar\tx1620\tx2250\tx4320\adjustright {\fs14 \tab MEND\par }\pard\plain \qj\widctlpar\adjustright \f4\cgrid {\fs20 \par }\pard \qj\fi360\widctlpar\adjustright {\fs20 The changes are shown in boldface.  Using the editor, we can add our new macro after MUL2 in the file MACROS/M16.INT2MATH.  Now to use unsigned multiplication in a program, we can simply code something like:\par }\pard \qj\widctlpar\adjustright {\fs20 \par }\pard\plain \s18\qj\li720\widctlpar\tx1620\tx2250\tx4320\adjustright \f6\fs18\cgrid {\fs14 \tab UNSMUL2 NUM1,NUM2\par }\pard\plain \qj\widctlpar\adjustright \f4\cgrid {\fs20 \par }}